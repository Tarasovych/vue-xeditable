!function(Q){function F(B){if(t[B])return t[B].exports;var U=t[B]={i:B,l:!1,exports:{}};return Q[B].call(U.exports,U,U.exports,F),U.l=!0,U.exports}var t={};F.m=Q,F.c=t,F.i=function(Q){return Q},F.d=function(Q,t,B){F.o(Q,t)||Object.defineProperty(Q,t,{configurable:!1,enumerable:!0,get:B})},F.n=function(Q){var t=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return F.d(t,"a",t),t},F.o=function(Q,F){return Object.prototype.hasOwnProperty.call(Q,F)},F.p="/dist/",F(F.s=8)}([function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn "@media " + item[2] + "{" + content + "}";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join("");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === "string")\n\t\t\tmodules = [[null, modules, ""]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === "number")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || \'\';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === \'function\') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn \'/*# sourceURL=\' + cssMapping.sourceRoot + source + \' */\'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n\t}\n\n\treturn [content].join(\'\\n\');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = \'sourceMappingURL=data:application/json;charset=utf-8;base64,\' + base64;\n\n\treturn \'/*# \' + data + \' */\';\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzP2RhMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYzs7QUFFbEU7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === "undefined") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === "undefined") {\n\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t}\n\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(17);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== "undefined" && DEBUG) {\n\t\tif (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === "object" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = "head";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = "bottom";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error("Couldn\'t find a style target. This probably means that the value for the \'insertInto\' parameter is invalid.");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === "top") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === "bottom") {\n\t\ttarget.appendChild(style);\n\t} else {\n\t\tthrow new Error("Invalid value for parameter \'insertAt\'. Must be \'top\' or \'bottom\'.");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement("style");\n\n\toptions.attrs.type = "text/css";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement("link");\n\n\toptions.attrs.type = "text/css";\n\toptions.attrs.rel = "stylesheet";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don\'t add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === "function" &&\n\t\ttypeof URL.createObjectURL === "function" &&\n\t\ttypeof URL.revokeObjectURL === "function" &&\n\t\ttypeof Blob === "function" &&\n\t\ttypeof btoa === "function"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join(\'\\n\');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? "" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute("media", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn\'t defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\n\t}\n\n\tvar blob = new Blob([css], { type: "text/css" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzP2I3ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0EsbUJBQW1CLDJCQUEyQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTs7QUFFQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdG1lbW9bc2VsZWN0b3JdID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},function(module,exports,__webpack_require__){eval("var Component = __webpack_require__(18)(\n  /* script */\n  __webpack_require__(3),\n  /* template */\n  __webpack_require__(19),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRWRpdGFibGUudnVlP2EwZjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBb0g7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0VkaXRhYmxlLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNDA5YjQ4MTZcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vRWRpdGFibGUudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgbnVsbCxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9FZGl0YWJsZS52dWVcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editable_css_bootstrap_min_css__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editable_css_bootstrap_min_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__editable_css_bootstrap_min_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__editable_css_bootstrap_editable_css__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__editable_css_bootstrap_editable_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__editable_css_bootstrap_editable_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__editable_css_bootstrap_wysihtml5_css__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__editable_css_bootstrap_wysihtml5_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__editable_css_bootstrap_wysihtml5_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__editable_js_bootstrap_min_js__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__editable_js_bootstrap_min_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__editable_js_bootstrap_min_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__editable_js_bootstrap_editable_js__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__editable_js_bootstrap_editable_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__editable_js_bootstrap_editable_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__editable_js_wysihtml5_js__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__editable_js_wysihtml5_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__editable_js_wysihtml5_js__);\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  props: {\n    type: {\n      type: String,\n      default: 'text'\n    },\n    value: {\n      type: String,\n      default: ''\n    },\n    ajaxOptions: {\n      type: Object,\n      default: function _default() {\n        return {\n          type: 'put',\n          dataType: 'json'\n        };\n      }\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    emptytext: {\n      type: String,\n      default: '无'\n    },\n    placeholder: {\n      type: String,\n      default: ''\n    },\n    display: {\n      type: Boolean,\n      default: true\n    },\n    shown: {\n      type: Function,\n      default: function _default() {}\n    },\n    hidden: {\n      type: Function,\n      default: function _default() {}\n    },\n    option: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    }\n  },\n  watch: {\n    display: function display(value) {\n      var input_el = $(this.$el);\n      var action = value ? 'show' : 'hide';\n      input_el.editable(action);\n    }\n  },\n  data: function data() {},\n  created: function created() {},\n  mounted: function mounted() {\n    var self = this;\n    var el = $(this.$el);\n    if (el.data('editable')) el.editable().destroy();\n    var defaultOption = {\n      mode: 'inline',\n      onblur: 'submit',\n      showbuttons: false,\n      clear: false\n    };\n    var option = Object.assign(defaultOption, this.ajaxOptions, this.option);\n    el.editable(option).on('shown', function (e, editble) {\n      self.shown();\n    }).on('hidden', function (e, reason) {\n      self.hidden();\n    }).on('save', function (e, params) {\n      if (params.newValue == self.value) return;\n      self.handleChange(params.newValue);\n    });\n  },\n\n  methods: {\n    handleChange: function handleChange(value) {\n      var self = this;\n      this.value = value;\n      self.$emit('input', self.value);\n      self.$emit('change', self.value);\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vRWRpdGFibGUudnVlPzY3OTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7WUFJQTtlQUVBO0FBSEE7O1lBS0E7ZUFFQTtBQUhBOztZQUtBO21DQUNBOztnQkFFQTtvQkFFQTtBQUhBO0FBS0E7QUFSQTs7WUFVQTtlQUVBO0FBSEE7O1lBS0E7ZUFFQTtBQUhBOztZQUtBO2VBRUE7QUFIQTs7WUFLQTtlQUVBO0FBSEE7O1lBS0E7b0NBRUE7QUFIQTs7WUFLQTtvQ0FFQTtBQUhBOztZQUtBOzs7QUFHQTtBQUpBO0FBMUNBOztxQ0FnREE7NEJBQ0E7b0NBQ0E7d0JBQ0E7QUFFQTtBQU5BO3dCQVFBLENBQ0E7OEJBQ0EsQ0FDQTs4QkFDQTtlQUNBO29CQUNBOzJDQUNBOztZQUVBO2NBQ0E7bUJBQ0E7YUFFQTtBQUxBO3FFQU1BOzBEQUNBO1dBQ0E7eUNBQ0E7V0FDQTt1Q0FDQTt5Q0FDQTsrQkFDQTtBQUNBO0FBQ0E7OzsrQ0FFQTtpQkFDQTttQkFDQTsrQkFDQTtnQ0FDQTtBQUVBO0FBUEE7QUFoRkEiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgPGEgaHJlZj1cImphdmFzY3JpcHQ6O1wiXG4gICAgIDpkYXRhLXR5cGU9XCJ0eXBlXCJcbiAgICAgOmRpc2FibGVkPSdkaXNhYmxlZCdcbiAgICAgOmVtcHR5dGV4dD0nZW1wdHl0ZXh0Jz57e3ZhbHVlfX08L2E+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbiAgaW1wb3J0ICcuL2VkaXRhYmxlL2Nzcy9ib290c3RyYXAubWluLmNzcydcbiAgaW1wb3J0ICcuL2VkaXRhYmxlL2Nzcy9ib290c3RyYXAtZWRpdGFibGUuY3NzJ1xuICBpbXBvcnQgJy4vZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzJ1xuXG4gIGltcG9ydCAnLi9lZGl0YWJsZS9qcy9ib290c3RyYXAubWluLmpzJ1xuICBpbXBvcnQgJy4vZWRpdGFibGUvanMvYm9vdHN0cmFwLWVkaXRhYmxlLmpzJ1xuICBpbXBvcnQgJy4vZWRpdGFibGUvanMvd3lzaWh0bWw1LmpzJ1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczp7XG4gICAgICB0eXBlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3RleHQnXG4gICAgICB9LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSxcbiAgICAgIGFqYXhPcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdwdXQnLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZW1wdHl0ZXh0OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ+aXoCdcbiAgICAgIH0sXG4gICAgICBwbGFjZWhvbGRlcjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9LFxuICAgICAgZGlzcGxheToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9LFxuICAgICAgc2hvd246IHtcbiAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge31cbiAgICAgIH0sXG4gICAgICBoaWRkZW46IHtcbiAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge31cbiAgICAgIH0sXG4gICAgICBvcHRpb246IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHsgfSB9XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgZGlzcGxheTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGxldCBpbnB1dF9lbCA9ICQodGhpcy4kZWwpXG4gICAgICAgIGxldCBhY3Rpb24gPSB2YWx1ZSA/ICdzaG93JyA6ICdoaWRlJ1xuICAgICAgICBpbnB1dF9lbC5lZGl0YWJsZShhY3Rpb24pXG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhKCkge1xuXG4gICAgfSxcbiAgICBjcmVhdGVkKCkge1xuICAgIH0sXG4gICAgbW91bnRlZCgpe1xuICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgbGV0IGVsID0gJCh0aGlzLiRlbClcbiAgICAgIGlmIChlbC5kYXRhKCdlZGl0YWJsZScpKSBlbC5lZGl0YWJsZSgpLmRlc3Ryb3koKVxuICAgICAgbGV0IGRlZmF1bHRPcHRpb24gPSB7XG4gICAgICAgIG1vZGU6ICdpbmxpbmUnLFxuICAgICAgICBvbmJsdXI6ICdzdWJtaXQnLFxuICAgICAgICBzaG93YnV0dG9uczogZmFsc2UsXG4gICAgICAgIGNsZWFyOiBmYWxzZVxuICAgICAgfVxuICAgICAgbGV0IG9wdGlvbiA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbiwgdGhpcy5hamF4T3B0aW9ucywgdGhpcy5vcHRpb24pXG4gICAgICBlbC5lZGl0YWJsZShvcHRpb24pLm9uKCdzaG93bicsIGZ1bmN0aW9uKGUsZWRpdGJsZSl7XG4gICAgICAgIHNlbGYuc2hvd24oKTtcbiAgICAgIH0pLm9uKCdoaWRkZW4nLCBmdW5jdGlvbihlLCByZWFzb24pe1xuICAgICAgICBzZWxmLmhpZGRlbigpO1xuICAgICAgfSkub24oJ3NhdmUnLCBmdW5jdGlvbihlLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5uZXdWYWx1ZSA9PSBzZWxmLnZhbHVlKSByZXR1cm5cbiAgICAgICAgc2VsZi5oYW5kbGVDaGFuZ2UocGFyYW1zLm5ld1ZhbHVlKVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBoYW5kbGVDaGFuZ2UodmFsdWUpIHtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHNlbGYuJGVtaXQoJ2lucHV0Jywgc2VsZi52YWx1ZSk7XG4gICAgICAgIHNlbGYuJGVtaXQoJ2NoYW5nZScsIHNlbGYudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gRWRpdGFibGUudnVlP2JhN2FkZDI2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! X-editable - v1.5.1 \n* In-place editing with Twitter Bootstrap, jQuery UI or pure jQuery\n* http://github.com/vitalets/x-editable\n* Copyright (c) 2013 Vitaliy Potapov; Licensed MIT */\n/**\nForm with single input element, two buttons and two states: normal/loading.\nApplied as jQuery method to DIV tag (not to form tag!). This is because form can be in loading state when spinner shown.\nEditableform is linked with one of input types, e.g. 'text', 'select' etc.\n\n@class editableform\n@uses text\n@uses textarea\n**/\n(function ($) {\n\n    var EditableForm = function EditableForm(div, options) {\n        this.options = $.extend({}, $.fn.editableform.defaults, options);\n        this.$div = $(div); //div, containing form. Not form tag. Not editable-element.\n        if (!this.options.scope) {\n            this.options.scope = this;\n        }\n        //nothing shown after init\n    };\n\n    EditableForm.prototype = {\n        constructor: EditableForm,\n        initInput: function initInput() {\n            //called once\n            //take input from options (as it is created in editable-element)\n            this.input = this.options.input;\n\n            //set initial value\n            //todo: may be add check: typeof str === 'string' ? \n            this.value = this.input.str2value(this.options.value);\n\n            //prerender: get input.$input\n            this.input.prerender();\n        },\n        initTemplate: function initTemplate() {\n            this.$form = $($.fn.editableform.template);\n        },\n        initButtons: function initButtons() {\n            var $btn = this.$form.find('.editable-buttons');\n            $btn.append($.fn.editableform.buttons);\n            if (this.options.showbuttons === 'bottom') {\n                $btn.addClass('editable-buttons-bottom');\n            }\n        },\n        /**\n        Renders editableform\n         @method render\n        **/\n        render: function render() {\n            //init loader\n            this.$loading = $($.fn.editableform.loading);\n            this.$div.empty().append(this.$loading);\n\n            //init form template and buttons\n            this.initTemplate();\n            if (this.options.showbuttons) {\n                this.initButtons();\n            } else {\n                this.$form.find('.editable-buttons').remove();\n            }\n\n            //show loading state\n            this.showLoading();\n\n            //flag showing is form now saving value to server. \n            //It is needed to wait when closing form.\n            this.isSaving = false;\n\n            /**        \n            Fired when rendering starts\n            @event rendering \n            @param {Object} event event object\n            **/\n            this.$div.triggerHandler('rendering');\n\n            //init input\n            this.initInput();\n\n            //append input to form\n            this.$form.find('div.editable-input').append(this.input.$tpl);\n\n            //append form to container\n            this.$div.append(this.$form);\n\n            //render input\n            $.when(this.input.render()).then($.proxy(function () {\n                //setup input to submit automatically when no buttons shown\n                if (!this.options.showbuttons) {\n                    this.input.autosubmit();\n                }\n\n                //attach 'cancel' handler\n                this.$form.find('.editable-cancel').click($.proxy(this.cancel, this));\n\n                if (this.input.error) {\n                    this.error(this.input.error);\n                    this.$form.find('.editable-submit').attr('disabled', true);\n                    this.input.$input.attr('disabled', true);\n                    //prevent form from submitting\n                    this.$form.submit(function (e) {\n                        e.preventDefault();\n                    });\n                } else {\n                    this.error(false);\n                    this.input.$input.removeAttr('disabled');\n                    this.$form.find('.editable-submit').removeAttr('disabled');\n                    var value = this.value === null || this.value === undefined || this.value === '' ? this.options.defaultValue : this.value;\n                    this.input.value2input(value);\n                    //attach submit handler\n                    this.$form.submit($.proxy(this.submit, this));\n                }\n\n                /**        \n                Fired when form is rendered\n                @event rendered\n                @param {Object} event event object\n                **/\n                this.$div.triggerHandler('rendered');\n\n                this.showForm();\n\n                //call postrender method to perform actions required visibility of form\n                if (this.input.postrender) {\n                    this.input.postrender();\n                }\n            }, this));\n        },\n        cancel: function cancel() {\n            /**        \n            Fired when form was cancelled by user\n            @event cancel \n            @param {Object} event event object\n            **/\n            this.$div.triggerHandler('cancel');\n        },\n        showLoading: function showLoading() {\n            var w, h;\n            if (this.$form) {\n                //set loading size equal to form\n                w = this.$form.outerWidth();\n                h = this.$form.outerHeight();\n                if (w) {\n                    this.$loading.width(w);\n                }\n                if (h) {\n                    this.$loading.height(h);\n                }\n                this.$form.hide();\n            } else {\n                //stretch loading to fill container width\n                w = this.$loading.parent().width();\n                if (w) {\n                    this.$loading.width(w);\n                }\n            }\n            this.$loading.show();\n        },\n\n        showForm: function showForm(activate) {\n            this.$loading.hide();\n            this.$form.show();\n            if (activate !== false) {\n                this.input.activate();\n            }\n            /**        \n            Fired when form is shown\n            @event show \n            @param {Object} event event object\n            **/\n            this.$div.triggerHandler('show');\n        },\n\n        error: function error(msg) {\n            var $group = this.$form.find('.control-group'),\n                $block = this.$form.find('.editable-error-block'),\n                lines;\n\n            if (msg === false) {\n                $group.removeClass($.fn.editableform.errorGroupClass);\n                $block.removeClass($.fn.editableform.errorBlockClass).empty().hide();\n            } else {\n                //convert newline to <br> for more pretty error display\n                if (msg) {\n                    lines = ('' + msg).split('\\n');\n                    for (var i = 0; i < lines.length; i++) {\n                        lines[i] = $('<div>').text(lines[i]).html();\n                    }\n                    msg = lines.join('<br>');\n                }\n                $group.addClass($.fn.editableform.errorGroupClass);\n                $block.addClass($.fn.editableform.errorBlockClass).html(msg).show();\n            }\n        },\n\n        submit: function submit(e) {\n            e.stopPropagation();\n            e.preventDefault();\n\n            //get new value from input\n            var newValue = this.input.input2value();\n\n            //validation: if validate returns string or truthy value - means error\n            //if returns object like {newValue: '...'} => submitted value is reassigned to it\n            var error = this.validate(newValue);\n            if ($.type(error) === 'object' && error.newValue !== undefined) {\n                newValue = error.newValue;\n                this.input.value2input(newValue);\n                if (typeof error.msg === 'string') {\n                    this.error(error.msg);\n                    this.showForm();\n                    return;\n                }\n            } else if (error) {\n                this.error(error);\n                this.showForm();\n                return;\n            }\n\n            //if value not changed --\x3e trigger 'nochange' event and return\n            /*jslint eqeq: true*/\n            if (!this.options.savenochange && this.input.value2str(newValue) == this.input.value2str(this.value)) {\n                /*jslint eqeq: false*/\n                /**        \n                Fired when value not changed but form is submitted. Requires savenochange = false.\n                @event nochange \n                @param {Object} event event object\n                **/\n                this.$div.triggerHandler('nochange');\n                return;\n            }\n\n            //convert value for submitting to server\n            var submitValue = this.input.value2submit(newValue);\n\n            this.isSaving = true;\n\n            //sending data to server\n            $.when(this.save(submitValue)).done($.proxy(function (response) {\n                this.isSaving = false;\n\n                //run success callback\n                var res = typeof this.options.success === 'function' ? this.options.success.call(this.options.scope, response, newValue) : null;\n\n                //if success callback returns false --\x3e keep form open and do not activate input\n                if (res === false) {\n                    this.error(false);\n                    this.showForm(false);\n                    return;\n                }\n\n                //if success callback returns string --\x3e  keep form open, show error and activate input               \n                if (typeof res === 'string') {\n                    this.error(res);\n                    this.showForm();\n                    return;\n                }\n\n                //if success callback returns object like {newValue: <something>} --\x3e use that value instead of submitted\n                //it is usefull if you want to chnage value in url-function\n                if (res && (typeof res === 'undefined' ? 'undefined' : _typeof(res)) === 'object' && res.hasOwnProperty('newValue')) {\n                    newValue = res.newValue;\n                }\n\n                //clear error message\n                this.error(false);\n                this.value = newValue;\n                /**        \n                Fired when form is submitted\n                @event save \n                @param {Object} event event object\n                @param {Object} params additional params\n                @param {mixed} params.newValue raw new value\n                @param {mixed} params.submitValue submitted value as string\n                @param {Object} params.response ajax response\n                 @example\n                $('#form-div').on('save'), function(e, params){\n                    if(params.newValue === 'username') {...}\n                });\n                **/\n                this.$div.triggerHandler('save', { newValue: newValue, submitValue: submitValue, response: response });\n            }, this)).fail($.proxy(function (xhr) {\n                this.isSaving = false;\n\n                var msg;\n                if (typeof this.options.error === 'function') {\n                    msg = this.options.error.call(this.options.scope, xhr, newValue);\n                } else {\n                    msg = typeof xhr === 'string' ? xhr : xhr.responseText || xhr.statusText || 'Unknown error!';\n                }\n\n                this.error(msg);\n                this.showForm();\n            }, this));\n        },\n\n        save: function save(submitValue) {\n            //try parse composite pk defined as json string in data-pk \n            this.options.pk = $.fn.editableutils.tryParseJson(this.options.pk, true);\n\n            var pk = typeof this.options.pk === 'function' ? this.options.pk.call(this.options.scope) : this.options.pk,\n\n            /*\n              send on server in following cases:\n              1. url is function\n              2. url is string AND (pk defined OR send option = always) \n            */\n            send = !!(typeof this.options.url === 'function' || this.options.url && (this.options.send === 'always' || this.options.send === 'auto' && pk !== null && pk !== undefined)),\n                params;\n\n            if (send) {\n                //send to server\n                this.showLoading();\n\n                //standard params\n                params = {\n                    name: this.options.name || '',\n                    value: submitValue,\n                    pk: pk\n                };\n\n                //additional params\n                if (typeof this.options.params === 'function') {\n                    params = this.options.params.call(this.options.scope, params);\n                } else {\n                    //try parse json in single quotes (from data-params attribute)\n                    this.options.params = $.fn.editableutils.tryParseJson(this.options.params, true);\n                    $.extend(params, this.options.params);\n                }\n\n                if (typeof this.options.url === 'function') {\n                    //user's function\n                    return this.options.url.call(this.options.scope, params);\n                } else {\n                    //send ajax to server and return deferred object\n                    return $.ajax($.extend({\n                        url: this.options.url,\n                        data: params,\n                        type: 'POST'\n                    }, this.options.ajaxOptions));\n                }\n            }\n        },\n\n        validate: function validate(value) {\n            if (value === undefined) {\n                value = this.value;\n            }\n            if (typeof this.options.validate === 'function') {\n                return this.options.validate.call(this.options.scope, value);\n            }\n        },\n\n        option: function option(key, value) {\n            if (key in this.options) {\n                this.options[key] = value;\n            }\n\n            if (key === 'value') {\n                this.setValue(value);\n            }\n\n            //do not pass option to input as it is passed in editable-element\n        },\n\n        setValue: function setValue(value, convertStr) {\n            if (convertStr) {\n                this.value = this.input.str2value(value);\n            } else {\n                this.value = value;\n            }\n\n            //if form is visible, update input\n            if (this.$form && this.$form.is(':visible')) {\n                this.input.value2input(this.value);\n            }\n        }\n    };\n\n    /*\n    Initialize editableform. Applied to jQuery object.\n     @method $().editableform(options)\n    @params {Object} options\n    @example\n    var $form = $('&lt;div&gt;').editableform({\n        type: 'text',\n        name: 'username',\n        url: '/post',\n        value: 'vitaliy'\n    });\n     //to display form you should call 'render' method\n    $form.editableform('render');     \n    */\n    $.fn.editableform = function (option) {\n        var args = arguments;\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data('editableform'),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) === 'object' && option;\n            if (!data) {\n                $this.data('editableform', data = new EditableForm(this, options));\n            }\n\n            if (typeof option === 'string') {\n                //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            }\n        });\n    };\n\n    //keep link to constructor to allow inheritance\n    $.fn.editableform.Constructor = EditableForm;\n\n    //defaults\n    $.fn.editableform.defaults = {\n        /* see also defaults for input */\n\n        /**\n        Type of input. Can be <code>text|textarea|select|date|checklist</code>\n         @property type \n        @type string\n        @default 'text'\n        **/\n        type: 'text',\n        /**\n        Url for submit, e.g. <code>'/post'</code>  \n        If function - it will be called instead of ajax. Function should return deferred object to run fail/done callbacks.\n         @property url \n        @type string|function\n        @default null\n        @example\n        url: function(params) {\n            var d = new $.Deferred;\n            if(params.value === 'abc') {\n                return d.reject('error message'); //returning error via deferred object\n            } else {\n                //async saving data in js model\n                someModel.asyncSaveMethod({\n                   ..., \n                   success: function(){\n                      d.resolve();\n                   }\n                }); \n                return d.promise();\n            }\n        } \n        **/\n        url: null,\n        /**\n        Additional params for submit. If defined as <code>object</code> - it is **appended** to original ajax data (pk, name and value).  \n        If defined as <code>function</code> - returned object **overwrites** original ajax data.\n        @example\n        params: function(params) {\n            //originally params contain pk, name and value\n            params.a = 1;\n            return params;\n        }\n         @property params \n        @type object|function\n        @default null\n        **/\n        params: null,\n        /**\n        Name of field. Will be submitted on server. Can be taken from <code>id</code> attribute\n         @property name \n        @type string\n        @default null\n        **/\n        name: null,\n        /**\n        Primary key of editable object (e.g. record id in database). For composite keys use object, e.g. <code>{id: 1, lang: 'en'}</code>.\n        Can be calculated dynamically via function.\n         @property pk \n        @type string|object|function\n        @default null\n        **/\n        pk: null,\n        /**\n        Initial value. If not defined - will be taken from element's content.\n        For __select__ type should be defined (as it is ID of shown text).\n         @property value \n        @type string|object\n        @default null\n        **/\n        value: null,\n        /**\n        Value that will be displayed in input if original field value is empty (`null|undefined|''`).\n         @property defaultValue \n        @type string|object\n        @default null\n        @since 1.4.6\n        **/\n        defaultValue: null,\n        /**\n        Strategy for sending data on server. Can be `auto|always|never`.\n        When 'auto' data will be sent on server **only if pk and url defined**, otherwise new value will be stored locally.\n         @property send \n        @type string\n        @default 'auto'\n        **/\n        send: 'auto',\n        /**\n        Function for client-side validation. If returns string - means validation not passed and string showed as error.\n        Since 1.5.1 you can modify submitted value by returning object from `validate`: \n        `{newValue: '...'}` or `{newValue: '...', msg: '...'}`\n         @property validate \n        @type function\n        @default null\n        @example\n        validate: function(value) {\n            if($.trim(value) == '') {\n                return 'This field is required';\n            }\n        }\n        **/\n        validate: null,\n        /**\n        Success callback. Called when value successfully sent on server and **response status = 200**.  \n        Usefull to work with json response. For example, if your backend response can be <code>{success: true}</code>\n        or <code>{success: false, msg: \"server error\"}</code> you can check it inside this callback.  \n        If it returns **string** - means error occured and string is shown as error message.  \n        If it returns **object like** <code>{newValue: &lt;something&gt;}</code> - it overwrites value, submitted by user.  \n        Otherwise newValue simply rendered into element.\n        \n        @property success \n        @type function\n        @default null\n        @example\n        success: function(response, newValue) {\n            if(!response.success) return response.msg;\n        }\n        **/\n        success: null,\n        /**\n        Error callback. Called when request failed (response status != 200).  \n        Usefull when you want to parse error response and display a custom message.\n        Must return **string** - the message to be displayed in the error block.\n                \n        @property error \n        @type function\n        @default null\n        @since 1.4.4\n        @example\n        error: function(response, newValue) {\n            if(response.status === 500) {\n                return 'Service unavailable. Please try later.';\n            } else {\n                return response.responseText;\n            }\n        }\n        **/\n        error: null,\n        /**\n        Additional options for submit ajax request.\n        List of values: http://api.jquery.com/jQuery.ajax\n        \n        @property ajaxOptions \n        @type object\n        @default null\n        @since 1.1.1        \n        @example \n        ajaxOptions: {\n            type: 'put',\n            dataType: 'json'\n        }        \n        **/\n        ajaxOptions: null,\n        /**\n        Where to show buttons: left(true)|bottom|false  \n        Form without buttons is auto-submitted.\n         @property showbuttons \n        @type boolean|string\n        @default true\n        @since 1.1.1\n        **/\n        showbuttons: true,\n        /**\n        Scope for callback methods (success, validate).  \n        If <code>null</code> means editableform instance itself. \n         @property scope \n        @type DOMElement|object\n        @default null\n        @since 1.2.0\n        @private\n        **/\n        scope: null,\n        /**\n        Whether to save or cancel value when it was not changed but form was submitted\n         @property savenochange \n        @type boolean\n        @default false\n        @since 1.2.0\n        **/\n        savenochange: false\n    };\n\n    /*\n    Note: following params could redefined in engine: bootstrap or jqueryui:\n    Classes 'control-group' and 'editable-error-block' must always present!\n    */\n    $.fn.editableform.template = '<form class=\"form-inline editableform\">' + '<div class=\"control-group\">' + '<div><div class=\"editable-input\"></div><div class=\"editable-buttons\"></div></div>' + '<div class=\"editable-error-block\"></div>' + '</div>' + '</form>';\n\n    //loading div\n    $.fn.editableform.loading = '<div class=\"editableform-loading\"></div>';\n\n    //buttons\n    $.fn.editableform.buttons = '<button type=\"submit\" class=\"editable-submit\">ok</button>' + '<button type=\"button\" class=\"editable-cancel\">cancel</button>';\n\n    //error class attached to control-group\n    $.fn.editableform.errorGroupClass = null;\n\n    //error class attached to editable-error-block\n    $.fn.editableform.errorBlockClass = 'editable-error';\n\n    //engine\n    $.fn.editableform.engine = 'jquery';\n})(window.jQuery);\n\n/**\n* EditableForm utilites\n*/\n(function ($) {\n\n    //utils\n    $.fn.editableutils = {\n        /**\n        * classic JS inheritance function\n        */\n        inherit: function inherit(Child, Parent) {\n            var F = function F() {};\n            F.prototype = Parent.prototype;\n            Child.prototype = new F();\n            Child.prototype.constructor = Child;\n            Child.superclass = Parent.prototype;\n        },\n\n        /**\n        * set caret position in input\n        * see http://stackoverflow.com/questions/499126/jquery-set-cursor-position-in-text-area\n        */\n        setCursorPosition: function setCursorPosition(elem, pos) {\n            if (elem.setSelectionRange) {\n                elem.setSelectionRange(pos, pos);\n            } else if (elem.createTextRange) {\n                var range = elem.createTextRange();\n                range.collapse(true);\n                range.moveEnd('character', pos);\n                range.moveStart('character', pos);\n                range.select();\n            }\n        },\n\n        /**\n        * function to parse JSON in *single* quotes. (jquery automatically parse only double quotes)\n        * That allows such code as: <a data-source=\"{'a': 'b', 'c': 'd'}\">\n        * safe = true --\x3e means no exception will be thrown\n        * for details see http://stackoverflow.com/questions/7410348/how-to-set-json-format-to-html5-data-attributes-in-the-jquery\n        */\n        tryParseJson: function tryParseJson(s, safe) {\n            if (typeof s === 'string' && s.length && s.match(/^[\\{\\[].*[\\}\\]]$/)) {\n                if (safe) {\n                    try {\n                        /*jslint evil: true*/\n                        s = new Function('return ' + s)();\n                        /*jslint evil: false*/\n                    } catch (e) {} finally {\n                        return s;\n                    }\n                } else {\n                    /*jslint evil: true*/\n                    s = new Function('return ' + s)();\n                    /*jslint evil: false*/\n                }\n            }\n            return s;\n        },\n\n        /**\n        * slice object by specified keys\n        */\n        sliceObj: function sliceObj(obj, keys, caseSensitive /* default: false */) {\n            var key,\n                keyLower,\n                newObj = {};\n\n            if (!$.isArray(keys) || !keys.length) {\n                return newObj;\n            }\n\n            for (var i = 0; i < keys.length; i++) {\n                key = keys[i];\n                if (obj.hasOwnProperty(key)) {\n                    newObj[key] = obj[key];\n                }\n\n                if (caseSensitive === true) {\n                    continue;\n                }\n\n                //when getting data-* attributes via $.data() it's converted to lowercase.\n                //details: http://stackoverflow.com/questions/7602565/using-data-attributes-with-jquery\n                //workaround is code below.\n                keyLower = key.toLowerCase();\n                if (obj.hasOwnProperty(keyLower)) {\n                    newObj[key] = obj[keyLower];\n                }\n            }\n\n            return newObj;\n        },\n\n        /*\n        exclude complex objects from $.data() before pass to config\n        */\n        getConfigData: function getConfigData($element) {\n            var data = {};\n            $.each($element.data(), function (k, v) {\n                if ((typeof v === 'undefined' ? 'undefined' : _typeof(v)) !== 'object' || v && (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' && (v.constructor === Object || v.constructor === Array)) {\n                    data[k] = v;\n                }\n            });\n            return data;\n        },\n\n        /*\n         returns keys of object\n        */\n        objectKeys: function objectKeys(o) {\n            if (Object.keys) {\n                return Object.keys(o);\n            } else {\n                if (o !== Object(o)) {\n                    throw new TypeError('Object.keys called on a non-object');\n                }\n                var k = [],\n                    p;\n                for (p in o) {\n                    if (Object.prototype.hasOwnProperty.call(o, p)) {\n                        k.push(p);\n                    }\n                }\n                return k;\n            }\n        },\n\n        /**\n         method to escape html.\n        **/\n        escape: function escape(str) {\n            return $('<div>').text(str).html();\n        },\n\n        /*\n         returns array items from sourceData having value property equal or inArray of 'value'\n        */\n        itemsByValue: function itemsByValue(value, sourceData, valueProp) {\n            if (!sourceData || value === null) {\n                return [];\n            }\n\n            if (typeof valueProp !== \"function\") {\n                var idKey = valueProp || 'value';\n                valueProp = function valueProp(e) {\n                    return e[idKey];\n                };\n            }\n\n            var isValArray = $.isArray(value),\n                result = [],\n                that = this;\n\n            $.each(sourceData, function (i, o) {\n                if (o.children) {\n                    result = result.concat(that.itemsByValue(value, o.children, valueProp));\n                } else {\n                    /*jslint eqeq: true*/\n                    if (isValArray) {\n                        if ($.grep(value, function (v) {\n                            return v == (o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' ? valueProp(o) : o);\n                        }).length) {\n                            result.push(o);\n                        }\n                    } else {\n                        var itemValue = o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' ? valueProp(o) : o;\n                        if (value == itemValue) {\n                            result.push(o);\n                        }\n                    }\n                    /*jslint eqeq: false*/\n                }\n            });\n\n            return result;\n        },\n\n        /*\n        Returns input by options: type, mode. \n        */\n        createInput: function createInput(options) {\n            var TypeConstructor,\n                typeOptions,\n                input,\n                type = options.type;\n\n            //`date` is some kind of virtual type that is transformed to one of exact types\n            //depending on mode and core lib\n            if (type === 'date') {\n                //inline\n                if (options.mode === 'inline') {\n                    if ($.fn.editabletypes.datefield) {\n                        type = 'datefield';\n                    } else if ($.fn.editabletypes.dateuifield) {\n                        type = 'dateuifield';\n                    }\n                    //popup\n                } else {\n                    if ($.fn.editabletypes.date) {\n                        type = 'date';\n                    } else if ($.fn.editabletypes.dateui) {\n                        type = 'dateui';\n                    }\n                }\n\n                //if type still `date` and not exist in types, replace with `combodate` that is base input\n                if (type === 'date' && !$.fn.editabletypes.date) {\n                    type = 'combodate';\n                }\n            }\n\n            //`datetime` should be datetimefield in 'inline' mode\n            if (type === 'datetime' && options.mode === 'inline') {\n                type = 'datetimefield';\n            }\n\n            //change wysihtml5 to textarea for jquery UI and plain versions\n            if (type === 'wysihtml5' && !$.fn.editabletypes[type]) {\n                type = 'textarea';\n            }\n\n            //create input of specified type. Input will be used for converting value, not in form\n            if (typeof $.fn.editabletypes[type] === 'function') {\n                TypeConstructor = $.fn.editabletypes[type];\n                typeOptions = this.sliceObj(options, this.objectKeys(TypeConstructor.defaults));\n                input = new TypeConstructor(typeOptions);\n                return input;\n            } else {\n                $.error('Unknown type: ' + type);\n                return false;\n            }\n        },\n\n        //see http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr\n        supportsTransitions: function supportsTransitions() {\n            var b = document.body || document.documentElement,\n                s = b.style,\n                p = 'transition',\n                v = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];\n\n            if (typeof s[p] === 'string') {\n                return true;\n            }\n\n            // Tests for vendor specific prop\n            p = p.charAt(0).toUpperCase() + p.substr(1);\n            for (var i = 0; i < v.length; i++) {\n                if (typeof s[v[i] + p] === 'string') {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    };\n})(window.jQuery);\n\n/**\nAttaches stand-alone container with editable-form to HTML element. Element is used only for positioning, value is not stored anywhere.<br>\nThis method applied internally in <code>$().editable()</code>. You should subscribe on it's events (save / cancel) to get profit of it.<br>\nFinal realization can be different: bootstrap-popover, jqueryui-tooltip, poshytip, inline-div. It depends on which js file you include.<br>\nApplied as jQuery method.\n\n@class editableContainer\n@uses editableform\n**/\n(function ($) {\n\n    var Popup = function Popup(element, options) {\n        this.init(element, options);\n    };\n\n    var Inline = function Inline(element, options) {\n        this.init(element, options);\n    };\n\n    //methods\n    Popup.prototype = {\n        containerName: null, //method to call container on element\n        containerDataName: null, //object name in element's .data()\n        innerCss: null, //tbd in child class\n        containerClass: 'editable-container editable-popup', //css class applied to container element\n        defaults: {}, //container itself defaults\n\n        init: function init(element, options) {\n            this.$element = $(element);\n            //since 1.4.1 container do not use data-* directly as they already merged into options.\n            this.options = $.extend({}, $.fn.editableContainer.defaults, options);\n            this.splitOptions();\n\n            //set scope of form callbacks to element\n            this.formOptions.scope = this.$element[0];\n\n            this.initContainer();\n\n            //flag to hide container, when saving value will finish\n            this.delayedHide = false;\n\n            //bind 'destroyed' listener to destroy container when element is removed from dom\n            this.$element.on('destroyed', $.proxy(function () {\n                this.destroy();\n            }, this));\n\n            //attach document handler to close containers on click / escape\n            if (!$(document).data('editable-handlers-attached')) {\n                //close all on escape\n                $(document).on('keyup.editable', function (e) {\n                    if (e.which === 27) {\n                        $('.editable-open').editableContainer('hide');\n                        //todo: return focus on element \n                    }\n                });\n\n                //close containers when click outside \n                //(mousedown could be better than click, it closes everything also on drag drop)\n                $(document).on('click.editable', function (e) {\n                    var $target = $(e.target),\n                        i,\n                        exclude_classes = ['.editable-container', '.ui-datepicker-header', '.datepicker', //in inline mode datepicker is rendered into body\n                    '.modal-backdrop', '.bootstrap-wysihtml5-insert-image-modal', '.bootstrap-wysihtml5-insert-link-modal'];\n\n                    //check if element is detached. It occurs when clicking in bootstrap datepicker\n                    if (!$.contains(document.documentElement, e.target)) {\n                        return;\n                    }\n\n                    //for some reason FF 20 generates extra event (click) in select2 widget with e.target = document\n                    //we need to filter it via construction below. See https://github.com/vitalets/x-editable/issues/199\n                    //Possibly related to http://stackoverflow.com/questions/10119793/why-does-firefox-react-differently-from-webkit-and-ie-to-click-event-on-selec\n                    if ($target.is(document)) {\n                        return;\n                    }\n\n                    //if click inside one of exclude classes --\x3e no nothing\n                    for (i = 0; i < exclude_classes.length; i++) {\n                        if ($target.is(exclude_classes[i]) || $target.parents(exclude_classes[i]).length) {\n                            return;\n                        }\n                    }\n\n                    //close all open containers (except one - target)\n                    Popup.prototype.closeOthers(e.target);\n                });\n\n                $(document).data('editable-handlers-attached', true);\n            }\n        },\n\n        //split options on containerOptions and formOptions\n        splitOptions: function splitOptions() {\n            this.containerOptions = {};\n            this.formOptions = {};\n\n            if (!$.fn[this.containerName]) {\n                throw new Error(this.containerName + ' not found. Have you included corresponding js file?');\n            }\n\n            //keys defined in container defaults go to container, others go to form\n            for (var k in this.options) {\n                if (k in this.defaults) {\n                    this.containerOptions[k] = this.options[k];\n                } else {\n                    this.formOptions[k] = this.options[k];\n                }\n            }\n        },\n\n        /*\n        Returns jquery object of container\n        @method tip()\n        */\n        tip: function tip() {\n            return this.container() ? this.container().$tip : null;\n        },\n\n        /* returns container object */\n        container: function container() {\n            var container;\n            //first, try get it by `containerDataName`\n            if (this.containerDataName) {\n                if (container = this.$element.data(this.containerDataName)) {\n                    return container;\n                }\n            }\n            //second, try `containerName`\n            container = this.$element.data(this.containerName);\n            return container;\n        },\n\n        /* call native method of underlying container, e.g. this.$element.popover('method') */\n        call: function call() {\n            this.$element[this.containerName].apply(this.$element, arguments);\n        },\n\n        initContainer: function initContainer() {\n            this.call(this.containerOptions);\n        },\n\n        renderForm: function renderForm() {\n            this.$form.editableform(this.formOptions).on({\n                save: $.proxy(this.save, this), //click on submit button (value changed)\n                nochange: $.proxy(function () {\n                    this.hide('nochange');\n                }, this), //click on submit button (value NOT changed)                \n                cancel: $.proxy(function () {\n                    this.hide('cancel');\n                }, this), //click on calcel button\n                show: $.proxy(function () {\n                    if (this.delayedHide) {\n                        this.hide(this.delayedHide.reason);\n                        this.delayedHide = false;\n                    } else {\n                        this.setPosition();\n                    }\n                }, this), //re-position container every time form is shown (occurs each time after loading state)\n                rendering: $.proxy(this.setPosition, this), //this allows to place container correctly when loading shown\n                resize: $.proxy(this.setPosition, this), //this allows to re-position container when form size is changed \n                rendered: $.proxy(function () {\n                    /**        \n                    Fired when container is shown and form is rendered (for select will wait for loading dropdown options).  \n                    **Note:** Bootstrap popover has own `shown` event that now cannot be separated from x-editable's one.\n                    The workaround is to check `arguments.length` that is always `2` for x-editable.                     \n                    \n                    @event shown \n                    @param {Object} event event object\n                    @example\n                    $('#username').on('shown', function(e, editable) {\n                        editable.input.$input.val('overwriting value of input..');\n                    });                     \n                    **/\n                    /*\n                     TODO: added second param mainly to distinguish from bootstrap's shown event. It's a hotfix that will be solved in future versions via namespaced events.  \n                    */\n                    this.$element.triggerHandler('shown', $(this.options.scope).data('editable'));\n                }, this)\n            }).editableform('render');\n        },\n\n        /**\n        Shows container with form\n        @method show()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/\n        /* Note: poshytip owerwrites this method totally! */\n        show: function show(closeAll) {\n            this.$element.addClass('editable-open');\n            if (closeAll !== false) {\n                //close all open containers (except this)\n                this.closeOthers(this.$element[0]);\n            }\n\n            //show container itself\n            this.innerShow();\n            this.tip().addClass(this.containerClass);\n\n            /*\n            Currently, form is re-rendered on every show. \n            The main reason is that we dont know, what will container do with content when closed:\n            remove(), detach() or just hide() - it depends on container.\n            \n            Detaching form itself before hide and re-insert before show is good solution, \n            but visually it looks ugly --\x3e container changes size before hide.  \n            */\n\n            //if form already exist - delete previous data \n            if (this.$form) {\n                //todo: destroy prev data!\n                //this.$form.destroy();\n            }\n\n            this.$form = $('<div>');\n\n            //insert form into container body\n            if (this.tip().is(this.innerCss)) {\n                //for inline container\n                this.tip().append(this.$form);\n            } else {\n                this.tip().find(this.innerCss).append(this.$form);\n            }\n\n            //render form\n            this.renderForm();\n        },\n\n        /**\n        Hides container with form\n        @method hide()\n        @param {string} reason Reason caused hiding. Can be <code>save|cancel|onblur|nochange|undefined (=manual)</code>\n        **/\n        hide: function hide(reason) {\n            if (!this.tip() || !this.tip().is(':visible') || !this.$element.hasClass('editable-open')) {\n                return;\n            }\n\n            //if form is saving value, schedule hide\n            if (this.$form.data('editableform').isSaving) {\n                this.delayedHide = { reason: reason };\n                return;\n            } else {\n                this.delayedHide = false;\n            }\n\n            this.$element.removeClass('editable-open');\n            this.innerHide();\n\n            /**\n            Fired when container was hidden. It occurs on both save or cancel.  \n            **Note:** Bootstrap popover has own `hidden` event that now cannot be separated from x-editable's one.\n            The workaround is to check `arguments.length` that is always `2` for x-editable. \n             @event hidden \n            @param {object} event event object\n            @param {string} reason Reason caused hiding. Can be <code>save|cancel|onblur|nochange|manual</code>\n            @example\n            $('#username').on('hidden', function(e, reason) {\n                if(reason === 'save' || reason === 'cancel') {\n                    //auto-open next editable\n                    $(this).closest('tr').next().find('.editable').editable('show');\n                } \n            });\n            **/\n            this.$element.triggerHandler('hidden', reason || 'manual');\n        },\n\n        /* internal show method. To be overwritten in child classes */\n        innerShow: function innerShow() {},\n\n        /* internal hide method. To be overwritten in child classes */\n        innerHide: function innerHide() {},\n\n        /**\n        Toggles container visibility (show / hide)\n        @method toggle()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/\n        toggle: function toggle(closeAll) {\n            if (this.container() && this.tip() && this.tip().is(':visible')) {\n                this.hide();\n            } else {\n                this.show(closeAll);\n            }\n        },\n\n        /*\n        Updates the position of container when content changed.\n        @method setPosition()\n        */\n        setPosition: function setPosition() {\n            //tbd in child class\n        },\n\n        save: function save(e, params) {\n            /**        \n            Fired when new value was submitted. You can use <code>$(this).data('editableContainer')</code> inside handler to access to editableContainer instance\n            \n            @event save \n            @param {Object} event event object\n            @param {Object} params additional params\n            @param {mixed} params.newValue submitted value\n            @param {Object} params.response ajax response\n            @example\n            $('#username').on('save', function(e, params) {\n                //assuming server response: '{success: true}'\n                var pk = $(this).data('editableContainer').options.pk;\n                if(params.response && params.response.success) {\n                    alert('value: ' + params.newValue + ' with pk: ' + pk + ' saved!');\n                } else {\n                    alert('error!'); \n                } \n            });\n            **/\n            this.$element.triggerHandler('save', params);\n\n            //hide must be after trigger, as saving value may require methods of plugin, applied to input\n            this.hide('save');\n        },\n\n        /**\n        Sets new option\n        \n        @method option(key, value)\n        @param {string} key \n        @param {mixed} value \n        **/\n        option: function option(key, value) {\n            this.options[key] = value;\n            if (key in this.containerOptions) {\n                this.containerOptions[key] = value;\n                this.setContainerOption(key, value);\n            } else {\n                this.formOptions[key] = value;\n                if (this.$form) {\n                    this.$form.editableform('option', key, value);\n                }\n            }\n        },\n\n        setContainerOption: function setContainerOption(key, value) {\n            this.call('option', key, value);\n        },\n\n        /**\n        Destroys the container instance\n        @method destroy()\n        **/\n        destroy: function destroy() {\n            this.hide();\n            this.innerDestroy();\n            this.$element.off('destroyed');\n            this.$element.removeData('editableContainer');\n        },\n\n        /* to be overwritten in child classes */\n        innerDestroy: function innerDestroy() {},\n\n        /*\n        Closes other containers except one related to passed element. \n        Other containers can be cancelled or submitted (depends on onblur option)\n        */\n        closeOthers: function closeOthers(element) {\n            $('.editable-open').each(function (i, el) {\n                //do nothing with passed element and it's children\n                if (el === element || $(el).find(element).length) {\n                    return;\n                }\n\n                //otherwise cancel or submit all open containers \n                var $el = $(el),\n                    ec = $el.data('editableContainer');\n\n                if (!ec) {\n                    return;\n                }\n\n                if (ec.options.onblur === 'cancel') {\n                    $el.data('editableContainer').hide('onblur');\n                } else if (ec.options.onblur === 'submit') {\n                    $el.data('editableContainer').tip().find('form').submit();\n                }\n            });\n        },\n\n        /**\n        Activates input of visible container (e.g. set focus)\n        @method activate()\n        **/\n        activate: function activate() {\n            if (this.tip && this.tip().is(':visible') && this.$form) {\n                this.$form.data('editableform').input.activate();\n            }\n        }\n\n    };\n\n    /**\n    jQuery method to initialize editableContainer.\n    \n    @method $().editableContainer(options)\n    @params {Object} options\n    @example\n    $('#edit').editableContainer({\n        type: 'text',\n        url: '/post',\n        pk: 1,\n        value: 'hello'\n    });\n    **/\n    $.fn.editableContainer = function (option) {\n        var args = arguments;\n        return this.each(function () {\n            var $this = $(this),\n                dataKey = 'editableContainer',\n                data = $this.data(dataKey),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) === 'object' && option,\n                Constructor = options.mode === 'inline' ? Inline : Popup;\n\n            if (!data) {\n                $this.data(dataKey, data = new Constructor(this, options));\n            }\n\n            if (typeof option === 'string') {\n                //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            }\n        });\n    };\n\n    //store constructors\n    $.fn.editableContainer.Popup = Popup;\n    $.fn.editableContainer.Inline = Inline;\n\n    //defaults\n    $.fn.editableContainer.defaults = {\n        /**\n        Initial value of form input\n         @property value \n        @type mixed\n        @default null\n        @private\n        **/\n        value: null,\n        /**\n        Placement of container relative to element. Can be <code>top|right|bottom|left</code>. Not used for inline container.\n         @property placement \n        @type string\n        @default 'top'\n        **/\n        placement: 'top',\n        /**\n        Whether to hide container on save/cancel.\n         @property autohide \n        @type boolean\n        @default true\n        @private \n        **/\n        autohide: true,\n        /**\n        Action when user clicks outside the container. Can be <code>cancel|submit|ignore</code>.  \n        Setting <code>ignore</code> allows to have several containers open. \n         @property onblur \n        @type string\n        @default 'cancel'\n        @since 1.1.1\n        **/\n        onblur: 'cancel',\n\n        /**\n        Animation speed (inline mode only)\n        @property anim \n        @type string\n        @default false\n        **/\n        anim: false,\n\n        /**\n        Mode of editable, can be `popup` or `inline` \n        \n        @property mode \n        @type string         \n        @default 'popup'\n        @since 1.4.0        \n        **/\n        mode: 'popup'\n    };\n\n    /* \n    * workaround to have 'destroyed' event to destroy popover when element is destroyed\n    * see http://stackoverflow.com/questions/2200494/jquery-trigger-event-when-an-element-is-removed-from-the-dom\n    */\n    jQuery.event.special.destroyed = {\n        remove: function remove(o) {\n            if (o.handler) {\n                o.handler();\n            }\n        }\n    };\n})(window.jQuery);\n\n/**\n* Editable Inline \n* ---------------------\n*/\n(function ($) {\n\n    //copy prototype from EditableContainer\n    //extend methods\n    $.extend($.fn.editableContainer.Inline.prototype, $.fn.editableContainer.Popup.prototype, {\n        containerName: 'editableform',\n        innerCss: '.editable-inline',\n        containerClass: 'editable-container editable-inline', //css class applied to container element\n\n        initContainer: function initContainer() {\n            //container is <span> element\n            this.$tip = $('<span></span>');\n\n            //convert anim to miliseconds (int)\n            if (!this.options.anim) {\n                this.options.anim = 0;\n            }\n        },\n\n        splitOptions: function splitOptions() {\n            //all options are passed to form\n            this.containerOptions = {};\n            this.formOptions = this.options;\n        },\n\n        tip: function tip() {\n            return this.$tip;\n        },\n\n        innerShow: function innerShow() {\n            this.$element.hide();\n            this.tip().insertAfter(this.$element).show();\n        },\n\n        innerHide: function innerHide() {\n            this.$tip.hide(this.options.anim, $.proxy(function () {\n                this.$element.show();\n                this.innerDestroy();\n            }, this));\n        },\n\n        innerDestroy: function innerDestroy() {\n            if (this.tip()) {\n                this.tip().empty().remove();\n            }\n        }\n    });\n})(window.jQuery);\n/**\nMakes editable any HTML element on the page. Applied as jQuery method.\n\n@class editable\n@uses editableContainer\n**/\n(function ($) {\n\n    var Editable = function Editable(element, options) {\n        this.$element = $(element);\n        //data-* has more priority over js options: because dynamically created elements may change data-* \n        this.options = $.extend({}, $.fn.editable.defaults, options, $.fn.editableutils.getConfigData(this.$element));\n        if (this.options.selector) {\n            this.initLive();\n        } else {\n            this.init();\n        }\n\n        //check for transition support\n        if (this.options.highlight && !$.fn.editableutils.supportsTransitions()) {\n            this.options.highlight = false;\n        }\n    };\n\n    Editable.prototype = {\n        constructor: Editable,\n        init: function init() {\n            var isValueByText = false,\n                doAutotext,\n                finalize;\n\n            //name\n            this.options.name = this.options.name || this.$element.attr('id');\n\n            //create input of specified type. Input needed already here to convert value for initial display (e.g. show text by id for select)\n            //also we set scope option to have access to element inside input specific callbacks (e. g. source as function)\n            this.options.scope = this.$element[0];\n            this.input = $.fn.editableutils.createInput(this.options);\n            if (!this.input) {\n                return;\n            }\n\n            //set value from settings or by element's text\n            if (this.options.value === undefined || this.options.value === null) {\n                this.value = this.input.html2value($.trim(this.$element.html()));\n                isValueByText = true;\n            } else {\n                /*\n                  value can be string when received from 'data-value' attribute\n                  for complext objects value can be set as json string in data-value attribute, \n                  e.g. data-value=\"{city: 'Moscow', street: 'Lenina'}\"\n                */\n                this.options.value = $.fn.editableutils.tryParseJson(this.options.value, true);\n                if (typeof this.options.value === 'string') {\n                    this.value = this.input.str2value(this.options.value);\n                } else {\n                    this.value = this.options.value;\n                }\n            }\n\n            //add 'editable' class to every editable element\n            this.$element.addClass('editable');\n\n            //specifically for \"textarea\" add class .editable-pre-wrapped to keep linebreaks\n            if (this.input.type === 'textarea') {\n                this.$element.addClass('editable-pre-wrapped');\n            }\n\n            //attach handler activating editable. In disabled mode it just prevent default action (useful for links)\n            if (this.options.toggle !== 'manual') {\n                this.$element.addClass('editable-click');\n                this.$element.on(this.options.toggle + '.editable', $.proxy(function (e) {\n                    //prevent following link if editable enabled\n                    if (!this.options.disabled) {\n                        e.preventDefault();\n                    }\n\n                    //stop propagation not required because in document click handler it checks event target\n                    //e.stopPropagation();\n\n                    if (this.options.toggle === 'mouseenter') {\n                        //for hover only show container\n                        this.show();\n                    } else {\n                        //when toggle='click' we should not close all other containers as they will be closed automatically in document click listener\n                        var closeAll = this.options.toggle !== 'click';\n                        this.toggle(closeAll);\n                    }\n                }, this));\n            } else {\n                this.$element.attr('tabindex', -1); //do not stop focus on element when toggled manually\n            }\n\n            //if display is function it's far more convinient to have autotext = always to render correctly on init\n            //see https://github.com/vitalets/x-editable-yii/issues/34\n            if (typeof this.options.display === 'function') {\n                this.options.autotext = 'always';\n            }\n\n            //check conditions for autotext:\n            switch (this.options.autotext) {\n                case 'always':\n                    doAutotext = true;\n                    break;\n                case 'auto':\n                    //if element text is empty and value is defined and value not generated by text --\x3e run autotext\n                    doAutotext = !$.trim(this.$element.text()).length && this.value !== null && this.value !== undefined && !isValueByText;\n                    break;\n                default:\n                    doAutotext = false;\n            }\n\n            //depending on autotext run render() or just finilize init\n            $.when(doAutotext ? this.render() : true).then($.proxy(function () {\n                if (this.options.disabled) {\n                    this.disable();\n                } else {\n                    this.enable();\n                }\n                /**        \n                Fired when element was initialized by `$().editable()` method. \n                Please note that you should setup `init` handler **before** applying `editable`. \n                               \n                @event init \n                @param {Object} event event object\n                @param {Object} editable editable instance (as here it cannot accessed via data('editable'))\n                @since 1.2.0\n                @example\n                $('#username').on('init', function(e, editable) {\n                    alert('initialized ' + editable.options.name);\n                });\n                $('#username').editable();\n                **/\n                this.$element.triggerHandler('init', this);\n            }, this));\n        },\n\n        /*\n         Initializes parent element for live editables \n        */\n        initLive: function initLive() {\n            //store selector \n            var selector = this.options.selector;\n            //modify options for child elements\n            this.options.selector = false;\n            this.options.autotext = 'never';\n            //listen toggle events\n            this.$element.on(this.options.toggle + '.editable', selector, $.proxy(function (e) {\n                var $target = $(e.target);\n                if (!$target.data('editable')) {\n                    //if delegated element initially empty, we need to clear it's text (that was manually set to `empty` by user)\n                    //see https://github.com/vitalets/x-editable/issues/137 \n                    if ($target.hasClass(this.options.emptyclass)) {\n                        $target.empty();\n                    }\n                    $target.editable(this.options).trigger(e);\n                }\n            }, this));\n        },\n\n        /*\n        Renders value into element's text.\n        Can call custom display method from options.\n        Can return deferred object.\n        @method render()\n        @param {mixed} response server response (if exist) to pass into display function\n        */\n        render: function render(response) {\n            //do not display anything\n            if (this.options.display === false) {\n                return;\n            }\n\n            //if input has `value2htmlFinal` method, we pass callback in third param to be called when source is loaded\n            if (this.input.value2htmlFinal) {\n                return this.input.value2html(this.value, this.$element[0], this.options.display, response);\n                //if display method defined --\x3e use it    \n            } else if (typeof this.options.display === 'function') {\n                return this.options.display.call(this.$element[0], this.value, response);\n                //else use input's original value2html() method    \n            } else {\n                return this.input.value2html(this.value, this.$element[0]);\n            }\n        },\n\n        /**\n        Enables editable\n        @method enable()\n        **/\n        enable: function enable() {\n            this.options.disabled = false;\n            this.$element.removeClass('editable-disabled');\n            this.handleEmpty(this.isEmpty);\n            if (this.options.toggle !== 'manual') {\n                if (this.$element.attr('tabindex') === '-1') {\n                    this.$element.removeAttr('tabindex');\n                }\n            }\n        },\n\n        /**\n        Disables editable\n        @method disable()\n        **/\n        disable: function disable() {\n            this.options.disabled = true;\n            this.hide();\n            this.$element.addClass('editable-disabled');\n            this.handleEmpty(this.isEmpty);\n            //do not stop focus on this element\n            this.$element.attr('tabindex', -1);\n        },\n\n        /**\n        Toggles enabled / disabled state of editable element\n        @method toggleDisabled()\n        **/\n        toggleDisabled: function toggleDisabled() {\n            if (this.options.disabled) {\n                this.enable();\n            } else {\n                this.disable();\n            }\n        },\n\n        /**\n        Sets new option\n        \n        @method option(key, value)\n        @param {string|object} key option name or object with several options\n        @param {mixed} value option new value\n        @example\n        $('.editable').editable('option', 'pk', 2);\n        **/\n        option: function option(key, value) {\n            //set option(s) by object\n            if (key && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {\n                $.each(key, $.proxy(function (k, v) {\n                    this.option($.trim(k), v);\n                }, this));\n                return;\n            }\n\n            //set option by string             \n            this.options[key] = value;\n\n            //disabled\n            if (key === 'disabled') {\n                return value ? this.disable() : this.enable();\n            }\n\n            //value\n            if (key === 'value') {\n                this.setValue(value);\n            }\n\n            //transfer new option to container! \n            if (this.container) {\n                this.container.option(key, value);\n            }\n\n            //pass option to input directly (as it points to the same in form)\n            if (this.input.option) {\n                this.input.option(key, value);\n            }\n        },\n\n        /*\n        * set emptytext if element is empty\n        */\n        handleEmpty: function handleEmpty(isEmpty) {\n            //do not handle empty if we do not display anything\n            if (this.options.display === false) {\n                return;\n            }\n\n            /* \n            isEmpty may be set directly as param of method.\n            It is required when we enable/disable field and can't rely on content \n            as node content is text: \"Empty\" that is not empty %)\n            */\n            if (isEmpty !== undefined) {\n                this.isEmpty = isEmpty;\n            } else {\n                //detect empty\n                //for some inputs we need more smart check\n                //e.g. wysihtml5 may have <br>, <p></p>, <img>\n                if (typeof this.input.isEmpty === 'function') {\n                    this.isEmpty = this.input.isEmpty(this.$element);\n                } else {\n                    this.isEmpty = $.trim(this.$element.html()) === '';\n                }\n            }\n\n            //emptytext shown only for enabled\n            if (!this.options.disabled) {\n                if (this.isEmpty) {\n                    this.$element.html(this.options.emptytext);\n                    if (this.options.emptyclass) {\n                        this.$element.addClass(this.options.emptyclass);\n                    }\n                } else if (this.options.emptyclass) {\n                    this.$element.removeClass(this.options.emptyclass);\n                }\n            } else {\n                //below required if element disable property was changed\n                if (this.isEmpty) {\n                    this.$element.empty();\n                    if (this.options.emptyclass) {\n                        this.$element.removeClass(this.options.emptyclass);\n                    }\n                }\n            }\n        },\n\n        /**\n        Shows container with form\n        @method show()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/\n        show: function show(closeAll) {\n            if (this.options.disabled) {\n                return;\n            }\n\n            //init editableContainer: popover, tooltip, inline, etc..\n            if (!this.container) {\n                var containerOptions = $.extend({}, this.options, {\n                    value: this.value,\n                    input: this.input //pass input to form (as it is already created)\n                });\n                this.$element.editableContainer(containerOptions);\n                //listen `save` event \n                this.$element.on(\"save.internal\", $.proxy(this.save, this));\n                this.container = this.$element.data('editableContainer');\n            } else if (this.container.tip().is(':visible')) {\n                return;\n            }\n\n            //show container\n            this.container.show(closeAll);\n        },\n\n        /**\n        Hides container with form\n        @method hide()\n        **/\n        hide: function hide() {\n            if (this.container) {\n                this.container.hide();\n            }\n        },\n\n        /**\n        Toggles container visibility (show / hide)\n        @method toggle()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/\n        toggle: function toggle(closeAll) {\n            if (this.container && this.container.tip().is(':visible')) {\n                this.hide();\n            } else {\n                this.show(closeAll);\n            }\n        },\n\n        /*\n        * called when form was submitted\n        */\n        save: function save(e, params) {\n            //mark element with unsaved class if needed\n            if (this.options.unsavedclass) {\n                /*\n                 Add unsaved css to element if:\n                  - url is not user's function \n                  - value was not sent to server\n                  - params.response === undefined, that means data was not sent\n                  - value changed \n                */\n                var sent = false;\n                sent = sent || typeof this.options.url === 'function';\n                sent = sent || this.options.display === false;\n                sent = sent || params.response !== undefined;\n                sent = sent || this.input.value2str(this.value) !== this.input.value2str(params.newValue);\n\n                if (sent) {\n                    this.$element.removeClass(this.options.unsavedclass);\n                } else {\n                    this.$element.addClass(this.options.unsavedclass);\n                }\n            }\n\n            //highlight when saving\n            if (this.options.highlight) {\n                var $e = this.$element,\n                    bgColor = $e.css('background-color');\n\n                $e.css('background-color', this.options.highlight);\n                setTimeout(function () {\n                    if (bgColor === 'transparent') {\n                        bgColor = '';\n                    }\n                    $e.css('background-color', bgColor);\n                    $e.addClass('editable-bg-transition');\n                    setTimeout(function () {\n                        $e.removeClass('editable-bg-transition');\n                    }, 1700);\n                }, 10);\n            }\n\n            //set new value\n            this.setValue(params.newValue, false, params.response);\n\n            /**        \n            Fired when new value was submitted. You can use <code>$(this).data('editable')</code> to access to editable instance\n            \n            @event save \n            @param {Object} event event object\n            @param {Object} params additional params\n            @param {mixed} params.newValue submitted value\n            @param {Object} params.response ajax response\n            @example\n            $('#username').on('save', function(e, params) {\n                alert('Saved value: ' + params.newValue);\n            });\n            **/\n            //event itself is triggered by editableContainer. Description here is only for documentation              \n        },\n\n        validate: function validate() {\n            if (typeof this.options.validate === 'function') {\n                return this.options.validate.call(this, this.value);\n            }\n        },\n\n        /**\n        Sets new value of editable\n        @method setValue(value, convertStr)\n        @param {mixed} value new value \n        @param {boolean} convertStr whether to convert value from string to internal format\n        **/\n        setValue: function setValue(value, convertStr, response) {\n            if (convertStr) {\n                this.value = this.input.str2value(value);\n            } else {\n                this.value = value;\n            }\n            if (this.container) {\n                this.container.option('value', this.value);\n            }\n            $.when(this.render(response)).then($.proxy(function () {\n                this.handleEmpty();\n            }, this));\n        },\n\n        /**\n        Activates input of visible container (e.g. set focus)\n        @method activate()\n        **/\n        activate: function activate() {\n            if (this.container) {\n                this.container.activate();\n            }\n        },\n\n        /**\n        Removes editable feature from element\n        @method destroy()\n        **/\n        destroy: function destroy() {\n            this.disable();\n\n            if (this.container) {\n                this.container.destroy();\n            }\n\n            this.input.destroy();\n\n            if (this.options.toggle !== 'manual') {\n                this.$element.removeClass('editable-click');\n                this.$element.off(this.options.toggle + '.editable');\n            }\n\n            this.$element.off(\"save.internal\");\n\n            this.$element.removeClass('editable editable-open editable-disabled');\n            this.$element.removeData('editable');\n        }\n    };\n\n    /* EDITABLE PLUGIN DEFINITION\n    * ======================= */\n\n    /**\n    jQuery method to initialize editable element.\n    \n    @method $().editable(options)\n    @params {Object} options\n    @example\n    $('#username').editable({\n        type: 'text',\n        url: '/post',\n        pk: 1\n    });\n    **/\n    $.fn.editable = function (option) {\n        //special API methods returning non-jquery object\n        var result = {},\n            args = arguments,\n            datakey = 'editable';\n        switch (option) {\n            /**\n            Runs client-side validation for all matched editables\n            \n            @method validate()\n            @returns {Object} validation errors map\n            @example\n            $('#username, #fullname').editable('validate');\n            // possible result:\n            {\n              username: \"username is required\",\n              fullname: \"fullname should be minimum 3 letters length\"\n            }\n            **/\n            case 'validate':\n                this.each(function () {\n                    var $this = $(this),\n                        data = $this.data(datakey),\n                        error;\n                    if (data && (error = data.validate())) {\n                        result[data.options.name] = error;\n                    }\n                });\n                return result;\n\n            /**\n            Returns current values of editable elements.   \n            Note that it returns an **object** with name-value pairs, not a value itself. It allows to get data from several elements.    \n            If value of some editable is `null` or `undefined` it is excluded from result object.\n            When param `isSingle` is set to **true** - it is supposed you have single element and will return value of editable instead of object.   \n             \n            @method getValue()\n            @param {bool} isSingle whether to return just value of single element\n            @returns {Object} object of element names and values\n            @example\n            $('#username, #fullname').editable('getValue');\n            //result:\n            {\n            username: \"superuser\",\n            fullname: \"John\"\n            }\n            //isSingle = true\n            $('#username').editable('getValue', true);\n            //result \"superuser\" \n            **/\n            case 'getValue':\n                if (arguments.length === 2 && arguments[1] === true) {\n                    //isSingle = true\n                    result = this.eq(0).data(datakey).value;\n                } else {\n                    this.each(function () {\n                        var $this = $(this),\n                            data = $this.data(datakey);\n                        if (data && data.value !== undefined && data.value !== null) {\n                            result[data.options.name] = data.input.value2submit(data.value);\n                        }\n                    });\n                }\n                return result;\n\n            /**\n            This method collects values from several editable elements and submit them all to server.   \n            Internally it runs client-side validation for all fields and submits only in case of success.  \n            See <a href=\"#newrecord\">creating new records</a> for details.  \n            Since 1.5.1 `submit` can be applied to single element to send data programmatically. In that case\n            `url`, `success` and `error` is taken from initial options and you can just call `$('#username').editable('submit')`. \n            \n            @method submit(options)\n            @param {object} options \n            @param {object} options.url url to submit data \n            @param {object} options.data additional data to submit\n            @param {object} options.ajaxOptions additional ajax options\n            @param {function} options.error(obj) error handler \n            @param {function} options.success(obj,config) success handler\n            @returns {Object} jQuery object\n            **/\n            case 'submit':\n                //collects value, validate and submit to server for creating new record\n                var config = arguments[1] || {},\n                    $elems = this,\n                    errors = this.editable('validate');\n\n                // validation ok\n                if ($.isEmptyObject(errors)) {\n                    var ajaxOptions = {};\n\n                    // for single element use url, success etc from options\n                    if ($elems.length === 1) {\n                        var editable = $elems.data('editable');\n                        //standard params\n                        var params = {\n                            name: editable.options.name || '',\n                            value: editable.input.value2submit(editable.value),\n                            pk: typeof editable.options.pk === 'function' ? editable.options.pk.call(editable.options.scope) : editable.options.pk\n                        };\n\n                        //additional params\n                        if (typeof editable.options.params === 'function') {\n                            params = editable.options.params.call(editable.options.scope, params);\n                        } else {\n                            //try parse json in single quotes (from data-params attribute)\n                            editable.options.params = $.fn.editableutils.tryParseJson(editable.options.params, true);\n                            $.extend(params, editable.options.params);\n                        }\n\n                        ajaxOptions = {\n                            url: editable.options.url,\n                            data: params,\n                            type: 'POST'\n                        };\n\n                        // use success / error from options \n                        config.success = config.success || editable.options.success;\n                        config.error = config.error || editable.options.error;\n\n                        // multiple elements\n                    } else {\n                        var values = this.editable('getValue');\n\n                        ajaxOptions = {\n                            url: config.url,\n                            data: values,\n                            type: 'POST'\n                        };\n                    }\n\n                    // ajax success callabck (response 200 OK)\n                    ajaxOptions.success = typeof config.success === 'function' ? function (response) {\n                        config.success.call($elems, response, config);\n                    } : $.noop;\n\n                    // ajax error callabck\n                    ajaxOptions.error = typeof config.error === 'function' ? function () {\n                        config.error.apply($elems, arguments);\n                    } : $.noop;\n\n                    // extend ajaxOptions    \n                    if (config.ajaxOptions) {\n                        $.extend(ajaxOptions, config.ajaxOptions);\n                    }\n\n                    // extra data \n                    if (config.data) {\n                        $.extend(ajaxOptions.data, config.data);\n                    }\n\n                    // perform ajax request\n                    $.ajax(ajaxOptions);\n                } else {\n                    //client-side validation error\n                    if (typeof config.error === 'function') {\n                        config.error.call($elems, errors);\n                    }\n                }\n                return this;\n        }\n\n        //return jquery object\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data(datakey),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) === 'object' && option;\n\n            //for delegated targets do not store `editable` object for element\n            //it's allows several different selectors.\n            //see: https://github.com/vitalets/x-editable/issues/312    \n            if (options && options.selector) {\n                data = new Editable(this, options);\n                return;\n            }\n\n            if (!data) {\n                $this.data(datakey, data = new Editable(this, options));\n            }\n\n            if (typeof option === 'string') {\n                //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            }\n        });\n    };\n\n    $.fn.editable.defaults = {\n        /**\n        Type of input. Can be <code>text|textarea|select|date|checklist</code> and more\n         @property type \n        @type string\n        @default 'text'\n        **/\n        type: 'text',\n        /**\n        Sets disabled state of editable\n         @property disabled \n        @type boolean\n        @default false\n        **/\n        disabled: false,\n        /**\n        How to toggle editable. Can be <code>click|dblclick|mouseenter|manual</code>.   \n        When set to <code>manual</code> you should manually call <code>show/hide</code> methods of editable.    \n        **Note**: if you call <code>show</code> or <code>toggle</code> inside **click** handler of some DOM element, \n        you need to apply <code>e.stopPropagation()</code> because containers are being closed on any click on document.\n        \n        @example\n        $('#edit-button').click(function(e) {\n            e.stopPropagation();\n            $('#username').editable('toggle');\n        });\n         @property toggle \n        @type string\n        @default 'click'\n        **/\n        toggle: 'click',\n        /**\n        Text shown when element is empty.\n         @property emptytext \n        @type string\n        @default 'Empty'\n        **/\n        emptytext: 'Empty',\n        /**\n        Allows to automatically set element's text based on it's value. Can be <code>auto|always|never</code>. Useful for select and date.\n        For example, if dropdown list is <code>{1: 'a', 2: 'b'}</code> and element's value set to <code>1</code>, it's html will be automatically set to <code>'a'</code>.  \n        <code>auto</code> - text will be automatically set only if element is empty.  \n        <code>always|never</code> - always(never) try to set element's text.\n         @property autotext \n        @type string\n        @default 'auto'\n        **/\n        autotext: 'auto',\n        /**\n        Initial value of input. If not set, taken from element's text.  \n        Note, that if element's text is empty - text is automatically generated from value and can be customized (see `autotext` option).  \n        For example, to display currency sign:\n        @example\n        <a id=\"price\" data-type=\"text\" data-value=\"100\"></a>\n        <script>\n        $('#price').editable({\n            ...\n            display: function(value) {\n              $(this).text(value + '$');\n            } \n        }) \n        <\/script>\n                \n        @property value \n        @type mixed\n        @default element's text\n        **/\n        value: null,\n        /**\n        Callback to perform custom displaying of value in element's text.  \n        If `null`, default input's display used.  \n        If `false`, no displaying methods will be called, element's text will never change.  \n        Runs under element's scope.  \n        _**Parameters:**_  \n        \n        * `value` current value to be displayed\n        * `response` server response (if display called after ajax submit), since 1.4.0\n         \n        For _inputs with source_ (select, checklist) parameters are different:  \n          \n        * `value` current value to be displayed\n        * `sourceData` array of items for current input (e.g. dropdown items) \n        * `response` server response (if display called after ajax submit), since 1.4.0\n                  \n        To get currently selected items use `$.fn.editableutils.itemsByValue(value, sourceData)`.\n        \n        @property display \n        @type function|boolean\n        @default null\n        @since 1.2.0\n        @example\n        display: function(value, sourceData) {\n           //display checklist as comma-separated values\n           var html = [],\n               checked = $.fn.editableutils.itemsByValue(value, sourceData);\n               \n           if(checked.length) {\n               $.each(checked, function(i, v) { html.push($.fn.editableutils.escape(v.text)); });\n               $(this).html(html.join(', '));\n           } else {\n               $(this).empty(); \n           }\n        }\n        **/\n        display: null,\n        /**\n        Css class applied when editable text is empty.\n         @property emptyclass \n        @type string\n        @since 1.4.1        \n        @default editable-empty\n        **/\n        emptyclass: 'editable-empty',\n        /**\n        Css class applied when value was stored but not sent to server (`pk` is empty or `send = 'never'`).  \n        You may set it to `null` if you work with editables locally and submit them together.  \n         @property unsavedclass \n        @type string\n        @since 1.4.1        \n        @default editable-unsaved\n        **/\n        unsavedclass: 'editable-unsaved',\n        /**\n        If selector is provided, editable will be delegated to the specified targets.  \n        Usefull for dynamically generated DOM elements.  \n        **Please note**, that delegated targets can't be initialized with `emptytext` and `autotext` options, \n        as they actually become editable only after first click.  \n        You should manually set class `editable-click` to these elements.  \n        Also, if element originally empty you should add class `editable-empty`, set `data-value=\"\"` and write emptytext into element:\n         @property selector \n        @type string\n        @since 1.4.1        \n        @default null\n        @example\n        <div id=\"user\">\n          \x3c!-- empty --\x3e\n          <a href=\"#\" data-name=\"username\" data-type=\"text\" class=\"editable-click editable-empty\" data-value=\"\" title=\"Username\">Empty</a>\n          \x3c!-- non-empty --\x3e\n          <a href=\"#\" data-name=\"group\" data-type=\"select\" data-source=\"/groups\" data-value=\"1\" class=\"editable-click\" title=\"Group\">Operator</a>\n        </div>     \n        \n        <script>\n        $('#user').editable({\n            selector: 'a',\n            url: '/post',\n            pk: 1\n        });\n        <\/script>\n        **/\n        selector: null,\n        /**\n        Color used to highlight element after update. Implemented via CSS3 transition, works in modern browsers.\n        \n        @property highlight \n        @type string|boolean\n        @since 1.4.5        \n        @default #FFFF80 \n        **/\n        highlight: '#FFFF80'\n    };\n})(window.jQuery);\n\n/**\nAbstractInput - base class for all editable inputs.\nIt defines interface to be implemented by any input type.\nTo create your own input you can inherit from this class.\n\n@class abstractinput\n**/\n(function ($) {\n\n    //types\n    $.fn.editabletypes = {};\n\n    var AbstractInput = function AbstractInput() {};\n\n    AbstractInput.prototype = {\n        /**\n         Initializes input\n          @method init() \n         **/\n        init: function init(type, options, defaults) {\n            this.type = type;\n            this.options = $.extend({}, defaults, options);\n        },\n\n        /*\n        this method called before render to init $tpl that is inserted in DOM\n        */\n        prerender: function prerender() {\n            this.$tpl = $(this.options.tpl); //whole tpl as jquery object    \n            this.$input = this.$tpl; //control itself, can be changed in render method\n            this.$clear = null; //clear button\n            this.error = null; //error message, if input cannot be rendered           \n        },\n\n        /**\n         Renders input from tpl. Can return jQuery deferred object.\n         Can be overwritten in child objects\n          @method render()\n        **/\n        render: function render() {},\n\n        /**\n         Sets element's html by value. \n          @method value2html(value, element)\n         @param {mixed} value\n         @param {DOMElement} element\n        **/\n        value2html: function value2html(value, element) {\n            $(element)[this.options.escape ? 'text' : 'html']($.trim(value));\n        },\n\n        /**\n         Converts element's html to value\n          @method html2value(html)\n         @param {string} html\n         @returns {mixed}\n        **/\n        html2value: function html2value(html) {\n            return $('<div>').html(html).text();\n        },\n\n        /**\n         Converts value to string (for internal compare). For submitting to server used value2submit().\n          @method value2str(value) \n         @param {mixed} value\n         @returns {string}\n        **/\n        value2str: function value2str(value) {\n            return value;\n        },\n\n        /**\n         Converts string received from server into value. Usually from `data-value` attribute.\n          @method str2value(str)\n         @param {string} str\n         @returns {mixed}\n        **/\n        str2value: function str2value(str) {\n            return str;\n        },\n\n        /**\n         Converts value for submitting to server. Result can be string or object.\n          @method value2submit(value) \n         @param {mixed} value\n         @returns {mixed}\n        **/\n        value2submit: function value2submit(value) {\n            return value;\n        },\n\n        /**\n         Sets value of input.\n          @method value2input(value) \n         @param {mixed} value\n        **/\n        value2input: function value2input(value) {\n            this.$input.val(value);\n        },\n\n        /**\n         Returns value of input. Value can be object (e.g. datepicker)\n          @method input2value() \n        **/\n        input2value: function input2value() {\n            return this.$input.val();\n        },\n\n        /**\n         Activates input. For text it sets focus.\n          @method activate() \n        **/\n        activate: function activate() {\n            if (this.$input.is(':visible')) {\n                this.$input.focus();\n            }\n        },\n\n        /**\n         Creates input.\n          @method clear() \n        **/\n        clear: function clear() {\n            this.$input.val(null);\n        },\n\n        /**\n         method to escape html.\n        **/\n        escape: function escape(str) {\n            return $('<div>').text(str).html();\n        },\n\n        /**\n         attach handler to automatically submit form when value changed (useful when buttons not shown)\n        **/\n        autosubmit: function autosubmit() {},\n\n        /**\n        Additional actions when destroying element \n        **/\n        destroy: function destroy() {},\n\n        // -------- helper functions --------\n        setClass: function setClass() {\n            if (this.options.inputclass) {\n                this.$input.addClass(this.options.inputclass);\n            }\n        },\n\n        setAttr: function setAttr(attr) {\n            if (this.options[attr] !== undefined && this.options[attr] !== null) {\n                this.$input.attr(attr, this.options[attr]);\n            }\n        },\n\n        option: function option(key, value) {\n            this.options[key] = value;\n        }\n\n    };\n\n    AbstractInput.defaults = {\n        /**\n        HTML template of input. Normally you should not change it.\n         @property tpl \n        @type string\n        @default ''\n        **/\n        tpl: '',\n        /**\n        CSS class automatically applied to input\n        \n        @property inputclass \n        @type string\n        @default null\n        **/\n        inputclass: null,\n\n        /**\n        If `true` - html will be escaped in content of element via $.text() method.  \n        If `false` - html will not be escaped, $.html() used.  \n        When you use own `display` function, this option obviosly has no effect.\n        \n        @property escape \n        @type boolean\n        @since 1.5.0\n        @default true\n        **/\n        escape: true,\n\n        //scope for external methods (e.g. source defined as function)\n        //for internal use only\n        scope: null,\n\n        //need to re-declare showbuttons here to get it's value from common config (passed only options existing in defaults)\n        showbuttons: true\n    };\n\n    $.extend($.fn.editabletypes, { abstractinput: AbstractInput });\n})(window.jQuery);\n\n/**\nList - abstract class for inputs that have source option loaded from js array or via ajax\n\n@class list\n@extends abstractinput\n**/\n(function ($) {\n\n    var List = function List(options) {};\n\n    $.fn.editableutils.inherit(List, $.fn.editabletypes.abstractinput);\n\n    $.extend(List.prototype, {\n        render: function render() {\n            var deferred = $.Deferred();\n\n            this.error = null;\n            this.onSourceReady(function () {\n                this.renderList();\n                deferred.resolve();\n            }, function () {\n                this.error = this.options.sourceError;\n                deferred.resolve();\n            });\n\n            return deferred.promise();\n        },\n\n        html2value: function html2value(html) {\n            return null; //can't set value by text\n        },\n\n        value2html: function value2html(value, element, display, response) {\n            var deferred = $.Deferred(),\n                success = function success() {\n                if (typeof display === 'function') {\n                    //custom display method\n                    display.call(element, value, this.sourceData, response);\n                } else {\n                    this.value2htmlFinal(value, element);\n                }\n                deferred.resolve();\n            };\n\n            //for null value just call success without loading source\n            if (value === null) {\n                success.call(this);\n            } else {\n                this.onSourceReady(success, function () {\n                    deferred.resolve();\n                });\n            }\n\n            return deferred.promise();\n        },\n\n        // ------------- additional functions ------------\n\n        onSourceReady: function onSourceReady(success, error) {\n            //run source if it function\n            var source;\n            if ($.isFunction(this.options.source)) {\n                source = this.options.source.call(this.options.scope);\n                this.sourceData = null;\n                //note: if function returns the same source as URL - sourceData will be taken from cahce and no extra request performed\n            } else {\n                source = this.options.source;\n            }\n\n            //if allready loaded just call success\n            if (this.options.sourceCache && $.isArray(this.sourceData)) {\n                success.call(this);\n                return;\n            }\n\n            //try parse json in single quotes (for double quotes jquery does automatically)\n            try {\n                source = $.fn.editableutils.tryParseJson(source, false);\n            } catch (e) {\n                error.call(this);\n                return;\n            }\n\n            //loading from url\n            if (typeof source === 'string') {\n                //try to get sourceData from cache\n                if (this.options.sourceCache) {\n                    var cacheID = source,\n                        cache;\n\n                    if (!$(document).data(cacheID)) {\n                        $(document).data(cacheID, {});\n                    }\n                    cache = $(document).data(cacheID);\n\n                    //check for cached data\n                    if (cache.loading === false && cache.sourceData) {\n                        //take source from cache\n                        this.sourceData = cache.sourceData;\n                        this.doPrepend();\n                        success.call(this);\n                        return;\n                    } else if (cache.loading === true) {\n                        //cache is loading, put callback in stack to be called later\n                        cache.callbacks.push($.proxy(function () {\n                            this.sourceData = cache.sourceData;\n                            this.doPrepend();\n                            success.call(this);\n                        }, this));\n\n                        //also collecting error callbacks\n                        cache.err_callbacks.push($.proxy(error, this));\n                        return;\n                    } else {\n                        //no cache yet, activate it\n                        cache.loading = true;\n                        cache.callbacks = [];\n                        cache.err_callbacks = [];\n                    }\n                }\n\n                //ajaxOptions for source. Can be overwritten bt options.sourceOptions\n                var ajaxOptions = $.extend({\n                    url: source,\n                    type: 'get',\n                    cache: false,\n                    dataType: 'json',\n                    success: $.proxy(function (data) {\n                        if (cache) {\n                            cache.loading = false;\n                        }\n                        this.sourceData = this.makeArray(data);\n                        if ($.isArray(this.sourceData)) {\n                            if (cache) {\n                                //store result in cache\n                                cache.sourceData = this.sourceData;\n                                //run success callbacks for other fields waiting for this source\n                                $.each(cache.callbacks, function () {\n                                    this.call();\n                                });\n                            }\n                            this.doPrepend();\n                            success.call(this);\n                        } else {\n                            error.call(this);\n                            if (cache) {\n                                //run error callbacks for other fields waiting for this source\n                                $.each(cache.err_callbacks, function () {\n                                    this.call();\n                                });\n                            }\n                        }\n                    }, this),\n                    error: $.proxy(function () {\n                        error.call(this);\n                        if (cache) {\n                            cache.loading = false;\n                            //run error callbacks for other fields\n                            $.each(cache.err_callbacks, function () {\n                                this.call();\n                            });\n                        }\n                    }, this)\n                }, this.options.sourceOptions);\n\n                //loading sourceData from server\n                $.ajax(ajaxOptions);\n            } else {\n                //options as json/array\n                this.sourceData = this.makeArray(source);\n\n                if ($.isArray(this.sourceData)) {\n                    this.doPrepend();\n                    success.call(this);\n                } else {\n                    error.call(this);\n                }\n            }\n        },\n\n        doPrepend: function doPrepend() {\n            if (this.options.prepend === null || this.options.prepend === undefined) {\n                return;\n            }\n\n            if (!$.isArray(this.prependData)) {\n                //run prepend if it is function (once)\n                if ($.isFunction(this.options.prepend)) {\n                    this.options.prepend = this.options.prepend.call(this.options.scope);\n                }\n\n                //try parse json in single quotes\n                this.options.prepend = $.fn.editableutils.tryParseJson(this.options.prepend, true);\n\n                //convert prepend from string to object\n                if (typeof this.options.prepend === 'string') {\n                    this.options.prepend = { '': this.options.prepend };\n                }\n\n                this.prependData = this.makeArray(this.options.prepend);\n            }\n\n            if ($.isArray(this.prependData) && $.isArray(this.sourceData)) {\n                this.sourceData = this.prependData.concat(this.sourceData);\n            }\n        },\n\n        /*\n         renders input list\n        */\n        renderList: function renderList() {\n            // this method should be overwritten in child class\n        },\n\n        /*\n        set element's html by value\n        */\n        value2htmlFinal: function value2htmlFinal(value, element) {\n            // this method should be overwritten in child class\n        },\n\n        /**\n        * convert data to array suitable for sourceData, e.g. [{value: 1, text: 'abc'}, {...}]\n        */\n        makeArray: function makeArray(data) {\n            var count,\n                obj,\n                result = [],\n                item,\n                iterateItem;\n            if (!data || typeof data === 'string') {\n                return null;\n            }\n\n            if ($.isArray(data)) {\n                //array\n                /* \n                   function to iterate inside item of array if item is object.\n                   Caclulates count of keys in item and store in obj. \n                */\n                iterateItem = function iterateItem(k, v) {\n                    obj = { value: k, text: v };\n                    if (count++ >= 2) {\n                        return false; // exit from `each` if item has more than one key.\n                    }\n                };\n\n                for (var i = 0; i < data.length; i++) {\n                    item = data[i];\n                    if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {\n                        count = 0; //count of keys inside item\n                        $.each(item, iterateItem);\n                        //case: [{val1: 'text1'}, {val2: 'text2} ...]\n                        if (count === 1) {\n                            result.push(obj);\n                            //case: [{value: 1, text: 'text1'}, {value: 2, text: 'text2'}, ...]\n                        } else if (count > 1) {\n                            //removed check of existance: item.hasOwnProperty('value') && item.hasOwnProperty('text')\n                            if (item.children) {\n                                item.children = this.makeArray(item.children);\n                            }\n                            result.push(item);\n                        }\n                    } else {\n                        //case: ['text1', 'text2' ...]\n                        result.push({ value: item, text: item });\n                    }\n                }\n            } else {\n                //case: {val1: 'text1', val2: 'text2, ...}\n                $.each(data, function (k, v) {\n                    result.push({ value: k, text: v });\n                });\n            }\n            return result;\n        },\n\n        option: function option(key, value) {\n            this.options[key] = value;\n            if (key === 'source') {\n                this.sourceData = null;\n            }\n            if (key === 'prepend') {\n                this.prependData = null;\n            }\n        }\n\n    });\n\n    List.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        Source data for list.  \n        If **array** - it should be in format: `[{value: 1, text: \"text1\"}, {value: 2, text: \"text2\"}, ...]`  \n        For compability, object format is also supported: `{\"1\": \"text1\", \"2\": \"text2\" ...}` but it does not guarantee elements order.\n        \n        If **string** - considered ajax url to load items. In that case results will be cached for fields with the same source and name. See also `sourceCache` option.\n          \n        If **function**, it should return data in format above (since 1.4.0).\n        \n        Since 1.4.1 key `children` supported to render OPTGROUP (for **select** input only).  \n        `[{text: \"group1\", children: [{value: 1, text: \"text1\"}, {value: 2, text: \"text2\"}]}, ...]` \n            @property source \n        @type string | array | object | function\n        @default null\n        **/\n        source: null,\n        /**\n        Data automatically prepended to the beginning of dropdown list.\n        \n        @property prepend \n        @type string | array | object | function\n        @default false\n        **/\n        prepend: false,\n        /**\n        Error message when list cannot be loaded (e.g. ajax error)\n        \n        @property sourceError \n        @type string\n        @default Error when loading list\n        **/\n        sourceError: 'Error when loading list',\n        /**\n        if <code>true</code> and source is **string url** - results will be cached for fields with the same source.    \n        Usefull for editable column in grid to prevent extra requests.\n        \n        @property sourceCache \n        @type boolean\n        @default true\n        @since 1.2.0\n        **/\n        sourceCache: true,\n        /**\n        Additional ajax options to be used in $.ajax() when loading list from server.\n        Useful to send extra parameters (`data` key) or change request method (`type` key).\n        \n        @property sourceOptions \n        @type object|function\n        @default null\n        @since 1.5.0\n        **/\n        sourceOptions: null\n    });\n\n    $.fn.editabletypes.list = List;\n})(window.jQuery);\n\n/**\nText input\n\n@class text\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"username\" data-type=\"text\" data-pk=\"1\">awesome</a>\n<script>\n$(function(){\n    $('#username').editable({\n        url: '/post',\n        title: 'Enter username'\n    });\n});\n<\/script>\n**/\n(function ($) {\n\n    var Text = function Text(options) {\n        this.init('text', options, Text.defaults);\n    };\n\n    $.fn.editableutils.inherit(Text, $.fn.editabletypes.abstractinput);\n\n    $.extend(Text.prototype, {\n        render: function render() {\n            this.renderClear();\n            this.setClass();\n            this.setAttr('placeholder');\n        },\n\n        activate: function activate() {\n            if (this.$input.is(':visible')) {\n                this.$input.focus();\n                $.fn.editableutils.setCursorPosition(this.$input.get(0), this.$input.val().length);\n                if (this.toggleClear) {\n                    this.toggleClear();\n                }\n            }\n        },\n\n        //render clear button\n        renderClear: function renderClear() {\n            if (this.options.clear) {\n                this.$clear = $('<span class=\"editable-clear-x\"></span>');\n                this.$input.after(this.$clear).css('padding-right', 24).keyup($.proxy(function (e) {\n                    //arrows, enter, tab, etc\n                    if (~$.inArray(e.keyCode, [40, 38, 9, 13, 27])) {\n                        return;\n                    }\n\n                    clearTimeout(this.t);\n                    var that = this;\n                    this.t = setTimeout(function () {\n                        that.toggleClear(e);\n                    }, 100);\n                }, this)).parent().css('position', 'relative');\n\n                this.$clear.click($.proxy(this.clear, this));\n            }\n        },\n\n        postrender: function postrender() {\n            /*\n            //now `clear` is positioned via css\n            if(this.$clear) {\n                //can position clear button only here, when form is shown and height can be calculated\n            //                var h = this.$input.outerHeight(true) || 20,\n                var h = this.$clear.parent().height(),\n                    delta = (h - this.$clear.height()) / 2;\n                    \n                //this.$clear.css({bottom: delta, right: delta});\n            }\n            */\n        },\n\n        //show / hide clear button\n        toggleClear: function toggleClear(e) {\n            if (!this.$clear) {\n                return;\n            }\n\n            var len = this.$input.val().length,\n                visible = this.$clear.is(':visible');\n\n            if (len && !visible) {\n                this.$clear.show();\n            }\n\n            if (!len && visible) {\n                this.$clear.hide();\n            }\n        },\n\n        clear: function clear() {\n            this.$clear.hide();\n            this.$input.val('').focus();\n        }\n    });\n\n    Text.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"text\">\n        **/\n        tpl: '<input type=\"text\">',\n        /**\n        Placeholder attribute of input. Shown when input is empty.\n         @property placeholder \n        @type string\n        @default null\n        **/\n        placeholder: null,\n\n        /**\n        Whether to show `clear` button \n        \n        @property clear \n        @type boolean\n        @default true        \n        **/\n        clear: true\n    });\n\n    $.fn.editabletypes.text = Text;\n})(window.jQuery);\n\n/**\nTextarea input\n\n@class textarea\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"comments\" data-type=\"textarea\" data-pk=\"1\">awesome comment!</a>\n<script>\n$(function(){\n    $('#comments').editable({\n        url: '/post',\n        title: 'Enter comments',\n        rows: 10\n    });\n});\n<\/script>\n**/\n(function ($) {\n\n    var Textarea = function Textarea(options) {\n        this.init('textarea', options, Textarea.defaults);\n    };\n\n    $.fn.editableutils.inherit(Textarea, $.fn.editabletypes.abstractinput);\n\n    $.extend(Textarea.prototype, {\n        render: function render() {\n            this.setClass();\n            this.setAttr('placeholder');\n            this.setAttr('rows');\n\n            //ctrl + enter\n            this.$input.keydown(function (e) {\n                if (e.ctrlKey && e.which === 13) {\n                    $(this).closest('form').submit();\n                }\n            });\n        },\n\n        //using `white-space: pre-wrap` solves \\n  <--\x3e BR conversion very elegant!\n        /* \n        value2html: function(value, element) {\n             var html = '', lines;\n             if(value) {\n                 lines = value.split(\"\\n\");\n                 for (var i = 0; i < lines.length; i++) {\n                     lines[i] = $('<div>').text(lines[i]).html();\n                 }\n                 html = lines.join('<br>');\n             }\n             $(element).html(html);\n         },\n        \n         html2value: function(html) {\n             if(!html) {\n                 return '';\n             }\n              var regex = new RegExp(String.fromCharCode(10), 'g');\n             var lines = html.split(/<br\\s*\\/?>/i);\n             for (var i = 0; i < lines.length; i++) {\n                 var text = $('<div>').html(lines[i]).text();\n                  // Remove newline characters (\\n) to avoid them being converted by value2html() method\n                 // thus adding extra <br> tags\n                 text = text.replace(regex, '');\n                  lines[i] = text;\n             }\n             return lines.join(\"\\n\");\n         },\n          */\n        activate: function activate() {\n            $.fn.editabletypes.text.prototype.activate.call(this);\n        }\n    });\n\n    Textarea.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl\n        @default <textarea></textarea>\n        **/\n        tpl: '<textarea></textarea>',\n        /**\n        @property inputclass\n        @default input-large\n        **/\n        inputclass: 'input-large',\n        /**\n        Placeholder attribute of input. Shown when input is empty.\n         @property placeholder\n        @type string\n        @default null\n        **/\n        placeholder: null,\n        /**\n        Number of rows in textarea\n         @property rows\n        @type integer\n        @default 7\n        **/\n        rows: 7\n    });\n\n    $.fn.editabletypes.textarea = Textarea;\n})(window.jQuery);\n\n/**\nSelect (dropdown)\n\n@class select\n@extends list\n@final\n@example\n<a href=\"#\" id=\"status\" data-type=\"select\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select status\"></a>\n<script>\n$(function(){\n    $('#status').editable({\n        value: 2,    \n        source: [\n              {value: 1, text: 'Active'},\n              {value: 2, text: 'Blocked'},\n              {value: 3, text: 'Deleted'}\n           ]\n    });\n});\n<\/script>\n**/\n(function ($) {\n    ;\n\n    var Select = function Select(options) {\n        this.init('select', options, Select.defaults);\n    };\n\n    $.fn.editableutils.inherit(Select, $.fn.editabletypes.list);\n\n    $.extend(Select.prototype, {\n        renderList: function renderList() {\n            this.$input.empty();\n\n            var fillItems = function fillItems($el, data) {\n                var attr;\n                if ($.isArray(data)) {\n                    for (var i = 0; i < data.length; i++) {\n                        attr = {};\n                        if (data[i].children) {\n                            attr.label = data[i].text;\n                            $el.append(fillItems($('<optgroup>', attr), data[i].children));\n                        } else {\n                            attr.value = data[i].value;\n                            if (data[i].disabled) {\n                                attr.disabled = true;\n                            }\n                            $el.append($('<option>', attr).text(data[i].text));\n                        }\n                    }\n                }\n                return $el;\n            };\n\n            fillItems(this.$input, this.sourceData);\n\n            this.setClass();\n\n            //enter submit\n            this.$input.on('keydown.editable', function (e) {\n                if (e.which === 13) {\n                    $(this).closest('form').submit();\n                }\n            });\n        },\n\n        value2htmlFinal: function value2htmlFinal(value, element) {\n            var text = '',\n                items = $.fn.editableutils.itemsByValue(value, this.sourceData);\n\n            if (items.length) {\n                text = items[0].text;\n            }\n\n            //$(element).text(text);\n            $.fn.editabletypes.abstractinput.prototype.value2html.call(this, text, element);\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.off('keydown.editable').on('change.editable', function () {\n                $(this).closest('form').submit();\n            });\n        }\n    });\n\n    Select.defaults = $.extend({}, $.fn.editabletypes.list.defaults, {\n        /**\n        @property tpl \n        @default <select></select>\n        **/\n        tpl: '<select></select>'\n    });\n\n    $.fn.editabletypes.select = Select;\n})(window.jQuery);\n\n/**\nList of checkboxes. \nInternally value stored as javascript array of values.\n\n@class checklist\n@extends list\n@final\n@example\n<a href=\"#\" id=\"options\" data-type=\"checklist\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select options\"></a>\n<script>\n$(function(){\n    $('#options').editable({\n        value: [2, 3],    \n        source: [\n              {value: 1, text: 'option1'},\n              {value: 2, text: 'option2'},\n              {value: 3, text: 'option3'}\n           ]\n    });\n});\n<\/script>\n**/\n(function ($) {\n    ;\n\n    var Checklist = function Checklist(options) {\n        this.init('checklist', options, Checklist.defaults);\n    };\n\n    $.fn.editableutils.inherit(Checklist, $.fn.editabletypes.list);\n\n    $.extend(Checklist.prototype, {\n        renderList: function renderList() {\n            var $label, $div;\n\n            this.$tpl.empty();\n\n            if (!$.isArray(this.sourceData)) {\n                return;\n            }\n\n            for (var i = 0; i < this.sourceData.length; i++) {\n                $label = $('<label>').append($('<input>', {\n                    type: 'checkbox',\n                    value: this.sourceData[i].value\n                })).append($('<span>').text(' ' + this.sourceData[i].text));\n\n                $('<div>').append($label).appendTo(this.$tpl);\n            }\n\n            this.$input = this.$tpl.find('input[type=\"checkbox\"]');\n            this.setClass();\n        },\n\n        value2str: function value2str(value) {\n            return $.isArray(value) ? value.sort().join($.trim(this.options.separator)) : '';\n        },\n\n        //parse separated string\n        str2value: function str2value(str) {\n            var reg,\n                value = null;\n            if (typeof str === 'string' && str.length) {\n                reg = new RegExp('\\\\s*' + $.trim(this.options.separator) + '\\\\s*');\n                value = str.split(reg);\n            } else if ($.isArray(str)) {\n                value = str;\n            } else {\n                value = [str];\n            }\n            return value;\n        },\n\n        //set checked on required checkboxes\n        value2input: function value2input(value) {\n            this.$input.prop('checked', false);\n            if ($.isArray(value) && value.length) {\n                this.$input.each(function (i, el) {\n                    var $el = $(el);\n                    // cannot use $.inArray as it performs strict comparison\n                    $.each(value, function (j, val) {\n                        /*jslint eqeq: true*/\n                        if ($el.val() == val) {\n                            /*jslint eqeq: false*/\n                            $el.prop('checked', true);\n                        }\n                    });\n                });\n            }\n        },\n\n        input2value: function input2value() {\n            var checked = [];\n            this.$input.filter(':checked').each(function (i, el) {\n                checked.push($(el).val());\n            });\n            return checked;\n        },\n\n        //collect text of checked boxes\n        value2htmlFinal: function value2htmlFinal(value, element) {\n            var html = [],\n                checked = $.fn.editableutils.itemsByValue(value, this.sourceData),\n                escape = this.options.escape;\n\n            if (checked.length) {\n                $.each(checked, function (i, v) {\n                    var text = escape ? $.fn.editableutils.escape(v.text) : v.text;\n                    html.push(text);\n                });\n                $(element).html(html.join('<br>'));\n            } else {\n                $(element).empty();\n            }\n        },\n\n        activate: function activate() {\n            this.$input.first().focus();\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.on('keydown', function (e) {\n                if (e.which === 13) {\n                    $(this).closest('form').submit();\n                }\n            });\n        }\n    });\n\n    Checklist.defaults = $.extend({}, $.fn.editabletypes.list.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/\n        tpl: '<div class=\"editable-checklist\"></div>',\n\n        /**\n        @property inputclass \n        @type string\n        @default null\n        **/\n        inputclass: null,\n\n        /**\n        Separator of values when reading from `data-value` attribute\n         @property separator \n        @type string\n        @default ','\n        **/\n        separator: ','\n    });\n\n    $.fn.editabletypes.checklist = Checklist;\n})(window.jQuery);\n\n/**\nHTML5 input types.\nFollowing types are supported:\n\n* password\n* email\n* url\n* tel\n* number\n* range\n* time\n\nLearn more about html5 inputs:  \nhttp://www.w3.org/wiki/HTML5_form_additions  \nTo check browser compatibility please see:  \nhttps://developer.mozilla.org/en-US/docs/HTML/Element/Input\n            \n@class html5types \n@extends text\n@final\n@since 1.3.0\n@example\n<a href=\"#\" id=\"email\" data-type=\"email\" data-pk=\"1\">admin@example.com</a>\n<script>\n$(function(){\n    $('#email').editable({\n        url: '/post',\n        title: 'Enter email'\n    });\n});\n<\/script>\n**/\n\n/**\n@property tpl \n@default depends on type\n**/\n\n/*\nPassword\n*/\n(function ($) {\n    ;\n\n    var Password = function Password(options) {\n        this.init('password', options, Password.defaults);\n    };\n    $.fn.editableutils.inherit(Password, $.fn.editabletypes.text);\n    $.extend(Password.prototype, {\n        //do not display password, show '[hidden]' instead\n        value2html: function value2html(value, element) {\n            if (value) {\n                $(element).text('[hidden]');\n            } else {\n                $(element).empty();\n            }\n        },\n        //as password not displayed, should not set value by html\n        html2value: function html2value(html) {\n            return null;\n        }\n    });\n    Password.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"password\">'\n    });\n    $.fn.editabletypes.password = Password;\n})(window.jQuery);\n\n/*\nEmail\n*/\n(function ($) {\n    ;\n\n    var Email = function Email(options) {\n        this.init('email', options, Email.defaults);\n    };\n    $.fn.editableutils.inherit(Email, $.fn.editabletypes.text);\n    Email.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"email\">'\n    });\n    $.fn.editabletypes.email = Email;\n})(window.jQuery);\n\n/*\nUrl\n*/\n(function ($) {\n    ;\n\n    var Url = function Url(options) {\n        this.init('url', options, Url.defaults);\n    };\n    $.fn.editableutils.inherit(Url, $.fn.editabletypes.text);\n    Url.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"url\">'\n    });\n    $.fn.editabletypes.url = Url;\n})(window.jQuery);\n\n/*\nTel\n*/\n(function ($) {\n    ;\n\n    var Tel = function Tel(options) {\n        this.init('tel', options, Tel.defaults);\n    };\n    $.fn.editableutils.inherit(Tel, $.fn.editabletypes.text);\n    Tel.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"tel\">'\n    });\n    $.fn.editabletypes.tel = Tel;\n})(window.jQuery);\n\n/*\nNumber\n*/\n(function ($) {\n    ;\n\n    var NumberInput = function NumberInput(options) {\n        this.init('number', options, NumberInput.defaults);\n    };\n    $.fn.editableutils.inherit(NumberInput, $.fn.editabletypes.text);\n    $.extend(NumberInput.prototype, {\n        render: function render() {\n            NumberInput.superclass.render.call(this);\n            this.setAttr('min');\n            this.setAttr('max');\n            this.setAttr('step');\n        },\n        postrender: function postrender() {\n            if (this.$clear) {\n                //increase right ffset  for up/down arrows\n                this.$clear.css({ right: 24 });\n                /*\n                //can position clear button only here, when form is shown and height can be calculated\n                var h = this.$input.outerHeight(true) || 20,\n                    delta = (h - this.$clear.height()) / 2;\n                \n                //add 12px to offset right for up/down arrows    \n                this.$clear.css({top: delta, right: delta + 16});\n                */\n            }\n        }\n    });\n    NumberInput.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"number\">',\n        inputclass: 'input-mini',\n        min: null,\n        max: null,\n        step: null\n    });\n    $.fn.editabletypes.number = NumberInput;\n})(window.jQuery);\n\n/*\nRange (inherit from number)\n*/\n(function ($) {\n    ;\n\n    var Range = function Range(options) {\n        this.init('range', options, Range.defaults);\n    };\n    $.fn.editableutils.inherit(Range, $.fn.editabletypes.number);\n    $.extend(Range.prototype, {\n        render: function render() {\n            this.$input = this.$tpl.filter('input');\n\n            this.setClass();\n            this.setAttr('min');\n            this.setAttr('max');\n            this.setAttr('step');\n\n            this.$input.on('input', function () {\n                $(this).siblings('output').text($(this).val());\n            });\n        },\n        activate: function activate() {\n            this.$input.focus();\n        }\n    });\n    Range.defaults = $.extend({}, $.fn.editabletypes.number.defaults, {\n        tpl: '<input type=\"range\"><output style=\"width: 30px; display: inline-block\"></output>',\n        inputclass: 'input-medium'\n    });\n    $.fn.editabletypes.range = Range;\n})(window.jQuery);\n\n/*\nTime\n*/\n(function ($) {\n    ;\n\n    var Time = function Time(options) {\n        this.init('time', options, Time.defaults);\n    };\n    //inherit from abstract, as inheritance from text gives selection error.\n    $.fn.editableutils.inherit(Time, $.fn.editabletypes.abstractinput);\n    $.extend(Time.prototype, {\n        render: function render() {\n            this.setClass();\n        }\n    });\n    Time.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        tpl: '<input type=\"time\">'\n    });\n    $.fn.editabletypes.time = Time;\n})(window.jQuery);\n\n/**\nSelect2 input. Based on amazing work of Igor Vaynberg https://github.com/ivaynberg/select2.  \nPlease see [original select2 docs](http://ivaynberg.github.com/select2) for detailed description and options.  \n \nYou should manually download and include select2 distributive:  \n\n    <link href=\"select2/select2.css\" rel=\"stylesheet\" type=\"text/css\"></link>  \n    <script src=\"select2/select2.js\"><\/script>  \n    \nTo make it **bootstrap-styled** you can use css from [here](https://github.com/t0m/select2-bootstrap-css): \n\n    <link href=\"select2-bootstrap.css\" rel=\"stylesheet\" type=\"text/css\"></link>    \n    \n**Note:** currently `autotext` feature does not work for select2 with `ajax` remote source.    \nYou need initially put both `data-value` and element's text youself:    \n\n    <a href=\"#\" data-type=\"select2\" data-value=\"1\">Text1</a>\n    \n    \n@class select2\n@extends abstractinput\n@since 1.4.1\n@final\n@example\n<a href=\"#\" id=\"country\" data-type=\"select2\" data-pk=\"1\" data-value=\"ru\" data-url=\"/post\" data-title=\"Select country\"></a>\n<script>\n$(function(){\n    //local source\n    $('#country').editable({\n        source: [\n              {id: 'gb', text: 'Great Britain'},\n              {id: 'us', text: 'United States'},\n              {id: 'ru', text: 'Russia'}\n           ],\n        select2: {\n           multiple: true\n        }\n    });\n    //remote source (simple)\n    $('#country').editable({\n        source: '/getCountries',\n        select2: {\n            placeholder: 'Select Country',\n            minimumInputLength: 1\n        }\n    });\n    //remote source (advanced)\n    $('#country').editable({\n        select2: {\n            placeholder: 'Select Country',\n            allowClear: true,\n            minimumInputLength: 3,\n            id: function (item) {\n                return item.CountryId;\n            },\n            ajax: {\n                url: '/getCountries',\n                dataType: 'json',\n                data: function (term, page) {\n                    return { query: term };\n                },\n                results: function (data, page) {\n                    return { results: data };\n                }\n            },\n            formatResult: function (item) {\n                return item.CountryName;\n            },\n            formatSelection: function (item) {\n                return item.CountryName;\n            },\n            initSelection: function (element, callback) {\n                return $.get('/getCountryById', { query: element.val() }, function (data) {\n                    callback(data);\n                });\n            } \n        }  \n    });\n});\n<\/script>\n**/\n(function ($) {\n    ;\n\n    var Constructor = function Constructor(options) {\n        this.init('select2', options, Constructor.defaults);\n\n        options.select2 = options.select2 || {};\n\n        this.sourceData = null;\n\n        //placeholder\n        if (options.placeholder) {\n            options.select2.placeholder = options.placeholder;\n        }\n\n        //if not `tags` mode, use source\n        if (!options.select2.tags && options.source) {\n            var source = options.source;\n            //if source is function, call it (once!)\n            if ($.isFunction(options.source)) {\n                source = options.source.call(options.scope);\n            }\n\n            if (typeof source === 'string') {\n                options.select2.ajax = options.select2.ajax || {};\n                //some default ajax params\n                if (!options.select2.ajax.data) {\n                    options.select2.ajax.data = function (term) {\n                        return { query: term };\n                    };\n                }\n                if (!options.select2.ajax.results) {\n                    options.select2.ajax.results = function (data) {\n                        return { results: data };\n                    };\n                }\n                options.select2.ajax.url = source;\n            } else {\n                //check format and convert x-editable format to select2 format (if needed)\n                this.sourceData = this.convertSource(source);\n                options.select2.data = this.sourceData;\n            }\n        }\n\n        //overriding objects in config (as by default jQuery extend() is not recursive)\n        this.options.select2 = $.extend({}, Constructor.defaults.select2, options.select2);\n\n        //detect whether it is multi-valued\n        this.isMultiple = this.options.select2.tags || this.options.select2.multiple;\n        this.isRemote = 'ajax' in this.options.select2;\n\n        //store function returning ID of item\n        //should be here as used inautotext for local source\n        this.idFunc = this.options.select2.id;\n        if (typeof this.idFunc !== \"function\") {\n            var idKey = this.idFunc || 'id';\n            this.idFunc = function (e) {\n                return e[idKey];\n            };\n        }\n\n        //store function that renders text in select2\n        this.formatSelection = this.options.select2.formatSelection;\n        if (typeof this.formatSelection !== \"function\") {\n            this.formatSelection = function (e) {\n                return e.text;\n            };\n        }\n    };\n\n    $.fn.editableutils.inherit(Constructor, $.fn.editabletypes.abstractinput);\n\n    $.extend(Constructor.prototype, {\n        render: function render() {\n            this.setClass();\n\n            //can not apply select2 here as it calls initSelection \n            //over input that does not have correct value yet.\n            //apply select2 only in value2input\n            //this.$input.select2(this.options.select2);\n\n            //when data is loaded via ajax, we need to know when it's done to populate listData\n            if (this.isRemote) {\n                //listen to loaded event to populate data\n                this.$input.on('select2-loaded', $.proxy(function (e) {\n                    this.sourceData = e.items.results;\n                }, this));\n            }\n\n            //trigger resize of editableform to re-position container in multi-valued mode\n            if (this.isMultiple) {\n                this.$input.on('change', function () {\n                    $(this).closest('form').parent().triggerHandler('resize');\n                });\n            }\n        },\n\n        value2html: function value2html(value, element) {\n            var text = '',\n                data,\n                that = this;\n\n            if (this.options.select2.tags) {\n                //in tags mode just assign value\n                data = value;\n                //data = $.fn.editableutils.itemsByValue(value, this.options.select2.tags, this.idFunc);\n            } else if (this.sourceData) {\n                data = $.fn.editableutils.itemsByValue(value, this.sourceData, this.idFunc);\n            } else {}\n            //can not get list of possible values \n            //(e.g. autotext for select2 with ajax source)\n\n\n            //data may be array (when multiple values allowed)\n            if ($.isArray(data)) {\n                //collect selected data and show with separator\n                text = [];\n                $.each(data, function (k, v) {\n                    text.push(v && (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' ? that.formatSelection(v) : v);\n                });\n            } else if (data) {\n                text = that.formatSelection(data);\n            }\n\n            text = $.isArray(text) ? text.join(this.options.viewseparator) : text;\n\n            //$(element).text(text);\n            Constructor.superclass.value2html.call(this, text, element);\n        },\n\n        html2value: function html2value(html) {\n            return this.options.select2.tags ? this.str2value(html, this.options.viewseparator) : null;\n        },\n\n        value2input: function value2input(value) {\n            // if value array => join it anyway\n            if ($.isArray(value)) {\n                value = value.join(this.getSeparator());\n            }\n\n            //for remote source just set value, text is updated by initSelection\n            if (!this.$input.data('select2')) {\n                this.$input.val(value);\n                this.$input.select2(this.options.select2);\n            } else {\n                //second argument needed to separate initial change from user's click (for autosubmit)   \n                this.$input.val(value).trigger('change', true);\n\n                //Uncaught Error: cannot call val() if initSelection() is not defined\n                //this.$input.select2('val', value);\n            }\n\n            // if defined remote source AND no multiple mode AND no user's initSelection provided --\x3e \n            // we should somehow get text for provided id.\n            // The solution is to use element's text as text for that id (exclude empty)\n            if (this.isRemote && !this.isMultiple && !this.options.select2.initSelection) {\n                // customId and customText are methods to extract `id` and `text` from data object\n                // we can use this workaround only if user did not define these methods\n                // otherwise we cant construct data object\n                var customId = this.options.select2.id,\n                    customText = this.options.select2.formatSelection;\n\n                if (!customId && !customText) {\n                    var $el = $(this.options.scope);\n                    if (!$el.data('editable').isEmpty) {\n                        var data = { id: value, text: $el.text() };\n                        this.$input.select2('data', data);\n                    }\n                }\n            }\n        },\n\n        input2value: function input2value() {\n            return this.$input.select2('val');\n        },\n\n        str2value: function str2value(str, separator) {\n            if (typeof str !== 'string' || !this.isMultiple) {\n                return str;\n            }\n\n            separator = separator || this.getSeparator();\n\n            var val, i, l;\n\n            if (str === null || str.length < 1) {\n                return null;\n            }\n            val = str.split(separator);\n            for (i = 0, l = val.length; i < l; i = i + 1) {\n                val[i] = $.trim(val[i]);\n            }\n\n            return val;\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.on('change', function (e, isInitial) {\n                if (!isInitial) {\n                    $(this).closest('form').submit();\n                }\n            });\n        },\n\n        getSeparator: function getSeparator() {\n            return this.options.select2.separator || $.fn.select2.defaults.separator;\n        },\n\n        /*\n        Converts source from x-editable format: {value: 1, text: \"1\"} to\n        select2 format: {id: 1, text: \"1\"}\n        */\n        convertSource: function convertSource(source) {\n            if ($.isArray(source) && source.length && source[0].value !== undefined) {\n                for (var i = 0; i < source.length; i++) {\n                    if (source[i].value !== undefined) {\n                        source[i].id = source[i].value;\n                        delete source[i].value;\n                    }\n                }\n            }\n            return source;\n        },\n\n        destroy: function destroy() {\n            if (this.$input.data('select2')) {\n                this.$input.select2('destroy');\n            }\n        }\n\n    });\n\n    Constructor.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"hidden\">\n        **/\n        tpl: '<input type=\"hidden\">',\n        /**\n        Configuration of select2. [Full list of options](http://ivaynberg.github.com/select2).\n         @property select2 \n        @type object\n        @default null\n        **/\n        select2: null,\n        /**\n        Placeholder attribute of select\n         @property placeholder \n        @type string\n        @default null\n        **/\n        placeholder: null,\n        /**\n        Source data for select. It will be assigned to select2 `data` property and kept here just for convenience.\n        Please note, that format is different from simple `select` input: use 'id' instead of 'value'.\n        E.g. `[{id: 1, text: \"text1\"}, {id: 2, text: \"text2\"}, ...]`.\n         @property source \n        @type array|string|function\n        @default null        \n        **/\n        source: null,\n        /**\n        Separator used to display tags.\n         @property viewseparator \n        @type string\n        @default ', '        \n        **/\n        viewseparator: ', '\n    });\n\n    $.fn.editabletypes.select2 = Constructor;\n})(window.jQuery);\n\n/**\n* Combodate - 1.0.5\n* Dropdown date and time picker.\n* Converts text input into dropdowns to pick day, month, year, hour, minute and second.\n* Uses momentjs as datetime library http://momentjs.com.\n* For i18n include corresponding file from https://github.com/timrwood/moment/tree/master/lang \n*\n* Confusion at noon and midnight - see http://en.wikipedia.org/wiki/12-hour_clock#Confusion_at_noon_and_midnight\n* In combodate: \n* 12:00 pm --\x3e 12:00 (24-h format, midday)\n* 12:00 am --\x3e 00:00 (24-h format, midnight, start of day)\n* \n* Differs from momentjs parse rules:\n* 00:00 pm, 12:00 pm --\x3e 12:00 (24-h format, day not change)\n* 00:00 am, 12:00 am --\x3e 00:00 (24-h format, day not change)\n* \n* \n* Author: Vitaliy Potapov\n* Project page: http://github.com/vitalets/combodate\n* Copyright (c) 2012 Vitaliy Potapov. Released under MIT License.\n**/\n(function ($) {\n\n    var Combodate = function Combodate(element, options) {\n        this.$element = $(element);\n        if (!this.$element.is('input')) {\n            $.error('Combodate should be applied to INPUT element');\n            return;\n        }\n        this.options = $.extend({}, $.fn.combodate.defaults, options, this.$element.data());\n        this.init();\n    };\n\n    Combodate.prototype = {\n        constructor: Combodate,\n        init: function init() {\n            this.map = {\n                //key   regexp    moment.method\n                day: ['D', 'date'],\n                month: ['M', 'month'],\n                year: ['Y', 'year'],\n                hour: ['[Hh]', 'hours'],\n                minute: ['m', 'minutes'],\n                second: ['s', 'seconds'],\n                ampm: ['[Aa]', '']\n            };\n\n            this.$widget = $('<span class=\"combodate\"></span>').html(this.getTemplate());\n\n            this.initCombos();\n\n            //update original input on change \n            this.$widget.on('change', 'select', $.proxy(function (e) {\n                this.$element.val(this.getValue()).change();\n                // update days count if month or year changes\n                if (this.options.smartDays) {\n                    if ($(e.target).is('.month') || $(e.target).is('.year')) {\n                        this.fillCombo('day');\n                    }\n                }\n            }, this));\n\n            this.$widget.find('select').css('width', 'auto');\n\n            // hide original input and insert widget                                       \n            this.$element.hide().after(this.$widget);\n\n            // set initial value\n            this.setValue(this.$element.val() || this.options.value);\n        },\n\n        /*\n         Replace tokens in template with <select> elements \n        */\n        getTemplate: function getTemplate() {\n            var tpl = this.options.template;\n\n            //first pass\n            $.each(this.map, function (k, v) {\n                v = v[0];\n                var r = new RegExp(v + '+'),\n                    token = v.length > 1 ? v.substring(1, 2) : v;\n\n                tpl = tpl.replace(r, '{' + token + '}');\n            });\n\n            //replace spaces with &nbsp;\n            tpl = tpl.replace(/ /g, '&nbsp;');\n\n            //second pass\n            $.each(this.map, function (k, v) {\n                v = v[0];\n                var token = v.length > 1 ? v.substring(1, 2) : v;\n\n                tpl = tpl.replace('{' + token + '}', '<select class=\"' + k + '\"></select>');\n            });\n\n            return tpl;\n        },\n\n        /*\n         Initialize combos that presents in template \n        */\n        initCombos: function initCombos() {\n            for (var k in this.map) {\n                var $c = this.$widget.find('.' + k);\n                // set properties like this.$day, this.$month etc.\n                this['$' + k] = $c.length ? $c : null;\n                // fill with items\n                this.fillCombo(k);\n            }\n        },\n\n        /*\n         Fill combo with items \n        */\n        fillCombo: function fillCombo(k) {\n            var $combo = this['$' + k];\n            if (!$combo) {\n                return;\n            }\n\n            // define method name to fill items, e.g `fillDays`\n            var f = 'fill' + k.charAt(0).toUpperCase() + k.slice(1);\n            var items = this[f]();\n            var value = $combo.val();\n\n            $combo.empty();\n            for (var i = 0; i < items.length; i++) {\n                $combo.append('<option value=\"' + items[i][0] + '\">' + items[i][1] + '</option>');\n            }\n\n            $combo.val(value);\n        },\n\n        /*\n         Initialize items of combos. Handles `firstItem` option \n        */\n        fillCommon: function fillCommon(key) {\n            var values = [],\n                relTime;\n\n            if (this.options.firstItem === 'name') {\n                //need both to support moment ver < 2 and  >= 2\n                relTime = moment.relativeTime || moment.langData()._relativeTime;\n                var header = typeof relTime[key] === 'function' ? relTime[key](1, true, key, false) : relTime[key];\n                //take last entry (see momentjs lang files structure) \n                header = header.split(' ').reverse()[0];\n                values.push(['', header]);\n            } else if (this.options.firstItem === 'empty') {\n                values.push(['', '']);\n            }\n            return values;\n        },\n\n        /*\n        fill day\n        */\n        fillDay: function fillDay() {\n            var items = this.fillCommon('d'),\n                name,\n                i,\n                twoDigit = this.options.template.indexOf('DD') !== -1,\n                daysCount = 31;\n\n            // detect days count (depends on month and year)\n            // originally https://github.com/vitalets/combodate/pull/7\n            if (this.options.smartDays && this.$month && this.$year) {\n                var month = parseInt(this.$month.val(), 10);\n                var year = parseInt(this.$year.val(), 10);\n\n                if (!isNaN(month) && !isNaN(year)) {\n                    daysCount = moment([year, month]).daysInMonth();\n                }\n            }\n\n            for (i = 1; i <= daysCount; i++) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill month\n        */\n        fillMonth: function fillMonth() {\n            var items = this.fillCommon('M'),\n                name,\n                i,\n                longNames = this.options.template.indexOf('MMMM') !== -1,\n                shortNames = this.options.template.indexOf('MMM') !== -1,\n                twoDigit = this.options.template.indexOf('MM') !== -1;\n\n            for (i = 0; i <= 11; i++) {\n                if (longNames) {\n                    //see https://github.com/timrwood/momentjs.com/pull/36\n                    name = moment().date(1).month(i).format('MMMM');\n                } else if (shortNames) {\n                    name = moment().date(1).month(i).format('MMM');\n                } else if (twoDigit) {\n                    name = this.leadZero(i + 1);\n                } else {\n                    name = i + 1;\n                }\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill year\n        */\n        fillYear: function fillYear() {\n            var items = [],\n                name,\n                i,\n                longNames = this.options.template.indexOf('YYYY') !== -1;\n\n            for (i = this.options.maxYear; i >= this.options.minYear; i--) {\n                name = longNames ? i : (i + '').substring(2);\n                items[this.options.yearDescending ? 'push' : 'unshift']([i, name]);\n            }\n\n            items = this.fillCommon('y').concat(items);\n\n            return items;\n        },\n\n        /*\n        fill hour\n        */\n        fillHour: function fillHour() {\n            var items = this.fillCommon('h'),\n                name,\n                i,\n                h12 = this.options.template.indexOf('h') !== -1,\n                h24 = this.options.template.indexOf('H') !== -1,\n                twoDigit = this.options.template.toLowerCase().indexOf('hh') !== -1,\n                min = h12 ? 1 : 0,\n                max = h12 ? 12 : 23;\n\n            for (i = min; i <= max; i++) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill minute\n        */\n        fillMinute: function fillMinute() {\n            var items = this.fillCommon('m'),\n                name,\n                i,\n                twoDigit = this.options.template.indexOf('mm') !== -1;\n\n            for (i = 0; i <= 59; i += this.options.minuteStep) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill second\n        */\n        fillSecond: function fillSecond() {\n            var items = this.fillCommon('s'),\n                name,\n                i,\n                twoDigit = this.options.template.indexOf('ss') !== -1;\n\n            for (i = 0; i <= 59; i += this.options.secondStep) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill ampm\n        */\n        fillAmpm: function fillAmpm() {\n            var ampmL = this.options.template.indexOf('a') !== -1,\n                ampmU = this.options.template.indexOf('A') !== -1,\n                items = [['am', ampmL ? 'am' : 'AM'], ['pm', ampmL ? 'pm' : 'PM']];\n            return items;\n        },\n\n        /*\n         Returns current date value from combos. \n         If format not specified - `options.format` used.\n         If format = `null` - Moment object returned.\n        */\n        getValue: function getValue(format) {\n            var dt,\n                values = {},\n                that = this,\n                notSelected = false;\n\n            //getting selected values    \n            $.each(this.map, function (k, v) {\n                if (k === 'ampm') {\n                    return;\n                }\n                var def = k === 'day' ? 1 : 0;\n\n                values[k] = that['$' + k] ? parseInt(that['$' + k].val(), 10) : def;\n\n                if (isNaN(values[k])) {\n                    notSelected = true;\n                    return false;\n                }\n            });\n\n            //if at least one visible combo not selected - return empty string\n            if (notSelected) {\n                return '';\n            }\n\n            //convert hours 12h --\x3e 24h \n            if (this.$ampm) {\n                //12:00 pm --\x3e 12:00 (24-h format, midday), 12:00 am --\x3e 00:00 (24-h format, midnight, start of day)\n                if (values.hour === 12) {\n                    values.hour = this.$ampm.val() === 'am' ? 0 : 12;\n                } else {\n                    values.hour = this.$ampm.val() === 'am' ? values.hour : values.hour + 12;\n                }\n            }\n\n            dt = moment([values.year, values.month, values.day, values.hour, values.minute, values.second]);\n\n            //highlight invalid date\n            this.highlight(dt);\n\n            format = format === undefined ? this.options.format : format;\n            if (format === null) {\n                return dt.isValid() ? dt : null;\n            } else {\n                return dt.isValid() ? dt.format(format) : '';\n            }\n        },\n\n        setValue: function setValue(value) {\n            if (!value) {\n                return;\n            }\n\n            var dt = typeof value === 'string' ? moment(value, this.options.format) : moment(value),\n                that = this,\n                values = {};\n\n            //function to find nearest value in select options\n            function getNearest($select, value) {\n                var delta = {};\n                $select.children('option').each(function (i, opt) {\n                    var optValue = $(opt).attr('value'),\n                        distance;\n\n                    if (optValue === '') return;\n                    distance = Math.abs(optValue - value);\n                    if (typeof delta.distance === 'undefined' || distance < delta.distance) {\n                        delta = { value: optValue, distance: distance };\n                    }\n                });\n                return delta.value;\n            }\n\n            if (dt.isValid()) {\n                //read values from date object\n                $.each(this.map, function (k, v) {\n                    if (k === 'ampm') {\n                        return;\n                    }\n                    values[k] = dt[v[1]]();\n                });\n\n                if (this.$ampm) {\n                    //12:00 pm --\x3e 12:00 (24-h format, midday), 12:00 am --\x3e 00:00 (24-h format, midnight, start of day)\n                    if (values.hour >= 12) {\n                        values.ampm = 'pm';\n                        if (values.hour > 12) {\n                            values.hour -= 12;\n                        }\n                    } else {\n                        values.ampm = 'am';\n                        if (values.hour === 0) {\n                            values.hour = 12;\n                        }\n                    }\n                }\n\n                $.each(values, function (k, v) {\n                    //call val() for each existing combo, e.g. this.$hour.val()\n                    if (that['$' + k]) {\n\n                        if (k === 'minute' && that.options.minuteStep > 1 && that.options.roundTime) {\n                            v = getNearest(that['$' + k], v);\n                        }\n\n                        if (k === 'second' && that.options.secondStep > 1 && that.options.roundTime) {\n                            v = getNearest(that['$' + k], v);\n                        }\n\n                        that['$' + k].val(v);\n                    }\n                });\n\n                // update days count\n                if (this.options.smartDays) {\n                    this.fillCombo('day');\n                }\n\n                this.$element.val(dt.format(this.options.format)).change();\n            }\n        },\n\n        /*\n         highlight combos if date is invalid\n        */\n        highlight: function highlight(dt) {\n            if (!dt.isValid()) {\n                if (this.options.errorClass) {\n                    this.$widget.addClass(this.options.errorClass);\n                } else {\n                    //store original border color\n                    if (!this.borderColor) {\n                        this.borderColor = this.$widget.find('select').css('border-color');\n                    }\n                    this.$widget.find('select').css('border-color', 'red');\n                }\n            } else {\n                if (this.options.errorClass) {\n                    this.$widget.removeClass(this.options.errorClass);\n                } else {\n                    this.$widget.find('select').css('border-color', this.borderColor);\n                }\n            }\n        },\n\n        leadZero: function leadZero(v) {\n            return v <= 9 ? '0' + v : v;\n        },\n\n        destroy: function destroy() {\n            this.$widget.remove();\n            this.$element.removeData('combodate').show();\n        }\n\n        //todo: clear method        \n    };\n\n    $.fn.combodate = function (option) {\n        var d,\n            args = Array.apply(null, arguments);\n        args.shift();\n\n        //getValue returns date as string / object (not jQuery object)\n        if (option === 'getValue' && this.length && (d = this.eq(0).data('combodate'))) {\n            return d.getValue.apply(d, args);\n        }\n\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data('combodate'),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option;\n            if (!data) {\n                $this.data('combodate', data = new Combodate(this, options));\n            }\n            if (typeof option == 'string' && typeof data[option] == 'function') {\n                data[option].apply(data, args);\n            }\n        });\n    };\n\n    $.fn.combodate.defaults = {\n        //in this format value stored in original input\n        format: 'DD-MM-YYYY HH:mm',\n        //in this format items in dropdowns are displayed\n        template: 'D / MMM / YYYY   H : mm',\n        //initial value, can be `new Date()`    \n        value: null,\n        minYear: 1970,\n        maxYear: 2015,\n        yearDescending: true,\n        minuteStep: 5,\n        secondStep: 1,\n        firstItem: 'empty', //'name', 'empty', 'none'\n        errorClass: null,\n        roundTime: true, // whether to round minutes and seconds if step > 1\n        smartDays: false // whether days in combo depend on selected month: 31, 30, 28\n    };\n})(window.jQuery);\n/**\nCombodate input - dropdown date and time picker.    \nBased on [combodate](http://vitalets.github.com/combodate) plugin (included). To use it you should manually include [momentjs](http://momentjs.com).\n\n    <script src=\"js/moment.min.js\"><\/script>\n   \nAllows to input:\n\n* only date\n* only time \n* both date and time  \n\nPlease note, that format is taken from momentjs and **not compatible** with bootstrap-datepicker / jquery UI datepicker.  \nInternally value stored as `momentjs` object. \n\n@class combodate\n@extends abstractinput\n@final\n@since 1.4.0\n@example\n<a href=\"#\" id=\"dob\" data-type=\"combodate\" data-pk=\"1\" data-url=\"/post\" data-value=\"1984-05-15\" data-title=\"Select date\"></a>\n<script>\n$(function(){\n    $('#dob').editable({\n        format: 'YYYY-MM-DD',    \n        viewformat: 'DD.MM.YYYY',    \n        template: 'D / MMMM / YYYY',    \n        combodate: {\n                minYear: 2000,\n                maxYear: 2015,\n                minuteStep: 1\n           }\n        }\n    });\n});\n<\/script>\n**/\n\n/*global moment*/\n\n(function ($) {\n    ;\n\n    var Constructor = function Constructor(options) {\n        this.init('combodate', options, Constructor.defaults);\n\n        //by default viewformat equals to format\n        if (!this.options.viewformat) {\n            this.options.viewformat = this.options.format;\n        }\n\n        //try parse combodate config defined as json string in data-combodate\n        options.combodate = $.fn.editableutils.tryParseJson(options.combodate, true);\n\n        //overriding combodate config (as by default jQuery extend() is not recursive)\n        this.options.combodate = $.extend({}, Constructor.defaults.combodate, options.combodate, {\n            format: this.options.format,\n            template: this.options.template\n        });\n    };\n\n    $.fn.editableutils.inherit(Constructor, $.fn.editabletypes.abstractinput);\n\n    $.extend(Constructor.prototype, {\n        render: function render() {\n            this.$input.combodate(this.options.combodate);\n\n            if ($.fn.editableform.engine === 'bs3') {\n                this.$input.siblings().find('select').addClass('form-control');\n            }\n\n            if (this.options.inputclass) {\n                this.$input.siblings().find('select').addClass(this.options.inputclass);\n            }\n            //\"clear\" link\n            /*\n            if(this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function(e){\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n                \n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));  \n            } \n            */\n        },\n\n        value2html: function value2html(value, element) {\n            var text = value ? value.format(this.options.viewformat) : '';\n            //$(element).text(text);\n            Constructor.superclass.value2html.call(this, text, element);\n        },\n\n        html2value: function html2value(html) {\n            return html ? moment(html, this.options.viewformat) : null;\n        },\n\n        value2str: function value2str(value) {\n            return value ? value.format(this.options.format) : '';\n        },\n\n        str2value: function str2value(str) {\n            return str ? moment(str, this.options.format) : null;\n        },\n\n        value2submit: function value2submit(value) {\n            return this.value2str(value);\n        },\n\n        value2input: function value2input(value) {\n            this.$input.combodate('setValue', value);\n        },\n\n        input2value: function input2value() {\n            return this.$input.combodate('getValue', null);\n        },\n\n        activate: function activate() {\n            this.$input.siblings('.combodate').find('select').eq(0).focus();\n        },\n\n        /*\n        clear:  function() {\n           this.$input.data('datepicker').date = null;\n           this.$input.find('.active').removeClass('active');\n        },\n        */\n\n        autosubmit: function autosubmit() {}\n\n    });\n\n    Constructor.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"text\">\n        **/\n        tpl: '<input type=\"text\">',\n        /**\n        @property inputclass \n        @default null\n        **/\n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        See list of tokens in [momentjs docs](http://momentjs.com/docs/#/parsing/string-format)  \n        \n        @property format \n        @type string\n        @default YYYY-MM-DD\n        **/\n        format: 'YYYY-MM-DD',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to `format`.\n        \n        @property viewformat \n        @type string\n        @default null\n        **/\n        viewformat: null,\n        /**\n        Template used for displaying dropdowns.\n        \n        @property template \n        @type string\n        @default D / MMM / YYYY\n        **/\n        template: 'D / MMM / YYYY',\n        /**\n        Configuration of combodate.\n        Full list of options: http://vitalets.github.com/combodate/#docs\n        \n        @property combodate \n        @type object\n        @default null\n        **/\n        combodate: null\n\n        /*\n        (not implemented yet)\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n        \n        @property clear \n        @type boolean|string\n        @default 'x clear'         \n        */\n        //clear: '&times; clear'\n    });\n\n    $.fn.editabletypes.combodate = Constructor;\n})(window.jQuery);\n\n/*\nEditableform based on Twitter Bootstrap 3\n*/\n(function ($) {\n    ;\n\n    //store parent methods\n    var pInitInput = $.fn.editableform.Constructor.prototype.initInput;\n\n    $.extend($.fn.editableform.Constructor.prototype, {\n        initTemplate: function initTemplate() {\n            this.$form = $($.fn.editableform.template);\n            this.$form.find('.control-group').addClass('form-group');\n            this.$form.find('.editable-error-block').addClass('help-block');\n        },\n        initInput: function initInput() {\n            pInitInput.apply(this);\n\n            //for bs3 set default class `input-sm` to standard inputs\n            var emptyInputClass = this.input.options.inputclass === null || this.input.options.inputclass === false;\n            var defaultClass = 'input-sm';\n\n            //bs3 add `form-control` class to standard inputs\n            var stdtypes = 'text,select,textarea,password,email,url,tel,number,range,time,typeaheadjs'.split(',');\n            if (~$.inArray(this.input.type, stdtypes)) {\n                this.input.$input.addClass('form-control');\n                if (emptyInputClass) {\n                    this.input.options.inputclass = defaultClass;\n                    this.input.$input.addClass(defaultClass);\n                }\n            }\n\n            //apply bs3 size class also to buttons (to fit size of control)\n            var $btn = this.$form.find('.editable-buttons');\n            var classes = emptyInputClass ? [defaultClass] : this.input.options.inputclass.split(' ');\n            for (var i = 0; i < classes.length; i++) {\n                // `btn-sm` is default now\n                /*\n                if(classes[i].toLowerCase() === 'input-sm') { \n                    $btn.find('button').addClass('btn-sm');  \n                }\n                */\n                if (classes[i].toLowerCase() === 'input-lg') {\n                    $btn.find('button').removeClass('btn-sm').addClass('btn-lg');\n                }\n            }\n        }\n    });\n\n    //buttons\n    $.fn.editableform.buttons = '<button type=\"submit\" class=\"btn btn-primary btn-sm editable-submit\">' + '<i class=\"fa fa-ok\"></i>' + '</button>' + '<button type=\"button\" class=\"btn btn-default btn-sm editable-cancel\">' + '<i class=\"fa fa-remove\"></i>' + '</button>';\n\n    //error classes\n    $.fn.editableform.errorGroupClass = 'has-error';\n    $.fn.editableform.errorBlockClass = null;\n    //engine\n    $.fn.editableform.engine = 'bs3';\n})(window.jQuery);\n/**\n* Editable Popover3 (for Bootstrap 3) \n* ---------------------\n* requires bootstrap-popover.js\n*/\n(function ($) {\n    ;\n\n    //extend methods\n    $.extend($.fn.editableContainer.Popup.prototype, {\n        containerName: 'popover',\n        containerDataName: 'bs.popover',\n        innerCss: '.popover-content',\n        defaults: $.fn.popover.Constructor.DEFAULTS,\n\n        initContainer: function initContainer() {\n            $.extend(this.containerOptions, {\n                trigger: 'manual',\n                selector: false,\n                content: ' ',\n                template: this.defaults.template\n            });\n\n            //as template property is used in inputs, hide it from popover\n            var t;\n            if (this.$element.data('template')) {\n                t = this.$element.data('template');\n                this.$element.removeData('template');\n            }\n\n            this.call(this.containerOptions);\n\n            if (t) {\n                //restore data('template')\n                this.$element.data('template', t);\n            }\n        },\n\n        /* show */\n        innerShow: function innerShow() {\n            this.call('show');\n        },\n\n        /* hide */\n        innerHide: function innerHide() {\n            this.call('hide');\n        },\n\n        /* destroy */\n        innerDestroy: function innerDestroy() {\n            this.call('destroy');\n        },\n\n        setContainerOption: function setContainerOption(key, value) {\n            this.container().options[key] = value;\n        },\n\n        /**\n        * move popover to new position. This function mainly copied from bootstrap-popover.\n        */\n        /*jshint laxcomma: true, eqeqeq: false*/\n        setPosition: function setPosition() {\n\n            (function () {\n                /*    \n                    var $tip = this.tip()\n                    , inside\n                    , pos\n                    , actualWidth\n                    , actualHeight\n                    , placement\n                    , tp\n                    , tpt\n                    , tpb\n                    , tpl\n                    , tpr;\n                     placement = typeof this.options.placement === 'function' ?\n                    this.options.placement.call(this, $tip[0], this.$element[0]) :\n                    this.options.placement;\n                     inside = /in/.test(placement);\n                   \n                    $tip\n                  //  .detach()\n                  //vitalets: remove any placement class because otherwise they dont influence on re-positioning of visible popover\n                    .removeClass('top right bottom left')\n                    .css({ top: 0, left: 0, display: 'block' });\n                  //  .insertAfter(this.$element);\n                   \n                    pos = this.getPosition(inside);\n                     actualWidth = $tip[0].offsetWidth;\n                    actualHeight = $tip[0].offsetHeight;\n                     placement = inside ? placement.split(' ')[1] : placement;\n                     tpb = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2};\n                    tpt = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2};\n                    tpl = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth};\n                    tpr = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width};\n                     switch (placement) {\n                        case 'bottom':\n                            if ((tpb.top + actualHeight) > ($(window).scrollTop() + $(window).height())) {\n                                if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'top';\n                                } else if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                    placement = 'right';\n                                } else if (tpl.left > $(window).scrollLeft()) {\n                                    placement = 'left';\n                                } else {\n                                    placement = 'right';\n                                }\n                            }\n                            break;\n                        case 'top':\n                            if (tpt.top < $(window).scrollTop()) {\n                                if ((tpb.top + actualHeight) < ($(window).scrollTop() + $(window).height())) {\n                                    placement = 'bottom';\n                                } else if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                    placement = 'right';\n                                } else if (tpl.left > $(window).scrollLeft()) {\n                                    placement = 'left';\n                                } else {\n                                    placement = 'right';\n                                }\n                            }\n                            break;\n                        case 'left':\n                            if (tpl.left < $(window).scrollLeft()) {\n                                if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                    placement = 'right';\n                                } else if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'top';\n                                } else if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'bottom';\n                                } else {\n                                    placement = 'right';\n                                }\n                            }\n                            break;\n                        case 'right':\n                            if ((tpr.left + actualWidth) > ($(window).scrollLeft() + $(window).width())) {\n                                if (tpl.left > $(window).scrollLeft()) {\n                                    placement = 'left';\n                                } else if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'top';\n                                } else if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'bottom';\n                                }\n                            }\n                            break;\n                    }\n                     switch (placement) {\n                        case 'bottom':\n                            tp = tpb;\n                            break;\n                        case 'top':\n                            tp = tpt;\n                            break;\n                        case 'left':\n                            tp = tpl;\n                            break;\n                        case 'right':\n                            tp = tpr;\n                            break;\n                    }\n                     $tip\n                    .offset(tp)\n                    .addClass(placement)\n                    .addClass('in');\n                */\n\n                var $tip = this.tip();\n\n                var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;\n\n                var autoToken = /\\s?auto?\\s?/i;\n                var autoPlace = autoToken.test(placement);\n                if (autoPlace) {\n                    placement = placement.replace(autoToken, '') || 'top';\n                }\n\n                var pos = this.getPosition();\n                var actualWidth = $tip[0].offsetWidth;\n                var actualHeight = $tip[0].offsetHeight;\n\n                if (autoPlace) {\n                    var $parent = this.$element.parent();\n\n                    var orgPlacement = placement;\n                    var docScroll = document.documentElement.scrollTop || document.body.scrollTop;\n                    var parentWidth = this.options.container == 'body' ? window.innerWidth : $parent.outerWidth();\n                    var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight();\n                    var parentLeft = this.options.container == 'body' ? 0 : $parent.offset().left;\n\n                    placement = placement == 'bottom' && pos.top + pos.height + actualHeight - docScroll > parentHeight ? 'top' : placement == 'top' && pos.top - docScroll - actualHeight < 0 ? 'bottom' : placement == 'right' && pos.right + actualWidth > parentWidth ? 'left' : placement == 'left' && pos.left - actualWidth < parentLeft ? 'right' : placement;\n\n                    $tip.removeClass(orgPlacement).addClass(placement);\n                }\n\n                var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);\n\n                this.applyPlacement(calculatedOffset, placement);\n            }).call(this.container());\n            /*jshint laxcomma: false, eqeqeq: true*/\n        }\n    });\n})(window.jQuery);\n\n/* =========================================================\n * bootstrap-datepicker.js\n * http://www.eyecon.ro/bootstrap-datepicker\n * =========================================================\n * Copyright 2012 Stefan Petre\n * Improvements by Andrew Rowls\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ========================================================= */\n\n(function ($) {\n\n    function UTCDate() {\n        return new Date(Date.UTC.apply(Date, arguments));\n    }\n    function UTCToday() {\n        var today = new Date();\n        return UTCDate(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate());\n    }\n\n    // Picker object\n\n    var Datepicker = function Datepicker(element, options) {\n        var that = this;\n\n        this._process_options(options);\n\n        this.element = $(element);\n        this.isInline = false;\n        this.isInput = this.element.is('input');\n        this.component = this.element.is('.date') ? this.element.find('.add-on, .btn') : false;\n        this.hasInput = this.component && this.element.find('input').length;\n        if (this.component && this.component.length === 0) this.component = false;\n\n        this.picker = $(DPGlobal.template);\n        this._buildEvents();\n        this._attachEvents();\n\n        if (this.isInline) {\n            this.picker.addClass('datepicker-inline').appendTo(this.element);\n        } else {\n            this.picker.addClass('datepicker-dropdown dropdown-menu');\n        }\n\n        if (this.o.rtl) {\n            this.picker.addClass('datepicker-rtl');\n            this.picker.find('.prev i, .next i').toggleClass('icon-arrow-left icon-arrow-right');\n        }\n\n        this.viewMode = this.o.startView;\n\n        if (this.o.calendarWeeks) this.picker.find('tfoot th.today').attr('colspan', function (i, val) {\n            return parseInt(val) + 1;\n        });\n\n        this._allow_update = false;\n\n        this.setStartDate(this.o.startDate);\n        this.setEndDate(this.o.endDate);\n        this.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled);\n\n        this.fillDow();\n        this.fillMonths();\n\n        this._allow_update = true;\n\n        this.update();\n        this.showMode();\n\n        if (this.isInline) {\n            this.show();\n        }\n    };\n\n    Datepicker.prototype = {\n        constructor: Datepicker,\n\n        _process_options: function _process_options(opts) {\n            // Store raw options for reference\n            this._o = $.extend({}, this._o, opts);\n            // Processed options\n            var o = this.o = $.extend({}, this._o);\n\n            // Check if \"de-DE\" style date is available, if not language should\n            // fallback to 2 letter code eg \"de\"\n            var lang = o.language;\n            if (!dates[lang]) {\n                lang = lang.split('-')[0];\n                if (!dates[lang]) lang = defaults.language;\n            }\n            o.language = lang;\n\n            switch (o.startView) {\n                case 2:\n                case 'decade':\n                    o.startView = 2;\n                    break;\n                case 1:\n                case 'year':\n                    o.startView = 1;\n                    break;\n                default:\n                    o.startView = 0;\n            }\n\n            switch (o.minViewMode) {\n                case 1:\n                case 'months':\n                    o.minViewMode = 1;\n                    break;\n                case 2:\n                case 'years':\n                    o.minViewMode = 2;\n                    break;\n                default:\n                    o.minViewMode = 0;\n            }\n\n            o.startView = Math.max(o.startView, o.minViewMode);\n\n            o.weekStart %= 7;\n            o.weekEnd = (o.weekStart + 6) % 7;\n\n            var format = DPGlobal.parseFormat(o.format);\n            if (o.startDate !== -Infinity) {\n                o.startDate = DPGlobal.parseDate(o.startDate, format, o.language);\n            }\n            if (o.endDate !== Infinity) {\n                o.endDate = DPGlobal.parseDate(o.endDate, format, o.language);\n            }\n\n            o.daysOfWeekDisabled = o.daysOfWeekDisabled || [];\n            if (!$.isArray(o.daysOfWeekDisabled)) o.daysOfWeekDisabled = o.daysOfWeekDisabled.split(/[,\\s]*/);\n            o.daysOfWeekDisabled = $.map(o.daysOfWeekDisabled, function (d) {\n                return parseInt(d, 10);\n            });\n        },\n        _events: [],\n        _secondaryEvents: [],\n        _applyEvents: function _applyEvents(evs) {\n            for (var i = 0, el, ev; i < evs.length; i++) {\n                el = evs[i][0];\n                ev = evs[i][1];\n                el.on(ev);\n            }\n        },\n        _unapplyEvents: function _unapplyEvents(evs) {\n            for (var i = 0, el, ev; i < evs.length; i++) {\n                el = evs[i][0];\n                ev = evs[i][1];\n                el.off(ev);\n            }\n        },\n        _buildEvents: function _buildEvents() {\n            if (this.isInput) {\n                // single input\n                this._events = [[this.element, {\n                    focus: $.proxy(this.show, this),\n                    keyup: $.proxy(this.update, this),\n                    keydown: $.proxy(this.keydown, this)\n                }]];\n            } else if (this.component && this.hasInput) {\n                // component: input + button\n                this._events = [\n                // For components that are not readonly, allow keyboard nav\n                [this.element.find('input'), {\n                    focus: $.proxy(this.show, this),\n                    keyup: $.proxy(this.update, this),\n                    keydown: $.proxy(this.keydown, this)\n                }], [this.component, {\n                    click: $.proxy(this.show, this)\n                }]];\n            } else if (this.element.is('div')) {\n                // inline datepicker\n                this.isInline = true;\n            } else {\n                this._events = [[this.element, {\n                    click: $.proxy(this.show, this)\n                }]];\n            }\n\n            this._secondaryEvents = [[this.picker, {\n                click: $.proxy(this.click, this)\n            }], [$(window), {\n                resize: $.proxy(this.place, this)\n            }], [$(document), {\n                mousedown: $.proxy(function (e) {\n                    // Clicked outside the datepicker, hide it\n                    if (!(this.element.is(e.target) || this.element.find(e.target).size() || this.picker.is(e.target) || this.picker.find(e.target).size())) {\n                        this.hide();\n                    }\n                }, this)\n            }]];\n        },\n        _attachEvents: function _attachEvents() {\n            this._detachEvents();\n            this._applyEvents(this._events);\n        },\n        _detachEvents: function _detachEvents() {\n            this._unapplyEvents(this._events);\n        },\n        _attachSecondaryEvents: function _attachSecondaryEvents() {\n            this._detachSecondaryEvents();\n            this._applyEvents(this._secondaryEvents);\n        },\n        _detachSecondaryEvents: function _detachSecondaryEvents() {\n            this._unapplyEvents(this._secondaryEvents);\n        },\n        _trigger: function _trigger(event, altdate) {\n            var date = altdate || this.date,\n                local_date = new Date(date.getTime() + date.getTimezoneOffset() * 60000);\n\n            this.element.trigger({\n                type: event,\n                date: local_date,\n                format: $.proxy(function (altformat) {\n                    var format = altformat || this.o.format;\n                    return DPGlobal.formatDate(date, format, this.o.language);\n                }, this)\n            });\n        },\n\n        show: function show(e) {\n            if (!this.isInline) this.picker.appendTo('body');\n            this.picker.show();\n            this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();\n            this.place();\n            this._attachSecondaryEvents();\n            if (e) {\n                e.preventDefault();\n            }\n            this._trigger('show');\n        },\n\n        hide: function hide(e) {\n            if (this.isInline) return;\n            if (!this.picker.is(':visible')) return;\n            this.picker.hide().detach();\n            this._detachSecondaryEvents();\n            this.viewMode = this.o.startView;\n            this.showMode();\n\n            if (this.o.forceParse && (this.isInput && this.element.val() || this.hasInput && this.element.find('input').val())) this.setValue();\n            this._trigger('hide');\n        },\n\n        remove: function remove() {\n            this.hide();\n            this._detachEvents();\n            this._detachSecondaryEvents();\n            this.picker.remove();\n            delete this.element.data().datepicker;\n            if (!this.isInput) {\n                delete this.element.data().date;\n            }\n        },\n\n        getDate: function getDate() {\n            var d = this.getUTCDate();\n            return new Date(d.getTime() + d.getTimezoneOffset() * 60000);\n        },\n\n        getUTCDate: function getUTCDate() {\n            return this.date;\n        },\n\n        setDate: function setDate(d) {\n            this.setUTCDate(new Date(d.getTime() - d.getTimezoneOffset() * 60000));\n        },\n\n        setUTCDate: function setUTCDate(d) {\n            this.date = d;\n            this.setValue();\n        },\n\n        setValue: function setValue() {\n            var formatted = this.getFormattedDate();\n            if (!this.isInput) {\n                if (this.component) {\n                    this.element.find('input').val(formatted);\n                }\n            } else {\n                this.element.val(formatted);\n            }\n        },\n\n        getFormattedDate: function getFormattedDate(format) {\n            if (format === undefined) format = this.o.format;\n            return DPGlobal.formatDate(this.date, format, this.o.language);\n        },\n\n        setStartDate: function setStartDate(startDate) {\n            this._process_options({ startDate: startDate });\n            this.update();\n            this.updateNavArrows();\n        },\n\n        setEndDate: function setEndDate(endDate) {\n            this._process_options({ endDate: endDate });\n            this.update();\n            this.updateNavArrows();\n        },\n\n        setDaysOfWeekDisabled: function setDaysOfWeekDisabled(daysOfWeekDisabled) {\n            this._process_options({ daysOfWeekDisabled: daysOfWeekDisabled });\n            this.update();\n            this.updateNavArrows();\n        },\n\n        place: function place() {\n            if (this.isInline) return;\n            var zIndex = parseInt(this.element.parents().filter(function () {\n                return $(this).css('z-index') != 'auto';\n            }).first().css('z-index')) + 10;\n            var offset = this.component ? this.component.parent().offset() : this.element.offset();\n            var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(true);\n            this.picker.css({\n                top: offset.top + height,\n                left: offset.left,\n                zIndex: zIndex\n            });\n        },\n\n        _allow_update: true,\n        update: function update() {\n            if (!this._allow_update) return;\n\n            var date,\n                fromArgs = false;\n            if (arguments && arguments.length && (typeof arguments[0] === 'string' || arguments[0] instanceof Date)) {\n                date = arguments[0];\n                fromArgs = true;\n            } else {\n                date = this.isInput ? this.element.val() : this.element.data('date') || this.element.find('input').val();\n                delete this.element.data().date;\n            }\n\n            this.date = DPGlobal.parseDate(date, this.o.format, this.o.language);\n\n            if (fromArgs) this.setValue();\n\n            if (this.date < this.o.startDate) {\n                this.viewDate = new Date(this.o.startDate);\n            } else if (this.date > this.o.endDate) {\n                this.viewDate = new Date(this.o.endDate);\n            } else {\n                this.viewDate = new Date(this.date);\n            }\n            this.fill();\n        },\n\n        fillDow: function fillDow() {\n            var dowCnt = this.o.weekStart,\n                html = '<tr>';\n            if (this.o.calendarWeeks) {\n                var cell = '<th class=\"cw\">&nbsp;</th>';\n                html += cell;\n                this.picker.find('.datepicker-days thead tr:first-child').prepend(cell);\n            }\n            while (dowCnt < this.o.weekStart + 7) {\n                html += '<th class=\"dow\">' + dates[this.o.language].daysMin[dowCnt++ % 7] + '</th>';\n            }\n            html += '</tr>';\n            this.picker.find('.datepicker-days thead').append(html);\n        },\n\n        fillMonths: function fillMonths() {\n            var html = '',\n                i = 0;\n            while (i < 12) {\n                html += '<span class=\"month\">' + dates[this.o.language].monthsShort[i++] + '</span>';\n            }\n            this.picker.find('.datepicker-months td').html(html);\n        },\n\n        setRange: function setRange(range) {\n            if (!range || !range.length) delete this.range;else this.range = $.map(range, function (d) {\n                return d.valueOf();\n            });\n            this.fill();\n        },\n\n        getClassNames: function getClassNames(date) {\n            var cls = [],\n                year = this.viewDate.getUTCFullYear(),\n                month = this.viewDate.getUTCMonth(),\n                currentDate = this.date.valueOf(),\n                today = new Date();\n            if (date.getUTCFullYear() < year || date.getUTCFullYear() == year && date.getUTCMonth() < month) {\n                cls.push('old');\n            } else if (date.getUTCFullYear() > year || date.getUTCFullYear() == year && date.getUTCMonth() > month) {\n                cls.push('new');\n            }\n            // Compare internal UTC date with local today, not UTC today\n            if (this.o.todayHighlight && date.getUTCFullYear() == today.getFullYear() && date.getUTCMonth() == today.getMonth() && date.getUTCDate() == today.getDate()) {\n                cls.push('today');\n            }\n            if (currentDate && date.valueOf() == currentDate) {\n                cls.push('active');\n            }\n            if (date.valueOf() < this.o.startDate || date.valueOf() > this.o.endDate || $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1) {\n                cls.push('disabled');\n            }\n            if (this.range) {\n                if (date > this.range[0] && date < this.range[this.range.length - 1]) {\n                    cls.push('range');\n                }\n                if ($.inArray(date.valueOf(), this.range) != -1) {\n                    cls.push('selected');\n                }\n            }\n            return cls;\n        },\n\n        fill: function fill() {\n            var d = new Date(this.viewDate),\n                year = d.getUTCFullYear(),\n                month = d.getUTCMonth(),\n                startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,\n                startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,\n                endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,\n                endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,\n                currentDate = this.date && this.date.valueOf(),\n                tooltip;\n            this.picker.find('.datepicker-days thead th.datepicker-switch').text(dates[this.o.language].months[month] + ' ' + year);\n            this.picker.find('tfoot th.today').text(dates[this.o.language].today).toggle(this.o.todayBtn !== false);\n            this.picker.find('tfoot th.clear').text(dates[this.o.language].clear).toggle(this.o.clearBtn !== false);\n            this.updateNavArrows();\n            this.fillMonths();\n            var prevMonth = UTCDate(year, month - 1, 28, 0, 0, 0, 0),\n                day = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());\n            prevMonth.setUTCDate(day);\n            prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7) % 7);\n            var nextMonth = new Date(prevMonth);\n            nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);\n            nextMonth = nextMonth.valueOf();\n            var html = [];\n            var clsName;\n            while (prevMonth.valueOf() < nextMonth) {\n                if (prevMonth.getUTCDay() == this.o.weekStart) {\n                    html.push('<tr>');\n                    if (this.o.calendarWeeks) {\n                        // ISO 8601: First week contains first thursday.\n                        // ISO also states week starts on Monday, but we can be more abstract here.\n                        var\n                        // Start of current week: based on weekstart/current date\n                        ws = new Date(+prevMonth + (this.o.weekStart - prevMonth.getUTCDay() - 7) % 7 * 864e5),\n\n                        // Thursday of this week\n                        th = new Date(+ws + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),\n\n                        // First Thursday of year, year from thursday\n                        yth = new Date(+(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay()) % 7 * 864e5),\n\n                        // Calendar week: ms between thursdays, div ms per day, div 7 days\n                        calWeek = (th - yth) / 864e5 / 7 + 1;\n                        html.push('<td class=\"cw\">' + calWeek + '</td>');\n                    }\n                }\n                clsName = this.getClassNames(prevMonth);\n                clsName.push('day');\n\n                var before = this.o.beforeShowDay(prevMonth);\n                if (before === undefined) before = {};else if (typeof before === 'boolean') before = { enabled: before };else if (typeof before === 'string') before = { classes: before };\n                if (before.enabled === false) clsName.push('disabled');\n                if (before.classes) clsName = clsName.concat(before.classes.split(/\\s+/));\n                if (before.tooltip) tooltip = before.tooltip;\n\n                clsName = $.unique(clsName);\n                html.push('<td class=\"' + clsName.join(' ') + '\"' + (tooltip ? ' title=\"' + tooltip + '\"' : '') + '>' + prevMonth.getUTCDate() + '</td>');\n                if (prevMonth.getUTCDay() == this.o.weekEnd) {\n                    html.push('</tr>');\n                }\n                prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);\n            }\n            this.picker.find('.datepicker-days tbody').empty().append(html.join(''));\n            var currentYear = this.date && this.date.getUTCFullYear();\n\n            var months = this.picker.find('.datepicker-months').find('th:eq(1)').text(year).end().find('span').removeClass('active');\n            if (currentYear && currentYear == year) {\n                months.eq(this.date.getUTCMonth()).addClass('active');\n            }\n            if (year < startYear || year > endYear) {\n                months.addClass('disabled');\n            }\n            if (year == startYear) {\n                months.slice(0, startMonth).addClass('disabled');\n            }\n            if (year == endYear) {\n                months.slice(endMonth + 1).addClass('disabled');\n            }\n\n            html = '';\n            year = parseInt(year / 10, 10) * 10;\n            var yearCont = this.picker.find('.datepicker-years').find('th:eq(1)').text(year + '-' + (year + 9)).end().find('td');\n            year -= 1;\n            for (var i = -1; i < 11; i++) {\n                html += '<span class=\"year' + (i == -1 ? ' old' : i == 10 ? ' new' : '') + (currentYear == year ? ' active' : '') + (year < startYear || year > endYear ? ' disabled' : '') + '\">' + year + '</span>';\n                year += 1;\n            }\n            yearCont.html(html);\n        },\n\n        updateNavArrows: function updateNavArrows() {\n            if (!this._allow_update) return;\n\n            var d = new Date(this.viewDate),\n                year = d.getUTCFullYear(),\n                month = d.getUTCMonth();\n            switch (this.viewMode) {\n                case 0:\n                    if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear() && month <= this.o.startDate.getUTCMonth()) {\n                        this.picker.find('.prev').css({ visibility: 'hidden' });\n                    } else {\n                        this.picker.find('.prev').css({ visibility: 'visible' });\n                    }\n                    if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear() && month >= this.o.endDate.getUTCMonth()) {\n                        this.picker.find('.next').css({ visibility: 'hidden' });\n                    } else {\n                        this.picker.find('.next').css({ visibility: 'visible' });\n                    }\n                    break;\n                case 1:\n                case 2:\n                    if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear()) {\n                        this.picker.find('.prev').css({ visibility: 'hidden' });\n                    } else {\n                        this.picker.find('.prev').css({ visibility: 'visible' });\n                    }\n                    if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear()) {\n                        this.picker.find('.next').css({ visibility: 'hidden' });\n                    } else {\n                        this.picker.find('.next').css({ visibility: 'visible' });\n                    }\n                    break;\n            }\n        },\n\n        click: function click(e) {\n            e.preventDefault();\n            var target = $(e.target).closest('span, td, th');\n            if (target.length == 1) {\n                switch (target[0].nodeName.toLowerCase()) {\n                    case 'th':\n                        switch (target[0].className) {\n                            case 'datepicker-switch':\n                                this.showMode(1);\n                                break;\n                            case 'prev':\n                            case 'next':\n                                var dir = DPGlobal.modes[this.viewMode].navStep * (target[0].className == 'prev' ? -1 : 1);\n                                switch (this.viewMode) {\n                                    case 0:\n                                        this.viewDate = this.moveMonth(this.viewDate, dir);\n                                        break;\n                                    case 1:\n                                    case 2:\n                                        this.viewDate = this.moveYear(this.viewDate, dir);\n                                        break;\n                                }\n                                this.fill();\n                                break;\n                            case 'today':\n                                var date = new Date();\n                                date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\n\n                                this.showMode(-2);\n                                var which = this.o.todayBtn == 'linked' ? null : 'view';\n                                this._setDate(date, which);\n                                break;\n                            case 'clear':\n                                var element;\n                                if (this.isInput) element = this.element;else if (this.component) element = this.element.find('input');\n                                if (element) element.val(\"\").change();\n                                this._trigger('changeDate');\n                                this.update();\n                                if (this.o.autoclose) this.hide();\n                                break;\n                        }\n                        break;\n                    case 'span':\n                        if (!target.is('.disabled')) {\n                            this.viewDate.setUTCDate(1);\n                            if (target.is('.month')) {\n                                var day = 1;\n                                var month = target.parent().find('span').index(target);\n                                var year = this.viewDate.getUTCFullYear();\n                                this.viewDate.setUTCMonth(month);\n                                this._trigger('changeMonth', this.viewDate);\n                                if (this.o.minViewMode === 1) {\n                                    this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));\n                                }\n                            } else {\n                                var year = parseInt(target.text(), 10) || 0;\n                                var day = 1;\n                                var month = 0;\n                                this.viewDate.setUTCFullYear(year);\n                                this._trigger('changeYear', this.viewDate);\n                                if (this.o.minViewMode === 2) {\n                                    this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));\n                                }\n                            }\n                            this.showMode(-1);\n                            this.fill();\n                        }\n                        break;\n                    case 'td':\n                        if (target.is('.day') && !target.is('.disabled')) {\n                            var day = parseInt(target.text(), 10) || 1;\n                            var year = this.viewDate.getUTCFullYear(),\n                                month = this.viewDate.getUTCMonth();\n                            if (target.is('.old')) {\n                                if (month === 0) {\n                                    month = 11;\n                                    year -= 1;\n                                } else {\n                                    month -= 1;\n                                }\n                            } else if (target.is('.new')) {\n                                if (month == 11) {\n                                    month = 0;\n                                    year += 1;\n                                } else {\n                                    month += 1;\n                                }\n                            }\n                            this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));\n                        }\n                        break;\n                }\n            }\n        },\n\n        _setDate: function _setDate(date, which) {\n            if (!which || which == 'date') this.date = new Date(date);\n            if (!which || which == 'view') this.viewDate = new Date(date);\n            this.fill();\n            this.setValue();\n            this._trigger('changeDate');\n            var element;\n            if (this.isInput) {\n                element = this.element;\n            } else if (this.component) {\n                element = this.element.find('input');\n            }\n            if (element) {\n                element.change();\n                if (this.o.autoclose && (!which || which == 'date')) {\n                    this.hide();\n                }\n            }\n        },\n\n        moveMonth: function moveMonth(date, dir) {\n            if (!dir) return date;\n            var new_date = new Date(date.valueOf()),\n                day = new_date.getUTCDate(),\n                month = new_date.getUTCMonth(),\n                mag = Math.abs(dir),\n                new_month,\n                test;\n            dir = dir > 0 ? 1 : -1;\n            if (mag == 1) {\n                test = dir == -1\n                // If going back one month, make sure month is not current month\n                // (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)\n                ? function () {\n                    return new_date.getUTCMonth() == month;\n                }\n                // If going forward one month, make sure month is as expected\n                // (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)\n                : function () {\n                    return new_date.getUTCMonth() != new_month;\n                };\n                new_month = month + dir;\n                new_date.setUTCMonth(new_month);\n                // Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11\n                if (new_month < 0 || new_month > 11) new_month = (new_month + 12) % 12;\n            } else {\n                // For magnitudes >1, move one month at a time...\n                for (var i = 0; i < mag; i++) {\n                    // ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...\n                    new_date = this.moveMonth(new_date, dir);\n                } // ...then reset the day, keeping it in the new month\n                new_month = new_date.getUTCMonth();\n                new_date.setUTCDate(day);\n                test = function test() {\n                    return new_month != new_date.getUTCMonth();\n                };\n            }\n            // Common date-resetting loop -- if date is beyond end of month, make it\n            // end of month\n            while (test()) {\n                new_date.setUTCDate(--day);\n                new_date.setUTCMonth(new_month);\n            }\n            return new_date;\n        },\n\n        moveYear: function moveYear(date, dir) {\n            return this.moveMonth(date, dir * 12);\n        },\n\n        dateWithinRange: function dateWithinRange(date) {\n            return date >= this.o.startDate && date <= this.o.endDate;\n        },\n\n        keydown: function keydown(e) {\n            if (this.picker.is(':not(:visible)')) {\n                if (e.keyCode == 27) // allow escape to hide and re-show picker\n                    this.show();\n                return;\n            }\n            var dateChanged = false,\n                dir,\n                day,\n                month,\n                newDate,\n                newViewDate;\n            switch (e.keyCode) {\n                case 27:\n                    // escape\n                    this.hide();\n                    e.preventDefault();\n                    break;\n                case 37: // left\n                case 39:\n                    // right\n                    if (!this.o.keyboardNavigation) break;\n                    dir = e.keyCode == 37 ? -1 : 1;\n                    if (e.ctrlKey) {\n                        newDate = this.moveYear(this.date, dir);\n                        newViewDate = this.moveYear(this.viewDate, dir);\n                    } else if (e.shiftKey) {\n                        newDate = this.moveMonth(this.date, dir);\n                        newViewDate = this.moveMonth(this.viewDate, dir);\n                    } else {\n                        newDate = new Date(this.date);\n                        newDate.setUTCDate(this.date.getUTCDate() + dir);\n                        newViewDate = new Date(this.viewDate);\n                        newViewDate.setUTCDate(this.viewDate.getUTCDate() + dir);\n                    }\n                    if (this.dateWithinRange(newDate)) {\n                        this.date = newDate;\n                        this.viewDate = newViewDate;\n                        this.setValue();\n                        this.update();\n                        e.preventDefault();\n                        dateChanged = true;\n                    }\n                    break;\n                case 38: // up\n                case 40:\n                    // down\n                    if (!this.o.keyboardNavigation) break;\n                    dir = e.keyCode == 38 ? -1 : 1;\n                    if (e.ctrlKey) {\n                        newDate = this.moveYear(this.date, dir);\n                        newViewDate = this.moveYear(this.viewDate, dir);\n                    } else if (e.shiftKey) {\n                        newDate = this.moveMonth(this.date, dir);\n                        newViewDate = this.moveMonth(this.viewDate, dir);\n                    } else {\n                        newDate = new Date(this.date);\n                        newDate.setUTCDate(this.date.getUTCDate() + dir * 7);\n                        newViewDate = new Date(this.viewDate);\n                        newViewDate.setUTCDate(this.viewDate.getUTCDate() + dir * 7);\n                    }\n                    if (this.dateWithinRange(newDate)) {\n                        this.date = newDate;\n                        this.viewDate = newViewDate;\n                        this.setValue();\n                        this.update();\n                        e.preventDefault();\n                        dateChanged = true;\n                    }\n                    break;\n                case 13:\n                    // enter\n                    this.hide();\n                    e.preventDefault();\n                    break;\n                case 9:\n                    // tab\n                    this.hide();\n                    break;\n            }\n            if (dateChanged) {\n                this._trigger('changeDate');\n                var element;\n                if (this.isInput) {\n                    element = this.element;\n                } else if (this.component) {\n                    element = this.element.find('input');\n                }\n                if (element) {\n                    element.change();\n                }\n            }\n        },\n\n        showMode: function showMode(dir) {\n            if (dir) {\n                this.viewMode = Math.max(this.o.minViewMode, Math.min(2, this.viewMode + dir));\n            }\n            /*\n            \tvitalets: fixing bug of very special conditions:\n            \tjquery 1.7.1 + webkit + show inline datepicker in bootstrap popover.\n            \tMethod show() does not set display css correctly and datepicker is not shown.\n            \tChanged to .css('display', 'block') solve the problem.\n            \tSee https://github.com/vitalets/x-editable/issues/37\n            \t\tIn jquery 1.7.2+ everything works fine.\n            */\n            //this.picker.find('>div').hide().filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName).show();\n            this.picker.find('>div').hide().filter('.datepicker-' + DPGlobal.modes[this.viewMode].clsName).css('display', 'block');\n            this.updateNavArrows();\n        }\n    };\n\n    var DateRangePicker = function DateRangePicker(element, options) {\n        this.element = $(element);\n        this.inputs = $.map(options.inputs, function (i) {\n            return i.jquery ? i[0] : i;\n        });\n        delete options.inputs;\n\n        $(this.inputs).datepicker(options).bind('changeDate', $.proxy(this.dateUpdated, this));\n\n        this.pickers = $.map(this.inputs, function (i) {\n            return $(i).data('datepicker');\n        });\n        this.updateDates();\n    };\n    DateRangePicker.prototype = {\n        updateDates: function updateDates() {\n            this.dates = $.map(this.pickers, function (i) {\n                return i.date;\n            });\n            this.updateRanges();\n        },\n        updateRanges: function updateRanges() {\n            var range = $.map(this.dates, function (d) {\n                return d.valueOf();\n            });\n            $.each(this.pickers, function (i, p) {\n                p.setRange(range);\n            });\n        },\n        dateUpdated: function dateUpdated(e) {\n            var dp = $(e.target).data('datepicker'),\n                new_date = dp.getUTCDate(),\n                i = $.inArray(e.target, this.inputs),\n                l = this.inputs.length;\n            if (i == -1) return;\n\n            if (new_date < this.dates[i]) {\n                // Date being moved earlier/left\n                while (i >= 0 && new_date < this.dates[i]) {\n                    this.pickers[i--].setUTCDate(new_date);\n                }\n            } else if (new_date > this.dates[i]) {\n                // Date being moved later/right\n                while (i < l && new_date > this.dates[i]) {\n                    this.pickers[i++].setUTCDate(new_date);\n                }\n            }\n            this.updateDates();\n        },\n        remove: function remove() {\n            $.map(this.pickers, function (p) {\n                p.remove();\n            });\n            delete this.element.data().datepicker;\n        }\n    };\n\n    function opts_from_el(el, prefix) {\n        // Derive options from element data-attrs\n        var data = $(el).data(),\n            out = {},\n            inkey,\n            replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])'),\n            prefix = new RegExp('^' + prefix.toLowerCase());\n        for (var key in data) {\n            if (prefix.test(key)) {\n                inkey = key.replace(replace, function (_, a) {\n                    return a.toLowerCase();\n                });\n                out[inkey] = data[key];\n            }\n        }return out;\n    }\n\n    function opts_from_locale(lang) {\n        // Derive options from locale plugins\n        var out = {};\n        // Check if \"de-DE\" style date is available, if not language should\n        // fallback to 2 letter code eg \"de\"\n        if (!dates[lang]) {\n            lang = lang.split('-')[0];\n            if (!dates[lang]) return;\n        }\n        var d = dates[lang];\n        $.each(locale_opts, function (i, k) {\n            if (k in d) out[k] = d[k];\n        });\n        return out;\n    }\n\n    var old = $.fn.datepicker;\n    var datepicker = $.fn.datepicker = function (option) {\n        var args = Array.apply(null, arguments);\n        args.shift();\n        var internal_return, this_return;\n        this.each(function () {\n            var $this = $(this),\n                data = $this.data('datepicker'),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option;\n            if (!data) {\n                var elopts = opts_from_el(this, 'date'),\n\n                // Preliminary otions\n                xopts = $.extend({}, defaults, elopts, options),\n                    locopts = opts_from_locale(xopts.language),\n\n                // Options priority: js args, data-attrs, locales, defaults\n                opts = $.extend({}, defaults, locopts, elopts, options);\n                if ($this.is('.input-daterange') || opts.inputs) {\n                    var ropts = {\n                        inputs: opts.inputs || $this.find('input').toArray()\n                    };\n                    $this.data('datepicker', data = new DateRangePicker(this, $.extend(opts, ropts)));\n                } else {\n                    $this.data('datepicker', data = new Datepicker(this, opts));\n                }\n            }\n            if (typeof option == 'string' && typeof data[option] == 'function') {\n                internal_return = data[option].apply(data, args);\n                if (internal_return !== undefined) return false;\n            }\n        });\n        if (internal_return !== undefined) return internal_return;else return this;\n    };\n\n    var defaults = $.fn.datepicker.defaults = {\n        autoclose: false,\n        beforeShowDay: $.noop,\n        calendarWeeks: false,\n        clearBtn: false,\n        daysOfWeekDisabled: [],\n        endDate: Infinity,\n        forceParse: true,\n        format: 'mm/dd/yyyy',\n        keyboardNavigation: true,\n        language: 'en',\n        minViewMode: 0,\n        rtl: false,\n        startDate: -Infinity,\n        startView: 0,\n        todayBtn: false,\n        todayHighlight: false,\n        weekStart: 0\n    };\n    var locale_opts = $.fn.datepicker.locale_opts = ['format', 'rtl', 'weekStart'];\n    $.fn.datepicker.Constructor = Datepicker;\n    var dates = $.fn.datepicker.dates = {\n        en: {\n            days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\n            daysShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\n            daysMin: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\", \"Su\"],\n            months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n            monthsShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n            today: \"Today\",\n            clear: \"Clear\"\n        }\n    };\n\n    var DPGlobal = {\n        modes: [{\n            clsName: 'days',\n            navFnc: 'Month',\n            navStep: 1\n        }, {\n            clsName: 'months',\n            navFnc: 'FullYear',\n            navStep: 1\n        }, {\n            clsName: 'years',\n            navFnc: 'FullYear',\n            navStep: 10\n        }],\n        isLeapYear: function isLeapYear(year) {\n            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n        },\n        getDaysInMonth: function getDaysInMonth(year, month) {\n            return [31, DPGlobal.isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n        },\n        validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,\n        nonpunctuation: /[^ -\\/:-@\\[\\u3400-\\u9fff-`{-~\\t\\n\\r]+/g,\n        parseFormat: function parseFormat(format) {\n            // IE treats \\0 as a string end in inputs (truncating the value),\n            // so it's a bad format delimiter, anyway\n            var separators = format.replace(this.validParts, '\\0').split('\\0'),\n                parts = format.match(this.validParts);\n            if (!separators || !separators.length || !parts || parts.length === 0) {\n                throw new Error(\"Invalid date format.\");\n            }\n            return { separators: separators, parts: parts };\n        },\n        parseDate: function parseDate(date, format, language) {\n            if (date instanceof Date) return date;\n            if (typeof format === 'string') format = DPGlobal.parseFormat(format);\n            if (/^[\\-+]\\d+[dmwy]([\\s,]+[\\-+]\\d+[dmwy])*$/.test(date)) {\n                var part_re = /([\\-+]\\d+)([dmwy])/,\n                    parts = date.match(/([\\-+]\\d+)([dmwy])/g),\n                    part,\n                    dir;\n                date = new Date();\n                for (var i = 0; i < parts.length; i++) {\n                    part = part_re.exec(parts[i]);\n                    dir = parseInt(part[1]);\n                    switch (part[2]) {\n                        case 'd':\n                            date.setUTCDate(date.getUTCDate() + dir);\n                            break;\n                        case 'm':\n                            date = Datepicker.prototype.moveMonth.call(Datepicker.prototype, date, dir);\n                            break;\n                        case 'w':\n                            date.setUTCDate(date.getUTCDate() + dir * 7);\n                            break;\n                        case 'y':\n                            date = Datepicker.prototype.moveYear.call(Datepicker.prototype, date, dir);\n                            break;\n                    }\n                }\n                return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);\n            }\n            var parts = date && date.match(this.nonpunctuation) || [],\n                date = new Date(),\n                parsed = {},\n                setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],\n                setters_map = {\n                yyyy: function yyyy(d, v) {\n                    return d.setUTCFullYear(v);\n                },\n                yy: function yy(d, v) {\n                    return d.setUTCFullYear(2000 + v);\n                },\n                m: function m(d, v) {\n                    v -= 1;\n                    while (v < 0) {\n                        v += 12;\n                    }v %= 12;\n                    d.setUTCMonth(v);\n                    while (d.getUTCMonth() != v) {\n                        d.setUTCDate(d.getUTCDate() - 1);\n                    }return d;\n                },\n                d: function d(_d, v) {\n                    return _d.setUTCDate(v);\n                }\n            },\n                val,\n                filtered,\n                part;\n            setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];\n            setters_map['dd'] = setters_map['d'];\n            date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\n            var fparts = format.parts.slice();\n            // Remove noop parts\n            if (parts.length != fparts.length) {\n                fparts = $(fparts).filter(function (i, p) {\n                    return $.inArray(p, setters_order) !== -1;\n                }).toArray();\n            }\n            // Process remainder\n            if (parts.length == fparts.length) {\n                for (var i = 0, cnt = fparts.length; i < cnt; i++) {\n                    val = parseInt(parts[i], 10);\n                    part = fparts[i];\n                    if (isNaN(val)) {\n                        switch (part) {\n                            case 'MM':\n                                filtered = $(dates[language].months).filter(function () {\n                                    var m = this.slice(0, parts[i].length),\n                                        p = parts[i].slice(0, m.length);\n                                    return m == p;\n                                });\n                                val = $.inArray(filtered[0], dates[language].months) + 1;\n                                break;\n                            case 'M':\n                                filtered = $(dates[language].monthsShort).filter(function () {\n                                    var m = this.slice(0, parts[i].length),\n                                        p = parts[i].slice(0, m.length);\n                                    return m == p;\n                                });\n                                val = $.inArray(filtered[0], dates[language].monthsShort) + 1;\n                                break;\n                        }\n                    }\n                    parsed[part] = val;\n                }\n                for (var i = 0, s; i < setters_order.length; i++) {\n                    s = setters_order[i];\n                    if (s in parsed && !isNaN(parsed[s])) setters_map[s](date, parsed[s]);\n                }\n            }\n            return date;\n        },\n        formatDate: function formatDate(date, format, language) {\n            if (typeof format === 'string') format = DPGlobal.parseFormat(format);\n            var val = {\n                d: date.getUTCDate(),\n                D: dates[language].daysShort[date.getUTCDay()],\n                DD: dates[language].days[date.getUTCDay()],\n                m: date.getUTCMonth() + 1,\n                M: dates[language].monthsShort[date.getUTCMonth()],\n                MM: dates[language].months[date.getUTCMonth()],\n                yy: date.getUTCFullYear().toString().substring(2),\n                yyyy: date.getUTCFullYear()\n            };\n            val.dd = (val.d < 10 ? '0' : '') + val.d;\n            val.mm = (val.m < 10 ? '0' : '') + val.m;\n            var date = [],\n                seps = $.extend([], format.separators);\n            for (var i = 0, cnt = format.parts.length; i <= cnt; i++) {\n                if (seps.length) date.push(seps.shift());\n                date.push(val[format.parts[i]]);\n            }\n            return date.join('');\n        },\n        headTemplate: '<thead>' + '<tr>' + '<th class=\"prev\"><i class=\"icon-arrow-left\"/></th>' + '<th colspan=\"5\" class=\"datepicker-switch\"></th>' + '<th class=\"next\"><i class=\"icon-arrow-right\"/></th>' + '</tr>' + '</thead>',\n        contTemplate: '<tbody><tr><td colspan=\"7\"></td></tr></tbody>',\n        footTemplate: '<tfoot><tr><th colspan=\"7\" class=\"today\"></th></tr><tr><th colspan=\"7\" class=\"clear\"></th></tr></tfoot>'\n    };\n    DPGlobal.template = '<div class=\"datepicker\">' + '<div class=\"datepicker-days\">' + '<table class=\" table-condensed\">' + DPGlobal.headTemplate + '<tbody></tbody>' + DPGlobal.footTemplate + '</table>' + '</div>' + '<div class=\"datepicker-months\">' + '<table class=\"table-condensed\">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table>' + '</div>' + '<div class=\"datepicker-years\">' + '<table class=\"table-condensed\">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table>' + '</div>' + '</div>';\n\n    $.fn.datepicker.DPGlobal = DPGlobal;\n\n    /* DATEPICKER NO CONFLICT\n    * =================== */\n\n    $.fn.datepicker.noConflict = function () {\n        $.fn.datepicker = old;\n        return this;\n    };\n\n    /* DATEPICKER DATA-API\n    * ================== */\n\n    $(document).on('focus.datepicker.data-api click.datepicker.data-api', '[data-provide=\"datepicker\"]', function (e) {\n        var $this = $(this);\n        if ($this.data('datepicker')) return;\n        e.preventDefault();\n        // component click requires us to explicitly show it\n        datepicker.call($this, 'show');\n    });\n    $(function () {\n        //$('[data-provide=\"datepicker-inline\"]').datepicker();\n        //vit: changed to support noConflict()\n        datepicker.call($('[data-provide=\"datepicker-inline\"]'));\n    });\n})(window.jQuery);\n\n/**\nBootstrap-datepicker.  \nDescription and examples: https://github.com/eternicode/bootstrap-datepicker.  \nFor **i18n** you should include js file from here: https://github.com/eternicode/bootstrap-datepicker/tree/master/js/locales\nand set `language` option.  \nSince 1.4.0 date has different appearance in **popup** and **inline** modes. \n\n@class date\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"dob\" data-type=\"date\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select date\">15/05/1984</a>\n<script>\n$(function(){\n    $('#dob').editable({\n        format: 'yyyy-mm-dd',    \n        viewformat: 'dd/mm/yyyy',    \n        datepicker: {\n                weekStart: 1\n           }\n        }\n    });\n});\n<\/script>\n**/\n(function ($) {\n    ;\n\n    //store bootstrap-datepicker as bdateicker to exclude conflict with jQuery UI one\n    $.fn.bdatepicker = $.fn.datepicker.noConflict();\n    if (!$.fn.datepicker) {\n        //if there were no other datepickers, keep also original name\n        $.fn.datepicker = $.fn.bdatepicker;\n    }\n\n    var Date = function Date(options) {\n        this.init('date', options, Date.defaults);\n        this.initPicker(options, Date.defaults);\n    };\n\n    $.fn.editableutils.inherit(Date, $.fn.editabletypes.abstractinput);\n\n    $.extend(Date.prototype, {\n        initPicker: function initPicker(options, defaults) {\n            //'format' is set directly from settings or data-* attributes\n\n            //by default viewformat equals to format\n            if (!this.options.viewformat) {\n                this.options.viewformat = this.options.format;\n            }\n\n            //try parse datepicker config defined as json string in data-datepicker\n            options.datepicker = $.fn.editableutils.tryParseJson(options.datepicker, true);\n\n            //overriding datepicker config (as by default jQuery extend() is not recursive)\n            //since 1.4 datepicker internally uses viewformat instead of format. Format is for submit only\n            this.options.datepicker = $.extend({}, defaults.datepicker, options.datepicker, {\n                format: this.options.viewformat\n            });\n\n            //language\n            this.options.datepicker.language = this.options.datepicker.language || 'en';\n\n            //store DPglobal\n            this.dpg = $.fn.bdatepicker.DPGlobal;\n\n            //store parsed formats\n            this.parsedFormat = this.dpg.parseFormat(this.options.format);\n            this.parsedViewFormat = this.dpg.parseFormat(this.options.viewformat);\n        },\n\n        render: function render() {\n            this.$input.bdatepicker(this.options.datepicker);\n\n            //\"clear\" link\n            if (this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function (e) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n\n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));\n            }\n        },\n\n        value2html: function value2html(value, element) {\n            var text = value ? this.dpg.formatDate(value, this.parsedViewFormat, this.options.datepicker.language) : '';\n            Date.superclass.value2html.call(this, text, element);\n        },\n\n        html2value: function html2value(html) {\n            return this.parseDate(html, this.parsedViewFormat);\n        },\n\n        value2str: function value2str(value) {\n            return value ? this.dpg.formatDate(value, this.parsedFormat, this.options.datepicker.language) : '';\n        },\n\n        str2value: function str2value(str) {\n            return this.parseDate(str, this.parsedFormat);\n        },\n\n        value2submit: function value2submit(value) {\n            return this.value2str(value);\n        },\n\n        value2input: function value2input(value) {\n            this.$input.bdatepicker('update', value);\n        },\n\n        input2value: function input2value() {\n            return this.$input.data('datepicker').date;\n        },\n\n        activate: function activate() {},\n\n        clear: function clear() {\n            this.$input.data('datepicker').date = null;\n            this.$input.find('.active').removeClass('active');\n            if (!this.options.showbuttons) {\n                this.$input.closest('form').submit();\n            }\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.on('mouseup', '.day', function (e) {\n                if ($(e.currentTarget).is('.old') || $(e.currentTarget).is('.new')) {\n                    return;\n                }\n                var $form = $(this).closest('form');\n                setTimeout(function () {\n                    $form.submit();\n                }, 200);\n            });\n            //changedate is not suitable as it triggered when showing datepicker. see #149\n            /*\n            this.$input.on('changeDate', function(e){\n                var $form = $(this).closest('form');\n                setTimeout(function() {\n                    $form.submit();\n                }, 200);\n            });\n            */\n        },\n\n        /*\n         For incorrect date bootstrap-datepicker returns current date that is not suitable\n         for datefield.\n         This function returns null for incorrect date.  \n        */\n        parseDate: function parseDate(str, format) {\n            var date = null,\n                formattedBack;\n            if (str) {\n                date = this.dpg.parseDate(str, format, this.options.datepicker.language);\n                if (typeof str === 'string') {\n                    formattedBack = this.dpg.formatDate(date, format, this.options.datepicker.language);\n                    if (str !== formattedBack) {\n                        date = null;\n                    }\n                }\n            }\n            return date;\n        }\n\n    });\n\n    Date.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/\n        tpl: '<div class=\"editable-date well\"></div>',\n        /**\n        @property inputclass \n        @default null\n        **/\n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        Possible tokens are: <code>d, dd, m, mm, yy, yyyy</code>  \n         @property format \n        @type string\n        @default yyyy-mm-dd\n        **/\n        format: 'yyyy-mm-dd',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to <code>format</code>\n         @property viewformat \n        @type string\n        @default null\n        **/\n        viewformat: null,\n        /**\n        Configuration of datepicker.\n        Full list of options: http://bootstrap-datepicker.readthedocs.org/en/latest/options.html\n         @property datepicker \n        @type object\n        @default {\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: false\n        }\n        **/\n        datepicker: {\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: false\n        },\n        /**\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n         @property clear \n        @type boolean|string\n        @default 'x clear'\n        **/\n        clear: '&times; clear'\n    });\n\n    $.fn.editabletypes.date = Date;\n})(window.jQuery);\n\n/**\nBootstrap datefield input - modification for inline mode.\nShows normal <input type=\"text\"> and binds popup datepicker.  \nAutomatically shown in inline mode.\n\n@class datefield\n@extends date\n\n@since 1.4.0\n**/\n(function ($) {\n    ;\n\n    var DateField = function DateField(options) {\n        this.init('datefield', options, DateField.defaults);\n        this.initPicker(options, DateField.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateField, $.fn.editabletypes.date);\n\n    $.extend(DateField.prototype, {\n        render: function render() {\n            this.$input = this.$tpl.find('input');\n            this.setClass();\n            this.setAttr('placeholder');\n\n            //bootstrap-datepicker is set `bdateicker` to exclude conflict with jQuery UI one. (in date.js)        \n            this.$tpl.bdatepicker(this.options.datepicker);\n\n            //need to disable original event handlers\n            this.$input.off('focus keydown');\n\n            //update value of datepicker\n            this.$input.keyup($.proxy(function () {\n                this.$tpl.removeData('date');\n                this.$tpl.bdatepicker('update');\n            }, this));\n        },\n\n        value2input: function value2input(value) {\n            this.$input.val(value ? this.dpg.formatDate(value, this.parsedViewFormat, this.options.datepicker.language) : '');\n            this.$tpl.bdatepicker('update');\n        },\n\n        input2value: function input2value() {\n            return this.html2value(this.$input.val());\n        },\n\n        activate: function activate() {\n            $.fn.editabletypes.text.prototype.activate.call(this);\n        },\n\n        autosubmit: function autosubmit() {\n            //reset autosubmit to empty  \n        }\n    });\n\n    DateField.defaults = $.extend({}, $.fn.editabletypes.date.defaults, {\n        /**\n        @property tpl \n        **/\n        tpl: '<div class=\"input-append date\"><input type=\"text\"/><span class=\"add-on\"><i class=\"icon-th\"></i></span></div>',\n        /**\n        @property inputclass \n        @default 'input-small'\n        **/\n        inputclass: 'input-small',\n\n        /* datepicker config */\n        datepicker: {\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: true\n        }\n    });\n\n    $.fn.editabletypes.datefield = DateField;\n})(window.jQuery);\n/**\nBootstrap-datetimepicker.  \nBased on [smalot bootstrap-datetimepicker plugin](https://github.com/smalot/bootstrap-datetimepicker). \nBefore usage you should manually include dependent js and css:\n\n    <link href=\"css/datetimepicker.css\" rel=\"stylesheet\" type=\"text/css\"></link> \n    <script src=\"js/bootstrap-datetimepicker.js\"><\/script>\n\nFor **i18n** you should include js file from here: https://github.com/smalot/bootstrap-datetimepicker/tree/master/js/locales\nand set `language` option.  \n\n@class datetime\n@extends abstractinput\n@final\n@since 1.4.4\n@example\n<a href=\"#\" id=\"last_seen\" data-type=\"datetime\" data-pk=\"1\" data-url=\"/post\" title=\"Select date & time\">15/03/2013 12:45</a>\n<script>\n$(function(){\n    $('#last_seen').editable({\n        format: 'yyyy-mm-dd hh:ii',    \n        viewformat: 'dd/mm/yyyy hh:ii',    \n        datetimepicker: {\n                weekStart: 1\n           }\n        }\n    });\n});\n<\/script>\n**/\n(function ($) {\n    ;\n\n    var DateTime = function DateTime(options) {\n        this.init('datetime', options, DateTime.defaults);\n        this.initPicker(options, DateTime.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateTime, $.fn.editabletypes.abstractinput);\n\n    $.extend(DateTime.prototype, {\n        initPicker: function initPicker(options, defaults) {\n            //'format' is set directly from settings or data-* attributes\n\n            //by default viewformat equals to format\n            if (!this.options.viewformat) {\n                this.options.viewformat = this.options.format;\n            }\n\n            //try parse datetimepicker config defined as json string in data-datetimepicker\n            options.datetimepicker = $.fn.editableutils.tryParseJson(options.datetimepicker, true);\n\n            //overriding datetimepicker config (as by default jQuery extend() is not recursive)\n            //since 1.4 datetimepicker internally uses viewformat instead of format. Format is for submit only\n            this.options.datetimepicker = $.extend({}, defaults.datetimepicker, options.datetimepicker, {\n                format: this.options.viewformat\n            });\n\n            //language\n            this.options.datetimepicker.language = this.options.datetimepicker.language || 'en';\n\n            //store DPglobal\n            this.dpg = $.fn.datetimepicker.DPGlobal;\n\n            //store parsed formats\n            this.parsedFormat = this.dpg.parseFormat(this.options.format, this.options.formatType);\n            this.parsedViewFormat = this.dpg.parseFormat(this.options.viewformat, this.options.formatType);\n        },\n\n        render: function render() {\n            this.$input.datetimepicker(this.options.datetimepicker);\n\n            //adjust container position when viewMode changes\n            //see https://github.com/smalot/bootstrap-datetimepicker/pull/80\n            this.$input.on('changeMode', function (e) {\n                var f = $(this).closest('form').parent();\n                //timeout here, otherwise container changes position before form has new size\n                setTimeout(function () {\n                    f.triggerHandler('resize');\n                }, 0);\n            });\n\n            //\"clear\" link\n            if (this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function (e) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n\n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));\n            }\n        },\n\n        value2html: function value2html(value, element) {\n            //formatDate works with UTCDate!\n            var text = value ? this.dpg.formatDate(this.toUTC(value), this.parsedViewFormat, this.options.datetimepicker.language, this.options.formatType) : '';\n            if (element) {\n                DateTime.superclass.value2html.call(this, text, element);\n            } else {\n                return text;\n            }\n        },\n\n        html2value: function html2value(html) {\n            //parseDate return utc date!\n            var value = this.parseDate(html, this.parsedViewFormat);\n            return value ? this.fromUTC(value) : null;\n        },\n\n        value2str: function value2str(value) {\n            //formatDate works with UTCDate!\n            return value ? this.dpg.formatDate(this.toUTC(value), this.parsedFormat, this.options.datetimepicker.language, this.options.formatType) : '';\n        },\n\n        str2value: function str2value(str) {\n            //parseDate return utc date!\n            var value = this.parseDate(str, this.parsedFormat);\n            return value ? this.fromUTC(value) : null;\n        },\n\n        value2submit: function value2submit(value) {\n            return this.value2str(value);\n        },\n\n        value2input: function value2input(value) {\n            if (value) {\n                this.$input.data('datetimepicker').setDate(value);\n            }\n        },\n\n        input2value: function input2value() {\n            //date may be cleared, in that case getDate() triggers error\n            var dt = this.$input.data('datetimepicker');\n            return dt.date ? dt.getDate() : null;\n        },\n\n        activate: function activate() {},\n\n        clear: function clear() {\n            this.$input.data('datetimepicker').date = null;\n            this.$input.find('.active').removeClass('active');\n            if (!this.options.showbuttons) {\n                this.$input.closest('form').submit();\n            }\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.on('mouseup', '.minute', function (e) {\n                var $form = $(this).closest('form');\n                setTimeout(function () {\n                    $form.submit();\n                }, 200);\n            });\n        },\n\n        //convert date from local to utc\n        toUTC: function toUTC(value) {\n            return value ? new Date(value.valueOf() - value.getTimezoneOffset() * 60000) : value;\n        },\n\n        //convert date from utc to local\n        fromUTC: function fromUTC(value) {\n            return value ? new Date(value.valueOf() + value.getTimezoneOffset() * 60000) : value;\n        },\n\n        /*\n         For incorrect date bootstrap-datetimepicker returns current date that is not suitable\n         for datetimefield.\n         This function returns null for incorrect date.  \n        */\n        parseDate: function parseDate(str, format) {\n            var date = null,\n                formattedBack;\n            if (str) {\n                date = this.dpg.parseDate(str, format, this.options.datetimepicker.language, this.options.formatType);\n                if (typeof str === 'string') {\n                    formattedBack = this.dpg.formatDate(date, format, this.options.datetimepicker.language, this.options.formatType);\n                    if (str !== formattedBack) {\n                        date = null;\n                    }\n                }\n            }\n            return date;\n        }\n\n    });\n\n    DateTime.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/\n        tpl: '<div class=\"editable-date well\"></div>',\n        /**\n        @property inputclass \n        @default null\n        **/\n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        Possible tokens are: <code>d, dd, m, mm, yy, yyyy, h, i</code>  \n        \n        @property format \n        @type string\n        @default yyyy-mm-dd hh:ii\n        **/\n        format: 'yyyy-mm-dd hh:ii',\n        formatType: 'standard',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to <code>format</code>\n        \n        @property viewformat \n        @type string\n        @default null\n        **/\n        viewformat: null,\n        /**\n        Configuration of datetimepicker.\n        Full list of options: https://github.com/smalot/bootstrap-datetimepicker\n         @property datetimepicker \n        @type object\n        @default { }\n        **/\n        datetimepicker: {\n            todayHighlight: false,\n            autoclose: false\n        },\n        /**\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n         @property clear \n        @type boolean|string\n        @default 'x clear'\n        **/\n        clear: '&times; clear'\n    });\n\n    $.fn.editabletypes.datetime = DateTime;\n})(window.jQuery);\n/**\nBootstrap datetimefield input - datetime input for inline mode.\nShows normal <input type=\"text\"> and binds popup datetimepicker.  \nAutomatically shown in inline mode.\n\n@class datetimefield\n@extends datetime\n\n**/\n(function ($) {\n    ;\n\n    var DateTimeField = function DateTimeField(options) {\n        this.init('datetimefield', options, DateTimeField.defaults);\n        this.initPicker(options, DateTimeField.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateTimeField, $.fn.editabletypes.datetime);\n\n    $.extend(DateTimeField.prototype, {\n        render: function render() {\n            this.$input = this.$tpl.find('input');\n            this.setClass();\n            this.setAttr('placeholder');\n\n            this.$tpl.datetimepicker(this.options.datetimepicker);\n\n            //need to disable original event handlers\n            this.$input.off('focus keydown');\n\n            //update value of datepicker\n            this.$input.keyup($.proxy(function () {\n                this.$tpl.removeData('date');\n                this.$tpl.datetimepicker('update');\n            }, this));\n        },\n\n        value2input: function value2input(value) {\n            this.$input.val(this.value2html(value));\n            this.$tpl.datetimepicker('update');\n        },\n\n        input2value: function input2value() {\n            return this.html2value(this.$input.val());\n        },\n\n        activate: function activate() {\n            $.fn.editabletypes.text.prototype.activate.call(this);\n        },\n\n        autosubmit: function autosubmit() {\n            //reset autosubmit to empty  \n        }\n    });\n\n    DateTimeField.defaults = $.extend({}, $.fn.editabletypes.datetime.defaults, {\n        /**\n        @property tpl \n        **/\n        tpl: '<div class=\"input-append date\"><input type=\"text\"/><span class=\"add-on\"><i class=\"icon-th\"></i></span></div>',\n        /**\n        @property inputclass \n        @default 'input-medium'\n        **/\n        inputclass: 'input-medium',\n\n        /* datetimepicker config */\n        datetimepicker: {\n            todayHighlight: false,\n            autoclose: true\n        }\n    });\n\n    $.fn.editabletypes.datetimefield = DateTimeField;\n})(window.jQuery);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvanMvYm9vdHN0cmFwLWVkaXRhYmxlLmpzPzI5MzQiXSwibmFtZXMiOlsiJCIsIkVkaXRhYmxlRm9ybSIsImRpdiIsIm9wdGlvbnMiLCJleHRlbmQiLCJmbiIsImVkaXRhYmxlZm9ybSIsImRlZmF1bHRzIiwiJGRpdiIsInNjb3BlIiwicHJvdG90eXBlIiwiY29uc3RydWN0b3IiLCJpbml0SW5wdXQiLCJpbnB1dCIsInZhbHVlIiwic3RyMnZhbHVlIiwicHJlcmVuZGVyIiwiaW5pdFRlbXBsYXRlIiwiJGZvcm0iLCJ0ZW1wbGF0ZSIsImluaXRCdXR0b25zIiwiJGJ0biIsImZpbmQiLCJhcHBlbmQiLCJidXR0b25zIiwic2hvd2J1dHRvbnMiLCJhZGRDbGFzcyIsInJlbmRlciIsIiRsb2FkaW5nIiwibG9hZGluZyIsImVtcHR5IiwicmVtb3ZlIiwic2hvd0xvYWRpbmciLCJpc1NhdmluZyIsInRyaWdnZXJIYW5kbGVyIiwiJHRwbCIsIndoZW4iLCJ0aGVuIiwicHJveHkiLCJhdXRvc3VibWl0IiwiY2xpY2siLCJjYW5jZWwiLCJlcnJvciIsImF0dHIiLCIkaW5wdXQiLCJzdWJtaXQiLCJlIiwicHJldmVudERlZmF1bHQiLCJyZW1vdmVBdHRyIiwidW5kZWZpbmVkIiwiZGVmYXVsdFZhbHVlIiwidmFsdWUyaW5wdXQiLCJzaG93Rm9ybSIsInBvc3RyZW5kZXIiLCJ3IiwiaCIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsIndpZHRoIiwiaGVpZ2h0IiwiaGlkZSIsInBhcmVudCIsInNob3ciLCJhY3RpdmF0ZSIsIm1zZyIsIiRncm91cCIsIiRibG9jayIsImxpbmVzIiwicmVtb3ZlQ2xhc3MiLCJlcnJvckdyb3VwQ2xhc3MiLCJlcnJvckJsb2NrQ2xhc3MiLCJzcGxpdCIsImkiLCJsZW5ndGgiLCJ0ZXh0IiwiaHRtbCIsImpvaW4iLCJzdG9wUHJvcGFnYXRpb24iLCJuZXdWYWx1ZSIsImlucHV0MnZhbHVlIiwidmFsaWRhdGUiLCJ0eXBlIiwic2F2ZW5vY2hhbmdlIiwidmFsdWUyc3RyIiwic3VibWl0VmFsdWUiLCJ2YWx1ZTJzdWJtaXQiLCJzYXZlIiwiZG9uZSIsInJlc3BvbnNlIiwicmVzIiwic3VjY2VzcyIsImNhbGwiLCJoYXNPd25Qcm9wZXJ0eSIsImZhaWwiLCJ4aHIiLCJyZXNwb25zZVRleHQiLCJzdGF0dXNUZXh0IiwicGsiLCJlZGl0YWJsZXV0aWxzIiwidHJ5UGFyc2VKc29uIiwic2VuZCIsInVybCIsInBhcmFtcyIsIm5hbWUiLCJhamF4IiwiZGF0YSIsImFqYXhPcHRpb25zIiwib3B0aW9uIiwia2V5Iiwic2V0VmFsdWUiLCJjb252ZXJ0U3RyIiwiaXMiLCJhcmdzIiwiYXJndW1lbnRzIiwiZWFjaCIsIiR0aGlzIiwiYXBwbHkiLCJBcnJheSIsInNsaWNlIiwiQ29uc3RydWN0b3IiLCJlbmdpbmUiLCJ3aW5kb3ciLCJqUXVlcnkiLCJpbmhlcml0IiwiQ2hpbGQiLCJQYXJlbnQiLCJGIiwic3VwZXJjbGFzcyIsInNldEN1cnNvclBvc2l0aW9uIiwiZWxlbSIsInBvcyIsInNldFNlbGVjdGlvblJhbmdlIiwiY3JlYXRlVGV4dFJhbmdlIiwicmFuZ2UiLCJjb2xsYXBzZSIsIm1vdmVFbmQiLCJtb3ZlU3RhcnQiLCJzZWxlY3QiLCJzIiwic2FmZSIsIm1hdGNoIiwiRnVuY3Rpb24iLCJzbGljZU9iaiIsIm9iaiIsImtleXMiLCJjYXNlU2Vuc2l0aXZlIiwia2V5TG93ZXIiLCJuZXdPYmoiLCJpc0FycmF5IiwidG9Mb3dlckNhc2UiLCJnZXRDb25maWdEYXRhIiwiJGVsZW1lbnQiLCJrIiwidiIsIk9iamVjdCIsIm9iamVjdEtleXMiLCJvIiwiVHlwZUVycm9yIiwicCIsInB1c2giLCJlc2NhcGUiLCJzdHIiLCJpdGVtc0J5VmFsdWUiLCJzb3VyY2VEYXRhIiwidmFsdWVQcm9wIiwiaWRLZXkiLCJpc1ZhbEFycmF5IiwicmVzdWx0IiwidGhhdCIsImNoaWxkcmVuIiwiY29uY2F0IiwiZ3JlcCIsIml0ZW1WYWx1ZSIsImNyZWF0ZUlucHV0IiwiVHlwZUNvbnN0cnVjdG9yIiwidHlwZU9wdGlvbnMiLCJtb2RlIiwiZWRpdGFibGV0eXBlcyIsImRhdGVmaWVsZCIsImRhdGV1aWZpZWxkIiwiZGF0ZSIsImRhdGV1aSIsInN1cHBvcnRzVHJhbnNpdGlvbnMiLCJiIiwiZG9jdW1lbnQiLCJib2R5IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInN1YnN0ciIsIlBvcHVwIiwiZWxlbWVudCIsImluaXQiLCJJbmxpbmUiLCJjb250YWluZXJOYW1lIiwiY29udGFpbmVyRGF0YU5hbWUiLCJpbm5lckNzcyIsImNvbnRhaW5lckNsYXNzIiwiZWRpdGFibGVDb250YWluZXIiLCJzcGxpdE9wdGlvbnMiLCJmb3JtT3B0aW9ucyIsImluaXRDb250YWluZXIiLCJkZWxheWVkSGlkZSIsIm9uIiwiZGVzdHJveSIsIndoaWNoIiwiJHRhcmdldCIsInRhcmdldCIsImV4Y2x1ZGVfY2xhc3NlcyIsImNvbnRhaW5zIiwicGFyZW50cyIsImNsb3NlT3RoZXJzIiwiY29udGFpbmVyT3B0aW9ucyIsIkVycm9yIiwidGlwIiwiY29udGFpbmVyIiwiJHRpcCIsInJlbmRlckZvcm0iLCJub2NoYW5nZSIsInJlYXNvbiIsInNldFBvc2l0aW9uIiwicmVuZGVyaW5nIiwicmVzaXplIiwicmVuZGVyZWQiLCJjbG9zZUFsbCIsImlubmVyU2hvdyIsImhhc0NsYXNzIiwiaW5uZXJIaWRlIiwidG9nZ2xlIiwic2V0Q29udGFpbmVyT3B0aW9uIiwiaW5uZXJEZXN0cm95Iiwib2ZmIiwicmVtb3ZlRGF0YSIsImVsIiwiJGVsIiwiZWMiLCJvbmJsdXIiLCJkYXRhS2V5IiwicGxhY2VtZW50IiwiYXV0b2hpZGUiLCJhbmltIiwiZXZlbnQiLCJzcGVjaWFsIiwiZGVzdHJveWVkIiwiaGFuZGxlciIsImluc2VydEFmdGVyIiwiRWRpdGFibGUiLCJlZGl0YWJsZSIsInNlbGVjdG9yIiwiaW5pdExpdmUiLCJoaWdobGlnaHQiLCJpc1ZhbHVlQnlUZXh0IiwiZG9BdXRvdGV4dCIsImZpbmFsaXplIiwiaHRtbDJ2YWx1ZSIsInRyaW0iLCJkaXNhYmxlZCIsImRpc3BsYXkiLCJhdXRvdGV4dCIsImRpc2FibGUiLCJlbmFibGUiLCJlbXB0eWNsYXNzIiwidHJpZ2dlciIsInZhbHVlMmh0bWxGaW5hbCIsInZhbHVlMmh0bWwiLCJoYW5kbGVFbXB0eSIsImlzRW1wdHkiLCJ0b2dnbGVEaXNhYmxlZCIsImVtcHR5dGV4dCIsInVuc2F2ZWRjbGFzcyIsInNlbnQiLCIkZSIsImJnQ29sb3IiLCJjc3MiLCJzZXRUaW1lb3V0IiwiZGF0YWtleSIsImVxIiwiY29uZmlnIiwiJGVsZW1zIiwiZXJyb3JzIiwiaXNFbXB0eU9iamVjdCIsInZhbHVlcyIsIm5vb3AiLCJBYnN0cmFjdElucHV0IiwidHBsIiwiJGNsZWFyIiwidmFsIiwiZm9jdXMiLCJjbGVhciIsInNldENsYXNzIiwiaW5wdXRjbGFzcyIsInNldEF0dHIiLCJhYnN0cmFjdGlucHV0IiwiTGlzdCIsImRlZmVycmVkIiwiRGVmZXJyZWQiLCJvblNvdXJjZVJlYWR5IiwicmVuZGVyTGlzdCIsInJlc29sdmUiLCJzb3VyY2VFcnJvciIsInByb21pc2UiLCJzb3VyY2UiLCJpc0Z1bmN0aW9uIiwic291cmNlQ2FjaGUiLCJjYWNoZUlEIiwiY2FjaGUiLCJkb1ByZXBlbmQiLCJjYWxsYmFja3MiLCJlcnJfY2FsbGJhY2tzIiwiZGF0YVR5cGUiLCJtYWtlQXJyYXkiLCJzb3VyY2VPcHRpb25zIiwicHJlcGVuZCIsInByZXBlbmREYXRhIiwiY291bnQiLCJpdGVtIiwiaXRlcmF0ZUl0ZW0iLCJsaXN0IiwiVGV4dCIsInJlbmRlckNsZWFyIiwiZ2V0IiwidG9nZ2xlQ2xlYXIiLCJhZnRlciIsImtleXVwIiwiaW5BcnJheSIsImtleUNvZGUiLCJjbGVhclRpbWVvdXQiLCJ0IiwibGVuIiwidmlzaWJsZSIsInBsYWNlaG9sZGVyIiwiVGV4dGFyZWEiLCJrZXlkb3duIiwiY3RybEtleSIsImNsb3Nlc3QiLCJyb3dzIiwidGV4dGFyZWEiLCJTZWxlY3QiLCJmaWxsSXRlbXMiLCJsYWJlbCIsIml0ZW1zIiwiQ2hlY2tsaXN0IiwiJGxhYmVsIiwiYXBwZW5kVG8iLCJzb3J0Iiwic2VwYXJhdG9yIiwicmVnIiwiUmVnRXhwIiwicHJvcCIsImoiLCJjaGVja2VkIiwiZmlsdGVyIiwiZmlyc3QiLCJjaGVja2xpc3QiLCJQYXNzd29yZCIsInBhc3N3b3JkIiwiRW1haWwiLCJlbWFpbCIsIlVybCIsIlRlbCIsInRlbCIsIk51bWJlcklucHV0IiwicmlnaHQiLCJtaW4iLCJtYXgiLCJzdGVwIiwibnVtYmVyIiwiUmFuZ2UiLCJzaWJsaW5ncyIsIlRpbWUiLCJ0aW1lIiwic2VsZWN0MiIsInRhZ3MiLCJ0ZXJtIiwicXVlcnkiLCJyZXN1bHRzIiwiY29udmVydFNvdXJjZSIsImlzTXVsdGlwbGUiLCJtdWx0aXBsZSIsImlzUmVtb3RlIiwiaWRGdW5jIiwiaWQiLCJmb3JtYXRTZWxlY3Rpb24iLCJ2aWV3c2VwYXJhdG9yIiwiZ2V0U2VwYXJhdG9yIiwiaW5pdFNlbGVjdGlvbiIsImN1c3RvbUlkIiwiY3VzdG9tVGV4dCIsImwiLCJpc0luaXRpYWwiLCJDb21ib2RhdGUiLCJjb21ib2RhdGUiLCJtYXAiLCJkYXkiLCJtb250aCIsInllYXIiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwiYW1wbSIsIiR3aWRnZXQiLCJnZXRUZW1wbGF0ZSIsImluaXRDb21ib3MiLCJnZXRWYWx1ZSIsImNoYW5nZSIsInNtYXJ0RGF5cyIsImZpbGxDb21ibyIsInIiLCJ0b2tlbiIsInN1YnN0cmluZyIsInJlcGxhY2UiLCIkYyIsIiRjb21ibyIsImYiLCJmaWxsQ29tbW9uIiwicmVsVGltZSIsImZpcnN0SXRlbSIsIm1vbWVudCIsInJlbGF0aXZlVGltZSIsImxhbmdEYXRhIiwiX3JlbGF0aXZlVGltZSIsImhlYWRlciIsInJldmVyc2UiLCJmaWxsRGF5IiwidHdvRGlnaXQiLCJpbmRleE9mIiwiZGF5c0NvdW50IiwiJG1vbnRoIiwiJHllYXIiLCJwYXJzZUludCIsImlzTmFOIiwiZGF5c0luTW9udGgiLCJsZWFkWmVybyIsImZpbGxNb250aCIsImxvbmdOYW1lcyIsInNob3J0TmFtZXMiLCJmb3JtYXQiLCJmaWxsWWVhciIsIm1heFllYXIiLCJtaW5ZZWFyIiwieWVhckRlc2NlbmRpbmciLCJmaWxsSG91ciIsImgxMiIsImgyNCIsImZpbGxNaW51dGUiLCJtaW51dGVTdGVwIiwiZmlsbFNlY29uZCIsInNlY29uZFN0ZXAiLCJmaWxsQW1wbSIsImFtcG1MIiwiYW1wbVUiLCJkdCIsIm5vdFNlbGVjdGVkIiwiZGVmIiwiJGFtcG0iLCJpc1ZhbGlkIiwiZ2V0TmVhcmVzdCIsIiRzZWxlY3QiLCJkZWx0YSIsIm9wdCIsIm9wdFZhbHVlIiwiZGlzdGFuY2UiLCJNYXRoIiwiYWJzIiwicm91bmRUaW1lIiwiZXJyb3JDbGFzcyIsImJvcmRlckNvbG9yIiwiZCIsInNoaWZ0Iiwidmlld2Zvcm1hdCIsInBJbml0SW5wdXQiLCJlbXB0eUlucHV0Q2xhc3MiLCJkZWZhdWx0Q2xhc3MiLCJzdGR0eXBlcyIsImNsYXNzZXMiLCJwb3BvdmVyIiwiREVGQVVMVFMiLCJjb250ZW50IiwiYXV0b1Rva2VuIiwiYXV0b1BsYWNlIiwidGVzdCIsImdldFBvc2l0aW9uIiwiYWN0dWFsV2lkdGgiLCJvZmZzZXRXaWR0aCIsImFjdHVhbEhlaWdodCIsIm9mZnNldEhlaWdodCIsIiRwYXJlbnQiLCJvcmdQbGFjZW1lbnQiLCJkb2NTY3JvbGwiLCJzY3JvbGxUb3AiLCJwYXJlbnRXaWR0aCIsImlubmVyV2lkdGgiLCJwYXJlbnRIZWlnaHQiLCJpbm5lckhlaWdodCIsInBhcmVudExlZnQiLCJvZmZzZXQiLCJsZWZ0IiwidG9wIiwiY2FsY3VsYXRlZE9mZnNldCIsImdldENhbGN1bGF0ZWRPZmZzZXQiLCJhcHBseVBsYWNlbWVudCIsIlVUQ0RhdGUiLCJEYXRlIiwiVVRDIiwiVVRDVG9kYXkiLCJ0b2RheSIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiRGF0ZXBpY2tlciIsIl9wcm9jZXNzX29wdGlvbnMiLCJpc0lubGluZSIsImlzSW5wdXQiLCJjb21wb25lbnQiLCJoYXNJbnB1dCIsInBpY2tlciIsIkRQR2xvYmFsIiwiX2J1aWxkRXZlbnRzIiwiX2F0dGFjaEV2ZW50cyIsInJ0bCIsInRvZ2dsZUNsYXNzIiwidmlld01vZGUiLCJzdGFydFZpZXciLCJjYWxlbmRhcldlZWtzIiwiX2FsbG93X3VwZGF0ZSIsInNldFN0YXJ0RGF0ZSIsInN0YXJ0RGF0ZSIsInNldEVuZERhdGUiLCJlbmREYXRlIiwic2V0RGF5c09mV2Vla0Rpc2FibGVkIiwiZGF5c09mV2Vla0Rpc2FibGVkIiwiZmlsbERvdyIsImZpbGxNb250aHMiLCJ1cGRhdGUiLCJzaG93TW9kZSIsIm9wdHMiLCJfbyIsImxhbmciLCJsYW5ndWFnZSIsImRhdGVzIiwibWluVmlld01vZGUiLCJ3ZWVrU3RhcnQiLCJ3ZWVrRW5kIiwicGFyc2VGb3JtYXQiLCJJbmZpbml0eSIsInBhcnNlRGF0ZSIsIl9ldmVudHMiLCJfc2Vjb25kYXJ5RXZlbnRzIiwiX2FwcGx5RXZlbnRzIiwiZXZzIiwiZXYiLCJfdW5hcHBseUV2ZW50cyIsInBsYWNlIiwibW91c2Vkb3duIiwic2l6ZSIsIl9kZXRhY2hFdmVudHMiLCJfYXR0YWNoU2Vjb25kYXJ5RXZlbnRzIiwiX2RldGFjaFNlY29uZGFyeUV2ZW50cyIsIl90cmlnZ2VyIiwiYWx0ZGF0ZSIsImxvY2FsX2RhdGUiLCJnZXRUaW1lIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJhbHRmb3JtYXQiLCJmb3JtYXREYXRlIiwiZGV0YWNoIiwiZm9yY2VQYXJzZSIsImRhdGVwaWNrZXIiLCJnZXREYXRlIiwic2V0RGF0ZSIsInNldFVUQ0RhdGUiLCJmb3JtYXR0ZWQiLCJnZXRGb3JtYXR0ZWREYXRlIiwidXBkYXRlTmF2QXJyb3dzIiwiekluZGV4IiwiZnJvbUFyZ3MiLCJ2aWV3RGF0ZSIsImZpbGwiLCJkb3dDbnQiLCJjZWxsIiwiZGF5c01pbiIsIm1vbnRoc1Nob3J0Iiwic2V0UmFuZ2UiLCJ2YWx1ZU9mIiwiZ2V0Q2xhc3NOYW1lcyIsImNscyIsImN1cnJlbnREYXRlIiwidG9kYXlIaWdobGlnaHQiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0VVRDRGF5Iiwic3RhcnRZZWFyIiwic3RhcnRNb250aCIsImVuZFllYXIiLCJlbmRNb250aCIsInRvb2x0aXAiLCJtb250aHMiLCJ0b2RheUJ0biIsImNsZWFyQnRuIiwicHJldk1vbnRoIiwiZ2V0RGF5c0luTW9udGgiLCJuZXh0TW9udGgiLCJjbHNOYW1lIiwid3MiLCJ0aCIsInl0aCIsImNhbFdlZWsiLCJiZWZvcmUiLCJiZWZvcmVTaG93RGF5IiwiZW5hYmxlZCIsInVuaXF1ZSIsImN1cnJlbnRZZWFyIiwiZW5kIiwieWVhckNvbnQiLCJ2aXNpYmlsaXR5Iiwibm9kZU5hbWUiLCJjbGFzc05hbWUiLCJkaXIiLCJtb2RlcyIsIm5hdlN0ZXAiLCJtb3ZlTW9udGgiLCJtb3ZlWWVhciIsIl9zZXREYXRlIiwiYXV0b2Nsb3NlIiwiaW5kZXgiLCJzZXRVVENNb250aCIsInNldFVUQ0Z1bGxZZWFyIiwibmV3X2RhdGUiLCJtYWciLCJuZXdfbW9udGgiLCJkYXRlV2l0aGluUmFuZ2UiLCJkYXRlQ2hhbmdlZCIsIm5ld0RhdGUiLCJuZXdWaWV3RGF0ZSIsImtleWJvYXJkTmF2aWdhdGlvbiIsInNoaWZ0S2V5IiwiRGF0ZVJhbmdlUGlja2VyIiwiaW5wdXRzIiwianF1ZXJ5IiwiYmluZCIsImRhdGVVcGRhdGVkIiwicGlja2VycyIsInVwZGF0ZURhdGVzIiwidXBkYXRlUmFuZ2VzIiwiZHAiLCJvcHRzX2Zyb21fZWwiLCJwcmVmaXgiLCJvdXQiLCJpbmtleSIsIl8iLCJhIiwib3B0c19mcm9tX2xvY2FsZSIsImxvY2FsZV9vcHRzIiwib2xkIiwiaW50ZXJuYWxfcmV0dXJuIiwidGhpc19yZXR1cm4iLCJlbG9wdHMiLCJ4b3B0cyIsImxvY29wdHMiLCJyb3B0cyIsInRvQXJyYXkiLCJlbiIsImRheXMiLCJkYXlzU2hvcnQiLCJuYXZGbmMiLCJpc0xlYXBZZWFyIiwidmFsaWRQYXJ0cyIsIm5vbnB1bmN0dWF0aW9uIiwic2VwYXJhdG9ycyIsInBhcnRzIiwicGFydF9yZSIsInBhcnQiLCJleGVjIiwicGFyc2VkIiwic2V0dGVyc19vcmRlciIsInNldHRlcnNfbWFwIiwieXl5eSIsInl5IiwibSIsImZpbHRlcmVkIiwiZnBhcnRzIiwiY250IiwiRCIsIkREIiwiTSIsIk1NIiwidG9TdHJpbmciLCJkZCIsIm1tIiwic2VwcyIsImhlYWRUZW1wbGF0ZSIsImNvbnRUZW1wbGF0ZSIsImZvb3RUZW1wbGF0ZSIsIm5vQ29uZmxpY3QiLCJiZGF0ZXBpY2tlciIsImluaXRQaWNrZXIiLCJkcGciLCJwYXJzZWRGb3JtYXQiLCJwYXJzZWRWaWV3Rm9ybWF0IiwiY3VycmVudFRhcmdldCIsImZvcm1hdHRlZEJhY2siLCJEYXRlRmllbGQiLCJEYXRlVGltZSIsImRhdGV0aW1lcGlja2VyIiwiZm9ybWF0VHlwZSIsInRvVVRDIiwiZnJvbVVUQyIsImRhdGV0aW1lIiwiRGF0ZVRpbWVGaWVsZCIsImRhdGV0aW1lZmllbGQiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7QUFJQTs7Ozs7Ozs7O0FBU0MsV0FBVUEsQ0FBVixFQUFhOztBQUVWLFFBQUlDLGVBQWUsU0FBZkEsWUFBZSxDQUFVQyxHQUFWLEVBQWVDLE9BQWYsRUFBd0I7QUFDdkMsYUFBS0EsT0FBTCxHQUFlSCxFQUFFSSxNQUFGLENBQVMsRUFBVCxFQUFhSixFQUFFSyxFQUFGLENBQUtDLFlBQUwsQ0FBa0JDLFFBQS9CLEVBQXlDSixPQUF6QyxDQUFmO0FBQ0EsYUFBS0ssSUFBTCxHQUFZUixFQUFFRSxHQUFGLENBQVosQ0FGdUMsQ0FFbkI7QUFDcEIsWUFBRyxDQUFDLEtBQUtDLE9BQUwsQ0FBYU0sS0FBakIsRUFBd0I7QUFDcEIsaUJBQUtOLE9BQUwsQ0FBYU0sS0FBYixHQUFxQixJQUFyQjtBQUNIO0FBQ0Q7QUFDSCxLQVBEOztBQVNBUixpQkFBYVMs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QW1CcWhCLGFBQW5CLEdBQW1DRCxhQUFuQztBQUVILENBbkVBLEVBbUVDNWtCLE9BQU9DLE1BbkVSLENBQUQiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBYLWVkaXRhYmxlIC0gdjEuNS4xIFxuKiBJbi1wbGFjZSBlZGl0aW5nIHdpdGggVHdpdHRlciBCb290c3RyYXAsIGpRdWVyeSBVSSBvciBwdXJlIGpRdWVyeVxuKiBodHRwOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlXG4qIENvcHlyaWdodCAoYykgMjAxMyBWaXRhbGl5IFBvdGFwb3Y7IExpY2Vuc2VkIE1JVCAqL1xuLyoqXG5Gb3JtIHdpdGggc2luZ2xlIGlucHV0IGVsZW1lbnQsIHR3byBidXR0b25zIGFuZCB0d28gc3RhdGVzOiBub3JtYWwvbG9hZGluZy5cbkFwcGxpZWQgYXMgalF1ZXJ5IG1ldGhvZCB0byBESVYgdGFnIChub3QgdG8gZm9ybSB0YWchKS4gVGhpcyBpcyBiZWNhdXNlIGZvcm0gY2FuIGJlIGluIGxvYWRpbmcgc3RhdGUgd2hlbiBzcGlubmVyIHNob3duLlxuRWRpdGFibGVmb3JtIGlzIGxpbmtlZCB3aXRoIG9uZSBvZiBpbnB1dCB0eXBlcywgZS5nLiAndGV4dCcsICdzZWxlY3QnIGV0Yy5cblxuQGNsYXNzIGVkaXRhYmxlZm9ybVxuQHVzZXMgdGV4dFxuQHVzZXMgdGV4dGFyZWFcbioqL1xuKGZ1bmN0aW9uICgkKSB7XG5cbiAgICB2YXIgRWRpdGFibGVGb3JtID0gZnVuY3Rpb24gKGRpdiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZWZvcm0uZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiRkaXYgPSAkKGRpdik7IC8vZGl2LCBjb250YWluaW5nIGZvcm0uIE5vdCBmb3JtIHRhZy4gTm90IGVkaXRhYmxlLWVsZW1lbnQuXG4gICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zY29wZSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy9ub3RoaW5nIHNob3duIGFmdGVyIGluaXRcbiAgICB9O1xuXG4gICAgRWRpdGFibGVGb3JtLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IEVkaXRhYmxlRm9ybSxcbiAgICAgICAgaW5pdElucHV0OiBmdW5jdGlvbigpIHsgIC8vY2FsbGVkIG9uY2VcbiAgICAgICAgICAgIC8vdGFrZSBpbnB1dCBmcm9tIG9wdGlvbnMgKGFzIGl0IGlzIGNyZWF0ZWQgaW4gZWRpdGFibGUtZWxlbWVudClcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLm9wdGlvbnMuaW5wdXQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2V0IGluaXRpYWwgdmFsdWVcbiAgICAgICAgICAgIC8vdG9kbzogbWF5IGJlIGFkZCBjaGVjazogdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmlucHV0LnN0cjJ2YWx1ZSh0aGlzLm9wdGlvbnMudmFsdWUpOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9wcmVyZW5kZXI6IGdldCBpbnB1dC4kaW5wdXRcbiAgICAgICAgICAgIHRoaXMuaW5wdXQucHJlcmVuZGVyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRUZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRmb3JtID0gJCgkLmZuLmVkaXRhYmxlZm9ybS50ZW1wbGF0ZSk7IFxuICAgICAgICB9LFxuICAgICAgICBpbml0QnV0dG9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgJGJ0biA9IHRoaXMuJGZvcm0uZmluZCgnLmVkaXRhYmxlLWJ1dHRvbnMnKTtcbiAgICAgICAgICAgICRidG4uYXBwZW5kKCQuZm4uZWRpdGFibGVmb3JtLmJ1dHRvbnMpO1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnNob3didXR0b25zID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICAgICRidG4uYWRkQ2xhc3MoJ2VkaXRhYmxlLWJ1dHRvbnMtYm90dG9tJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICBSZW5kZXJzIGVkaXRhYmxlZm9ybVxuXG4gICAgICAgIEBtZXRob2QgcmVuZGVyXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvL2luaXQgbG9hZGVyXG4gICAgICAgICAgICB0aGlzLiRsb2FkaW5nID0gJCgkLmZuLmVkaXRhYmxlZm9ybS5sb2FkaW5nKTsgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kZGl2LmVtcHR5KCkuYXBwZW5kKHRoaXMuJGxvYWRpbmcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2luaXQgZm9ybSB0ZW1wbGF0ZSBhbmQgYnV0dG9uc1xuICAgICAgICAgICAgdGhpcy5pbml0VGVtcGxhdGUoKTtcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5zaG93YnV0dG9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdEJ1dHRvbnMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtYnV0dG9ucycpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3Nob3cgbG9hZGluZyBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5zaG93TG9hZGluZygpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2ZsYWcgc2hvd2luZyBpcyBmb3JtIG5vdyBzYXZpbmcgdmFsdWUgdG8gc2VydmVyLiBcbiAgICAgICAgICAgIC8vSXQgaXMgbmVlZGVkIHRvIHdhaXQgd2hlbiBjbG9zaW5nIGZvcm0uXG4gICAgICAgICAgICB0aGlzLmlzU2F2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICBGaXJlZCB3aGVuIHJlbmRlcmluZyBzdGFydHNcbiAgICAgICAgICAgIEBldmVudCByZW5kZXJpbmcgXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAqKi8gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGRpdi50cmlnZ2VySGFuZGxlcigncmVuZGVyaW5nJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaW5pdCBpbnB1dFxuICAgICAgICAgICAgdGhpcy5pbml0SW5wdXQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hcHBlbmQgaW5wdXQgdG8gZm9ybVxuICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCdkaXYuZWRpdGFibGUtaW5wdXQnKS5hcHBlbmQodGhpcy5pbnB1dC4kdHBsKTsgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hcHBlbmQgZm9ybSB0byBjb250YWluZXJcbiAgICAgICAgICAgIHRoaXMuJGRpdi5hcHBlbmQodGhpcy4kZm9ybSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcmVuZGVyIGlucHV0XG4gICAgICAgICAgICAkLndoZW4odGhpcy5pbnB1dC5yZW5kZXIoKSlcbiAgICAgICAgICAgIC50aGVuKCQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vc2V0dXAgaW5wdXQgdG8gc3VibWl0IGF1dG9tYXRpY2FsbHkgd2hlbiBubyBidXR0b25zIHNob3duXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMub3B0aW9ucy5zaG93YnV0dG9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmF1dG9zdWJtaXQoKTsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL2F0dGFjaCAnY2FuY2VsJyBoYW5kbGVyXG4gICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtY2FuY2VsJykuY2xpY2soJC5wcm94eSh0aGlzLmNhbmNlbCwgdGhpcykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcih0aGlzLmlucHV0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtc3VibWl0JykuYXR0cignZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC4kaW5wdXQuYXR0cignZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IGZvcm0gZnJvbSBzdWJtaXR0aW5nXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uc3VibWl0KGZ1bmN0aW9uKGUpeyBlLnByZXZlbnREZWZhdWx0KCk7IH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LiRpbnB1dC5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1zdWJtaXQnKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAodGhpcy52YWx1ZSA9PT0gbnVsbCB8fCB0aGlzLnZhbHVlID09PSB1bmRlZmluZWQgfHwgdGhpcy52YWx1ZSA9PT0gJycpID8gdGhpcy5vcHRpb25zLmRlZmF1bHRWYWx1ZSA6IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQudmFsdWUyaW5wdXQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAvL2F0dGFjaCBzdWJtaXQgaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLnN1Ym1pdCgkLnByb3h5KHRoaXMuc3VibWl0LCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgICAgICBGaXJlZCB3aGVuIGZvcm0gaXMgcmVuZGVyZWRcbiAgICAgICAgICAgICAgICBAZXZlbnQgcmVuZGVyZWRcbiAgICAgICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgKiovICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy4kZGl2LnRyaWdnZXJIYW5kbGVyKCdyZW5kZXJlZCcpOyAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zvcm0oKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL2NhbGwgcG9zdHJlbmRlciBtZXRob2QgdG8gcGVyZm9ybSBhY3Rpb25zIHJlcXVpcmVkIHZpc2liaWxpdHkgb2YgZm9ybVxuICAgICAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQucG9zdHJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnBvc3RyZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkgeyAgIFxuICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgIEZpcmVkIHdoZW4gZm9ybSB3YXMgY2FuY2VsbGVkIGJ5IHVzZXJcbiAgICAgICAgICAgIEBldmVudCBjYW5jZWwgXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAqKi8gICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kZGl2LnRyaWdnZXJIYW5kbGVyKCdjYW5jZWwnKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2hvd0xvYWRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHcsIGg7XG4gICAgICAgICAgICBpZih0aGlzLiRmb3JtKSB7XG4gICAgICAgICAgICAgICAgLy9zZXQgbG9hZGluZyBzaXplIGVxdWFsIHRvIGZvcm1cbiAgICAgICAgICAgICAgICB3ID0gdGhpcy4kZm9ybS5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgICAgICAgaCA9IHRoaXMuJGZvcm0ub3V0ZXJIZWlnaHQoKTsgXG4gICAgICAgICAgICAgICAgaWYodykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2FkaW5nLndpZHRoKHcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvYWRpbmcuaGVpZ2h0KGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9zdHJldGNoIGxvYWRpbmcgdG8gZmlsbCBjb250YWluZXIgd2lkdGhcbiAgICAgICAgICAgICAgICB3ID0gdGhpcy4kbG9hZGluZy5wYXJlbnQoKS53aWR0aCgpO1xuICAgICAgICAgICAgICAgIGlmKHcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9hZGluZy53aWR0aCh3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRsb2FkaW5nLnNob3coKTsgXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvd0Zvcm06IGZ1bmN0aW9uKGFjdGl2YXRlKSB7XG4gICAgICAgICAgICB0aGlzLiRsb2FkaW5nLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuJGZvcm0uc2hvdygpO1xuICAgICAgICAgICAgaWYoYWN0aXZhdGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5hY3RpdmF0ZSgpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICBGaXJlZCB3aGVuIGZvcm0gaXMgc2hvd25cbiAgICAgICAgICAgIEBldmVudCBzaG93IFxuICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgKiovICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGRpdi50cmlnZ2VySGFuZGxlcignc2hvdycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgIHZhciAkZ3JvdXAgPSB0aGlzLiRmb3JtLmZpbmQoJy5jb250cm9sLWdyb3VwJyksXG4gICAgICAgICAgICAgICAgJGJsb2NrID0gdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtZXJyb3ItYmxvY2snKSxcbiAgICAgICAgICAgICAgICBsaW5lcztcblxuICAgICAgICAgICAgaWYobXNnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICRncm91cC5yZW1vdmVDbGFzcygkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckdyb3VwQ2xhc3MpO1xuICAgICAgICAgICAgICAgICRibG9jay5yZW1vdmVDbGFzcygkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckJsb2NrQ2xhc3MpLmVtcHR5KCkuaGlkZSgpOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IG5ld2xpbmUgdG8gPGJyPiBmb3IgbW9yZSBwcmV0dHkgZXJyb3IgZGlzcGxheVxuICAgICAgICAgICAgICAgIGlmKG1zZykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lcyA9ICgnJyttc2cpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbaV0gPSAkKCc8ZGl2PicpLnRleHQobGluZXNbaV0pLmh0bWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtc2cgPSBsaW5lcy5qb2luKCc8YnI+Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRncm91cC5hZGRDbGFzcygkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckdyb3VwQ2xhc3MpO1xuICAgICAgICAgICAgICAgICRibG9jay5hZGRDbGFzcygkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckJsb2NrQ2xhc3MpLmh0bWwobXNnKS5zaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3VibWl0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2dldCBuZXcgdmFsdWUgZnJvbSBpbnB1dFxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5pbnB1dC5pbnB1dDJ2YWx1ZSgpOyBcblxuICAgICAgICAgICAgLy92YWxpZGF0aW9uOiBpZiB2YWxpZGF0ZSByZXR1cm5zIHN0cmluZyBvciB0cnV0aHkgdmFsdWUgLSBtZWFucyBlcnJvclxuICAgICAgICAgICAgLy9pZiByZXR1cm5zIG9iamVjdCBsaWtlIHtuZXdWYWx1ZTogJy4uLid9ID0+IHN1Ym1pdHRlZCB2YWx1ZSBpcyByZWFzc2lnbmVkIHRvIGl0XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGlmICgkLnR5cGUoZXJyb3IpID09PSAnb2JqZWN0JyAmJiBlcnJvci5uZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBlcnJvci5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnZhbHVlMmlucHV0KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgZXJyb3IubXNnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yLm1zZyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zvcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dGb3JtKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiB2YWx1ZSBub3QgY2hhbmdlZCAtLT4gdHJpZ2dlciAnbm9jaGFuZ2UnIGV2ZW50IGFuZCByZXR1cm5cbiAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IHRydWUqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2F2ZW5vY2hhbmdlICYmIHRoaXMuaW5wdXQudmFsdWUyc3RyKG5ld1ZhbHVlKSA9PSB0aGlzLmlucHV0LnZhbHVlMnN0cih0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgLypqc2xpbnQgZXFlcTogZmFsc2UqLyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKiogICAgICAgIFxuICAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gdmFsdWUgbm90IGNoYW5nZWQgYnV0IGZvcm0gaXMgc3VibWl0dGVkLiBSZXF1aXJlcyBzYXZlbm9jaGFuZ2UgPSBmYWxzZS5cbiAgICAgICAgICAgICAgICBAZXZlbnQgbm9jaGFuZ2UgXG4gICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgICAgICoqLyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy4kZGl2LnRyaWdnZXJIYW5kbGVyKCdub2NoYW5nZScpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgIC8vY29udmVydCB2YWx1ZSBmb3Igc3VibWl0dGluZyB0byBzZXJ2ZXJcbiAgICAgICAgICAgIHZhciBzdWJtaXRWYWx1ZSA9IHRoaXMuaW5wdXQudmFsdWUyc3VibWl0KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5pc1NhdmluZyA9IHRydWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2VuZGluZyBkYXRhIHRvIHNlcnZlclxuICAgICAgICAgICAgJC53aGVuKHRoaXMuc2F2ZShzdWJtaXRWYWx1ZSkpXG4gICAgICAgICAgICAuZG9uZSgkLnByb3h5KGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy9ydW4gc3VjY2VzcyBjYWxsYmFja1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnN1Y2Nlc3MgPT09ICdmdW5jdGlvbicgPyB0aGlzLm9wdGlvbnMuc3VjY2Vzcy5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSwgcmVzcG9uc2UsIG5ld1ZhbHVlKSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHN1Y2Nlc3MgY2FsbGJhY2sgcmV0dXJucyBmYWxzZSAtLT4ga2VlcCBmb3JtIG9wZW4gYW5kIGRvIG5vdCBhY3RpdmF0ZSBpbnB1dFxuICAgICAgICAgICAgICAgIGlmKHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zvcm0oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pZiBzdWNjZXNzIGNhbGxiYWNrIHJldHVybnMgc3RyaW5nIC0tPiAga2VlcCBmb3JtIG9wZW4sIHNob3cgZXJyb3IgYW5kIGFjdGl2YXRlIGlucHV0ICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHJlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihyZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dGb3JtKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2lmIHN1Y2Nlc3MgY2FsbGJhY2sgcmV0dXJucyBvYmplY3QgbGlrZSB7bmV3VmFsdWU6IDxzb21ldGhpbmc+fSAtLT4gdXNlIHRoYXQgdmFsdWUgaW5zdGVhZCBvZiBzdWJtaXR0ZWRcbiAgICAgICAgICAgICAgICAvL2l0IGlzIHVzZWZ1bGwgaWYgeW91IHdhbnQgdG8gY2huYWdlIHZhbHVlIGluIHVybC1mdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmKHJlcyAmJiB0eXBlb2YgcmVzID09PSAnb2JqZWN0JyAmJiByZXMuaGFzT3duUHJvcGVydHkoJ25ld1ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSByZXMubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9jbGVhciBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihmYWxzZSk7ICAgXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICAgICAgRmlyZWQgd2hlbiBmb3JtIGlzIHN1Ym1pdHRlZFxuICAgICAgICAgICAgICAgIEBldmVudCBzYXZlIFxuICAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gcGFyYW1zIGFkZGl0aW9uYWwgcGFyYW1zXG4gICAgICAgICAgICAgICAgQHBhcmFtIHttaXhlZH0gcGFyYW1zLm5ld1ZhbHVlIHJhdyBuZXcgdmFsdWVcbiAgICAgICAgICAgICAgICBAcGFyYW0ge21peGVkfSBwYXJhbXMuc3VibWl0VmFsdWUgc3VibWl0dGVkIHZhbHVlIGFzIHN0cmluZ1xuICAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucmVzcG9uc2UgYWpheCByZXNwb25zZVxuXG4gICAgICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAkKCcjZm9ybS1kaXYnKS5vbignc2F2ZScpLCBmdW5jdGlvbihlLCBwYXJhbXMpe1xuICAgICAgICAgICAgICAgICAgICBpZihwYXJhbXMubmV3VmFsdWUgPT09ICd1c2VybmFtZScpIHsuLi59XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgKiovXG4gICAgICAgICAgICAgICAgdGhpcy4kZGl2LnRyaWdnZXJIYW5kbGVyKCdzYXZlJywge25ld1ZhbHVlOiBuZXdWYWx1ZSwgc3VibWl0VmFsdWU6IHN1Ym1pdFZhbHVlLCByZXNwb25zZTogcmVzcG9uc2V9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgLmZhaWwoJC5wcm94eShmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB2YXIgbXNnO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiB0aGlzLm9wdGlvbnMuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gdGhpcy5vcHRpb25zLmVycm9yLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlLCB4aHIsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtc2cgPSB0eXBlb2YgeGhyID09PSAnc3RyaW5nJyA/IHhociA6IHhoci5yZXNwb25zZVRleHQgfHwgeGhyLnN0YXR1c1RleHQgfHwgJ1Vua25vd24gZXJyb3IhJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93Rm9ybSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uKHN1Ym1pdFZhbHVlKSB7XG4gICAgICAgICAgICAvL3RyeSBwYXJzZSBjb21wb3NpdGUgcGsgZGVmaW5lZCBhcyBqc29uIHN0cmluZyBpbiBkYXRhLXBrIFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBrID0gJC5mbi5lZGl0YWJsZXV0aWxzLnRyeVBhcnNlSnNvbih0aGlzLm9wdGlvbnMucGssIHRydWUpOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBrID0gKHR5cGVvZiB0aGlzLm9wdGlvbnMucGsgPT09ICdmdW5jdGlvbicpID8gdGhpcy5vcHRpb25zLnBrLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlKSA6IHRoaXMub3B0aW9ucy5wayxcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIHNlbmQgb24gc2VydmVyIGluIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgICAgICAgMS4gdXJsIGlzIGZ1bmN0aW9uXG4gICAgICAgICAgICAgIDIuIHVybCBpcyBzdHJpbmcgQU5EIChwayBkZWZpbmVkIE9SIHNlbmQgb3B0aW9uID0gYWx3YXlzKSBcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZW5kID0gISEodHlwZW9mIHRoaXMub3B0aW9ucy51cmwgPT09ICdmdW5jdGlvbicgfHwgKHRoaXMub3B0aW9ucy51cmwgJiYgKCh0aGlzLm9wdGlvbnMuc2VuZCA9PT0gJ2Fsd2F5cycpIHx8ICh0aGlzLm9wdGlvbnMuc2VuZCA9PT0gJ2F1dG8nICYmIHBrICE9PSBudWxsICYmIHBrICE9PSB1bmRlZmluZWQpKSkpLFxuICAgICAgICAgICAgcGFyYW1zO1xuXG4gICAgICAgICAgICBpZiAoc2VuZCkgeyAvL3NlbmQgdG8gc2VydmVyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93TG9hZGluZygpO1xuXG4gICAgICAgICAgICAgICAgLy9zdGFuZGFyZCBwYXJhbXNcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMub3B0aW9ucy5uYW1lIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3VibWl0VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBrOiBwayBcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy9hZGRpdGlvbmFsIHBhcmFtc1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiB0aGlzLm9wdGlvbnMucGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHRoaXMub3B0aW9ucy5wYXJhbXMuY2FsbCh0aGlzLm9wdGlvbnMuc2NvcGUsIHBhcmFtcyk7ICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL3RyeSBwYXJzZSBqc29uIGluIHNpbmdsZSBxdW90ZXMgKGZyb20gZGF0YS1wYXJhbXMgYXR0cmlidXRlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucGFyYW1zID0gJC5mbi5lZGl0YWJsZXV0aWxzLnRyeVBhcnNlSnNvbih0aGlzLm9wdGlvbnMucGFyYW1zLCB0cnVlKTsgICBcbiAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQocGFyYW1zLCB0aGlzLm9wdGlvbnMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgdGhpcy5vcHRpb25zLnVybCA9PT0gJ2Z1bmN0aW9uJykgeyAvL3VzZXIncyBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnVybC5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAgXG4gICAgICAgICAgICAgICAgICAgIC8vc2VuZCBhamF4IHRvIHNlcnZlciBhbmQgcmV0dXJuIGRlZmVycmVkIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5hamF4KCQuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCAgICAgOiB0aGlzLm9wdGlvbnMudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSAgICA6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgICAgOiAnUE9TVCdcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLmFqYXhPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBcblxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnZhbGlkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YWxpZGF0ZS5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYoa2V5IGluIHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2RvIG5vdCBwYXNzIG9wdGlvbiB0byBpbnB1dCBhcyBpdCBpcyBwYXNzZWQgaW4gZWRpdGFibGUtZWxlbWVudFxuICAgICAgICB9LFxuXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgY29udmVydFN0cikge1xuICAgICAgICAgICAgaWYoY29udmVydFN0cikge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmlucHV0LnN0cjJ2YWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiBmb3JtIGlzIHZpc2libGUsIHVwZGF0ZSBpbnB1dFxuICAgICAgICAgICAgaWYodGhpcy4kZm9ybSAmJiB0aGlzLiRmb3JtLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC52YWx1ZTJpbnB1dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfSAgICAgICAgICAgICAgIFxuICAgIH07XG5cbiAgICAvKlxuICAgIEluaXRpYWxpemUgZWRpdGFibGVmb3JtLiBBcHBsaWVkIHRvIGpRdWVyeSBvYmplY3QuXG5cbiAgICBAbWV0aG9kICQoKS5lZGl0YWJsZWZvcm0ob3B0aW9ucylcbiAgICBAcGFyYW1zIHtPYmplY3R9IG9wdGlvbnNcbiAgICBAZXhhbXBsZVxuICAgIHZhciAkZm9ybSA9ICQoJyZsdDtkaXYmZ3Q7JykuZWRpdGFibGVmb3JtKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBuYW1lOiAndXNlcm5hbWUnLFxuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHZhbHVlOiAndml0YWxpeSdcbiAgICB9KTtcblxuICAgIC8vdG8gZGlzcGxheSBmb3JtIHlvdSBzaG91bGQgY2FsbCAncmVuZGVyJyBtZXRob2RcbiAgICAkZm9ybS5lZGl0YWJsZWZvcm0oJ3JlbmRlcicpOyAgICAgXG4gICAgKi9cbiAgICAkLmZuLmVkaXRhYmxlZm9ybSA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSwgXG4gICAgICAgICAgICBkYXRhID0gJHRoaXMuZGF0YSgnZWRpdGFibGVmb3JtJyksIFxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT09ICdvYmplY3QnICYmIG9wdGlvbjsgXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKCdlZGl0YWJsZWZvcm0nLCAoZGF0YSA9IG5ldyBFZGl0YWJsZUZvcm0odGhpcywgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnKSB7IC8vY2FsbCBtZXRob2QgXG4gICAgICAgICAgICAgICAgZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvL2tlZXAgbGluayB0byBjb25zdHJ1Y3RvciB0byBhbGxvdyBpbmhlcml0YW5jZVxuICAgICQuZm4uZWRpdGFibGVmb3JtLkNvbnN0cnVjdG9yID0gRWRpdGFibGVGb3JtOyAgICBcblxuICAgIC8vZGVmYXVsdHNcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5kZWZhdWx0cyA9IHtcbiAgICAgICAgLyogc2VlIGFsc28gZGVmYXVsdHMgZm9yIGlucHV0ICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgIFR5cGUgb2YgaW5wdXQuIENhbiBiZSA8Y29kZT50ZXh0fHRleHRhcmVhfHNlbGVjdHxkYXRlfGNoZWNrbGlzdDwvY29kZT5cblxuICAgICAgICBAcHJvcGVydHkgdHlwZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICd0ZXh0J1xuICAgICAgICAqKi9cbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAvKipcbiAgICAgICAgVXJsIGZvciBzdWJtaXQsIGUuZy4gPGNvZGU+Jy9wb3N0JzwvY29kZT4gIFxuICAgICAgICBJZiBmdW5jdGlvbiAtIGl0IHdpbGwgYmUgY2FsbGVkIGluc3RlYWQgb2YgYWpheC4gRnVuY3Rpb24gc2hvdWxkIHJldHVybiBkZWZlcnJlZCBvYmplY3QgdG8gcnVuIGZhaWwvZG9uZSBjYWxsYmFja3MuXG5cbiAgICAgICAgQHByb3BlcnR5IHVybCBcbiAgICAgICAgQHR5cGUgc3RyaW5nfGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgdXJsOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBkID0gbmV3ICQuRGVmZXJyZWQ7XG4gICAgICAgICAgICBpZihwYXJhbXMudmFsdWUgPT09ICdhYmMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQucmVqZWN0KCdlcnJvciBtZXNzYWdlJyk7IC8vcmV0dXJuaW5nIGVycm9yIHZpYSBkZWZlcnJlZCBvYmplY3RcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9hc3luYyBzYXZpbmcgZGF0YSBpbiBqcyBtb2RlbFxuICAgICAgICAgICAgICAgIHNvbWVNb2RlbC5hc3luY1NhdmVNZXRob2Qoe1xuICAgICAgICAgICAgICAgICAgIC4uLiwgXG4gICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICBkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7IFxuICAgICAgICAgICAgICAgIHJldHVybiBkLnByb21pc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgdXJsOm51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBBZGRpdGlvbmFsIHBhcmFtcyBmb3Igc3VibWl0LiBJZiBkZWZpbmVkIGFzIDxjb2RlPm9iamVjdDwvY29kZT4gLSBpdCBpcyAqKmFwcGVuZGVkKiogdG8gb3JpZ2luYWwgYWpheCBkYXRhIChwaywgbmFtZSBhbmQgdmFsdWUpLiAgXG4gICAgICAgIElmIGRlZmluZWQgYXMgPGNvZGU+ZnVuY3Rpb248L2NvZGU+IC0gcmV0dXJuZWQgb2JqZWN0ICoqb3ZlcndyaXRlcyoqIG9yaWdpbmFsIGFqYXggZGF0YS5cbiAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgcGFyYW1zOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgIC8vb3JpZ2luYWxseSBwYXJhbXMgY29udGFpbiBwaywgbmFtZSBhbmQgdmFsdWVcbiAgICAgICAgICAgIHBhcmFtcy5hID0gMTtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH1cblxuICAgICAgICBAcHJvcGVydHkgcGFyYW1zIFxuICAgICAgICBAdHlwZSBvYmplY3R8ZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIHBhcmFtczpudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgTmFtZSBvZiBmaWVsZC4gV2lsbCBiZSBzdWJtaXR0ZWQgb24gc2VydmVyLiBDYW4gYmUgdGFrZW4gZnJvbSA8Y29kZT5pZDwvY29kZT4gYXR0cmlidXRlXG5cbiAgICAgICAgQHByb3BlcnR5IG5hbWUgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgUHJpbWFyeSBrZXkgb2YgZWRpdGFibGUgb2JqZWN0IChlLmcuIHJlY29yZCBpZCBpbiBkYXRhYmFzZSkuIEZvciBjb21wb3NpdGUga2V5cyB1c2Ugb2JqZWN0LCBlLmcuIDxjb2RlPntpZDogMSwgbGFuZzogJ2VuJ308L2NvZGU+LlxuICAgICAgICBDYW4gYmUgY2FsY3VsYXRlZCBkeW5hbWljYWxseSB2aWEgZnVuY3Rpb24uXG5cbiAgICAgICAgQHByb3BlcnR5IHBrIFxuICAgICAgICBAdHlwZSBzdHJpbmd8b2JqZWN0fGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHBrOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgSW5pdGlhbCB2YWx1ZS4gSWYgbm90IGRlZmluZWQgLSB3aWxsIGJlIHRha2VuIGZyb20gZWxlbWVudCdzIGNvbnRlbnQuXG4gICAgICAgIEZvciBfX3NlbGVjdF9fIHR5cGUgc2hvdWxkIGJlIGRlZmluZWQgKGFzIGl0IGlzIElEIG9mIHNob3duIHRleHQpLlxuXG4gICAgICAgIEBwcm9wZXJ0eSB2YWx1ZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nfG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgVmFsdWUgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBpbiBpbnB1dCBpZiBvcmlnaW5hbCBmaWVsZCB2YWx1ZSBpcyBlbXB0eSAoYG51bGx8dW5kZWZpbmVkfCcnYCkuXG5cbiAgICAgICAgQHByb3BlcnR5IGRlZmF1bHRWYWx1ZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nfG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjQuNlxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBTdHJhdGVneSBmb3Igc2VuZGluZyBkYXRhIG9uIHNlcnZlci4gQ2FuIGJlIGBhdXRvfGFsd2F5c3xuZXZlcmAuXG4gICAgICAgIFdoZW4gJ2F1dG8nIGRhdGEgd2lsbCBiZSBzZW50IG9uIHNlcnZlciAqKm9ubHkgaWYgcGsgYW5kIHVybCBkZWZpbmVkKiosIG90aGVyd2lzZSBuZXcgdmFsdWUgd2lsbCBiZSBzdG9yZWQgbG9jYWxseS5cblxuICAgICAgICBAcHJvcGVydHkgc2VuZCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICdhdXRvJ1xuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIHNlbmQ6ICdhdXRvJywgXG4gICAgICAgIC8qKlxuICAgICAgICBGdW5jdGlvbiBmb3IgY2xpZW50LXNpZGUgdmFsaWRhdGlvbi4gSWYgcmV0dXJucyBzdHJpbmcgLSBtZWFucyB2YWxpZGF0aW9uIG5vdCBwYXNzZWQgYW5kIHN0cmluZyBzaG93ZWQgYXMgZXJyb3IuXG4gICAgICAgIFNpbmNlIDEuNS4xIHlvdSBjYW4gbW9kaWZ5IHN1Ym1pdHRlZCB2YWx1ZSBieSByZXR1cm5pbmcgb2JqZWN0IGZyb20gYHZhbGlkYXRlYDogXG4gICAgICAgIGB7bmV3VmFsdWU6ICcuLi4nfWAgb3IgYHtuZXdWYWx1ZTogJy4uLicsIG1zZzogJy4uLid9YFxuXG4gICAgICAgIEBwcm9wZXJ0eSB2YWxpZGF0ZSBcbiAgICAgICAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmKCQudHJpbSh2YWx1ZSkgPT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1RoaXMgZmllbGQgaXMgcmVxdWlyZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB2YWxpZGF0ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIFN1Y2Nlc3MgY2FsbGJhY2suIENhbGxlZCB3aGVuIHZhbHVlIHN1Y2Nlc3NmdWxseSBzZW50IG9uIHNlcnZlciBhbmQgKipyZXNwb25zZSBzdGF0dXMgPSAyMDAqKi4gIFxuICAgICAgICBVc2VmdWxsIHRvIHdvcmsgd2l0aCBqc29uIHJlc3BvbnNlLiBGb3IgZXhhbXBsZSwgaWYgeW91ciBiYWNrZW5kIHJlc3BvbnNlIGNhbiBiZSA8Y29kZT57c3VjY2VzczogdHJ1ZX08L2NvZGU+XG4gICAgICAgIG9yIDxjb2RlPntzdWNjZXNzOiBmYWxzZSwgbXNnOiBcInNlcnZlciBlcnJvclwifTwvY29kZT4geW91IGNhbiBjaGVjayBpdCBpbnNpZGUgdGhpcyBjYWxsYmFjay4gIFxuICAgICAgICBJZiBpdCByZXR1cm5zICoqc3RyaW5nKiogLSBtZWFucyBlcnJvciBvY2N1cmVkIGFuZCBzdHJpbmcgaXMgc2hvd24gYXMgZXJyb3IgbWVzc2FnZS4gIFxuICAgICAgICBJZiBpdCByZXR1cm5zICoqb2JqZWN0IGxpa2UqKiA8Y29kZT57bmV3VmFsdWU6ICZsdDtzb21ldGhpbmcmZ3Q7fTwvY29kZT4gLSBpdCBvdmVyd3JpdGVzIHZhbHVlLCBzdWJtaXR0ZWQgYnkgdXNlci4gIFxuICAgICAgICBPdGhlcndpc2UgbmV3VmFsdWUgc2ltcGx5IHJlbmRlcmVkIGludG8gZWxlbWVudC5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBzdWNjZXNzIFxuICAgICAgICBAdHlwZSBmdW5jdGlvblxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlc3BvbnNlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYoIXJlc3BvbnNlLnN1Y2Nlc3MpIHJldHVybiByZXNwb25zZS5tc2c7XG4gICAgICAgIH1cbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBzdWNjZXNzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgRXJyb3IgY2FsbGJhY2suIENhbGxlZCB3aGVuIHJlcXVlc3QgZmFpbGVkIChyZXNwb25zZSBzdGF0dXMgIT0gMjAwKS4gIFxuICAgICAgICBVc2VmdWxsIHdoZW4geW91IHdhbnQgdG8gcGFyc2UgZXJyb3IgcmVzcG9uc2UgYW5kIGRpc3BsYXkgYSBjdXN0b20gbWVzc2FnZS5cbiAgICAgICAgTXVzdCByZXR1cm4gKipzdHJpbmcqKiAtIHRoZSBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgZXJyb3IgYmxvY2suXG4gICAgICAgICAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBlcnJvciBcbiAgICAgICAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAc2luY2UgMS40LjRcbiAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHJlc3BvbnNlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYocmVzcG9uc2Uuc3RhdHVzID09PSA1MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1NlcnZpY2UgdW5hdmFpbGFibGUuIFBsZWFzZSB0cnkgbGF0ZXIuJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgQWRkaXRpb25hbCBvcHRpb25zIGZvciBzdWJtaXQgYWpheCByZXF1ZXN0LlxuICAgICAgICBMaXN0IG9mIHZhbHVlczogaHR0cDovL2FwaS5qcXVlcnkuY29tL2pRdWVyeS5hamF4XG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgYWpheE9wdGlvbnMgXG4gICAgICAgIEB0eXBlIG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjEuMSAgICAgICAgXG4gICAgICAgIEBleGFtcGxlIFxuICAgICAgICBhamF4T3B0aW9uczoge1xuICAgICAgICAgICAgdHlwZTogJ3B1dCcsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBhamF4T3B0aW9uczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZXJlIHRvIHNob3cgYnV0dG9uczogbGVmdCh0cnVlKXxib3R0b218ZmFsc2UgIFxuICAgICAgICBGb3JtIHdpdGhvdXQgYnV0dG9ucyBpcyBhdXRvLXN1Ym1pdHRlZC5cblxuICAgICAgICBAcHJvcGVydHkgc2hvd2J1dHRvbnMgXG4gICAgICAgIEB0eXBlIGJvb2xlYW58c3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IHRydWVcbiAgICAgICAgQHNpbmNlIDEuMS4xXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBzaG93YnV0dG9uczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgIFNjb3BlIGZvciBjYWxsYmFjayBtZXRob2RzIChzdWNjZXNzLCB2YWxpZGF0ZSkuICBcbiAgICAgICAgSWYgPGNvZGU+bnVsbDwvY29kZT4gbWVhbnMgZWRpdGFibGVmb3JtIGluc3RhbmNlIGl0c2VsZi4gXG5cbiAgICAgICAgQHByb3BlcnR5IHNjb3BlIFxuICAgICAgICBAdHlwZSBET01FbGVtZW50fG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICBAcHJpdmF0ZVxuICAgICAgICAqKi8gICAgICAgICAgICBcbiAgICAgICAgc2NvcGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBXaGV0aGVyIHRvIHNhdmUgb3IgY2FuY2VsIHZhbHVlIHdoZW4gaXQgd2FzIG5vdCBjaGFuZ2VkIGJ1dCBmb3JtIHdhcyBzdWJtaXR0ZWRcblxuICAgICAgICBAcHJvcGVydHkgc2F2ZW5vY2hhbmdlIFxuICAgICAgICBAdHlwZSBib29sZWFuXG4gICAgICAgIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICAqKi9cbiAgICAgICAgc2F2ZW5vY2hhbmdlOiBmYWxzZVxuICAgIH07ICAgXG5cbiAgICAvKlxuICAgIE5vdGU6IGZvbGxvd2luZyBwYXJhbXMgY291bGQgcmVkZWZpbmVkIGluIGVuZ2luZTogYm9vdHN0cmFwIG9yIGpxdWVyeXVpOlxuICAgIENsYXNzZXMgJ2NvbnRyb2wtZ3JvdXAnIGFuZCAnZWRpdGFibGUtZXJyb3ItYmxvY2snIG11c3QgYWx3YXlzIHByZXNlbnQhXG4gICAgKi8gICAgICBcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS50ZW1wbGF0ZSA9ICc8Zm9ybSBjbGFzcz1cImZvcm0taW5saW5lIGVkaXRhYmxlZm9ybVwiPicrXG4gICAgJzxkaXYgY2xhc3M9XCJjb250cm9sLWdyb3VwXCI+JyArIFxuICAgICc8ZGl2PjxkaXYgY2xhc3M9XCJlZGl0YWJsZS1pbnB1dFwiPjwvZGl2PjxkaXYgY2xhc3M9XCJlZGl0YWJsZS1idXR0b25zXCI+PC9kaXY+PC9kaXY+JytcbiAgICAnPGRpdiBjbGFzcz1cImVkaXRhYmxlLWVycm9yLWJsb2NrXCI+PC9kaXY+JyArIFxuICAgICc8L2Rpdj4nICsgXG4gICAgJzwvZm9ybT4nO1xuXG4gICAgLy9sb2FkaW5nIGRpdlxuICAgICQuZm4uZWRpdGFibGVmb3JtLmxvYWRpbmcgPSAnPGRpdiBjbGFzcz1cImVkaXRhYmxlZm9ybS1sb2FkaW5nXCI+PC9kaXY+JztcblxuICAgIC8vYnV0dG9uc1xuICAgICQuZm4uZWRpdGFibGVmb3JtLmJ1dHRvbnMgPSAnPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3M9XCJlZGl0YWJsZS1zdWJtaXRcIj5vazwvYnV0dG9uPicrXG4gICAgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiZWRpdGFibGUtY2FuY2VsXCI+Y2FuY2VsPC9idXR0b24+JzsgICAgICBcblxuICAgIC8vZXJyb3IgY2xhc3MgYXR0YWNoZWQgdG8gY29udHJvbC1ncm91cFxuICAgICQuZm4uZWRpdGFibGVmb3JtLmVycm9yR3JvdXBDbGFzcyA9IG51bGw7ICBcblxuICAgIC8vZXJyb3IgY2xhc3MgYXR0YWNoZWQgdG8gZWRpdGFibGUtZXJyb3ItYmxvY2tcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckJsb2NrQ2xhc3MgPSAnZWRpdGFibGUtZXJyb3InO1xuICAgIFxuICAgIC8vZW5naW5lXG4gICAgJC5mbi5lZGl0YWJsZWZvcm0uZW5naW5lID0gJ2pxdWVyeSc7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG4qIEVkaXRhYmxlRm9ybSB1dGlsaXRlc1xuKi9cbihmdW5jdGlvbiAoJCkge1xuXG4gICAgLy91dGlsc1xuICAgICQuZm4uZWRpdGFibGV1dGlscyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICogY2xhc3NpYyBKUyBpbmhlcml0YW5jZSBmdW5jdGlvblxuICAgICAgICAqLyAgXG4gICAgICAgIGluaGVyaXQ6IGZ1bmN0aW9uIChDaGlsZCwgUGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgRiA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBQYXJlbnQucHJvdG90eXBlO1xuICAgICAgICAgICAgQ2hpbGQucHJvdG90eXBlID0gbmV3IEYoKTtcbiAgICAgICAgICAgIENoaWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENoaWxkO1xuICAgICAgICAgICAgQ2hpbGQuc3VwZXJjbGFzcyA9IFBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogc2V0IGNhcmV0IHBvc2l0aW9uIGluIGlucHV0XG4gICAgICAgICogc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk5MTI2L2pxdWVyeS1zZXQtY3Vyc29yLXBvc2l0aW9uLWluLXRleHQtYXJlYVxuICAgICAgICAqLyAgICAgICAgXG4gICAgICAgIHNldEN1cnNvclBvc2l0aW9uOiBmdW5jdGlvbihlbGVtLCBwb3MpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLnNldFNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zZXRTZWxlY3Rpb25SYW5nZShwb3MsIHBvcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0uY3JlYXRlVGV4dFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZWxlbS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBwb3MpO1xuICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgcG9zKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgKiBmdW5jdGlvbiB0byBwYXJzZSBKU09OIGluICpzaW5nbGUqIHF1b3Rlcy4gKGpxdWVyeSBhdXRvbWF0aWNhbGx5IHBhcnNlIG9ubHkgZG91YmxlIHF1b3RlcylcbiAgICAgICAgKiBUaGF0IGFsbG93cyBzdWNoIGNvZGUgYXM6IDxhIGRhdGEtc291cmNlPVwieydhJzogJ2InLCAnYyc6ICdkJ31cIj5cbiAgICAgICAgKiBzYWZlID0gdHJ1ZSAtLT4gbWVhbnMgbm8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duXG4gICAgICAgICogZm9yIGRldGFpbHMgc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQxMDM0OC9ob3ctdG8tc2V0LWpzb24tZm9ybWF0LXRvLWh0bWw1LWRhdGEtYXR0cmlidXRlcy1pbi10aGUtanF1ZXJ5XG4gICAgICAgICovXG4gICAgICAgIHRyeVBhcnNlSnNvbjogZnVuY3Rpb24ocywgc2FmZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJyAmJiBzLmxlbmd0aCAmJiBzLm1hdGNoKC9eW1xce1xcW10uKltcXH1cXF1dJC8pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhZmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGV2aWw6IHRydWUqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgcykpKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKmpzbGludCBldmlsOiBmYWxzZSovXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKmpzbGludCBldmlsOiB0cnVlKi9cbiAgICAgICAgICAgICAgICAgICAgcyA9IChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgcykpKCk7XG4gICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGV2aWw6IGZhbHNlKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgKiBzbGljZSBvYmplY3QgYnkgc3BlY2lmaWVkIGtleXNcbiAgICAgICAgKi9cbiAgICAgICAgc2xpY2VPYmo6IGZ1bmN0aW9uKG9iaiwga2V5cywgY2FzZVNlbnNpdGl2ZSAvKiBkZWZhdWx0OiBmYWxzZSAqLykge1xuICAgICAgICAgICAgdmFyIGtleSwga2V5TG93ZXIsIG5ld09iaiA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoISQuaXNBcnJheShrZXlzKSB8fCAha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGNhc2VTZW5zaXRpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy93aGVuIGdldHRpbmcgZGF0YS0qIGF0dHJpYnV0ZXMgdmlhICQuZGF0YSgpIGl0J3MgY29udmVydGVkIHRvIGxvd2VyY2FzZS5cbiAgICAgICAgICAgICAgICAvL2RldGFpbHM6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzYwMjU2NS91c2luZy1kYXRhLWF0dHJpYnV0ZXMtd2l0aC1qcXVlcnlcbiAgICAgICAgICAgICAgICAvL3dvcmthcm91bmQgaXMgY29kZSBiZWxvdy5cbiAgICAgICAgICAgICAgICBrZXlMb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5TG93ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleUxvd2VyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgZXhjbHVkZSBjb21wbGV4IG9iamVjdHMgZnJvbSAkLmRhdGEoKSBiZWZvcmUgcGFzcyB0byBjb25maWdcbiAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29uZmlnRGF0YTogZnVuY3Rpb24oJGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICAkLmVhY2goJGVsZW1lbnQuZGF0YSgpLCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHYgIT09ICdvYmplY3QnIHx8ICh2ICYmIHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiAodi5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8IHYuY29uc3RydWN0b3IgPT09IEFycmF5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgcmV0dXJucyBrZXlzIG9mIG9iamVjdFxuICAgICAgICAqL1xuICAgICAgICBvYmplY3RLZXlzOiBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobyk7ICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG8gIT09IE9iamVjdChvKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrPVtdLCBwO1xuICAgICAgICAgICAgICAgIGZvciAocCBpbiBvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobyxwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgay5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgIC8qKlxuICAgICAgICBtZXRob2QgdG8gZXNjYXBlIGh0bWwuXG4gICAgICAgKiovXG4gICAgICAgZXNjYXBlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgcmV0dXJuICQoJzxkaXY+JykudGV4dChzdHIpLmh0bWwoKTtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgIHJldHVybnMgYXJyYXkgaXRlbXMgZnJvbSBzb3VyY2VEYXRhIGhhdmluZyB2YWx1ZSBwcm9wZXJ0eSBlcXVhbCBvciBpbkFycmF5IG9mICd2YWx1ZSdcbiAgICAgICAqL1xuICAgICAgIGl0ZW1zQnlWYWx1ZTogZnVuY3Rpb24odmFsdWUsIHNvdXJjZURhdGEsIHZhbHVlUHJvcCkge1xuICAgICAgICAgICBpZighc291cmNlRGF0YSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICBpZiAodHlwZW9mKHZhbHVlUHJvcCkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgdmFyIGlkS2V5ID0gdmFsdWVQcm9wIHx8ICd2YWx1ZSc7XG4gICAgICAgICAgICAgICB2YWx1ZVByb3AgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZVtpZEtleV07IH07XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgdmFyIGlzVmFsQXJyYXkgPSAkLmlzQXJyYXkodmFsdWUpLFxuICAgICAgICAgICByZXN1bHQgPSBbXSwgXG4gICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICQuZWFjaChzb3VyY2VEYXRhLCBmdW5jdGlvbihpLCBvKSB7XG4gICAgICAgICAgICAgICBpZihvLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGF0Lml0ZW1zQnlWYWx1ZSh2YWx1ZSwgby5jaGlsZHJlbiwgdmFsdWVQcm9wKSk7XG4gICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IHRydWUqL1xuICAgICAgICAgICAgICAgICAgIGlmKGlzVmFsQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgaWYoJC5ncmVwKHZhbHVlLCBmdW5jdGlvbih2KXsgIHJldHVybiB2ID09IChvICYmIHR5cGVvZiBvID09PSAnb2JqZWN0JyA/IHZhbHVlUHJvcChvKSA6IG8pOyB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG8pOyBcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVmFsdWUgPSAobyAmJiAodHlwZW9mIG8gPT09ICdvYmplY3QnKSkgPyB2YWx1ZVByb3AobykgOiBvO1xuICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZSA9PSBpdGVtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG8pOyBcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAvKmpzbGludCBlcWVxOiBmYWxzZSovXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgICBcbiAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgUmV0dXJucyBpbnB1dCBieSBvcHRpb25zOiB0eXBlLCBtb2RlLiBcbiAgICAgICAqL1xuICAgICAgIGNyZWF0ZUlucHV0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgIHZhciBUeXBlQ29uc3RydWN0b3IsIHR5cGVPcHRpb25zLCBpbnB1dCxcbiAgICAgICAgICAgdHlwZSA9IG9wdGlvbnMudHlwZTtcblxuICAgICAgICAgICAvL2BkYXRlYCBpcyBzb21lIGtpbmQgb2YgdmlydHVhbCB0eXBlIHRoYXQgaXMgdHJhbnNmb3JtZWQgdG8gb25lIG9mIGV4YWN0IHR5cGVzXG4gICAgICAgICAgIC8vZGVwZW5kaW5nIG9uIG1vZGUgYW5kIGNvcmUgbGliXG4gICAgICAgICAgIGlmKHR5cGUgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgICAgLy9pbmxpbmVcbiAgICAgICAgICAgICAgIGlmKG9wdGlvbnMubW9kZSA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICAgICBpZigkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnZGF0ZWZpZWxkJztcbiAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGV1aWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnZGF0ZXVpZmllbGQnO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIC8vcG9wdXBcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgaWYoJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdkYXRlJztcbiAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGV1aSkge1xuICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2RhdGV1aSc7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAvL2lmIHR5cGUgc3RpbGwgYGRhdGVgIGFuZCBub3QgZXhpc3QgaW4gdHlwZXMsIHJlcGxhY2Ugd2l0aCBgY29tYm9kYXRlYCB0aGF0IGlzIGJhc2UgaW5wdXRcbiAgICAgICAgICAgICAgIGlmKHR5cGUgPT09ICdkYXRlJyAmJiAhJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2NvbWJvZGF0ZSc7XG4gICAgICAgICAgICAgICB9IFxuICAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICAvL2BkYXRldGltZWAgc2hvdWxkIGJlIGRhdGV0aW1lZmllbGQgaW4gJ2lubGluZScgbW9kZVxuICAgICAgICAgICBpZih0eXBlID09PSAnZGF0ZXRpbWUnICYmIG9wdGlvbnMubW9kZSA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICB0eXBlID0gJ2RhdGV0aW1lZmllbGQnOyAgXG4gICAgICAgICAgIH0gICAgICAgICAgIFxuXG4gICAgICAgICAgIC8vY2hhbmdlIHd5c2lodG1sNSB0byB0ZXh0YXJlYSBmb3IganF1ZXJ5IFVJIGFuZCBwbGFpbiB2ZXJzaW9uc1xuICAgICAgICAgICBpZih0eXBlID09PSAnd3lzaWh0bWw1JyAmJiAhJC5mbi5lZGl0YWJsZXR5cGVzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICB0eXBlID0gJ3RleHRhcmVhJztcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vY3JlYXRlIGlucHV0IG9mIHNwZWNpZmllZCB0eXBlLiBJbnB1dCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgdmFsdWUsIG5vdCBpbiBmb3JtXG4gICAgICAgICAgIGlmKHR5cGVvZiAkLmZuLmVkaXRhYmxldHlwZXNbdHlwZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgIFR5cGVDb25zdHJ1Y3RvciA9ICQuZm4uZWRpdGFibGV0eXBlc1t0eXBlXTtcbiAgICAgICAgICAgICAgIHR5cGVPcHRpb25zID0gdGhpcy5zbGljZU9iaihvcHRpb25zLCB0aGlzLm9iamVjdEtleXMoVHlwZUNvbnN0cnVjdG9yLmRlZmF1bHRzKSk7XG4gICAgICAgICAgICAgICBpbnB1dCA9IG5ldyBUeXBlQ29uc3RydWN0b3IodHlwZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgJC5lcnJvcignVW5rbm93biB0eXBlOiAnKyB0eXBlKTtcbiAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgXG4gICAgICAgICAgIH0gIFxuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgLy9zZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MjY0ODk5L2RldGVjdC1jc3MtdHJhbnNpdGlvbnMtdXNpbmctamF2YXNjcmlwdC1hbmQtd2l0aG91dC1tb2Rlcm5penJcbiAgICAgICBzdXBwb3J0c1RyYW5zaXRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgIHZhciBiID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICBzID0gYi5zdHlsZSxcbiAgICAgICAgICAgICAgIHAgPSAndHJhbnNpdGlvbicsXG4gICAgICAgICAgICAgICB2ID0gWydNb3onLCAnV2Via2l0JywgJ0todG1sJywgJ08nLCAnbXMnXTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICBpZih0eXBlb2Ygc1twXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyBcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vIFRlc3RzIGZvciB2ZW5kb3Igc3BlY2lmaWMgcHJvcFxuICAgICAgICAgICBwID0gcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHAuc3Vic3RyKDEpO1xuICAgICAgICAgICBmb3IodmFyIGk9MDsgaTx2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICBpZih0eXBlb2Ygc1t2W2ldICsgcF0gPT09ICdzdHJpbmcnKSB7IFxuICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyBcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgfSAgICAgICAgICAgIFxuICAgICAgIFxuICAgIH07ICAgICAgXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5BdHRhY2hlcyBzdGFuZC1hbG9uZSBjb250YWluZXIgd2l0aCBlZGl0YWJsZS1mb3JtIHRvIEhUTUwgZWxlbWVudC4gRWxlbWVudCBpcyB1c2VkIG9ubHkgZm9yIHBvc2l0aW9uaW5nLCB2YWx1ZSBpcyBub3Qgc3RvcmVkIGFueXdoZXJlLjxicj5cblRoaXMgbWV0aG9kIGFwcGxpZWQgaW50ZXJuYWxseSBpbiA8Y29kZT4kKCkuZWRpdGFibGUoKTwvY29kZT4uIFlvdSBzaG91bGQgc3Vic2NyaWJlIG9uIGl0J3MgZXZlbnRzIChzYXZlIC8gY2FuY2VsKSB0byBnZXQgcHJvZml0IG9mIGl0Ljxicj5cbkZpbmFsIHJlYWxpemF0aW9uIGNhbiBiZSBkaWZmZXJlbnQ6IGJvb3RzdHJhcC1wb3BvdmVyLCBqcXVlcnl1aS10b29sdGlwLCBwb3NoeXRpcCwgaW5saW5lLWRpdi4gSXQgZGVwZW5kcyBvbiB3aGljaCBqcyBmaWxlIHlvdSBpbmNsdWRlLjxicj5cbkFwcGxpZWQgYXMgalF1ZXJ5IG1ldGhvZC5cblxuQGNsYXNzIGVkaXRhYmxlQ29udGFpbmVyXG5AdXNlcyBlZGl0YWJsZWZvcm1cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG5cbiAgICB2YXIgUG9wdXAgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgSW5saW5lID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH07ICAgIFxuXG4gICAgLy9tZXRob2RzXG4gICAgUG9wdXAucHJvdG90eXBlID0ge1xuICAgICAgICBjb250YWluZXJOYW1lOiBudWxsLCAvL21ldGhvZCB0byBjYWxsIGNvbnRhaW5lciBvbiBlbGVtZW50XG4gICAgICAgIGNvbnRhaW5lckRhdGFOYW1lOiBudWxsLCAvL29iamVjdCBuYW1lIGluIGVsZW1lbnQncyAuZGF0YSgpXG4gICAgICAgIGlubmVyQ3NzOiBudWxsLCAvL3RiZCBpbiBjaGlsZCBjbGFzc1xuICAgICAgICBjb250YWluZXJDbGFzczogJ2VkaXRhYmxlLWNvbnRhaW5lciBlZGl0YWJsZS1wb3B1cCcsIC8vY3NzIGNsYXNzIGFwcGxpZWQgdG8gY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgZGVmYXVsdHM6IHt9LCAvL2NvbnRhaW5lciBpdHNlbGYgZGVmYXVsdHNcbiAgICAgICAgXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgICAgICAgLy9zaW5jZSAxLjQuMSBjb250YWluZXIgZG8gbm90IHVzZSBkYXRhLSogZGlyZWN0bHkgYXMgdGhleSBhbHJlYWR5IG1lcmdlZCBpbnRvIG9wdGlvbnMuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZUNvbnRhaW5lci5kZWZhdWx0cywgb3B0aW9ucyk7ICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnNwbGl0T3B0aW9ucygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3NldCBzY29wZSBvZiBmb3JtIGNhbGxiYWNrcyB0byBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLmZvcm1PcHRpb25zLnNjb3BlID0gdGhpcy4kZWxlbWVudFswXTsgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaW5pdENvbnRhaW5lcigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2ZsYWcgdG8gaGlkZSBjb250YWluZXIsIHdoZW4gc2F2aW5nIHZhbHVlIHdpbGwgZmluaXNoXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRIaWRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vYmluZCAnZGVzdHJveWVkJyBsaXN0ZW5lciB0byBkZXN0cm95IGNvbnRhaW5lciB3aGVuIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIGRvbVxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vbignZGVzdHJveWVkJywgJC5wcm94eShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hdHRhY2ggZG9jdW1lbnQgaGFuZGxlciB0byBjbG9zZSBjb250YWluZXJzIG9uIGNsaWNrIC8gZXNjYXBlXG4gICAgICAgICAgICBpZighJChkb2N1bWVudCkuZGF0YSgnZWRpdGFibGUtaGFuZGxlcnMtYXR0YWNoZWQnKSkge1xuICAgICAgICAgICAgICAgIC8vY2xvc2UgYWxsIG9uIGVzY2FwZVxuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdrZXl1cC5lZGl0YWJsZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAyNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnLmVkaXRhYmxlLW9wZW4nKS5lZGl0YWJsZUNvbnRhaW5lcignaGlkZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy90b2RvOiByZXR1cm4gZm9jdXMgb24gZWxlbWVudCBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9jbG9zZSBjb250YWluZXJzIHdoZW4gY2xpY2sgb3V0c2lkZSBcbiAgICAgICAgICAgICAgICAvLyhtb3VzZWRvd24gY291bGQgYmUgYmV0dGVyIHRoYW4gY2xpY2ssIGl0IGNsb3NlcyBldmVyeXRoaW5nIGFsc28gb24gZHJhZyBkcm9wKVxuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljay5lZGl0YWJsZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KSwgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVfY2xhc3NlcyA9IFsnLmVkaXRhYmxlLWNvbnRhaW5lcicsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcudWktZGF0ZXBpY2tlci1oZWFkZXInLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLmRhdGVwaWNrZXInLCAvL2luIGlubGluZSBtb2RlIGRhdGVwaWNrZXIgaXMgcmVuZGVyZWQgaW50byBib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy5tb2RhbC1iYWNrZHJvcCcsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtaW1hZ2UtbW9kYWwnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLmJvb3RzdHJhcC13eXNpaHRtbDUtaW5zZXJ0LWxpbmstbW9kYWwnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgZWxlbWVudCBpcyBkZXRhY2hlZC4gSXQgb2NjdXJzIHdoZW4gY2xpY2tpbmcgaW4gYm9vdHN0cmFwIGRhdGVwaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkLmNvbnRhaW5zKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9mb3Igc29tZSByZWFzb24gRkYgMjAgZ2VuZXJhdGVzIGV4dHJhIGV2ZW50IChjbGljaykgaW4gc2VsZWN0MiB3aWRnZXQgd2l0aCBlLnRhcmdldCA9IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vd2UgbmVlZCB0byBmaWx0ZXIgaXQgdmlhIGNvbnN0cnVjdGlvbiBiZWxvdy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlL2lzc3Vlcy8xOTlcbiAgICAgICAgICAgICAgICAgICAgLy9Qb3NzaWJseSByZWxhdGVkIHRvIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAxMTk3OTMvd2h5LWRvZXMtZmlyZWZveC1yZWFjdC1kaWZmZXJlbnRseS1mcm9tLXdlYmtpdC1hbmQtaWUtdG8tY2xpY2stZXZlbnQtb24tc2VsZWNcbiAgICAgICAgICAgICAgICAgICAgaWYoJHRhcmdldC5pcyhkb2N1bWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBjbGljayBpbnNpZGUgb25lIG9mIGV4Y2x1ZGUgY2xhc3NlcyAtLT4gbm8gbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICBmb3IoaT0wOyBpPGV4Y2x1ZGVfY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCR0YXJnZXQuaXMoZXhjbHVkZV9jbGFzc2VzW2ldKSB8fCAkdGFyZ2V0LnBhcmVudHMoZXhjbHVkZV9jbGFzc2VzW2ldKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL2Nsb3NlIGFsbCBvcGVuIGNvbnRhaW5lcnMgKGV4Y2VwdCBvbmUgLSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgIFBvcHVwLnByb3RvdHlwZS5jbG9zZU90aGVycyhlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkuZGF0YSgnZWRpdGFibGUtaGFuZGxlcnMtYXR0YWNoZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfSxcblxuICAgICAgICAvL3NwbGl0IG9wdGlvbnMgb24gY29udGFpbmVyT3B0aW9ucyBhbmQgZm9ybU9wdGlvbnNcbiAgICAgICAgc3BsaXRPcHRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5mb3JtT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZighJC5mblt0aGlzLmNvbnRhaW5lck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuY29udGFpbmVyTmFtZSArICcgbm90IGZvdW5kLiBIYXZlIHlvdSBpbmNsdWRlZCBjb3JyZXNwb25kaW5nIGpzIGZpbGU/Jyk7ICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8va2V5cyBkZWZpbmVkIGluIGNvbnRhaW5lciBkZWZhdWx0cyBnbyB0byBjb250YWluZXIsIG90aGVycyBnbyB0byBmb3JtXG4gICAgICAgICAgICBmb3IodmFyIGsgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIGlmKGsgaW4gdGhpcy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lck9wdGlvbnNba10gPSB0aGlzLm9wdGlvbnNba107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIHRoaXMuZm9ybU9wdGlvbnNba10gPSB0aGlzLm9wdGlvbnNba107XG4gICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBSZXR1cm5zIGpxdWVyeSBvYmplY3Qgb2YgY29udGFpbmVyXG4gICAgICAgIEBtZXRob2QgdGlwKClcbiAgICAgICAgKi8gICAgICAgICBcbiAgICAgICAgdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcigpID8gdGhpcy5jb250YWluZXIoKS4kdGlwIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiByZXR1cm5zIGNvbnRhaW5lciBvYmplY3QgKi9cbiAgICAgICAgY29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXI7XG4gICAgICAgICAgICAvL2ZpcnN0LCB0cnkgZ2V0IGl0IGJ5IGBjb250YWluZXJEYXRhTmFtZWBcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyRGF0YU5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZihjb250YWluZXIgPSB0aGlzLiRlbGVtZW50LmRhdGEodGhpcy5jb250YWluZXJEYXRhTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3NlY29uZCwgdHJ5IGBjb250YWluZXJOYW1lYFxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy4kZWxlbWVudC5kYXRhKHRoaXMuY29udGFpbmVyTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qIGNhbGwgbmF0aXZlIG1ldGhvZCBvZiB1bmRlcmx5aW5nIGNvbnRhaW5lciwgZS5nLiB0aGlzLiRlbGVtZW50LnBvcG92ZXIoJ21ldGhvZCcpICovIFxuICAgICAgICBjYWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnRbdGhpcy5jb250YWluZXJOYW1lXS5hcHBseSh0aGlzLiRlbGVtZW50LCBhcmd1bWVudHMpOyBcbiAgICAgICAgfSwgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaW5pdENvbnRhaW5lcjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuY2FsbCh0aGlzLmNvbnRhaW5lck9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlckZvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kZm9ybVxuICAgICAgICAgICAgLmVkaXRhYmxlZm9ybSh0aGlzLmZvcm1PcHRpb25zKVxuICAgICAgICAgICAgLm9uKHtcbiAgICAgICAgICAgICAgICBzYXZlOiAkLnByb3h5KHRoaXMuc2F2ZSwgdGhpcyksIC8vY2xpY2sgb24gc3VibWl0IGJ1dHRvbiAodmFsdWUgY2hhbmdlZClcbiAgICAgICAgICAgICAgICBub2NoYW5nZTogJC5wcm94eShmdW5jdGlvbigpeyB0aGlzLmhpZGUoJ25vY2hhbmdlJyk7IH0sIHRoaXMpLCAvL2NsaWNrIG9uIHN1Ym1pdCBidXR0b24gKHZhbHVlIE5PVCBjaGFuZ2VkKSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjYW5jZWw6ICQucHJveHkoZnVuY3Rpb24oKXsgdGhpcy5oaWRlKCdjYW5jZWwnKTsgfSwgdGhpcyksIC8vY2xpY2sgb24gY2FsY2VsIGJ1dHRvblxuICAgICAgICAgICAgICAgIHNob3c6ICQucHJveHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZGVsYXllZEhpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZSh0aGlzLmRlbGF5ZWRIaWRlLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ZWRIaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKSwgLy9yZS1wb3NpdGlvbiBjb250YWluZXIgZXZlcnkgdGltZSBmb3JtIGlzIHNob3duIChvY2N1cnMgZWFjaCB0aW1lIGFmdGVyIGxvYWRpbmcgc3RhdGUpXG4gICAgICAgICAgICAgICAgcmVuZGVyaW5nOiAkLnByb3h5KHRoaXMuc2V0UG9zaXRpb24sIHRoaXMpLCAvL3RoaXMgYWxsb3dzIHRvIHBsYWNlIGNvbnRhaW5lciBjb3JyZWN0bHkgd2hlbiBsb2FkaW5nIHNob3duXG4gICAgICAgICAgICAgICAgcmVzaXplOiAkLnByb3h5KHRoaXMuc2V0UG9zaXRpb24sIHRoaXMpLCAvL3RoaXMgYWxsb3dzIHRvIHJlLXBvc2l0aW9uIGNvbnRhaW5lciB3aGVuIGZvcm0gc2l6ZSBpcyBjaGFuZ2VkIFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiAkLnByb3h5KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gY29udGFpbmVyIGlzIHNob3duIGFuZCBmb3JtIGlzIHJlbmRlcmVkIChmb3Igc2VsZWN0IHdpbGwgd2FpdCBmb3IgbG9hZGluZyBkcm9wZG93biBvcHRpb25zKS4gIFxuICAgICAgICAgICAgICAgICAgICAqKk5vdGU6KiogQm9vdHN0cmFwIHBvcG92ZXIgaGFzIG93biBgc2hvd25gIGV2ZW50IHRoYXQgbm93IGNhbm5vdCBiZSBzZXBhcmF0ZWQgZnJvbSB4LWVkaXRhYmxlJ3Mgb25lLlxuICAgICAgICAgICAgICAgICAgICBUaGUgd29ya2Fyb3VuZCBpcyB0byBjaGVjayBgYXJndW1lbnRzLmxlbmd0aGAgdGhhdCBpcyBhbHdheXMgYDJgIGZvciB4LWVkaXRhYmxlLiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgQGV2ZW50IHNob3duIFxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICQoJyN1c2VybmFtZScpLm9uKCdzaG93bicsIGZ1bmN0aW9uKGUsIGVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5pbnB1dC4kaW5wdXQudmFsKCdvdmVyd3JpdGluZyB2YWx1ZSBvZiBpbnB1dC4uJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pOyAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAqKi8gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICBUT0RPOiBhZGRlZCBzZWNvbmQgcGFyYW0gbWFpbmx5IHRvIGRpc3Rpbmd1aXNoIGZyb20gYm9vdHN0cmFwJ3Mgc2hvd24gZXZlbnQuIEl0J3MgYSBob3RmaXggdGhhdCB3aWxsIGJlIHNvbHZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgdmlhIG5hbWVzcGFjZWQgZXZlbnRzLiAgXG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlckhhbmRsZXIoJ3Nob3duJywgJCh0aGlzLm9wdGlvbnMuc2NvcGUpLmRhdGEoJ2VkaXRhYmxlJykpOyBcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZWRpdGFibGVmb3JtKCdyZW5kZXInKTtcbiAgICAgICAgfSwgICAgICAgIFxuXG4gICAgICAgIC8qKlxuICAgICAgICBTaG93cyBjb250YWluZXIgd2l0aCBmb3JtXG4gICAgICAgIEBtZXRob2Qgc2hvdygpXG4gICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gY2xvc2VBbGwgV2hldGhlciB0byBjbG9zZSBhbGwgb3RoZXIgZWRpdGFibGUgY29udGFpbmVycyB3aGVuIHNob3dpbmcgdGhpcyBvbmUuIERlZmF1bHQgdHJ1ZS5cbiAgICAgICAgKiovXG4gICAgICAgIC8qIE5vdGU6IHBvc2h5dGlwIG93ZXJ3cml0ZXMgdGhpcyBtZXRob2QgdG90YWxseSEgKi8gICAgICAgICAgXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uIChjbG9zZUFsbCkge1xuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUtb3BlbicpO1xuICAgICAgICAgICAgaWYoY2xvc2VBbGwgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy9jbG9zZSBhbGwgb3BlbiBjb250YWluZXJzIChleGNlcHQgdGhpcylcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlT3RoZXJzKHRoaXMuJGVsZW1lbnRbMF0pOyAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2hvdyBjb250YWluZXIgaXRzZWxmXG4gICAgICAgICAgICB0aGlzLmlubmVyU2hvdygpO1xuICAgICAgICAgICAgdGhpcy50aXAoKS5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lckNsYXNzKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIEN1cnJlbnRseSwgZm9ybSBpcyByZS1yZW5kZXJlZCBvbiBldmVyeSBzaG93LiBcbiAgICAgICAgICAgIFRoZSBtYWluIHJlYXNvbiBpcyB0aGF0IHdlIGRvbnQga25vdywgd2hhdCB3aWxsIGNvbnRhaW5lciBkbyB3aXRoIGNvbnRlbnQgd2hlbiBjbG9zZWQ6XG4gICAgICAgICAgICByZW1vdmUoKSwgZGV0YWNoKCkgb3IganVzdCBoaWRlKCkgLSBpdCBkZXBlbmRzIG9uIGNvbnRhaW5lci5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgRGV0YWNoaW5nIGZvcm0gaXRzZWxmIGJlZm9yZSBoaWRlIGFuZCByZS1pbnNlcnQgYmVmb3JlIHNob3cgaXMgZ29vZCBzb2x1dGlvbiwgXG4gICAgICAgICAgICBidXQgdmlzdWFsbHkgaXQgbG9va3MgdWdseSAtLT4gY29udGFpbmVyIGNoYW5nZXMgc2l6ZSBiZWZvcmUgaGlkZS4gIFxuICAgICAgICAgICAgKi8gICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgZm9ybSBhbHJlYWR5IGV4aXN0IC0gZGVsZXRlIHByZXZpb3VzIGRhdGEgXG4gICAgICAgICAgICBpZih0aGlzLiRmb3JtKSB7XG4gICAgICAgICAgICAgICAgLy90b2RvOiBkZXN0cm95IHByZXYgZGF0YSFcbiAgICAgICAgICAgICAgICAvL3RoaXMuJGZvcm0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRmb3JtID0gJCgnPGRpdj4nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pbnNlcnQgZm9ybSBpbnRvIGNvbnRhaW5lciBib2R5XG4gICAgICAgICAgICBpZih0aGlzLnRpcCgpLmlzKHRoaXMuaW5uZXJDc3MpKSB7XG4gICAgICAgICAgICAgICAgLy9mb3IgaW5saW5lIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIHRoaXMudGlwKCkuYXBwZW5kKHRoaXMuJGZvcm0pOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aXAoKS5maW5kKHRoaXMuaW5uZXJDc3MpLmFwcGVuZCh0aGlzLiRmb3JtKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcmVuZGVyIGZvcm1cbiAgICAgICAgICAgIHRoaXMucmVuZGVyRm9ybSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICBIaWRlcyBjb250YWluZXIgd2l0aCBmb3JtXG4gICAgICAgIEBtZXRob2QgaGlkZSgpXG4gICAgICAgIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gUmVhc29uIGNhdXNlZCBoaWRpbmcuIENhbiBiZSA8Y29kZT5zYXZlfGNhbmNlbHxvbmJsdXJ8bm9jaGFuZ2V8dW5kZWZpbmVkICg9bWFudWFsKTwvY29kZT5cbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKHJlYXNvbikgeyAgXG4gICAgICAgICAgICBpZighdGhpcy50aXAoKSB8fCAhdGhpcy50aXAoKS5pcygnOnZpc2libGUnKSB8fCAhdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZWRpdGFibGUtb3BlbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2lmIGZvcm0gaXMgc2F2aW5nIHZhbHVlLCBzY2hlZHVsZSBoaWRlXG4gICAgICAgICAgICBpZih0aGlzLiRmb3JtLmRhdGEoJ2VkaXRhYmxlZm9ybScpLmlzU2F2aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheWVkSGlkZSA9IHtyZWFzb246IHJlYXNvbn07XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheWVkSGlkZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdlZGl0YWJsZS1vcGVuJyk7ICAgXG4gICAgICAgICAgICB0aGlzLmlubmVySGlkZSgpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEZpcmVkIHdoZW4gY29udGFpbmVyIHdhcyBoaWRkZW4uIEl0IG9jY3VycyBvbiBib3RoIHNhdmUgb3IgY2FuY2VsLiAgXG4gICAgICAgICAgICAqKk5vdGU6KiogQm9vdHN0cmFwIHBvcG92ZXIgaGFzIG93biBgaGlkZGVuYCBldmVudCB0aGF0IG5vdyBjYW5ub3QgYmUgc2VwYXJhdGVkIGZyb20geC1lZGl0YWJsZSdzIG9uZS5cbiAgICAgICAgICAgIFRoZSB3b3JrYXJvdW5kIGlzIHRvIGNoZWNrIGBhcmd1bWVudHMubGVuZ3RoYCB0aGF0IGlzIGFsd2F5cyBgMmAgZm9yIHgtZWRpdGFibGUuIFxuXG4gICAgICAgICAgICBAZXZlbnQgaGlkZGVuIFxuICAgICAgICAgICAgQHBhcmFtIHtvYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiBSZWFzb24gY2F1c2VkIGhpZGluZy4gQ2FuIGJlIDxjb2RlPnNhdmV8Y2FuY2VsfG9uYmx1cnxub2NoYW5nZXxtYW51YWw8L2NvZGU+XG4gICAgICAgICAgICBAZXhhbXBsZVxuICAgICAgICAgICAgJCgnI3VzZXJuYW1lJykub24oJ2hpZGRlbicsIGZ1bmN0aW9uKGUsIHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGlmKHJlYXNvbiA9PT0gJ3NhdmUnIHx8IHJlYXNvbiA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9hdXRvLW9wZW4gbmV4dCBlZGl0YWJsZVxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ3RyJykubmV4dCgpLmZpbmQoJy5lZGl0YWJsZScpLmVkaXRhYmxlKCdzaG93Jyk7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCdoaWRkZW4nLCByZWFzb24gfHwgJ21hbnVhbCcpOyAgIFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qIGludGVybmFsIHNob3cgbWV0aG9kLiBUbyBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBjbGFzc2VzICovXG4gICAgICAgIGlubmVyU2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIFxuICAgICAgICB9LCAgICAgICAgXG5cbiAgICAgICAgLyogaW50ZXJuYWwgaGlkZSBtZXRob2QuIFRvIGJlIG92ZXJ3cml0dGVuIGluIGNoaWxkIGNsYXNzZXMgKi9cbiAgICAgICAgaW5uZXJIaWRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBUb2dnbGVzIGNvbnRhaW5lciB2aXNpYmlsaXR5IChzaG93IC8gaGlkZSlcbiAgICAgICAgQG1ldGhvZCB0b2dnbGUoKVxuICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlQWxsIFdoZXRoZXIgdG8gY2xvc2UgYWxsIG90aGVyIGVkaXRhYmxlIGNvbnRhaW5lcnMgd2hlbiBzaG93aW5nIHRoaXMgb25lLiBEZWZhdWx0IHRydWUuXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbihjbG9zZUFsbCkge1xuICAgICAgICAgICAgaWYodGhpcy5jb250YWluZXIoKSAmJiB0aGlzLnRpcCgpICYmIHRoaXMudGlwKCkuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93KGNsb3NlQWxsKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgY29udGFpbmVyIHdoZW4gY29udGVudCBjaGFuZ2VkLlxuICAgICAgICBAbWV0aG9kIHNldFBvc2l0aW9uKClcbiAgICAgICAgKi8gICAgICAgXG4gICAgICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vdGJkIGluIGNoaWxkIGNsYXNzXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2F2ZTogZnVuY3Rpb24oZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICAvKiogICAgICAgIFxuICAgICAgICAgICAgRmlyZWQgd2hlbiBuZXcgdmFsdWUgd2FzIHN1Ym1pdHRlZC4gWW91IGNhbiB1c2UgPGNvZGU+JCh0aGlzKS5kYXRhKCdlZGl0YWJsZUNvbnRhaW5lcicpPC9jb2RlPiBpbnNpZGUgaGFuZGxlciB0byBhY2Nlc3MgdG8gZWRpdGFibGVDb250YWluZXIgaW5zdGFuY2VcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQGV2ZW50IHNhdmUgXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gcGFyYW1zIGFkZGl0aW9uYWwgcGFyYW1zXG4gICAgICAgICAgICBAcGFyYW0ge21peGVkfSBwYXJhbXMubmV3VmFsdWUgc3VibWl0dGVkIHZhbHVlXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnJlc3BvbnNlIGFqYXggcmVzcG9uc2VcbiAgICAgICAgICAgIEBleGFtcGxlXG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5vbignc2F2ZScsIGZ1bmN0aW9uKGUsIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIC8vYXNzdW1pbmcgc2VydmVyIHJlc3BvbnNlOiAne3N1Y2Nlc3M6IHRydWV9J1xuICAgICAgICAgICAgICAgIHZhciBwayA9ICQodGhpcykuZGF0YSgnZWRpdGFibGVDb250YWluZXInKS5vcHRpb25zLnBrO1xuICAgICAgICAgICAgICAgIGlmKHBhcmFtcy5yZXNwb25zZSAmJiBwYXJhbXMucmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBhbGVydCgndmFsdWU6ICcgKyBwYXJhbXMubmV3VmFsdWUgKyAnIHdpdGggcGs6ICcgKyBwayArICcgc2F2ZWQhJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ2Vycm9yIScpOyBcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAqKi8gICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCdzYXZlJywgcGFyYW1zKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9oaWRlIG11c3QgYmUgYWZ0ZXIgdHJpZ2dlciwgYXMgc2F2aW5nIHZhbHVlIG1heSByZXF1aXJlIG1ldGhvZHMgb2YgcGx1Z2luLCBhcHBsaWVkIHRvIGlucHV0XG4gICAgICAgICAgICB0aGlzLmhpZGUoJ3NhdmUnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgU2V0cyBuZXcgb3B0aW9uXG4gICAgICAgIFxuICAgICAgICBAbWV0aG9kIG9wdGlvbihrZXksIHZhbHVlKVxuICAgICAgICBAcGFyYW0ge3N0cmluZ30ga2V5IFxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZSBcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIG9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmKGtleSBpbiB0aGlzLmNvbnRhaW5lck9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lck9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29udGFpbmVyT3B0aW9uKGtleSwgdmFsdWUpOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtT3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYodGhpcy4kZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLmVkaXRhYmxlZm9ybSgnb3B0aW9uJywga2V5LCB2YWx1ZSk7ICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBzZXRDb250YWluZXJPcHRpb246IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbCgnb3B0aW9uJywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgIERlc3Ryb3lzIHRoZSBjb250YWluZXIgaW5zdGFuY2VcbiAgICAgICAgQG1ldGhvZCBkZXN0cm95KClcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignZGVzdHJveWVkJyk7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoJ2VkaXRhYmxlQ29udGFpbmVyJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKiB0byBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBjbGFzc2VzICovXG4gICAgICAgIGlubmVyRGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgfSwgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBDbG9zZXMgb3RoZXIgY29udGFpbmVycyBleGNlcHQgb25lIHJlbGF0ZWQgdG8gcGFzc2VkIGVsZW1lbnQuIFxuICAgICAgICBPdGhlciBjb250YWluZXJzIGNhbiBiZSBjYW5jZWxsZWQgb3Igc3VibWl0dGVkIChkZXBlbmRzIG9uIG9uYmx1ciBvcHRpb24pXG4gICAgICAgICovXG4gICAgICAgIGNsb3NlT3RoZXJzOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAkKCcuZWRpdGFibGUtb3BlbicpLmVhY2goZnVuY3Rpb24oaSwgZWwpe1xuICAgICAgICAgICAgICAgIC8vZG8gbm90aGluZyB3aXRoIHBhc3NlZCBlbGVtZW50IGFuZCBpdCdzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgaWYoZWwgPT09IGVsZW1lbnQgfHwgJChlbCkuZmluZChlbGVtZW50KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGNhbmNlbCBvciBzdWJtaXQgYWxsIG9wZW4gY29udGFpbmVycyBcbiAgICAgICAgICAgICAgICB2YXIgJGVsID0gJChlbCksXG4gICAgICAgICAgICAgICAgZWMgPSAkZWwuZGF0YSgnZWRpdGFibGVDb250YWluZXInKTtcblxuICAgICAgICAgICAgICAgIGlmKCFlYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoZWMub3B0aW9ucy5vbmJsdXIgPT09ICdjYW5jZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICRlbC5kYXRhKCdlZGl0YWJsZUNvbnRhaW5lcicpLmhpZGUoJ29uYmx1cicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihlYy5vcHRpb25zLm9uYmx1ciA9PT0gJ3N1Ym1pdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVsLmRhdGEoJ2VkaXRhYmxlQ29udGFpbmVyJykudGlwKCkuZmluZCgnZm9ybScpLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgQWN0aXZhdGVzIGlucHV0IG9mIHZpc2libGUgY29udGFpbmVyIChlLmcuIHNldCBmb2N1cylcbiAgICAgICAgQG1ldGhvZCBhY3RpdmF0ZSgpXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLnRpcCAmJiB0aGlzLnRpcCgpLmlzKCc6dmlzaWJsZScpICYmIHRoaXMuJGZvcm0pIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uZGF0YSgnZWRpdGFibGVmb3JtJykuaW5wdXQuYWN0aXZhdGUoKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgalF1ZXJ5IG1ldGhvZCB0byBpbml0aWFsaXplIGVkaXRhYmxlQ29udGFpbmVyLlxuICAgIFxuICAgIEBtZXRob2QgJCgpLmVkaXRhYmxlQ29udGFpbmVyKG9wdGlvbnMpXG4gICAgQHBhcmFtcyB7T2JqZWN0fSBvcHRpb25zXG4gICAgQGV4YW1wbGVcbiAgICAkKCcjZWRpdCcpLmVkaXRhYmxlQ29udGFpbmVyKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHBrOiAxLFxuICAgICAgICB2YWx1ZTogJ2hlbGxvJ1xuICAgIH0pO1xuICAgICoqLyAgXG4gICAgJC5mbi5lZGl0YWJsZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcbiAgICAgICAgICAgIGRhdGFLZXkgPSAnZWRpdGFibGVDb250YWluZXInLCBcbiAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKGRhdGFLZXkpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT09ICdvYmplY3QnICYmIG9wdGlvbixcbiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gKG9wdGlvbnMubW9kZSA9PT0gJ2lubGluZScpID8gSW5saW5lIDogUG9wdXA7ICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKGRhdGFLZXksIChkYXRhID0gbmV3IENvbnN0cnVjdG9yKHRoaXMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJykgeyAvL2NhbGwgbWV0aG9kIFxuICAgICAgICAgICAgICAgIGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgIH0pO1xuICAgIH07ICAgICBcblxuICAgIC8vc3RvcmUgY29uc3RydWN0b3JzXG4gICAgJC5mbi5lZGl0YWJsZUNvbnRhaW5lci5Qb3B1cCA9IFBvcHVwO1xuICAgICQuZm4uZWRpdGFibGVDb250YWluZXIuSW5saW5lID0gSW5saW5lO1xuXG4gICAgLy9kZWZhdWx0c1xuICAgICQuZm4uZWRpdGFibGVDb250YWluZXIuZGVmYXVsdHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICBJbml0aWFsIHZhbHVlIG9mIGZvcm0gaW5wdXRcblxuICAgICAgICBAcHJvcGVydHkgdmFsdWUgXG4gICAgICAgIEB0eXBlIG1peGVkXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQHByaXZhdGVcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBQbGFjZW1lbnQgb2YgY29udGFpbmVyIHJlbGF0aXZlIHRvIGVsZW1lbnQuIENhbiBiZSA8Y29kZT50b3B8cmlnaHR8Ym90dG9tfGxlZnQ8L2NvZGU+LiBOb3QgdXNlZCBmb3IgaW5saW5lIGNvbnRhaW5lci5cblxuICAgICAgICBAcHJvcGVydHkgcGxhY2VtZW50IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ3RvcCdcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZXRoZXIgdG8gaGlkZSBjb250YWluZXIgb24gc2F2ZS9jYW5jZWwuXG5cbiAgICAgICAgQHByb3BlcnR5IGF1dG9oaWRlIFxuICAgICAgICBAdHlwZSBib29sZWFuXG4gICAgICAgIEBkZWZhdWx0IHRydWVcbiAgICAgICAgQHByaXZhdGUgXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIGF1dG9oaWRlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgQWN0aW9uIHdoZW4gdXNlciBjbGlja3Mgb3V0c2lkZSB0aGUgY29udGFpbmVyLiBDYW4gYmUgPGNvZGU+Y2FuY2VsfHN1Ym1pdHxpZ25vcmU8L2NvZGU+LiAgXG4gICAgICAgIFNldHRpbmcgPGNvZGU+aWdub3JlPC9jb2RlPiBhbGxvd3MgdG8gaGF2ZSBzZXZlcmFsIGNvbnRhaW5lcnMgb3Blbi4gXG5cbiAgICAgICAgQHByb3BlcnR5IG9uYmx1ciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICdjYW5jZWwnXG4gICAgICAgIEBzaW5jZSAxLjEuMVxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBvbmJsdXI6ICdjYW5jZWwnLFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIEFuaW1hdGlvbiBzcGVlZCAoaW5saW5lIG1vZGUgb25seSlcbiAgICAgICAgQHByb3BlcnR5IGFuaW0gXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBhbmltOiBmYWxzZSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBNb2RlIG9mIGVkaXRhYmxlLCBjYW4gYmUgYHBvcHVwYCBvciBgaW5saW5lYCBcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBtb2RlIFxuICAgICAgICBAdHlwZSBzdHJpbmcgICAgICAgICBcbiAgICAgICAgQGRlZmF1bHQgJ3BvcHVwJ1xuICAgICAgICBAc2luY2UgMS40LjAgICAgICAgIFxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBtb2RlOiAncG9wdXAnICAgICAgICBcbiAgICB9O1xuXG4gICAgLyogXG4gICAgKiB3b3JrYXJvdW5kIHRvIGhhdmUgJ2Rlc3Ryb3llZCcgZXZlbnQgdG8gZGVzdHJveSBwb3BvdmVyIHdoZW4gZWxlbWVudCBpcyBkZXN0cm95ZWRcbiAgICAqIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIyMDA0OTQvanF1ZXJ5LXRyaWdnZXItZXZlbnQtd2hlbi1hbi1lbGVtZW50LWlzLXJlbW92ZWQtZnJvbS10aGUtZG9tXG4gICAgKi9cbiAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbC5kZXN0cm95ZWQgPSB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24obykge1xuICAgICAgICAgICAgaWYgKG8uaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIG8uaGFuZGxlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTsgICAgXG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcbiogRWRpdGFibGUgSW5saW5lIFxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIC8vY29weSBwcm90b3R5cGUgZnJvbSBFZGl0YWJsZUNvbnRhaW5lclxuICAgIC8vZXh0ZW5kIG1ldGhvZHNcbiAgICAkLmV4dGVuZCgkLmZuLmVkaXRhYmxlQ29udGFpbmVyLklubGluZS5wcm90b3R5cGUsICQuZm4uZWRpdGFibGVDb250YWluZXIuUG9wdXAucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnRhaW5lck5hbWU6ICdlZGl0YWJsZWZvcm0nLFxuICAgICAgICBpbm5lckNzczogJy5lZGl0YWJsZS1pbmxpbmUnLFxuICAgICAgICBjb250YWluZXJDbGFzczogJ2VkaXRhYmxlLWNvbnRhaW5lciBlZGl0YWJsZS1pbmxpbmUnLCAvL2NzcyBjbGFzcyBhcHBsaWVkIHRvIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICAgICAgICAgICAgIFxuICAgICAgICBpbml0Q29udGFpbmVyOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy9jb250YWluZXIgaXMgPHNwYW4+IGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuJHRpcCA9ICQoJzxzcGFuPjwvc3Bhbj4nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jb252ZXJ0IGFuaW0gdG8gbWlsaXNlY29uZHMgKGludClcbiAgICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuYW5pbSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hbmltID0gMDtcbiAgICAgICAgICAgIH0gICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHNwbGl0T3B0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvL2FsbCBvcHRpb25zIGFyZSBwYXNzZWQgdG8gZm9ybVxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJPcHRpb25zID0ge307XG4gICAgICAgICAgICB0aGlzLmZvcm1PcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuJHRpcDsgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBpbm5lclNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy50aXAoKS5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KS5zaG93KCk7XG4gICAgICAgIH0sIFxuICAgICAgICBcbiAgICAgICAgaW5uZXJIaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiR0aXAuaGlkZSh0aGlzLm9wdGlvbnMuYW5pbSwgJC5wcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnNob3coKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyRGVzdHJveSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpOyBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGlubmVyRGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLnRpcCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aXAoKS5lbXB0eSgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgIH0pO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcbi8qKlxuTWFrZXMgZWRpdGFibGUgYW55IEhUTUwgZWxlbWVudCBvbiB0aGUgcGFnZS4gQXBwbGllZCBhcyBqUXVlcnkgbWV0aG9kLlxuXG5AY2xhc3MgZWRpdGFibGVcbkB1c2VzIGVkaXRhYmxlQ29udGFpbmVyXG4qKi9cbihmdW5jdGlvbiAoJCkge1xuXG4gICAgdmFyIEVkaXRhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgIC8vZGF0YS0qIGhhcyBtb3JlIHByaW9yaXR5IG92ZXIganMgb3B0aW9uczogYmVjYXVzZSBkeW5hbWljYWxseSBjcmVhdGVkIGVsZW1lbnRzIG1heSBjaGFuZ2UgZGF0YS0qIFxuICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZS5kZWZhdWx0cywgb3B0aW9ucywgJC5mbi5lZGl0YWJsZXV0aWxzLmdldENvbmZpZ0RhdGEodGhpcy4kZWxlbWVudCkpOyAgXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5zZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5pbml0TGl2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vY2hlY2sgZm9yIHRyYW5zaXRpb24gc3VwcG9ydFxuICAgICAgICBpZih0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ICYmICEkLmZuLmVkaXRhYmxldXRpbHMuc3VwcG9ydHNUcmFuc2l0aW9ucygpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRWRpdGFibGUucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogRWRpdGFibGUsIFxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXNWYWx1ZUJ5VGV4dCA9IGZhbHNlLCBcbiAgICAgICAgICAgICAgICBkb0F1dG90ZXh0LCBmaW5hbGl6ZTtcblxuICAgICAgICAgICAgLy9uYW1lXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMub3B0aW9ucy5uYW1lIHx8IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTtcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY3JlYXRlIGlucHV0IG9mIHNwZWNpZmllZCB0eXBlLiBJbnB1dCBuZWVkZWQgYWxyZWFkeSBoZXJlIHRvIGNvbnZlcnQgdmFsdWUgZm9yIGluaXRpYWwgZGlzcGxheSAoZS5nLiBzaG93IHRleHQgYnkgaWQgZm9yIHNlbGVjdClcbiAgICAgICAgICAgIC8vYWxzbyB3ZSBzZXQgc2NvcGUgb3B0aW9uIHRvIGhhdmUgYWNjZXNzIHRvIGVsZW1lbnQgaW5zaWRlIGlucHV0IHNwZWNpZmljIGNhbGxiYWNrcyAoZS4gZy4gc291cmNlIGFzIGZ1bmN0aW9uKVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNjb3BlID0gdGhpcy4kZWxlbWVudFswXTsgXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gJC5mbi5lZGl0YWJsZXV0aWxzLmNyZWF0ZUlucHV0KHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICBpZighdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgXG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIC8vc2V0IHZhbHVlIGZyb20gc2V0dGluZ3Mgb3IgYnkgZWxlbWVudCdzIHRleHRcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbnB1dC5odG1sMnZhbHVlKCQudHJpbSh0aGlzLiRlbGVtZW50Lmh0bWwoKSkpO1xuICAgICAgICAgICAgICAgIGlzVmFsdWVCeVRleHQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgdmFsdWUgY2FuIGJlIHN0cmluZyB3aGVuIHJlY2VpdmVkIGZyb20gJ2RhdGEtdmFsdWUnIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgZm9yIGNvbXBsZXh0IG9iamVjdHMgdmFsdWUgY2FuIGJlIHNldCBhcyBqc29uIHN0cmluZyBpbiBkYXRhLXZhbHVlIGF0dHJpYnV0ZSwgXG4gICAgICAgICAgICAgICAgICBlLmcuIGRhdGEtdmFsdWU9XCJ7Y2l0eTogJ01vc2NvdycsIHN0cmVldDogJ0xlbmluYSd9XCJcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy52YWx1ZSA9ICQuZm4uZWRpdGFibGV1dGlscy50cnlQYXJzZUpzb24odGhpcy5vcHRpb25zLnZhbHVlLCB0cnVlKTsgXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHRoaXMub3B0aW9ucy52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5wdXQuc3RyMnZhbHVlKHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vYWRkICdlZGl0YWJsZScgY2xhc3MgdG8gZXZlcnkgZWRpdGFibGUgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zcGVjaWZpY2FsbHkgZm9yIFwidGV4dGFyZWFcIiBhZGQgY2xhc3MgLmVkaXRhYmxlLXByZS13cmFwcGVkIHRvIGtlZXAgbGluZWJyZWFrc1xuICAgICAgICAgICAgaWYodGhpcy5pbnB1dC50eXBlID09PSAndGV4dGFyZWEnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUtcHJlLXdyYXBwZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hdHRhY2ggaGFuZGxlciBhY3RpdmF0aW5nIGVkaXRhYmxlLiBJbiBkaXNhYmxlZCBtb2RlIGl0IGp1c3QgcHJldmVudCBkZWZhdWx0IGFjdGlvbiAodXNlZnVsIGZvciBsaW5rcylcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy50b2dnbGUgIT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUtY2xpY2snKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKHRoaXMub3B0aW9ucy50b2dnbGUgKyAnLmVkaXRhYmxlJywgJC5wcm94eShmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IGZvbGxvd2luZyBsaW5rIGlmIGVkaXRhYmxlIGVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL3N0b3AgcHJvcGFnYXRpb24gbm90IHJlcXVpcmVkIGJlY2F1c2UgaW4gZG9jdW1lbnQgY2xpY2sgaGFuZGxlciBpdCBjaGVja3MgZXZlbnQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIC8vZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy50b2dnbGUgPT09ICdtb3VzZWVudGVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9mb3IgaG92ZXIgb25seSBzaG93IGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3doZW4gdG9nZ2xlPSdjbGljaycgd2Ugc2hvdWxkIG5vdCBjbG9zZSBhbGwgb3RoZXIgY29udGFpbmVycyBhcyB0aGV5IHdpbGwgYmUgY2xvc2VkIGF1dG9tYXRpY2FsbHkgaW4gZG9jdW1lbnQgY2xpY2sgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZUFsbCA9ICh0aGlzLm9wdGlvbnMudG9nZ2xlICE9PSAnY2xpY2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGNsb3NlQWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsIC0xKTsgLy9kbyBub3Qgc3RvcCBmb2N1cyBvbiBlbGVtZW50IHdoZW4gdG9nZ2xlZCBtYW51YWxseVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2lmIGRpc3BsYXkgaXMgZnVuY3Rpb24gaXQncyBmYXIgbW9yZSBjb252aW5pZW50IHRvIGhhdmUgYXV0b3RleHQgPSBhbHdheXMgdG8gcmVuZGVyIGNvcnJlY3RseSBvbiBpbml0XG4gICAgICAgICAgICAvL3NlZSBodHRwczovL2dpdGh1Yi5jb20vdml0YWxldHMveC1lZGl0YWJsZS15aWkvaXNzdWVzLzM0XG4gICAgICAgICAgICBpZih0eXBlb2YgdGhpcy5vcHRpb25zLmRpc3BsYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXV0b3RleHQgPSAnYWx3YXlzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jaGVjayBjb25kaXRpb25zIGZvciBhdXRvdGV4dDpcbiAgICAgICAgICAgIHN3aXRjaCh0aGlzLm9wdGlvbnMuYXV0b3RleHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAnYWx3YXlzJzpcbiAgICAgICAgICAgICAgIGRvQXV0b3RleHQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYXV0byc6XG4gICAgICAgICAgICAgICAgLy9pZiBlbGVtZW50IHRleHQgaXMgZW1wdHkgYW5kIHZhbHVlIGlzIGRlZmluZWQgYW5kIHZhbHVlIG5vdCBnZW5lcmF0ZWQgYnkgdGV4dCAtLT4gcnVuIGF1dG90ZXh0XG4gICAgICAgICAgICAgICAgZG9BdXRvdGV4dCA9ICEkLnRyaW0odGhpcy4kZWxlbWVudC50ZXh0KCkpLmxlbmd0aCAmJiB0aGlzLnZhbHVlICE9PSBudWxsICYmIHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhaXNWYWx1ZUJ5VGV4dDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICBkb0F1dG90ZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZGVwZW5kaW5nIG9uIGF1dG90ZXh0IHJ1biByZW5kZXIoKSBvciBqdXN0IGZpbmlsaXplIGluaXRcbiAgICAgICAgICAgICQud2hlbihkb0F1dG90ZXh0ID8gdGhpcy5yZW5kZXIoKSA6IHRydWUpLnRoZW4oJC5wcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoKTsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gZWxlbWVudCB3YXMgaW5pdGlhbGl6ZWQgYnkgYCQoKS5lZGl0YWJsZSgpYCBtZXRob2QuIFxuICAgICAgICAgICAgICAgUGxlYXNlIG5vdGUgdGhhdCB5b3Ugc2hvdWxkIHNldHVwIGBpbml0YCBoYW5kbGVyICoqYmVmb3JlKiogYXBwbHlpbmcgYGVkaXRhYmxlYC4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIEBldmVudCBpbml0IFxuICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGVkaXRhYmxlIGVkaXRhYmxlIGluc3RhbmNlIChhcyBoZXJlIGl0IGNhbm5vdCBhY2Nlc3NlZCB2aWEgZGF0YSgnZWRpdGFibGUnKSlcbiAgICAgICAgICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICAgICQoJyN1c2VybmFtZScpLm9uKCdpbml0JywgZnVuY3Rpb24oZSwgZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICBhbGVydCgnaW5pdGlhbGl6ZWQgJyArIGVkaXRhYmxlLm9wdGlvbnMubmFtZSk7XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICQoJyN1c2VybmFtZScpLmVkaXRhYmxlKCk7XG4gICAgICAgICAgICAgICAqKi8gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCdpbml0JywgdGhpcyk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgIEluaXRpYWxpemVzIHBhcmVudCBlbGVtZW50IGZvciBsaXZlIGVkaXRhYmxlcyBcbiAgICAgICAgKi9cbiAgICAgICAgaW5pdExpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAvL3N0b3JlIHNlbGVjdG9yIFxuICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLm9wdGlvbnMuc2VsZWN0b3I7XG4gICAgICAgICAgIC8vbW9kaWZ5IG9wdGlvbnMgZm9yIGNoaWxkIGVsZW1lbnRzXG4gICAgICAgICAgIHRoaXMub3B0aW9ucy5zZWxlY3RvciA9IGZhbHNlOyBcbiAgICAgICAgICAgdGhpcy5vcHRpb25zLmF1dG90ZXh0ID0gJ25ldmVyJztcbiAgICAgICAgICAgLy9saXN0ZW4gdG9nZ2xlIGV2ZW50c1xuICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKHRoaXMub3B0aW9ucy50b2dnbGUgKyAnLmVkaXRhYmxlJywgc2VsZWN0b3IsICQucHJveHkoZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICB2YXIgJHRhcmdldCA9ICQoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgaWYoISR0YXJnZXQuZGF0YSgnZWRpdGFibGUnKSkge1xuICAgICAgICAgICAgICAgICAgIC8vaWYgZGVsZWdhdGVkIGVsZW1lbnQgaW5pdGlhbGx5IGVtcHR5LCB3ZSBuZWVkIHRvIGNsZWFyIGl0J3MgdGV4dCAodGhhdCB3YXMgbWFudWFsbHkgc2V0IHRvIGBlbXB0eWAgYnkgdXNlcilcbiAgICAgICAgICAgICAgICAgICAvL3NlZSBodHRwczovL2dpdGh1Yi5jb20vdml0YWxldHMveC1lZGl0YWJsZS9pc3N1ZXMvMTM3IFxuICAgICAgICAgICAgICAgICAgIGlmKCR0YXJnZXQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmVtcHR5Y2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHRhcmdldC5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAkdGFyZ2V0LmVkaXRhYmxlKHRoaXMub3B0aW9ucykudHJpZ2dlcihlKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSwgdGhpcykpOyBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgIFJlbmRlcnMgdmFsdWUgaW50byBlbGVtZW50J3MgdGV4dC5cbiAgICAgICAgQ2FuIGNhbGwgY3VzdG9tIGRpc3BsYXkgbWV0aG9kIGZyb20gb3B0aW9ucy5cbiAgICAgICAgQ2FuIHJldHVybiBkZWZlcnJlZCBvYmplY3QuXG4gICAgICAgIEBtZXRob2QgcmVuZGVyKClcbiAgICAgICAgQHBhcmFtIHttaXhlZH0gcmVzcG9uc2Ugc2VydmVyIHJlc3BvbnNlIChpZiBleGlzdCkgdG8gcGFzcyBpbnRvIGRpc3BsYXkgZnVuY3Rpb25cbiAgICAgICAgKi8gICAgICAgICAgXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IGRpc3BsYXkgYW55dGhpbmdcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5kaXNwbGF5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiBpbnB1dCBoYXMgYHZhbHVlMmh0bWxGaW5hbGAgbWV0aG9kLCB3ZSBwYXNzIGNhbGxiYWNrIGluIHRoaXJkIHBhcmFtIHRvIGJlIGNhbGxlZCB3aGVuIHNvdXJjZSBpcyBsb2FkZWRcbiAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQudmFsdWUyaHRtbEZpbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQudmFsdWUyaHRtbCh0aGlzLnZhbHVlLCB0aGlzLiRlbGVtZW50WzBdLCB0aGlzLm9wdGlvbnMuZGlzcGxheSwgcmVzcG9uc2UpOyBcbiAgICAgICAgICAgIC8vaWYgZGlzcGxheSBtZXRob2QgZGVmaW5lZCAtLT4gdXNlIGl0ICAgIFxuICAgICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiB0aGlzLm9wdGlvbnMuZGlzcGxheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZGlzcGxheS5jYWxsKHRoaXMuJGVsZW1lbnRbMF0sIHRoaXMudmFsdWUsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vZWxzZSB1c2UgaW5wdXQncyBvcmlnaW5hbCB2YWx1ZTJodG1sKCkgbWV0aG9kICAgIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC52YWx1ZTJodG1sKHRoaXMudmFsdWUsIHRoaXMuJGVsZW1lbnRbMF0pOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBFbmFibGVzIGVkaXRhYmxlXG4gICAgICAgIEBtZXRob2QgZW5hYmxlKClcbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBlbmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdlZGl0YWJsZS1kaXNhYmxlZCcpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFbXB0eSh0aGlzLmlzRW1wdHkpO1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnRvZ2dsZSAhPT0gJ21hbnVhbCcpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JykgPT09ICctMScpIHsgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQXR0cigndGFiaW5kZXgnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBEaXNhYmxlcyBlZGl0YWJsZVxuICAgICAgICBAbWV0aG9kIGRpc2FibGUoKVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSB0cnVlOyBcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpOyAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdlZGl0YWJsZS1kaXNhYmxlZCcpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFbXB0eSh0aGlzLmlzRW1wdHkpO1xuICAgICAgICAgICAgLy9kbyBub3Qgc3RvcCBmb2N1cyBvbiB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAtMSk7ICAgICAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFRvZ2dsZXMgZW5hYmxlZCAvIGRpc2FibGVkIHN0YXRlIG9mIGVkaXRhYmxlIGVsZW1lbnRcbiAgICAgICAgQG1ldGhvZCB0b2dnbGVEaXNhYmxlZCgpXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0b2dnbGVEaXNhYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHsgXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgU2V0cyBuZXcgb3B0aW9uXG4gICAgICAgIFxuICAgICAgICBAbWV0aG9kIG9wdGlvbihrZXksIHZhbHVlKVxuICAgICAgICBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGtleSBvcHRpb24gbmFtZSBvciBvYmplY3Qgd2l0aCBzZXZlcmFsIG9wdGlvbnNcbiAgICAgICAgQHBhcmFtIHttaXhlZH0gdmFsdWUgb3B0aW9uIG5ldyB2YWx1ZVxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICAkKCcuZWRpdGFibGUnKS5lZGl0YWJsZSgnb3B0aW9uJywgJ3BrJywgMik7XG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgb3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAvL3NldCBvcHRpb24ocykgYnkgb2JqZWN0XG4gICAgICAgICAgICBpZihrZXkgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICQuZWFjaChrZXksICQucHJveHkoZnVuY3Rpb24oaywgdil7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbigkLnRyaW0oayksIHYpOyBcbiAgICAgICAgICAgICAgIH0sIHRoaXMpKTsgXG4gICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vc2V0IG9wdGlvbiBieSBzdHJpbmcgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZGlzYWJsZWRcbiAgICAgICAgICAgIGlmKGtleSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdGhpcy5kaXNhYmxlKCkgOiB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy92YWx1ZVxuICAgICAgICAgICAgaWYoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vdHJhbnNmZXIgbmV3IG9wdGlvbiB0byBjb250YWluZXIhIFxuICAgICAgICAgICAgaWYodGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5vcHRpb24oa2V5LCB2YWx1ZSk7ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcGFzcyBvcHRpb24gdG8gaW5wdXQgZGlyZWN0bHkgKGFzIGl0IHBvaW50cyB0byB0aGUgc2FtZSBpbiBmb3JtKVxuICAgICAgICAgICAgaWYodGhpcy5pbnB1dC5vcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Lm9wdGlvbihrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9LCAgICAgICAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAqIHNldCBlbXB0eXRleHQgaWYgZWxlbWVudCBpcyBlbXB0eVxuICAgICAgICAqL1xuICAgICAgICBoYW5kbGVFbXB0eTogZnVuY3Rpb24gKGlzRW1wdHkpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IGhhbmRsZSBlbXB0eSBpZiB3ZSBkbyBub3QgZGlzcGxheSBhbnl0aGluZ1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBcbiAgICAgICAgICAgIGlzRW1wdHkgbWF5IGJlIHNldCBkaXJlY3RseSBhcyBwYXJhbSBvZiBtZXRob2QuXG4gICAgICAgICAgICBJdCBpcyByZXF1aXJlZCB3aGVuIHdlIGVuYWJsZS9kaXNhYmxlIGZpZWxkIGFuZCBjYW4ndCByZWx5IG9uIGNvbnRlbnQgXG4gICAgICAgICAgICBhcyBub2RlIGNvbnRlbnQgaXMgdGV4dDogXCJFbXB0eVwiIHRoYXQgaXMgbm90IGVtcHR5ICUpXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYoaXNFbXB0eSAhPT0gdW5kZWZpbmVkKSB7IFxuICAgICAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vZGV0ZWN0IGVtcHR5XG4gICAgICAgICAgICAgICAgLy9mb3Igc29tZSBpbnB1dHMgd2UgbmVlZCBtb3JlIHNtYXJ0IGNoZWNrXG4gICAgICAgICAgICAgICAgLy9lLmcuIHd5c2lodG1sNSBtYXkgaGF2ZSA8YnI+LCA8cD48L3A+LCA8aW1nPlxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZih0aGlzLmlucHV0LmlzRW1wdHkpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA9IHRoaXMuaW5wdXQuaXNFbXB0eSh0aGlzLiRlbGVtZW50KTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA9ICQudHJpbSh0aGlzLiRlbGVtZW50Lmh0bWwoKSkgPT09ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2VtcHR5dGV4dCBzaG93biBvbmx5IGZvciBlbmFibGVkXG4gICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50Lmh0bWwodGhpcy5vcHRpb25zLmVtcHR5dGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLm9wdGlvbnMuZW1wdHljbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vYmVsb3cgcmVxdWlyZWQgaWYgZWxlbWVudCBkaXNhYmxlIHByb3BlcnR5IHdhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgaWYodGhpcy5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmVtcHR5Y2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmVtcHR5Y2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgU2hvd3MgY29udGFpbmVyIHdpdGggZm9ybVxuICAgICAgICBAbWV0aG9kIHNob3coKVxuICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlQWxsIFdoZXRoZXIgdG8gY2xvc2UgYWxsIG90aGVyIGVkaXRhYmxlIGNvbnRhaW5lcnMgd2hlbiBzaG93aW5nIHRoaXMgb25lLiBEZWZhdWx0IHRydWUuXG4gICAgICAgICoqLyAgXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uIChjbG9zZUFsbCkge1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2luaXQgZWRpdGFibGVDb250YWluZXI6IHBvcG92ZXIsIHRvb2x0aXAsIGlubGluZSwgZXRjLi5cbiAgICAgICAgICAgIGlmKCF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJPcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQgLy9wYXNzIGlucHV0IHRvIGZvcm0gKGFzIGl0IGlzIGFscmVhZHkgY3JlYXRlZClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LmVkaXRhYmxlQ29udGFpbmVyKGNvbnRhaW5lck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vbGlzdGVuIGBzYXZlYCBldmVudCBcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKFwic2F2ZS5pbnRlcm5hbFwiLCAkLnByb3h5KHRoaXMuc2F2ZSwgdGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy4kZWxlbWVudC5kYXRhKCdlZGl0YWJsZUNvbnRhaW5lcicpOyBcbiAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLmNvbnRhaW5lci50aXAoKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zaG93IGNvbnRhaW5lclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc2hvdyhjbG9zZUFsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgSGlkZXMgY29udGFpbmVyIHdpdGggZm9ybVxuICAgICAgICBAbWV0aG9kIGhpZGUoKVxuICAgICAgICAqKi8gICAgICAgXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHsgICBcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyKSB7ICBcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgVG9nZ2xlcyBjb250YWluZXIgdmlzaWJpbGl0eSAoc2hvdyAvIGhpZGUpXG4gICAgICAgIEBtZXRob2QgdG9nZ2xlKClcbiAgICAgICAgQHBhcmFtIHtib29sZWFufSBjbG9zZUFsbCBXaGV0aGVyIHRvIGNsb3NlIGFsbCBvdGhlciBlZGl0YWJsZSBjb250YWluZXJzIHdoZW4gc2hvd2luZyB0aGlzIG9uZS4gRGVmYXVsdCB0cnVlLlxuICAgICAgICAqKi8gIFxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uKGNsb3NlQWxsKSB7XG4gICAgICAgICAgICBpZih0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci50aXAoKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coY2xvc2VBbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgKiBjYWxsZWQgd2hlbiBmb3JtIHdhcyBzdWJtaXR0ZWRcbiAgICAgICAgKi8gICAgICAgICAgXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uKGUsIHBhcmFtcykge1xuICAgICAgICAgICAgLy9tYXJrIGVsZW1lbnQgd2l0aCB1bnNhdmVkIGNsYXNzIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnVuc2F2ZWRjbGFzcykge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgIEFkZCB1bnNhdmVkIGNzcyB0byBlbGVtZW50IGlmOlxuICAgICAgICAgICAgICAgICAgLSB1cmwgaXMgbm90IHVzZXIncyBmdW5jdGlvbiBcbiAgICAgICAgICAgICAgICAgIC0gdmFsdWUgd2FzIG5vdCBzZW50IHRvIHNlcnZlclxuICAgICAgICAgICAgICAgICAgLSBwYXJhbXMucmVzcG9uc2UgPT09IHVuZGVmaW5lZCwgdGhhdCBtZWFucyBkYXRhIHdhcyBub3Qgc2VudFxuICAgICAgICAgICAgICAgICAgLSB2YWx1ZSBjaGFuZ2VkIFxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZW50ID0gc2VudCB8fCB0eXBlb2YgdGhpcy5vcHRpb25zLnVybCA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgICAgICBzZW50ID0gc2VudCB8fCB0aGlzLm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2U7IFxuICAgICAgICAgICAgICAgIHNlbnQgPSBzZW50IHx8IHBhcmFtcy5yZXNwb25zZSAhPT0gdW5kZWZpbmVkOyBcbiAgICAgICAgICAgICAgICBzZW50ID0gc2VudCB8fCAodGhpcy5pbnB1dC52YWx1ZTJzdHIodGhpcy52YWx1ZSkgIT09IHRoaXMuaW5wdXQudmFsdWUyc3RyKHBhcmFtcy5uZXdWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMudW5zYXZlZGNsYXNzKTsgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMudW5zYXZlZGNsYXNzKTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9oaWdobGlnaHQgd2hlbiBzYXZpbmdcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgJGUgPSB0aGlzLiRlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gJGUuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICRlLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHRoaXMub3B0aW9ucy5oaWdobGlnaHQpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoYmdDb2xvciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmdDb2xvciA9ICcnOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkZS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBiZ0NvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgJGUuYWRkQ2xhc3MoJ2VkaXRhYmxlLWJnLXRyYW5zaXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAkZS5yZW1vdmVDbGFzcygnZWRpdGFibGUtYmctdHJhbnNpdGlvbicpOyAgXG4gICAgICAgICAgICAgICAgICAgIH0sIDE3MDApO1xuICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zZXQgbmV3IHZhbHVlXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHBhcmFtcy5uZXdWYWx1ZSwgZmFsc2UsIHBhcmFtcy5yZXNwb25zZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICBGaXJlZCB3aGVuIG5ldyB2YWx1ZSB3YXMgc3VibWl0dGVkLiBZb3UgY2FuIHVzZSA8Y29kZT4kKHRoaXMpLmRhdGEoJ2VkaXRhYmxlJyk8L2NvZGU+IHRvIGFjY2VzcyB0byBlZGl0YWJsZSBpbnN0YW5jZVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBAZXZlbnQgc2F2ZSBcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgYWRkaXRpb25hbCBwYXJhbXNcbiAgICAgICAgICAgIEBwYXJhbSB7bWl4ZWR9IHBhcmFtcy5uZXdWYWx1ZSBzdWJtaXR0ZWQgdmFsdWVcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucmVzcG9uc2UgYWpheCByZXNwb25zZVxuICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICQoJyN1c2VybmFtZScpLm9uKCdzYXZlJywgZnVuY3Rpb24oZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ1NhdmVkIHZhbHVlOiAnICsgcGFyYW1zLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICAvL2V2ZW50IGl0c2VsZiBpcyB0cmlnZ2VyZWQgYnkgZWRpdGFibGVDb250YWluZXIuIERlc2NyaXB0aW9uIGhlcmUgaXMgb25seSBmb3IgZG9jdW1lbnRhdGlvbiAgICAgICAgICAgICAgXG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnZhbGlkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YWxpZGF0ZS5jYWxsKHRoaXMsIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFNldHMgbmV3IHZhbHVlIG9mIGVkaXRhYmxlXG4gICAgICAgIEBtZXRob2Qgc2V0VmFsdWUodmFsdWUsIGNvbnZlcnRTdHIpXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHZhbHVlIG5ldyB2YWx1ZSBcbiAgICAgICAgQHBhcmFtIHtib29sZWFufSBjb252ZXJ0U3RyIHdoZXRoZXIgdG8gY29udmVydCB2YWx1ZSBmcm9tIHN0cmluZyB0byBpbnRlcm5hbCBmb3JtYXRcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgY29udmVydFN0ciwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmKGNvbnZlcnRTdHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbnB1dC5zdHIydmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLm9wdGlvbigndmFsdWUnLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQud2hlbih0aGlzLnJlbmRlcihyZXNwb25zZSkpXG4gICAgICAgICAgICAudGhlbigkLnByb3h5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRW1wdHkoKTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBBY3RpdmF0ZXMgaW5wdXQgb2YgdmlzaWJsZSBjb250YWluZXIgKGUuZy4gc2V0IGZvY3VzKVxuICAgICAgICBAbWV0aG9kIGFjdGl2YXRlKClcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hY3RpdmF0ZSgpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBSZW1vdmVzIGVkaXRhYmxlIGZlYXR1cmUgZnJvbSBlbGVtZW50XG4gICAgICAgIEBtZXRob2QgZGVzdHJveSgpXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5kZXN0cm95KCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnRvZ2dsZSAhPT0gJ21hbnVhbCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdlZGl0YWJsZS1jbGljaycpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKHRoaXMub3B0aW9ucy50b2dnbGUgKyAnLmVkaXRhYmxlJyk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZihcInNhdmUuaW50ZXJuYWxcIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2VkaXRhYmxlIGVkaXRhYmxlLW9wZW4gZWRpdGFibGUtZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnZWRpdGFibGUnKTtcbiAgICAgICAgfSAgICAgICAgXG4gICAgfTtcblxuICAgIC8qIEVESVRBQkxFIFBMVUdJTiBERUZJTklUSU9OXG4gICAgKiA9PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgLyoqXG4gICAgalF1ZXJ5IG1ldGhvZCB0byBpbml0aWFsaXplIGVkaXRhYmxlIGVsZW1lbnQuXG4gICAgXG4gICAgQG1ldGhvZCAkKCkuZWRpdGFibGUob3B0aW9ucylcbiAgICBAcGFyYW1zIHtPYmplY3R9IG9wdGlvbnNcbiAgICBAZXhhbXBsZVxuICAgICQoJyN1c2VybmFtZScpLmVkaXRhYmxlKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHBrOiAxXG4gICAgfSk7XG4gICAgKiovXG4gICAgJC5mbi5lZGl0YWJsZSA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgLy9zcGVjaWFsIEFQSSBtZXRob2RzIHJldHVybmluZyBub24tanF1ZXJ5IG9iamVjdFxuICAgICAgICB2YXIgcmVzdWx0ID0ge30sIGFyZ3MgPSBhcmd1bWVudHMsIGRhdGFrZXkgPSAnZWRpdGFibGUnO1xuICAgICAgICBzd2l0Y2ggKG9wdGlvbikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBSdW5zIGNsaWVudC1zaWRlIHZhbGlkYXRpb24gZm9yIGFsbCBtYXRjaGVkIGVkaXRhYmxlc1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBAbWV0aG9kIHZhbGlkYXRlKClcbiAgICAgICAgICAgIEByZXR1cm5zIHtPYmplY3R9IHZhbGlkYXRpb24gZXJyb3JzIG1hcFxuICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICQoJyN1c2VybmFtZSwgI2Z1bGxuYW1lJykuZWRpdGFibGUoJ3ZhbGlkYXRlJyk7XG4gICAgICAgICAgICAvLyBwb3NzaWJsZSByZXN1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHVzZXJuYW1lOiBcInVzZXJuYW1lIGlzIHJlcXVpcmVkXCIsXG4gICAgICAgICAgICAgIGZ1bGxuYW1lOiBcImZ1bGxuYW1lIHNob3VsZCBiZSBtaW5pbXVtIDMgbGV0dGVycyBsZW5ndGhcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICBjYXNlICd2YWxpZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSwgZGF0YSA9ICR0aGlzLmRhdGEoZGF0YWtleSksIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiAoZXJyb3IgPSBkYXRhLnZhbGlkYXRlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbZGF0YS5vcHRpb25zLm5hbWVdID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgUmV0dXJucyBjdXJyZW50IHZhbHVlcyBvZiBlZGl0YWJsZSBlbGVtZW50cy4gICBcbiAgICAgICAgICAgIE5vdGUgdGhhdCBpdCByZXR1cm5zIGFuICoqb2JqZWN0Kiogd2l0aCBuYW1lLXZhbHVlIHBhaXJzLCBub3QgYSB2YWx1ZSBpdHNlbGYuIEl0IGFsbG93cyB0byBnZXQgZGF0YSBmcm9tIHNldmVyYWwgZWxlbWVudHMuICAgIFxuICAgICAgICAgICAgSWYgdmFsdWUgb2Ygc29tZSBlZGl0YWJsZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgaXQgaXMgZXhjbHVkZWQgZnJvbSByZXN1bHQgb2JqZWN0LlxuICAgICAgICAgICAgV2hlbiBwYXJhbSBgaXNTaW5nbGVgIGlzIHNldCB0byAqKnRydWUqKiAtIGl0IGlzIHN1cHBvc2VkIHlvdSBoYXZlIHNpbmdsZSBlbGVtZW50IGFuZCB3aWxsIHJldHVybiB2YWx1ZSBvZiBlZGl0YWJsZSBpbnN0ZWFkIG9mIG9iamVjdC4gICBcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIEBtZXRob2QgZ2V0VmFsdWUoKVxuICAgICAgICAgICAgQHBhcmFtIHtib29sfSBpc1NpbmdsZSB3aGV0aGVyIHRvIHJldHVybiBqdXN0IHZhbHVlIG9mIHNpbmdsZSBlbGVtZW50XG4gICAgICAgICAgICBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgb2YgZWxlbWVudCBuYW1lcyBhbmQgdmFsdWVzXG4gICAgICAgICAgICBAZXhhbXBsZVxuICAgICAgICAgICAgJCgnI3VzZXJuYW1lLCAjZnVsbG5hbWUnKS5lZGl0YWJsZSgnZ2V0VmFsdWUnKTtcbiAgICAgICAgICAgIC8vcmVzdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgdXNlcm5hbWU6IFwic3VwZXJ1c2VyXCIsXG4gICAgICAgICAgICBmdWxsbmFtZTogXCJKb2huXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaXNTaW5nbGUgPSB0cnVlXG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSgnZ2V0VmFsdWUnLCB0cnVlKTtcbiAgICAgICAgICAgIC8vcmVzdWx0IFwic3VwZXJ1c2VyXCIgXG4gICAgICAgICAgICAqKi9cbiAgICAgICAgICAgIGNhc2UgJ2dldFZhbHVlJzpcbiAgICAgICAgICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIGFyZ3VtZW50c1sxXSA9PT0gdHJ1ZSkgeyAvL2lzU2luZ2xlID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmVxKDApLmRhdGEoZGF0YWtleSkudmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksIGRhdGEgPSAkdGhpcy5kYXRhKGRhdGFrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGRhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbZGF0YS5vcHRpb25zLm5hbWVdID0gZGF0YS5pbnB1dC52YWx1ZTJzdWJtaXQoZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgVGhpcyBtZXRob2QgY29sbGVjdHMgdmFsdWVzIGZyb20gc2V2ZXJhbCBlZGl0YWJsZSBlbGVtZW50cyBhbmQgc3VibWl0IHRoZW0gYWxsIHRvIHNlcnZlci4gICBcbiAgICAgICAgICAgIEludGVybmFsbHkgaXQgcnVucyBjbGllbnQtc2lkZSB2YWxpZGF0aW9uIGZvciBhbGwgZmllbGRzIGFuZCBzdWJtaXRzIG9ubHkgaW4gY2FzZSBvZiBzdWNjZXNzLiAgXG4gICAgICAgICAgICBTZWUgPGEgaHJlZj1cIiNuZXdyZWNvcmRcIj5jcmVhdGluZyBuZXcgcmVjb3JkczwvYT4gZm9yIGRldGFpbHMuICBcbiAgICAgICAgICAgIFNpbmNlIDEuNS4xIGBzdWJtaXRgIGNhbiBiZSBhcHBsaWVkIHRvIHNpbmdsZSBlbGVtZW50IHRvIHNlbmQgZGF0YSBwcm9ncmFtbWF0aWNhbGx5LiBJbiB0aGF0IGNhc2VcbiAgICAgICAgICAgIGB1cmxgLCBgc3VjY2Vzc2AgYW5kIGBlcnJvcmAgaXMgdGFrZW4gZnJvbSBpbml0aWFsIG9wdGlvbnMgYW5kIHlvdSBjYW4ganVzdCBjYWxsIGAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSgnc3VibWl0JylgLiBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQG1ldGhvZCBzdWJtaXQob3B0aW9ucylcbiAgICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFxuICAgICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudXJsIHVybCB0byBzdWJtaXQgZGF0YSBcbiAgICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmRhdGEgYWRkaXRpb25hbCBkYXRhIHRvIHN1Ym1pdFxuICAgICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuYWpheE9wdGlvbnMgYWRkaXRpb25hbCBhamF4IG9wdGlvbnNcbiAgICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuZXJyb3Iob2JqKSBlcnJvciBoYW5kbGVyIFxuICAgICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5zdWNjZXNzKG9iaixjb25maWcpIHN1Y2Nlc3MgaGFuZGxlclxuICAgICAgICAgICAgQHJldHVybnMge09iamVjdH0galF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICBjYXNlICdzdWJtaXQnOiAgLy9jb2xsZWN0cyB2YWx1ZSwgdmFsaWRhdGUgYW5kIHN1Ym1pdCB0byBzZXJ2ZXIgZm9yIGNyZWF0aW5nIG5ldyByZWNvcmRcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gYXJndW1lbnRzWzFdIHx8IHt9LFxuICAgICAgICAgICAgICAgICRlbGVtcyA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZXJyb3JzID0gdGhpcy5lZGl0YWJsZSgndmFsaWRhdGUnKTtcblxuICAgICAgICAgICAgICAgIC8vIHZhbGlkYXRpb24gb2tcbiAgICAgICAgICAgICAgICBpZigkLmlzRW1wdHlPYmplY3QoZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWpheE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3Igc2luZ2xlIGVsZW1lbnQgdXNlIHVybCwgc3VjY2VzcyBldGMgZnJvbSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmKCRlbGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9ICRlbGVtcy5kYXRhKCdlZGl0YWJsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9zdGFuZGFyZCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWRpdGFibGUub3B0aW9ucy5uYW1lIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlZGl0YWJsZS5pbnB1dC52YWx1ZTJzdWJtaXQoZWRpdGFibGUudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrOiAodHlwZW9mIGVkaXRhYmxlLm9wdGlvbnMucGsgPT09ICdmdW5jdGlvbicpID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLm9wdGlvbnMucGsuY2FsbChlZGl0YWJsZS5vcHRpb25zLnNjb3BlKSA6IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5vcHRpb25zLnBrIFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGRpdGlvbmFsIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGVkaXRhYmxlLm9wdGlvbnMucGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gZWRpdGFibGUub3B0aW9ucy5wYXJhbXMuY2FsbChlZGl0YWJsZS5vcHRpb25zLnNjb3BlLCBwYXJhbXMpOyAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGpzb24gaW4gc2luZ2xlIHF1b3RlcyAoZnJvbSBkYXRhLXBhcmFtcyBhdHRyaWJ1dGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUub3B0aW9ucy5wYXJhbXMgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKGVkaXRhYmxlLm9wdGlvbnMucGFyYW1zLCB0cnVlKTsgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChwYXJhbXMsIGVkaXRhYmxlLm9wdGlvbnMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYWpheE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBlZGl0YWJsZS5vcHRpb25zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBzdWNjZXNzIC8gZXJyb3IgZnJvbSBvcHRpb25zIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN1Y2Nlc3MgPSBjb25maWcuc3VjY2VzcyB8fCBlZGl0YWJsZS5vcHRpb25zLnN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZXJyb3IgPSBjb25maWcuZXJyb3IgfHwgZWRpdGFibGUub3B0aW9ucy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBtdWx0aXBsZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZWRpdGFibGUoJ2dldFZhbHVlJyk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBhamF4T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGNvbmZpZy51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFqYXggc3VjY2VzcyBjYWxsYWJjayAocmVzcG9uc2UgMjAwIE9LKVxuICAgICAgICAgICAgICAgICAgICBhamF4T3B0aW9ucy5zdWNjZXNzID0gdHlwZW9mIGNvbmZpZy5zdWNjZXNzID09PSAnZnVuY3Rpb24nID8gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc3VjY2Vzcy5jYWxsKCRlbGVtcywgcmVzcG9uc2UsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IDogJC5ub29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBhamF4IGVycm9yIGNhbGxhYmNrXG4gICAgICAgICAgICAgICAgICAgIGFqYXhPcHRpb25zLmVycm9yID0gdHlwZW9mIGNvbmZpZy5lcnJvciA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZXJyb3IuYXBwbHkoJGVsZW1zLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSA6ICQubm9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dGVuZCBhamF4T3B0aW9ucyAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoY29uZmlnLmFqYXhPcHRpb25zKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQoYWpheE9wdGlvbnMsIGNvbmZpZy5hamF4T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dHJhIGRhdGEgXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbmZpZy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChhamF4T3B0aW9ucy5kYXRhLCBjb25maWcuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gYWpheCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICQuYWpheChhamF4T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9jbGllbnQtc2lkZSB2YWxpZGF0aW9uIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb25maWcuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lcnJvci5jYWxsKCRlbGVtcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9yZXR1cm4ganF1ZXJ5IG9iamVjdFxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksIFxuICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKGRhdGFrZXkpLCBcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PT0gJ29iamVjdCcgJiYgb3B0aW9uO1xuXG4gICAgICAgICAgICAvL2ZvciBkZWxlZ2F0ZWQgdGFyZ2V0cyBkbyBub3Qgc3RvcmUgYGVkaXRhYmxlYCBvYmplY3QgZm9yIGVsZW1lbnRcbiAgICAgICAgICAgIC8vaXQncyBhbGxvd3Mgc2V2ZXJhbCBkaWZmZXJlbnQgc2VsZWN0b3JzLlxuICAgICAgICAgICAgLy9zZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlL2lzc3Vlcy8zMTIgICAgXG4gICAgICAgICAgICBpZihvcHRpb25zICYmIG9wdGlvbnMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbmV3IEVkaXRhYmxlKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgXG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKGRhdGFrZXksIChkYXRhID0gbmV3IEVkaXRhYmxlKHRoaXMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJykgeyAvL2NhbGwgbWV0aG9kIFxuICAgICAgICAgICAgICAgIGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICB9OyAgICBcbiAgICAgICAgICAgIFxuXG4gICAgJC5mbi5lZGl0YWJsZS5kZWZhdWx0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgIFR5cGUgb2YgaW5wdXQuIENhbiBiZSA8Y29kZT50ZXh0fHRleHRhcmVhfHNlbGVjdHxkYXRlfGNoZWNrbGlzdDwvY29kZT4gYW5kIG1vcmVcblxuICAgICAgICBAcHJvcGVydHkgdHlwZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICd0ZXh0J1xuICAgICAgICAqKi9cbiAgICAgICAgdHlwZTogJ3RleHQnLCAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBTZXRzIGRpc2FibGVkIHN0YXRlIG9mIGVkaXRhYmxlXG5cbiAgICAgICAgQHByb3BlcnR5IGRpc2FibGVkIFxuICAgICAgICBAdHlwZSBib29sZWFuXG4gICAgICAgIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICBIb3cgdG8gdG9nZ2xlIGVkaXRhYmxlLiBDYW4gYmUgPGNvZGU+Y2xpY2t8ZGJsY2xpY2t8bW91c2VlbnRlcnxtYW51YWw8L2NvZGU+LiAgIFxuICAgICAgICBXaGVuIHNldCB0byA8Y29kZT5tYW51YWw8L2NvZGU+IHlvdSBzaG91bGQgbWFudWFsbHkgY2FsbCA8Y29kZT5zaG93L2hpZGU8L2NvZGU+IG1ldGhvZHMgb2YgZWRpdGFibGUuICAgIFxuICAgICAgICAqKk5vdGUqKjogaWYgeW91IGNhbGwgPGNvZGU+c2hvdzwvY29kZT4gb3IgPGNvZGU+dG9nZ2xlPC9jb2RlPiBpbnNpZGUgKipjbGljayoqIGhhbmRsZXIgb2Ygc29tZSBET00gZWxlbWVudCwgXG4gICAgICAgIHlvdSBuZWVkIHRvIGFwcGx5IDxjb2RlPmUuc3RvcFByb3BhZ2F0aW9uKCk8L2NvZGU+IGJlY2F1c2UgY29udGFpbmVycyBhcmUgYmVpbmcgY2xvc2VkIG9uIGFueSBjbGljayBvbiBkb2N1bWVudC5cbiAgICAgICAgXG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgICQoJyNlZGl0LWJ1dHRvbicpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSgndG9nZ2xlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIEBwcm9wZXJ0eSB0b2dnbGUgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAnY2xpY2snXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgdG9nZ2xlOiAnY2xpY2snLFxuICAgICAgICAvKipcbiAgICAgICAgVGV4dCBzaG93biB3aGVuIGVsZW1lbnQgaXMgZW1wdHkuXG5cbiAgICAgICAgQHByb3BlcnR5IGVtcHR5dGV4dCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICdFbXB0eSdcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGVtcHR5dGV4dDogJ0VtcHR5JyxcbiAgICAgICAgLyoqXG4gICAgICAgIEFsbG93cyB0byBhdXRvbWF0aWNhbGx5IHNldCBlbGVtZW50J3MgdGV4dCBiYXNlZCBvbiBpdCdzIHZhbHVlLiBDYW4gYmUgPGNvZGU+YXV0b3xhbHdheXN8bmV2ZXI8L2NvZGU+LiBVc2VmdWwgZm9yIHNlbGVjdCBhbmQgZGF0ZS5cbiAgICAgICAgRm9yIGV4YW1wbGUsIGlmIGRyb3Bkb3duIGxpc3QgaXMgPGNvZGU+ezE6ICdhJywgMjogJ2InfTwvY29kZT4gYW5kIGVsZW1lbnQncyB2YWx1ZSBzZXQgdG8gPGNvZGU+MTwvY29kZT4sIGl0J3MgaHRtbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIDxjb2RlPidhJzwvY29kZT4uICBcbiAgICAgICAgPGNvZGU+YXV0bzwvY29kZT4gLSB0ZXh0IHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgb25seSBpZiBlbGVtZW50IGlzIGVtcHR5LiAgXG4gICAgICAgIDxjb2RlPmFsd2F5c3xuZXZlcjwvY29kZT4gLSBhbHdheXMobmV2ZXIpIHRyeSB0byBzZXQgZWxlbWVudCdzIHRleHQuXG5cbiAgICAgICAgQHByb3BlcnR5IGF1dG90ZXh0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ2F1dG8nXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgYXV0b3RleHQ6ICdhdXRvJywgXG4gICAgICAgIC8qKlxuICAgICAgICBJbml0aWFsIHZhbHVlIG9mIGlucHV0LiBJZiBub3Qgc2V0LCB0YWtlbiBmcm9tIGVsZW1lbnQncyB0ZXh0LiAgXG4gICAgICAgIE5vdGUsIHRoYXQgaWYgZWxlbWVudCdzIHRleHQgaXMgZW1wdHkgLSB0ZXh0IGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGZyb20gdmFsdWUgYW5kIGNhbiBiZSBjdXN0b21pemVkIChzZWUgYGF1dG90ZXh0YCBvcHRpb24pLiAgXG4gICAgICAgIEZvciBleGFtcGxlLCB0byBkaXNwbGF5IGN1cnJlbmN5IHNpZ246XG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIDxhIGlkPVwicHJpY2VcIiBkYXRhLXR5cGU9XCJ0ZXh0XCIgZGF0YS12YWx1ZT1cIjEwMFwiPjwvYT5cbiAgICAgICAgPHNjcmlwdD5cbiAgICAgICAgJCgnI3ByaWNlJykuZWRpdGFibGUoe1xuICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICBkaXNwbGF5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAkKHRoaXMpLnRleHQodmFsdWUgKyAnJCcpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSkgXG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICAgICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgdmFsdWUgXG4gICAgICAgIEB0eXBlIG1peGVkXG4gICAgICAgIEBkZWZhdWx0IGVsZW1lbnQncyB0ZXh0XG4gICAgICAgICoqL1xuICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIENhbGxiYWNrIHRvIHBlcmZvcm0gY3VzdG9tIGRpc3BsYXlpbmcgb2YgdmFsdWUgaW4gZWxlbWVudCdzIHRleHQuICBcbiAgICAgICAgSWYgYG51bGxgLCBkZWZhdWx0IGlucHV0J3MgZGlzcGxheSB1c2VkLiAgXG4gICAgICAgIElmIGBmYWxzZWAsIG5vIGRpc3BsYXlpbmcgbWV0aG9kcyB3aWxsIGJlIGNhbGxlZCwgZWxlbWVudCdzIHRleHQgd2lsbCBuZXZlciBjaGFuZ2UuICBcbiAgICAgICAgUnVucyB1bmRlciBlbGVtZW50J3Mgc2NvcGUuICBcbiAgICAgICAgXyoqUGFyYW1ldGVyczoqKl8gIFxuICAgICAgICBcbiAgICAgICAgKiBgdmFsdWVgIGN1cnJlbnQgdmFsdWUgdG8gYmUgZGlzcGxheWVkXG4gICAgICAgICogYHJlc3BvbnNlYCBzZXJ2ZXIgcmVzcG9uc2UgKGlmIGRpc3BsYXkgY2FsbGVkIGFmdGVyIGFqYXggc3VibWl0KSwgc2luY2UgMS40LjBcbiAgICAgICAgIFxuICAgICAgICBGb3IgX2lucHV0cyB3aXRoIHNvdXJjZV8gKHNlbGVjdCwgY2hlY2tsaXN0KSBwYXJhbWV0ZXJzIGFyZSBkaWZmZXJlbnQ6ICBcbiAgICAgICAgICBcbiAgICAgICAgKiBgdmFsdWVgIGN1cnJlbnQgdmFsdWUgdG8gYmUgZGlzcGxheWVkXG4gICAgICAgICogYHNvdXJjZURhdGFgIGFycmF5IG9mIGl0ZW1zIGZvciBjdXJyZW50IGlucHV0IChlLmcuIGRyb3Bkb3duIGl0ZW1zKSBcbiAgICAgICAgKiBgcmVzcG9uc2VgIHNlcnZlciByZXNwb25zZSAoaWYgZGlzcGxheSBjYWxsZWQgYWZ0ZXIgYWpheCBzdWJtaXQpLCBzaW5jZSAxLjQuMFxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgIFRvIGdldCBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXMgdXNlIGAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCBzb3VyY2VEYXRhKWAuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgZGlzcGxheSBcbiAgICAgICAgQHR5cGUgZnVuY3Rpb258Ym9vbGVhblxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICBkaXNwbGF5OiBmdW5jdGlvbih2YWx1ZSwgc291cmNlRGF0YSkge1xuICAgICAgICAgICAvL2Rpc3BsYXkgY2hlY2tsaXN0IGFzIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgdmFyIGh0bWwgPSBbXSxcbiAgICAgICAgICAgICAgIGNoZWNrZWQgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCBzb3VyY2VEYXRhKTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICBpZihjaGVja2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgJC5lYWNoKGNoZWNrZWQsIGZ1bmN0aW9uKGksIHYpIHsgaHRtbC5wdXNoKCQuZm4uZWRpdGFibGV1dGlscy5lc2NhcGUodi50ZXh0KSk7IH0pO1xuICAgICAgICAgICAgICAgJCh0aGlzKS5odG1sKGh0bWwuam9pbignLCAnKSk7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAkKHRoaXMpLmVtcHR5KCk7IFxuICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBkaXNwbGF5OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgQ3NzIGNsYXNzIGFwcGxpZWQgd2hlbiBlZGl0YWJsZSB0ZXh0IGlzIGVtcHR5LlxuXG4gICAgICAgIEBwcm9wZXJ0eSBlbXB0eWNsYXNzIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQHNpbmNlIDEuNC4xICAgICAgICBcbiAgICAgICAgQGRlZmF1bHQgZWRpdGFibGUtZW1wdHlcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgZW1wdHljbGFzczogJ2VkaXRhYmxlLWVtcHR5JyxcbiAgICAgICAgLyoqXG4gICAgICAgIENzcyBjbGFzcyBhcHBsaWVkIHdoZW4gdmFsdWUgd2FzIHN0b3JlZCBidXQgbm90IHNlbnQgdG8gc2VydmVyIChgcGtgIGlzIGVtcHR5IG9yIGBzZW5kID0gJ25ldmVyJ2ApLiAgXG4gICAgICAgIFlvdSBtYXkgc2V0IGl0IHRvIGBudWxsYCBpZiB5b3Ugd29yayB3aXRoIGVkaXRhYmxlcyBsb2NhbGx5IGFuZCBzdWJtaXQgdGhlbSB0b2dldGhlci4gIFxuXG4gICAgICAgIEBwcm9wZXJ0eSB1bnNhdmVkY2xhc3MgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAc2luY2UgMS40LjEgICAgICAgIFxuICAgICAgICBAZGVmYXVsdCBlZGl0YWJsZS11bnNhdmVkXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHVuc2F2ZWRjbGFzczogJ2VkaXRhYmxlLXVuc2F2ZWQnLFxuICAgICAgICAvKipcbiAgICAgICAgSWYgc2VsZWN0b3IgaXMgcHJvdmlkZWQsIGVkaXRhYmxlIHdpbGwgYmUgZGVsZWdhdGVkIHRvIHRoZSBzcGVjaWZpZWQgdGFyZ2V0cy4gIFxuICAgICAgICBVc2VmdWxsIGZvciBkeW5hbWljYWxseSBnZW5lcmF0ZWQgRE9NIGVsZW1lbnRzLiAgXG4gICAgICAgICoqUGxlYXNlIG5vdGUqKiwgdGhhdCBkZWxlZ2F0ZWQgdGFyZ2V0cyBjYW4ndCBiZSBpbml0aWFsaXplZCB3aXRoIGBlbXB0eXRleHRgIGFuZCBgYXV0b3RleHRgIG9wdGlvbnMsIFxuICAgICAgICBhcyB0aGV5IGFjdHVhbGx5IGJlY29tZSBlZGl0YWJsZSBvbmx5IGFmdGVyIGZpcnN0IGNsaWNrLiAgXG4gICAgICAgIFlvdSBzaG91bGQgbWFudWFsbHkgc2V0IGNsYXNzIGBlZGl0YWJsZS1jbGlja2AgdG8gdGhlc2UgZWxlbWVudHMuICBcbiAgICAgICAgQWxzbywgaWYgZWxlbWVudCBvcmlnaW5hbGx5IGVtcHR5IHlvdSBzaG91bGQgYWRkIGNsYXNzIGBlZGl0YWJsZS1lbXB0eWAsIHNldCBgZGF0YS12YWx1ZT1cIlwiYCBhbmQgd3JpdGUgZW1wdHl0ZXh0IGludG8gZWxlbWVudDpcblxuICAgICAgICBAcHJvcGVydHkgc2VsZWN0b3IgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAc2luY2UgMS40LjEgICAgICAgIFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIDxkaXYgaWQ9XCJ1c2VyXCI+XG4gICAgICAgICAgPCEtLSBlbXB0eSAtLT5cbiAgICAgICAgICA8YSBocmVmPVwiI1wiIGRhdGEtbmFtZT1cInVzZXJuYW1lXCIgZGF0YS10eXBlPVwidGV4dFwiIGNsYXNzPVwiZWRpdGFibGUtY2xpY2sgZWRpdGFibGUtZW1wdHlcIiBkYXRhLXZhbHVlPVwiXCIgdGl0bGU9XCJVc2VybmFtZVwiPkVtcHR5PC9hPlxuICAgICAgICAgIDwhLS0gbm9uLWVtcHR5IC0tPlxuICAgICAgICAgIDxhIGhyZWY9XCIjXCIgZGF0YS1uYW1lPVwiZ3JvdXBcIiBkYXRhLXR5cGU9XCJzZWxlY3RcIiBkYXRhLXNvdXJjZT1cIi9ncm91cHNcIiBkYXRhLXZhbHVlPVwiMVwiIGNsYXNzPVwiZWRpdGFibGUtY2xpY2tcIiB0aXRsZT1cIkdyb3VwXCI+T3BlcmF0b3I8L2E+XG4gICAgICAgIDwvZGl2PiAgICAgXG4gICAgICAgIFxuICAgICAgICA8c2NyaXB0PlxuICAgICAgICAkKCcjdXNlcicpLmVkaXRhYmxlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnYScsXG4gICAgICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgICAgICBwazogMVxuICAgICAgICB9KTtcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBzZWxlY3RvcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIENvbG9yIHVzZWQgdG8gaGlnaGxpZ2h0IGVsZW1lbnQgYWZ0ZXIgdXBkYXRlLiBJbXBsZW1lbnRlZCB2aWEgQ1NTMyB0cmFuc2l0aW9uLCB3b3JrcyBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgaGlnaGxpZ2h0IFxuICAgICAgICBAdHlwZSBzdHJpbmd8Ym9vbGVhblxuICAgICAgICBAc2luY2UgMS40LjUgICAgICAgIFxuICAgICAgICBAZGVmYXVsdCAjRkZGRjgwIFxuICAgICAgICAqKi9cbiAgICAgICAgaGlnaGxpZ2h0OiAnI0ZGRkY4MCdcbiAgICB9O1xuICAgIFxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuQWJzdHJhY3RJbnB1dCAtIGJhc2UgY2xhc3MgZm9yIGFsbCBlZGl0YWJsZSBpbnB1dHMuXG5JdCBkZWZpbmVzIGludGVyZmFjZSB0byBiZSBpbXBsZW1lbnRlZCBieSBhbnkgaW5wdXQgdHlwZS5cblRvIGNyZWF0ZSB5b3VyIG93biBpbnB1dCB5b3UgY2FuIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzLlxuXG5AY2xhc3MgYWJzdHJhY3RpbnB1dFxuKiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIC8vdHlwZXNcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMgPSB7fTtcblxuICAgIHZhciBBYnN0cmFjdElucHV0ID0gZnVuY3Rpb24gKCkgeyB9O1xuXG4gICAgQWJzdHJhY3RJbnB1dC5wcm90b3R5cGUgPSB7XG4gICAgICAgLyoqXG4gICAgICAgIEluaXRpYWxpemVzIGlucHV0XG5cbiAgICAgICAgQG1ldGhvZCBpbml0KCkgXG4gICAgICAgICoqL1xuICAgICAgIGluaXQ6IGZ1bmN0aW9uKHR5cGUsIG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgfSxcblxuICAgICAgIC8qXG4gICAgICAgdGhpcyBtZXRob2QgY2FsbGVkIGJlZm9yZSByZW5kZXIgdG8gaW5pdCAkdHBsIHRoYXQgaXMgaW5zZXJ0ZWQgaW4gRE9NXG4gICAgICAgKi9cbiAgICAgICBwcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB0aGlzLiR0cGwgPSAkKHRoaXMub3B0aW9ucy50cGwpOyAvL3dob2xlIHRwbCBhcyBqcXVlcnkgb2JqZWN0ICAgIFxuICAgICAgICAgICB0aGlzLiRpbnB1dCA9IHRoaXMuJHRwbDsgICAgICAgICAvL2NvbnRyb2wgaXRzZWxmLCBjYW4gYmUgY2hhbmdlZCBpbiByZW5kZXIgbWV0aG9kXG4gICAgICAgICAgIHRoaXMuJGNsZWFyID0gbnVsbDsgICAgICAgICAgICAgIC8vY2xlYXIgYnV0dG9uXG4gICAgICAgICAgIHRoaXMuZXJyb3IgPSBudWxsOyAgICAgICAgICAgICAgIC8vZXJyb3IgbWVzc2FnZSwgaWYgaW5wdXQgY2Fubm90IGJlIHJlbmRlcmVkICAgICAgICAgICBcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qKlxuICAgICAgICBSZW5kZXJzIGlucHV0IGZyb20gdHBsLiBDYW4gcmV0dXJuIGpRdWVyeSBkZWZlcnJlZCBvYmplY3QuXG4gICAgICAgIENhbiBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBvYmplY3RzXG5cbiAgICAgICAgQG1ldGhvZCByZW5kZXIoKVxuICAgICAgICoqL1xuICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICB9LCBcblxuICAgICAgIC8qKlxuICAgICAgICBTZXRzIGVsZW1lbnQncyBodG1sIGJ5IHZhbHVlLiBcblxuICAgICAgICBAbWV0aG9kIHZhbHVlMmh0bWwodmFsdWUsIGVsZW1lbnQpXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHZhbHVlXG4gICAgICAgIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudFxuICAgICAgICoqL1xuICAgICAgIHZhbHVlMmh0bWw6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICQoZWxlbWVudClbdGhpcy5vcHRpb25zLmVzY2FwZSA/ICd0ZXh0JyA6ICdodG1sJ10oJC50cmltKHZhbHVlKSk7XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICBDb252ZXJ0cyBlbGVtZW50J3MgaHRtbCB0byB2YWx1ZVxuXG4gICAgICAgIEBtZXRob2QgaHRtbDJ2YWx1ZShodG1sKVxuICAgICAgICBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAgICBAcmV0dXJucyB7bWl4ZWR9XG4gICAgICAgKiovXG4gICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICByZXR1cm4gJCgnPGRpdj4nKS5odG1sKGh0bWwpLnRleHQoKTtcbiAgICAgICB9LFxuXG4gICAgICAgLyoqXG4gICAgICAgIENvbnZlcnRzIHZhbHVlIHRvIHN0cmluZyAoZm9yIGludGVybmFsIGNvbXBhcmUpLiBGb3Igc3VibWl0dGluZyB0byBzZXJ2ZXIgdXNlZCB2YWx1ZTJzdWJtaXQoKS5cblxuICAgICAgICBAbWV0aG9kIHZhbHVlMnN0cih2YWx1ZSkgXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHZhbHVlXG4gICAgICAgIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgKiovXG4gICAgICAgdmFsdWUyc3RyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgfSwgXG5cbiAgICAgICAvKipcbiAgICAgICAgQ29udmVydHMgc3RyaW5nIHJlY2VpdmVkIGZyb20gc2VydmVyIGludG8gdmFsdWUuIFVzdWFsbHkgZnJvbSBgZGF0YS12YWx1ZWAgYXR0cmlidXRlLlxuXG4gICAgICAgIEBtZXRob2Qgc3RyMnZhbHVlKHN0cilcbiAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAgICBAcmV0dXJucyB7bWl4ZWR9XG4gICAgICAgKiovXG4gICAgICAgc3RyMnZhbHVlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICB9LCBcbiAgICAgICBcbiAgICAgICAvKipcbiAgICAgICAgQ29udmVydHMgdmFsdWUgZm9yIHN1Ym1pdHRpbmcgdG8gc2VydmVyLiBSZXN1bHQgY2FuIGJlIHN0cmluZyBvciBvYmplY3QuXG5cbiAgICAgICAgQG1ldGhvZCB2YWx1ZTJzdWJtaXQodmFsdWUpIFxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZVxuICAgICAgICBAcmV0dXJucyB7bWl4ZWR9XG4gICAgICAgKiovXG4gICAgICAgdmFsdWUyc3VibWl0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICBTZXRzIHZhbHVlIG9mIGlucHV0LlxuXG4gICAgICAgIEBtZXRob2QgdmFsdWUyaW5wdXQodmFsdWUpIFxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZVxuICAgICAgICoqL1xuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwodmFsdWUpO1xuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgUmV0dXJucyB2YWx1ZSBvZiBpbnB1dC4gVmFsdWUgY2FuIGJlIG9iamVjdCAoZS5nLiBkYXRlcGlja2VyKVxuXG4gICAgICAgIEBtZXRob2QgaW5wdXQydmFsdWUoKSBcbiAgICAgICAqKi9cbiAgICAgICBpbnB1dDJ2YWx1ZTogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQudmFsKCk7XG4gICAgICAgfSwgXG5cbiAgICAgICAvKipcbiAgICAgICAgQWN0aXZhdGVzIGlucHV0LiBGb3IgdGV4dCBpdCBzZXRzIGZvY3VzLlxuXG4gICAgICAgIEBtZXRob2QgYWN0aXZhdGUoKSBcbiAgICAgICAqKi9cbiAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIGlmKHRoaXMuJGlucHV0LmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICB9XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICBDcmVhdGVzIGlucHV0LlxuXG4gICAgICAgIEBtZXRob2QgY2xlYXIoKSBcbiAgICAgICAqKi8gICAgICAgIFxuICAgICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQudmFsKG51bGwpO1xuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgbWV0aG9kIHRvIGVzY2FwZSBodG1sLlxuICAgICAgICoqL1xuICAgICAgIGVzY2FwZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgIHJldHVybiAkKCc8ZGl2PicpLnRleHQoc3RyKS5odG1sKCk7XG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICAvKipcbiAgICAgICAgYXR0YWNoIGhhbmRsZXIgdG8gYXV0b21hdGljYWxseSBzdWJtaXQgZm9ybSB3aGVuIHZhbHVlIGNoYW5nZWQgKHVzZWZ1bCB3aGVuIGJ1dHRvbnMgbm90IHNob3duKVxuICAgICAgICoqL1xuICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qKlxuICAgICAgIEFkZGl0aW9uYWwgYWN0aW9ucyB3aGVuIGRlc3Ryb3lpbmcgZWxlbWVudCBcbiAgICAgICAqKi9cbiAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICB9LFxuXG4gICAgICAgLy8gLS0tLS0tLS0gaGVscGVyIGZ1bmN0aW9ucyAtLS0tLS0tLVxuICAgICAgIHNldENsYXNzOiBmdW5jdGlvbigpIHsgICAgICAgICAgXG4gICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5pbnB1dGNsYXNzKSB7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRjbGFzcyk7IFxuICAgICAgICAgICB9IFxuICAgICAgIH0sXG5cbiAgICAgICBzZXRBdHRyOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNbYXR0cl0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnNbYXR0cl0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LmF0dHIoYXR0ciwgdGhpcy5vcHRpb25zW2F0dHJdKTtcbiAgICAgICAgICAgfSBcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIG9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICB9XG4gICAgICAgXG4gICAgfTtcbiAgICAgICAgXG4gICAgQWJzdHJhY3RJbnB1dC5kZWZhdWx0cyA9IHsgIFxuICAgICAgICAvKipcbiAgICAgICAgSFRNTCB0ZW1wbGF0ZSBvZiBpbnB1dC4gTm9ybWFsbHkgeW91IHNob3VsZCBub3QgY2hhbmdlIGl0LlxuXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAnJ1xuICAgICAgICAqKi8gICBcbiAgICAgICAgdHBsOiAnJyxcbiAgICAgICAgLyoqXG4gICAgICAgIENTUyBjbGFzcyBhdXRvbWF0aWNhbGx5IGFwcGxpZWQgdG8gaW5wdXRcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgaW5wdXRjbGFzczogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBJZiBgdHJ1ZWAgLSBodG1sIHdpbGwgYmUgZXNjYXBlZCBpbiBjb250ZW50IG9mIGVsZW1lbnQgdmlhICQudGV4dCgpIG1ldGhvZC4gIFxuICAgICAgICBJZiBgZmFsc2VgIC0gaHRtbCB3aWxsIG5vdCBiZSBlc2NhcGVkLCAkLmh0bWwoKSB1c2VkLiAgXG4gICAgICAgIFdoZW4geW91IHVzZSBvd24gYGRpc3BsYXlgIGZ1bmN0aW9uLCB0aGlzIG9wdGlvbiBvYnZpb3NseSBoYXMgbm8gZWZmZWN0LlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IGVzY2FwZSBcbiAgICAgICAgQHR5cGUgYm9vbGVhblxuICAgICAgICBAc2luY2UgMS41LjBcbiAgICAgICAgQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgZXNjYXBlOiB0cnVlLFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAvL3Njb3BlIGZvciBleHRlcm5hbCBtZXRob2RzIChlLmcuIHNvdXJjZSBkZWZpbmVkIGFzIGZ1bmN0aW9uKVxuICAgICAgICAvL2ZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAgICBzY29wZTogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIC8vbmVlZCB0byByZS1kZWNsYXJlIHNob3didXR0b25zIGhlcmUgdG8gZ2V0IGl0J3MgdmFsdWUgZnJvbSBjb21tb24gY29uZmlnIChwYXNzZWQgb25seSBvcHRpb25zIGV4aXN0aW5nIGluIGRlZmF1bHRzKVxuICAgICAgICBzaG93YnV0dG9uczogdHJ1ZSBcbiAgICB9O1xuICAgIFxuICAgICQuZXh0ZW5kKCQuZm4uZWRpdGFibGV0eXBlcywge2Fic3RyYWN0aW5wdXQ6IEFic3RyYWN0SW5wdXR9KTtcbiAgICAgICAgXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5MaXN0IC0gYWJzdHJhY3QgY2xhc3MgZm9yIGlucHV0cyB0aGF0IGhhdmUgc291cmNlIG9wdGlvbiBsb2FkZWQgZnJvbSBqcyBhcnJheSBvciB2aWEgYWpheFxuXG5AY2xhc3MgbGlzdFxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuKiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIHZhciBMaXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICBcbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoTGlzdCwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpO1xuXG4gICAgJC5leHRlbmQoTGlzdC5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vblNvdXJjZVJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxpc3QoKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IHRoaXMub3B0aW9ucy5zb3VyY2VFcnJvcjtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBodG1sMnZhbHVlOiBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vY2FuJ3Qgc2V0IHZhbHVlIGJ5IHRleHRcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHZhbHVlMmh0bWw6IGZ1bmN0aW9uICh2YWx1ZSwgZWxlbWVudCwgZGlzcGxheSwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgZGlzcGxheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jdXN0b20gZGlzcGxheSBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkuY2FsbChlbGVtZW50LCB2YWx1ZSwgdGhpcy5zb3VyY2VEYXRhLCByZXNwb25zZSk7IFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZTJodG1sRmluYWwodmFsdWUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZm9yIG51bGwgdmFsdWUganVzdCBjYWxsIHN1Y2Nlc3Mgd2l0aG91dCBsb2FkaW5nIHNvdXJjZVxuICAgICAgICAgICAgaWYodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgIHN1Y2Nlc3MuY2FsbCh0aGlzKTsgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICB0aGlzLm9uU291cmNlUmVhZHkoc3VjY2VzcywgZnVuY3Rpb24gKCkgeyBkZWZlcnJlZC5yZXNvbHZlKCk7IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgICB9LCAgXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLSBhZGRpdGlvbmFsIGZ1bmN0aW9ucyAtLS0tLS0tLS0tLS1cblxuICAgICAgICBvblNvdXJjZVJlYWR5OiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIC8vcnVuIHNvdXJjZSBpZiBpdCBmdW5jdGlvblxuICAgICAgICAgICAgdmFyIHNvdXJjZTtcbiAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGlzLm9wdGlvbnMuc291cmNlLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vbm90ZTogaWYgZnVuY3Rpb24gcmV0dXJucyB0aGUgc2FtZSBzb3VyY2UgYXMgVVJMIC0gc291cmNlRGF0YSB3aWxsIGJlIHRha2VuIGZyb20gY2FoY2UgYW5kIG5vIGV4dHJhIHJlcXVlc3QgcGVyZm9ybWVkXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgYWxscmVhZHkgbG9hZGVkIGp1c3QgY2FsbCBzdWNjZXNzXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuc291cmNlQ2FjaGUgJiYgJC5pc0FycmF5KHRoaXMuc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy90cnkgcGFyc2UganNvbiBpbiBzaW5nbGUgcXVvdGVzIChmb3IgZG91YmxlIHF1b3RlcyBqcXVlcnkgZG9lcyBhdXRvbWF0aWNhbGx5KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKHNvdXJjZSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2xvYWRpbmcgZnJvbSB1cmxcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vdHJ5IHRvIGdldCBzb3VyY2VEYXRhIGZyb20gY2FjaGVcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuc291cmNlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlSUQgPSBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghJChkb2N1bWVudCkuZGF0YShjYWNoZUlEKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJChkb2N1bWVudCkuZGF0YShjYWNoZUlELCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSAkKGRvY3VtZW50KS5kYXRhKGNhY2hlSUQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIGNhY2hlZCBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZS5sb2FkaW5nID09PSBmYWxzZSAmJiBjYWNoZS5zb3VyY2VEYXRhKSB7IC8vdGFrZSBzb3VyY2UgZnJvbSBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gY2FjaGUuc291cmNlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9QcmVwZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FjaGUubG9hZGluZyA9PT0gdHJ1ZSkgeyAvL2NhY2hlIGlzIGxvYWRpbmcsIHB1dCBjYWxsYmFjayBpbiBzdGFjayB0byBiZSBjYWxsZWQgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmNhbGxiYWNrcy5wdXNoKCQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRGF0YSA9IGNhY2hlLnNvdXJjZURhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1ByZXBlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWxzbyBjb2xsZWN0aW5nIGVycm9yIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuZXJyX2NhbGxiYWNrcy5wdXNoKCQucHJveHkoZXJyb3IsIHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9ubyBjYWNoZSB5ZXQsIGFjdGl2YXRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuZXJyX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vYWpheE9wdGlvbnMgZm9yIHNvdXJjZS4gQ2FuIGJlIG92ZXJ3cml0dGVuIGJ0IG9wdGlvbnMuc291cmNlT3B0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBhamF4T3B0aW9ucyA9ICQuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdnZXQnLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6ICQucHJveHkoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gdGhpcy5tYWtlQXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZigkLmlzQXJyYXkodGhpcy5zb3VyY2VEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3RvcmUgcmVzdWx0IGluIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNvdXJjZURhdGEgPSB0aGlzLnNvdXJjZURhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcnVuIHN1Y2Nlc3MgY2FsbGJhY2tzIGZvciBvdGhlciBmaWVsZHMgd2FpdGluZyBmb3IgdGhpcyBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGNhY2hlLmNhbGxiYWNrcywgZnVuY3Rpb24gKCkgeyB0aGlzLmNhbGwoKTsgfSk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvUHJlcGVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3J1biBlcnJvciBjYWxsYmFja3MgZm9yIG90aGVyIGZpZWxkcyB3YWl0aW5nIGZvciB0aGlzIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goY2FjaGUuZXJyX2NhbGxiYWNrcywgZnVuY3Rpb24gKCkgeyB0aGlzLmNhbGwoKTsgfSk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAkLnByb3h5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcnVuIGVycm9yIGNhbGxiYWNrcyBmb3Igb3RoZXIgZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChjYWNoZS5lcnJfY2FsbGJhY2tzLCBmdW5jdGlvbiAoKSB7IHRoaXMuY2FsbCgpOyB9KTsgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnNvdXJjZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vbG9hZGluZyBzb3VyY2VEYXRhIGZyb20gc2VydmVyXG4gICAgICAgICAgICAgICAgJC5hamF4KGFqYXhPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vb3B0aW9ucyBhcyBqc29uL2FycmF5XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gdGhpcy5tYWtlQXJyYXkoc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoJC5pc0FycmF5KHRoaXMuc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1ByZXBlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcy5jYWxsKHRoaXMpOyAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRvUHJlcGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnByZXBlbmQgPT09IG51bGwgfHwgdGhpcy5vcHRpb25zLnByZXBlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZighJC5pc0FycmF5KHRoaXMucHJlcGVuZERhdGEpKSB7XG4gICAgICAgICAgICAgICAgLy9ydW4gcHJlcGVuZCBpZiBpdCBpcyBmdW5jdGlvbiAob25jZSlcbiAgICAgICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5wcmVwZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucHJlcGVuZCA9IHRoaXMub3B0aW9ucy5wcmVwZW5kLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGpzb24gaW4gc2luZ2xlIHF1b3Rlc1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wcmVwZW5kID0gJC5mbi5lZGl0YWJsZXV0aWxzLnRyeVBhcnNlSnNvbih0aGlzLm9wdGlvbnMucHJlcGVuZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IHByZXBlbmQgZnJvbSBzdHJpbmcgdG8gb2JqZWN0XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucHJlcGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnByZXBlbmQgPSB7Jyc6IHRoaXMub3B0aW9ucy5wcmVwZW5kfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5wcmVwZW5kRGF0YSA9IHRoaXMubWFrZUFycmF5KHRoaXMub3B0aW9ucy5wcmVwZW5kKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoJC5pc0FycmF5KHRoaXMucHJlcGVuZERhdGEpICYmICQuaXNBcnJheSh0aGlzLnNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gdGhpcy5wcmVwZW5kRGF0YS5jb25jYXQodGhpcy5zb3VyY2VEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgcmVuZGVycyBpbnB1dCBsaXN0XG4gICAgICAgICovXG4gICAgICAgIHJlbmRlckxpc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gdGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJ3cml0dGVuIGluIGNoaWxkIGNsYXNzXG4gICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgICAvKlxuICAgICAgICAgc2V0IGVsZW1lbnQncyBodG1sIGJ5IHZhbHVlXG4gICAgICAgICovXG4gICAgICAgIHZhbHVlMmh0bWxGaW5hbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBjbGFzc1xuICAgICAgICB9LCAgICAgICAgXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogY29udmVydCBkYXRhIHRvIGFycmF5IHN1aXRhYmxlIGZvciBzb3VyY2VEYXRhLCBlLmcuIFt7dmFsdWU6IDEsIHRleHQ6ICdhYmMnfSwgey4uLn1dXG4gICAgICAgICovXG4gICAgICAgIG1ha2VBcnJheTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvdW50LCBvYmosIHJlc3VsdCA9IFtdLCBpdGVtLCBpdGVyYXRlSXRlbTtcbiAgICAgICAgICAgIGlmKCFkYXRhIHx8IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoJC5pc0FycmF5KGRhdGEpKSB7IC8vYXJyYXlcbiAgICAgICAgICAgICAgICAvKiBcbiAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0byBpdGVyYXRlIGluc2lkZSBpdGVtIG9mIGFycmF5IGlmIGl0ZW0gaXMgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgIENhY2x1bGF0ZXMgY291bnQgb2Yga2V5cyBpbiBpdGVtIGFuZCBzdG9yZSBpbiBvYmouIFxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaXRlcmF0ZUl0ZW0gPSBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSB7dmFsdWU6IGssIHRleHQ6IHZ9O1xuICAgICAgICAgICAgICAgICAgICBpZihjb3VudCsrID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsvLyBleGl0IGZyb20gYGVhY2hgIGlmIGl0ZW0gaGFzIG1vcmUgdGhhbiBvbmUga2V5LlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBkYXRhW2ldOyBcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDA7IC8vY291bnQgb2Yga2V5cyBpbnNpZGUgaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGl0ZW0sIGl0ZXJhdGVJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FzZTogW3t2YWwxOiAndGV4dDEnfSwge3ZhbDI6ICd0ZXh0Mn0gLi4uXVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY291bnQgPT09IDEpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jYXNlOiBbe3ZhbHVlOiAxLCB0ZXh0OiAndGV4dDEnfSwge3ZhbHVlOiAyLCB0ZXh0OiAndGV4dDInfSwgLi4uXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKGNvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlZCBjaGVjayBvZiBleGlzdGFuY2U6IGl0ZW0uaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgJiYgaXRlbS5oYXNPd25Qcm9wZXJ0eSgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNoaWxkcmVuID0gdGhpcy5tYWtlQXJyYXkoaXRlbS5jaGlsZHJlbik7ICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jYXNlOiBbJ3RleHQxJywgJ3RleHQyJyAuLi5dXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7dmFsdWU6IGl0ZW0sIHRleHQ6IGl0ZW19KTsgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAgLy9jYXNlOiB7dmFsMTogJ3RleHQxJywgdmFsMjogJ3RleHQyLCAuLi59XG4gICAgICAgICAgICAgICAgJC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHt2YWx1ZTogaywgdGV4dDogdn0pO1xuICAgICAgICAgICAgICAgIH0pOyAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgb3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYoa2V5ID09PSAnc291cmNlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihrZXkgPT09ICdwcmVwZW5kJykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlcGVuZERhdGEgPSBudWxsO1xuICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICB9ICAgICAgICBcblxuICAgIH0pOyAgICAgIFxuXG4gICAgTGlzdC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgU291cmNlIGRhdGEgZm9yIGxpc3QuICBcbiAgICAgICAgSWYgKiphcnJheSoqIC0gaXQgc2hvdWxkIGJlIGluIGZvcm1hdDogYFt7dmFsdWU6IDEsIHRleHQ6IFwidGV4dDFcIn0sIHt2YWx1ZTogMiwgdGV4dDogXCJ0ZXh0MlwifSwgLi4uXWAgIFxuICAgICAgICBGb3IgY29tcGFiaWxpdHksIG9iamVjdCBmb3JtYXQgaXMgYWxzbyBzdXBwb3J0ZWQ6IGB7XCIxXCI6IFwidGV4dDFcIiwgXCIyXCI6IFwidGV4dDJcIiAuLi59YCBidXQgaXQgZG9lcyBub3QgZ3VhcmFudGVlIGVsZW1lbnRzIG9yZGVyLlxuICAgICAgICBcbiAgICAgICAgSWYgKipzdHJpbmcqKiAtIGNvbnNpZGVyZWQgYWpheCB1cmwgdG8gbG9hZCBpdGVtcy4gSW4gdGhhdCBjYXNlIHJlc3VsdHMgd2lsbCBiZSBjYWNoZWQgZm9yIGZpZWxkcyB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmQgbmFtZS4gU2VlIGFsc28gYHNvdXJjZUNhY2hlYCBvcHRpb24uXG4gICAgICAgICAgXG4gICAgICAgIElmICoqZnVuY3Rpb24qKiwgaXQgc2hvdWxkIHJldHVybiBkYXRhIGluIGZvcm1hdCBhYm92ZSAoc2luY2UgMS40LjApLlxuICAgICAgICBcbiAgICAgICAgU2luY2UgMS40LjEga2V5IGBjaGlsZHJlbmAgc3VwcG9ydGVkIHRvIHJlbmRlciBPUFRHUk9VUCAoZm9yICoqc2VsZWN0KiogaW5wdXQgb25seSkuICBcbiAgICAgICAgYFt7dGV4dDogXCJncm91cDFcIiwgY2hpbGRyZW46IFt7dmFsdWU6IDEsIHRleHQ6IFwidGV4dDFcIn0sIHt2YWx1ZTogMiwgdGV4dDogXCJ0ZXh0MlwifV19LCAuLi5dYCBcblxuXHRcdFxuICAgICAgICBAcHJvcGVydHkgc291cmNlIFxuICAgICAgICBAdHlwZSBzdHJpbmcgfCBhcnJheSB8IG9iamVjdCB8IGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHNvdXJjZTogbnVsbCwgXG4gICAgICAgIC8qKlxuICAgICAgICBEYXRhIGF1dG9tYXRpY2FsbHkgcHJlcGVuZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgZHJvcGRvd24gbGlzdC5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBwcmVwZW5kIFxuICAgICAgICBAdHlwZSBzdHJpbmcgfCBhcnJheSB8IG9iamVjdCB8IGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBwcmVwZW5kOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgIEVycm9yIG1lc3NhZ2Ugd2hlbiBsaXN0IGNhbm5vdCBiZSBsb2FkZWQgKGUuZy4gYWpheCBlcnJvcilcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBzb3VyY2VFcnJvciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IEVycm9yIHdoZW4gbG9hZGluZyBsaXN0XG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgc291cmNlRXJyb3I6ICdFcnJvciB3aGVuIGxvYWRpbmcgbGlzdCcsXG4gICAgICAgIC8qKlxuICAgICAgICBpZiA8Y29kZT50cnVlPC9jb2RlPiBhbmQgc291cmNlIGlzICoqc3RyaW5nIHVybCoqIC0gcmVzdWx0cyB3aWxsIGJlIGNhY2hlZCBmb3IgZmllbGRzIHdpdGggdGhlIHNhbWUgc291cmNlLiAgICBcbiAgICAgICAgVXNlZnVsbCBmb3IgZWRpdGFibGUgY29sdW1uIGluIGdyaWQgdG8gcHJldmVudCBleHRyYSByZXF1ZXN0cy5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBzb3VyY2VDYWNoZSBcbiAgICAgICAgQHR5cGUgYm9vbGVhblxuICAgICAgICBAZGVmYXVsdCB0cnVlXG4gICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBzb3VyY2VDYWNoZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgIEFkZGl0aW9uYWwgYWpheCBvcHRpb25zIHRvIGJlIHVzZWQgaW4gJC5hamF4KCkgd2hlbiBsb2FkaW5nIGxpc3QgZnJvbSBzZXJ2ZXIuXG4gICAgICAgIFVzZWZ1bCB0byBzZW5kIGV4dHJhIHBhcmFtZXRlcnMgKGBkYXRhYCBrZXkpIG9yIGNoYW5nZSByZXF1ZXN0IG1ldGhvZCAoYHR5cGVgIGtleSkuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgc291cmNlT3B0aW9ucyBcbiAgICAgICAgQHR5cGUgb2JqZWN0fGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQHNpbmNlIDEuNS4wXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHNvdXJjZU9wdGlvbnM6IG51bGxcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5saXN0ID0gTGlzdDsgICAgICBcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuVGV4dCBpbnB1dFxuXG5AY2xhc3MgdGV4dFxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQGZpbmFsXG5AZXhhbXBsZVxuPGEgaHJlZj1cIiNcIiBpZD1cInVzZXJuYW1lXCIgZGF0YS10eXBlPVwidGV4dFwiIGRhdGEtcGs9XCIxXCI+YXdlc29tZTwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI3VzZXJuYW1lJykuZWRpdGFibGUoe1xuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHRpdGxlOiAnRW50ZXIgdXNlcm5hbWUnXG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIHZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCd0ZXh0Jywgb3B0aW9ucywgVGV4dC5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KFRleHQsICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTtcblxuICAgICQuZXh0ZW5kKFRleHQucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMucmVuZGVyQ2xlYXIoKTtcbiAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3BsYWNlaG9sZGVyJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLiRpbnB1dC5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgJC5mbi5lZGl0YWJsZXV0aWxzLnNldEN1cnNvclBvc2l0aW9uKHRoaXMuJGlucHV0LmdldCgwKSwgdGhpcy4kaW5wdXQudmFsKCkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnRvZ2dsZUNsZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlQ2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvL3JlbmRlciBjbGVhciBidXR0b25cbiAgICAgICAgcmVuZGVyQ2xlYXI6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGVhcikge1xuICAgICAgICAgICAgICAgdGhpcy4kY2xlYXIgPSAkKCc8c3BhbiBjbGFzcz1cImVkaXRhYmxlLWNsZWFyLXhcIj48L3NwYW4+Jyk7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5hZnRlcih0aGlzLiRjbGVhcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygncGFkZGluZy1yaWdodCcsIDI0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAua2V5dXAoJC5wcm94eShmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Fycm93cywgZW50ZXIsIHRhYiwgZXRjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih+JC5pbkFycmF5KGUua2V5Q29kZSwgWzQwLDM4LDksMTMsMjddKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudG9nZ2xlQ2xlYXIoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAucGFyZW50KCkuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLmNsaWNrKCQucHJveHkodGhpcy5jbGVhciwgdGhpcykpOyAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHBvc3RyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIC8vbm93IGBjbGVhcmAgaXMgcG9zaXRpb25lZCB2aWEgY3NzXG4gICAgICAgICAgICBpZih0aGlzLiRjbGVhcikge1xuICAgICAgICAgICAgICAgIC8vY2FuIHBvc2l0aW9uIGNsZWFyIGJ1dHRvbiBvbmx5IGhlcmUsIHdoZW4gZm9ybSBpcyBzaG93biBhbmQgaGVpZ2h0IGNhbiBiZSBjYWxjdWxhdGVkXG4vLyAgICAgICAgICAgICAgICB2YXIgaCA9IHRoaXMuJGlucHV0Lm91dGVySGVpZ2h0KHRydWUpIHx8IDIwLFxuICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy4kY2xlYXIucGFyZW50KCkuaGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gKGggLSB0aGlzLiRjbGVhci5oZWlnaHQoKSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL3RoaXMuJGNsZWFyLmNzcyh7Ym90dG9tOiBkZWx0YSwgcmlnaHQ6IGRlbHRhfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAqLyBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8vc2hvdyAvIGhpZGUgY2xlYXIgYnV0dG9uXG4gICAgICAgIHRvZ2dsZUNsZWFyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZighdGhpcy4kY2xlYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLiRpbnB1dC52YWwoKS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdmlzaWJsZSA9IHRoaXMuJGNsZWFyLmlzKCc6dmlzaWJsZScpO1xuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGxlbiAmJiAhdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLnNob3coKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCFsZW4gJiYgdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLmhpZGUoKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMuJGNsZWFyLmhpZGUoKTtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQudmFsKCcnKS5mb2N1cygpO1xuICAgICAgICB9ICAgICAgICAgIFxuICAgIH0pO1xuXG4gICAgVGV4dC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbCBcbiAgICAgICAgQGRlZmF1bHQgPGlucHV0IHR5cGU9XCJ0ZXh0XCI+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0cGw6ICc8aW5wdXQgdHlwZT1cInRleHRcIj4nLFxuICAgICAgICAvKipcbiAgICAgICAgUGxhY2Vob2xkZXIgYXR0cmlidXRlIG9mIGlucHV0LiBTaG93biB3aGVuIGlucHV0IGlzIGVtcHR5LlxuXG4gICAgICAgIEBwcm9wZXJ0eSBwbGFjZWhvbGRlciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgICAgIFxuICAgICAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBXaGV0aGVyIHRvIHNob3cgYGNsZWFyYCBidXR0b24gXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgY2xlYXIgXG4gICAgICAgIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgQGRlZmF1bHQgdHJ1ZSAgICAgICAgXG4gICAgICAgICoqL1xuICAgICAgICBjbGVhcjogdHJ1ZVxuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQgPSBUZXh0O1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5UZXh0YXJlYSBpbnB1dFxuXG5AY2xhc3MgdGV4dGFyZWFcbkBleHRlbmRzIGFic3RyYWN0aW5wdXRcbkBmaW5hbFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJjb21tZW50c1wiIGRhdGEtdHlwZT1cInRleHRhcmVhXCIgZGF0YS1waz1cIjFcIj5hd2Vzb21lIGNvbW1lbnQhPC9hPlxuPHNjcmlwdD5cbiQoZnVuY3Rpb24oKXtcbiAgICAkKCcjY29tbWVudHMnKS5lZGl0YWJsZSh7XG4gICAgICAgIHVybDogJy9wb3N0JyxcbiAgICAgICAgdGl0bGU6ICdFbnRlciBjb21tZW50cycsXG4gICAgICAgIHJvd3M6IDEwXG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIHZhciBUZXh0YXJlYSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgndGV4dGFyZWEnLCBvcHRpb25zLCBUZXh0YXJlYS5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KFRleHRhcmVhLCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dCk7XG5cbiAgICAkLmV4dGVuZChUZXh0YXJlYS5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNldENsYXNzKCk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3BsYWNlaG9sZGVyJyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3Jvd3MnKTsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jdHJsICsgZW50ZXJcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmtleWRvd24oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5ICYmIGUud2hpY2ggPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnZm9ybScpLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAvL3VzaW5nIGB3aGl0ZS1zcGFjZTogcHJlLXdyYXBgIHNvbHZlcyBcXG4gIDwtLT4gQlIgY29udmVyc2lvbiB2ZXJ5IGVsZWdhbnQhXG4gICAgICAgLyogXG4gICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBodG1sID0gJycsIGxpbmVzO1xuICAgICAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsaW5lcyA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXNbaV0gPSAkKCc8ZGl2PicpLnRleHQobGluZXNbaV0pLmh0bWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHRtbCA9IGxpbmVzLmpvaW4oJzxicj4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQoZWxlbWVudCkuaHRtbChodG1sKTtcbiAgICAgICAgfSxcbiAgICAgICBcbiAgICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgaWYoIWh0bWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoU3RyaW5nLmZyb21DaGFyQ29kZSgxMCksICdnJyk7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBodG1sLnNwbGl0KC88YnJcXHMqXFwvPz4vaSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSAkKCc8ZGl2PicpLmh0bWwobGluZXNbaV0pLnRleHQoKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBuZXdsaW5lIGNoYXJhY3RlcnMgKFxcbikgdG8gYXZvaWQgdGhlbSBiZWluZyBjb252ZXJ0ZWQgYnkgdmFsdWUyaHRtbCgpIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHRodXMgYWRkaW5nIGV4dHJhIDxicj4gdGFnc1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVnZXgsICcnKTtcblxuICAgICAgICAgICAgICAgIGxpbmVzW2ldID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9LFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQucHJvdG90eXBlLmFjdGl2YXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFRleHRhcmVhLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsXG4gICAgICAgIEBkZWZhdWx0IDx0ZXh0YXJlYT48L3RleHRhcmVhPlxuICAgICAgICAqKi9cbiAgICAgICAgdHBsOic8dGV4dGFyZWE+PC90ZXh0YXJlYT4nLFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3NcbiAgICAgICAgQGRlZmF1bHQgaW5wdXQtbGFyZ2VcbiAgICAgICAgKiovXG4gICAgICAgIGlucHV0Y2xhc3M6ICdpbnB1dC1sYXJnZScsXG4gICAgICAgIC8qKlxuICAgICAgICBQbGFjZWhvbGRlciBhdHRyaWJ1dGUgb2YgaW5wdXQuIFNob3duIHdoZW4gaW5wdXQgaXMgZW1wdHkuXG5cbiAgICAgICAgQHByb3BlcnR5IHBsYWNlaG9sZGVyXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIE51bWJlciBvZiByb3dzIGluIHRleHRhcmVhXG5cbiAgICAgICAgQHByb3BlcnR5IHJvd3NcbiAgICAgICAgQHR5cGUgaW50ZWdlclxuICAgICAgICBAZGVmYXVsdCA3XG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHJvd3M6IDcgICAgICAgIFxuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHRhcmVhID0gVGV4dGFyZWE7XG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcblNlbGVjdCAoZHJvcGRvd24pXG5cbkBjbGFzcyBzZWxlY3RcbkBleHRlbmRzIGxpc3RcbkBmaW5hbFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJzdGF0dXNcIiBkYXRhLXR5cGU9XCJzZWxlY3RcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IHN0YXR1c1wiPjwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI3N0YXR1cycpLmVkaXRhYmxlKHtcbiAgICAgICAgdmFsdWU6IDIsICAgIFxuICAgICAgICBzb3VyY2U6IFtcbiAgICAgICAgICAgICAge3ZhbHVlOiAxLCB0ZXh0OiAnQWN0aXZlJ30sXG4gICAgICAgICAgICAgIHt2YWx1ZTogMiwgdGV4dDogJ0Jsb2NrZWQnfSxcbiAgICAgICAgICAgICAge3ZhbHVlOiAzLCB0ZXh0OiAnRGVsZXRlZCd9XG4gICAgICAgICAgIF1cbiAgICB9KTtcbn0pO1xuPC9zY3JpcHQ+XG4qKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgU2VsZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdzZWxlY3QnLCBvcHRpb25zLCBTZWxlY3QuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChTZWxlY3QsICQuZm4uZWRpdGFibGV0eXBlcy5saXN0KTtcblxuICAgICQuZXh0ZW5kKFNlbGVjdC5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyTGlzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5lbXB0eSgpO1xuXG4gICAgICAgICAgICB2YXIgZmlsbEl0ZW1zID0gZnVuY3Rpb24oJGVsLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgICAgICAgICAgaWYoJC5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhdGFbaV0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmxhYmVsID0gZGF0YVtpXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRlbC5hcHBlbmQoZmlsbEl0ZW1zKCQoJzxvcHRncm91cD4nLCBhdHRyKSwgZGF0YVtpXS5jaGlsZHJlbikpOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci52YWx1ZSA9IGRhdGFbaV0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGF0YVtpXS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGVsLmFwcGVuZCgkKCc8b3B0aW9uPicsIGF0dHIpLnRleHQoZGF0YVtpXS50ZXh0KSk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkZWw7XG4gICAgICAgICAgICB9OyAgICAgICAgXG5cbiAgICAgICAgICAgIGZpbGxJdGVtcyh0aGlzLiRpbnB1dCwgdGhpcy5zb3VyY2VEYXRhKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2VudGVyIHN1Ym1pdFxuICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2tleWRvd24uZWRpdGFibGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAxMykge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTsgICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICBcbiAgICAgICAgdmFsdWUyaHRtbEZpbmFsOiBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSAnJywgXG4gICAgICAgICAgICAgICAgaXRlbXMgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCB0aGlzLnNvdXJjZURhdGEpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGl0ZW1zWzBdLnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vJChlbGVtZW50KS50ZXh0KHRleHQpO1xuICAgICAgICAgICAgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQucHJvdG90eXBlLnZhbHVlMmh0bWwuY2FsbCh0aGlzLCB0ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQub2ZmKCdrZXlkb3duLmVkaXRhYmxlJykub24oJ2NoYW5nZS5lZGl0YWJsZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pOyAgICAgIFxuXG4gICAgU2VsZWN0LmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5saXN0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICBAZGVmYXVsdCA8c2VsZWN0Pjwvc2VsZWN0PlxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdHBsOic8c2VsZWN0Pjwvc2VsZWN0PidcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5zZWxlY3QgPSBTZWxlY3Q7ICAgICAgXG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcbkxpc3Qgb2YgY2hlY2tib3hlcy4gXG5JbnRlcm5hbGx5IHZhbHVlIHN0b3JlZCBhcyBqYXZhc2NyaXB0IGFycmF5IG9mIHZhbHVlcy5cblxuQGNsYXNzIGNoZWNrbGlzdFxuQGV4dGVuZHMgbGlzdFxuQGZpbmFsXG5AZXhhbXBsZVxuPGEgaHJlZj1cIiNcIiBpZD1cIm9wdGlvbnNcIiBkYXRhLXR5cGU9XCJjaGVja2xpc3RcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IG9wdGlvbnNcIj48L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNvcHRpb25zJykuZWRpdGFibGUoe1xuICAgICAgICB2YWx1ZTogWzIsIDNdLCAgICBcbiAgICAgICAgc291cmNlOiBbXG4gICAgICAgICAgICAgIHt2YWx1ZTogMSwgdGV4dDogJ29wdGlvbjEnfSxcbiAgICAgICAgICAgICAge3ZhbHVlOiAyLCB0ZXh0OiAnb3B0aW9uMid9LFxuICAgICAgICAgICAgICB7dmFsdWU6IDMsIHRleHQ6ICdvcHRpb24zJ31cbiAgICAgICAgICAgXVxuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIHZhciBDaGVja2xpc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2NoZWNrbGlzdCcsIG9wdGlvbnMsIENoZWNrbGlzdC5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KENoZWNrbGlzdCwgJC5mbi5lZGl0YWJsZXR5cGVzLmxpc3QpO1xuXG4gICAgJC5leHRlbmQoQ2hlY2tsaXN0LnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXJMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkbGFiZWwsICRkaXY7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJHRwbC5lbXB0eSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZighJC5pc0FycmF5KHRoaXMuc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuc291cmNlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICRsYWJlbCA9ICQoJzxsYWJlbD4nKS5hcHBlbmQoJCgnPGlucHV0PicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNvdXJjZURhdGFbaV0udmFsdWUgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8c3Bhbj4nKS50ZXh0KCcgJyt0aGlzLnNvdXJjZURhdGFbaV0udGV4dCkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICQoJzxkaXY+JykuYXBwZW5kKCRsYWJlbCkuYXBwZW5kVG8odGhpcy4kdHBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kaW5wdXQgPSB0aGlzLiR0cGwuZmluZCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJyk7XG4gICAgICAgICAgICB0aGlzLnNldENsYXNzKCk7XG4gICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgdmFsdWUyc3RyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICByZXR1cm4gJC5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNvcnQoKS5qb2luKCQudHJpbSh0aGlzLm9wdGlvbnMuc2VwYXJhdG9yKSkgOiAnJztcbiAgICAgICB9LCAgXG4gICAgICAgXG4gICAgICAgLy9wYXJzZSBzZXBhcmF0ZWQgc3RyaW5nXG4gICAgICAgIHN0cjJ2YWx1ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgIHZhciByZWcsIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgcmVnID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyskLnRyaW0odGhpcy5vcHRpb25zLnNlcGFyYXRvcikrJ1xcXFxzKicpO1xuICAgICAgICAgICAgICAgdmFsdWUgPSBzdHIuc3BsaXQocmVnKTtcbiAgICAgICAgICAgfSBlbHNlIGlmKCQuaXNBcnJheShzdHIpKSB7XG4gICAgICAgICAgICAgICB2YWx1ZSA9IHN0cjsgXG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICB2YWx1ZSA9IFtzdHJdO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSwgICAgICAgXG4gICAgICAgXG4gICAgICAgLy9zZXQgY2hlY2tlZCBvbiByZXF1aXJlZCBjaGVja2JveGVzXG4gICAgICAgdmFsdWUyaW5wdXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xuICAgICAgICAgICAgaWYoJC5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LmVhY2goZnVuY3Rpb24oaSwgZWwpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgJGVsID0gJChlbCk7XG4gICAgICAgICAgICAgICAgICAgLy8gY2Fubm90IHVzZSAkLmluQXJyYXkgYXMgaXQgcGVyZm9ybXMgc3RyaWN0IGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICAgICAkLmVhY2godmFsdWUsIGZ1bmN0aW9uKGosIHZhbCl7XG4gICAgICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IHRydWUqL1xuICAgICAgICAgICAgICAgICAgICAgICBpZigkZWwudmFsKCkgPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IGZhbHNlKi8gICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICRlbC5wcm9wKCdjaGVja2VkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgIH0pOyBcbiAgICAgICAgICAgIH0gIFxuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgIGlucHV0MnZhbHVlOiBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgIHZhciBjaGVja2VkID0gW107XG4gICAgICAgICAgIHRoaXMuJGlucHV0LmZpbHRlcignOmNoZWNrZWQnKS5lYWNoKGZ1bmN0aW9uKGksIGVsKSB7XG4gICAgICAgICAgICAgICBjaGVja2VkLnB1c2goJChlbCkudmFsKCkpO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgICAgcmV0dXJuIGNoZWNrZWQ7XG4gICAgICAgfSwgICAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAvL2NvbGxlY3QgdGV4dCBvZiBjaGVja2VkIGJveGVzXG4gICAgICAgIHZhbHVlMmh0bWxGaW5hbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgdmFyIGh0bWwgPSBbXSxcbiAgICAgICAgICAgICAgIGNoZWNrZWQgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCB0aGlzLnNvdXJjZURhdGEpLFxuICAgICAgICAgICAgICAgZXNjYXBlID0gdGhpcy5vcHRpb25zLmVzY2FwZTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICBpZihjaGVja2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgJC5lYWNoKGNoZWNrZWQsIGZ1bmN0aW9uKGksIHYpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGVzY2FwZSA/ICQuZm4uZWRpdGFibGV1dGlscy5lc2NhcGUodi50ZXh0KSA6IHYudGV4dDsgXG4gICAgICAgICAgICAgICAgICAgaHRtbC5wdXNoKHRleHQpOyBcbiAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgJChlbGVtZW50KS5odG1sKGh0bWwuam9pbignPGJyPicpKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICQoZWxlbWVudCkuZW1wdHkoKTsgXG4gICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICBhdXRvc3VibWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2tleWRvd24nLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAxMykge1xuICAgICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnZm9ybScpLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgfSk7ICAgICAgXG5cbiAgICBDaGVja2xpc3QuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmxpc3QuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEBkZWZhdWx0IDxkaXY+PC9kaXY+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0cGw6JzxkaXYgY2xhc3M9XCJlZGl0YWJsZS1jaGVja2xpc3RcIj48L2Rpdj4nLFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgaW5wdXRjbGFzczogbnVsbCwgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFNlcGFyYXRvciBvZiB2YWx1ZXMgd2hlbiByZWFkaW5nIGZyb20gYGRhdGEtdmFsdWVgIGF0dHJpYnV0ZVxuXG4gICAgICAgIEBwcm9wZXJ0eSBzZXBhcmF0b3IgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAnLCdcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHNlcGFyYXRvcjogJywnXG4gICAgfSk7XG5cbiAgICAkLmZuLmVkaXRhYmxldHlwZXMuY2hlY2tsaXN0ID0gQ2hlY2tsaXN0OyAgICAgIFxuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5IVE1MNSBpbnB1dCB0eXBlcy5cbkZvbGxvd2luZyB0eXBlcyBhcmUgc3VwcG9ydGVkOlxuXG4qIHBhc3N3b3JkXG4qIGVtYWlsXG4qIHVybFxuKiB0ZWxcbiogbnVtYmVyXG4qIHJhbmdlXG4qIHRpbWVcblxuTGVhcm4gbW9yZSBhYm91dCBodG1sNSBpbnB1dHM6ICBcbmh0dHA6Ly93d3cudzMub3JnL3dpa2kvSFRNTDVfZm9ybV9hZGRpdGlvbnMgIFxuVG8gY2hlY2sgYnJvd3NlciBjb21wYXRpYmlsaXR5IHBsZWFzZSBzZWU6ICBcbmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9FbGVtZW50L0lucHV0XG4gICAgICAgICAgICBcbkBjbGFzcyBodG1sNXR5cGVzIFxuQGV4dGVuZHMgdGV4dFxuQGZpbmFsXG5Ac2luY2UgMS4zLjBcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwiZW1haWxcIiBkYXRhLXR5cGU9XCJlbWFpbFwiIGRhdGEtcGs9XCIxXCI+YWRtaW5AZXhhbXBsZS5jb208L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNlbWFpbCcpLmVkaXRhYmxlKHtcbiAgICAgICAgdXJsOiAnL3Bvc3QnLFxuICAgICAgICB0aXRsZTogJ0VudGVyIGVtYWlsJ1xuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuXG4vKipcbkBwcm9wZXJ0eSB0cGwgXG5AZGVmYXVsdCBkZXBlbmRzIG9uIHR5cGVcbioqLyBcblxuLypcblBhc3N3b3JkXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIHZhciBQYXNzd29yZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgncGFzc3dvcmQnLCBvcHRpb25zLCBQYXNzd29yZC5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChQYXNzd29yZCwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQpO1xuICAgICQuZXh0ZW5kKFBhc3N3b3JkLnByb3RvdHlwZSwge1xuICAgICAgIC8vZG8gbm90IGRpc3BsYXkgcGFzc3dvcmQsIHNob3cgJ1toaWRkZW5dJyBpbnN0ZWFkXG4gICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICAgICAgICQoZWxlbWVudCkudGV4dCgnW2hpZGRlbl0nKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICQoZWxlbWVudCkuZW1wdHkoKTsgXG4gICAgICAgICAgIH1cbiAgICAgICB9LFxuICAgICAgIC8vYXMgcGFzc3dvcmQgbm90IGRpc3BsYXllZCwgc2hvdWxkIG5vdCBzZXQgdmFsdWUgYnkgaHRtbFxuICAgICAgIGh0bWwydmFsdWU6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgfSAgICAgICBcbiAgICB9KTsgICAgXG4gICAgUGFzc3dvcmQuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiPidcbiAgICB9KTtcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMucGFzc3dvcmQgPSBQYXNzd29yZDtcbn0od2luZG93LmpRdWVyeSkpO1xuXG5cbi8qXG5FbWFpbFxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgRW1haWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2VtYWlsJywgb3B0aW9ucywgRW1haWwuZGVmYXVsdHMpO1xuICAgIH07XG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoRW1haWwsICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0KTtcbiAgICBFbWFpbC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMudGV4dC5kZWZhdWx0cywge1xuICAgICAgICB0cGw6ICc8aW5wdXQgdHlwZT1cImVtYWlsXCI+J1xuICAgIH0pO1xuICAgICQuZm4uZWRpdGFibGV0eXBlcy5lbWFpbCA9IEVtYWlsO1xufSh3aW5kb3cualF1ZXJ5KSk7XG5cblxuLypcblVybFxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgVXJsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCd1cmwnLCBvcHRpb25zLCBVcmwuZGVmYXVsdHMpO1xuICAgIH07XG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoVXJsLCAkLmZuLmVkaXRhYmxldHlwZXMudGV4dCk7XG4gICAgVXJsLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0LmRlZmF1bHRzLCB7XG4gICAgICAgIHRwbDogJzxpbnB1dCB0eXBlPVwidXJsXCI+J1xuICAgIH0pO1xuICAgICQuZm4uZWRpdGFibGV0eXBlcy51cmwgPSBVcmw7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuXG4vKlxuVGVsXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIHZhciBUZWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ3RlbCcsIG9wdGlvbnMsIFRlbC5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChUZWwsICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0KTtcbiAgICBUZWwuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJ0ZWxcIj4nXG4gICAgfSk7XG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRlbCA9IFRlbDtcbn0od2luZG93LmpRdWVyeSkpO1xuXG5cbi8qXG5OdW1iZXJcbiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG4gICAgXG4gICAgdmFyIE51bWJlcklucHV0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdudW1iZXInLCBvcHRpb25zLCBOdW1iZXJJbnB1dC5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChOdW1iZXJJbnB1dCwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQpO1xuICAgICQuZXh0ZW5kKE51bWJlcklucHV0LnByb3RvdHlwZSwge1xuICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBOdW1iZXJJbnB1dC5zdXBlcmNsYXNzLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdtaW4nKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbWF4Jyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3N0ZXAnKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLiRjbGVhcikge1xuICAgICAgICAgICAgICAgIC8vaW5jcmVhc2UgcmlnaHQgZmZzZXQgIGZvciB1cC9kb3duIGFycm93c1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLmNzcyh7cmlnaHQ6IDI0fSk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAvL2NhbiBwb3NpdGlvbiBjbGVhciBidXR0b24gb25seSBoZXJlLCB3aGVuIGZvcm0gaXMgc2hvd24gYW5kIGhlaWdodCBjYW4gYmUgY2FsY3VsYXRlZFxuICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy4kaW5wdXQub3V0ZXJIZWlnaHQodHJ1ZSkgfHwgMjAsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gKGggLSB0aGlzLiRjbGVhci5oZWlnaHQoKSkgLyAyO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vYWRkIDEycHggdG8gb2Zmc2V0IHJpZ2h0IGZvciB1cC9kb3duIGFycm93cyAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiRjbGVhci5jc3Moe3RvcDogZGVsdGEsIHJpZ2h0OiBkZWx0YSArIDE2fSk7XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0gICAgICAgIFxuICAgIH0pOyAgICAgXG4gICAgTnVtYmVySW5wdXQuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJudW1iZXJcIj4nLFxuICAgICAgICBpbnB1dGNsYXNzOiAnaW5wdXQtbWluaScsXG4gICAgICAgIG1pbjogbnVsbCxcbiAgICAgICAgbWF4OiBudWxsLFxuICAgICAgICBzdGVwOiBudWxsXG4gICAgfSk7XG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLm51bWJlciA9IE51bWJlcklucHV0O1xufSh3aW5kb3cualF1ZXJ5KSk7XG5cblxuLypcblJhbmdlIChpbmhlcml0IGZyb20gbnVtYmVyKVxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgUmFuZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ3JhbmdlJywgb3B0aW9ucywgUmFuZ2UuZGVmYXVsdHMpO1xuICAgIH07XG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoUmFuZ2UsICQuZm4uZWRpdGFibGV0eXBlcy5udW1iZXIpO1xuICAgICQuZXh0ZW5kKFJhbmdlLnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0ID0gdGhpcy4kdHBsLmZpbHRlcignaW5wdXQnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdtaW4nKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbWF4Jyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3N0ZXAnKTsgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vbignaW5wdXQnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICQodGhpcykuc2libGluZ3MoJ291dHB1dCcpLnRleHQoJCh0aGlzKS52YWwoKSk7IFxuICAgICAgICAgICAgfSk7ICBcbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfSAgICAgICAgIFxuICAgIH0pO1xuICAgIFJhbmdlLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5udW1iZXIuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJyYW5nZVwiPjxvdXRwdXQgc3R5bGU9XCJ3aWR0aDogMzBweDsgZGlzcGxheTogaW5saW5lLWJsb2NrXCI+PC9vdXRwdXQ+JyxcbiAgICAgICAgaW5wdXRjbGFzczogJ2lucHV0LW1lZGl1bSdcbiAgICB9KTtcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMucmFuZ2UgPSBSYW5nZTtcbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKlxuVGltZVxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcblxuICAgIHZhciBUaW1lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCd0aW1lJywgb3B0aW9ucywgVGltZS5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAvL2luaGVyaXQgZnJvbSBhYnN0cmFjdCwgYXMgaW5oZXJpdGFuY2UgZnJvbSB0ZXh0IGdpdmVzIHNlbGVjdGlvbiBlcnJvci5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChUaW1lLCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dCk7XG4gICAgJC5leHRlbmQoVGltZS5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICB9ICAgICAgICBcbiAgICB9KTtcbiAgICBUaW1lLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIHRwbDogJzxpbnB1dCB0eXBlPVwidGltZVwiPidcbiAgICB9KTtcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMudGltZSA9IFRpbWU7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5TZWxlY3QyIGlucHV0LiBCYXNlZCBvbiBhbWF6aW5nIHdvcmsgb2YgSWdvciBWYXluYmVyZyBodHRwczovL2dpdGh1Yi5jb20vaXZheW5iZXJnL3NlbGVjdDIuICBcblBsZWFzZSBzZWUgW29yaWdpbmFsIHNlbGVjdDIgZG9jc10oaHR0cDovL2l2YXluYmVyZy5naXRodWIuY29tL3NlbGVjdDIpIGZvciBkZXRhaWxlZCBkZXNjcmlwdGlvbiBhbmQgb3B0aW9ucy4gIFxuIFxuWW91IHNob3VsZCBtYW51YWxseSBkb3dubG9hZCBhbmQgaW5jbHVkZSBzZWxlY3QyIGRpc3RyaWJ1dGl2ZTogIFxuXG4gICAgPGxpbmsgaHJlZj1cInNlbGVjdDIvc2VsZWN0Mi5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCI+PC9saW5rPiAgXG4gICAgPHNjcmlwdCBzcmM9XCJzZWxlY3QyL3NlbGVjdDIuanNcIj48L3NjcmlwdD4gIFxuICAgIFxuVG8gbWFrZSBpdCAqKmJvb3RzdHJhcC1zdHlsZWQqKiB5b3UgY2FuIHVzZSBjc3MgZnJvbSBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL3QwbS9zZWxlY3QyLWJvb3RzdHJhcC1jc3MpOiBcblxuICAgIDxsaW5rIGhyZWY9XCJzZWxlY3QyLWJvb3RzdHJhcC5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCI+PC9saW5rPiAgICBcbiAgICBcbioqTm90ZToqKiBjdXJyZW50bHkgYGF1dG90ZXh0YCBmZWF0dXJlIGRvZXMgbm90IHdvcmsgZm9yIHNlbGVjdDIgd2l0aCBgYWpheGAgcmVtb3RlIHNvdXJjZS4gICAgXG5Zb3UgbmVlZCBpbml0aWFsbHkgcHV0IGJvdGggYGRhdGEtdmFsdWVgIGFuZCBlbGVtZW50J3MgdGV4dCB5b3VzZWxmOiAgICBcblxuICAgIDxhIGhyZWY9XCIjXCIgZGF0YS10eXBlPVwic2VsZWN0MlwiIGRhdGEtdmFsdWU9XCIxXCI+VGV4dDE8L2E+XG4gICAgXG4gICAgXG5AY2xhc3Mgc2VsZWN0MlxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQHNpbmNlIDEuNC4xXG5AZmluYWxcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwiY291bnRyeVwiIGRhdGEtdHlwZT1cInNlbGVjdDJcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdmFsdWU9XCJydVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IGNvdW50cnlcIj48L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgIC8vbG9jYWwgc291cmNlXG4gICAgJCgnI2NvdW50cnknKS5lZGl0YWJsZSh7XG4gICAgICAgIHNvdXJjZTogW1xuICAgICAgICAgICAgICB7aWQ6ICdnYicsIHRleHQ6ICdHcmVhdCBCcml0YWluJ30sXG4gICAgICAgICAgICAgIHtpZDogJ3VzJywgdGV4dDogJ1VuaXRlZCBTdGF0ZXMnfSxcbiAgICAgICAgICAgICAge2lkOiAncnUnLCB0ZXh0OiAnUnVzc2lhJ31cbiAgICAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0Mjoge1xuICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy9yZW1vdGUgc291cmNlIChzaW1wbGUpXG4gICAgJCgnI2NvdW50cnknKS5lZGl0YWJsZSh7XG4gICAgICAgIHNvdXJjZTogJy9nZXRDb3VudHJpZXMnLFxuICAgICAgICBzZWxlY3QyOiB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogJ1NlbGVjdCBDb3VudHJ5JyxcbiAgICAgICAgICAgIG1pbmltdW1JbnB1dExlbmd0aDogMVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy9yZW1vdGUgc291cmNlIChhZHZhbmNlZClcbiAgICAkKCcjY291bnRyeScpLmVkaXRhYmxlKHtcbiAgICAgICAgc2VsZWN0Mjoge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdTZWxlY3QgQ291bnRyeScsXG4gICAgICAgICAgICBhbGxvd0NsZWFyOiB0cnVlLFxuICAgICAgICAgICAgbWluaW11bUlucHV0TGVuZ3RoOiAzLFxuICAgICAgICAgICAgaWQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uQ291bnRyeUlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFqYXg6IHtcbiAgICAgICAgICAgICAgICB1cmw6ICcvZ2V0Q291bnRyaWVzJyxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uICh0ZXJtLCBwYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHF1ZXJ5OiB0ZXJtIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBmdW5jdGlvbiAoZGF0YSwgcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHRzOiBkYXRhIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm1hdFJlc3VsdDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5Db3VudHJ5TmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uQ291bnRyeU5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5pdFNlbGVjdGlvbjogZnVuY3Rpb24gKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQuZ2V0KCcvZ2V0Q291bnRyeUJ5SWQnLCB7IHF1ZXJ5OiBlbGVtZW50LnZhbCgpIH0sIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSAgXG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG4gICAgXG4gICAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdzZWxlY3QyJywgb3B0aW9ucywgQ29uc3RydWN0b3IuZGVmYXVsdHMpO1xuXG4gICAgICAgIG9wdGlvbnMuc2VsZWN0MiA9IG9wdGlvbnMuc2VsZWN0MiB8fCB7fTtcblxuICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgLy9wbGFjZWhvbGRlclxuICAgICAgICBpZihvcHRpb25zLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIucGxhY2Vob2xkZXIgPSBvcHRpb25zLnBsYWNlaG9sZGVyO1xuICAgICAgICB9XG4gICAgICAgXG4gICAgICAgIC8vaWYgbm90IGB0YWdzYCBtb2RlLCB1c2Ugc291cmNlXG4gICAgICAgIGlmKCFvcHRpb25zLnNlbGVjdDIudGFncyAmJiBvcHRpb25zLnNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlO1xuICAgICAgICAgICAgLy9pZiBzb3VyY2UgaXMgZnVuY3Rpb24sIGNhbGwgaXQgKG9uY2UhKVxuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihvcHRpb25zLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZS5jYWxsKG9wdGlvbnMuc2NvcGUpO1xuICAgICAgICAgICAgfSAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIuYWpheCA9IG9wdGlvbnMuc2VsZWN0Mi5hamF4IHx8IHt9O1xuICAgICAgICAgICAgICAgIC8vc29tZSBkZWZhdWx0IGFqYXggcGFyYW1zXG4gICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuc2VsZWN0Mi5hamF4LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZWxlY3QyLmFqYXguZGF0YSA9IGZ1bmN0aW9uKHRlcm0pIHtyZXR1cm4geyBxdWVyeTp0ZXJtIH07fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuc2VsZWN0Mi5hamF4LnJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZWxlY3QyLmFqYXgucmVzdWx0cyA9IGZ1bmN0aW9uKGRhdGEpIHsgcmV0dXJuIHtyZXN1bHRzOmRhdGEgfTt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIuYWpheC51cmwgPSBzb3VyY2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9ybWF0IGFuZCBjb252ZXJ0IHgtZWRpdGFibGUgZm9ybWF0IHRvIHNlbGVjdDIgZm9ybWF0IChpZiBuZWVkZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gdGhpcy5jb252ZXJ0U291cmNlKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZWxlY3QyLmRhdGEgPSB0aGlzLnNvdXJjZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG5cbiAgICAgICAgLy9vdmVycmlkaW5nIG9iamVjdHMgaW4gY29uZmlnIChhcyBieSBkZWZhdWx0IGpRdWVyeSBleHRlbmQoKSBpcyBub3QgcmVjdXJzaXZlKVxuICAgICAgICB0aGlzLm9wdGlvbnMuc2VsZWN0MiA9ICQuZXh0ZW5kKHt9LCBDb25zdHJ1Y3Rvci5kZWZhdWx0cy5zZWxlY3QyLCBvcHRpb25zLnNlbGVjdDIpO1xuXG4gICAgICAgIC8vZGV0ZWN0IHdoZXRoZXIgaXQgaXMgbXVsdGktdmFsdWVkXG4gICAgICAgIHRoaXMuaXNNdWx0aXBsZSA9IHRoaXMub3B0aW9ucy5zZWxlY3QyLnRhZ3MgfHwgdGhpcy5vcHRpb25zLnNlbGVjdDIubXVsdGlwbGU7XG4gICAgICAgIHRoaXMuaXNSZW1vdGUgPSAoJ2FqYXgnIGluIHRoaXMub3B0aW9ucy5zZWxlY3QyKTtcblxuICAgICAgICAvL3N0b3JlIGZ1bmN0aW9uIHJldHVybmluZyBJRCBvZiBpdGVtXG4gICAgICAgIC8vc2hvdWxkIGJlIGhlcmUgYXMgdXNlZCBpbmF1dG90ZXh0IGZvciBsb2NhbCBzb3VyY2VcbiAgICAgICAgdGhpcy5pZEZ1bmMgPSB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5pZDtcbiAgICAgICAgaWYgKHR5cGVvZih0aGlzLmlkRnVuYykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGlkS2V5ID0gdGhpcy5pZEZ1bmMgfHwgJ2lkJztcbiAgICAgICAgICAgIHRoaXMuaWRGdW5jID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGVbaWRLZXldOyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9zdG9yZSBmdW5jdGlvbiB0aGF0IHJlbmRlcnMgdGV4dCBpbiBzZWxlY3QyXG4gICAgICAgIHRoaXMuZm9ybWF0U2VsZWN0aW9uID0gdGhpcy5vcHRpb25zLnNlbGVjdDIuZm9ybWF0U2VsZWN0aW9uO1xuICAgICAgICBpZiAodHlwZW9mKHRoaXMuZm9ybWF0U2VsZWN0aW9uKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRleHQ7IH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoQ29uc3RydWN0b3IsICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTtcblxuICAgICQuZXh0ZW5kKENvbnN0cnVjdG9yLnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuXG4gICAgICAgICAgICAvL2NhbiBub3QgYXBwbHkgc2VsZWN0MiBoZXJlIGFzIGl0IGNhbGxzIGluaXRTZWxlY3Rpb24gXG4gICAgICAgICAgICAvL292ZXIgaW5wdXQgdGhhdCBkb2VzIG5vdCBoYXZlIGNvcnJlY3QgdmFsdWUgeWV0LlxuICAgICAgICAgICAgLy9hcHBseSBzZWxlY3QyIG9ubHkgaW4gdmFsdWUyaW5wdXRcbiAgICAgICAgICAgIC8vdGhpcy4kaW5wdXQuc2VsZWN0Mih0aGlzLm9wdGlvbnMuc2VsZWN0Mik7XG5cbiAgICAgICAgICAgIC8vd2hlbiBkYXRhIGlzIGxvYWRlZCB2aWEgYWpheCwgd2UgbmVlZCB0byBrbm93IHdoZW4gaXQncyBkb25lIHRvIHBvcHVsYXRlIGxpc3REYXRhXG4gICAgICAgICAgICBpZih0aGlzLmlzUmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgLy9saXN0ZW4gdG8gbG9hZGVkIGV2ZW50IHRvIHBvcHVsYXRlIGRhdGFcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5vbignc2VsZWN0Mi1sb2FkZWQnLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gZS5pdGVtcy5yZXN1bHRzO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy90cmlnZ2VyIHJlc2l6ZSBvZiBlZGl0YWJsZWZvcm0gdG8gcmUtcG9zaXRpb24gY29udGFpbmVyIGluIG11bHRpLXZhbHVlZCBtb2RlXG4gICAgICAgICAgICBpZih0aGlzLmlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5wYXJlbnQoKS50cmlnZ2VySGFuZGxlcigncmVzaXplJyk7XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICB9LFxuXG4gICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgdmFyIHRleHQgPSAnJywgZGF0YSxcbiAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5zZWxlY3QyLnRhZ3MpIHsgLy9pbiB0YWdzIG1vZGUganVzdCBhc3NpZ24gdmFsdWVcbiAgICAgICAgICAgICAgZGF0YSA9IHZhbHVlOyBcbiAgICAgICAgICAgICAgLy9kYXRhID0gJC5mbi5lZGl0YWJsZXV0aWxzLml0ZW1zQnlWYWx1ZSh2YWx1ZSwgdGhpcy5vcHRpb25zLnNlbGVjdDIudGFncywgdGhpcy5pZEZ1bmMpO1xuICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5zb3VyY2VEYXRhKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCB0aGlzLnNvdXJjZURhdGEsIHRoaXMuaWRGdW5jKTsgXG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vY2FuIG5vdCBnZXQgbGlzdCBvZiBwb3NzaWJsZSB2YWx1ZXMgXG4gICAgICAgICAgICAgIC8vKGUuZy4gYXV0b3RleHQgZm9yIHNlbGVjdDIgd2l0aCBhamF4IHNvdXJjZSlcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vZGF0YSBtYXkgYmUgYXJyYXkgKHdoZW4gbXVsdGlwbGUgdmFsdWVzIGFsbG93ZWQpXG4gICAgICAgICAgIGlmKCQuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgLy9jb2xsZWN0IHNlbGVjdGVkIGRhdGEgYW5kIHNob3cgd2l0aCBzZXBhcmF0b3JcbiAgICAgICAgICAgICAgIHRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICQuZWFjaChkYXRhLCBmdW5jdGlvbihrLCB2KXtcbiAgICAgICAgICAgICAgICAgICB0ZXh0LnB1c2godiAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgPyB0aGF0LmZvcm1hdFNlbGVjdGlvbih2KSA6IHYpO1xuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgIH0gZWxzZSBpZihkYXRhKSB7XG4gICAgICAgICAgICAgICB0ZXh0ID0gdGhhdC5mb3JtYXRTZWxlY3Rpb24oZGF0YSk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB0ZXh0ID0gJC5pc0FycmF5KHRleHQpID8gdGV4dC5qb2luKHRoaXMub3B0aW9ucy52aWV3c2VwYXJhdG9yKSA6IHRleHQ7XG5cbiAgICAgICAgICAgLy8kKGVsZW1lbnQpLnRleHQodGV4dCk7XG4gICAgICAgICAgIENvbnN0cnVjdG9yLnN1cGVyY2xhc3MudmFsdWUyaHRtbC5jYWxsKHRoaXMsIHRleHQsIGVsZW1lbnQpOyBcbiAgICAgICB9LFxuXG4gICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNlbGVjdDIudGFncyA/IHRoaXMuc3RyMnZhbHVlKGh0bWwsIHRoaXMub3B0aW9ucy52aWV3c2VwYXJhdG9yKSA6IG51bGw7XG4gICAgICAgfSxcblxuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAvLyBpZiB2YWx1ZSBhcnJheSA9PiBqb2luIGl0IGFueXdheVxuICAgICAgICAgICBpZigkLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuam9pbih0aGlzLmdldFNlcGFyYXRvcigpKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vZm9yIHJlbW90ZSBzb3VyY2UganVzdCBzZXQgdmFsdWUsIHRleHQgaXMgdXBkYXRlZCBieSBpbml0U2VsZWN0aW9uXG4gICAgICAgICAgIGlmKCF0aGlzLiRpbnB1dC5kYXRhKCdzZWxlY3QyJykpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LnZhbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zZWxlY3QyKHRoaXMub3B0aW9ucy5zZWxlY3QyKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIC8vc2Vjb25kIGFyZ3VtZW50IG5lZWRlZCB0byBzZXBhcmF0ZSBpbml0aWFsIGNoYW5nZSBmcm9tIHVzZXIncyBjbGljayAoZm9yIGF1dG9zdWJtaXQpICAgXG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwodmFsdWUpLnRyaWdnZXIoJ2NoYW5nZScsIHRydWUpOyBcblxuICAgICAgICAgICAgICAgLy9VbmNhdWdodCBFcnJvcjogY2Fubm90IGNhbGwgdmFsKCkgaWYgaW5pdFNlbGVjdGlvbigpIGlzIG5vdCBkZWZpbmVkXG4gICAgICAgICAgICAgICAvL3RoaXMuJGlucHV0LnNlbGVjdDIoJ3ZhbCcsIHZhbHVlKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vIGlmIGRlZmluZWQgcmVtb3RlIHNvdXJjZSBBTkQgbm8gbXVsdGlwbGUgbW9kZSBBTkQgbm8gdXNlcidzIGluaXRTZWxlY3Rpb24gcHJvdmlkZWQgLS0+IFxuICAgICAgICAgICAvLyB3ZSBzaG91bGQgc29tZWhvdyBnZXQgdGV4dCBmb3IgcHJvdmlkZWQgaWQuXG4gICAgICAgICAgIC8vIFRoZSBzb2x1dGlvbiBpcyB0byB1c2UgZWxlbWVudCdzIHRleHQgYXMgdGV4dCBmb3IgdGhhdCBpZCAoZXhjbHVkZSBlbXB0eSlcbiAgICAgICAgICAgaWYodGhpcy5pc1JlbW90ZSAmJiAhdGhpcy5pc011bHRpcGxlICYmICF0aGlzLm9wdGlvbnMuc2VsZWN0Mi5pbml0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAvLyBjdXN0b21JZCBhbmQgY3VzdG9tVGV4dCBhcmUgbWV0aG9kcyB0byBleHRyYWN0IGBpZGAgYW5kIGB0ZXh0YCBmcm9tIGRhdGEgb2JqZWN0XG4gICAgICAgICAgICAgICAvLyB3ZSBjYW4gdXNlIHRoaXMgd29ya2Fyb3VuZCBvbmx5IGlmIHVzZXIgZGlkIG5vdCBkZWZpbmUgdGhlc2UgbWV0aG9kc1xuICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGNhbnQgY29uc3RydWN0IGRhdGEgb2JqZWN0XG4gICAgICAgICAgICAgICB2YXIgY3VzdG9tSWQgPSB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5pZCxcbiAgICAgICAgICAgICAgICAgICBjdXN0b21UZXh0ID0gdGhpcy5vcHRpb25zLnNlbGVjdDIuZm9ybWF0U2VsZWN0aW9uO1xuXG4gICAgICAgICAgICAgICBpZighY3VzdG9tSWQgJiYgIWN1c3RvbVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgJGVsID0gJCh0aGlzLm9wdGlvbnMuc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgIGlmICghJGVsLmRhdGEoJ2VkaXRhYmxlJykuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtpZDogdmFsdWUsIHRleHQ6ICRlbC50ZXh0KCl9O1xuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zZWxlY3QyKCdkYXRhJywgZGF0YSk7IFxuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LnNlbGVjdDIoJ3ZhbCcpO1xuICAgICAgIH0sXG5cbiAgICAgICBzdHIydmFsdWU6IGZ1bmN0aW9uKHN0ciwgc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBpZih0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyB8fCAhdGhpcy5pc011bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8IHRoaXMuZ2V0U2VwYXJhdG9yKCk7XG5cbiAgICAgICAgICAgIHZhciB2YWwsIGksIGw7XG5cbiAgICAgICAgICAgIGlmIChzdHIgPT09IG51bGwgfHwgc3RyLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbCA9IHN0ci5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB2YWxbaV0gPSAkLnRyaW0odmFsW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICB9LFxuXG4gICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGUsIGlzSW5pdGlhbCl7XG4gICAgICAgICAgICAgICAgaWYoIWlzSW5pdGlhbCkge1xuICAgICAgICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2VwYXJhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5zZXBhcmF0b3IgfHwgJC5mbi5zZWxlY3QyLmRlZmF1bHRzLnNlcGFyYXRvcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICBDb252ZXJ0cyBzb3VyY2UgZnJvbSB4LWVkaXRhYmxlIGZvcm1hdDoge3ZhbHVlOiAxLCB0ZXh0OiBcIjFcIn0gdG9cbiAgICAgICAgc2VsZWN0MiBmb3JtYXQ6IHtpZDogMSwgdGV4dDogXCIxXCJ9XG4gICAgICAgICovXG4gICAgICAgIGNvbnZlcnRTb3VyY2U6IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYoJC5pc0FycmF5KHNvdXJjZSkgJiYgc291cmNlLmxlbmd0aCAmJiBzb3VyY2VbMF0udmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8c291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHNvdXJjZVtpXS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VbaV0uaWQgPSBzb3VyY2VbaV0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc291cmNlW2ldLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYodGhpcy4kaW5wdXQuZGF0YSgnc2VsZWN0MicpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuc2VsZWN0MignZGVzdHJveScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0pO1xuXG4gICAgQ29uc3RydWN0b3IuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEBkZWZhdWx0IDxpbnB1dCB0eXBlPVwiaGlkZGVuXCI+XG4gICAgICAgICoqL1xuICAgICAgICB0cGw6JzxpbnB1dCB0eXBlPVwiaGlkZGVuXCI+JyxcbiAgICAgICAgLyoqXG4gICAgICAgIENvbmZpZ3VyYXRpb24gb2Ygc2VsZWN0Mi4gW0Z1bGwgbGlzdCBvZiBvcHRpb25zXShodHRwOi8vaXZheW5iZXJnLmdpdGh1Yi5jb20vc2VsZWN0MikuXG5cbiAgICAgICAgQHByb3BlcnR5IHNlbGVjdDIgXG4gICAgICAgIEB0eXBlIG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBzZWxlY3QyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgUGxhY2Vob2xkZXIgYXR0cmlidXRlIG9mIHNlbGVjdFxuXG4gICAgICAgIEBwcm9wZXJ0eSBwbGFjZWhvbGRlciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovXG4gICAgICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgU291cmNlIGRhdGEgZm9yIHNlbGVjdC4gSXQgd2lsbCBiZSBhc3NpZ25lZCB0byBzZWxlY3QyIGBkYXRhYCBwcm9wZXJ0eSBhbmQga2VwdCBoZXJlIGp1c3QgZm9yIGNvbnZlbmllbmNlLlxuICAgICAgICBQbGVhc2Ugbm90ZSwgdGhhdCBmb3JtYXQgaXMgZGlmZmVyZW50IGZyb20gc2ltcGxlIGBzZWxlY3RgIGlucHV0OiB1c2UgJ2lkJyBpbnN0ZWFkIG9mICd2YWx1ZScuXG4gICAgICAgIEUuZy4gYFt7aWQ6IDEsIHRleHQ6IFwidGV4dDFcIn0sIHtpZDogMiwgdGV4dDogXCJ0ZXh0MlwifSwgLi4uXWAuXG5cbiAgICAgICAgQHByb3BlcnR5IHNvdXJjZSBcbiAgICAgICAgQHR5cGUgYXJyYXl8c3RyaW5nfGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGwgICAgICAgIFxuICAgICAgICAqKi9cbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgU2VwYXJhdG9yIHVzZWQgdG8gZGlzcGxheSB0YWdzLlxuXG4gICAgICAgIEBwcm9wZXJ0eSB2aWV3c2VwYXJhdG9yIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJywgJyAgICAgICAgXG4gICAgICAgICoqL1xuICAgICAgICB2aWV3c2VwYXJhdG9yOiAnLCAnXG4gICAgfSk7XG5cbiAgICAkLmZuLmVkaXRhYmxldHlwZXMuc2VsZWN0MiA9IENvbnN0cnVjdG9yO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG4qIENvbWJvZGF0ZSAtIDEuMC41XG4qIERyb3Bkb3duIGRhdGUgYW5kIHRpbWUgcGlja2VyLlxuKiBDb252ZXJ0cyB0ZXh0IGlucHV0IGludG8gZHJvcGRvd25zIHRvIHBpY2sgZGF5LCBtb250aCwgeWVhciwgaG91ciwgbWludXRlIGFuZCBzZWNvbmQuXG4qIFVzZXMgbW9tZW50anMgYXMgZGF0ZXRpbWUgbGlicmFyeSBodHRwOi8vbW9tZW50anMuY29tLlxuKiBGb3IgaTE4biBpbmNsdWRlIGNvcnJlc3BvbmRpbmcgZmlsZSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1yd29vZC9tb21lbnQvdHJlZS9tYXN0ZXIvbGFuZyBcbipcbiogQ29uZnVzaW9uIGF0IG5vb24gYW5kIG1pZG5pZ2h0IC0gc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvMTItaG91cl9jbG9jayNDb25mdXNpb25fYXRfbm9vbl9hbmRfbWlkbmlnaHRcbiogSW4gY29tYm9kYXRlOiBcbiogMTI6MDAgcG0gLS0+IDEyOjAwICgyNC1oIGZvcm1hdCwgbWlkZGF5KVxuKiAxMjowMCBhbSAtLT4gMDA6MDAgKDI0LWggZm9ybWF0LCBtaWRuaWdodCwgc3RhcnQgb2YgZGF5KVxuKiBcbiogRGlmZmVycyBmcm9tIG1vbWVudGpzIHBhcnNlIHJ1bGVzOlxuKiAwMDowMCBwbSwgMTI6MDAgcG0gLS0+IDEyOjAwICgyNC1oIGZvcm1hdCwgZGF5IG5vdCBjaGFuZ2UpXG4qIDAwOjAwIGFtLCAxMjowMCBhbSAtLT4gMDA6MDAgKDI0LWggZm9ybWF0LCBkYXkgbm90IGNoYW5nZSlcbiogXG4qIFxuKiBBdXRob3I6IFZpdGFsaXkgUG90YXBvdlxuKiBQcm9qZWN0IHBhZ2U6IGh0dHA6Ly9naXRodWIuY29tL3ZpdGFsZXRzL2NvbWJvZGF0ZVxuKiBDb3B5cmlnaHQgKGMpIDIwMTIgVml0YWxpeSBQb3RhcG92LiBSZWxlYXNlZCB1bmRlciBNSVQgTGljZW5zZS5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG5cbiAgICB2YXIgQ29tYm9kYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgIGlmKCF0aGlzLiRlbGVtZW50LmlzKCdpbnB1dCcpKSB7XG4gICAgICAgICAgICAkLmVycm9yKCdDb21ib2RhdGUgc2hvdWxkIGJlIGFwcGxpZWQgdG8gSU5QVVQgZWxlbWVudCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmNvbWJvZGF0ZS5kZWZhdWx0cywgb3B0aW9ucywgdGhpcy4kZWxlbWVudC5kYXRhKCkpO1xuICAgICAgICB0aGlzLmluaXQoKTsgIFxuICAgICB9O1xuXG4gICAgQ29tYm9kYXRlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IENvbWJvZGF0ZSwgXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0ge1xuICAgICAgICAgICAgICAgIC8va2V5ICAgcmVnZXhwICAgIG1vbWVudC5tZXRob2RcbiAgICAgICAgICAgICAgICBkYXk6ICAgIFsnRCcsICAgICdkYXRlJ10sIFxuICAgICAgICAgICAgICAgIG1vbnRoOiAgWydNJywgICAgJ21vbnRoJ10sIFxuICAgICAgICAgICAgICAgIHllYXI6ICAgWydZJywgICAgJ3llYXInXSwgXG4gICAgICAgICAgICAgICAgaG91cjogICBbJ1tIaF0nLCAnaG91cnMnXSxcbiAgICAgICAgICAgICAgICBtaW51dGU6IFsnbScsICAgICdtaW51dGVzJ10sIFxuICAgICAgICAgICAgICAgIHNlY29uZDogWydzJywgICAgJ3NlY29uZHMnXSxcbiAgICAgICAgICAgICAgICBhbXBtOiAgIFsnW0FhXScsICcnXSBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJHdpZGdldCA9ICQoJzxzcGFuIGNsYXNzPVwiY29tYm9kYXRlXCI+PC9zcGFuPicpLmh0bWwodGhpcy5nZXRUZW1wbGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaW5pdENvbWJvcygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3VwZGF0ZSBvcmlnaW5hbCBpbnB1dCBvbiBjaGFuZ2UgXG4gICAgICAgICAgICB0aGlzLiR3aWRnZXQub24oJ2NoYW5nZScsICdzZWxlY3QnLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnZhbCh0aGlzLmdldFZhbHVlKCkpLmNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBkYXlzIGNvdW50IGlmIG1vbnRoIG9yIHllYXIgY2hhbmdlc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnREYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcygnLm1vbnRoJykgfHwgJChlLnRhcmdldCkuaXMoJy55ZWFyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsbENvbWJvKCdkYXknKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kd2lkZ2V0LmZpbmQoJ3NlbGVjdCcpLmNzcygnd2lkdGgnLCAnYXV0bycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBoaWRlIG9yaWdpbmFsIGlucHV0IGFuZCBpbnNlcnQgd2lkZ2V0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmhpZGUoKS5hZnRlcih0aGlzLiR3aWRnZXQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLiRlbGVtZW50LnZhbCgpIHx8IHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAgUmVwbGFjZSB0b2tlbnMgaW4gdGVtcGxhdGUgd2l0aCA8c2VsZWN0PiBlbGVtZW50cyBcbiAgICAgICAgKi8gICAgICAgICBcbiAgICAgICAgZ2V0VGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRwbCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZTtcblxuICAgICAgICAgICAgLy9maXJzdCBwYXNzXG4gICAgICAgICAgICAkLmVhY2godGhpcy5tYXAsIGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgICAgICAgICB2ID0gdlswXTsgXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBuZXcgUmVnRXhwKHYrJysnKSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB2Lmxlbmd0aCA+IDEgPyB2LnN1YnN0cmluZygxLCAyKSA6IHY7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKHIsICd7Jyt0b2tlbisnfScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vcmVwbGFjZSBzcGFjZXMgd2l0aCAmbmJzcDtcbiAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKC8gL2csICcmbmJzcDsnKTtcblxuICAgICAgICAgICAgLy9zZWNvbmQgcGFzc1xuICAgICAgICAgICAgJC5lYWNoKHRoaXMubWFwLCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgICAgICAgdiA9IHZbMF07XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdi5sZW5ndGggPiAxID8gdi5zdWJzdHJpbmcoMSwgMikgOiB2O1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0cGwgPSB0cGwucmVwbGFjZSgneycrdG9rZW4rJ30nLCAnPHNlbGVjdCBjbGFzcz1cIicraysnXCI+PC9zZWxlY3Q+Jyk7XG4gICAgICAgICAgICB9KTsgICBcblxuICAgICAgICAgICAgcmV0dXJuIHRwbDtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICBJbml0aWFsaXplIGNvbWJvcyB0aGF0IHByZXNlbnRzIGluIHRlbXBsYXRlIFxuICAgICAgICAqLyAgICAgICAgXG4gICAgICAgIGluaXRDb21ib3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgICAgIHZhciAkYyA9IHRoaXMuJHdpZGdldC5maW5kKCcuJytrKTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgcHJvcGVydGllcyBsaWtlIHRoaXMuJGRheSwgdGhpcy4kbW9udGggZXRjLlxuICAgICAgICAgICAgICAgIHRoaXNbJyQnK2tdID0gJGMubGVuZ3RoID8gJGMgOiBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGZpbGwgd2l0aCBpdGVtc1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsbENvbWJvKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICBGaWxsIGNvbWJvIHdpdGggaXRlbXMgXG4gICAgICAgICovICAgICAgICBcbiAgICAgICAgZmlsbENvbWJvOiBmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICB2YXIgJGNvbWJvID0gdGhpc1snJCcra107XG4gICAgICAgICAgICBpZiAoISRjb21ibykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGVmaW5lIG1ldGhvZCBuYW1lIHRvIGZpbGwgaXRlbXMsIGUuZyBgZmlsbERheXNgXG4gICAgICAgICAgICB2YXIgZiA9ICdmaWxsJyArIGsuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrLnNsaWNlKDEpOyBcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXNbZl0oKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICRjb21iby52YWwoKTtcblxuICAgICAgICAgICAgJGNvbWJvLmVtcHR5KCk7XG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICRjb21iby5hcHBlbmQoJzxvcHRpb24gdmFsdWU9XCInK2l0ZW1zW2ldWzBdKydcIj4nK2l0ZW1zW2ldWzFdKyc8L29wdGlvbj4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGNvbWJvLnZhbCh2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgIEluaXRpYWxpemUgaXRlbXMgb2YgY29tYm9zLiBIYW5kbGVzIGBmaXJzdEl0ZW1gIG9wdGlvbiBcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbENvbW1vbjogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW10sXG4gICAgICAgICAgICAgICAgcmVsVGltZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5maXJzdEl0ZW0gPT09ICduYW1lJykge1xuICAgICAgICAgICAgICAgIC8vbmVlZCBib3RoIHRvIHN1cHBvcnQgbW9tZW50IHZlciA8IDIgYW5kICA+PSAyXG4gICAgICAgICAgICAgICAgcmVsVGltZSA9IG1vbWVudC5yZWxhdGl2ZVRpbWUgfHwgbW9tZW50LmxhbmdEYXRhKCkuX3JlbGF0aXZlVGltZTsgXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IHR5cGVvZiByZWxUaW1lW2tleV0gPT09ICdmdW5jdGlvbicgPyByZWxUaW1lW2tleV0oMSwgdHJ1ZSwga2V5LCBmYWxzZSkgOiByZWxUaW1lW2tleV07XG4gICAgICAgICAgICAgICAgLy90YWtlIGxhc3QgZW50cnkgKHNlZSBtb21lbnRqcyBsYW5nIGZpbGVzIHN0cnVjdHVyZSkgXG4gICAgICAgICAgICAgICAgaGVhZGVyID0gaGVhZGVyLnNwbGl0KCcgJykucmV2ZXJzZSgpWzBdOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChbJycsIGhlYWRlcl0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMub3B0aW9ucy5maXJzdEl0ZW0gPT09ICdlbXB0eScpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChbJycsICcnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9LCAgXG5cblxuICAgICAgICAvKlxuICAgICAgICBmaWxsIGRheVxuICAgICAgICAqL1xuICAgICAgICBmaWxsRGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXMuZmlsbENvbW1vbignZCcpLCBuYW1lLCBpLFxuICAgICAgICAgICAgICAgIHR3b0RpZ2l0ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ0REJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIGRheXNDb3VudCA9IDMxO1xuXG4gICAgICAgICAgICAvLyBkZXRlY3QgZGF5cyBjb3VudCAoZGVwZW5kcyBvbiBtb250aCBhbmQgeWVhcilcbiAgICAgICAgICAgIC8vIG9yaWdpbmFsbHkgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGFsZXRzL2NvbWJvZGF0ZS9wdWxsLzdcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnREYXlzICYmIHRoaXMuJG1vbnRoICYmIHRoaXMuJHllYXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGggPSBwYXJzZUludCh0aGlzLiRtb250aC52YWwoKSwgMTApO1xuICAgICAgICAgICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQodGhpcy4keWVhci52YWwoKSwgMTApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihtb250aCkgJiYgIWlzTmFOKHllYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRheXNDb3VudCA9IG1vbWVudChbeWVhciwgbW9udGhdKS5kYXlzSW5Nb250aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBkYXlzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0d29EaWdpdCA/IHRoaXMubGVhZFplcm8oaSkgOiBpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtczsgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBtb250aFxuICAgICAgICAqL1xuICAgICAgICBmaWxsTW9udGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5maWxsQ29tbW9uKCdNJyksIG5hbWUsIGksIFxuICAgICAgICAgICAgICAgIGxvbmdOYW1lcyA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdNTU1NJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIHNob3J0TmFtZXMgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUuaW5kZXhPZignTU1NJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIHR3b0RpZ2l0ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ01NJykgIT09IC0xO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKGk9MDsgaTw9MTE7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmKGxvbmdOYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAvL3NlZSBodHRwczovL2dpdGh1Yi5jb20vdGltcndvb2QvbW9tZW50anMuY29tL3B1bGwvMzZcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG1vbWVudCgpLmRhdGUoMSkubW9udGgoaSkuZm9ybWF0KCdNTU1NJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHNob3J0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG1vbWVudCgpLmRhdGUoMSkubW9udGgoaSkuZm9ybWF0KCdNTU0nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodHdvRGlnaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMubGVhZFplcm8oaSsxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gaSsxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKFtpLCBuYW1lXSk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBmaWxsIHllYXJcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbFllYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gW10sIG5hbWUsIGksIFxuICAgICAgICAgICAgICAgIGxvbmdOYW1lcyA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdZWVlZJykgIT09IC0xO1xuICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcihpPXRoaXMub3B0aW9ucy5tYXhZZWFyOyBpPj10aGlzLm9wdGlvbnMubWluWWVhcjsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGxvbmdOYW1lcyA/IGkgOiAoaSsnJykuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgICAgIGl0ZW1zW3RoaXMub3B0aW9ucy55ZWFyRGVzY2VuZGluZyA/ICdwdXNoJyA6ICd1bnNoaWZ0J10oW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaXRlbXMgPSB0aGlzLmZpbGxDb21tb24oJ3knKS5jb25jYXQoaXRlbXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7ICAgICAgICAgICAgICBcbiAgICAgICAgfSwgICAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBmaWxsIGhvdXJcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbEhvdXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5maWxsQ29tbW9uKCdoJyksIG5hbWUsIGksXG4gICAgICAgICAgICAgICAgaDEyID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ2gnKSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgaDI0ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ0gnKSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgdHdvRGlnaXQgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdoaCcpICE9PSAtMSxcbiAgICAgICAgICAgICAgICBtaW4gPSBoMTIgPyAxIDogMCwgXG4gICAgICAgICAgICAgICAgbWF4ID0gaDEyID8gMTIgOiAyMztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcihpPW1pbjsgaTw9bWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gdHdvRGlnaXQgPyB0aGlzLmxlYWRaZXJvKGkpIDogaTtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKFtpLCBuYW1lXSk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zOyAgICAgICAgICAgICAgICAgXG4gICAgICAgIH0sICAgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBtaW51dGVcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbE1pbnV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmZpbGxDb21tb24oJ20nKSwgbmFtZSwgaSxcbiAgICAgICAgICAgICAgICB0d29EaWdpdCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdtbScpICE9PSAtMTtcblxuICAgICAgICAgICAgZm9yKGk9MDsgaTw9NTk7IGkrPSB0aGlzLm9wdGlvbnMubWludXRlU3RlcCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0d29EaWdpdCA/IHRoaXMubGVhZFplcm8oaSkgOiBpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7ICAgICAgICAgICAgICBcbiAgICAgICAgfSwgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBzZWNvbmRcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbFNlY29uZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmZpbGxDb21tb24oJ3MnKSwgbmFtZSwgaSxcbiAgICAgICAgICAgICAgICB0d29EaWdpdCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdzcycpICE9PSAtMTtcblxuICAgICAgICAgICAgZm9yKGk9MDsgaTw9NTk7IGkrPSB0aGlzLm9wdGlvbnMuc2Vjb25kU3RlcCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0d29EaWdpdCA/IHRoaXMubGVhZFplcm8oaSkgOiBpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7ICAgICAgICAgICAgICBcbiAgICAgICAgfSwgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBhbXBtXG4gICAgICAgICovXG4gICAgICAgIGZpbGxBbXBtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhbXBtTCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdhJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIGFtcG1VID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ0EnKSAhPT0gLTEsICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaXRlbXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIFsnYW0nLCBhbXBtTCA/ICdhbScgOiAnQU0nXSxcbiAgICAgICAgICAgICAgICAgICAgWydwbScsIGFtcG1MID8gJ3BtJyA6ICdQTSddXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAvKlxuICAgICAgICAgUmV0dXJucyBjdXJyZW50IGRhdGUgdmFsdWUgZnJvbSBjb21ib3MuIFxuICAgICAgICAgSWYgZm9ybWF0IG5vdCBzcGVjaWZpZWQgLSBgb3B0aW9ucy5mb3JtYXRgIHVzZWQuXG4gICAgICAgICBJZiBmb3JtYXQgPSBgbnVsbGAgLSBNb21lbnQgb2JqZWN0IHJldHVybmVkLlxuICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgICAgICB2YXIgZHQsIHZhbHVlcyA9IHt9LCBcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBub3RTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9nZXR0aW5nIHNlbGVjdGVkIHZhbHVlcyAgICBcbiAgICAgICAgICAgICQuZWFjaCh0aGlzLm1hcCwgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgICAgIGlmKGsgPT09ICdhbXBtJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZWYgPSBrID09PSAnZGF5JyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFsdWVzW2tdID0gdGhhdFsnJCcra10gPyBwYXJzZUludCh0aGF0WyckJytrXS52YWwoKSwgMTApIDogZGVmOyBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihpc05hTih2YWx1ZXNba10pKSB7XG4gICAgICAgICAgICAgICAgICAgbm90U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgYXQgbGVhc3Qgb25lIHZpc2libGUgY29tYm8gbm90IHNlbGVjdGVkIC0gcmV0dXJuIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgaWYobm90U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jb252ZXJ0IGhvdXJzIDEyaCAtLT4gMjRoIFxuICAgICAgICAgICAgaWYodGhpcy4kYW1wbSkge1xuICAgICAgICAgICAgICAgIC8vMTI6MDAgcG0gLS0+IDEyOjAwICgyNC1oIGZvcm1hdCwgbWlkZGF5KSwgMTI6MDAgYW0gLS0+IDAwOjAwICgyNC1oIGZvcm1hdCwgbWlkbmlnaHQsIHN0YXJ0IG9mIGRheSlcbiAgICAgICAgICAgICAgICBpZih2YWx1ZXMuaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmhvdXIgPSB0aGlzLiRhbXBtLnZhbCgpID09PSAnYW0nID8gMCA6IDEyOyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmhvdXIgPSB0aGlzLiRhbXBtLnZhbCgpID09PSAnYW0nID8gdmFsdWVzLmhvdXIgOiB2YWx1ZXMuaG91cisxMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBkdCA9IG1vbWVudChbdmFsdWVzLnllYXIsIHZhbHVlcy5tb250aCwgdmFsdWVzLmRheSwgdmFsdWVzLmhvdXIsIHZhbHVlcy5taW51dGUsIHZhbHVlcy5zZWNvbmRdKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9oaWdobGlnaHQgaW52YWxpZCBkYXRlXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodChkdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmZvcm1hdCA6IGZvcm1hdDtcbiAgICAgICAgICAgIGlmKGZvcm1hdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgcmV0dXJuIGR0LmlzVmFsaWQoKSA/IGR0IDogbnVsbDsgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgcmV0dXJuIGR0LmlzVmFsaWQoKSA/IGR0LmZvcm1hdChmb3JtYXQpIDogJyc7IFxuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGR0ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IG1vbWVudCh2YWx1ZSwgdGhpcy5vcHRpb25zLmZvcm1hdCkgOiBtb21lbnQodmFsdWUpLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2Z1bmN0aW9uIHRvIGZpbmQgbmVhcmVzdCB2YWx1ZSBpbiBzZWxlY3Qgb3B0aW9uc1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TmVhcmVzdCgkc2VsZWN0LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IHt9O1xuICAgICAgICAgICAgICAgICRzZWxlY3QuY2hpbGRyZW4oJ29wdGlvbicpLmVhY2goZnVuY3Rpb24oaSwgb3B0KXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdFZhbHVlID0gJChvcHQpLmF0dHIoJ3ZhbHVlJyksXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdFZhbHVlID09PSAnJykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKG9wdFZhbHVlIC0gdmFsdWUpOyBcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGRlbHRhLmRpc3RhbmNlID09PSAndW5kZWZpbmVkJyB8fCBkaXN0YW5jZSA8IGRlbHRhLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IHt2YWx1ZTogb3B0VmFsdWUsIGRpc3RhbmNlOiBkaXN0YW5jZX07XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgfSk7IFxuICAgICAgICAgICAgICAgIHJldHVybiBkZWx0YS52YWx1ZTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGR0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIC8vcmVhZCB2YWx1ZXMgZnJvbSBkYXRlIG9iamVjdFxuICAgICAgICAgICAgICAgICQuZWFjaCh0aGlzLm1hcCwgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgICAgICAgICBpZihrID09PSAnYW1wbScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba10gPSBkdFt2WzFdXSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodGhpcy4kYW1wbSkge1xuICAgICAgICAgICAgICAgICAgICAvLzEyOjAwIHBtIC0tPiAxMjowMCAoMjQtaCBmb3JtYXQsIG1pZGRheSksIDEyOjAwIGFtIC0tPiAwMDowMCAoMjQtaCBmb3JtYXQsIG1pZG5pZ2h0LCBzdGFydCBvZiBkYXkpXG4gICAgICAgICAgICAgICAgICAgIGlmKHZhbHVlcy5ob3VyID49IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuYW1wbSA9ICdwbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZXMuaG91ciA+IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmhvdXIgLT0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuYW1wbSA9ICdhbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZXMuaG91ciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5ob3VyID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJC5lYWNoKHZhbHVlcywgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgICAgICAgICAvL2NhbGwgdmFsKCkgZm9yIGVhY2ggZXhpc3RpbmcgY29tYm8sIGUuZy4gdGhpcy4kaG91ci52YWwoKVxuICAgICAgICAgICAgICAgICAgICBpZih0aGF0WyckJytrXSkge1xuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGsgPT09ICdtaW51dGUnICYmIHRoYXQub3B0aW9ucy5taW51dGVTdGVwID4gMSAmJiB0aGF0Lm9wdGlvbnMucm91bmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2V0TmVhcmVzdCh0aGF0WyckJytrXSwgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoayA9PT0gJ3NlY29uZCcgJiYgdGhhdC5vcHRpb25zLnNlY29uZFN0ZXAgPiAxICYmIHRoYXQub3B0aW9ucy5yb3VuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnZXROZWFyZXN0KHRoYXRbJyQnK2tdLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXRbJyQnK2tdLnZhbCh2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGRheXMgY291bnRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNtYXJ0RGF5cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGxDb21ibygnZGF5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnZhbChkdC5mb3JtYXQodGhpcy5vcHRpb25zLmZvcm1hdCkpLmNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgIGhpZ2hsaWdodCBjb21ib3MgaWYgZGF0ZSBpcyBpbnZhbGlkXG4gICAgICAgICovXG4gICAgICAgIGhpZ2hsaWdodDogZnVuY3Rpb24oZHQpIHtcbiAgICAgICAgICAgIGlmKCFkdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR3aWRnZXQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vc3RvcmUgb3JpZ2luYWwgYm9yZGVyIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gdGhpcy4kd2lkZ2V0LmZpbmQoJ3NlbGVjdCcpLmNzcygnYm9yZGVyLWNvbG9yJyk7IFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHdpZGdldC5maW5kKCdzZWxlY3QnKS5jc3MoJ2JvcmRlci1jb2xvcicsICdyZWQnKTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR3aWRnZXQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHdpZGdldC5maW5kKCdzZWxlY3QnKS5jc3MoJ2JvcmRlci1jb2xvcicsIHRoaXMuYm9yZGVyQ29sb3IpO1xuICAgICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgbGVhZFplcm86IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2IDw9IDkgPyAnMCcgKyB2IDogdjsgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJHdpZGdldC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnY29tYm9kYXRlJykuc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL3RvZG86IGNsZWFyIG1ldGhvZCAgICAgICAgXG4gICAgfTtcblxuICAgICQuZm4uY29tYm9kYXRlID0gZnVuY3Rpb24gKCBvcHRpb24gKSB7XG4gICAgICAgIHZhciBkLCBhcmdzID0gQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgYXJncy5zaGlmdCgpO1xuXG4gICAgICAgIC8vZ2V0VmFsdWUgcmV0dXJucyBkYXRlIGFzIHN0cmluZyAvIG9iamVjdCAobm90IGpRdWVyeSBvYmplY3QpXG4gICAgICAgIGlmKG9wdGlvbiA9PT0gJ2dldFZhbHVlJyAmJiB0aGlzLmxlbmd0aCAmJiAoZCA9IHRoaXMuZXEoMCkuZGF0YSgnY29tYm9kYXRlJykpKSB7XG4gICAgICAgICAgcmV0dXJuIGQuZ2V0VmFsdWUuYXBwbHkoZCwgYXJncyk7XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgZGF0YSA9ICR0aGlzLmRhdGEoJ2NvbWJvZGF0ZScpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uO1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnY29tYm9kYXRlJywgKGRhdGEgPSBuZXcgQ29tYm9kYXRlKHRoaXMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGF0YVtvcHRpb25dID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkYXRhW29wdGlvbl0uYXBwbHkoZGF0YSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07ICBcbiAgICBcbiAgICAkLmZuLmNvbWJvZGF0ZS5kZWZhdWx0cyA9IHtcbiAgICAgICAgIC8vaW4gdGhpcyBmb3JtYXQgdmFsdWUgc3RvcmVkIGluIG9yaWdpbmFsIGlucHV0XG4gICAgICAgIGZvcm1hdDogJ0RELU1NLVlZWVkgSEg6bW0nLCAgICAgIFxuICAgICAgICAvL2luIHRoaXMgZm9ybWF0IGl0ZW1zIGluIGRyb3Bkb3ducyBhcmUgZGlzcGxheWVkXG4gICAgICAgIHRlbXBsYXRlOiAnRCAvIE1NTSAvIFlZWVkgICBIIDogbW0nLFxuICAgICAgICAvL2luaXRpYWwgdmFsdWUsIGNhbiBiZSBgbmV3IERhdGUoKWAgICAgXG4gICAgICAgIHZhbHVlOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIG1pblllYXI6IDE5NzAsXG4gICAgICAgIG1heFllYXI6IDIwMTUsXG4gICAgICAgIHllYXJEZXNjZW5kaW5nOiB0cnVlLFxuICAgICAgICBtaW51dGVTdGVwOiA1LFxuICAgICAgICBzZWNvbmRTdGVwOiAxLFxuICAgICAgICBmaXJzdEl0ZW06ICdlbXB0eScsIC8vJ25hbWUnLCAnZW1wdHknLCAnbm9uZSdcbiAgICAgICAgZXJyb3JDbGFzczogbnVsbCxcbiAgICAgICAgcm91bmRUaW1lOiB0cnVlLCAvLyB3aGV0aGVyIHRvIHJvdW5kIG1pbnV0ZXMgYW5kIHNlY29uZHMgaWYgc3RlcCA+IDFcbiAgICAgICAgc21hcnREYXlzOiBmYWxzZSAvLyB3aGV0aGVyIGRheXMgaW4gY29tYm8gZGVwZW5kIG9uIHNlbGVjdGVkIG1vbnRoOiAzMSwgMzAsIDI4XG4gICAgfTtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG4vKipcbkNvbWJvZGF0ZSBpbnB1dCAtIGRyb3Bkb3duIGRhdGUgYW5kIHRpbWUgcGlja2VyLiAgICBcbkJhc2VkIG9uIFtjb21ib2RhdGVdKGh0dHA6Ly92aXRhbGV0cy5naXRodWIuY29tL2NvbWJvZGF0ZSkgcGx1Z2luIChpbmNsdWRlZCkuIFRvIHVzZSBpdCB5b3Ugc2hvdWxkIG1hbnVhbGx5IGluY2x1ZGUgW21vbWVudGpzXShodHRwOi8vbW9tZW50anMuY29tKS5cblxuICAgIDxzY3JpcHQgc3JjPVwianMvbW9tZW50Lm1pbi5qc1wiPjwvc2NyaXB0PlxuICAgXG5BbGxvd3MgdG8gaW5wdXQ6XG5cbiogb25seSBkYXRlXG4qIG9ubHkgdGltZSBcbiogYm90aCBkYXRlIGFuZCB0aW1lICBcblxuUGxlYXNlIG5vdGUsIHRoYXQgZm9ybWF0IGlzIHRha2VuIGZyb20gbW9tZW50anMgYW5kICoqbm90IGNvbXBhdGlibGUqKiB3aXRoIGJvb3RzdHJhcC1kYXRlcGlja2VyIC8ganF1ZXJ5IFVJIGRhdGVwaWNrZXIuICBcbkludGVybmFsbHkgdmFsdWUgc3RvcmVkIGFzIGBtb21lbnRqc2Agb2JqZWN0LiBcblxuQGNsYXNzIGNvbWJvZGF0ZVxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQGZpbmFsXG5Ac2luY2UgMS40LjBcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwiZG9iXCIgZGF0YS10eXBlPVwiY29tYm9kYXRlXCIgZGF0YS1waz1cIjFcIiBkYXRhLXVybD1cIi9wb3N0XCIgZGF0YS12YWx1ZT1cIjE5ODQtMDUtMTVcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IGRhdGVcIj48L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNkb2InKS5lZGl0YWJsZSh7XG4gICAgICAgIGZvcm1hdDogJ1lZWVktTU0tREQnLCAgICBcbiAgICAgICAgdmlld2Zvcm1hdDogJ0RELk1NLllZWVknLCAgICBcbiAgICAgICAgdGVtcGxhdGU6ICdEIC8gTU1NTSAvIFlZWVknLCAgICBcbiAgICAgICAgY29tYm9kYXRlOiB7XG4gICAgICAgICAgICAgICAgbWluWWVhcjogMjAwMCxcbiAgICAgICAgICAgICAgICBtYXhZZWFyOiAyMDE1LFxuICAgICAgICAgICAgICAgIG1pbnV0ZVN0ZXA6IDFcbiAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG5cbi8qZ2xvYmFsIG1vbWVudCovXG5cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2NvbWJvZGF0ZScsIG9wdGlvbnMsIENvbnN0cnVjdG9yLmRlZmF1bHRzKTtcbiAgICAgICAgXG4gICAgICAgIC8vYnkgZGVmYXVsdCB2aWV3Zm9ybWF0IGVxdWFscyB0byBmb3JtYXRcbiAgICAgICAgaWYoIXRoaXMub3B0aW9ucy52aWV3Zm9ybWF0KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCA9IHRoaXMub3B0aW9ucy5mb3JtYXQ7XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy90cnkgcGFyc2UgY29tYm9kYXRlIGNvbmZpZyBkZWZpbmVkIGFzIGpzb24gc3RyaW5nIGluIGRhdGEtY29tYm9kYXRlXG4gICAgICAgIG9wdGlvbnMuY29tYm9kYXRlID0gJC5mbi5lZGl0YWJsZXV0aWxzLnRyeVBhcnNlSnNvbihvcHRpb25zLmNvbWJvZGF0ZSwgdHJ1ZSk7XG5cbiAgICAgICAgLy9vdmVycmlkaW5nIGNvbWJvZGF0ZSBjb25maWcgKGFzIGJ5IGRlZmF1bHQgalF1ZXJ5IGV4dGVuZCgpIGlzIG5vdCByZWN1cnNpdmUpXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb21ib2RhdGUgPSAkLmV4dGVuZCh7fSwgQ29uc3RydWN0b3IuZGVmYXVsdHMuY29tYm9kYXRlLCBvcHRpb25zLmNvbWJvZGF0ZSwge1xuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLm9wdGlvbnMuZm9ybWF0LFxuICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMub3B0aW9ucy50ZW1wbGF0ZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoQ29uc3RydWN0b3IsICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTsgICAgXG4gICAgXG4gICAgJC5leHRlbmQoQ29uc3RydWN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuY29tYm9kYXRlKHRoaXMub3B0aW9ucy5jb21ib2RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCQuZm4uZWRpdGFibGVmb3JtLmVuZ2luZSA9PT0gJ2JzMycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zaWJsaW5ncygpLmZpbmQoJ3NlbGVjdCcpLmFkZENsYXNzKCdmb3JtLWNvbnRyb2wnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmlucHV0Y2xhc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zaWJsaW5ncygpLmZpbmQoJ3NlbGVjdCcpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5pbnB1dGNsYXNzKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vXCJjbGVhclwiIGxpbmtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuY2xlYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjbGVhciA9ICQoJzxhIGhyZWY9XCIjXCI+PC9hPicpLmh0bWwodGhpcy5vcHRpb25zLmNsZWFyKS5jbGljaygkLnByb3h5KGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy4kdHBsLnBhcmVudCgpLmFwcGVuZCgkKCc8ZGl2IGNsYXNzPVwiZWRpdGFibGUtY2xlYXJcIj4nKS5hcHBlbmQodGhpcy4kY2xlYXIpKTsgIFxuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICovICAgICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICB2YWx1ZTJodG1sOiBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSB2YWx1ZSA/IHZhbHVlLmZvcm1hdCh0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCkgOiAnJztcbiAgICAgICAgICAgIC8vJChlbGVtZW50KS50ZXh0KHRleHQpO1xuICAgICAgICAgICAgQ29uc3RydWN0b3Iuc3VwZXJjbGFzcy52YWx1ZTJodG1sLmNhbGwodGhpcywgdGV4dCwgZWxlbWVudCk7ICBcbiAgICAgICAgfSxcblxuICAgICAgICBodG1sMnZhbHVlOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbCA/IG1vbWVudChodG1sLCB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCkgOiBudWxsO1xuICAgICAgICB9LCAgIFxuICAgICAgICBcbiAgICAgICAgdmFsdWUyc3RyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdmFsdWUuZm9ybWF0KHRoaXMub3B0aW9ucy5mb3JtYXQpIDogJyc7XG4gICAgICAgfSwgXG4gICAgICAgXG4gICAgICAgc3RyMnZhbHVlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgcmV0dXJuIHN0ciA/IG1vbWVudChzdHIsIHRoaXMub3B0aW9ucy5mb3JtYXQpIDogbnVsbDtcbiAgICAgICB9LCBcbiAgICAgICBcbiAgICAgICB2YWx1ZTJzdWJtaXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlMnN0cih2YWx1ZSk7XG4gICAgICAgfSwgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgdmFsdWUyaW5wdXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHRoaXMuJGlucHV0LmNvbWJvZGF0ZSgnc2V0VmFsdWUnLCB2YWx1ZSk7XG4gICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LmNvbWJvZGF0ZSgnZ2V0VmFsdWUnLCBudWxsKTtcbiAgICAgICB9LCAgICAgICBcbiAgICAgICBcbiAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMuJGlucHV0LnNpYmxpbmdzKCcuY29tYm9kYXRlJykuZmluZCgnc2VsZWN0JykuZXEoMCkuZm9jdXMoKTtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgY2xlYXI6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLiRpbnB1dC5kYXRhKCdkYXRlcGlja2VyJykuZGF0ZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy4kaW5wdXQuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICB9LFxuICAgICAgICovXG4gICAgICAgXG4gICAgICAgYXV0b3N1Ym1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIFxuICAgICAgIH1cblxuICAgIH0pO1xuICAgIFxuICAgIENvbnN0cnVjdG9yLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICBAZGVmYXVsdCA8aW5wdXQgdHlwZT1cInRleHRcIj5cbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHRwbDonPGlucHV0IHR5cGU9XCJ0ZXh0XCI+JyxcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBpbnB1dGNsYXNzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgRm9ybWF0IHVzZWQgZm9yIHNlbmRpbmcgdmFsdWUgdG8gc2VydmVyLiBBbHNvIGFwcGxpZWQgd2hlbiBjb252ZXJ0aW5nIGRhdGUgZnJvbSA8Y29kZT5kYXRhLXZhbHVlPC9jb2RlPiBhdHRyaWJ1dGUuPGJyPlxuICAgICAgICBTZWUgbGlzdCBvZiB0b2tlbnMgaW4gW21vbWVudGpzIGRvY3NdKGh0dHA6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3BhcnNpbmcvc3RyaW5nLWZvcm1hdCkgIFxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IGZvcm1hdCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IFlZWVktTU0tRERcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGZvcm1hdDonWVlZWS1NTS1ERCcsXG4gICAgICAgIC8qKlxuICAgICAgICBGb3JtYXQgdXNlZCBmb3IgZGlzcGxheWluZyBkYXRlLiBBbHNvIGFwcGxpZWQgd2hlbiBjb252ZXJ0aW5nIGRhdGUgZnJvbSBlbGVtZW50J3MgdGV4dCBvbiBpbml0LiAgIFxuICAgICAgICBJZiBub3Qgc3BlY2lmaWVkIGVxdWFscyB0byBgZm9ybWF0YC5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSB2aWV3Zm9ybWF0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIHZpZXdmb3JtYXQ6IG51bGwsICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFRlbXBsYXRlIHVzZWQgZm9yIGRpc3BsYXlpbmcgZHJvcGRvd25zLlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IHRlbXBsYXRlIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgRCAvIE1NTSAvIFlZWVlcbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICB0ZW1wbGF0ZTogJ0QgLyBNTU0gLyBZWVlZJywgIFxuICAgICAgICAvKipcbiAgICAgICAgQ29uZmlndXJhdGlvbiBvZiBjb21ib2RhdGUuXG4gICAgICAgIEZ1bGwgbGlzdCBvZiBvcHRpb25zOiBodHRwOi8vdml0YWxldHMuZ2l0aHViLmNvbS9jb21ib2RhdGUvI2RvY3NcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBjb21ib2RhdGUgXG4gICAgICAgIEB0eXBlIG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBjb21ib2RhdGU6IG51bGxcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgIChub3QgaW1wbGVtZW50ZWQgeWV0KVxuICAgICAgICBUZXh0IHNob3duIGFzIGNsZWFyIGRhdGUgYnV0dG9uLiBcbiAgICAgICAgSWYgPGNvZGU+ZmFsc2U8L2NvZGU+IGNsZWFyIGJ1dHRvbiB3aWxsIG5vdCBiZSByZW5kZXJlZC5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBjbGVhciBcbiAgICAgICAgQHR5cGUgYm9vbGVhbnxzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ3ggY2xlYXInICAgICAgICAgXG4gICAgICAgICovXG4gICAgICAgIC8vY2xlYXI6ICcmdGltZXM7IGNsZWFyJ1xuICAgIH0pOyAgIFxuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLmNvbWJvZGF0ZSA9IENvbnN0cnVjdG9yO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLypcbkVkaXRhYmxlZm9ybSBiYXNlZCBvbiBUd2l0dGVyIEJvb3RzdHJhcCAzXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIC8vc3RvcmUgcGFyZW50IG1ldGhvZHNcbiAgICB2YXIgcEluaXRJbnB1dCA9ICQuZm4uZWRpdGFibGVmb3JtLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5pbml0SW5wdXQ7XG4gICAgXG4gICAgJC5leHRlbmQoJC5mbi5lZGl0YWJsZWZvcm0uQ29uc3RydWN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGluaXRUZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRmb3JtID0gJCgkLmZuLmVkaXRhYmxlZm9ybS50ZW1wbGF0ZSk7IFxuICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuY29udHJvbC1ncm91cCcpLmFkZENsYXNzKCdmb3JtLWdyb3VwJyk7XG4gICAgICAgICAgICB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1lcnJvci1ibG9jaycpLmFkZENsYXNzKCdoZWxwLWJsb2NrJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRJbnB1dDogZnVuY3Rpb24oKSB7ICBcbiAgICAgICAgICAgIHBJbml0SW5wdXQuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgICAgIC8vZm9yIGJzMyBzZXQgZGVmYXVsdCBjbGFzcyBgaW5wdXQtc21gIHRvIHN0YW5kYXJkIGlucHV0c1xuICAgICAgICAgICAgdmFyIGVtcHR5SW5wdXRDbGFzcyA9IHRoaXMuaW5wdXQub3B0aW9ucy5pbnB1dGNsYXNzID09PSBudWxsIHx8IHRoaXMuaW5wdXQub3B0aW9ucy5pbnB1dGNsYXNzID09PSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Q2xhc3MgPSAnaW5wdXQtc20nO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2JzMyBhZGQgYGZvcm0tY29udHJvbGAgY2xhc3MgdG8gc3RhbmRhcmQgaW5wdXRzXG4gICAgICAgICAgICB2YXIgc3RkdHlwZXMgPSAndGV4dCxzZWxlY3QsdGV4dGFyZWEscGFzc3dvcmQsZW1haWwsdXJsLHRlbCxudW1iZXIscmFuZ2UsdGltZSx0eXBlYWhlYWRqcycuc3BsaXQoJywnKTsgXG4gICAgICAgICAgICBpZih+JC5pbkFycmF5KHRoaXMuaW5wdXQudHlwZSwgc3RkdHlwZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC4kaW5wdXQuYWRkQ2xhc3MoJ2Zvcm0tY29udHJvbCcpO1xuICAgICAgICAgICAgICAgIGlmKGVtcHR5SW5wdXRDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0Lm9wdGlvbnMuaW5wdXRjbGFzcyA9IGRlZmF1bHRDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC4kaW5wdXQuYWRkQ2xhc3MoZGVmYXVsdENsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgICAgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgICAgIC8vYXBwbHkgYnMzIHNpemUgY2xhc3MgYWxzbyB0byBidXR0b25zICh0byBmaXQgc2l6ZSBvZiBjb250cm9sKVxuICAgICAgICAgICAgdmFyICRidG4gPSB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1idXR0b25zJyk7XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IGVtcHR5SW5wdXRDbGFzcyA/IFtkZWZhdWx0Q2xhc3NdIDogdGhpcy5pbnB1dC5vcHRpb25zLmlucHV0Y2xhc3Muc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBgYnRuLXNtYCBpcyBkZWZhdWx0IG5vd1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgaWYoY2xhc3Nlc1tpXS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQtc20nKSB7IFxuICAgICAgICAgICAgICAgICAgICAkYnRuLmZpbmQoJ2J1dHRvbicpLmFkZENsYXNzKCdidG4tc20nKTsgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmKGNsYXNzZXNbaV0udG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0LWxnJykge1xuICAgICAgICAgICAgICAgICAgICAkYnRuLmZpbmQoJ2J1dHRvbicpLnJlbW92ZUNsYXNzKCdidG4tc20nKS5hZGRDbGFzcygnYnRuLWxnJyk7IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pOyAgICBcbiAgICBcbiAgICAvL2J1dHRvbnNcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5idXR0b25zID0gXG4gICAgICAnPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLXNtIGVkaXRhYmxlLXN1Ym1pdFwiPicrXG4gICAgICAgICc8aSBjbGFzcz1cImZhIGZhLW9rXCI+PC9pPicrXG4gICAgICAnPC9idXR0b24+JytcbiAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBidG4tc20gZWRpdGFibGUtY2FuY2VsXCI+JytcbiAgICAgICAgJzxpIGNsYXNzPVwiZmEgZmEtcmVtb3ZlXCI+PC9pPicrXG4gICAgICAnPC9idXR0b24+JzsgICAgICAgICBcbiAgICBcbiAgICAvL2Vycm9yIGNsYXNzZXNcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckdyb3VwQ2xhc3MgPSAnaGFzLWVycm9yJztcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckJsb2NrQ2xhc3MgPSBudWxsOyAgXG4gICAgLy9lbmdpbmVcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5lbmdpbmUgPSAnYnMzJzsgIFxufSh3aW5kb3cualF1ZXJ5KSk7XG4vKipcbiogRWRpdGFibGUgUG9wb3ZlcjMgKGZvciBCb290c3RyYXAgMykgXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiByZXF1aXJlcyBib290c3RyYXAtcG9wb3Zlci5qc1xuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcblxuICAgIC8vZXh0ZW5kIG1ldGhvZHNcbiAgICAkLmV4dGVuZCgkLmZuLmVkaXRhYmxlQ29udGFpbmVyLlBvcHVwLnByb3RvdHlwZSwge1xuICAgICAgICBjb250YWluZXJOYW1lOiAncG9wb3ZlcicsXG4gICAgICAgIGNvbnRhaW5lckRhdGFOYW1lOiAnYnMucG9wb3ZlcicsXG4gICAgICAgIGlubmVyQ3NzOiAnLnBvcG92ZXItY29udGVudCcsXG4gICAgICAgIGRlZmF1bHRzOiAkLmZuLnBvcG92ZXIuQ29uc3RydWN0b3IuREVGQVVMVFMsXG5cbiAgICAgICAgaW5pdENvbnRhaW5lcjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICQuZXh0ZW5kKHRoaXMuY29udGFpbmVyT3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnICcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMuZGVmYXVsdHMudGVtcGxhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2FzIHRlbXBsYXRlIHByb3BlcnR5IGlzIHVzZWQgaW4gaW5wdXRzLCBoaWRlIGl0IGZyb20gcG9wb3ZlclxuICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICBpZih0aGlzLiRlbGVtZW50LmRhdGEoJ3RlbXBsYXRlJykpIHtcbiAgICAgICAgICAgICAgIHQgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoJ3RlbXBsYXRlJyk7ICBcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuY2FsbCh0aGlzLmNvbnRhaW5lck9wdGlvbnMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0KSB7XG4gICAgICAgICAgICAgICAvL3Jlc3RvcmUgZGF0YSgndGVtcGxhdGUnKVxuICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5kYXRhKCd0ZW1wbGF0ZScsIHQpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgXG4gICAgICAgIFxuICAgICAgICAvKiBzaG93ICovXG4gICAgICAgIGlubmVyU2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsKCdzaG93Jyk7ICAgICAgICAgICAgICAgIFxuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgICAvKiBoaWRlICovXG4gICAgICAgIGlubmVySGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsKCdoaWRlJyk7ICAgICAgIFxuICAgICAgICB9LCBcbiAgICAgICAgXG4gICAgICAgIC8qIGRlc3Ryb3kgKi9cbiAgICAgICAgaW5uZXJEZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbCgnZGVzdHJveScpO1xuICAgICAgICB9LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHNldENvbnRhaW5lck9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIoKS5vcHRpb25zW2tleV0gPSB2YWx1ZTsgXG4gICAgICAgIH0sICAgICAgICAgICAgICAgXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogbW92ZSBwb3BvdmVyIHRvIG5ldyBwb3NpdGlvbi4gVGhpcyBmdW5jdGlvbiBtYWlubHkgY29waWVkIGZyb20gYm9vdHN0cmFwLXBvcG92ZXIuXG4gICAgICAgICovXG4gICAgICAgIC8qanNoaW50IGxheGNvbW1hOiB0cnVlLCBlcWVxZXE6IGZhbHNlKi9cbiAgICAgICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHsgXG5cbiAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8qICAgIFxuICAgICAgICAgICAgICAgIHZhciAkdGlwID0gdGhpcy50aXAoKVxuICAgICAgICAgICAgICAgICwgaW5zaWRlXG4gICAgICAgICAgICAgICAgLCBwb3NcbiAgICAgICAgICAgICAgICAsIGFjdHVhbFdpZHRoXG4gICAgICAgICAgICAgICAgLCBhY3R1YWxIZWlnaHRcbiAgICAgICAgICAgICAgICAsIHBsYWNlbWVudFxuICAgICAgICAgICAgICAgICwgdHBcbiAgICAgICAgICAgICAgICAsIHRwdFxuICAgICAgICAgICAgICAgICwgdHBiXG4gICAgICAgICAgICAgICAgLCB0cGxcbiAgICAgICAgICAgICAgICAsIHRwcjtcblxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50LmNhbGwodGhpcywgJHRpcFswXSwgdGhpcy4kZWxlbWVudFswXSkgOlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICBpbnNpZGUgPSAvaW4vLnRlc3QocGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICR0aXBcbiAgICAgICAgICAgICAgLy8gIC5kZXRhY2goKVxuICAgICAgICAgICAgICAvL3ZpdGFsZXRzOiByZW1vdmUgYW55IHBsYWNlbWVudCBjbGFzcyBiZWNhdXNlIG90aGVyd2lzZSB0aGV5IGRvbnQgaW5mbHVlbmNlIG9uIHJlLXBvc2l0aW9uaW5nIG9mIHZpc2libGUgcG9wb3ZlclxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygndG9wIHJpZ2h0IGJvdHRvbSBsZWZ0JylcbiAgICAgICAgICAgICAgICAuY3NzKHsgdG9wOiAwLCBsZWZ0OiAwLCBkaXNwbGF5OiAnYmxvY2snIH0pO1xuICAgICAgICAgICAgICAvLyAgLmluc2VydEFmdGVyKHRoaXMuJGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbihpbnNpZGUpO1xuXG4gICAgICAgICAgICAgICAgYWN0dWFsV2lkdGggPSAkdGlwWzBdLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIGFjdHVhbEhlaWdodCA9ICR0aXBbMF0ub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gaW5zaWRlID8gcGxhY2VtZW50LnNwbGl0KCcgJylbMV0gOiBwbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB0cGIgPSB7dG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCwgbGVmdDogcG9zLmxlZnQgKyBwb3Mud2lkdGggLyAyIC0gYWN0dWFsV2lkdGggLyAyfTtcbiAgICAgICAgICAgICAgICB0cHQgPSB7dG9wOiBwb3MudG9wIC0gYWN0dWFsSGVpZ2h0LCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDJ9O1xuICAgICAgICAgICAgICAgIHRwbCA9IHt0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0IC0gYWN0dWFsV2lkdGh9O1xuICAgICAgICAgICAgICAgIHRwciA9IHt0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRofTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRwYi50b3AgKyBhY3R1YWxIZWlnaHQpID4gKCQod2luZG93KS5zY3JvbGxUb3AoKSArICQod2luZG93KS5oZWlnaHQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHB0LnRvcCA+ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0cHIubGVmdCArIGFjdHVhbFdpZHRoKSA8ICgkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgJCh3aW5kb3cpLndpZHRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cGwubGVmdCA+ICQod2luZG93KS5zY3JvbGxMZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHB0LnRvcCA8ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHBiLnRvcCArIGFjdHVhbEhlaWdodCkgPCAoJCh3aW5kb3cpLnNjcm9sbFRvcCgpICsgJCh3aW5kb3cpLmhlaWdodCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0cHIubGVmdCArIGFjdHVhbFdpZHRoKSA8ICgkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgJCh3aW5kb3cpLndpZHRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cGwubGVmdCA+ICQod2luZG93KS5zY3JvbGxMZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRwbC5sZWZ0IDwgJCh3aW5kb3cpLnNjcm9sbExlZnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHByLmxlZnQgKyBhY3R1YWxXaWR0aCkgPCAoJCh3aW5kb3cpLnNjcm9sbExlZnQoKSArICQod2luZG93KS53aWR0aCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHB0LnRvcCA+ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRwdC50b3AgPiAkKHdpbmRvdykuc2Nyb2xsVG9wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0cHIubGVmdCArIGFjdHVhbFdpZHRoKSA+ICgkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgJCh3aW5kb3cpLndpZHRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRwbC5sZWZ0ID4gJCh3aW5kb3cpLnNjcm9sbExlZnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cHQudG9wID4gJCh3aW5kb3cpLnNjcm9sbFRvcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICd0b3AnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHB0LnRvcCA+ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHAgPSB0cGI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwID0gdHB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHAgPSB0cGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHAgPSB0cHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkdGlwXG4gICAgICAgICAgICAgICAgLm9mZnNldCh0cClcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnaW4nKTtcbiAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciAkdGlwID0gdGhpcy50aXAoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQuY2FsbCh0aGlzLCAkdGlwWzBdLCB0aGlzLiRlbGVtZW50WzBdKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBsYWNlbWVudDsgICAgICAgICAgICBcblxuICAgICAgICAgICAgdmFyIGF1dG9Ub2tlbiA9IC9cXHM/YXV0bz9cXHM/L2k7XG4gICAgICAgICAgICB2YXIgYXV0b1BsYWNlID0gYXV0b1Rva2VuLnRlc3QocGxhY2VtZW50KTtcbiAgICAgICAgICAgIGlmIChhdXRvUGxhY2UpIHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQucmVwbGFjZShhdXRvVG9rZW4sICcnKSB8fCAndG9wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgdmFyIGFjdHVhbFdpZHRoID0gJHRpcFswXS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHZhciBhY3R1YWxIZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgaWYgKGF1dG9QbGFjZSkge1xuICAgICAgICAgICAgICAgIHZhciAkcGFyZW50ID0gdGhpcy4kZWxlbWVudC5wYXJlbnQoKTtcblxuICAgICAgICAgICAgICAgIHZhciBvcmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGRvY1Njcm9sbCAgICA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFdpZHRoICA9IHRoaXMub3B0aW9ucy5jb250YWluZXIgPT0gJ2JvZHknID8gd2luZG93LmlubmVyV2lkdGggIDogJHBhcmVudC5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEhlaWdodCA9IHRoaXMub3B0aW9ucy5jb250YWluZXIgPT0gJ2JvZHknID8gd2luZG93LmlubmVySGVpZ2h0IDogJHBhcmVudC5vdXRlckhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRMZWZ0ICAgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyID09ICdib2R5JyA/IDAgOiAkcGFyZW50Lm9mZnNldCgpLmxlZnQ7XG5cbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQgPT0gJ2JvdHRvbScgJiYgcG9zLnRvcCAgICsgcG9zLmhlaWdodCAgKyBhY3R1YWxIZWlnaHQgLSBkb2NTY3JvbGwgPiBwYXJlbnRIZWlnaHQgID8gJ3RvcCcgICAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICAmJiBwb3MudG9wICAgLSBkb2NTY3JvbGwgICAtIGFjdHVhbEhlaWdodCA8IDAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm90dG9tJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICdyaWdodCcgICYmIHBvcy5yaWdodCArIGFjdHVhbFdpZHRoID4gcGFyZW50V2lkdGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdsZWZ0JyAgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ2xlZnQnICAgJiYgcG9zLmxlZnQgIC0gYWN0dWFsV2lkdGggPCBwYXJlbnRMZWZ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3JpZ2h0JyAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDtcblxuICAgICAgICAgICAgICAgICR0aXBcbiAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhvcmdQbGFjZW1lbnQpXG4gICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlZE9mZnNldCA9IHRoaXMuZ2V0Q2FsY3VsYXRlZE9mZnNldChwbGFjZW1lbnQsIHBvcywgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoY2FsY3VsYXRlZE9mZnNldCwgcGxhY2VtZW50KTsgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSkuY2FsbCh0aGlzLmNvbnRhaW5lcigpKTtcbiAgICAgICAgICAvKmpzaGludCBsYXhjb21tYTogZmFsc2UsIGVxZXFlcTogdHJ1ZSovICBcbiAgICAgICAgfSAgICAgICAgICAgIFxuICAgIH0pO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBib290c3RyYXAtZGF0ZXBpY2tlci5qc1xuICogaHR0cDovL3d3dy5leWVjb24ucm8vYm9vdHN0cmFwLWRhdGVwaWNrZXJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTIgU3RlZmFuIFBldHJlXG4gKiBJbXByb3ZlbWVudHMgYnkgQW5kcmV3IFJvd2xzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuKGZ1bmN0aW9uKCAkICkge1xuXG5cdGZ1bmN0aW9uIFVUQ0RhdGUoKXtcblx0XHRyZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkoRGF0ZSwgYXJndW1lbnRzKSk7XG5cdH1cblx0ZnVuY3Rpb24gVVRDVG9kYXkoKXtcblx0XHR2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuXHRcdHJldHVybiBVVENEYXRlKHRvZGF5LmdldFVUQ0Z1bGxZZWFyKCksIHRvZGF5LmdldFVUQ01vbnRoKCksIHRvZGF5LmdldFVUQ0RhdGUoKSk7XG5cdH1cblxuXHQvLyBQaWNrZXIgb2JqZWN0XG5cblx0dmFyIERhdGVwaWNrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKG9wdGlvbnMpO1xuXG5cdFx0dGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcblx0XHR0aGlzLmlzSW5saW5lID0gZmFsc2U7XG5cdFx0dGhpcy5pc0lucHV0ID0gdGhpcy5lbGVtZW50LmlzKCdpbnB1dCcpO1xuXHRcdHRoaXMuY29tcG9uZW50ID0gdGhpcy5lbGVtZW50LmlzKCcuZGF0ZScpID8gdGhpcy5lbGVtZW50LmZpbmQoJy5hZGQtb24sIC5idG4nKSA6IGZhbHNlO1xuXHRcdHRoaXMuaGFzSW5wdXQgPSB0aGlzLmNvbXBvbmVudCAmJiB0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKS5sZW5ndGg7XG5cdFx0aWYodGhpcy5jb21wb25lbnQgJiYgdGhpcy5jb21wb25lbnQubGVuZ3RoID09PSAwKVxuXHRcdFx0dGhpcy5jb21wb25lbnQgPSBmYWxzZTtcblxuXHRcdHRoaXMucGlja2VyID0gJChEUEdsb2JhbC50ZW1wbGF0ZSk7XG5cdFx0dGhpcy5fYnVpbGRFdmVudHMoKTtcblx0XHR0aGlzLl9hdHRhY2hFdmVudHMoKTtcblxuXHRcdGlmKHRoaXMuaXNJbmxpbmUpIHtcblx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLWlubGluZScpLmFwcGVuZFRvKHRoaXMuZWxlbWVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLWRyb3Bkb3duIGRyb3Bkb3duLW1lbnUnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vLnJ0bCl7XG5cdFx0XHR0aGlzLnBpY2tlci5hZGRDbGFzcygnZGF0ZXBpY2tlci1ydGwnKTtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5wcmV2IGksIC5uZXh0IGknKVxuXHRcdFx0XHRcdFx0LnRvZ2dsZUNsYXNzKCdpY29uLWFycm93LWxlZnQgaWNvbi1hcnJvdy1yaWdodCcpO1xuXHRcdH1cblxuXG5cdFx0dGhpcy52aWV3TW9kZSA9IHRoaXMuby5zdGFydFZpZXc7XG5cblx0XHRpZiAodGhpcy5vLmNhbGVuZGFyV2Vla3MpXG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCd0Zm9vdCB0aC50b2RheScpXG5cdFx0XHRcdFx0XHQuYXR0cignY29sc3BhbicsIGZ1bmN0aW9uKGksIHZhbCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwYXJzZUludCh2YWwpICsgMTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0dGhpcy5fYWxsb3dfdXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLnNldFN0YXJ0RGF0ZSh0aGlzLm8uc3RhcnREYXRlKTtcblx0XHR0aGlzLnNldEVuZERhdGUodGhpcy5vLmVuZERhdGUpO1xuXHRcdHRoaXMuc2V0RGF5c09mV2Vla0Rpc2FibGVkKHRoaXMuby5kYXlzT2ZXZWVrRGlzYWJsZWQpO1xuXG5cdFx0dGhpcy5maWxsRG93KCk7XG5cdFx0dGhpcy5maWxsTW9udGhzKCk7XG5cblx0XHR0aGlzLl9hbGxvd191cGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblx0XHR0aGlzLnNob3dNb2RlKCk7XG5cblx0XHRpZih0aGlzLmlzSW5saW5lKSB7XG5cdFx0XHR0aGlzLnNob3coKTtcblx0XHR9XG5cdH07XG5cblx0RGF0ZXBpY2tlci5wcm90b3R5cGUgPSB7XG5cdFx0Y29uc3RydWN0b3I6IERhdGVwaWNrZXIsXG5cblx0XHRfcHJvY2Vzc19vcHRpb25zOiBmdW5jdGlvbihvcHRzKXtcblx0XHRcdC8vIFN0b3JlIHJhdyBvcHRpb25zIGZvciByZWZlcmVuY2Vcblx0XHRcdHRoaXMuX28gPSAkLmV4dGVuZCh7fSwgdGhpcy5fbywgb3B0cyk7XG5cdFx0XHQvLyBQcm9jZXNzZWQgb3B0aW9uc1xuXHRcdFx0dmFyIG8gPSB0aGlzLm8gPSAkLmV4dGVuZCh7fSwgdGhpcy5fbyk7XG5cblx0XHRcdC8vIENoZWNrIGlmIFwiZGUtREVcIiBzdHlsZSBkYXRlIGlzIGF2YWlsYWJsZSwgaWYgbm90IGxhbmd1YWdlIHNob3VsZFxuXHRcdFx0Ly8gZmFsbGJhY2sgdG8gMiBsZXR0ZXIgY29kZSBlZyBcImRlXCJcblx0XHRcdHZhciBsYW5nID0gby5sYW5ndWFnZTtcblx0XHRcdGlmICghZGF0ZXNbbGFuZ10pIHtcblx0XHRcdFx0bGFuZyA9IGxhbmcuc3BsaXQoJy0nKVswXTtcblx0XHRcdFx0aWYgKCFkYXRlc1tsYW5nXSlcblx0XHRcdFx0XHRsYW5nID0gZGVmYXVsdHMubGFuZ3VhZ2U7XG5cdFx0XHR9XG5cdFx0XHRvLmxhbmd1YWdlID0gbGFuZztcblxuXHRcdFx0c3dpdGNoKG8uc3RhcnRWaWV3KXtcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRjYXNlICdkZWNhZGUnOlxuXHRcdFx0XHRcdG8uc3RhcnRWaWV3ID0gMjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRjYXNlICd5ZWFyJzpcblx0XHRcdFx0XHRvLnN0YXJ0VmlldyA9IDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0by5zdGFydFZpZXcgPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKG8ubWluVmlld01vZGUpIHtcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRjYXNlICdtb250aHMnOlxuXHRcdFx0XHRcdG8ubWluVmlld01vZGUgPSAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdGNhc2UgJ3llYXJzJzpcblx0XHRcdFx0XHRvLm1pblZpZXdNb2RlID0gMjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRvLm1pblZpZXdNb2RlID0gMDtcblx0XHRcdH1cblxuXHRcdFx0by5zdGFydFZpZXcgPSBNYXRoLm1heChvLnN0YXJ0Vmlldywgby5taW5WaWV3TW9kZSk7XG5cblx0XHRcdG8ud2Vla1N0YXJ0ICU9IDc7XG5cdFx0XHRvLndlZWtFbmQgPSAoKG8ud2Vla1N0YXJ0ICsgNikgJSA3KTtcblxuXHRcdFx0dmFyIGZvcm1hdCA9IERQR2xvYmFsLnBhcnNlRm9ybWF0KG8uZm9ybWF0KVxuXHRcdFx0aWYgKG8uc3RhcnREYXRlICE9PSAtSW5maW5pdHkpIHtcblx0XHRcdFx0by5zdGFydERhdGUgPSBEUEdsb2JhbC5wYXJzZURhdGUoby5zdGFydERhdGUsIGZvcm1hdCwgby5sYW5ndWFnZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoby5lbmREYXRlICE9PSBJbmZpbml0eSkge1xuXHRcdFx0XHRvLmVuZERhdGUgPSBEUEdsb2JhbC5wYXJzZURhdGUoby5lbmREYXRlLCBmb3JtYXQsIG8ubGFuZ3VhZ2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRvLmRheXNPZldlZWtEaXNhYmxlZCA9IG8uZGF5c09mV2Vla0Rpc2FibGVkfHxbXTtcblx0XHRcdGlmICghJC5pc0FycmF5KG8uZGF5c09mV2Vla0Rpc2FibGVkKSlcblx0XHRcdFx0by5kYXlzT2ZXZWVrRGlzYWJsZWQgPSBvLmRheXNPZldlZWtEaXNhYmxlZC5zcGxpdCgvWyxcXHNdKi8pO1xuXHRcdFx0by5kYXlzT2ZXZWVrRGlzYWJsZWQgPSAkLm1hcChvLmRheXNPZldlZWtEaXNhYmxlZCwgZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KGQsIDEwKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0X2V2ZW50czogW10sXG5cdFx0X3NlY29uZGFyeUV2ZW50czogW10sXG5cdFx0X2FwcGx5RXZlbnRzOiBmdW5jdGlvbihldnMpe1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBlbCwgZXY7IGk8ZXZzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0ZWwgPSBldnNbaV1bMF07XG5cdFx0XHRcdGV2ID0gZXZzW2ldWzFdO1xuXHRcdFx0XHRlbC5vbihldik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfdW5hcHBseUV2ZW50czogZnVuY3Rpb24oZXZzKXtcblx0XHRcdGZvciAodmFyIGk9MCwgZWwsIGV2OyBpPGV2cy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdGVsID0gZXZzW2ldWzBdO1xuXHRcdFx0XHRldiA9IGV2c1tpXVsxXTtcblx0XHRcdFx0ZWwub2ZmKGV2KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9idWlsZEV2ZW50czogZnVuY3Rpb24oKXtcblx0XHRcdGlmICh0aGlzLmlzSW5wdXQpIHsgLy8gc2luZ2xlIGlucHV0XG5cdFx0XHRcdHRoaXMuX2V2ZW50cyA9IFtcblx0XHRcdFx0XHRbdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdFx0XHRmb2N1czogJC5wcm94eSh0aGlzLnNob3csIHRoaXMpLFxuXHRcdFx0XHRcdFx0a2V5dXA6ICQucHJveHkodGhpcy51cGRhdGUsIHRoaXMpLFxuXHRcdFx0XHRcdFx0a2V5ZG93bjogJC5wcm94eSh0aGlzLmtleWRvd24sIHRoaXMpXG5cdFx0XHRcdFx0fV1cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHRoaXMuY29tcG9uZW50ICYmIHRoaXMuaGFzSW5wdXQpeyAvLyBjb21wb25lbnQ6IGlucHV0ICsgYnV0dG9uXG5cdFx0XHRcdHRoaXMuX2V2ZW50cyA9IFtcblx0XHRcdFx0XHQvLyBGb3IgY29tcG9uZW50cyB0aGF0IGFyZSBub3QgcmVhZG9ubHksIGFsbG93IGtleWJvYXJkIG5hdlxuXHRcdFx0XHRcdFt0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKSwge1xuXHRcdFx0XHRcdFx0Zm9jdXM6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKSxcblx0XHRcdFx0XHRcdGtleXVwOiAkLnByb3h5KHRoaXMudXBkYXRlLCB0aGlzKSxcblx0XHRcdFx0XHRcdGtleWRvd246ICQucHJveHkodGhpcy5rZXlkb3duLCB0aGlzKVxuXHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFt0aGlzLmNvbXBvbmVudCwge1xuXHRcdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKVxuXHRcdFx0XHRcdH1dXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0aGlzLmVsZW1lbnQuaXMoJ2RpdicpKSB7ICAvLyBpbmxpbmUgZGF0ZXBpY2tlclxuXHRcdFx0XHR0aGlzLmlzSW5saW5lID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9ldmVudHMgPSBbXG5cdFx0XHRcdFx0W3RoaXMuZWxlbWVudCwge1xuXHRcdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKVxuXHRcdFx0XHRcdH1dXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NlY29uZGFyeUV2ZW50cyA9IFtcblx0XHRcdFx0W3RoaXMucGlja2VyLCB7XG5cdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5jbGljaywgdGhpcylcblx0XHRcdFx0fV0sXG5cdFx0XHRcdFskKHdpbmRvdyksIHtcblx0XHRcdFx0XHRyZXNpemU6ICQucHJveHkodGhpcy5wbGFjZSwgdGhpcylcblx0XHRcdFx0fV0sXG5cdFx0XHRcdFskKGRvY3VtZW50KSwge1xuXHRcdFx0XHRcdG1vdXNlZG93bjogJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0Ly8gQ2xpY2tlZCBvdXRzaWRlIHRoZSBkYXRlcGlja2VyLCBoaWRlIGl0XG5cdFx0XHRcdFx0XHRpZiAoIShcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmlzKGUudGFyZ2V0KSB8fFxuXHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZChlLnRhcmdldCkuc2l6ZSgpIHx8XG5cdFx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmlzKGUudGFyZ2V0KSB8fFxuXHRcdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKGUudGFyZ2V0KS5zaXplKClcblx0XHRcdFx0XHRcdCkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcylcblx0XHRcdFx0fV1cblx0XHRcdF07XG5cdFx0fSxcblx0XHRfYXR0YWNoRXZlbnRzOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5fZGV0YWNoRXZlbnRzKCk7XG5cdFx0XHR0aGlzLl9hcHBseUV2ZW50cyh0aGlzLl9ldmVudHMpO1xuXHRcdH0sXG5cdFx0X2RldGFjaEV2ZW50czogZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuX3VuYXBwbHlFdmVudHModGhpcy5fZXZlbnRzKTtcblx0XHR9LFxuXHRcdF9hdHRhY2hTZWNvbmRhcnlFdmVudHM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLl9kZXRhY2hTZWNvbmRhcnlFdmVudHMoKTtcblx0XHRcdHRoaXMuX2FwcGx5RXZlbnRzKHRoaXMuX3NlY29uZGFyeUV2ZW50cyk7XG5cdFx0fSxcblx0XHRfZGV0YWNoU2Vjb25kYXJ5RXZlbnRzOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5fdW5hcHBseUV2ZW50cyh0aGlzLl9zZWNvbmRhcnlFdmVudHMpO1xuXHRcdH0sXG5cdFx0X3RyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50LCBhbHRkYXRlKXtcblx0XHRcdHZhciBkYXRlID0gYWx0ZGF0ZSB8fCB0aGlzLmRhdGUsXG5cdFx0XHRcdGxvY2FsX2RhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkqNjAwMDApKTtcblxuXHRcdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoe1xuXHRcdFx0XHR0eXBlOiBldmVudCxcblx0XHRcdFx0ZGF0ZTogbG9jYWxfZGF0ZSxcblx0XHRcdFx0Zm9ybWF0OiAkLnByb3h5KGZ1bmN0aW9uKGFsdGZvcm1hdCl7XG5cdFx0XHRcdFx0dmFyIGZvcm1hdCA9IGFsdGZvcm1hdCB8fCB0aGlzLm8uZm9ybWF0O1xuXHRcdFx0XHRcdHJldHVybiBEUEdsb2JhbC5mb3JtYXREYXRlKGRhdGUsIGZvcm1hdCwgdGhpcy5vLmxhbmd1YWdlKTtcblx0XHRcdFx0fSwgdGhpcylcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRzaG93OiBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoIXRoaXMuaXNJbmxpbmUpXG5cdFx0XHRcdHRoaXMucGlja2VyLmFwcGVuZFRvKCdib2R5Jyk7XG5cdFx0XHR0aGlzLnBpY2tlci5zaG93KCk7XG5cdFx0XHR0aGlzLmhlaWdodCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQub3V0ZXJIZWlnaHQoKSA6IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpO1xuXHRcdFx0dGhpcy5wbGFjZSgpO1xuXHRcdFx0dGhpcy5fYXR0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XG5cdFx0XHRpZiAoZSkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCdzaG93Jyk7XG5cdFx0fSxcblxuXHRcdGhpZGU6IGZ1bmN0aW9uKGUpe1xuXHRcdFx0aWYodGhpcy5pc0lubGluZSkgcmV0dXJuO1xuXHRcdFx0aWYgKCF0aGlzLnBpY2tlci5pcygnOnZpc2libGUnKSkgcmV0dXJuO1xuXHRcdFx0dGhpcy5waWNrZXIuaGlkZSgpLmRldGFjaCgpO1xuXHRcdFx0dGhpcy5fZGV0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XG5cdFx0XHR0aGlzLnZpZXdNb2RlID0gdGhpcy5vLnN0YXJ0Vmlldztcblx0XHRcdHRoaXMuc2hvd01vZGUoKTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0aGlzLm8uZm9yY2VQYXJzZSAmJlxuXHRcdFx0XHQoXG5cdFx0XHRcdFx0dGhpcy5pc0lucHV0ICYmIHRoaXMuZWxlbWVudC52YWwoKSB8fFxuXHRcdFx0XHRcdHRoaXMuaGFzSW5wdXQgJiYgdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0JykudmFsKClcblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdFx0XHR0aGlzLnNldFZhbHVlKCk7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCdoaWRlJyk7XG5cdFx0fSxcblxuXHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdHRoaXMuX2RldGFjaEV2ZW50cygpO1xuXHRcdFx0dGhpcy5fZGV0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XG5cdFx0XHR0aGlzLnBpY2tlci5yZW1vdmUoKTtcblx0XHRcdGRlbGV0ZSB0aGlzLmVsZW1lbnQuZGF0YSgpLmRhdGVwaWNrZXI7XG5cdFx0XHRpZiAoIXRoaXMuaXNJbnB1dCkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5lbGVtZW50LmRhdGEoKS5kYXRlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXREYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkID0gdGhpcy5nZXRVVENEYXRlKCk7XG5cdFx0XHRyZXR1cm4gbmV3IERhdGUoZC5nZXRUaW1lKCkgKyAoZC5nZXRUaW1lem9uZU9mZnNldCgpKjYwMDAwKSk7XG5cdFx0fSxcblxuXHRcdGdldFVUQ0RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0ZTtcblx0XHR9LFxuXG5cdFx0c2V0RGF0ZTogZnVuY3Rpb24oZCkge1xuXHRcdFx0dGhpcy5zZXRVVENEYXRlKG5ldyBEYXRlKGQuZ2V0VGltZSgpIC0gKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMCkpKTtcblx0XHR9LFxuXG5cdFx0c2V0VVRDRGF0ZTogZnVuY3Rpb24oZCkge1xuXHRcdFx0dGhpcy5kYXRlID0gZDtcblx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcblx0XHR9LFxuXG5cdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGZvcm1hdHRlZCA9IHRoaXMuZ2V0Rm9ybWF0dGVkRGF0ZSgpO1xuXHRcdFx0aWYgKCF0aGlzLmlzSW5wdXQpIHtcblx0XHRcdFx0aWYgKHRoaXMuY29tcG9uZW50KXtcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKS52YWwoZm9ybWF0dGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnZhbChmb3JtYXR0ZWQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRGb3JtYXR0ZWREYXRlOiBmdW5jdGlvbihmb3JtYXQpIHtcblx0XHRcdGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0Zm9ybWF0ID0gdGhpcy5vLmZvcm1hdDtcblx0XHRcdHJldHVybiBEUEdsb2JhbC5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgZm9ybWF0LCB0aGlzLm8ubGFuZ3VhZ2UpO1xuXHRcdH0sXG5cblx0XHRzZXRTdGFydERhdGU6IGZ1bmN0aW9uKHN0YXJ0RGF0ZSl7XG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe3N0YXJ0RGF0ZTogc3RhcnREYXRlfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcblx0XHR9LFxuXG5cdFx0c2V0RW5kRGF0ZTogZnVuY3Rpb24oZW5kRGF0ZSl7XG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe2VuZERhdGU6IGVuZERhdGV9KTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xuXHRcdH0sXG5cblx0XHRzZXREYXlzT2ZXZWVrRGlzYWJsZWQ6IGZ1bmN0aW9uKGRheXNPZldlZWtEaXNhYmxlZCl7XG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe2RheXNPZldlZWtEaXNhYmxlZDogZGF5c09mV2Vla0Rpc2FibGVkfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcblx0XHR9LFxuXG5cdFx0cGxhY2U6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRpZih0aGlzLmlzSW5saW5lKSByZXR1cm47XG5cdFx0XHR2YXIgekluZGV4ID0gcGFyc2VJbnQodGhpcy5lbGVtZW50LnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAkKHRoaXMpLmNzcygnei1pbmRleCcpICE9ICdhdXRvJztcblx0XHRcdFx0XHRcdH0pLmZpcnN0KCkuY3NzKCd6LWluZGV4JykpKzEwO1xuXHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQucGFyZW50KCkub2Zmc2V0KCkgOiB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XG5cdFx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5jb21wb25lbnQgPyB0aGlzLmNvbXBvbmVudC5vdXRlckhlaWdodCh0cnVlKSA6IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCh0cnVlKTtcblx0XHRcdHRoaXMucGlja2VyLmNzcyh7XG5cdFx0XHRcdHRvcDogb2Zmc2V0LnRvcCArIGhlaWdodCxcblx0XHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQsXG5cdFx0XHRcdHpJbmRleDogekluZGV4XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0X2FsbG93X3VwZGF0ZTogdHJ1ZSxcblx0XHR1cGRhdGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAoIXRoaXMuX2FsbG93X3VwZGF0ZSkgcmV0dXJuO1xuXG5cdFx0XHR2YXIgZGF0ZSwgZnJvbUFyZ3MgPSBmYWxzZTtcblx0XHRcdGlmKGFyZ3VtZW50cyAmJiBhcmd1bWVudHMubGVuZ3RoICYmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJyB8fCBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBEYXRlKSkge1xuXHRcdFx0XHRkYXRlID0gYXJndW1lbnRzWzBdO1xuXHRcdFx0XHRmcm9tQXJncyA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRlID0gdGhpcy5pc0lucHV0ID8gdGhpcy5lbGVtZW50LnZhbCgpIDogdGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUnKSB8fCB0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKS52YWwoKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRhKCkuZGF0ZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5kYXRlID0gRFBHbG9iYWwucGFyc2VEYXRlKGRhdGUsIHRoaXMuby5mb3JtYXQsIHRoaXMuby5sYW5ndWFnZSk7XG5cblx0XHRcdGlmKGZyb21BcmdzKSB0aGlzLnNldFZhbHVlKCk7XG5cblx0XHRcdGlmICh0aGlzLmRhdGUgPCB0aGlzLm8uc3RhcnREYXRlKSB7XG5cdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLm8uc3RhcnREYXRlKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5kYXRlID4gdGhpcy5vLmVuZERhdGUpIHtcblx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuby5lbmREYXRlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLmRhdGUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5maWxsKCk7XG5cdFx0fSxcblxuXHRcdGZpbGxEb3c6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgZG93Q250ID0gdGhpcy5vLndlZWtTdGFydCxcblx0XHRcdGh0bWwgPSAnPHRyPic7XG5cdFx0XHRpZih0aGlzLm8uY2FsZW5kYXJXZWVrcyl7XG5cdFx0XHRcdHZhciBjZWxsID0gJzx0aCBjbGFzcz1cImN3XCI+Jm5ic3A7PC90aD4nO1xuXHRcdFx0XHRodG1sICs9IGNlbGw7XG5cdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQgdHI6Zmlyc3QtY2hpbGQnKS5wcmVwZW5kKGNlbGwpO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGRvd0NudCA8IHRoaXMuby53ZWVrU3RhcnQgKyA3KSB7XG5cdFx0XHRcdGh0bWwgKz0gJzx0aCBjbGFzcz1cImRvd1wiPicrZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5kYXlzTWluWyhkb3dDbnQrKyklN10rJzwvdGg+Jztcblx0XHRcdH1cblx0XHRcdGh0bWwgKz0gJzwvdHI+Jztcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQnKS5hcHBlbmQoaHRtbCk7XG5cdFx0fSxcblxuXHRcdGZpbGxNb250aHM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgaHRtbCA9ICcnLFxuXHRcdFx0aSA9IDA7XG5cdFx0XHR3aGlsZSAoaSA8IDEyKSB7XG5cdFx0XHRcdGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwibW9udGhcIj4nK2RhdGVzW3RoaXMuby5sYW5ndWFnZV0ubW9udGhzU2hvcnRbaSsrXSsnPC9zcGFuPic7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMgdGQnKS5odG1sKGh0bWwpO1xuXHRcdH0sXG5cblx0XHRzZXRSYW5nZTogZnVuY3Rpb24ocmFuZ2Upe1xuXHRcdFx0aWYgKCFyYW5nZSB8fCAhcmFuZ2UubGVuZ3RoKVxuXHRcdFx0XHRkZWxldGUgdGhpcy5yYW5nZTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhpcy5yYW5nZSA9ICQubWFwKHJhbmdlLCBmdW5jdGlvbihkKXsgcmV0dXJuIGQudmFsdWVPZigpOyB9KTtcblx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdH0sXG5cblx0XHRnZXRDbGFzc05hbWVzOiBmdW5jdGlvbihkYXRlKXtcblx0XHRcdHZhciBjbHMgPSBbXSxcblx0XHRcdFx0eWVhciA9IHRoaXMudmlld0RhdGUuZ2V0VVRDRnVsbFllYXIoKSxcblx0XHRcdFx0bW9udGggPSB0aGlzLnZpZXdEYXRlLmdldFVUQ01vbnRoKCksXG5cdFx0XHRcdGN1cnJlbnREYXRlID0gdGhpcy5kYXRlLnZhbHVlT2YoKSxcblx0XHRcdFx0dG9kYXkgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0aWYgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA8IHllYXIgfHwgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA9PSB5ZWFyICYmIGRhdGUuZ2V0VVRDTW9udGgoKSA8IG1vbnRoKSkge1xuXHRcdFx0XHRjbHMucHVzaCgnb2xkJyk7XG5cdFx0XHR9IGVsc2UgaWYgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA+IHllYXIgfHwgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA9PSB5ZWFyICYmIGRhdGUuZ2V0VVRDTW9udGgoKSA+IG1vbnRoKSkge1xuXHRcdFx0XHRjbHMucHVzaCgnbmV3Jyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDb21wYXJlIGludGVybmFsIFVUQyBkYXRlIHdpdGggbG9jYWwgdG9kYXksIG5vdCBVVEMgdG9kYXlcblx0XHRcdGlmICh0aGlzLm8udG9kYXlIaWdobGlnaHQgJiZcblx0XHRcdFx0ZGF0ZS5nZXRVVENGdWxsWWVhcigpID09IHRvZGF5LmdldEZ1bGxZZWFyKCkgJiZcblx0XHRcdFx0ZGF0ZS5nZXRVVENNb250aCgpID09IHRvZGF5LmdldE1vbnRoKCkgJiZcblx0XHRcdFx0ZGF0ZS5nZXRVVENEYXRlKCkgPT0gdG9kYXkuZ2V0RGF0ZSgpKSB7XG5cdFx0XHRcdGNscy5wdXNoKCd0b2RheScpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnREYXRlICYmIGRhdGUudmFsdWVPZigpID09IGN1cnJlbnREYXRlKSB7XG5cdFx0XHRcdGNscy5wdXNoKCdhY3RpdmUnKTtcblx0XHRcdH1cblx0XHRcdGlmIChkYXRlLnZhbHVlT2YoKSA8IHRoaXMuby5zdGFydERhdGUgfHwgZGF0ZS52YWx1ZU9mKCkgPiB0aGlzLm8uZW5kRGF0ZSB8fFxuXHRcdFx0XHQkLmluQXJyYXkoZGF0ZS5nZXRVVENEYXkoKSwgdGhpcy5vLmRheXNPZldlZWtEaXNhYmxlZCkgIT09IC0xKSB7XG5cdFx0XHRcdGNscy5wdXNoKCdkaXNhYmxlZCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMucmFuZ2Upe1xuXHRcdFx0XHRpZiAoZGF0ZSA+IHRoaXMucmFuZ2VbMF0gJiYgZGF0ZSA8IHRoaXMucmFuZ2VbdGhpcy5yYW5nZS5sZW5ndGgtMV0pe1xuXHRcdFx0XHRcdGNscy5wdXNoKCdyYW5nZScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgkLmluQXJyYXkoZGF0ZS52YWx1ZU9mKCksIHRoaXMucmFuZ2UpICE9IC0xKXtcblx0XHRcdFx0XHRjbHMucHVzaCgnc2VsZWN0ZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNscztcblx0XHR9LFxuXG5cdFx0ZmlsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZCA9IG5ldyBEYXRlKHRoaXMudmlld0RhdGUpLFxuXHRcdFx0XHR5ZWFyID0gZC5nZXRVVENGdWxsWWVhcigpLFxuXHRcdFx0XHRtb250aCA9IGQuZ2V0VVRDTW9udGgoKSxcblx0XHRcdFx0c3RhcnRZZWFyID0gdGhpcy5vLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5ID8gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENGdWxsWWVhcigpIDogLUluZmluaXR5LFxuXHRcdFx0XHRzdGFydE1vbnRoID0gdGhpcy5vLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5ID8gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENNb250aCgpIDogLUluZmluaXR5LFxuXHRcdFx0XHRlbmRZZWFyID0gdGhpcy5vLmVuZERhdGUgIT09IEluZmluaXR5ID8gdGhpcy5vLmVuZERhdGUuZ2V0VVRDRnVsbFllYXIoKSA6IEluZmluaXR5LFxuXHRcdFx0XHRlbmRNb250aCA9IHRoaXMuby5lbmREYXRlICE9PSBJbmZpbml0eSA/IHRoaXMuby5lbmREYXRlLmdldFVUQ01vbnRoKCkgOiBJbmZpbml0eSxcblx0XHRcdFx0Y3VycmVudERhdGUgPSB0aGlzLmRhdGUgJiYgdGhpcy5kYXRlLnZhbHVlT2YoKSxcblx0XHRcdFx0dG9vbHRpcDtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQgdGguZGF0ZXBpY2tlci1zd2l0Y2gnKVxuXHRcdFx0XHRcdFx0LnRleHQoZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5tb250aHNbbW9udGhdKycgJyt5ZWFyKTtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJ3Rmb290IHRoLnRvZGF5Jylcblx0XHRcdFx0XHRcdC50ZXh0KGRhdGVzW3RoaXMuby5sYW5ndWFnZV0udG9kYXkpXG5cdFx0XHRcdFx0XHQudG9nZ2xlKHRoaXMuby50b2RheUJ0biAhPT0gZmFsc2UpO1xuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgndGZvb3QgdGguY2xlYXInKVxuXHRcdFx0XHRcdFx0LnRleHQoZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5jbGVhcilcblx0XHRcdFx0XHRcdC50b2dnbGUodGhpcy5vLmNsZWFyQnRuICE9PSBmYWxzZSk7XG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xuXHRcdFx0dGhpcy5maWxsTW9udGhzKCk7XG5cdFx0XHR2YXIgcHJldk1vbnRoID0gVVRDRGF0ZSh5ZWFyLCBtb250aC0xLCAyOCwwLDAsMCwwKSxcblx0XHRcdFx0ZGF5ID0gRFBHbG9iYWwuZ2V0RGF5c0luTW9udGgocHJldk1vbnRoLmdldFVUQ0Z1bGxZZWFyKCksIHByZXZNb250aC5nZXRVVENNb250aCgpKTtcblx0XHRcdHByZXZNb250aC5zZXRVVENEYXRlKGRheSk7XG5cdFx0XHRwcmV2TW9udGguc2V0VVRDRGF0ZShkYXkgLSAocHJldk1vbnRoLmdldFVUQ0RheSgpIC0gdGhpcy5vLndlZWtTdGFydCArIDcpJTcpO1xuXHRcdFx0dmFyIG5leHRNb250aCA9IG5ldyBEYXRlKHByZXZNb250aCk7XG5cdFx0XHRuZXh0TW9udGguc2V0VVRDRGF0ZShuZXh0TW9udGguZ2V0VVRDRGF0ZSgpICsgNDIpO1xuXHRcdFx0bmV4dE1vbnRoID0gbmV4dE1vbnRoLnZhbHVlT2YoKTtcblx0XHRcdHZhciBodG1sID0gW107XG5cdFx0XHR2YXIgY2xzTmFtZTtcblx0XHRcdHdoaWxlKHByZXZNb250aC52YWx1ZU9mKCkgPCBuZXh0TW9udGgpIHtcblx0XHRcdFx0aWYgKHByZXZNb250aC5nZXRVVENEYXkoKSA9PSB0aGlzLm8ud2Vla1N0YXJ0KSB7XG5cdFx0XHRcdFx0aHRtbC5wdXNoKCc8dHI+Jyk7XG5cdFx0XHRcdFx0aWYodGhpcy5vLmNhbGVuZGFyV2Vla3Mpe1xuXHRcdFx0XHRcdFx0Ly8gSVNPIDg2MDE6IEZpcnN0IHdlZWsgY29udGFpbnMgZmlyc3QgdGh1cnNkYXkuXG5cdFx0XHRcdFx0XHQvLyBJU08gYWxzbyBzdGF0ZXMgd2VlayBzdGFydHMgb24gTW9uZGF5LCBidXQgd2UgY2FuIGJlIG1vcmUgYWJzdHJhY3QgaGVyZS5cblx0XHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0XHQvLyBTdGFydCBvZiBjdXJyZW50IHdlZWs6IGJhc2VkIG9uIHdlZWtzdGFydC9jdXJyZW50IGRhdGVcblx0XHRcdFx0XHRcdFx0d3MgPSBuZXcgRGF0ZSgrcHJldk1vbnRoICsgKHRoaXMuby53ZWVrU3RhcnQgLSBwcmV2TW9udGguZ2V0VVRDRGF5KCkgLSA3KSAlIDcgKiA4NjRlNSksXG5cdFx0XHRcdFx0XHRcdC8vIFRodXJzZGF5IG9mIHRoaXMgd2Vla1xuXHRcdFx0XHRcdFx0XHR0aCA9IG5ldyBEYXRlKCt3cyArICg3ICsgNCAtIHdzLmdldFVUQ0RheSgpKSAlIDcgKiA4NjRlNSksXG5cdFx0XHRcdFx0XHRcdC8vIEZpcnN0IFRodXJzZGF5IG9mIHllYXIsIHllYXIgZnJvbSB0aHVyc2RheVxuXHRcdFx0XHRcdFx0XHR5dGggPSBuZXcgRGF0ZSgrKHl0aCA9IFVUQ0RhdGUodGguZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpICsgKDcgKyA0IC0geXRoLmdldFVUQ0RheSgpKSU3Kjg2NGU1KSxcblx0XHRcdFx0XHRcdFx0Ly8gQ2FsZW5kYXIgd2VlazogbXMgYmV0d2VlbiB0aHVyc2RheXMsIGRpdiBtcyBwZXIgZGF5LCBkaXYgNyBkYXlzXG5cdFx0XHRcdFx0XHRcdGNhbFdlZWsgPSAgKHRoIC0geXRoKSAvIDg2NGU1IC8gNyArIDE7XG5cdFx0XHRcdFx0XHRodG1sLnB1c2goJzx0ZCBjbGFzcz1cImN3XCI+JysgY2FsV2VlayArJzwvdGQ+Jyk7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2xzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lcyhwcmV2TW9udGgpO1xuXHRcdFx0XHRjbHNOYW1lLnB1c2goJ2RheScpO1xuXG5cdFx0XHRcdHZhciBiZWZvcmUgPSB0aGlzLm8uYmVmb3JlU2hvd0RheShwcmV2TW9udGgpO1xuXHRcdFx0XHRpZiAoYmVmb3JlID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0YmVmb3JlID0ge307XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZihiZWZvcmUpID09PSAnYm9vbGVhbicpXG5cdFx0XHRcdFx0YmVmb3JlID0ge2VuYWJsZWQ6IGJlZm9yZX07XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZihiZWZvcmUpID09PSAnc3RyaW5nJylcblx0XHRcdFx0XHRiZWZvcmUgPSB7Y2xhc3NlczogYmVmb3JlfTtcblx0XHRcdFx0aWYgKGJlZm9yZS5lbmFibGVkID09PSBmYWxzZSlcblx0XHRcdFx0XHRjbHNOYW1lLnB1c2goJ2Rpc2FibGVkJyk7XG5cdFx0XHRcdGlmIChiZWZvcmUuY2xhc3Nlcylcblx0XHRcdFx0XHRjbHNOYW1lID0gY2xzTmFtZS5jb25jYXQoYmVmb3JlLmNsYXNzZXMuc3BsaXQoL1xccysvKSk7XG5cdFx0XHRcdGlmIChiZWZvcmUudG9vbHRpcClcblx0XHRcdFx0XHR0b29sdGlwID0gYmVmb3JlLnRvb2x0aXA7XG5cblx0XHRcdFx0Y2xzTmFtZSA9ICQudW5pcXVlKGNsc05hbWUpO1xuXHRcdFx0XHRodG1sLnB1c2goJzx0ZCBjbGFzcz1cIicrY2xzTmFtZS5qb2luKCcgJykrJ1wiJyArICh0b29sdGlwID8gJyB0aXRsZT1cIicrdG9vbHRpcCsnXCInIDogJycpICsgJz4nK3ByZXZNb250aC5nZXRVVENEYXRlKCkgKyAnPC90ZD4nKTtcblx0XHRcdFx0aWYgKHByZXZNb250aC5nZXRVVENEYXkoKSA9PSB0aGlzLm8ud2Vla0VuZCkge1xuXHRcdFx0XHRcdGh0bWwucHVzaCgnPC90cj4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcmV2TW9udGguc2V0VVRDRGF0ZShwcmV2TW9udGguZ2V0VVRDRGF0ZSgpKzEpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItZGF5cyB0Ym9keScpLmVtcHR5KCkuYXBwZW5kKGh0bWwuam9pbignJykpO1xuXHRcdFx0dmFyIGN1cnJlbnRZZWFyID0gdGhpcy5kYXRlICYmIHRoaXMuZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuXG5cdFx0XHR2YXIgbW9udGhzID0gdGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzJylcblx0XHRcdFx0XHRcdC5maW5kKCd0aDplcSgxKScpXG5cdFx0XHRcdFx0XHRcdC50ZXh0KHllYXIpXG5cdFx0XHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdFx0LmZpbmQoJ3NwYW4nKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cdFx0XHRpZiAoY3VycmVudFllYXIgJiYgY3VycmVudFllYXIgPT0geWVhcikge1xuXHRcdFx0XHRtb250aHMuZXEodGhpcy5kYXRlLmdldFVUQ01vbnRoKCkpLmFkZENsYXNzKCdhY3RpdmUnKTtcblx0XHRcdH1cblx0XHRcdGlmICh5ZWFyIDwgc3RhcnRZZWFyIHx8IHllYXIgPiBlbmRZZWFyKSB7XG5cdFx0XHRcdG1vbnRocy5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblx0XHRcdH1cblx0XHRcdGlmICh5ZWFyID09IHN0YXJ0WWVhcikge1xuXHRcdFx0XHRtb250aHMuc2xpY2UoMCwgc3RhcnRNb250aCkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoeWVhciA9PSBlbmRZZWFyKSB7XG5cdFx0XHRcdG1vbnRocy5zbGljZShlbmRNb250aCsxKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblx0XHRcdH1cblxuXHRcdFx0aHRtbCA9ICcnO1xuXHRcdFx0eWVhciA9IHBhcnNlSW50KHllYXIvMTAsIDEwKSAqIDEwO1xuXHRcdFx0dmFyIHllYXJDb250ID0gdGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXIteWVhcnMnKVxuXHRcdFx0XHRcdFx0XHRcdC5maW5kKCd0aDplcSgxKScpXG5cdFx0XHRcdFx0XHRcdFx0XHQudGV4dCh5ZWFyICsgJy0nICsgKHllYXIgKyA5KSlcblx0XHRcdFx0XHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdFx0XHRcdC5maW5kKCd0ZCcpO1xuXHRcdFx0eWVhciAtPSAxO1xuXHRcdFx0Zm9yICh2YXIgaSA9IC0xOyBpIDwgMTE7IGkrKykge1xuXHRcdFx0XHRodG1sICs9ICc8c3BhbiBjbGFzcz1cInllYXInKyhpID09IC0xID8gJyBvbGQnIDogaSA9PSAxMCA/ICcgbmV3JyA6ICcnKSsoY3VycmVudFllYXIgPT0geWVhciA/ICcgYWN0aXZlJyA6ICcnKSsoeWVhciA8IHN0YXJ0WWVhciB8fCB5ZWFyID4gZW5kWWVhciA/ICcgZGlzYWJsZWQnIDogJycpKydcIj4nK3llYXIrJzwvc3Bhbj4nO1xuXHRcdFx0XHR5ZWFyICs9IDE7XG5cdFx0XHR9XG5cdFx0XHR5ZWFyQ29udC5odG1sKGh0bWwpO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVOYXZBcnJvd3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9hbGxvd191cGRhdGUpIHJldHVybjtcblxuXHRcdFx0dmFyIGQgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKSxcblx0XHRcdFx0eWVhciA9IGQuZ2V0VVRDRnVsbFllYXIoKSxcblx0XHRcdFx0bW9udGggPSBkLmdldFVUQ01vbnRoKCk7XG5cdFx0XHRzd2l0Y2ggKHRoaXMudmlld01vZGUpIHtcblx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdGlmICh0aGlzLm8uc3RhcnREYXRlICE9PSAtSW5maW5pdHkgJiYgeWVhciA8PSB0aGlzLm8uc3RhcnREYXRlLmdldFVUQ0Z1bGxZZWFyKCkgJiYgbW9udGggPD0gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENNb250aCgpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcucHJldicpLmNzcyh7dmlzaWJpbGl0eTogJ2hpZGRlbid9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLnByZXYnKS5jc3Moe3Zpc2liaWxpdHk6ICd2aXNpYmxlJ30pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5vLmVuZERhdGUgIT09IEluZmluaXR5ICYmIHllYXIgPj0gdGhpcy5vLmVuZERhdGUuZ2V0VVRDRnVsbFllYXIoKSAmJiBtb250aCA+PSB0aGlzLm8uZW5kRGF0ZS5nZXRVVENNb250aCgpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcubmV4dCcpLmNzcyh7dmlzaWJpbGl0eTogJ2hpZGRlbid9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLm5leHQnKS5jc3Moe3Zpc2liaWxpdHk6ICd2aXNpYmxlJ30pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0aWYgKHRoaXMuby5zdGFydERhdGUgIT09IC1JbmZpbml0eSAmJiB5ZWFyIDw9IHRoaXMuby5zdGFydERhdGUuZ2V0VVRDRnVsbFllYXIoKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLnByZXYnKS5jc3Moe3Zpc2liaWxpdHk6ICdoaWRkZW4nfSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5wcmV2JykuY3NzKHt2aXNpYmlsaXR5OiAndmlzaWJsZSd9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuby5lbmREYXRlICE9PSBJbmZpbml0eSAmJiB5ZWFyID49IHRoaXMuby5lbmREYXRlLmdldFVUQ0Z1bGxZZWFyKCkpIHtcblx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5uZXh0JykuY3NzKHt2aXNpYmlsaXR5OiAnaGlkZGVuJ30pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcubmV4dCcpLmNzcyh7dmlzaWJpbGl0eTogJ3Zpc2libGUnfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjbGljazogZnVuY3Rpb24oZSkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dmFyIHRhcmdldCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJ3NwYW4sIHRkLCB0aCcpO1xuXHRcdFx0aWYgKHRhcmdldC5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHRzd2l0Y2godGFyZ2V0WzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRjYXNlICd0aCc6XG5cdFx0XHRcdFx0XHRzd2l0Y2godGFyZ2V0WzBdLmNsYXNzTmFtZSkge1xuXHRcdFx0XHRcdFx0XHRjYXNlICdkYXRlcGlja2VyLXN3aXRjaCc6XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zaG93TW9kZSgxKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAncHJldic6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ25leHQnOlxuXHRcdFx0XHRcdFx0XHRcdHZhciBkaXIgPSBEUEdsb2JhbC5tb2Rlc1t0aGlzLnZpZXdNb2RlXS5uYXZTdGVwICogKHRhcmdldFswXS5jbGFzc05hbWUgPT0gJ3ByZXYnID8gLTEgOiAxKTtcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2godGhpcy52aWV3TW9kZSl7XG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSB0aGlzLm1vdmVNb250aCh0aGlzLnZpZXdEYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IHRoaXMubW92ZVllYXIodGhpcy52aWV3RGF0ZSwgZGlyKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlICd0b2RheSc6XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGUgPSBVVENEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSwgMCwgMCwgMCk7XG5cblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNob3dNb2RlKC0yKTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgd2hpY2ggPSB0aGlzLm8udG9kYXlCdG4gPT0gJ2xpbmtlZCcgPyBudWxsIDogJ3ZpZXcnO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NldERhdGUoZGF0ZSwgd2hpY2gpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlICdjbGVhcic6XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGVsZW1lbnQ7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuaXNJbnB1dClcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAodGhpcy5jb21wb25lbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0Jyk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtZW50LnZhbChcIlwiKS5jaGFuZ2UoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VEYXRlJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5vLmF1dG9jbG9zZSlcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnc3Bhbic6XG5cdFx0XHRcdFx0XHRpZiAoIXRhcmdldC5pcygnLmRpc2FibGVkJykpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy52aWV3RGF0ZS5zZXRVVENEYXRlKDEpO1xuXHRcdFx0XHRcdFx0XHRpZiAodGFyZ2V0LmlzKCcubW9udGgnKSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBkYXkgPSAxO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBtb250aCA9IHRhcmdldC5wYXJlbnQoKS5maW5kKCdzcGFuJykuaW5kZXgodGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgeWVhciA9IHRoaXMudmlld0RhdGUuZ2V0VVRDRnVsbFllYXIoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlLnNldFVUQ01vbnRoKG1vbnRoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VNb250aCcsIHRoaXMudmlld0RhdGUpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm8ubWluVmlld01vZGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NldERhdGUoVVRDRGF0ZSh5ZWFyLCBtb250aCwgZGF5LDAsMCwwLDApKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHllYXIgPSBwYXJzZUludCh0YXJnZXQudGV4dCgpLCAxMCl8fDA7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRheSA9IDE7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1vbnRoID0gMDtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZVllYXInLCB0aGlzLnZpZXdEYXRlKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5vLm1pblZpZXdNb2RlID09PSAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zZXREYXRlKFVUQ0RhdGUoeWVhciwgbW9udGgsIGRheSwwLDAsMCwwKSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2hvd01vZGUoLTEpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmZpbGwoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3RkJzpcblx0XHRcdFx0XHRcdGlmICh0YXJnZXQuaXMoJy5kYXknKSAmJiAhdGFyZ2V0LmlzKCcuZGlzYWJsZWQnKSl7XG5cdFx0XHRcdFx0XHRcdHZhciBkYXkgPSBwYXJzZUludCh0YXJnZXQudGV4dCgpLCAxMCl8fDE7XG5cdFx0XHRcdFx0XHRcdHZhciB5ZWFyID0gdGhpcy52aWV3RGF0ZS5nZXRVVENGdWxsWWVhcigpLFxuXHRcdFx0XHRcdFx0XHRcdG1vbnRoID0gdGhpcy52aWV3RGF0ZS5nZXRVVENNb250aCgpO1xuXHRcdFx0XHRcdFx0XHRpZiAodGFyZ2V0LmlzKCcub2xkJykpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAobW9udGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vbnRoID0gMTE7XG5cdFx0XHRcdFx0XHRcdFx0XHR5ZWFyIC09IDE7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vbnRoIC09IDE7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRhcmdldC5pcygnLm5ldycpKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG1vbnRoID09IDExKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb250aCA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHR5ZWFyICs9IDE7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vbnRoICs9IDE7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3NldERhdGUoVVRDRGF0ZSh5ZWFyLCBtb250aCwgZGF5LDAsMCwwLDApKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9zZXREYXRlOiBmdW5jdGlvbihkYXRlLCB3aGljaCl7XG5cdFx0XHRpZiAoIXdoaWNoIHx8IHdoaWNoID09ICdkYXRlJylcblx0XHRcdFx0dGhpcy5kYXRlID0gbmV3IERhdGUoZGF0ZSk7XG5cdFx0XHRpZiAoIXdoaWNoIHx8IHdoaWNoICA9PSAndmlldycpXG5cdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcblx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSgpO1xuXHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlRGF0ZScpO1xuXHRcdFx0dmFyIGVsZW1lbnQ7XG5cdFx0XHRpZiAodGhpcy5pc0lucHV0KSB7XG5cdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuY29tcG9uZW50KXtcblx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudC5maW5kKCdpbnB1dCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0ZWxlbWVudC5jaGFuZ2UoKTtcblx0XHRcdFx0aWYgKHRoaXMuby5hdXRvY2xvc2UgJiYgKCF3aGljaCB8fCB3aGljaCA9PSAnZGF0ZScpKSB7XG5cdFx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0bW92ZU1vbnRoOiBmdW5jdGlvbihkYXRlLCBkaXIpe1xuXHRcdFx0aWYgKCFkaXIpIHJldHVybiBkYXRlO1xuXHRcdFx0dmFyIG5ld19kYXRlID0gbmV3IERhdGUoZGF0ZS52YWx1ZU9mKCkpLFxuXHRcdFx0XHRkYXkgPSBuZXdfZGF0ZS5nZXRVVENEYXRlKCksXG5cdFx0XHRcdG1vbnRoID0gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKSxcblx0XHRcdFx0bWFnID0gTWF0aC5hYnMoZGlyKSxcblx0XHRcdFx0bmV3X21vbnRoLCB0ZXN0O1xuXHRcdFx0ZGlyID0gZGlyID4gMCA/IDEgOiAtMTtcblx0XHRcdGlmIChtYWcgPT0gMSl7XG5cdFx0XHRcdHRlc3QgPSBkaXIgPT0gLTFcblx0XHRcdFx0XHQvLyBJZiBnb2luZyBiYWNrIG9uZSBtb250aCwgbWFrZSBzdXJlIG1vbnRoIGlzIG5vdCBjdXJyZW50IG1vbnRoXG5cdFx0XHRcdFx0Ly8gKGVnLCBNYXIgMzEgLT4gRmViIDMxID09IEZlYiAyOCwgbm90IE1hciAwMilcblx0XHRcdFx0XHQ/IGZ1bmN0aW9uKCl7IHJldHVybiBuZXdfZGF0ZS5nZXRVVENNb250aCgpID09IG1vbnRoOyB9XG5cdFx0XHRcdFx0Ly8gSWYgZ29pbmcgZm9yd2FyZCBvbmUgbW9udGgsIG1ha2Ugc3VyZSBtb250aCBpcyBhcyBleHBlY3RlZFxuXHRcdFx0XHRcdC8vIChlZywgSmFuIDMxIC0+IEZlYiAzMSA9PSBGZWIgMjgsIG5vdCBNYXIgMDIpXG5cdFx0XHRcdFx0OiBmdW5jdGlvbigpeyByZXR1cm4gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKSAhPSBuZXdfbW9udGg7IH07XG5cdFx0XHRcdG5ld19tb250aCA9IG1vbnRoICsgZGlyO1xuXHRcdFx0XHRuZXdfZGF0ZS5zZXRVVENNb250aChuZXdfbW9udGgpO1xuXHRcdFx0XHQvLyBEZWMgLT4gSmFuICgxMikgb3IgSmFuIC0+IERlYyAoLTEpIC0tIGxpbWl0IGV4cGVjdGVkIGRhdGUgdG8gMC0xMVxuXHRcdFx0XHRpZiAobmV3X21vbnRoIDwgMCB8fCBuZXdfbW9udGggPiAxMSlcblx0XHRcdFx0XHRuZXdfbW9udGggPSAobmV3X21vbnRoICsgMTIpICUgMTI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBGb3IgbWFnbml0dWRlcyA+MSwgbW92ZSBvbmUgbW9udGggYXQgYSB0aW1lLi4uXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTxtYWc7IGkrKylcblx0XHRcdFx0XHQvLyAuLi53aGljaCBtaWdodCBkZWNyZWFzZSB0aGUgZGF5IChlZywgSmFuIDMxIHRvIEZlYiAyOCwgZXRjKS4uLlxuXHRcdFx0XHRcdG5ld19kYXRlID0gdGhpcy5tb3ZlTW9udGgobmV3X2RhdGUsIGRpcik7XG5cdFx0XHRcdC8vIC4uLnRoZW4gcmVzZXQgdGhlIGRheSwga2VlcGluZyBpdCBpbiB0aGUgbmV3IG1vbnRoXG5cdFx0XHRcdG5ld19tb250aCA9IG5ld19kYXRlLmdldFVUQ01vbnRoKCk7XG5cdFx0XHRcdG5ld19kYXRlLnNldFVUQ0RhdGUoZGF5KTtcblx0XHRcdFx0dGVzdCA9IGZ1bmN0aW9uKCl7IHJldHVybiBuZXdfbW9udGggIT0gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKTsgfTtcblx0XHRcdH1cblx0XHRcdC8vIENvbW1vbiBkYXRlLXJlc2V0dGluZyBsb29wIC0tIGlmIGRhdGUgaXMgYmV5b25kIGVuZCBvZiBtb250aCwgbWFrZSBpdFxuXHRcdFx0Ly8gZW5kIG9mIG1vbnRoXG5cdFx0XHR3aGlsZSAodGVzdCgpKXtcblx0XHRcdFx0bmV3X2RhdGUuc2V0VVRDRGF0ZSgtLWRheSk7XG5cdFx0XHRcdG5ld19kYXRlLnNldFVUQ01vbnRoKG5ld19tb250aCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3X2RhdGU7XG5cdFx0fSxcblxuXHRcdG1vdmVZZWFyOiBmdW5jdGlvbihkYXRlLCBkaXIpe1xuXHRcdFx0cmV0dXJuIHRoaXMubW92ZU1vbnRoKGRhdGUsIGRpcioxMik7XG5cdFx0fSxcblxuXHRcdGRhdGVXaXRoaW5SYW5nZTogZnVuY3Rpb24oZGF0ZSl7XG5cdFx0XHRyZXR1cm4gZGF0ZSA+PSB0aGlzLm8uc3RhcnREYXRlICYmIGRhdGUgPD0gdGhpcy5vLmVuZERhdGU7XG5cdFx0fSxcblxuXHRcdGtleWRvd246IGZ1bmN0aW9uKGUpe1xuXHRcdFx0aWYgKHRoaXMucGlja2VyLmlzKCc6bm90KDp2aXNpYmxlKScpKXtcblx0XHRcdFx0aWYgKGUua2V5Q29kZSA9PSAyNykgLy8gYWxsb3cgZXNjYXBlIHRvIGhpZGUgYW5kIHJlLXNob3cgcGlja2VyXG5cdFx0XHRcdFx0dGhpcy5zaG93KCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBkYXRlQ2hhbmdlZCA9IGZhbHNlLFxuXHRcdFx0XHRkaXIsIGRheSwgbW9udGgsXG5cdFx0XHRcdG5ld0RhdGUsIG5ld1ZpZXdEYXRlO1xuXHRcdFx0c3dpdGNoKGUua2V5Q29kZSl7XG5cdFx0XHRcdGNhc2UgMjc6IC8vIGVzY2FwZVxuXHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAzNzogLy8gbGVmdFxuXHRcdFx0XHRjYXNlIDM5OiAvLyByaWdodFxuXHRcdFx0XHRcdGlmICghdGhpcy5vLmtleWJvYXJkTmF2aWdhdGlvbikgYnJlYWs7XG5cdFx0XHRcdFx0ZGlyID0gZS5rZXlDb2RlID09IDM3ID8gLTEgOiAxO1xuXHRcdFx0XHRcdGlmIChlLmN0cmxLZXkpe1xuXHRcdFx0XHRcdFx0bmV3RGF0ZSA9IHRoaXMubW92ZVllYXIodGhpcy5kYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSB0aGlzLm1vdmVZZWFyKHRoaXMudmlld0RhdGUsIGRpcik7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlLnNoaWZ0S2V5KXtcblx0XHRcdFx0XHRcdG5ld0RhdGUgPSB0aGlzLm1vdmVNb250aCh0aGlzLmRhdGUsIGRpcik7XG5cdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZU1vbnRoKHRoaXMudmlld0RhdGUsIGRpcik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLmRhdGUpO1xuXHRcdFx0XHRcdFx0bmV3RGF0ZS5zZXRVVENEYXRlKHRoaXMuZGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIpO1xuXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlLnNldFVUQ0RhdGUodGhpcy52aWV3RGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5kYXRlV2l0aGluUmFuZ2UobmV3RGF0ZSkpe1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRlID0gbmV3RGF0ZTtcblx0XHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXdWaWV3RGF0ZTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRkYXRlQ2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDM4OiAvLyB1cFxuXHRcdFx0XHRjYXNlIDQwOiAvLyBkb3duXG5cdFx0XHRcdFx0aWYgKCF0aGlzLm8ua2V5Ym9hcmROYXZpZ2F0aW9uKSBicmVhaztcblx0XHRcdFx0XHRkaXIgPSBlLmtleUNvZGUgPT0gMzggPyAtMSA6IDE7XG5cdFx0XHRcdFx0aWYgKGUuY3RybEtleSl7XG5cdFx0XHRcdFx0XHRuZXdEYXRlID0gdGhpcy5tb3ZlWWVhcih0aGlzLmRhdGUsIGRpcik7XG5cdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZVllYXIodGhpcy52aWV3RGF0ZSwgZGlyKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGUuc2hpZnRLZXkpe1xuXHRcdFx0XHRcdFx0bmV3RGF0ZSA9IHRoaXMubW92ZU1vbnRoKHRoaXMuZGF0ZSwgZGlyKTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlID0gdGhpcy5tb3ZlTW9udGgodGhpcy52aWV3RGF0ZSwgZGlyKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuZGF0ZSk7XG5cdFx0XHRcdFx0XHRuZXdEYXRlLnNldFVUQ0RhdGUodGhpcy5kYXRlLmdldFVUQ0RhdGUoKSArIGRpciAqIDcpO1xuXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlLnNldFVUQ0RhdGUodGhpcy52aWV3RGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIgKiA3KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuZGF0ZVdpdGhpblJhbmdlKG5ld0RhdGUpKXtcblx0XHRcdFx0XHRcdHRoaXMuZGF0ZSA9IG5ld0RhdGU7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gbmV3Vmlld0RhdGU7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFZhbHVlKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0ZGF0ZUNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAxMzogLy8gZW50ZXJcblx0XHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgOTogLy8gdGFiXG5cdFx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0ZUNoYW5nZWQpe1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VEYXRlJyk7XG5cdFx0XHRcdHZhciBlbGVtZW50O1xuXHRcdFx0XHRpZiAodGhpcy5pc0lucHV0KSB7XG5cdFx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudCl7XG5cdFx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudC5maW5kKCdpbnB1dCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5jaGFuZ2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzaG93TW9kZTogZnVuY3Rpb24oZGlyKSB7XG5cdFx0XHRpZiAoZGlyKSB7XG5cdFx0XHRcdHRoaXMudmlld01vZGUgPSBNYXRoLm1heCh0aGlzLm8ubWluVmlld01vZGUsIE1hdGgubWluKDIsIHRoaXMudmlld01vZGUgKyBkaXIpKTtcblx0XHRcdH1cblx0XHRcdC8qXG5cdFx0XHRcdHZpdGFsZXRzOiBmaXhpbmcgYnVnIG9mIHZlcnkgc3BlY2lhbCBjb25kaXRpb25zOlxuXHRcdFx0XHRqcXVlcnkgMS43LjEgKyB3ZWJraXQgKyBzaG93IGlubGluZSBkYXRlcGlja2VyIGluIGJvb3RzdHJhcCBwb3BvdmVyLlxuXHRcdFx0XHRNZXRob2Qgc2hvdygpIGRvZXMgbm90IHNldCBkaXNwbGF5IGNzcyBjb3JyZWN0bHkgYW5kIGRhdGVwaWNrZXIgaXMgbm90IHNob3duLlxuXHRcdFx0XHRDaGFuZ2VkIHRvIC5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKSBzb2x2ZSB0aGUgcHJvYmxlbS5cblx0XHRcdFx0U2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlL2lzc3Vlcy8zN1xuXG5cdFx0XHRcdEluIGpxdWVyeSAxLjcuMisgZXZlcnl0aGluZyB3b3JrcyBmaW5lLlxuXHRcdFx0Ki9cblx0XHRcdC8vdGhpcy5waWNrZXIuZmluZCgnPmRpdicpLmhpZGUoKS5maWx0ZXIoJy5kYXRlcGlja2VyLScrRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZSkuc2hvdygpO1xuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnPmRpdicpLmhpZGUoKS5maWx0ZXIoJy5kYXRlcGlja2VyLScrRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZSkuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgRGF0ZVJhbmdlUGlja2VyID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucyl7XG5cdFx0dGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcblx0XHR0aGlzLmlucHV0cyA9ICQubWFwKG9wdGlvbnMuaW5wdXRzLCBmdW5jdGlvbihpKXsgcmV0dXJuIGkuanF1ZXJ5ID8gaVswXSA6IGk7IH0pO1xuXHRcdGRlbGV0ZSBvcHRpb25zLmlucHV0cztcblxuXHRcdCQodGhpcy5pbnB1dHMpXG5cdFx0XHQuZGF0ZXBpY2tlcihvcHRpb25zKVxuXHRcdFx0LmJpbmQoJ2NoYW5nZURhdGUnLCAkLnByb3h5KHRoaXMuZGF0ZVVwZGF0ZWQsIHRoaXMpKTtcblxuXHRcdHRoaXMucGlja2VycyA9ICQubWFwKHRoaXMuaW5wdXRzLCBmdW5jdGlvbihpKXsgcmV0dXJuICQoaSkuZGF0YSgnZGF0ZXBpY2tlcicpOyB9KTtcblx0XHR0aGlzLnVwZGF0ZURhdGVzKCk7XG5cdH07XG5cdERhdGVSYW5nZVBpY2tlci5wcm90b3R5cGUgPSB7XG5cdFx0dXBkYXRlRGF0ZXM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLmRhdGVzID0gJC5tYXAodGhpcy5waWNrZXJzLCBmdW5jdGlvbihpKXsgcmV0dXJuIGkuZGF0ZTsgfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZVJhbmdlcygpO1xuXHRcdH0sXG5cdFx0dXBkYXRlUmFuZ2VzOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHJhbmdlID0gJC5tYXAodGhpcy5kYXRlcywgZnVuY3Rpb24oZCl7IHJldHVybiBkLnZhbHVlT2YoKTsgfSk7XG5cdFx0XHQkLmVhY2godGhpcy5waWNrZXJzLCBmdW5jdGlvbihpLCBwKXtcblx0XHRcdFx0cC5zZXRSYW5nZShyYW5nZSk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdGRhdGVVcGRhdGVkOiBmdW5jdGlvbihlKXtcblx0XHRcdHZhciBkcCA9ICQoZS50YXJnZXQpLmRhdGEoJ2RhdGVwaWNrZXInKSxcblx0XHRcdFx0bmV3X2RhdGUgPSBkcC5nZXRVVENEYXRlKCksXG5cdFx0XHRcdGkgPSAkLmluQXJyYXkoZS50YXJnZXQsIHRoaXMuaW5wdXRzKSxcblx0XHRcdFx0bCA9IHRoaXMuaW5wdXRzLmxlbmd0aDtcblx0XHRcdGlmIChpID09IC0xKSByZXR1cm47XG5cblx0XHRcdGlmIChuZXdfZGF0ZSA8IHRoaXMuZGF0ZXNbaV0pe1xuXHRcdFx0XHQvLyBEYXRlIGJlaW5nIG1vdmVkIGVhcmxpZXIvbGVmdFxuXHRcdFx0XHR3aGlsZSAoaT49MCAmJiBuZXdfZGF0ZSA8IHRoaXMuZGF0ZXNbaV0pe1xuXHRcdFx0XHRcdHRoaXMucGlja2Vyc1tpLS1dLnNldFVUQ0RhdGUobmV3X2RhdGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChuZXdfZGF0ZSA+IHRoaXMuZGF0ZXNbaV0pe1xuXHRcdFx0XHQvLyBEYXRlIGJlaW5nIG1vdmVkIGxhdGVyL3JpZ2h0XG5cdFx0XHRcdHdoaWxlIChpPGwgJiYgbmV3X2RhdGUgPiB0aGlzLmRhdGVzW2ldKXtcblx0XHRcdFx0XHR0aGlzLnBpY2tlcnNbaSsrXS5zZXRVVENEYXRlKG5ld19kYXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy51cGRhdGVEYXRlcygpO1xuXHRcdH0sXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbigpe1xuXHRcdFx0JC5tYXAodGhpcy5waWNrZXJzLCBmdW5jdGlvbihwKXsgcC5yZW1vdmUoKTsgfSk7XG5cdFx0XHRkZWxldGUgdGhpcy5lbGVtZW50LmRhdGEoKS5kYXRlcGlja2VyO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBvcHRzX2Zyb21fZWwoZWwsIHByZWZpeCl7XG5cdFx0Ly8gRGVyaXZlIG9wdGlvbnMgZnJvbSBlbGVtZW50IGRhdGEtYXR0cnNcblx0XHR2YXIgZGF0YSA9ICQoZWwpLmRhdGEoKSxcblx0XHRcdG91dCA9IHt9LCBpbmtleSxcblx0XHRcdHJlcGxhY2UgPSBuZXcgUmVnRXhwKCdeJyArIHByZWZpeC50b0xvd2VyQ2FzZSgpICsgJyhbQS1aXSknKSxcblx0XHRcdHByZWZpeCA9IG5ldyBSZWdFeHAoJ14nICsgcHJlZml4LnRvTG93ZXJDYXNlKCkpO1xuXHRcdGZvciAodmFyIGtleSBpbiBkYXRhKVxuXHRcdFx0aWYgKHByZWZpeC50ZXN0KGtleSkpe1xuXHRcdFx0XHRpbmtleSA9IGtleS5yZXBsYWNlKHJlcGxhY2UsIGZ1bmN0aW9uKF8sYSl7IHJldHVybiBhLnRvTG93ZXJDYXNlKCk7IH0pO1xuXHRcdFx0XHRvdXRbaW5rZXldID0gZGF0YVtrZXldO1xuXHRcdFx0fVxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBvcHRzX2Zyb21fbG9jYWxlKGxhbmcpe1xuXHRcdC8vIERlcml2ZSBvcHRpb25zIGZyb20gbG9jYWxlIHBsdWdpbnNcblx0XHR2YXIgb3V0ID0ge307XG5cdFx0Ly8gQ2hlY2sgaWYgXCJkZS1ERVwiIHN0eWxlIGRhdGUgaXMgYXZhaWxhYmxlLCBpZiBub3QgbGFuZ3VhZ2Ugc2hvdWxkXG5cdFx0Ly8gZmFsbGJhY2sgdG8gMiBsZXR0ZXIgY29kZSBlZyBcImRlXCJcblx0XHRpZiAoIWRhdGVzW2xhbmddKSB7XG5cdFx0XHRsYW5nID0gbGFuZy5zcGxpdCgnLScpWzBdXG5cdFx0XHRpZiAoIWRhdGVzW2xhbmddKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBkID0gZGF0ZXNbbGFuZ107XG5cdFx0JC5lYWNoKGxvY2FsZV9vcHRzLCBmdW5jdGlvbihpLGspe1xuXHRcdFx0aWYgKGsgaW4gZClcblx0XHRcdFx0b3V0W2tdID0gZFtrXTtcblx0XHR9KTtcblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cblx0dmFyIG9sZCA9ICQuZm4uZGF0ZXBpY2tlcjtcblx0dmFyIGRhdGVwaWNrZXIgPSAkLmZuLmRhdGVwaWNrZXIgPSBmdW5jdGlvbiAoIG9wdGlvbiApIHtcblx0XHR2YXIgYXJncyA9IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0YXJncy5zaGlmdCgpO1xuXHRcdHZhciBpbnRlcm5hbF9yZXR1cm4sXG5cdFx0XHR0aGlzX3JldHVybjtcblx0XHR0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKSxcblx0XHRcdFx0ZGF0YSA9ICR0aGlzLmRhdGEoJ2RhdGVwaWNrZXInKSxcblx0XHRcdFx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uO1xuXHRcdFx0aWYgKCFkYXRhKSB7XG5cdFx0XHRcdHZhciBlbG9wdHMgPSBvcHRzX2Zyb21fZWwodGhpcywgJ2RhdGUnKSxcblx0XHRcdFx0XHQvLyBQcmVsaW1pbmFyeSBvdGlvbnNcblx0XHRcdFx0XHR4b3B0cyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZWxvcHRzLCBvcHRpb25zKSxcblx0XHRcdFx0XHRsb2NvcHRzID0gb3B0c19mcm9tX2xvY2FsZSh4b3B0cy5sYW5ndWFnZSksXG5cdFx0XHRcdFx0Ly8gT3B0aW9ucyBwcmlvcml0eToganMgYXJncywgZGF0YS1hdHRycywgbG9jYWxlcywgZGVmYXVsdHNcblx0XHRcdFx0XHRvcHRzID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBsb2NvcHRzLCBlbG9wdHMsIG9wdGlvbnMpO1xuXHRcdFx0XHRpZiAoJHRoaXMuaXMoJy5pbnB1dC1kYXRlcmFuZ2UnKSB8fCBvcHRzLmlucHV0cyl7XG5cdFx0XHRcdFx0dmFyIHJvcHRzID0ge1xuXHRcdFx0XHRcdFx0aW5wdXRzOiBvcHRzLmlucHV0cyB8fCAkdGhpcy5maW5kKCdpbnB1dCcpLnRvQXJyYXkoKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0JHRoaXMuZGF0YSgnZGF0ZXBpY2tlcicsIChkYXRhID0gbmV3IERhdGVSYW5nZVBpY2tlcih0aGlzLCAkLmV4dGVuZChvcHRzLCByb3B0cykpKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZXtcblx0XHRcdFx0XHQkdGhpcy5kYXRhKCdkYXRlcGlja2VyJywgKGRhdGEgPSBuZXcgRGF0ZXBpY2tlcih0aGlzLCBvcHRzKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGF0YVtvcHRpb25dID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aW50ZXJuYWxfcmV0dXJuID0gZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIGFyZ3MpO1xuXHRcdFx0XHRpZiAoaW50ZXJuYWxfcmV0dXJuICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlmIChpbnRlcm5hbF9yZXR1cm4gIT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiBpbnRlcm5hbF9yZXR1cm47XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0dmFyIGRlZmF1bHRzID0gJC5mbi5kYXRlcGlja2VyLmRlZmF1bHRzID0ge1xuXHRcdGF1dG9jbG9zZTogZmFsc2UsXG5cdFx0YmVmb3JlU2hvd0RheTogJC5ub29wLFxuXHRcdGNhbGVuZGFyV2Vla3M6IGZhbHNlLFxuXHRcdGNsZWFyQnRuOiBmYWxzZSxcblx0XHRkYXlzT2ZXZWVrRGlzYWJsZWQ6IFtdLFxuXHRcdGVuZERhdGU6IEluZmluaXR5LFxuXHRcdGZvcmNlUGFyc2U6IHRydWUsXG5cdFx0Zm9ybWF0OiAnbW0vZGQveXl5eScsXG5cdFx0a2V5Ym9hcmROYXZpZ2F0aW9uOiB0cnVlLFxuXHRcdGxhbmd1YWdlOiAnZW4nLFxuXHRcdG1pblZpZXdNb2RlOiAwLFxuXHRcdHJ0bDogZmFsc2UsXG5cdFx0c3RhcnREYXRlOiAtSW5maW5pdHksXG5cdFx0c3RhcnRWaWV3OiAwLFxuXHRcdHRvZGF5QnRuOiBmYWxzZSxcblx0XHR0b2RheUhpZ2hsaWdodDogZmFsc2UsXG5cdFx0d2Vla1N0YXJ0OiAwXG5cdH07XG5cdHZhciBsb2NhbGVfb3B0cyA9ICQuZm4uZGF0ZXBpY2tlci5sb2NhbGVfb3B0cyA9IFtcblx0XHQnZm9ybWF0Jyxcblx0XHQncnRsJyxcblx0XHQnd2Vla1N0YXJ0J1xuXHRdO1xuXHQkLmZuLmRhdGVwaWNrZXIuQ29uc3RydWN0b3IgPSBEYXRlcGlja2VyO1xuXHR2YXIgZGF0ZXMgPSAkLmZuLmRhdGVwaWNrZXIuZGF0ZXMgPSB7XG5cdFx0ZW46IHtcblx0XHRcdGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCIsIFwiU3VuZGF5XCJdLFxuXHRcdFx0ZGF5c1Nob3J0OiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiwgXCJTdW5cIl0sXG5cdFx0XHRkYXlzTWluOiBbXCJTdVwiLCBcIk1vXCIsIFwiVHVcIiwgXCJXZVwiLCBcIlRoXCIsIFwiRnJcIiwgXCJTYVwiLCBcIlN1XCJdLFxuXHRcdFx0bW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcblx0XHRcdG1vbnRoc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sXG5cdFx0XHR0b2RheTogXCJUb2RheVwiLFxuXHRcdFx0Y2xlYXI6IFwiQ2xlYXJcIlxuXHRcdH1cblx0fTtcblxuXHR2YXIgRFBHbG9iYWwgPSB7XG5cdFx0bW9kZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0Y2xzTmFtZTogJ2RheXMnLFxuXHRcdFx0XHRuYXZGbmM6ICdNb250aCcsXG5cdFx0XHRcdG5hdlN0ZXA6IDFcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGNsc05hbWU6ICdtb250aHMnLFxuXHRcdFx0XHRuYXZGbmM6ICdGdWxsWWVhcicsXG5cdFx0XHRcdG5hdlN0ZXA6IDFcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGNsc05hbWU6ICd5ZWFycycsXG5cdFx0XHRcdG5hdkZuYzogJ0Z1bGxZZWFyJyxcblx0XHRcdFx0bmF2U3RlcDogMTBcblx0XHR9XSxcblx0XHRpc0xlYXBZZWFyOiBmdW5jdGlvbiAoeWVhcikge1xuXHRcdFx0cmV0dXJuICgoKHllYXIgJSA0ID09PSAwKSAmJiAoeWVhciAlIDEwMCAhPT0gMCkpIHx8ICh5ZWFyICUgNDAwID09PSAwKSk7XG5cdFx0fSxcblx0XHRnZXREYXlzSW5Nb250aDogZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG5cdFx0XHRyZXR1cm4gWzMxLCAoRFBHbG9iYWwuaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjgpLCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1bbW9udGhdO1xuXHRcdH0sXG5cdFx0dmFsaWRQYXJ0czogL2RkP3xERD98bW0/fE1NP3x5eSg/Onl5KT8vZyxcblx0XHRub25wdW5jdHVhdGlvbjogL1teIC1cXC86LUBcXFtcXHUzNDAwLVxcdTlmZmYtYHstflxcdFxcblxccl0rL2csXG5cdFx0cGFyc2VGb3JtYXQ6IGZ1bmN0aW9uKGZvcm1hdCl7XG5cdFx0XHQvLyBJRSB0cmVhdHMgXFwwIGFzIGEgc3RyaW5nIGVuZCBpbiBpbnB1dHMgKHRydW5jYXRpbmcgdGhlIHZhbHVlKSxcblx0XHRcdC8vIHNvIGl0J3MgYSBiYWQgZm9ybWF0IGRlbGltaXRlciwgYW55d2F5XG5cdFx0XHR2YXIgc2VwYXJhdG9ycyA9IGZvcm1hdC5yZXBsYWNlKHRoaXMudmFsaWRQYXJ0cywgJ1xcMCcpLnNwbGl0KCdcXDAnKSxcblx0XHRcdFx0cGFydHMgPSBmb3JtYXQubWF0Y2godGhpcy52YWxpZFBhcnRzKTtcblx0XHRcdGlmICghc2VwYXJhdG9ycyB8fCAhc2VwYXJhdG9ycy5sZW5ndGggfHwgIXBhcnRzIHx8IHBhcnRzLmxlbmd0aCA9PT0gMCl7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtzZXBhcmF0b3JzOiBzZXBhcmF0b3JzLCBwYXJ0czogcGFydHN9O1xuXHRcdH0sXG5cdFx0cGFyc2VEYXRlOiBmdW5jdGlvbihkYXRlLCBmb3JtYXQsIGxhbmd1YWdlKSB7XG5cdFx0XHRpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBkYXRlO1xuXHRcdFx0aWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRmb3JtYXQgPSBEUEdsb2JhbC5wYXJzZUZvcm1hdChmb3JtYXQpO1xuXHRcdFx0aWYgKC9eW1xcLStdXFxkK1tkbXd5XShbXFxzLF0rW1xcLStdXFxkK1tkbXd5XSkqJC8udGVzdChkYXRlKSkge1xuXHRcdFx0XHR2YXIgcGFydF9yZSA9IC8oW1xcLStdXFxkKykoW2Rtd3ldKS8sXG5cdFx0XHRcdFx0cGFydHMgPSBkYXRlLm1hdGNoKC8oW1xcLStdXFxkKykoW2Rtd3ldKS9nKSxcblx0XHRcdFx0XHRwYXJ0LCBkaXI7XG5cdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRwYXJ0ID0gcGFydF9yZS5leGVjKHBhcnRzW2ldKTtcblx0XHRcdFx0XHRkaXIgPSBwYXJzZUludChwYXJ0WzFdKTtcblx0XHRcdFx0XHRzd2l0Y2gocGFydFsyXSl7XG5cdFx0XHRcdFx0XHRjYXNlICdkJzpcblx0XHRcdFx0XHRcdFx0ZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlyKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtJzpcblx0XHRcdFx0XHRcdFx0ZGF0ZSA9IERhdGVwaWNrZXIucHJvdG90eXBlLm1vdmVNb250aC5jYWxsKERhdGVwaWNrZXIucHJvdG90eXBlLCBkYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3cnOlxuXHRcdFx0XHRcdFx0XHRkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIgKiA3KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICd5Jzpcblx0XHRcdFx0XHRcdFx0ZGF0ZSA9IERhdGVwaWNrZXIucHJvdG90eXBlLm1vdmVZZWFyLmNhbGwoRGF0ZXBpY2tlci5wcm90b3R5cGUsIGRhdGUsIGRpcik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gVVRDRGF0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgZGF0ZS5nZXRVVENEYXRlKCksIDAsIDAsIDApO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHBhcnRzID0gZGF0ZSAmJiBkYXRlLm1hdGNoKHRoaXMubm9ucHVuY3R1YXRpb24pIHx8IFtdLFxuXHRcdFx0XHRkYXRlID0gbmV3IERhdGUoKSxcblx0XHRcdFx0cGFyc2VkID0ge30sXG5cdFx0XHRcdHNldHRlcnNfb3JkZXIgPSBbJ3l5eXknLCAneXknLCAnTScsICdNTScsICdtJywgJ21tJywgJ2QnLCAnZGQnXSxcblx0XHRcdFx0c2V0dGVyc19tYXAgPSB7XG5cdFx0XHRcdFx0eXl5eTogZnVuY3Rpb24oZCx2KXsgcmV0dXJuIGQuc2V0VVRDRnVsbFllYXIodik7IH0sXG5cdFx0XHRcdFx0eXk6IGZ1bmN0aW9uKGQsdil7IHJldHVybiBkLnNldFVUQ0Z1bGxZZWFyKDIwMDArdik7IH0sXG5cdFx0XHRcdFx0bTogZnVuY3Rpb24oZCx2KXtcblx0XHRcdFx0XHRcdHYgLT0gMTtcblx0XHRcdFx0XHRcdHdoaWxlICh2PDApIHYgKz0gMTI7XG5cdFx0XHRcdFx0XHR2ICU9IDEyO1xuXHRcdFx0XHRcdFx0ZC5zZXRVVENNb250aCh2KTtcblx0XHRcdFx0XHRcdHdoaWxlIChkLmdldFVUQ01vbnRoKCkgIT0gdilcblx0XHRcdFx0XHRcdFx0ZC5zZXRVVENEYXRlKGQuZ2V0VVRDRGF0ZSgpLTEpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGQ7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRkOiBmdW5jdGlvbihkLHYpeyByZXR1cm4gZC5zZXRVVENEYXRlKHYpOyB9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHZhbCwgZmlsdGVyZWQsIHBhcnQ7XG5cdFx0XHRzZXR0ZXJzX21hcFsnTSddID0gc2V0dGVyc19tYXBbJ01NJ10gPSBzZXR0ZXJzX21hcFsnbW0nXSA9IHNldHRlcnNfbWFwWydtJ107XG5cdFx0XHRzZXR0ZXJzX21hcFsnZGQnXSA9IHNldHRlcnNfbWFwWydkJ107XG5cdFx0XHRkYXRlID0gVVRDRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIDAsIDAsIDApO1xuXHRcdFx0dmFyIGZwYXJ0cyA9IGZvcm1hdC5wYXJ0cy5zbGljZSgpO1xuXHRcdFx0Ly8gUmVtb3ZlIG5vb3AgcGFydHNcblx0XHRcdGlmIChwYXJ0cy5sZW5ndGggIT0gZnBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHRmcGFydHMgPSAkKGZwYXJ0cykuZmlsdGVyKGZ1bmN0aW9uKGkscCl7XG5cdFx0XHRcdFx0cmV0dXJuICQuaW5BcnJheShwLCBzZXR0ZXJzX29yZGVyKSAhPT0gLTE7XG5cdFx0XHRcdH0pLnRvQXJyYXkoKTtcblx0XHRcdH1cblx0XHRcdC8vIFByb2Nlc3MgcmVtYWluZGVyXG5cdFx0XHRpZiAocGFydHMubGVuZ3RoID09IGZwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0Zm9yICh2YXIgaT0wLCBjbnQgPSBmcGFydHMubGVuZ3RoOyBpIDwgY250OyBpKyspIHtcblx0XHRcdFx0XHR2YWwgPSBwYXJzZUludChwYXJ0c1tpXSwgMTApO1xuXHRcdFx0XHRcdHBhcnQgPSBmcGFydHNbaV07XG5cdFx0XHRcdFx0aWYgKGlzTmFOKHZhbCkpIHtcblx0XHRcdFx0XHRcdHN3aXRjaChwYXJ0KSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ01NJzpcblx0XHRcdFx0XHRcdFx0XHRmaWx0ZXJlZCA9ICQoZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRocykuZmlsdGVyKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgbSA9IHRoaXMuc2xpY2UoMCwgcGFydHNbaV0ubGVuZ3RoKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cCA9IHBhcnRzW2ldLnNsaWNlKDAsIG0ubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBtID09IHA7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0dmFsID0gJC5pbkFycmF5KGZpbHRlcmVkWzBdLCBkYXRlc1tsYW5ndWFnZV0ubW9udGhzKSArIDE7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ00nOlxuXHRcdFx0XHRcdFx0XHRcdGZpbHRlcmVkID0gJChkYXRlc1tsYW5ndWFnZV0ubW9udGhzU2hvcnQpLmZpbHRlcihmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG0gPSB0aGlzLnNsaWNlKDAsIHBhcnRzW2ldLmxlbmd0aCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSBwYXJ0c1tpXS5zbGljZSgwLCBtLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbSA9PSBwO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdHZhbCA9ICQuaW5BcnJheShmaWx0ZXJlZFswXSwgZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRoc1Nob3J0KSArIDE7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcnNlZFtwYXJ0XSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHZhciBpPTAsIHM7IGk8c2V0dGVyc19vcmRlci5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0cyA9IHNldHRlcnNfb3JkZXJbaV07XG5cdFx0XHRcdFx0aWYgKHMgaW4gcGFyc2VkICYmICFpc05hTihwYXJzZWRbc10pKVxuXHRcdFx0XHRcdFx0c2V0dGVyc19tYXBbc10oZGF0ZSwgcGFyc2VkW3NdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRhdGU7XG5cdFx0fSxcblx0XHRmb3JtYXREYXRlOiBmdW5jdGlvbihkYXRlLCBmb3JtYXQsIGxhbmd1YWdlKXtcblx0XHRcdGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJylcblx0XHRcdFx0Zm9ybWF0ID0gRFBHbG9iYWwucGFyc2VGb3JtYXQoZm9ybWF0KTtcblx0XHRcdHZhciB2YWwgPSB7XG5cdFx0XHRcdGQ6IGRhdGUuZ2V0VVRDRGF0ZSgpLFxuXHRcdFx0XHREOiBkYXRlc1tsYW5ndWFnZV0uZGF5c1Nob3J0W2RhdGUuZ2V0VVRDRGF5KCldLFxuXHRcdFx0XHRERDogZGF0ZXNbbGFuZ3VhZ2VdLmRheXNbZGF0ZS5nZXRVVENEYXkoKV0sXG5cdFx0XHRcdG06IGRhdGUuZ2V0VVRDTW9udGgoKSArIDEsXG5cdFx0XHRcdE06IGRhdGVzW2xhbmd1YWdlXS5tb250aHNTaG9ydFtkYXRlLmdldFVUQ01vbnRoKCldLFxuXHRcdFx0XHRNTTogZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRoc1tkYXRlLmdldFVUQ01vbnRoKCldLFxuXHRcdFx0XHR5eTogZGF0ZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFxuXHRcdFx0XHR5eXl5OiBkYXRlLmdldFVUQ0Z1bGxZZWFyKClcblx0XHRcdH07XG5cdFx0XHR2YWwuZGQgPSAodmFsLmQgPCAxMCA/ICcwJyA6ICcnKSArIHZhbC5kO1xuXHRcdFx0dmFsLm1tID0gKHZhbC5tIDwgMTAgPyAnMCcgOiAnJykgKyB2YWwubTtcblx0XHRcdHZhciBkYXRlID0gW10sXG5cdFx0XHRcdHNlcHMgPSAkLmV4dGVuZChbXSwgZm9ybWF0LnNlcGFyYXRvcnMpO1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBjbnQgPSBmb3JtYXQucGFydHMubGVuZ3RoOyBpIDw9IGNudDsgaSsrKSB7XG5cdFx0XHRcdGlmIChzZXBzLmxlbmd0aClcblx0XHRcdFx0XHRkYXRlLnB1c2goc2Vwcy5zaGlmdCgpKTtcblx0XHRcdFx0ZGF0ZS5wdXNoKHZhbFtmb3JtYXQucGFydHNbaV1dKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkYXRlLmpvaW4oJycpO1xuXHRcdH0sXG5cdFx0aGVhZFRlbXBsYXRlOiAnPHRoZWFkPicrXG5cdFx0XHRcdFx0XHRcdCc8dHI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNsYXNzPVwicHJldlwiPjxpIGNsYXNzPVwiaWNvbi1hcnJvdy1sZWZ0XCIvPjwvdGg+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNvbHNwYW49XCI1XCIgY2xhc3M9XCJkYXRlcGlja2VyLXN3aXRjaFwiPjwvdGg+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNsYXNzPVwibmV4dFwiPjxpIGNsYXNzPVwiaWNvbi1hcnJvdy1yaWdodFwiLz48L3RoPicrXG5cdFx0XHRcdFx0XHRcdCc8L3RyPicrXG5cdFx0XHRcdFx0XHQnPC90aGVhZD4nLFxuXHRcdGNvbnRUZW1wbGF0ZTogJzx0Ym9keT48dHI+PHRkIGNvbHNwYW49XCI3XCI+PC90ZD48L3RyPjwvdGJvZHk+Jyxcblx0XHRmb290VGVtcGxhdGU6ICc8dGZvb3Q+PHRyPjx0aCBjb2xzcGFuPVwiN1wiIGNsYXNzPVwidG9kYXlcIj48L3RoPjwvdHI+PHRyPjx0aCBjb2xzcGFuPVwiN1wiIGNsYXNzPVwiY2xlYXJcIj48L3RoPjwvdHI+PC90Zm9vdD4nXG5cdH07XG5cdERQR2xvYmFsLnRlbXBsYXRlID0gJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyXCI+Jytcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWRheXNcIj4nK1xuXHRcdFx0XHRcdFx0XHRcdCc8dGFibGUgY2xhc3M9XCIgdGFibGUtY29uZGVuc2VkXCI+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdCc8dGJvZHk+PC90Ym9keT4nK1xuXHRcdFx0XHRcdFx0XHRcdFx0RFBHbG9iYWwuZm9vdFRlbXBsYXRlK1xuXHRcdFx0XHRcdFx0XHRcdCc8L3RhYmxlPicrXG5cdFx0XHRcdFx0XHRcdCc8L2Rpdj4nK1xuXHRcdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItbW9udGhzXCI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmNvbnRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xuXHRcdFx0XHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLXllYXJzXCI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmNvbnRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xuXHRcdFx0XHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdFx0XHRcdCc8L2Rpdj4nO1xuXG5cdCQuZm4uZGF0ZXBpY2tlci5EUEdsb2JhbCA9IERQR2xvYmFsO1xuXG5cblx0LyogREFURVBJQ0tFUiBOTyBDT05GTElDVFxuXHQqID09PT09PT09PT09PT09PT09PT0gKi9cblxuXHQkLmZuLmRhdGVwaWNrZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCl7XG5cdFx0JC5mbi5kYXRlcGlja2VyID0gb2xkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cblx0LyogREFURVBJQ0tFUiBEQVRBLUFQSVxuXHQqID09PT09PT09PT09PT09PT09PSAqL1xuXG5cdCQoZG9jdW1lbnQpLm9uKFxuXHRcdCdmb2N1cy5kYXRlcGlja2VyLmRhdGEtYXBpIGNsaWNrLmRhdGVwaWNrZXIuZGF0YS1hcGknLFxuXHRcdCdbZGF0YS1wcm92aWRlPVwiZGF0ZXBpY2tlclwiXScsXG5cdFx0ZnVuY3Rpb24oZSl7XG5cdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXHRcdFx0aWYgKCR0aGlzLmRhdGEoJ2RhdGVwaWNrZXInKSkgcmV0dXJuO1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0Ly8gY29tcG9uZW50IGNsaWNrIHJlcXVpcmVzIHVzIHRvIGV4cGxpY2l0bHkgc2hvdyBpdFxuXHRcdFx0ZGF0ZXBpY2tlci5jYWxsKCR0aGlzLCAnc2hvdycpO1xuXHRcdH1cblx0KTtcblx0JChmdW5jdGlvbigpe1xuXHRcdC8vJCgnW2RhdGEtcHJvdmlkZT1cImRhdGVwaWNrZXItaW5saW5lXCJdJykuZGF0ZXBpY2tlcigpO1xuICAgICAgICAvL3ZpdDogY2hhbmdlZCB0byBzdXBwb3J0IG5vQ29uZmxpY3QoKVxuICAgICAgICBkYXRlcGlja2VyLmNhbGwoJCgnW2RhdGEtcHJvdmlkZT1cImRhdGVwaWNrZXItaW5saW5lXCJdJykpO1xuXHR9KTtcblxufSggd2luZG93LmpRdWVyeSApKTtcblxuLyoqXG5Cb290c3RyYXAtZGF0ZXBpY2tlci4gIFxuRGVzY3JpcHRpb24gYW5kIGV4YW1wbGVzOiBodHRwczovL2dpdGh1Yi5jb20vZXRlcm5pY29kZS9ib290c3RyYXAtZGF0ZXBpY2tlci4gIFxuRm9yICoqaTE4bioqIHlvdSBzaG91bGQgaW5jbHVkZSBqcyBmaWxlIGZyb20gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL2V0ZXJuaWNvZGUvYm9vdHN0cmFwLWRhdGVwaWNrZXIvdHJlZS9tYXN0ZXIvanMvbG9jYWxlc1xuYW5kIHNldCBgbGFuZ3VhZ2VgIG9wdGlvbi4gIFxuU2luY2UgMS40LjAgZGF0ZSBoYXMgZGlmZmVyZW50IGFwcGVhcmFuY2UgaW4gKipwb3B1cCoqIGFuZCAqKmlubGluZSoqIG1vZGVzLiBcblxuQGNsYXNzIGRhdGVcbkBleHRlbmRzIGFic3RyYWN0aW5wdXRcbkBmaW5hbFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJkb2JcIiBkYXRhLXR5cGU9XCJkYXRlXCIgZGF0YS1waz1cIjFcIiBkYXRhLXVybD1cIi9wb3N0XCIgZGF0YS10aXRsZT1cIlNlbGVjdCBkYXRlXCI+MTUvMDUvMTk4NDwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI2RvYicpLmVkaXRhYmxlKHtcbiAgICAgICAgZm9ybWF0OiAneXl5eS1tbS1kZCcsICAgIFxuICAgICAgICB2aWV3Zm9ybWF0OiAnZGQvbW0veXl5eScsICAgIFxuICAgICAgICBkYXRlcGlja2VyOiB7XG4gICAgICAgICAgICAgICAgd2Vla1N0YXJ0OiAxXG4gICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIC8vc3RvcmUgYm9vdHN0cmFwLWRhdGVwaWNrZXIgYXMgYmRhdGVpY2tlciB0byBleGNsdWRlIGNvbmZsaWN0IHdpdGggalF1ZXJ5IFVJIG9uZVxuICAgICQuZm4uYmRhdGVwaWNrZXIgPSAkLmZuLmRhdGVwaWNrZXIubm9Db25mbGljdCgpO1xuICAgIGlmKCEkLmZuLmRhdGVwaWNrZXIpIHsgLy9pZiB0aGVyZSB3ZXJlIG5vIG90aGVyIGRhdGVwaWNrZXJzLCBrZWVwIGFsc28gb3JpZ2luYWwgbmFtZVxuICAgICAgICAkLmZuLmRhdGVwaWNrZXIgPSAkLmZuLmJkYXRlcGlja2VyOyAgICBcbiAgICB9ICAgIFxuICAgIFxuICAgIHZhciBEYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdkYXRlJywgb3B0aW9ucywgRGF0ZS5kZWZhdWx0cyk7XG4gICAgICAgIHRoaXMuaW5pdFBpY2tlcihvcHRpb25zLCBEYXRlLmRlZmF1bHRzKTtcbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoRGF0ZSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpOyAgICBcbiAgICBcbiAgICAkLmV4dGVuZChEYXRlLnByb3RvdHlwZSwge1xuICAgICAgICBpbml0UGlja2VyOiBmdW5jdGlvbihvcHRpb25zLCBkZWZhdWx0cykge1xuICAgICAgICAgICAgLy8nZm9ybWF0JyBpcyBzZXQgZGlyZWN0bHkgZnJvbSBzZXR0aW5ncyBvciBkYXRhLSogYXR0cmlidXRlc1xuXG4gICAgICAgICAgICAvL2J5IGRlZmF1bHQgdmlld2Zvcm1hdCBlcXVhbHMgdG8gZm9ybWF0XG4gICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLnZpZXdmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCA9IHRoaXMub3B0aW9ucy5mb3JtYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGRhdGVwaWNrZXIgY29uZmlnIGRlZmluZWQgYXMganNvbiBzdHJpbmcgaW4gZGF0YS1kYXRlcGlja2VyXG4gICAgICAgICAgICBvcHRpb25zLmRhdGVwaWNrZXIgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKG9wdGlvbnMuZGF0ZXBpY2tlciwgdHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vb3ZlcnJpZGluZyBkYXRlcGlja2VyIGNvbmZpZyAoYXMgYnkgZGVmYXVsdCBqUXVlcnkgZXh0ZW5kKCkgaXMgbm90IHJlY3Vyc2l2ZSlcbiAgICAgICAgICAgIC8vc2luY2UgMS40IGRhdGVwaWNrZXIgaW50ZXJuYWxseSB1c2VzIHZpZXdmb3JtYXQgaW5zdGVhZCBvZiBmb3JtYXQuIEZvcm1hdCBpcyBmb3Igc3VibWl0IG9ubHlcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kYXRlcGlja2VyID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLmRhdGVwaWNrZXIsIG9wdGlvbnMuZGF0ZXBpY2tlciwge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5vcHRpb25zLnZpZXdmb3JtYXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2xhbmd1YWdlXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlci5sYW5ndWFnZSA9IHRoaXMub3B0aW9ucy5kYXRlcGlja2VyLmxhbmd1YWdlIHx8ICdlbic7IFxuXG4gICAgICAgICAgICAvL3N0b3JlIERQZ2xvYmFsXG4gICAgICAgICAgICB0aGlzLmRwZyA9ICQuZm4uYmRhdGVwaWNrZXIuRFBHbG9iYWw7IFxuXG4gICAgICAgICAgICAvL3N0b3JlIHBhcnNlZCBmb3JtYXRzXG4gICAgICAgICAgICB0aGlzLnBhcnNlZEZvcm1hdCA9IHRoaXMuZHBnLnBhcnNlRm9ybWF0KHRoaXMub3B0aW9ucy5mb3JtYXQpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRWaWV3Rm9ybWF0ID0gdGhpcy5kcGcucGFyc2VGb3JtYXQodGhpcy5vcHRpb25zLnZpZXdmb3JtYXQpOyAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5iZGF0ZXBpY2tlcih0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vXCJjbGVhclwiIGxpbmtcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5jbGVhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyID0gJCgnPGEgaHJlZj1cIiNcIj48L2E+JykuaHRtbCh0aGlzLm9wdGlvbnMuY2xlYXIpLmNsaWNrKCQucHJveHkoZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiR0cGwucGFyZW50KCkuYXBwZW5kKCQoJzxkaXYgY2xhc3M9XCJlZGl0YWJsZS1jbGVhclwiPicpLmFwcGVuZCh0aGlzLiRjbGVhcikpOyAgXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgdmFyIHRleHQgPSB2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodmFsdWUsIHRoaXMucGFyc2VkVmlld0Zvcm1hdCwgdGhpcy5vcHRpb25zLmRhdGVwaWNrZXIubGFuZ3VhZ2UpIDogJyc7XG4gICAgICAgICAgIERhdGUuc3VwZXJjbGFzcy52YWx1ZTJodG1sLmNhbGwodGhpcywgdGV4dCwgZWxlbWVudCk7IFxuICAgICAgICB9LFxuXG4gICAgICAgIGh0bWwydmFsdWU6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGF0ZShodG1sLCB0aGlzLnBhcnNlZFZpZXdGb3JtYXQpO1xuICAgICAgICB9LCAgIFxuXG4gICAgICAgIHZhbHVlMnN0cjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodmFsdWUsIHRoaXMucGFyc2VkRm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlci5sYW5ndWFnZSkgOiAnJztcbiAgICAgICAgfSwgXG5cbiAgICAgICAgc3RyMnZhbHVlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGF0ZShzdHIsIHRoaXMucGFyc2VkRm9ybWF0KTtcbiAgICAgICAgfSwgXG5cbiAgICAgICAgdmFsdWUyc3VibWl0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUyc3RyKHZhbHVlKTtcbiAgICAgICAgfSwgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuYmRhdGVwaWNrZXIoJ3VwZGF0ZScsIHZhbHVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnB1dDJ2YWx1ZTogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LmRhdGEoJ2RhdGVwaWNrZXInKS5kYXRlO1xuICAgICAgICB9LCAgICAgICBcblxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXI6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmRhdGEoJ2RhdGVwaWNrZXInKS5kYXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmZpbmQoJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLnNob3didXR0b25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuY2xvc2VzdCgnZm9ybScpLnN1Ym1pdCgpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdXRvc3VibWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdtb3VzZXVwJywgJy5kYXknLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICBpZigkKGUuY3VycmVudFRhcmdldCkuaXMoJy5vbGQnKSB8fCAkKGUuY3VycmVudFRhcmdldCkuaXMoJy5uZXcnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAkZm9ybSA9ICQodGhpcykuY2xvc2VzdCgnZm9ybScpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgLy9jaGFuZ2VkYXRlIGlzIG5vdCBzdWl0YWJsZSBhcyBpdCB0cmlnZ2VyZWQgd2hlbiBzaG93aW5nIGRhdGVwaWNrZXIuIHNlZSAjMTQ5XG4gICAgICAgICAgIC8qXG4gICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdjaGFuZ2VEYXRlJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICB2YXIgJGZvcm0gPSAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgJGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgICAgKi9cbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgIEZvciBpbmNvcnJlY3QgZGF0ZSBib290c3RyYXAtZGF0ZXBpY2tlciByZXR1cm5zIGN1cnJlbnQgZGF0ZSB0aGF0IGlzIG5vdCBzdWl0YWJsZVxuICAgICAgICBmb3IgZGF0ZWZpZWxkLlxuICAgICAgICBUaGlzIGZ1bmN0aW9uIHJldHVybnMgbnVsbCBmb3IgaW5jb3JyZWN0IGRhdGUuICBcbiAgICAgICAqL1xuICAgICAgIHBhcnNlRGF0ZTogZnVuY3Rpb24oc3RyLCBmb3JtYXQpIHtcbiAgICAgICAgICAgdmFyIGRhdGUgPSBudWxsLCBmb3JtYXR0ZWRCYWNrO1xuICAgICAgICAgICBpZihzdHIpIHtcbiAgICAgICAgICAgICAgIGRhdGUgPSB0aGlzLmRwZy5wYXJzZURhdGUoc3RyLCBmb3JtYXQsIHRoaXMub3B0aW9ucy5kYXRlcGlja2VyLmxhbmd1YWdlKTtcbiAgICAgICAgICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkQmFjayA9IHRoaXMuZHBnLmZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlci5sYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgICAgaWYoc3RyICE9PSBmb3JtYXR0ZWRCYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIERhdGUuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEBkZWZhdWx0IDxkaXY+PC9kaXY+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0cGw6JzxkaXYgY2xhc3M9XCJlZGl0YWJsZS1kYXRlIHdlbGxcIj48L2Rpdj4nLFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3MgXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovXG4gICAgICAgIGlucHV0Y2xhc3M6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBGb3JtYXQgdXNlZCBmb3Igc2VuZGluZyB2YWx1ZSB0byBzZXJ2ZXIuIEFsc28gYXBwbGllZCB3aGVuIGNvbnZlcnRpbmcgZGF0ZSBmcm9tIDxjb2RlPmRhdGEtdmFsdWU8L2NvZGU+IGF0dHJpYnV0ZS48YnI+XG4gICAgICAgIFBvc3NpYmxlIHRva2VucyBhcmU6IDxjb2RlPmQsIGRkLCBtLCBtbSwgeXksIHl5eXk8L2NvZGU+ICBcblxuICAgICAgICBAcHJvcGVydHkgZm9ybWF0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgeXl5eS1tbS1kZFxuICAgICAgICAqKi9cbiAgICAgICAgZm9ybWF0Oid5eXl5LW1tLWRkJyxcbiAgICAgICAgLyoqXG4gICAgICAgIEZvcm1hdCB1c2VkIGZvciBkaXNwbGF5aW5nIGRhdGUuIEFsc28gYXBwbGllZCB3aGVuIGNvbnZlcnRpbmcgZGF0ZSBmcm9tIGVsZW1lbnQncyB0ZXh0IG9uIGluaXQuICAgXG4gICAgICAgIElmIG5vdCBzcGVjaWZpZWQgZXF1YWxzIHRvIDxjb2RlPmZvcm1hdDwvY29kZT5cblxuICAgICAgICBAcHJvcGVydHkgdmlld2Zvcm1hdCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovXG4gICAgICAgIHZpZXdmb3JtYXQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBDb25maWd1cmF0aW9uIG9mIGRhdGVwaWNrZXIuXG4gICAgICAgIEZ1bGwgbGlzdCBvZiBvcHRpb25zOiBodHRwOi8vYm9vdHN0cmFwLWRhdGVwaWNrZXIucmVhZHRoZWRvY3Mub3JnL2VuL2xhdGVzdC9vcHRpb25zLmh0bWxcblxuICAgICAgICBAcHJvcGVydHkgZGF0ZXBpY2tlciBcbiAgICAgICAgQHR5cGUgb2JqZWN0XG4gICAgICAgIEBkZWZhdWx0IHtcbiAgICAgICAgICAgIHdlZWtTdGFydDogMCxcbiAgICAgICAgICAgIHN0YXJ0VmlldzogMCxcbiAgICAgICAgICAgIG1pblZpZXdNb2RlOiAwLFxuICAgICAgICAgICAgYXV0b2Nsb3NlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgICoqL1xuICAgICAgICBkYXRlcGlja2VyOntcbiAgICAgICAgICAgIHdlZWtTdGFydDogMCxcbiAgICAgICAgICAgIHN0YXJ0VmlldzogMCxcbiAgICAgICAgICAgIG1pblZpZXdNb2RlOiAwLFxuICAgICAgICAgICAgYXV0b2Nsb3NlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgVGV4dCBzaG93biBhcyBjbGVhciBkYXRlIGJ1dHRvbi4gXG4gICAgICAgIElmIDxjb2RlPmZhbHNlPC9jb2RlPiBjbGVhciBidXR0b24gd2lsbCBub3QgYmUgcmVuZGVyZWQuXG5cbiAgICAgICAgQHByb3BlcnR5IGNsZWFyIFxuICAgICAgICBAdHlwZSBib29sZWFufHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAneCBjbGVhcidcbiAgICAgICAgKiovXG4gICAgICAgIGNsZWFyOiAnJnRpbWVzOyBjbGVhcidcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5kYXRlID0gRGF0ZTtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuQm9vdHN0cmFwIGRhdGVmaWVsZCBpbnB1dCAtIG1vZGlmaWNhdGlvbiBmb3IgaW5saW5lIG1vZGUuXG5TaG93cyBub3JtYWwgPGlucHV0IHR5cGU9XCJ0ZXh0XCI+IGFuZCBiaW5kcyBwb3B1cCBkYXRlcGlja2VyLiAgXG5BdXRvbWF0aWNhbGx5IHNob3duIGluIGlubGluZSBtb2RlLlxuXG5AY2xhc3MgZGF0ZWZpZWxkXG5AZXh0ZW5kcyBkYXRlXG5cbkBzaW5jZSAxLjQuMFxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG4gICAgXG4gICAgdmFyIERhdGVGaWVsZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgnZGF0ZWZpZWxkJywgb3B0aW9ucywgRGF0ZUZpZWxkLmRlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5pbml0UGlja2VyKG9wdGlvbnMsIERhdGVGaWVsZC5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KERhdGVGaWVsZCwgJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGUpOyAgICBcbiAgICBcbiAgICAkLmV4dGVuZChEYXRlRmllbGQucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQgPSB0aGlzLiR0cGwuZmluZCgnaW5wdXQnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cigncGxhY2Vob2xkZXInKTtcbiAgICBcbiAgICAgICAgICAgIC8vYm9vdHN0cmFwLWRhdGVwaWNrZXIgaXMgc2V0IGBiZGF0ZWlja2VyYCB0byBleGNsdWRlIGNvbmZsaWN0IHdpdGggalF1ZXJ5IFVJIG9uZS4gKGluIGRhdGUuanMpICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJHRwbC5iZGF0ZXBpY2tlcih0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vbmVlZCB0byBkaXNhYmxlIG9yaWdpbmFsIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vZmYoJ2ZvY3VzIGtleWRvd24nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy91cGRhdGUgdmFsdWUgb2YgZGF0ZXBpY2tlclxuICAgICAgICAgICAgdGhpcy4kaW5wdXQua2V5dXAoJC5wcm94eShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgdGhpcy4kdHBsLnJlbW92ZURhdGEoJ2RhdGUnKTtcbiAgICAgICAgICAgICAgIHRoaXMuJHRwbC5iZGF0ZXBpY2tlcigndXBkYXRlJyk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSwgICBcbiAgICAgICAgXG4gICAgICAgdmFsdWUyaW5wdXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHRoaXMuJGlucHV0LnZhbCh2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodmFsdWUsIHRoaXMucGFyc2VkVmlld0Zvcm1hdCwgdGhpcy5vcHRpb25zLmRhdGVwaWNrZXIubGFuZ3VhZ2UpIDogJycpO1xuICAgICAgICAgICB0aGlzLiR0cGwuYmRhdGVwaWNrZXIoJ3VwZGF0ZScpO1xuICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgIGlucHV0MnZhbHVlOiBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgIHJldHVybiB0aGlzLmh0bWwydmFsdWUodGhpcy4kaW5wdXQudmFsKCkpO1xuICAgICAgIH0sICAgICAgICAgICAgICBcbiAgICAgICAgXG4gICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAkLmZuLmVkaXRhYmxldHlwZXMudGV4dC5wcm90b3R5cGUuYWN0aXZhdGUuY2FsbCh0aGlzKTtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgLy9yZXNldCBhdXRvc3VibWl0IHRvIGVtcHR5ICBcbiAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgRGF0ZUZpZWxkLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5kYXRlLmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdHBsOic8ZGl2IGNsYXNzPVwiaW5wdXQtYXBwZW5kIGRhdGVcIj48aW5wdXQgdHlwZT1cInRleHRcIi8+PHNwYW4gY2xhc3M9XCJhZGQtb25cIj48aSBjbGFzcz1cImljb24tdGhcIj48L2k+PC9zcGFuPjwvZGl2PicsXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgaW5wdXRjbGFzcyBcbiAgICAgICAgQGRlZmF1bHQgJ2lucHV0LXNtYWxsJ1xuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgaW5wdXRjbGFzczogJ2lucHV0LXNtYWxsJyxcbiAgICAgICAgXG4gICAgICAgIC8qIGRhdGVwaWNrZXIgY29uZmlnICovXG4gICAgICAgIGRhdGVwaWNrZXI6IHtcbiAgICAgICAgICAgIHdlZWtTdGFydDogMCxcbiAgICAgICAgICAgIHN0YXJ0VmlldzogMCxcbiAgICAgICAgICAgIG1pblZpZXdNb2RlOiAwLFxuICAgICAgICAgICAgYXV0b2Nsb3NlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZWZpZWxkID0gRGF0ZUZpZWxkO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcbi8qKlxuQm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLiAgXG5CYXNlZCBvbiBbc21hbG90IGJvb3RzdHJhcC1kYXRldGltZXBpY2tlciBwbHVnaW5dKGh0dHBzOi8vZ2l0aHViLmNvbS9zbWFsb3QvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyKS4gXG5CZWZvcmUgdXNhZ2UgeW91IHNob3VsZCBtYW51YWxseSBpbmNsdWRlIGRlcGVuZGVudCBqcyBhbmQgY3NzOlxuXG4gICAgPGxpbmsgaHJlZj1cImNzcy9kYXRldGltZXBpY2tlci5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCI+PC9saW5rPiBcbiAgICA8c2NyaXB0IHNyYz1cImpzL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci5qc1wiPjwvc2NyaXB0PlxuXG5Gb3IgKippMThuKiogeW91IHNob3VsZCBpbmNsdWRlIGpzIGZpbGUgZnJvbSBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vc21hbG90L2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci90cmVlL21hc3Rlci9qcy9sb2NhbGVzXG5hbmQgc2V0IGBsYW5ndWFnZWAgb3B0aW9uLiAgXG5cbkBjbGFzcyBkYXRldGltZVxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQGZpbmFsXG5Ac2luY2UgMS40LjRcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwibGFzdF9zZWVuXCIgZGF0YS10eXBlPVwiZGF0ZXRpbWVcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiB0aXRsZT1cIlNlbGVjdCBkYXRlICYgdGltZVwiPjE1LzAzLzIwMTMgMTI6NDU8L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNsYXN0X3NlZW4nKS5lZGl0YWJsZSh7XG4gICAgICAgIGZvcm1hdDogJ3l5eXktbW0tZGQgaGg6aWknLCAgICBcbiAgICAgICAgdmlld2Zvcm1hdDogJ2RkL21tL3l5eXkgaGg6aWknLCAgICBcbiAgICAgICAgZGF0ZXRpbWVwaWNrZXI6IHtcbiAgICAgICAgICAgICAgICB3ZWVrU3RhcnQ6IDFcbiAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG5cbiAgICB2YXIgRGF0ZVRpbWUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2RhdGV0aW1lJywgb3B0aW9ucywgRGF0ZVRpbWUuZGVmYXVsdHMpO1xuICAgICAgICB0aGlzLmluaXRQaWNrZXIob3B0aW9ucywgRGF0ZVRpbWUuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChEYXRlVGltZSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpO1xuXG4gICAgJC5leHRlbmQoRGF0ZVRpbWUucHJvdG90eXBlLCB7XG4gICAgICAgIGluaXRQaWNrZXI6IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAvLydmb3JtYXQnIGlzIHNldCBkaXJlY3RseSBmcm9tIHNldHRpbmdzIG9yIGRhdGEtKiBhdHRyaWJ1dGVzXG5cbiAgICAgICAgICAgIC8vYnkgZGVmYXVsdCB2aWV3Zm9ybWF0IGVxdWFscyB0byBmb3JtYXRcbiAgICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy52aWV3Zm9ybWF0ID0gdGhpcy5vcHRpb25zLmZvcm1hdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy90cnkgcGFyc2UgZGF0ZXRpbWVwaWNrZXIgY29uZmlnIGRlZmluZWQgYXMganNvbiBzdHJpbmcgaW4gZGF0YS1kYXRldGltZXBpY2tlclxuICAgICAgICAgICAgb3B0aW9ucy5kYXRldGltZXBpY2tlciA9ICQuZm4uZWRpdGFibGV1dGlscy50cnlQYXJzZUpzb24ob3B0aW9ucy5kYXRldGltZXBpY2tlciwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vb3ZlcnJpZGluZyBkYXRldGltZXBpY2tlciBjb25maWcgKGFzIGJ5IGRlZmF1bHQgalF1ZXJ5IGV4dGVuZCgpIGlzIG5vdCByZWN1cnNpdmUpXG4gICAgICAgICAgICAvL3NpbmNlIDEuNCBkYXRldGltZXBpY2tlciBpbnRlcm5hbGx5IHVzZXMgdmlld2Zvcm1hdCBpbnN0ZWFkIG9mIGZvcm1hdC4gRm9ybWF0IGlzIGZvciBzdWJtaXQgb25seVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLmRhdGV0aW1lcGlja2VyLCBvcHRpb25zLmRhdGV0aW1lcGlja2VyLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vbGFuZ3VhZ2VcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlci5sYW5ndWFnZSA9IHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlci5sYW5ndWFnZSB8fCAnZW4nOyBcblxuICAgICAgICAgICAgLy9zdG9yZSBEUGdsb2JhbFxuICAgICAgICAgICAgdGhpcy5kcGcgPSAkLmZuLmRhdGV0aW1lcGlja2VyLkRQR2xvYmFsOyBcblxuICAgICAgICAgICAgLy9zdG9yZSBwYXJzZWQgZm9ybWF0c1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRGb3JtYXQgPSB0aGlzLmRwZy5wYXJzZUZvcm1hdCh0aGlzLm9wdGlvbnMuZm9ybWF0LCB0aGlzLm9wdGlvbnMuZm9ybWF0VHlwZSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFZpZXdGb3JtYXQgPSB0aGlzLmRwZy5wYXJzZUZvcm1hdCh0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCwgdGhpcy5vcHRpb25zLmZvcm1hdFR5cGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuZGF0ZXRpbWVwaWNrZXIodGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyKTtcblxuICAgICAgICAgICAgLy9hZGp1c3QgY29udGFpbmVyIHBvc2l0aW9uIHdoZW4gdmlld01vZGUgY2hhbmdlc1xuICAgICAgICAgICAgLy9zZWUgaHR0cHM6Ly9naXRodWIuY29tL3NtYWxvdC9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvcHVsbC84MFxuICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2NoYW5nZU1vZGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAvL3RpbWVvdXQgaGVyZSwgb3RoZXJ3aXNlIGNvbnRhaW5lciBjaGFuZ2VzIHBvc2l0aW9uIGJlZm9yZSBmb3JtIGhhcyBuZXcgc2l6ZVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgZi50cmlnZ2VySGFuZGxlcigncmVzaXplJyk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9cImNsZWFyXCIgbGlua1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmNsZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2xlYXIgPSAkKCc8YSBocmVmPVwiI1wiPjwvYT4nKS5odG1sKHRoaXMub3B0aW9ucy5jbGVhcikuY2xpY2soJC5wcm94eShmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy4kdHBsLnBhcmVudCgpLmFwcGVuZCgkKCc8ZGl2IGNsYXNzPVwiZWRpdGFibGUtY2xlYXJcIj4nKS5hcHBlbmQodGhpcy4kY2xlYXIpKTsgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlMmh0bWw6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAvL2Zvcm1hdERhdGUgd29ya3Mgd2l0aCBVVENEYXRlIVxuICAgICAgICAgICAgdmFyIHRleHQgPSB2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodGhpcy50b1VUQyh2YWx1ZSksIHRoaXMucGFyc2VkVmlld0Zvcm1hdCwgdGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyLmxhbmd1YWdlLCB0aGlzLm9wdGlvbnMuZm9ybWF0VHlwZSkgOiAnJztcbiAgICAgICAgICAgIGlmKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBEYXRlVGltZS5zdXBlcmNsYXNzLnZhbHVlMmh0bWwuY2FsbCh0aGlzLCB0ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgLy9wYXJzZURhdGUgcmV0dXJuIHV0YyBkYXRlIVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZURhdGUoaHRtbCwgdGhpcy5wYXJzZWRWaWV3Rm9ybWF0KTsgXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPyB0aGlzLmZyb21VVEModmFsdWUpIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZTJzdHI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAvL2Zvcm1hdERhdGUgd29ya3Mgd2l0aCBVVENEYXRlIVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdGhpcy5kcGcuZm9ybWF0RGF0ZSh0aGlzLnRvVVRDKHZhbHVlKSwgdGhpcy5wYXJzZWRGb3JtYXQsIHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlci5sYW5ndWFnZSwgdGhpcy5vcHRpb25zLmZvcm1hdFR5cGUpIDogJyc7XG4gICAgICAgfSxcblxuICAgICAgIHN0cjJ2YWx1ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgIC8vcGFyc2VEYXRlIHJldHVybiB1dGMgZGF0ZSFcbiAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZURhdGUoc3RyLCB0aGlzLnBhcnNlZEZvcm1hdCk7XG4gICAgICAgICAgIHJldHVybiB2YWx1ZSA/IHRoaXMuZnJvbVVUQyh2YWx1ZSkgOiBudWxsO1xuICAgICAgIH0sXG5cbiAgICAgICB2YWx1ZTJzdWJtaXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlMnN0cih2YWx1ZSk7XG4gICAgICAgfSxcblxuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICBpZih2YWx1ZSkge1xuICAgICAgICAgICAgIHRoaXMuJGlucHV0LmRhdGEoJ2RhdGV0aW1lcGlja2VyJykuc2V0RGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgIH1cbiAgICAgICB9LFxuXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgLy9kYXRlIG1heSBiZSBjbGVhcmVkLCBpbiB0aGF0IGNhc2UgZ2V0RGF0ZSgpIHRyaWdnZXJzIGVycm9yXG4gICAgICAgICAgIHZhciBkdCA9IHRoaXMuJGlucHV0LmRhdGEoJ2RhdGV0aW1lcGlja2VyJyk7XG4gICAgICAgICAgIHJldHVybiBkdC5kYXRlID8gZHQuZ2V0RGF0ZSgpIDogbnVsbDtcbiAgICAgICB9LFxuXG4gICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgIH0sXG5cbiAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy4kaW5wdXQuZGF0YSgnZGF0ZXRpbWVwaWNrZXInKS5kYXRlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiRpbnB1dC5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuc2hvd2J1dHRvbnMpIHtcbiAgICAgICAgICAgICB0aGlzLiRpbnB1dC5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7IFxuICAgICAgICAgIH0gICAgICAgICAgXG4gICAgICAgfSxcblxuICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC5vbignbW91c2V1cCcsICcubWludXRlJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICB2YXIgJGZvcm0gPSAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgJGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICB9KTtcbiAgICAgICB9LFxuXG4gICAgICAgLy9jb252ZXJ0IGRhdGUgZnJvbSBsb2NhbCB0byB1dGNcbiAgICAgICB0b1VUQzogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgIHJldHVybiB2YWx1ZSA/IG5ldyBEYXRlKHZhbHVlLnZhbHVlT2YoKSAtIHZhbHVlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMCkgOiB2YWx1ZTsgIFxuICAgICAgIH0sXG5cbiAgICAgICAvL2NvbnZlcnQgZGF0ZSBmcm9tIHV0YyB0byBsb2NhbFxuICAgICAgIGZyb21VVEM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICByZXR1cm4gdmFsdWUgPyBuZXcgRGF0ZSh2YWx1ZS52YWx1ZU9mKCkgKyB2YWx1ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApIDogdmFsdWU7ICBcbiAgICAgICB9LFxuXG4gICAgICAgLypcbiAgICAgICAgRm9yIGluY29ycmVjdCBkYXRlIGJvb3RzdHJhcC1kYXRldGltZXBpY2tlciByZXR1cm5zIGN1cnJlbnQgZGF0ZSB0aGF0IGlzIG5vdCBzdWl0YWJsZVxuICAgICAgICBmb3IgZGF0ZXRpbWVmaWVsZC5cbiAgICAgICAgVGhpcyBmdW5jdGlvbiByZXR1cm5zIG51bGwgZm9yIGluY29ycmVjdCBkYXRlLiAgXG4gICAgICAgKi9cbiAgICAgICBwYXJzZURhdGU6IGZ1bmN0aW9uKHN0ciwgZm9ybWF0KSB7XG4gICAgICAgICAgIHZhciBkYXRlID0gbnVsbCwgZm9ybWF0dGVkQmFjaztcbiAgICAgICAgICAgaWYoc3RyKSB7XG4gICAgICAgICAgICAgICBkYXRlID0gdGhpcy5kcGcucGFyc2VEYXRlKHN0ciwgZm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXRpbWVwaWNrZXIubGFuZ3VhZ2UsIHRoaXMub3B0aW9ucy5mb3JtYXRUeXBlKTtcbiAgICAgICAgICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkQmFjayA9IHRoaXMuZHBnLmZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXRpbWVwaWNrZXIubGFuZ3VhZ2UsIHRoaXMub3B0aW9ucy5mb3JtYXRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICBpZihzdHIgIT09IGZvcm1hdHRlZEJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIERhdGVUaW1lLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICBAZGVmYXVsdCA8ZGl2PjwvZGl2PlxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdHBsOic8ZGl2IGNsYXNzPVwiZWRpdGFibGUtZGF0ZSB3ZWxsXCI+PC9kaXY+JyxcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBpbnB1dGNsYXNzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgRm9ybWF0IHVzZWQgZm9yIHNlbmRpbmcgdmFsdWUgdG8gc2VydmVyLiBBbHNvIGFwcGxpZWQgd2hlbiBjb252ZXJ0aW5nIGRhdGUgZnJvbSA8Y29kZT5kYXRhLXZhbHVlPC9jb2RlPiBhdHRyaWJ1dGUuPGJyPlxuICAgICAgICBQb3NzaWJsZSB0b2tlbnMgYXJlOiA8Y29kZT5kLCBkZCwgbSwgbW0sIHl5LCB5eXl5LCBoLCBpPC9jb2RlPiAgXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgZm9ybWF0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgeXl5eS1tbS1kZCBoaDppaVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgZm9ybWF0Oid5eXl5LW1tLWRkIGhoOmlpJyxcbiAgICAgICAgZm9ybWF0VHlwZTonc3RhbmRhcmQnLFxuICAgICAgICAvKipcbiAgICAgICAgRm9ybWF0IHVzZWQgZm9yIGRpc3BsYXlpbmcgZGF0ZS4gQWxzbyBhcHBsaWVkIHdoZW4gY29udmVydGluZyBkYXRlIGZyb20gZWxlbWVudCdzIHRleHQgb24gaW5pdC4gICBcbiAgICAgICAgSWYgbm90IHNwZWNpZmllZCBlcXVhbHMgdG8gPGNvZGU+Zm9ybWF0PC9jb2RlPlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IHZpZXdmb3JtYXQgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICB2aWV3Zm9ybWF0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgQ29uZmlndXJhdGlvbiBvZiBkYXRldGltZXBpY2tlci5cbiAgICAgICAgRnVsbCBsaXN0IG9mIG9wdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9zbWFsb3QvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyXG5cbiAgICAgICAgQHByb3BlcnR5IGRhdGV0aW1lcGlja2VyIFxuICAgICAgICBAdHlwZSBvYmplY3RcbiAgICAgICAgQGRlZmF1bHQgeyB9XG4gICAgICAgICoqL1xuICAgICAgICBkYXRldGltZXBpY2tlcjp7XG4gICAgICAgICAgICB0b2RheUhpZ2hsaWdodDogZmFsc2UsXG4gICAgICAgICAgICBhdXRvY2xvc2U6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICBUZXh0IHNob3duIGFzIGNsZWFyIGRhdGUgYnV0dG9uLiBcbiAgICAgICAgSWYgPGNvZGU+ZmFsc2U8L2NvZGU+IGNsZWFyIGJ1dHRvbiB3aWxsIG5vdCBiZSByZW5kZXJlZC5cblxuICAgICAgICBAcHJvcGVydHkgY2xlYXIgXG4gICAgICAgIEB0eXBlIGJvb2xlYW58c3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICd4IGNsZWFyJ1xuICAgICAgICAqKi9cbiAgICAgICAgY2xlYXI6ICcmdGltZXM7IGNsZWFyJ1xuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGV0aW1lID0gRGF0ZVRpbWU7XG5cbn0od2luZG93LmpRdWVyeSkpO1xuLyoqXG5Cb290c3RyYXAgZGF0ZXRpbWVmaWVsZCBpbnB1dCAtIGRhdGV0aW1lIGlucHV0IGZvciBpbmxpbmUgbW9kZS5cblNob3dzIG5vcm1hbCA8aW5wdXQgdHlwZT1cInRleHRcIj4gYW5kIGJpbmRzIHBvcHVwIGRhdGV0aW1lcGlja2VyLiAgXG5BdXRvbWF0aWNhbGx5IHNob3duIGluIGlubGluZSBtb2RlLlxuXG5AY2xhc3MgZGF0ZXRpbWVmaWVsZFxuQGV4dGVuZHMgZGF0ZXRpbWVcblxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG4gICAgXG4gICAgdmFyIERhdGVUaW1lRmllbGQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2RhdGV0aW1lZmllbGQnLCBvcHRpb25zLCBEYXRlVGltZUZpZWxkLmRlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5pbml0UGlja2VyKG9wdGlvbnMsIERhdGVUaW1lRmllbGQuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChEYXRlVGltZUZpZWxkLCAkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZXRpbWUpO1xuICAgIFxuICAgICQuZXh0ZW5kKERhdGVUaW1lRmllbGQucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQgPSB0aGlzLiR0cGwuZmluZCgnaW5wdXQnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cigncGxhY2Vob2xkZXInKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kdHBsLmRhdGV0aW1lcGlja2VyKHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vbmVlZCB0byBkaXNhYmxlIG9yaWdpbmFsIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vZmYoJ2ZvY3VzIGtleWRvd24nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy91cGRhdGUgdmFsdWUgb2YgZGF0ZXBpY2tlclxuICAgICAgICAgICAgdGhpcy4kaW5wdXQua2V5dXAoJC5wcm94eShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgdGhpcy4kdHBsLnJlbW92ZURhdGEoJ2RhdGUnKTtcbiAgICAgICAgICAgICAgIHRoaXMuJHRwbC5kYXRldGltZXBpY2tlcigndXBkYXRlJyk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSwgICBcbiAgICAgIFxuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwodGhpcy52YWx1ZTJodG1sKHZhbHVlKSk7XG4gICAgICAgICAgIHRoaXMuJHRwbC5kYXRldGltZXBpY2tlcigndXBkYXRlJyk7XG4gICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuaHRtbDJ2YWx1ZSh0aGlzLiRpbnB1dC52YWwoKSk7XG4gICAgICAgfSwgICAgICAgICAgICAgIFxuICAgICAgICBcbiAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0LnByb3RvdHlwZS5hY3RpdmF0ZS5jYWxsKHRoaXMpO1xuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgYXV0b3N1Ym1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAvL3Jlc2V0IGF1dG9zdWJtaXQgdG8gZW1wdHkgIFxuICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBEYXRlVGltZUZpZWxkLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5kYXRldGltZS5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbCBcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHRwbDonPGRpdiBjbGFzcz1cImlucHV0LWFwcGVuZCBkYXRlXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIvPjxzcGFuIGNsYXNzPVwiYWRkLW9uXCI+PGkgY2xhc3M9XCJpY29uLXRoXCI+PC9pPjwvc3Bhbj48L2Rpdj4nLFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3MgXG4gICAgICAgIEBkZWZhdWx0ICdpbnB1dC1tZWRpdW0nXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBpbnB1dGNsYXNzOiAnaW5wdXQtbWVkaXVtJyxcbiAgICAgICAgXG4gICAgICAgIC8qIGRhdGV0aW1lcGlja2VyIGNvbmZpZyAqL1xuICAgICAgICBkYXRldGltZXBpY2tlcjp7XG4gICAgICAgICAgICB0b2RheUhpZ2hsaWdodDogZmFsc2UsXG4gICAgICAgICAgICBhdXRvY2xvc2U6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5kYXRldGltZWZpZWxkID0gRGF0ZVRpbWVGaWVsZDtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VkaXRhYmxlL2pzL2Jvb3RzdHJhcC1lZGl0YWJsZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n")},function(module,exports,__webpack_require__){eval('var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nwindow.$ = window.jQuery = __webpack_require__(6);\n/*!\n * Bootstrap v3.3.5 (http://getbootstrap.com)\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under the MIT license\n */\nif ("undefined" == typeof jQuery) throw new Error("Bootstrap\'s JavaScript requires jQuery");+function (a) {\n  "use strict";\n  var b = a.fn.jquery.split(" ")[0].split(".");if (b[0] < 2 && b[1] < 9 || 1 == b[0] && 9 == b[1] && b[2] < 1) throw new Error("Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher");\n}(jQuery), +function (a) {\n  "use strict";\n  function b() {\n    var a = document.createElement("bootstrap"),\n        b = { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd otransitionend", transition: "transitionend" };for (var c in b) {\n      if (void 0 !== a.style[c]) return { end: b[c] };\n    }return !1;\n  }a.fn.emulateTransitionEnd = function (b) {\n    var c = !1,\n        d = this;a(this).one("bsTransitionEnd", function () {\n      c = !0;\n    });var e = function e() {\n      c || a(d).trigger(a.support.transition.end);\n    };return setTimeout(e, b), this;\n  }, a(function () {\n    a.support.transition = b(), a.support.transition && (a.event.special.bsTransitionEnd = { bindType: a.support.transition.end, delegateType: a.support.transition.end, handle: function handle(b) {\n        return a(b.target).is(this) ? b.handleObj.handler.apply(this, arguments) : void 0;\n      } });\n  });\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    return this.each(function () {\n      var c = a(this),\n          e = c.data("bs.alert");e || c.data("bs.alert", e = new d(this)), "string" == typeof b && e[b].call(c);\n    });\n  }var c = \'[data-dismiss="alert"]\',\n      d = function d(b) {\n    a(b).on("click", c, this.close);\n  };d.VERSION = "3.3.5", d.TRANSITION_DURATION = 150, d.prototype.close = function (b) {\n    function c() {\n      g.detach().trigger("closed.bs.alert").remove();\n    }var e = a(this),\n        f = e.attr("data-target");f || (f = e.attr("href"), f = f && f.replace(/.*(?=#[^\\s]*$)/, ""));var g = a(f);b && b.preventDefault(), g.length || (g = e.closest(".alert")), g.trigger(b = a.Event("close.bs.alert")), b.isDefaultPrevented() || (g.removeClass("in"), a.support.transition && g.hasClass("fade") ? g.one("bsTransitionEnd", c).emulateTransitionEnd(d.TRANSITION_DURATION) : c());\n  };var e = a.fn.alert;a.fn.alert = b, a.fn.alert.Constructor = d, a.fn.alert.noConflict = function () {\n    return a.fn.alert = e, this;\n  }, a(document).on("click.bs.alert.data-api", c, d.prototype.close);\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data("bs.button"),\n          f = "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b;e || d.data("bs.button", e = new c(this, f)), "toggle" == b ? e.toggle() : b && e.setState(b);\n    });\n  }var c = function c(b, d) {\n    this.$element = a(b), this.options = a.extend({}, c.DEFAULTS, d), this.isLoading = !1;\n  };c.VERSION = "3.3.5", c.DEFAULTS = { loadingText: "loading..." }, c.prototype.setState = function (b) {\n    var c = "disabled",\n        d = this.$element,\n        e = d.is("input") ? "val" : "html",\n        f = d.data();b += "Text", null == f.resetText && d.data("resetText", d[e]()), setTimeout(a.proxy(function () {\n      d[e](null == f[b] ? this.options[b] : f[b]), "loadingText" == b ? (this.isLoading = !0, d.addClass(c).attr(c, c)) : this.isLoading && (this.isLoading = !1, d.removeClass(c).removeAttr(c));\n    }, this), 0);\n  }, c.prototype.toggle = function () {\n    var a = !0,\n        b = this.$element.closest(\'[data-toggle="buttons"]\');if (b.length) {\n      var c = this.$element.find("input");"radio" == c.prop("type") ? (c.prop("checked") && (a = !1), b.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == c.prop("type") && (c.prop("checked") !== this.$element.hasClass("active") && (a = !1), this.$element.toggleClass("active")), c.prop("checked", this.$element.hasClass("active")), a && c.trigger("change");\n    } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active");\n  };var d = a.fn.button;a.fn.button = b, a.fn.button.Constructor = c, a.fn.button.noConflict = function () {\n    return a.fn.button = d, this;\n  }, a(document).on("click.bs.button.data-api", \'[data-toggle^="button"]\', function (c) {\n    var d = a(c.target);d.hasClass("btn") || (d = d.closest(".btn")), b.call(d, "toggle"), a(c.target).is(\'input[type="radio"]\') || a(c.target).is(\'input[type="checkbox"]\') || c.preventDefault();\n  }).on("focus.bs.button.data-api blur.bs.button.data-api", \'[data-toggle^="button"]\', function (b) {\n    a(b.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(b.type));\n  });\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data("bs.carousel"),\n          f = a.extend({}, c.DEFAULTS, d.data(), "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b),\n          g = "string" == typeof b ? b : f.slide;e || d.data("bs.carousel", e = new c(this, f)), "number" == typeof b ? e.to(b) : g ? e[g]() : f.interval && e.pause().cycle();\n    });\n  }var c = function c(b, _c) {\n    this.$element = a(b), this.$indicators = this.$element.find(".carousel-indicators"), this.options = _c, this.paused = null, this.sliding = null, this.interval = null, this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", a.proxy(this.keydown, this)), "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", a.proxy(this.pause, this)).on("mouseleave.bs.carousel", a.proxy(this.cycle, this));\n  };c.VERSION = "3.3.5", c.TRANSITION_DURATION = 600, c.DEFAULTS = { interval: 5e3, pause: "hover", wrap: !0, keyboard: !0 }, c.prototype.keydown = function (a) {\n    if (!/input|textarea/i.test(a.target.tagName)) {\n      switch (a.which) {case 37:\n          this.prev();break;case 39:\n          this.next();break;default:\n          return;}a.preventDefault();\n    }\n  }, c.prototype.cycle = function (b) {\n    return b || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(a.proxy(this.next, this), this.options.interval)), this;\n  }, c.prototype.getItemIndex = function (a) {\n    return this.$items = a.parent().children(".item"), this.$items.index(a || this.$active);\n  }, c.prototype.getItemForDirection = function (a, b) {\n    var c = this.getItemIndex(b),\n        d = "prev" == a && 0 === c || "next" == a && c == this.$items.length - 1;if (d && !this.options.wrap) return b;var e = "prev" == a ? -1 : 1,\n        f = (c + e) % this.$items.length;return this.$items.eq(f);\n  }, c.prototype.to = function (a) {\n    var b = this,\n        c = this.getItemIndex(this.$active = this.$element.find(".item.active"));return a > this.$items.length - 1 || 0 > a ? void 0 : this.sliding ? this.$element.one("slid.bs.carousel", function () {\n      b.to(a);\n    }) : c == a ? this.pause().cycle() : this.slide(a > c ? "next" : "prev", this.$items.eq(a));\n  }, c.prototype.pause = function (b) {\n    return b || (this.paused = !0), this.$element.find(".next, .prev").length && a.support.transition && (this.$element.trigger(a.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this;\n  }, c.prototype.next = function () {\n    return this.sliding ? void 0 : this.slide("next");\n  }, c.prototype.prev = function () {\n    return this.sliding ? void 0 : this.slide("prev");\n  }, c.prototype.slide = function (b, d) {\n    var e = this.$element.find(".item.active"),\n        f = d || this.getItemForDirection(b, e),\n        g = this.interval,\n        h = "next" == b ? "left" : "right",\n        i = this;if (f.hasClass("active")) return this.sliding = !1;var j = f[0],\n        k = a.Event("slide.bs.carousel", { relatedTarget: j, direction: h });if (this.$element.trigger(k), !k.isDefaultPrevented()) {\n      if (this.sliding = !0, g && this.pause(), this.$indicators.length) {\n        this.$indicators.find(".active").removeClass("active");var l = a(this.$indicators.children()[this.getItemIndex(f)]);l && l.addClass("active");\n      }var m = a.Event("slid.bs.carousel", { relatedTarget: j, direction: h });return a.support.transition && this.$element.hasClass("slide") ? (f.addClass(b), f[0].offsetWidth, e.addClass(h), f.addClass(h), e.one("bsTransitionEnd", function () {\n        f.removeClass([b, h].join(" ")).addClass("active"), e.removeClass(["active", h].join(" ")), i.sliding = !1, setTimeout(function () {\n          i.$element.trigger(m);\n        }, 0);\n      }).emulateTransitionEnd(c.TRANSITION_DURATION)) : (e.removeClass("active"), f.addClass("active"), this.sliding = !1, this.$element.trigger(m)), g && this.cycle(), this;\n    }\n  };var d = a.fn.carousel;a.fn.carousel = b, a.fn.carousel.Constructor = c, a.fn.carousel.noConflict = function () {\n    return a.fn.carousel = d, this;\n  };var e = function e(c) {\n    var d,\n        e = a(this),\n        f = a(e.attr("data-target") || (d = e.attr("href")) && d.replace(/.*(?=#[^\\s]+$)/, ""));if (f.hasClass("carousel")) {\n      var g = a.extend({}, f.data(), e.data()),\n          h = e.attr("data-slide-to");h && (g.interval = !1), b.call(f, g), h && f.data("bs.carousel").to(h), c.preventDefault();\n    }\n  };a(document).on("click.bs.carousel.data-api", "[data-slide]", e).on("click.bs.carousel.data-api", "[data-slide-to]", e), a(window).on("load", function () {\n    a(\'[data-ride="carousel"]\').each(function () {\n      var c = a(this);b.call(c, c.data());\n    });\n  });\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    var c,\n        d = b.attr("data-target") || (c = b.attr("href")) && c.replace(/.*(?=#[^\\s]+$)/, "");return a(d);\n  }function c(b) {\n    return this.each(function () {\n      var c = a(this),\n          e = c.data("bs.collapse"),\n          f = a.extend({}, d.DEFAULTS, c.data(), "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b);!e && f.toggle && /show|hide/.test(b) && (f.toggle = !1), e || c.data("bs.collapse", e = new d(this, f)), "string" == typeof b && e[b]();\n    });\n  }var d = function d(b, c) {\n    this.$element = a(b), this.options = a.extend({}, d.DEFAULTS, c), this.$trigger = a(\'[data-toggle="collapse"][href="#\' + b.id + \'"],[data-toggle="collapse"][data-target="#\' + b.id + \'"]\'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle();\n  };d.VERSION = "3.3.5", d.TRANSITION_DURATION = 350, d.DEFAULTS = { toggle: !0 }, d.prototype.dimension = function () {\n    var a = this.$element.hasClass("width");return a ? "width" : "height";\n  }, d.prototype.show = function () {\n    if (!this.transitioning && !this.$element.hasClass("in")) {\n      var b,\n          e = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");if (!(e && e.length && (b = e.data("bs.collapse"), b && b.transitioning))) {\n        var f = a.Event("show.bs.collapse");if (this.$element.trigger(f), !f.isDefaultPrevented()) {\n          e && e.length && (c.call(e, "hide"), b || e.data("bs.collapse", null));var g = this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded", !0), this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1;var h = function h() {\n            this.$element.removeClass("collapsing").addClass("collapse in")[g](""), this.transitioning = 0, this.$element.trigger("shown.bs.collapse");\n          };if (!a.support.transition) return h.call(this);var i = a.camelCase(["scroll", g].join("-"));this.$element.one("bsTransitionEnd", a.proxy(h, this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i]);\n        }\n      }\n    }\n  }, d.prototype.hide = function () {\n    if (!this.transitioning && this.$element.hasClass("in")) {\n      var b = a.Event("hide.bs.collapse");if (this.$element.trigger(b), !b.isDefaultPrevented()) {\n        var c = this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1;var e = function e() {\n          this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse");\n        };return a.support.transition ? void this.$element[c](0).one("bsTransitionEnd", a.proxy(e, this)).emulateTransitionEnd(d.TRANSITION_DURATION) : e.call(this);\n      }\n    }\n  }, d.prototype.toggle = function () {\n    this[this.$element.hasClass("in") ? "hide" : "show"]();\n  }, d.prototype.getParent = function () {\n    return a(this.options.parent).find(\'[data-toggle="collapse"][data-parent="\' + this.options.parent + \'"]\').each(a.proxy(function (c, d) {\n      var e = a(d);this.addAriaAndCollapsedClass(b(e), e);\n    }, this)).end();\n  }, d.prototype.addAriaAndCollapsedClass = function (a, b) {\n    var c = a.hasClass("in");a.attr("aria-expanded", c), b.toggleClass("collapsed", !c).attr("aria-expanded", c);\n  };var e = a.fn.collapse;a.fn.collapse = c, a.fn.collapse.Constructor = d, a.fn.collapse.noConflict = function () {\n    return a.fn.collapse = e, this;\n  }, a(document).on("click.bs.collapse.data-api", \'[data-toggle="collapse"]\', function (d) {\n    var e = a(this);e.attr("data-target") || d.preventDefault();var f = b(e),\n        g = f.data("bs.collapse"),\n        h = g ? "toggle" : e.data();c.call(f, h);\n  });\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    var c = b.attr("data-target");c || (c = b.attr("href"), c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\\s]*$)/, ""));var d = c && a(c);return d && d.length ? d : b.parent();\n  }function c(c) {\n    c && 3 === c.which || (a(e).remove(), a(f).each(function () {\n      var d = a(this),\n          e = b(d),\n          f = { relatedTarget: this };e.hasClass("open") && (c && "click" == c.type && /input|textarea/i.test(c.target.tagName) && a.contains(e[0], c.target) || (e.trigger(c = a.Event("hide.bs.dropdown", f)), c.isDefaultPrevented() || (d.attr("aria-expanded", "false"), e.removeClass("open").trigger("hidden.bs.dropdown", f))));\n    }));\n  }function d(b) {\n    return this.each(function () {\n      var c = a(this),\n          d = c.data("bs.dropdown");d || c.data("bs.dropdown", d = new g(this)), "string" == typeof b && d[b].call(c);\n    });\n  }var e = ".dropdown-backdrop",\n      f = \'[data-toggle="dropdown"]\',\n      g = function g(b) {\n    a(b).on("click.bs.dropdown", this.toggle);\n  };g.VERSION = "3.3.5", g.prototype.toggle = function (d) {\n    var e = a(this);if (!e.is(".disabled, :disabled")) {\n      var f = b(e),\n          g = f.hasClass("open");if (c(), !g) {\n        "ontouchstart" in document.documentElement && !f.closest(".navbar-nav").length && a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click", c);var h = { relatedTarget: this };if (f.trigger(d = a.Event("show.bs.dropdown", h)), d.isDefaultPrevented()) return;e.trigger("focus").attr("aria-expanded", "true"), f.toggleClass("open").trigger("shown.bs.dropdown", h);\n      }return !1;\n    }\n  }, g.prototype.keydown = function (c) {\n    if (/(38|40|27|32)/.test(c.which) && !/input|textarea/i.test(c.target.tagName)) {\n      var d = a(this);if (c.preventDefault(), c.stopPropagation(), !d.is(".disabled, :disabled")) {\n        var e = b(d),\n            g = e.hasClass("open");if (!g && 27 != c.which || g && 27 == c.which) return 27 == c.which && e.find(f).trigger("focus"), d.trigger("click");var h = " li:not(.disabled):visible a",\n            i = e.find(".dropdown-menu" + h);if (i.length) {\n          var j = i.index(c.target);38 == c.which && j > 0 && j--, 40 == c.which && j < i.length - 1 && j++, ~j || (j = 0), i.eq(j).trigger("focus");\n        }\n      }\n    }\n  };var h = a.fn.dropdown;a.fn.dropdown = d, a.fn.dropdown.Constructor = g, a.fn.dropdown.noConflict = function () {\n    return a.fn.dropdown = h, this;\n  }, a(document).on("click.bs.dropdown.data-api", c).on("click.bs.dropdown.data-api", ".dropdown form", function (a) {\n    a.stopPropagation();\n  }).on("click.bs.dropdown.data-api", f, g.prototype.toggle).on("keydown.bs.dropdown.data-api", f, g.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", g.prototype.keydown);\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b, d) {\n    return this.each(function () {\n      var e = a(this),\n          f = e.data("bs.modal"),\n          g = a.extend({}, c.DEFAULTS, e.data(), "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b);f || e.data("bs.modal", f = new c(this, g)), "string" == typeof b ? f[b](d) : g.show && f.show(d);\n    });\n  }var c = function c(b, _c2) {\n    this.options = _c2, this.$body = a(document.body), this.$element = a(b), this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, a.proxy(function () {\n      this.$element.trigger("loaded.bs.modal");\n    }, this));\n  };c.VERSION = "3.3.5", c.TRANSITION_DURATION = 300, c.BACKDROP_TRANSITION_DURATION = 150, c.DEFAULTS = { backdrop: !0, keyboard: !0, show: !0 }, c.prototype.toggle = function (a) {\n    return this.isShown ? this.hide() : this.show(a);\n  }, c.prototype.show = function (b) {\n    var d = this,\n        e = a.Event("show.bs.modal", { relatedTarget: b });this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", \'[data-dismiss="modal"]\', a.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", function () {\n      d.$element.one("mouseup.dismiss.bs.modal", function (b) {\n        a(b.target).is(d.$element) && (d.ignoreBackdropClick = !0);\n      });\n    }), this.backdrop(function () {\n      var e = a.support.transition && d.$element.hasClass("fade");d.$element.parent().length || d.$element.appendTo(d.$body), d.$element.show().scrollTop(0), d.adjustDialog(), e && d.$element[0].offsetWidth, d.$element.addClass("in"), d.enforceFocus();var f = a.Event("shown.bs.modal", { relatedTarget: b });e ? d.$dialog.one("bsTransitionEnd", function () {\n        d.$element.trigger("focus").trigger(f);\n      }).emulateTransitionEnd(c.TRANSITION_DURATION) : d.$element.trigger("focus").trigger(f);\n    }));\n  }, c.prototype.hide = function (b) {\n    b && b.preventDefault(), b = a.Event("hide.bs.modal"), this.$element.trigger(b), this.isShown && !b.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), a(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), a.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", a.proxy(this.hideModal, this)).emulateTransitionEnd(c.TRANSITION_DURATION) : this.hideModal());\n  }, c.prototype.enforceFocus = function () {\n    a(document).off("focusin.bs.modal").on("focusin.bs.modal", a.proxy(function (a) {\n      this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.trigger("focus");\n    }, this));\n  }, c.prototype.escape = function () {\n    this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", a.proxy(function (a) {\n      27 == a.which && this.hide();\n    }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal");\n  }, c.prototype.resize = function () {\n    this.isShown ? a(window).on("resize.bs.modal", a.proxy(this.handleUpdate, this)) : a(window).off("resize.bs.modal");\n  }, c.prototype.hideModal = function () {\n    var a = this;this.$element.hide(), this.backdrop(function () {\n      a.$body.removeClass("modal-open"), a.resetAdjustments(), a.resetScrollbar(), a.$element.trigger("hidden.bs.modal");\n    });\n  }, c.prototype.removeBackdrop = function () {\n    this.$backdrop && this.$backdrop.remove(), this.$backdrop = null;\n  }, c.prototype.backdrop = function (b) {\n    var d = this,\n        e = this.$element.hasClass("fade") ? "fade" : "";if (this.isShown && this.options.backdrop) {\n      var f = a.support.transition && e;if (this.$backdrop = a(document.createElement("div")).addClass("modal-backdrop " + e).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", a.proxy(function (a) {\n        return this.ignoreBackdropClick ? void (this.ignoreBackdropClick = !1) : void (a.target === a.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()));\n      }, this)), f && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !b) return;f ? this.$backdrop.one("bsTransitionEnd", b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : b();\n    } else if (!this.isShown && this.$backdrop) {\n      this.$backdrop.removeClass("in");var g = function g() {\n        d.removeBackdrop(), b && b();\n      };a.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : g();\n    } else b && b();\n  }, c.prototype.handleUpdate = function () {\n    this.adjustDialog();\n  }, c.prototype.adjustDialog = function () {\n    var a = this.$element[0].scrollHeight > document.documentElement.clientHeight;this.$element.css({ paddingLeft: !this.bodyIsOverflowing && a ? this.scrollbarWidth : "", paddingRight: this.bodyIsOverflowing && !a ? this.scrollbarWidth : "" });\n  }, c.prototype.resetAdjustments = function () {\n    this.$element.css({ paddingLeft: "", paddingRight: "" });\n  }, c.prototype.checkScrollbar = function () {\n    var a = window.innerWidth;if (!a) {\n      var b = document.documentElement.getBoundingClientRect();a = b.right - Math.abs(b.left);\n    }this.bodyIsOverflowing = document.body.clientWidth < a, this.scrollbarWidth = this.measureScrollbar();\n  }, c.prototype.setScrollbar = function () {\n    var a = parseInt(this.$body.css("padding-right") || 0, 10);this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", a + this.scrollbarWidth);\n  }, c.prototype.resetScrollbar = function () {\n    this.$body.css("padding-right", this.originalBodyPad);\n  }, c.prototype.measureScrollbar = function () {\n    var a = document.createElement("div");a.className = "modal-scrollbar-measure", this.$body.append(a);var b = a.offsetWidth - a.clientWidth;return this.$body[0].removeChild(a), b;\n  };var d = a.fn.modal;a.fn.modal = b, a.fn.modal.Constructor = c, a.fn.modal.noConflict = function () {\n    return a.fn.modal = d, this;\n  }, a(document).on("click.bs.modal.data-api", \'[data-toggle="modal"]\', function (c) {\n    var d = a(this),\n        e = d.attr("href"),\n        f = a(d.attr("data-target") || e && e.replace(/.*(?=#[^\\s]+$)/, "")),\n        g = f.data("bs.modal") ? "toggle" : a.extend({ remote: !/#/.test(e) && e }, f.data(), d.data());d.is("a") && c.preventDefault(), f.one("show.bs.modal", function (a) {\n      a.isDefaultPrevented() || f.one("hidden.bs.modal", function () {\n        d.is(":visible") && d.trigger("focus");\n      });\n    }), b.call(f, g, this);\n  });\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data("bs.tooltip"),\n          f = "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b;(e || !/destroy|hide/.test(b)) && (e || d.data("bs.tooltip", e = new c(this, f)), "string" == typeof b && e[b]());\n    });\n  }var c = function c(a, b) {\n    this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", a, b);\n  };c.VERSION = "3.3.5", c.TRANSITION_DURATION = 150, c.DEFAULTS = { animation: !0, placement: "top", selector: !1, template: \'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>\', trigger: "hover focus", title: "", delay: 0, html: !1, container: !1, viewport: { selector: "body", padding: 0 } }, c.prototype.init = function (b, c, d) {\n    if (this.enabled = !0, this.type = b, this.$element = a(c), this.options = this.getOptions(d), this.$viewport = this.options.viewport && a(a.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = { click: !1, hover: !1, focus: !1 }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");for (var e = this.options.trigger.split(" "), f = e.length; f--;) {\n      var g = e[f];if ("click" == g) this.$element.on("click." + this.type, this.options.selector, a.proxy(this.toggle, this));else if ("manual" != g) {\n        var h = "hover" == g ? "mouseenter" : "focusin",\n            i = "hover" == g ? "mouseleave" : "focusout";this.$element.on(h + "." + this.type, this.options.selector, a.proxy(this.enter, this)), this.$element.on(i + "." + this.type, this.options.selector, a.proxy(this.leave, this));\n      }\n    }this.options.selector ? this._options = a.extend({}, this.options, { trigger: "manual", selector: "" }) : this.fixTitle();\n  }, c.prototype.getDefaults = function () {\n    return c.DEFAULTS;\n  }, c.prototype.getOptions = function (b) {\n    return b = a.extend({}, this.getDefaults(), this.$element.data(), b), b.delay && "number" == typeof b.delay && (b.delay = { show: b.delay, hide: b.delay }), b;\n  }, c.prototype.getDelegateOptions = function () {\n    var b = {},\n        c = this.getDefaults();return this._options && a.each(this._options, function (a, d) {\n      c[a] != d && (b[a] = d);\n    }), b;\n  }, c.prototype.enter = function (b) {\n    var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type);return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusin" == b.type ? "focus" : "hover"] = !0), c.tip().hasClass("in") || "in" == c.hoverState ? void (c.hoverState = "in") : (clearTimeout(c.timeout), c.hoverState = "in", c.options.delay && c.options.delay.show ? void (c.timeout = setTimeout(function () {\n      "in" == c.hoverState && c.show();\n    }, c.options.delay.show)) : c.show());\n  }, c.prototype.isInStateTrue = function () {\n    for (var a in this.inState) {\n      if (this.inState[a]) return !0;\n    }return !1;\n  }, c.prototype.leave = function (b) {\n    var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type);return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusout" == b.type ? "focus" : "hover"] = !1), c.isInStateTrue() ? void 0 : (clearTimeout(c.timeout), c.hoverState = "out", c.options.delay && c.options.delay.hide ? void (c.timeout = setTimeout(function () {\n      "out" == c.hoverState && c.hide();\n    }, c.options.delay.hide)) : c.hide());\n  }, c.prototype.show = function () {\n    var b = a.Event("show.bs." + this.type);if (this.hasContent() && this.enabled) {\n      this.$element.trigger(b);var d = a.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);if (b.isDefaultPrevented() || !d) return;var e = this,\n          f = this.tip(),\n          g = this.getUID(this.type);this.setContent(), f.attr("id", g), this.$element.attr("aria-describedby", g), this.options.animation && f.addClass("fade");var h = "function" == typeof this.options.placement ? this.options.placement.call(this, f[0], this.$element[0]) : this.options.placement,\n          i = /\\s?auto?\\s?/i,\n          j = i.test(h);j && (h = h.replace(i, "") || "top"), f.detach().css({ top: 0, left: 0, display: "block" }).addClass(h).data("bs." + this.type, this), this.options.container ? f.appendTo(this.options.container) : f.insertAfter(this.$element), this.$element.trigger("inserted.bs." + this.type);var k = this.getPosition(),\n          l = f[0].offsetWidth,\n          m = f[0].offsetHeight;if (j) {\n        var n = h,\n            o = this.getPosition(this.$viewport);h = "bottom" == h && k.bottom + m > o.bottom ? "top" : "top" == h && k.top - m < o.top ? "bottom" : "right" == h && k.right + l > o.width ? "left" : "left" == h && k.left - l < o.left ? "right" : h, f.removeClass(n).addClass(h);\n      }var p = this.getCalculatedOffset(h, k, l, m);this.applyPlacement(p, h);var q = function q() {\n        var a = e.hoverState;e.$element.trigger("shown.bs." + e.type), e.hoverState = null, "out" == a && e.leave(e);\n      };a.support.transition && this.$tip.hasClass("fade") ? f.one("bsTransitionEnd", q).emulateTransitionEnd(c.TRANSITION_DURATION) : q();\n    }\n  }, c.prototype.applyPlacement = function (b, c) {\n    var d = this.tip(),\n        e = d[0].offsetWidth,\n        f = d[0].offsetHeight,\n        g = parseInt(d.css("margin-top"), 10),\n        h = parseInt(d.css("margin-left"), 10);isNaN(g) && (g = 0), isNaN(h) && (h = 0), b.top += g, b.left += h, a.offset.setOffset(d[0], a.extend({ using: function using(a) {\n        d.css({ top: Math.round(a.top), left: Math.round(a.left) });\n      } }, b), 0), d.addClass("in");var i = d[0].offsetWidth,\n        j = d[0].offsetHeight;"top" == c && j != f && (b.top = b.top + f - j);var k = this.getViewportAdjustedDelta(c, b, i, j);k.left ? b.left += k.left : b.top += k.top;var l = /top|bottom/.test(c),\n        m = l ? 2 * k.left - e + i : 2 * k.top - f + j,\n        n = l ? "offsetWidth" : "offsetHeight";d.offset(b), this.replaceArrow(m, d[0][n], l);\n  }, c.prototype.replaceArrow = function (a, b, c) {\n    this.arrow().css(c ? "left" : "top", 50 * (1 - a / b) + "%").css(c ? "top" : "left", "");\n  }, c.prototype.setContent = function () {\n    var a = this.tip(),\n        b = this.getTitle();a.find(".tooltip-inner")[this.options.html ? "html" : "text"](b), a.removeClass("fade in top bottom left right");\n  }, c.prototype.hide = function (b) {\n    function d() {\n      "in" != e.hoverState && f.detach(), e.$element.removeAttr("aria-describedby").trigger("hidden.bs." + e.type), b && b();\n    }var e = this,\n        f = a(this.$tip),\n        g = a.Event("hide.bs." + this.type);return this.$element.trigger(g), g.isDefaultPrevented() ? void 0 : (f.removeClass("in"), a.support.transition && f.hasClass("fade") ? f.one("bsTransitionEnd", d).emulateTransitionEnd(c.TRANSITION_DURATION) : d(), this.hoverState = null, this);\n  }, c.prototype.fixTitle = function () {\n    var a = this.$element;(a.attr("title") || "string" != typeof a.attr("data-original-title")) && a.attr("data-original-title", a.attr("title") || "").attr("title", "");\n  }, c.prototype.hasContent = function () {\n    return this.getTitle();\n  }, c.prototype.getPosition = function (b) {\n    b = b || this.$element;var c = b[0],\n        d = "BODY" == c.tagName,\n        e = c.getBoundingClientRect();null == e.width && (e = a.extend({}, e, { width: e.right - e.left, height: e.bottom - e.top }));var f = d ? { top: 0, left: 0 } : b.offset(),\n        g = { scroll: d ? document.documentElement.scrollTop || document.body.scrollTop : b.scrollTop() },\n        h = d ? { width: a(window).width(), height: a(window).height() } : null;return a.extend({}, e, g, h, f);\n  }, c.prototype.getCalculatedOffset = function (a, b, c, d) {\n    return "bottom" == a ? { top: b.top + b.height, left: b.left + b.width / 2 - c / 2 } : "top" == a ? { top: b.top - d, left: b.left + b.width / 2 - c / 2 } : "left" == a ? { top: b.top + b.height / 2 - d / 2, left: b.left - c } : { top: b.top + b.height / 2 - d / 2, left: b.left + b.width };\n  }, c.prototype.getViewportAdjustedDelta = function (a, b, c, d) {\n    var e = { top: 0, left: 0 };if (!this.$viewport) return e;var f = this.options.viewport && this.options.viewport.padding || 0,\n        g = this.getPosition(this.$viewport);if (/right|left/.test(a)) {\n      var h = b.top - f - g.scroll,\n          i = b.top + f - g.scroll + d;h < g.top ? e.top = g.top - h : i > g.top + g.height && (e.top = g.top + g.height - i);\n    } else {\n      var j = b.left - f,\n          k = b.left + f + c;j < g.left ? e.left = g.left - j : k > g.right && (e.left = g.left + g.width - k);\n    }return e;\n  }, c.prototype.getTitle = function () {\n    var a,\n        b = this.$element,\n        c = this.options;return a = b.attr("data-original-title") || ("function" == typeof c.title ? c.title.call(b[0]) : c.title);\n  }, c.prototype.getUID = function (a) {\n    do {\n      a += ~~(1e6 * Math.random());\n    } while (document.getElementById(a));return a;\n  }, c.prototype.tip = function () {\n    if (!this.$tip && (this.$tip = a(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");return this.$tip;\n  }, c.prototype.arrow = function () {\n    return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");\n  }, c.prototype.enable = function () {\n    this.enabled = !0;\n  }, c.prototype.disable = function () {\n    this.enabled = !1;\n  }, c.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled;\n  }, c.prototype.toggle = function (b) {\n    var c = this;b && (c = a(b.currentTarget).data("bs." + this.type), c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c))), b ? (c.inState.click = !c.inState.click, c.isInStateTrue() ? c.enter(c) : c.leave(c)) : c.tip().hasClass("in") ? c.leave(c) : c.enter(c);\n  }, c.prototype.destroy = function () {\n    var a = this;clearTimeout(this.timeout), this.hide(function () {\n      a.$element.off("." + a.type).removeData("bs." + a.type), a.$tip && a.$tip.detach(), a.$tip = null, a.$arrow = null, a.$viewport = null;\n    });\n  };var d = a.fn.tooltip;a.fn.tooltip = b, a.fn.tooltip.Constructor = c, a.fn.tooltip.noConflict = function () {\n    return a.fn.tooltip = d, this;\n  };\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data("bs.popover"),\n          f = "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b;(e || !/destroy|hide/.test(b)) && (e || d.data("bs.popover", e = new c(this, f)), "string" == typeof b && e[b]());\n    });\n  }var c = function c(a, b) {\n    this.init("popover", a, b);\n  };if (!a.fn.tooltip) throw new Error("Popover requires tooltip.js");c.VERSION = "3.3.5", c.DEFAULTS = a.extend({}, a.fn.tooltip.Constructor.DEFAULTS, { placement: "right", trigger: "click", content: "", template: \'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>\' }), c.prototype = a.extend({}, a.fn.tooltip.Constructor.prototype), c.prototype.constructor = c, c.prototype.getDefaults = function () {\n    return c.DEFAULTS;\n  }, c.prototype.setContent = function () {\n    var a = this.tip(),\n        b = this.getTitle(),\n        c = this.getContent();a.find(".popover-title")[this.options.html ? "html" : "text"](b), a.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof c ? "html" : "append" : "text"](c), a.removeClass("fade top bottom left right in"), a.find(".popover-title").html() || a.find(".popover-title").hide();\n  }, c.prototype.hasContent = function () {\n    return this.getTitle() || this.getContent();\n  }, c.prototype.getContent = function () {\n    var a = this.$element,\n        b = this.options;return a.attr("data-content") || ("function" == typeof b.content ? b.content.call(a[0]) : b.content);\n  }, c.prototype.arrow = function () {\n    return this.$arrow = this.$arrow || this.tip().find(".arrow");\n  };var d = a.fn.popover;a.fn.popover = b, a.fn.popover.Constructor = c, a.fn.popover.noConflict = function () {\n    return a.fn.popover = d, this;\n  };\n}(jQuery), +function (a) {\n  "use strict";\n  function b(c, d) {\n    this.$body = a(document.body), this.$scrollElement = a(a(c).is(document.body) ? window : c), this.options = a.extend({}, b.DEFAULTS, d), this.selector = (this.options.target || "") + " .nav li > a", this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on("scroll.bs.scrollspy", a.proxy(this.process, this)), this.refresh(), this.process();\n  }function c(c) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data("bs.scrollspy"),\n          f = "object" == (typeof c === "undefined" ? "undefined" : _typeof(c)) && c;e || d.data("bs.scrollspy", e = new b(this, f)), "string" == typeof c && e[c]();\n    });\n  }b.VERSION = "3.3.5", b.DEFAULTS = { offset: 10 }, b.prototype.getScrollHeight = function () {\n    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);\n  }, b.prototype.refresh = function () {\n    var b = this,\n        c = "offset",\n        d = 0;this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), a.isWindow(this.$scrollElement[0]) || (c = "position", d = this.$scrollElement.scrollTop()), this.$body.find(this.selector).map(function () {\n      var b = a(this),\n          e = b.data("target") || b.attr("href"),\n          f = /^#./.test(e) && a(e);return f && f.length && f.is(":visible") && [[f[c]().top + d, e]] || null;\n    }).sort(function (a, b) {\n      return a[0] - b[0];\n    }).each(function () {\n      b.offsets.push(this[0]), b.targets.push(this[1]);\n    });\n  }, b.prototype.process = function () {\n    var a,\n        b = this.$scrollElement.scrollTop() + this.options.offset,\n        c = this.getScrollHeight(),\n        d = this.options.offset + c - this.$scrollElement.height(),\n        e = this.offsets,\n        f = this.targets,\n        g = this.activeTarget;if (this.scrollHeight != c && this.refresh(), b >= d) return g != (a = f[f.length - 1]) && this.activate(a);if (g && b < e[0]) return this.activeTarget = null, this.clear();for (a = e.length; a--;) {\n      g != f[a] && b >= e[a] && (void 0 === e[a + 1] || b < e[a + 1]) && this.activate(f[a]);\n    }\n  }, b.prototype.activate = function (b) {\n    this.activeTarget = b, this.clear();var c = this.selector + \'[data-target="\' + b + \'"],\' + this.selector + \'[href="\' + b + \'"]\',\n        d = a(c).parents("li").addClass("active");d.parent(".dropdown-menu").length && (d = d.closest("li.dropdown").addClass("active")), d.trigger("activate.bs.scrollspy");\n  }, b.prototype.clear = function () {\n    a(this.selector).parentsUntil(this.options.target, ".active").removeClass("active");\n  };var d = a.fn.scrollspy;a.fn.scrollspy = c, a.fn.scrollspy.Constructor = b, a.fn.scrollspy.noConflict = function () {\n    return a.fn.scrollspy = d, this;\n  }, a(window).on("load.bs.scrollspy.data-api", function () {\n    a(\'[data-spy="scroll"]\').each(function () {\n      var b = a(this);c.call(b, b.data());\n    });\n  });\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data("bs.tab");e || d.data("bs.tab", e = new c(this)), "string" == typeof b && e[b]();\n    });\n  }var c = function c(b) {\n    this.element = a(b);\n  };c.VERSION = "3.3.5", c.TRANSITION_DURATION = 150, c.prototype.show = function () {\n    var b = this.element,\n        c = b.closest("ul:not(.dropdown-menu)"),\n        d = b.data("target");if (d || (d = b.attr("href"), d = d && d.replace(/.*(?=#[^\\s]*$)/, "")), !b.parent("li").hasClass("active")) {\n      var e = c.find(".active:last a"),\n          f = a.Event("hide.bs.tab", { relatedTarget: b[0] }),\n          g = a.Event("show.bs.tab", { relatedTarget: e[0] });if (e.trigger(f), b.trigger(g), !g.isDefaultPrevented() && !f.isDefaultPrevented()) {\n        var h = a(d);this.activate(b.closest("li"), c), this.activate(h, h.parent(), function () {\n          e.trigger({ type: "hidden.bs.tab", relatedTarget: b[0] }), b.trigger({ type: "shown.bs.tab", relatedTarget: e[0] });\n        });\n      }\n    }\n  }, c.prototype.activate = function (b, d, e) {\n    function f() {\n      g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find(\'[data-toggle="tab"]\').attr("aria-expanded", !1), b.addClass("active").find(\'[data-toggle="tab"]\').attr("aria-expanded", !0), h ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"), b.parent(".dropdown-menu").length && b.closest("li.dropdown").addClass("active").end().find(\'[data-toggle="tab"]\').attr("aria-expanded", !0), e && e();\n    }var g = d.find("> .active"),\n        h = e && a.support.transition && (g.length && g.hasClass("fade") || !!d.find("> .fade").length);g.length && h ? g.one("bsTransitionEnd", f).emulateTransitionEnd(c.TRANSITION_DURATION) : f(), g.removeClass("in");\n  };var d = a.fn.tab;a.fn.tab = b, a.fn.tab.Constructor = c, a.fn.tab.noConflict = function () {\n    return a.fn.tab = d, this;\n  };var e = function e(c) {\n    c.preventDefault(), b.call(a(this), "show");\n  };a(document).on("click.bs.tab.data-api", \'[data-toggle="tab"]\', e).on("click.bs.tab.data-api", \'[data-toggle="pill"]\', e);\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data("bs.affix"),\n          f = "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b;e || d.data("bs.affix", e = new c(this, f)), "string" == typeof b && e[b]();\n    });\n  }var c = function c(b, d) {\n    this.options = a.extend({}, c.DEFAULTS, d), this.$target = a(this.options.target).on("scroll.bs.affix.data-api", a.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", a.proxy(this.checkPositionWithEventLoop, this)), this.$element = a(b), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this.checkPosition();\n  };c.VERSION = "3.3.5", c.RESET = "affix affix-top affix-bottom", c.DEFAULTS = { offset: 0, target: window }, c.prototype.getState = function (a, b, c, d) {\n    var e = this.$target.scrollTop(),\n        f = this.$element.offset(),\n        g = this.$target.height();if (null != c && "top" == this.affixed) return c > e ? "top" : !1;if ("bottom" == this.affixed) return null != c ? e + this.unpin <= f.top ? !1 : "bottom" : a - d >= e + g ? !1 : "bottom";var h = null == this.affixed,\n        i = h ? e : f.top,\n        j = h ? g : b;return null != c && c >= e ? "top" : null != d && i + j >= a - d ? "bottom" : !1;\n  }, c.prototype.getPinnedOffset = function () {\n    if (this.pinnedOffset) return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a = this.$target.scrollTop(),\n        b = this.$element.offset();return this.pinnedOffset = b.top - a;\n  }, c.prototype.checkPositionWithEventLoop = function () {\n    setTimeout(a.proxy(this.checkPosition, this), 1);\n  }, c.prototype.checkPosition = function () {\n    if (this.$element.is(":visible")) {\n      var b = this.$element.height(),\n          d = this.options.offset,\n          e = d.top,\n          f = d.bottom,\n          g = Math.max(a(document).height(), a(document.body).height());"object" != (typeof d === "undefined" ? "undefined" : _typeof(d)) && (f = e = d), "function" == typeof e && (e = d.top(this.$element)), "function" == typeof f && (f = d.bottom(this.$element));var h = this.getState(g, b, e, f);if (this.affixed != h) {\n        null != this.unpin && this.$element.css("top", "");var i = "affix" + (h ? "-" + h : ""),\n            j = a.Event(i + ".bs.affix");if (this.$element.trigger(j), j.isDefaultPrevented()) return;this.affixed = h, this.unpin = "bottom" == h ? this.getPinnedOffset() : null, this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix", "affixed") + ".bs.affix");\n      }"bottom" == h && this.$element.offset({ top: g - b - f });\n    }\n  };var d = a.fn.affix;a.fn.affix = b, a.fn.affix.Constructor = c, a.fn.affix.noConflict = function () {\n    return a.fn.affix = d, this;\n  }, a(window).on("load", function () {\n    a(\'[data-spy="affix"]\').each(function () {\n      var c = a(this),\n          d = c.data();d.offset = d.offset || {}, null != d.offsetBottom && (d.offset.bottom = d.offsetBottom), null != d.offsetTop && (d.offset.top = d.offsetTop), b.call(c, d);\n    });\n  });\n}(jQuery);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvanMvYm9vdHN0cmFwLm1pbi5qcz9iYzA2Il0sIm5hbWVzIjpbIndpbmRvdyIsIiQiLCJqUXVlcnkiLCJyZXF1aXJlIiwiRXJyb3IiLCJhIiwiYiIsImZuIiwianF1ZXJ5Iiwic3BsaXQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJXZWJraXRUcmFuc2l0aW9uIiwiTW96VHJhbnNpdGlvbiIsIk9UcmFuc2l0aW9uIiwidHJhbnNpdGlvbiIsImMiLCJzdHlsZSIsImVuZCIsImVtdWxhdGVUcmFuc2l0aW9uRW5kIiwiZCIsIm9uZSIsImUiLCJ0cmlnZ2VyIiwic3VwcG9ydCIsInNldFRpbWVvdXQiLCJldmVudCIsInNwZWNpYWwiLCJic1RyYW5zaXRpb25FbmQiLCJiaW5kVHlwZSIsImRlbGVnYXRlVHlwZSIsImhhbmRsZSIsInRhcmdldCIsImlzIiwiaGFuZGxlT2JqIiwiaGFuZGxlciIsImFwcGx5IiwiYXJndW1lbnRzIiwiZWFjaCIsImRhdGEiLCJjYWxsIiwib24iLCJjbG9zZSIsIlZFUlNJT04iLCJUUkFOU0lUSU9OX0RVUkFUSU9OIiwicHJvdG90eXBlIiwiZyIsImRldGFjaCIsInJlbW92ZSIsImYiLCJhdHRyIiwicmVwbGFjZSIsInByZXZlbnREZWZhdWx0IiwibGVuZ3RoIiwiY2xvc2VzdCIsIkV2ZW50IiwiaXNEZWZhdWx0UHJldmVudGVkIiwicmVtb3ZlQ2xhc3MiLCJoYXNDbGFzcyIsImFsZXJ0IiwiQ29uc3RydWN0b3IiLCJub0NvbmZsaWN0IiwidG9nZ2xlIiwic2V0U3RhdGUiLCIkZWxlbWVudCIsIm9wdGlvbnMiLCJleHRlbmQiLCJERUZBVUxUUyIsImlzTG9hZGluZyIsImxvYWRpbmdUZXh0IiwicmVzZXRUZXh0IiwicHJveHkiLCJhZGRDbGFzcyIsInJlbW92ZUF0dHIiLCJmaW5kIiwicHJvcCIsInRvZ2dsZUNsYXNzIiwiYnV0dG9uIiwidGVzdCIsInR5cGUiLCJzbGlkZSIsInRvIiwiaW50ZXJ2YWwiLCJwYXVzZSIsImN5Y2xlIiwiJGluZGljYXRvcnMiLCJwYXVzZWQiLCJzbGlkaW5nIiwiJGFjdGl2ZSIsIiRpdGVtcyIsImtleWJvYXJkIiwia2V5ZG93biIsImRvY3VtZW50RWxlbWVudCIsIndyYXAiLCJ0YWdOYW1lIiwid2hpY2giLCJwcmV2IiwibmV4dCIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImdldEl0ZW1JbmRleCIsInBhcmVudCIsImNoaWxkcmVuIiwiaW5kZXgiLCJnZXRJdGVtRm9yRGlyZWN0aW9uIiwiZXEiLCJoIiwiaSIsImoiLCJrIiwicmVsYXRlZFRhcmdldCIsImRpcmVjdGlvbiIsImwiLCJtIiwib2Zmc2V0V2lkdGgiLCJqb2luIiwiY2Fyb3VzZWwiLCIkdHJpZ2dlciIsImlkIiwidHJhbnNpdGlvbmluZyIsIiRwYXJlbnQiLCJnZXRQYXJlbnQiLCJhZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MiLCJkaW1lbnNpb24iLCJzaG93IiwiY2FtZWxDYXNlIiwiaGlkZSIsIm9mZnNldEhlaWdodCIsImNvbGxhcHNlIiwiY29udGFpbnMiLCJpbnNlcnRBZnRlciIsInN0b3BQcm9wYWdhdGlvbiIsImRyb3Bkb3duIiwiJGJvZHkiLCJib2R5IiwiJGRpYWxvZyIsIiRiYWNrZHJvcCIsImlzU2hvd24iLCJvcmlnaW5hbEJvZHlQYWQiLCJzY3JvbGxiYXJXaWR0aCIsImlnbm9yZUJhY2tkcm9wQ2xpY2siLCJyZW1vdGUiLCJsb2FkIiwiQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiIsImJhY2tkcm9wIiwiY2hlY2tTY3JvbGxiYXIiLCJzZXRTY3JvbGxiYXIiLCJlc2NhcGUiLCJyZXNpemUiLCJhcHBlbmRUbyIsInNjcm9sbFRvcCIsImFkanVzdERpYWxvZyIsImVuZm9yY2VGb2N1cyIsIm9mZiIsImhpZGVNb2RhbCIsImhhcyIsImhhbmRsZVVwZGF0ZSIsInJlc2V0QWRqdXN0bWVudHMiLCJyZXNldFNjcm9sbGJhciIsInJlbW92ZUJhY2tkcm9wIiwiY3VycmVudFRhcmdldCIsImZvY3VzIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiY3NzIiwicGFkZGluZ0xlZnQiLCJib2R5SXNPdmVyZmxvd2luZyIsInBhZGRpbmdSaWdodCIsImlubmVyV2lkdGgiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyaWdodCIsIk1hdGgiLCJhYnMiLCJsZWZ0IiwiY2xpZW50V2lkdGgiLCJtZWFzdXJlU2Nyb2xsYmFyIiwicGFyc2VJbnQiLCJjbGFzc05hbWUiLCJhcHBlbmQiLCJyZW1vdmVDaGlsZCIsIm1vZGFsIiwiZW5hYmxlZCIsInRpbWVvdXQiLCJob3ZlclN0YXRlIiwiaW5TdGF0ZSIsImluaXQiLCJhbmltYXRpb24iLCJwbGFjZW1lbnQiLCJzZWxlY3RvciIsInRlbXBsYXRlIiwidGl0bGUiLCJkZWxheSIsImh0bWwiLCJjb250YWluZXIiLCJ2aWV3cG9ydCIsInBhZGRpbmciLCJnZXRPcHRpb25zIiwiJHZpZXdwb3J0IiwiaXNGdW5jdGlvbiIsImNsaWNrIiwiaG92ZXIiLCJjb25zdHJ1Y3RvciIsImVudGVyIiwibGVhdmUiLCJfb3B0aW9ucyIsImZpeFRpdGxlIiwiZ2V0RGVmYXVsdHMiLCJnZXREZWxlZ2F0ZU9wdGlvbnMiLCJ0aXAiLCJjbGVhclRpbWVvdXQiLCJpc0luU3RhdGVUcnVlIiwiaGFzQ29udGVudCIsIm93bmVyRG9jdW1lbnQiLCJnZXRVSUQiLCJzZXRDb250ZW50IiwidG9wIiwiZGlzcGxheSIsImdldFBvc2l0aW9uIiwibiIsIm8iLCJib3R0b20iLCJ3aWR0aCIsInAiLCJnZXRDYWxjdWxhdGVkT2Zmc2V0IiwiYXBwbHlQbGFjZW1lbnQiLCJxIiwiJHRpcCIsImlzTmFOIiwib2Zmc2V0Iiwic2V0T2Zmc2V0IiwidXNpbmciLCJyb3VuZCIsImdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YSIsInJlcGxhY2VBcnJvdyIsImFycm93IiwiZ2V0VGl0bGUiLCJoZWlnaHQiLCJzY3JvbGwiLCJyYW5kb20iLCJnZXRFbGVtZW50QnlJZCIsIiRhcnJvdyIsImVuYWJsZSIsImRpc2FibGUiLCJ0b2dnbGVFbmFibGVkIiwiZGVzdHJveSIsInJlbW92ZURhdGEiLCJ0b29sdGlwIiwiY29udGVudCIsImdldENvbnRlbnQiLCJwb3BvdmVyIiwiJHNjcm9sbEVsZW1lbnQiLCJvZmZzZXRzIiwidGFyZ2V0cyIsImFjdGl2ZVRhcmdldCIsInByb2Nlc3MiLCJyZWZyZXNoIiwiZ2V0U2Nyb2xsSGVpZ2h0IiwibWF4IiwiaXNXaW5kb3ciLCJtYXAiLCJzb3J0IiwicHVzaCIsImFjdGl2YXRlIiwiY2xlYXIiLCJwYXJlbnRzIiwicGFyZW50c1VudGlsIiwic2Nyb2xsc3B5IiwiZWxlbWVudCIsInRhYiIsIiR0YXJnZXQiLCJjaGVja1Bvc2l0aW9uIiwiY2hlY2tQb3NpdGlvbldpdGhFdmVudExvb3AiLCJhZmZpeGVkIiwidW5waW4iLCJwaW5uZWRPZmZzZXQiLCJSRVNFVCIsImdldFN0YXRlIiwiZ2V0UGlubmVkT2Zmc2V0IiwiYWZmaXgiLCJvZmZzZXRCb3R0b20iLCJvZmZzZXRUb3AiXSwibWFwcGluZ3MiOiI7O0FBQUFBLE9BQU9DLENBQVAsR0FBV0QsT0FBT0UsTUFBUCxHQUFnQixtQkFBQUMsQ0FBUSxDQUFSLENBQTNCO0FBQ0E7Ozs7O0FBS0EsSUFBRyxlQUFhLE9BQU9ELE1BQXZCLEVBQThCLE1BQU0sSUFBSUUsS0FBSixDQUFVLHdDQUFWLENBQU4sQ0FBMEQsQ0FBQyxVQUFTQyxDQUFULEVBQVc7QUFBQztBQUFhLE1BQUlDLElBQUVELEVBQUVFLEVBQUYsQ0FBS0MsTUFBTCxDQUFZQyxLQUFaLENBQWtCLEdBQWxCLEVBQXVCLENBQXZCLEVBQTBCQSxLQUExQixDQUFnQyxHQUFoQyxDQUFOLENBQTJDLElBQUdILEVBQUUsQ0FBRixJQUFLLENBQUwsSUFBUUEsRUFBRSxDQUFGLElBQUssQ0FBYixJQUFnQixLQUFHQSxFQUFFLENBQUYsQ0FBSCxJQUFTLEtBQUdBLEVBQUUsQ0FBRixDQUFaLElBQWtCQSxFQUFFLENBQUYsSUFBSyxDQUExQyxFQUE0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QUsrUSxLQUFMLEdBQVdoUixDQUFYLEVBQWFELEVBQUVFLEVBQUYsQ0FBSytRLEtBQUwsQ0FBVzFOLFdBQVgsR0FBdUI1QyxDQUFwQyxFQUFzQ1gsRUFBRUUsRUFBRixDQUFLK1EsS0FBTCxDQUFXek4sVUFBWCxHQUFzQixZQUFVO0FBQUMsV0FBT3hELEVBQUVFLEVBQUYsQ0FBSytRLEtBQUwsR0FBV2xRLENBQVgsRUFBYSxJQUFwQjtBQUF5QixHQUFoRyxFQUFpR2YsRUFBRUwsTUFBRixFQUFVeUMsRUFBVixDQUFhLE1BQWIsRUFBb0IsWUFBVTtBQUFDcEMsTUFBRSxvQkFBRixFQUF3QmlDLElBQXhCLENBQTZCLFlBQVU7QUFBQyxVQUFJdEIsSUFBRVgsRUFBRSxJQUFGLENBQU47QUFBQSxVQUFjZSxJQUFFSixFQUFFdUIsSUFBRixFQUFoQixDQUF5Qm5CLEVBQUVnTixNQUFGLEdBQVNoTixFQUFFZ04sTUFBRixJQUFVLEVBQW5CLEVBQXNCLFFBQU1oTixFQUFFbVEsWUFBUixLQUF1Qm5RLEVBQUVnTixNQUFGLENBQVNSLE1BQVQsR0FBZ0J4TSxFQUFFbVEsWUFBekMsQ0FBdEIsRUFBNkUsUUFBTW5RLEVBQUVvUSxTQUFSLEtBQW9CcFEsRUFBRWdOLE1BQUYsQ0FBU2IsR0FBVCxHQUFhbk0sRUFBRW9RLFNBQW5DLENBQTdFLEVBQTJIbFIsRUFBRWtDLElBQUYsQ0FBT3hCLENBQVAsRUFBU0ksQ0FBVCxDQUEzSDtBQUF1SSxLQUF4TTtBQUEwTSxHQUF6TyxDQUFqRztBQUE0VSxDQUFuMkUsQ0FBbzJFbEIsTUFBcDJFLENBRGhuRSIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsid2luZG93LiQgPSB3aW5kb3cualF1ZXJ5ID0gcmVxdWlyZSgnLi9qcXVlcnkuanMnKVxuLyohXG4gKiBCb290c3RyYXAgdjMuMy41IChodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbSlcbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmlmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBqUXVlcnkpdGhyb3cgbmV3IEVycm9yKFwiQm9vdHN0cmFwJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBqUXVlcnlcIik7K2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO3ZhciBiPWEuZm4uanF1ZXJ5LnNwbGl0KFwiIFwiKVswXS5zcGxpdChcIi5cIik7aWYoYlswXTwyJiZiWzFdPDl8fDE9PWJbMF0mJjk9PWJbMV0mJmJbMl08MSl0aHJvdyBuZXcgRXJyb3IoXCJCb290c3RyYXAncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeSB2ZXJzaW9uIDEuOS4xIG9yIGhpZ2hlclwiKX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJib290c3RyYXBcIiksYj17V2Via2l0VHJhbnNpdGlvbjpcIndlYmtpdFRyYW5zaXRpb25FbmRcIixNb3pUcmFuc2l0aW9uOlwidHJhbnNpdGlvbmVuZFwiLE9UcmFuc2l0aW9uOlwib1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmRcIix0cmFuc2l0aW9uOlwidHJhbnNpdGlvbmVuZFwifTtmb3IodmFyIGMgaW4gYilpZih2b2lkIDAhPT1hLnN0eWxlW2NdKXJldHVybntlbmQ6YltjXX07cmV0dXJuITF9YS5mbi5lbXVsYXRlVHJhbnNpdGlvbkVuZD1mdW5jdGlvbihiKXt2YXIgYz0hMSxkPXRoaXM7YSh0aGlzKS5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixmdW5jdGlvbigpe2M9ITB9KTt2YXIgZT1mdW5jdGlvbigpe2N8fGEoZCkudHJpZ2dlcihhLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQpfTtyZXR1cm4gc2V0VGltZW91dChlLGIpLHRoaXN9LGEoZnVuY3Rpb24oKXthLnN1cHBvcnQudHJhbnNpdGlvbj1iKCksYS5zdXBwb3J0LnRyYW5zaXRpb24mJihhLmV2ZW50LnNwZWNpYWwuYnNUcmFuc2l0aW9uRW5kPXtiaW5kVHlwZTphLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsZGVsZWdhdGVUeXBlOmEuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxoYW5kbGU6ZnVuY3Rpb24oYil7cmV0dXJuIGEoYi50YXJnZXQpLmlzKHRoaXMpP2IuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOnZvaWQgMH19KX0pfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1hKHRoaXMpLGU9Yy5kYXRhKFwiYnMuYWxlcnRcIik7ZXx8Yy5kYXRhKFwiYnMuYWxlcnRcIixlPW5ldyBkKHRoaXMpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZVtiXS5jYWxsKGMpfSl9dmFyIGM9J1tkYXRhLWRpc21pc3M9XCJhbGVydFwiXScsZD1mdW5jdGlvbihiKXthKGIpLm9uKFwiY2xpY2tcIixjLHRoaXMuY2xvc2UpfTtkLlZFUlNJT049XCIzLjMuNVwiLGQuVFJBTlNJVElPTl9EVVJBVElPTj0xNTAsZC5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe2cuZGV0YWNoKCkudHJpZ2dlcihcImNsb3NlZC5icy5hbGVydFwiKS5yZW1vdmUoKX12YXIgZT1hKHRoaXMpLGY9ZS5hdHRyKFwiZGF0YS10YXJnZXRcIik7Znx8KGY9ZS5hdHRyKFwiaHJlZlwiKSxmPWYmJmYucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLyxcIlwiKSk7dmFyIGc9YShmKTtiJiZiLnByZXZlbnREZWZhdWx0KCksZy5sZW5ndGh8fChnPWUuY2xvc2VzdChcIi5hbGVydFwiKSksZy50cmlnZ2VyKGI9YS5FdmVudChcImNsb3NlLmJzLmFsZXJ0XCIpKSxiLmlzRGVmYXVsdFByZXZlbnRlZCgpfHwoZy5yZW1vdmVDbGFzcyhcImluXCIpLGEuc3VwcG9ydC50cmFuc2l0aW9uJiZnLmhhc0NsYXNzKFwiZmFkZVwiKT9nLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGMpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGQuVFJBTlNJVElPTl9EVVJBVElPTik6YygpKX07dmFyIGU9YS5mbi5hbGVydDthLmZuLmFsZXJ0PWIsYS5mbi5hbGVydC5Db25zdHJ1Y3Rvcj1kLGEuZm4uYWxlcnQubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLmFsZXJ0PWUsdGhpc30sYShkb2N1bWVudCkub24oXCJjbGljay5icy5hbGVydC5kYXRhLWFwaVwiLGMsZC5wcm90b3R5cGUuY2xvc2UpfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZD1hKHRoaXMpLGU9ZC5kYXRhKFwiYnMuYnV0dG9uXCIpLGY9XCJvYmplY3RcIj09dHlwZW9mIGImJmI7ZXx8ZC5kYXRhKFwiYnMuYnV0dG9uXCIsZT1uZXcgYyh0aGlzLGYpKSxcInRvZ2dsZVwiPT1iP2UudG9nZ2xlKCk6YiYmZS5zZXRTdGF0ZShiKX0pfXZhciBjPWZ1bmN0aW9uKGIsZCl7dGhpcy4kZWxlbWVudD1hKGIpLHRoaXMub3B0aW9ucz1hLmV4dGVuZCh7fSxjLkRFRkFVTFRTLGQpLHRoaXMuaXNMb2FkaW5nPSExfTtjLlZFUlNJT049XCIzLjMuNVwiLGMuREVGQVVMVFM9e2xvYWRpbmdUZXh0OlwibG9hZGluZy4uLlwifSxjLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihiKXt2YXIgYz1cImRpc2FibGVkXCIsZD10aGlzLiRlbGVtZW50LGU9ZC5pcyhcImlucHV0XCIpP1widmFsXCI6XCJodG1sXCIsZj1kLmRhdGEoKTtiKz1cIlRleHRcIixudWxsPT1mLnJlc2V0VGV4dCYmZC5kYXRhKFwicmVzZXRUZXh0XCIsZFtlXSgpKSxzZXRUaW1lb3V0KGEucHJveHkoZnVuY3Rpb24oKXtkW2VdKG51bGw9PWZbYl0/dGhpcy5vcHRpb25zW2JdOmZbYl0pLFwibG9hZGluZ1RleHRcIj09Yj8odGhpcy5pc0xvYWRpbmc9ITAsZC5hZGRDbGFzcyhjKS5hdHRyKGMsYykpOnRoaXMuaXNMb2FkaW5nJiYodGhpcy5pc0xvYWRpbmc9ITEsZC5yZW1vdmVDbGFzcyhjKS5yZW1vdmVBdHRyKGMpKX0sdGhpcyksMCl9LGMucHJvdG90eXBlLnRvZ2dsZT1mdW5jdGlvbigpe3ZhciBhPSEwLGI9dGhpcy4kZWxlbWVudC5jbG9zZXN0KCdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJyk7aWYoYi5sZW5ndGgpe3ZhciBjPXRoaXMuJGVsZW1lbnQuZmluZChcImlucHV0XCIpO1wicmFkaW9cIj09Yy5wcm9wKFwidHlwZVwiKT8oYy5wcm9wKFwiY2hlY2tlZFwiKSYmKGE9ITEpLGIuZmluZChcIi5hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIiksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcImFjdGl2ZVwiKSk6XCJjaGVja2JveFwiPT1jLnByb3AoXCJ0eXBlXCIpJiYoYy5wcm9wKFwiY2hlY2tlZFwiKSE9PXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJhY3RpdmVcIikmJihhPSExKSx0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKFwiYWN0aXZlXCIpKSxjLnByb3AoXCJjaGVja2VkXCIsdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImFjdGl2ZVwiKSksYSYmYy50cmlnZ2VyKFwiY2hhbmdlXCIpfWVsc2UgdGhpcy4kZWxlbWVudC5hdHRyKFwiYXJpYS1wcmVzc2VkXCIsIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJhY3RpdmVcIikpLHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoXCJhY3RpdmVcIil9O3ZhciBkPWEuZm4uYnV0dG9uO2EuZm4uYnV0dG9uPWIsYS5mbi5idXR0b24uQ29uc3RydWN0b3I9YyxhLmZuLmJ1dHRvbi5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4uYnV0dG9uPWQsdGhpc30sYShkb2N1bWVudCkub24oXCJjbGljay5icy5idXR0b24uZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlXj1cImJ1dHRvblwiXScsZnVuY3Rpb24oYyl7dmFyIGQ9YShjLnRhcmdldCk7ZC5oYXNDbGFzcyhcImJ0blwiKXx8KGQ9ZC5jbG9zZXN0KFwiLmJ0blwiKSksYi5jYWxsKGQsXCJ0b2dnbGVcIiksYShjLnRhcmdldCkuaXMoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXScpfHxhKGMudGFyZ2V0KS5pcygnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJyl8fGMucHJldmVudERlZmF1bHQoKX0pLm9uKFwiZm9jdXMuYnMuYnV0dG9uLmRhdGEtYXBpIGJsdXIuYnMuYnV0dG9uLmRhdGEtYXBpXCIsJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLGZ1bmN0aW9uKGIpe2EoYi50YXJnZXQpLmNsb3Nlc3QoXCIuYnRuXCIpLnRvZ2dsZUNsYXNzKFwiZm9jdXNcIiwvXmZvY3VzKGluKT8kLy50ZXN0KGIudHlwZSkpfSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy5jYXJvdXNlbFwiKSxmPWEuZXh0ZW5kKHt9LGMuREVGQVVMVFMsZC5kYXRhKCksXCJvYmplY3RcIj09dHlwZW9mIGImJmIpLGc9XCJzdHJpbmdcIj09dHlwZW9mIGI/YjpmLnNsaWRlO2V8fGQuZGF0YShcImJzLmNhcm91c2VsXCIsZT1uZXcgYyh0aGlzLGYpKSxcIm51bWJlclwiPT10eXBlb2YgYj9lLnRvKGIpOmc/ZVtnXSgpOmYuaW50ZXJ2YWwmJmUucGF1c2UoKS5jeWNsZSgpfSl9dmFyIGM9ZnVuY3Rpb24oYixjKXt0aGlzLiRlbGVtZW50PWEoYiksdGhpcy4kaW5kaWNhdG9ycz10aGlzLiRlbGVtZW50LmZpbmQoXCIuY2Fyb3VzZWwtaW5kaWNhdG9yc1wiKSx0aGlzLm9wdGlvbnM9Yyx0aGlzLnBhdXNlZD1udWxsLHRoaXMuc2xpZGluZz1udWxsLHRoaXMuaW50ZXJ2YWw9bnVsbCx0aGlzLiRhY3RpdmU9bnVsbCx0aGlzLiRpdGVtcz1udWxsLHRoaXMub3B0aW9ucy5rZXlib2FyZCYmdGhpcy4kZWxlbWVudC5vbihcImtleWRvd24uYnMuY2Fyb3VzZWxcIixhLnByb3h5KHRoaXMua2V5ZG93bix0aGlzKSksXCJob3ZlclwiPT10aGlzLm9wdGlvbnMucGF1c2UmJiEoXCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkmJnRoaXMuJGVsZW1lbnQub24oXCJtb3VzZWVudGVyLmJzLmNhcm91c2VsXCIsYS5wcm94eSh0aGlzLnBhdXNlLHRoaXMpKS5vbihcIm1vdXNlbGVhdmUuYnMuY2Fyb3VzZWxcIixhLnByb3h5KHRoaXMuY3ljbGUsdGhpcykpfTtjLlZFUlNJT049XCIzLjMuNVwiLGMuVFJBTlNJVElPTl9EVVJBVElPTj02MDAsYy5ERUZBVUxUUz17aW50ZXJ2YWw6NWUzLHBhdXNlOlwiaG92ZXJcIix3cmFwOiEwLGtleWJvYXJkOiEwfSxjLnByb3RvdHlwZS5rZXlkb3duPWZ1bmN0aW9uKGEpe2lmKCEvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGEudGFyZ2V0LnRhZ05hbWUpKXtzd2l0Y2goYS53aGljaCl7Y2FzZSAzNzp0aGlzLnByZXYoKTticmVhaztjYXNlIDM5OnRoaXMubmV4dCgpO2JyZWFrO2RlZmF1bHQ6cmV0dXJufWEucHJldmVudERlZmF1bHQoKX19LGMucHJvdG90eXBlLmN5Y2xlPWZ1bmN0aW9uKGIpe3JldHVybiBifHwodGhpcy5wYXVzZWQ9ITEpLHRoaXMuaW50ZXJ2YWwmJmNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCksdGhpcy5vcHRpb25zLmludGVydmFsJiYhdGhpcy5wYXVzZWQmJih0aGlzLmludGVydmFsPXNldEludGVydmFsKGEucHJveHkodGhpcy5uZXh0LHRoaXMpLHRoaXMub3B0aW9ucy5pbnRlcnZhbCkpLHRoaXN9LGMucHJvdG90eXBlLmdldEl0ZW1JbmRleD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy4kaXRlbXM9YS5wYXJlbnQoKS5jaGlsZHJlbihcIi5pdGVtXCIpLHRoaXMuJGl0ZW1zLmluZGV4KGF8fHRoaXMuJGFjdGl2ZSl9LGMucHJvdG90eXBlLmdldEl0ZW1Gb3JEaXJlY3Rpb249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldEl0ZW1JbmRleChiKSxkPVwicHJldlwiPT1hJiYwPT09Y3x8XCJuZXh0XCI9PWEmJmM9PXRoaXMuJGl0ZW1zLmxlbmd0aC0xO2lmKGQmJiF0aGlzLm9wdGlvbnMud3JhcClyZXR1cm4gYjt2YXIgZT1cInByZXZcIj09YT8tMToxLGY9KGMrZSkldGhpcy4kaXRlbXMubGVuZ3RoO3JldHVybiB0aGlzLiRpdGVtcy5lcShmKX0sYy5wcm90b3R5cGUudG89ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPXRoaXMuZ2V0SXRlbUluZGV4KHRoaXMuJGFjdGl2ZT10aGlzLiRlbGVtZW50LmZpbmQoXCIuaXRlbS5hY3RpdmVcIikpO3JldHVybiBhPnRoaXMuJGl0ZW1zLmxlbmd0aC0xfHwwPmE/dm9pZCAwOnRoaXMuc2xpZGluZz90aGlzLiRlbGVtZW50Lm9uZShcInNsaWQuYnMuY2Fyb3VzZWxcIixmdW5jdGlvbigpe2IudG8oYSl9KTpjPT1hP3RoaXMucGF1c2UoKS5jeWNsZSgpOnRoaXMuc2xpZGUoYT5jP1wibmV4dFwiOlwicHJldlwiLHRoaXMuJGl0ZW1zLmVxKGEpKX0sYy5wcm90b3R5cGUucGF1c2U9ZnVuY3Rpb24oYil7cmV0dXJuIGJ8fCh0aGlzLnBhdXNlZD0hMCksdGhpcy4kZWxlbWVudC5maW5kKFwiLm5leHQsIC5wcmV2XCIpLmxlbmd0aCYmYS5zdXBwb3J0LnRyYW5zaXRpb24mJih0aGlzLiRlbGVtZW50LnRyaWdnZXIoYS5zdXBwb3J0LnRyYW5zaXRpb24uZW5kKSx0aGlzLmN5Y2xlKCEwKSksdGhpcy5pbnRlcnZhbD1jbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpLHRoaXN9LGMucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zbGlkaW5nP3ZvaWQgMDp0aGlzLnNsaWRlKFwibmV4dFwiKX0sYy5wcm90b3R5cGUucHJldj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNsaWRpbmc/dm9pZCAwOnRoaXMuc2xpZGUoXCJwcmV2XCIpfSxjLnByb3RvdHlwZS5zbGlkZT1mdW5jdGlvbihiLGQpe3ZhciBlPXRoaXMuJGVsZW1lbnQuZmluZChcIi5pdGVtLmFjdGl2ZVwiKSxmPWR8fHRoaXMuZ2V0SXRlbUZvckRpcmVjdGlvbihiLGUpLGc9dGhpcy5pbnRlcnZhbCxoPVwibmV4dFwiPT1iP1wibGVmdFwiOlwicmlnaHRcIixpPXRoaXM7aWYoZi5oYXNDbGFzcyhcImFjdGl2ZVwiKSlyZXR1cm4gdGhpcy5zbGlkaW5nPSExO3ZhciBqPWZbMF0saz1hLkV2ZW50KFwic2xpZGUuYnMuY2Fyb3VzZWxcIix7cmVsYXRlZFRhcmdldDpqLGRpcmVjdGlvbjpofSk7aWYodGhpcy4kZWxlbWVudC50cmlnZ2VyKGspLCFrLmlzRGVmYXVsdFByZXZlbnRlZCgpKXtpZih0aGlzLnNsaWRpbmc9ITAsZyYmdGhpcy5wYXVzZSgpLHRoaXMuJGluZGljYXRvcnMubGVuZ3RoKXt0aGlzLiRpbmRpY2F0b3JzLmZpbmQoXCIuYWN0aXZlXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO3ZhciBsPWEodGhpcy4kaW5kaWNhdG9ycy5jaGlsZHJlbigpW3RoaXMuZ2V0SXRlbUluZGV4KGYpXSk7bCYmbC5hZGRDbGFzcyhcImFjdGl2ZVwiKX12YXIgbT1hLkV2ZW50KFwic2xpZC5icy5jYXJvdXNlbFwiLHtyZWxhdGVkVGFyZ2V0OmosZGlyZWN0aW9uOmh9KTtyZXR1cm4gYS5zdXBwb3J0LnRyYW5zaXRpb24mJnRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJzbGlkZVwiKT8oZi5hZGRDbGFzcyhiKSxmWzBdLm9mZnNldFdpZHRoLGUuYWRkQ2xhc3MoaCksZi5hZGRDbGFzcyhoKSxlLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGZ1bmN0aW9uKCl7Zi5yZW1vdmVDbGFzcyhbYixoXS5qb2luKFwiIFwiKSkuYWRkQ2xhc3MoXCJhY3RpdmVcIiksZS5yZW1vdmVDbGFzcyhbXCJhY3RpdmVcIixoXS5qb2luKFwiIFwiKSksaS5zbGlkaW5nPSExLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtpLiRlbGVtZW50LnRyaWdnZXIobSl9LDApfSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5UUkFOU0lUSU9OX0RVUkFUSU9OKSk6KGUucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIiksZi5hZGRDbGFzcyhcImFjdGl2ZVwiKSx0aGlzLnNsaWRpbmc9ITEsdGhpcy4kZWxlbWVudC50cmlnZ2VyKG0pKSxnJiZ0aGlzLmN5Y2xlKCksdGhpc319O3ZhciBkPWEuZm4uY2Fyb3VzZWw7YS5mbi5jYXJvdXNlbD1iLGEuZm4uY2Fyb3VzZWwuQ29uc3RydWN0b3I9YyxhLmZuLmNhcm91c2VsLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5jYXJvdXNlbD1kLHRoaXN9O3ZhciBlPWZ1bmN0aW9uKGMpe3ZhciBkLGU9YSh0aGlzKSxmPWEoZS5hdHRyKFwiZGF0YS10YXJnZXRcIil8fChkPWUuYXR0cihcImhyZWZcIikpJiZkLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sXCJcIikpO2lmKGYuaGFzQ2xhc3MoXCJjYXJvdXNlbFwiKSl7dmFyIGc9YS5leHRlbmQoe30sZi5kYXRhKCksZS5kYXRhKCkpLGg9ZS5hdHRyKFwiZGF0YS1zbGlkZS10b1wiKTtoJiYoZy5pbnRlcnZhbD0hMSksYi5jYWxsKGYsZyksaCYmZi5kYXRhKFwiYnMuY2Fyb3VzZWxcIikudG8oaCksYy5wcmV2ZW50RGVmYXVsdCgpfX07YShkb2N1bWVudCkub24oXCJjbGljay5icy5jYXJvdXNlbC5kYXRhLWFwaVwiLFwiW2RhdGEtc2xpZGVdXCIsZSkub24oXCJjbGljay5icy5jYXJvdXNlbC5kYXRhLWFwaVwiLFwiW2RhdGEtc2xpZGUtdG9dXCIsZSksYSh3aW5kb3cpLm9uKFwibG9hZFwiLGZ1bmN0aW9uKCl7YSgnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJykuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcyk7Yi5jYWxsKGMsYy5kYXRhKCkpfSl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXt2YXIgYyxkPWIuYXR0cihcImRhdGEtdGFyZ2V0XCIpfHwoYz1iLmF0dHIoXCJocmVmXCIpKSYmYy5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLFwiXCIpO3JldHVybiBhKGQpfWZ1bmN0aW9uIGMoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcyksZT1jLmRhdGEoXCJicy5jb2xsYXBzZVwiKSxmPWEuZXh0ZW5kKHt9LGQuREVGQVVMVFMsYy5kYXRhKCksXCJvYmplY3RcIj09dHlwZW9mIGImJmIpOyFlJiZmLnRvZ2dsZSYmL3Nob3d8aGlkZS8udGVzdChiKSYmKGYudG9nZ2xlPSExKSxlfHxjLmRhdGEoXCJicy5jb2xsYXBzZVwiLGU9bmV3IGQodGhpcyxmKSksXCJzdHJpbmdcIj09dHlwZW9mIGImJmVbYl0oKX0pfXZhciBkPWZ1bmN0aW9uKGIsYyl7dGhpcy4kZWxlbWVudD1hKGIpLHRoaXMub3B0aW9ucz1hLmV4dGVuZCh7fSxkLkRFRkFVTFRTLGMpLHRoaXMuJHRyaWdnZXI9YSgnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1baHJlZj1cIiMnK2IuaWQrJ1wiXSxbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXRhcmdldD1cIiMnK2IuaWQrJ1wiXScpLHRoaXMudHJhbnNpdGlvbmluZz1udWxsLHRoaXMub3B0aW9ucy5wYXJlbnQ/dGhpcy4kcGFyZW50PXRoaXMuZ2V0UGFyZW50KCk6dGhpcy5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy4kZWxlbWVudCx0aGlzLiR0cmlnZ2VyKSx0aGlzLm9wdGlvbnMudG9nZ2xlJiZ0aGlzLnRvZ2dsZSgpfTtkLlZFUlNJT049XCIzLjMuNVwiLGQuVFJBTlNJVElPTl9EVVJBVElPTj0zNTAsZC5ERUZBVUxUUz17dG9nZ2xlOiEwfSxkLnByb3RvdHlwZS5kaW1lbnNpb249ZnVuY3Rpb24oKXt2YXIgYT10aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwid2lkdGhcIik7cmV0dXJuIGE/XCJ3aWR0aFwiOlwiaGVpZ2h0XCJ9LGQucHJvdG90eXBlLnNob3c9ZnVuY3Rpb24oKXtpZighdGhpcy50cmFuc2l0aW9uaW5nJiYhdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImluXCIpKXt2YXIgYixlPXRoaXMuJHBhcmVudCYmdGhpcy4kcGFyZW50LmNoaWxkcmVuKFwiLnBhbmVsXCIpLmNoaWxkcmVuKFwiLmluLCAuY29sbGFwc2luZ1wiKTtpZighKGUmJmUubGVuZ3RoJiYoYj1lLmRhdGEoXCJicy5jb2xsYXBzZVwiKSxiJiZiLnRyYW5zaXRpb25pbmcpKSl7dmFyIGY9YS5FdmVudChcInNob3cuYnMuY29sbGFwc2VcIik7aWYodGhpcy4kZWxlbWVudC50cmlnZ2VyKGYpLCFmLmlzRGVmYXVsdFByZXZlbnRlZCgpKXtlJiZlLmxlbmd0aCYmKGMuY2FsbChlLFwiaGlkZVwiKSxifHxlLmRhdGEoXCJicy5jb2xsYXBzZVwiLG51bGwpKTt2YXIgZz10aGlzLmRpbWVuc2lvbigpO3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJjb2xsYXBzZVwiKS5hZGRDbGFzcyhcImNvbGxhcHNpbmdcIilbZ10oMCkuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMCksdGhpcy4kdHJpZ2dlci5yZW1vdmVDbGFzcyhcImNvbGxhcHNlZFwiKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCEwKSx0aGlzLnRyYW5zaXRpb25pbmc9MTt2YXIgaD1mdW5jdGlvbigpe3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJjb2xsYXBzaW5nXCIpLmFkZENsYXNzKFwiY29sbGFwc2UgaW5cIilbZ10oXCJcIiksdGhpcy50cmFuc2l0aW9uaW5nPTAsdGhpcy4kZWxlbWVudC50cmlnZ2VyKFwic2hvd24uYnMuY29sbGFwc2VcIil9O2lmKCFhLnN1cHBvcnQudHJhbnNpdGlvbilyZXR1cm4gaC5jYWxsKHRoaXMpO3ZhciBpPWEuY2FtZWxDYXNlKFtcInNjcm9sbFwiLGddLmpvaW4oXCItXCIpKTt0aGlzLiRlbGVtZW50Lm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGEucHJveHkoaCx0aGlzKSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoZC5UUkFOU0lUSU9OX0RVUkFUSU9OKVtnXSh0aGlzLiRlbGVtZW50WzBdW2ldKX19fX0sZC5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbigpe2lmKCF0aGlzLnRyYW5zaXRpb25pbmcmJnRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJpblwiKSl7dmFyIGI9YS5FdmVudChcImhpZGUuYnMuY29sbGFwc2VcIik7aWYodGhpcy4kZWxlbWVudC50cmlnZ2VyKGIpLCFiLmlzRGVmYXVsdFByZXZlbnRlZCgpKXt2YXIgYz10aGlzLmRpbWVuc2lvbigpO3RoaXMuJGVsZW1lbnRbY10odGhpcy4kZWxlbWVudFtjXSgpKVswXS5vZmZzZXRIZWlnaHQsdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcImNvbGxhcHNpbmdcIikucmVtb3ZlQ2xhc3MoXCJjb2xsYXBzZSBpblwiKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCExKSx0aGlzLiR0cmlnZ2VyLmFkZENsYXNzKFwiY29sbGFwc2VkXCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITEpLHRoaXMudHJhbnNpdGlvbmluZz0xO3ZhciBlPWZ1bmN0aW9uKCl7dGhpcy50cmFuc2l0aW9uaW5nPTAsdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcImNvbGxhcHNpbmdcIikuYWRkQ2xhc3MoXCJjb2xsYXBzZVwiKS50cmlnZ2VyKFwiaGlkZGVuLmJzLmNvbGxhcHNlXCIpfTtyZXR1cm4gYS5zdXBwb3J0LnRyYW5zaXRpb24/dm9pZCB0aGlzLiRlbGVtZW50W2NdKDApLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGEucHJveHkoZSx0aGlzKSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoZC5UUkFOU0lUSU9OX0RVUkFUSU9OKTplLmNhbGwodGhpcyl9fX0sZC5wcm90b3R5cGUudG9nZ2xlPWZ1bmN0aW9uKCl7dGhpc1t0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiaW5cIik/XCJoaWRlXCI6XCJzaG93XCJdKCl9LGQucHJvdG90eXBlLmdldFBhcmVudD1mdW5jdGlvbigpe3JldHVybiBhKHRoaXMub3B0aW9ucy5wYXJlbnQpLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2RhdGEtcGFyZW50PVwiJyt0aGlzLm9wdGlvbnMucGFyZW50KydcIl0nKS5lYWNoKGEucHJveHkoZnVuY3Rpb24oYyxkKXt2YXIgZT1hKGQpO3RoaXMuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKGIoZSksZSl9LHRoaXMpKS5lbmQoKX0sZC5wcm90b3R5cGUuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5oYXNDbGFzcyhcImluXCIpO2EuYXR0cihcImFyaWEtZXhwYW5kZWRcIixjKSxiLnRvZ2dsZUNsYXNzKFwiY29sbGFwc2VkXCIsIWMpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsYyl9O3ZhciBlPWEuZm4uY29sbGFwc2U7YS5mbi5jb2xsYXBzZT1jLGEuZm4uY29sbGFwc2UuQ29uc3RydWN0b3I9ZCxhLmZuLmNvbGxhcHNlLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5jb2xsYXBzZT1lLHRoaXN9LGEoZG9jdW1lbnQpLm9uKFwiY2xpY2suYnMuY29sbGFwc2UuZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nLGZ1bmN0aW9uKGQpe3ZhciBlPWEodGhpcyk7ZS5hdHRyKFwiZGF0YS10YXJnZXRcIil8fGQucHJldmVudERlZmF1bHQoKTt2YXIgZj1iKGUpLGc9Zi5kYXRhKFwiYnMuY29sbGFwc2VcIiksaD1nP1widG9nZ2xlXCI6ZS5kYXRhKCk7Yy5jYWxsKGYsaCl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXt2YXIgYz1iLmF0dHIoXCJkYXRhLXRhcmdldFwiKTtjfHwoYz1iLmF0dHIoXCJocmVmXCIpLGM9YyYmLyNbQS1aYS16XS8udGVzdChjKSYmYy5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLFwiXCIpKTt2YXIgZD1jJiZhKGMpO3JldHVybiBkJiZkLmxlbmd0aD9kOmIucGFyZW50KCl9ZnVuY3Rpb24gYyhjKXtjJiYzPT09Yy53aGljaHx8KGEoZSkucmVtb3ZlKCksYShmKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWIoZCksZj17cmVsYXRlZFRhcmdldDp0aGlzfTtlLmhhc0NsYXNzKFwib3BlblwiKSYmKGMmJlwiY2xpY2tcIj09Yy50eXBlJiYvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGMudGFyZ2V0LnRhZ05hbWUpJiZhLmNvbnRhaW5zKGVbMF0sYy50YXJnZXQpfHwoZS50cmlnZ2VyKGM9YS5FdmVudChcImhpZGUuYnMuZHJvcGRvd25cIixmKSksYy5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8KGQuYXR0cihcImFyaWEtZXhwYW5kZWRcIixcImZhbHNlXCIpLGUucmVtb3ZlQ2xhc3MoXCJvcGVuXCIpLnRyaWdnZXIoXCJoaWRkZW4uYnMuZHJvcGRvd25cIixmKSkpKX0pKX1mdW5jdGlvbiBkKGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1hKHRoaXMpLGQ9Yy5kYXRhKFwiYnMuZHJvcGRvd25cIik7ZHx8Yy5kYXRhKFwiYnMuZHJvcGRvd25cIixkPW5ldyBnKHRoaXMpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZFtiXS5jYWxsKGMpfSl9dmFyIGU9XCIuZHJvcGRvd24tYmFja2Ryb3BcIixmPSdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXScsZz1mdW5jdGlvbihiKXthKGIpLm9uKFwiY2xpY2suYnMuZHJvcGRvd25cIix0aGlzLnRvZ2dsZSl9O2cuVkVSU0lPTj1cIjMuMy41XCIsZy5wcm90b3R5cGUudG9nZ2xlPWZ1bmN0aW9uKGQpe3ZhciBlPWEodGhpcyk7aWYoIWUuaXMoXCIuZGlzYWJsZWQsIDpkaXNhYmxlZFwiKSl7dmFyIGY9YihlKSxnPWYuaGFzQ2xhc3MoXCJvcGVuXCIpO2lmKGMoKSwhZyl7XCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmIWYuY2xvc2VzdChcIi5uYXZiYXItbmF2XCIpLmxlbmd0aCYmYShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKS5hZGRDbGFzcyhcImRyb3Bkb3duLWJhY2tkcm9wXCIpLmluc2VydEFmdGVyKGEodGhpcykpLm9uKFwiY2xpY2tcIixjKTt2YXIgaD17cmVsYXRlZFRhcmdldDp0aGlzfTtpZihmLnRyaWdnZXIoZD1hLkV2ZW50KFwic2hvdy5icy5kcm9wZG93blwiLGgpKSxkLmlzRGVmYXVsdFByZXZlbnRlZCgpKXJldHVybjtlLnRyaWdnZXIoXCJmb2N1c1wiKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLFwidHJ1ZVwiKSxmLnRvZ2dsZUNsYXNzKFwib3BlblwiKS50cmlnZ2VyKFwic2hvd24uYnMuZHJvcGRvd25cIixoKX1yZXR1cm4hMX19LGcucHJvdG90eXBlLmtleWRvd249ZnVuY3Rpb24oYyl7aWYoLygzOHw0MHwyN3wzMikvLnRlc3QoYy53aGljaCkmJiEvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGMudGFyZ2V0LnRhZ05hbWUpKXt2YXIgZD1hKHRoaXMpO2lmKGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLCFkLmlzKFwiLmRpc2FibGVkLCA6ZGlzYWJsZWRcIikpe3ZhciBlPWIoZCksZz1lLmhhc0NsYXNzKFwib3BlblwiKTtpZighZyYmMjchPWMud2hpY2h8fGcmJjI3PT1jLndoaWNoKXJldHVybiAyNz09Yy53aGljaCYmZS5maW5kKGYpLnRyaWdnZXIoXCJmb2N1c1wiKSxkLnRyaWdnZXIoXCJjbGlja1wiKTt2YXIgaD1cIiBsaTpub3QoLmRpc2FibGVkKTp2aXNpYmxlIGFcIixpPWUuZmluZChcIi5kcm9wZG93bi1tZW51XCIraCk7aWYoaS5sZW5ndGgpe3ZhciBqPWkuaW5kZXgoYy50YXJnZXQpOzM4PT1jLndoaWNoJiZqPjAmJmotLSw0MD09Yy53aGljaCYmajxpLmxlbmd0aC0xJiZqKyssfmp8fChqPTApLGkuZXEoaikudHJpZ2dlcihcImZvY3VzXCIpfX19fTt2YXIgaD1hLmZuLmRyb3Bkb3duO2EuZm4uZHJvcGRvd249ZCxhLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yPWcsYS5mbi5kcm9wZG93bi5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4uZHJvcGRvd249aCx0aGlzfSxhKGRvY3VtZW50KS5vbihcImNsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpXCIsYykub24oXCJjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaVwiLFwiLmRyb3Bkb3duIGZvcm1cIixmdW5jdGlvbihhKXthLnN0b3BQcm9wYWdhdGlvbigpfSkub24oXCJjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaVwiLGYsZy5wcm90b3R5cGUudG9nZ2xlKS5vbihcImtleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGlcIixmLGcucHJvdG90eXBlLmtleWRvd24pLm9uKFwia2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaVwiLFwiLmRyb3Bkb3duLW1lbnVcIixnLnByb3RvdHlwZS5rZXlkb3duKX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiLGQpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZT1hKHRoaXMpLGY9ZS5kYXRhKFwiYnMubW9kYWxcIiksZz1hLmV4dGVuZCh7fSxjLkRFRkFVTFRTLGUuZGF0YSgpLFwib2JqZWN0XCI9PXR5cGVvZiBiJiZiKTtmfHxlLmRhdGEoXCJicy5tb2RhbFwiLGY9bmV3IGModGhpcyxnKSksXCJzdHJpbmdcIj09dHlwZW9mIGI/ZltiXShkKTpnLnNob3cmJmYuc2hvdyhkKX0pfXZhciBjPWZ1bmN0aW9uKGIsYyl7dGhpcy5vcHRpb25zPWMsdGhpcy4kYm9keT1hKGRvY3VtZW50LmJvZHkpLHRoaXMuJGVsZW1lbnQ9YShiKSx0aGlzLiRkaWFsb2c9dGhpcy4kZWxlbWVudC5maW5kKFwiLm1vZGFsLWRpYWxvZ1wiKSx0aGlzLiRiYWNrZHJvcD1udWxsLHRoaXMuaXNTaG93bj1udWxsLHRoaXMub3JpZ2luYWxCb2R5UGFkPW51bGwsdGhpcy5zY3JvbGxiYXJXaWR0aD0wLHRoaXMuaWdub3JlQmFja2Ryb3BDbGljaz0hMSx0aGlzLm9wdGlvbnMucmVtb3RlJiZ0aGlzLiRlbGVtZW50LmZpbmQoXCIubW9kYWwtY29udGVudFwiKS5sb2FkKHRoaXMub3B0aW9ucy5yZW1vdGUsYS5wcm94eShmdW5jdGlvbigpe3RoaXMuJGVsZW1lbnQudHJpZ2dlcihcImxvYWRlZC5icy5tb2RhbFwiKX0sdGhpcykpfTtjLlZFUlNJT049XCIzLjMuNVwiLGMuVFJBTlNJVElPTl9EVVJBVElPTj0zMDAsYy5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OPTE1MCxjLkRFRkFVTFRTPXtiYWNrZHJvcDohMCxrZXlib2FyZDohMCxzaG93OiEwfSxjLnByb3RvdHlwZS50b2dnbGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaXNTaG93bj90aGlzLmhpZGUoKTp0aGlzLnNob3coYSl9LGMucHJvdG90eXBlLnNob3c9ZnVuY3Rpb24oYil7dmFyIGQ9dGhpcyxlPWEuRXZlbnQoXCJzaG93LmJzLm1vZGFsXCIse3JlbGF0ZWRUYXJnZXQ6Yn0pO3RoaXMuJGVsZW1lbnQudHJpZ2dlcihlKSx0aGlzLmlzU2hvd258fGUuaXNEZWZhdWx0UHJldmVudGVkKCl8fCh0aGlzLmlzU2hvd249ITAsdGhpcy5jaGVja1Njcm9sbGJhcigpLHRoaXMuc2V0U2Nyb2xsYmFyKCksdGhpcy4kYm9keS5hZGRDbGFzcyhcIm1vZGFsLW9wZW5cIiksdGhpcy5lc2NhcGUoKSx0aGlzLnJlc2l6ZSgpLHRoaXMuJGVsZW1lbnQub24oXCJjbGljay5kaXNtaXNzLmJzLm1vZGFsXCIsJ1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScsYS5wcm94eSh0aGlzLmhpZGUsdGhpcykpLHRoaXMuJGRpYWxvZy5vbihcIm1vdXNlZG93bi5kaXNtaXNzLmJzLm1vZGFsXCIsZnVuY3Rpb24oKXtkLiRlbGVtZW50Lm9uZShcIm1vdXNldXAuZGlzbWlzcy5icy5tb2RhbFwiLGZ1bmN0aW9uKGIpe2EoYi50YXJnZXQpLmlzKGQuJGVsZW1lbnQpJiYoZC5pZ25vcmVCYWNrZHJvcENsaWNrPSEwKX0pfSksdGhpcy5iYWNrZHJvcChmdW5jdGlvbigpe3ZhciBlPWEuc3VwcG9ydC50cmFuc2l0aW9uJiZkLiRlbGVtZW50Lmhhc0NsYXNzKFwiZmFkZVwiKTtkLiRlbGVtZW50LnBhcmVudCgpLmxlbmd0aHx8ZC4kZWxlbWVudC5hcHBlbmRUbyhkLiRib2R5KSxkLiRlbGVtZW50LnNob3coKS5zY3JvbGxUb3AoMCksZC5hZGp1c3REaWFsb2coKSxlJiZkLiRlbGVtZW50WzBdLm9mZnNldFdpZHRoLGQuJGVsZW1lbnQuYWRkQ2xhc3MoXCJpblwiKSxkLmVuZm9yY2VGb2N1cygpO3ZhciBmPWEuRXZlbnQoXCJzaG93bi5icy5tb2RhbFwiLHtyZWxhdGVkVGFyZ2V0OmJ9KTtlP2QuJGRpYWxvZy5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixmdW5jdGlvbigpe2QuJGVsZW1lbnQudHJpZ2dlcihcImZvY3VzXCIpLnRyaWdnZXIoZil9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLlRSQU5TSVRJT05fRFVSQVRJT04pOmQuJGVsZW1lbnQudHJpZ2dlcihcImZvY3VzXCIpLnRyaWdnZXIoZil9KSl9LGMucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oYil7YiYmYi5wcmV2ZW50RGVmYXVsdCgpLGI9YS5FdmVudChcImhpZGUuYnMubW9kYWxcIiksdGhpcy4kZWxlbWVudC50cmlnZ2VyKGIpLHRoaXMuaXNTaG93biYmIWIuaXNEZWZhdWx0UHJldmVudGVkKCkmJih0aGlzLmlzU2hvd249ITEsdGhpcy5lc2NhcGUoKSx0aGlzLnJlc2l6ZSgpLGEoZG9jdW1lbnQpLm9mZihcImZvY3VzaW4uYnMubW9kYWxcIiksdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcImluXCIpLm9mZihcImNsaWNrLmRpc21pc3MuYnMubW9kYWxcIikub2ZmKFwibW91c2V1cC5kaXNtaXNzLmJzLm1vZGFsXCIpLHRoaXMuJGRpYWxvZy5vZmYoXCJtb3VzZWRvd24uZGlzbWlzcy5icy5tb2RhbFwiKSxhLnN1cHBvcnQudHJhbnNpdGlvbiYmdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImZhZGVcIik/dGhpcy4kZWxlbWVudC5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixhLnByb3h5KHRoaXMuaGlkZU1vZGFsLHRoaXMpKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLlRSQU5TSVRJT05fRFVSQVRJT04pOnRoaXMuaGlkZU1vZGFsKCkpfSxjLnByb3RvdHlwZS5lbmZvcmNlRm9jdXM9ZnVuY3Rpb24oKXthKGRvY3VtZW50KS5vZmYoXCJmb2N1c2luLmJzLm1vZGFsXCIpLm9uKFwiZm9jdXNpbi5icy5tb2RhbFwiLGEucHJveHkoZnVuY3Rpb24oYSl7dGhpcy4kZWxlbWVudFswXT09PWEudGFyZ2V0fHx0aGlzLiRlbGVtZW50LmhhcyhhLnRhcmdldCkubGVuZ3RofHx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJmb2N1c1wiKX0sdGhpcykpfSxjLnByb3RvdHlwZS5lc2NhcGU9ZnVuY3Rpb24oKXt0aGlzLmlzU2hvd24mJnRoaXMub3B0aW9ucy5rZXlib2FyZD90aGlzLiRlbGVtZW50Lm9uKFwia2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsXCIsYS5wcm94eShmdW5jdGlvbihhKXsyNz09YS53aGljaCYmdGhpcy5oaWRlKCl9LHRoaXMpKTp0aGlzLmlzU2hvd258fHRoaXMuJGVsZW1lbnQub2ZmKFwia2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsXCIpfSxjLnByb3RvdHlwZS5yZXNpemU9ZnVuY3Rpb24oKXt0aGlzLmlzU2hvd24/YSh3aW5kb3cpLm9uKFwicmVzaXplLmJzLm1vZGFsXCIsYS5wcm94eSh0aGlzLmhhbmRsZVVwZGF0ZSx0aGlzKSk6YSh3aW5kb3cpLm9mZihcInJlc2l6ZS5icy5tb2RhbFwiKX0sYy5wcm90b3R5cGUuaGlkZU1vZGFsPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczt0aGlzLiRlbGVtZW50LmhpZGUoKSx0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uKCl7YS4kYm9keS5yZW1vdmVDbGFzcyhcIm1vZGFsLW9wZW5cIiksYS5yZXNldEFkanVzdG1lbnRzKCksYS5yZXNldFNjcm9sbGJhcigpLGEuJGVsZW1lbnQudHJpZ2dlcihcImhpZGRlbi5icy5tb2RhbFwiKX0pfSxjLnByb3RvdHlwZS5yZW1vdmVCYWNrZHJvcD1mdW5jdGlvbigpe3RoaXMuJGJhY2tkcm9wJiZ0aGlzLiRiYWNrZHJvcC5yZW1vdmUoKSx0aGlzLiRiYWNrZHJvcD1udWxsfSxjLnByb3RvdHlwZS5iYWNrZHJvcD1mdW5jdGlvbihiKXt2YXIgZD10aGlzLGU9dGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImZhZGVcIik/XCJmYWRlXCI6XCJcIjtpZih0aGlzLmlzU2hvd24mJnRoaXMub3B0aW9ucy5iYWNrZHJvcCl7dmFyIGY9YS5zdXBwb3J0LnRyYW5zaXRpb24mJmU7aWYodGhpcy4kYmFja2Ryb3A9YShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKS5hZGRDbGFzcyhcIm1vZGFsLWJhY2tkcm9wIFwiK2UpLmFwcGVuZFRvKHRoaXMuJGJvZHkpLHRoaXMuJGVsZW1lbnQub24oXCJjbGljay5kaXNtaXNzLmJzLm1vZGFsXCIsYS5wcm94eShmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrP3ZvaWQodGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrPSExKTp2b2lkKGEudGFyZ2V0PT09YS5jdXJyZW50VGFyZ2V0JiYoXCJzdGF0aWNcIj09dGhpcy5vcHRpb25zLmJhY2tkcm9wP3RoaXMuJGVsZW1lbnRbMF0uZm9jdXMoKTp0aGlzLmhpZGUoKSkpfSx0aGlzKSksZiYmdGhpcy4kYmFja2Ryb3BbMF0ub2Zmc2V0V2lkdGgsdGhpcy4kYmFja2Ryb3AuYWRkQ2xhc3MoXCJpblwiKSwhYilyZXR1cm47Zj90aGlzLiRiYWNrZHJvcC5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixiKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pOmIoKX1lbHNlIGlmKCF0aGlzLmlzU2hvd24mJnRoaXMuJGJhY2tkcm9wKXt0aGlzLiRiYWNrZHJvcC5yZW1vdmVDbGFzcyhcImluXCIpO3ZhciBnPWZ1bmN0aW9uKCl7ZC5yZW1vdmVCYWNrZHJvcCgpLGImJmIoKX07YS5zdXBwb3J0LnRyYW5zaXRpb24mJnRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJmYWRlXCIpP3RoaXMuJGJhY2tkcm9wLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGcpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGMuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTik6ZygpfWVsc2UgYiYmYigpfSxjLnByb3RvdHlwZS5oYW5kbGVVcGRhdGU9ZnVuY3Rpb24oKXt0aGlzLmFkanVzdERpYWxvZygpfSxjLnByb3RvdHlwZS5hZGp1c3REaWFsb2c9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLiRlbGVtZW50WzBdLnNjcm9sbEhlaWdodD5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O3RoaXMuJGVsZW1lbnQuY3NzKHtwYWRkaW5nTGVmdDohdGhpcy5ib2R5SXNPdmVyZmxvd2luZyYmYT90aGlzLnNjcm9sbGJhcldpZHRoOlwiXCIscGFkZGluZ1JpZ2h0OnRoaXMuYm9keUlzT3ZlcmZsb3dpbmcmJiFhP3RoaXMuc2Nyb2xsYmFyV2lkdGg6XCJcIn0pfSxjLnByb3RvdHlwZS5yZXNldEFkanVzdG1lbnRzPWZ1bmN0aW9uKCl7dGhpcy4kZWxlbWVudC5jc3Moe3BhZGRpbmdMZWZ0OlwiXCIscGFkZGluZ1JpZ2h0OlwiXCJ9KX0sYy5wcm90b3R5cGUuY2hlY2tTY3JvbGxiYXI9ZnVuY3Rpb24oKXt2YXIgYT13aW5kb3cuaW5uZXJXaWR0aDtpZighYSl7dmFyIGI9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2E9Yi5yaWdodC1NYXRoLmFicyhiLmxlZnQpfXRoaXMuYm9keUlzT3ZlcmZsb3dpbmc9ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDxhLHRoaXMuc2Nyb2xsYmFyV2lkdGg9dGhpcy5tZWFzdXJlU2Nyb2xsYmFyKCl9LGMucHJvdG90eXBlLnNldFNjcm9sbGJhcj1mdW5jdGlvbigpe3ZhciBhPXBhcnNlSW50KHRoaXMuJGJvZHkuY3NzKFwicGFkZGluZy1yaWdodFwiKXx8MCwxMCk7dGhpcy5vcmlnaW5hbEJvZHlQYWQ9ZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHR8fFwiXCIsdGhpcy5ib2R5SXNPdmVyZmxvd2luZyYmdGhpcy4kYm9keS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIsYSt0aGlzLnNjcm9sbGJhcldpZHRoKX0sYy5wcm90b3R5cGUucmVzZXRTY3JvbGxiYXI9ZnVuY3Rpb24oKXt0aGlzLiRib2R5LmNzcyhcInBhZGRpbmctcmlnaHRcIix0aGlzLm9yaWdpbmFsQm9keVBhZCl9LGMucHJvdG90eXBlLm1lYXN1cmVTY3JvbGxiYXI9ZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2EuY2xhc3NOYW1lPVwibW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmVcIix0aGlzLiRib2R5LmFwcGVuZChhKTt2YXIgYj1hLm9mZnNldFdpZHRoLWEuY2xpZW50V2lkdGg7cmV0dXJuIHRoaXMuJGJvZHlbMF0ucmVtb3ZlQ2hpbGQoYSksYn07dmFyIGQ9YS5mbi5tb2RhbDthLmZuLm1vZGFsPWIsYS5mbi5tb2RhbC5Db25zdHJ1Y3Rvcj1jLGEuZm4ubW9kYWwubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLm1vZGFsPWQsdGhpc30sYShkb2N1bWVudCkub24oXCJjbGljay5icy5tb2RhbC5kYXRhLWFwaVwiLCdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXScsZnVuY3Rpb24oYyl7dmFyIGQ9YSh0aGlzKSxlPWQuYXR0cihcImhyZWZcIiksZj1hKGQuYXR0cihcImRhdGEtdGFyZ2V0XCIpfHxlJiZlLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sXCJcIikpLGc9Zi5kYXRhKFwiYnMubW9kYWxcIik/XCJ0b2dnbGVcIjphLmV4dGVuZCh7cmVtb3RlOiEvIy8udGVzdChlKSYmZX0sZi5kYXRhKCksZC5kYXRhKCkpO2QuaXMoXCJhXCIpJiZjLnByZXZlbnREZWZhdWx0KCksZi5vbmUoXCJzaG93LmJzLm1vZGFsXCIsZnVuY3Rpb24oYSl7YS5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8Zi5vbmUoXCJoaWRkZW4uYnMubW9kYWxcIixmdW5jdGlvbigpe2QuaXMoXCI6dmlzaWJsZVwiKSYmZC50cmlnZ2VyKFwiZm9jdXNcIil9KX0pLGIuY2FsbChmLGcsdGhpcyl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLnRvb2x0aXBcIiksZj1cIm9iamVjdFwiPT10eXBlb2YgYiYmYjsoZXx8IS9kZXN0cm95fGhpZGUvLnRlc3QoYikpJiYoZXx8ZC5kYXRhKFwiYnMudG9vbHRpcFwiLGU9bmV3IGModGhpcyxmKSksXCJzdHJpbmdcIj09dHlwZW9mIGImJmVbYl0oKSl9KX12YXIgYz1mdW5jdGlvbihhLGIpe3RoaXMudHlwZT1udWxsLHRoaXMub3B0aW9ucz1udWxsLHRoaXMuZW5hYmxlZD1udWxsLHRoaXMudGltZW91dD1udWxsLHRoaXMuaG92ZXJTdGF0ZT1udWxsLHRoaXMuJGVsZW1lbnQ9bnVsbCx0aGlzLmluU3RhdGU9bnVsbCx0aGlzLmluaXQoXCJ0b29sdGlwXCIsYSxiKX07Yy5WRVJTSU9OPVwiMy4zLjVcIixjLlRSQU5TSVRJT05fRFVSQVRJT049MTUwLGMuREVGQVVMVFM9e2FuaW1hdGlvbjohMCxwbGFjZW1lbnQ6XCJ0b3BcIixzZWxlY3RvcjohMSx0ZW1wbGF0ZTonPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLHRyaWdnZXI6XCJob3ZlciBmb2N1c1wiLHRpdGxlOlwiXCIsZGVsYXk6MCxodG1sOiExLGNvbnRhaW5lcjohMSx2aWV3cG9ydDp7c2VsZWN0b3I6XCJib2R5XCIscGFkZGluZzowfX0sYy5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihiLGMsZCl7aWYodGhpcy5lbmFibGVkPSEwLHRoaXMudHlwZT1iLHRoaXMuJGVsZW1lbnQ9YShjKSx0aGlzLm9wdGlvbnM9dGhpcy5nZXRPcHRpb25zKGQpLHRoaXMuJHZpZXdwb3J0PXRoaXMub3B0aW9ucy52aWV3cG9ydCYmYShhLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLnZpZXdwb3J0KT90aGlzLm9wdGlvbnMudmlld3BvcnQuY2FsbCh0aGlzLHRoaXMuJGVsZW1lbnQpOnRoaXMub3B0aW9ucy52aWV3cG9ydC5zZWxlY3Rvcnx8dGhpcy5vcHRpb25zLnZpZXdwb3J0KSx0aGlzLmluU3RhdGU9e2NsaWNrOiExLGhvdmVyOiExLGZvY3VzOiExfSx0aGlzLiRlbGVtZW50WzBdaW5zdGFuY2VvZiBkb2N1bWVudC5jb25zdHJ1Y3RvciYmIXRoaXMub3B0aW9ucy5zZWxlY3Rvcil0aHJvdyBuZXcgRXJyb3IoXCJgc2VsZWN0b3JgIG9wdGlvbiBtdXN0IGJlIHNwZWNpZmllZCB3aGVuIGluaXRpYWxpemluZyBcIit0aGlzLnR5cGUrXCIgb24gdGhlIHdpbmRvdy5kb2N1bWVudCBvYmplY3QhXCIpO2Zvcih2YXIgZT10aGlzLm9wdGlvbnMudHJpZ2dlci5zcGxpdChcIiBcIiksZj1lLmxlbmd0aDtmLS07KXt2YXIgZz1lW2ZdO2lmKFwiY2xpY2tcIj09Zyl0aGlzLiRlbGVtZW50Lm9uKFwiY2xpY2suXCIrdGhpcy50eXBlLHRoaXMub3B0aW9ucy5zZWxlY3RvcixhLnByb3h5KHRoaXMudG9nZ2xlLHRoaXMpKTtlbHNlIGlmKFwibWFudWFsXCIhPWcpe3ZhciBoPVwiaG92ZXJcIj09Zz9cIm1vdXNlZW50ZXJcIjpcImZvY3VzaW5cIixpPVwiaG92ZXJcIj09Zz9cIm1vdXNlbGVhdmVcIjpcImZvY3Vzb3V0XCI7dGhpcy4kZWxlbWVudC5vbihoK1wiLlwiK3RoaXMudHlwZSx0aGlzLm9wdGlvbnMuc2VsZWN0b3IsYS5wcm94eSh0aGlzLmVudGVyLHRoaXMpKSx0aGlzLiRlbGVtZW50Lm9uKGkrXCIuXCIrdGhpcy50eXBlLHRoaXMub3B0aW9ucy5zZWxlY3RvcixhLnByb3h5KHRoaXMubGVhdmUsdGhpcykpfX10aGlzLm9wdGlvbnMuc2VsZWN0b3I/dGhpcy5fb3B0aW9ucz1hLmV4dGVuZCh7fSx0aGlzLm9wdGlvbnMse3RyaWdnZXI6XCJtYW51YWxcIixzZWxlY3RvcjpcIlwifSk6dGhpcy5maXhUaXRsZSgpfSxjLnByb3RvdHlwZS5nZXREZWZhdWx0cz1mdW5jdGlvbigpe3JldHVybiBjLkRFRkFVTFRTfSxjLnByb3RvdHlwZS5nZXRPcHRpb25zPWZ1bmN0aW9uKGIpe3JldHVybiBiPWEuZXh0ZW5kKHt9LHRoaXMuZ2V0RGVmYXVsdHMoKSx0aGlzLiRlbGVtZW50LmRhdGEoKSxiKSxiLmRlbGF5JiZcIm51bWJlclwiPT10eXBlb2YgYi5kZWxheSYmKGIuZGVsYXk9e3Nob3c6Yi5kZWxheSxoaWRlOmIuZGVsYXl9KSxifSxjLnByb3RvdHlwZS5nZXREZWxlZ2F0ZU9wdGlvbnM9ZnVuY3Rpb24oKXt2YXIgYj17fSxjPXRoaXMuZ2V0RGVmYXVsdHMoKTtyZXR1cm4gdGhpcy5fb3B0aW9ucyYmYS5lYWNoKHRoaXMuX29wdGlvbnMsZnVuY3Rpb24oYSxkKXtjW2FdIT1kJiYoYlthXT1kKX0pLGJ9LGMucHJvdG90eXBlLmVudGVyPWZ1bmN0aW9uKGIpe3ZhciBjPWIgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yP2I6YShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUpO3JldHVybiBjfHwoYz1uZXcgdGhpcy5jb25zdHJ1Y3RvcihiLmN1cnJlbnRUYXJnZXQsdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSksYShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUsYykpLGIgaW5zdGFuY2VvZiBhLkV2ZW50JiYoYy5pblN0YXRlW1wiZm9jdXNpblwiPT1iLnR5cGU/XCJmb2N1c1wiOlwiaG92ZXJcIl09ITApLGMudGlwKCkuaGFzQ2xhc3MoXCJpblwiKXx8XCJpblwiPT1jLmhvdmVyU3RhdGU/dm9pZChjLmhvdmVyU3RhdGU9XCJpblwiKTooY2xlYXJUaW1lb3V0KGMudGltZW91dCksYy5ob3ZlclN0YXRlPVwiaW5cIixjLm9wdGlvbnMuZGVsYXkmJmMub3B0aW9ucy5kZWxheS5zaG93P3ZvaWQoYy50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtcImluXCI9PWMuaG92ZXJTdGF0ZSYmYy5zaG93KCl9LGMub3B0aW9ucy5kZWxheS5zaG93KSk6Yy5zaG93KCkpfSxjLnByb3RvdHlwZS5pc0luU3RhdGVUcnVlPWZ1bmN0aW9uKCl7Zm9yKHZhciBhIGluIHRoaXMuaW5TdGF0ZSlpZih0aGlzLmluU3RhdGVbYV0pcmV0dXJuITA7cmV0dXJuITF9LGMucHJvdG90eXBlLmxlYXZlPWZ1bmN0aW9uKGIpe3ZhciBjPWIgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yP2I6YShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUpO3JldHVybiBjfHwoYz1uZXcgdGhpcy5jb25zdHJ1Y3RvcihiLmN1cnJlbnRUYXJnZXQsdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSksYShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUsYykpLGIgaW5zdGFuY2VvZiBhLkV2ZW50JiYoYy5pblN0YXRlW1wiZm9jdXNvdXRcIj09Yi50eXBlP1wiZm9jdXNcIjpcImhvdmVyXCJdPSExKSxjLmlzSW5TdGF0ZVRydWUoKT92b2lkIDA6KGNsZWFyVGltZW91dChjLnRpbWVvdXQpLGMuaG92ZXJTdGF0ZT1cIm91dFwiLGMub3B0aW9ucy5kZWxheSYmYy5vcHRpb25zLmRlbGF5LmhpZGU/dm9pZChjLnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe1wib3V0XCI9PWMuaG92ZXJTdGF0ZSYmYy5oaWRlKCl9LGMub3B0aW9ucy5kZWxheS5oaWRlKSk6Yy5oaWRlKCkpfSxjLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKCl7dmFyIGI9YS5FdmVudChcInNob3cuYnMuXCIrdGhpcy50eXBlKTtpZih0aGlzLmhhc0NvbnRlbnQoKSYmdGhpcy5lbmFibGVkKXt0aGlzLiRlbGVtZW50LnRyaWdnZXIoYik7dmFyIGQ9YS5jb250YWlucyh0aGlzLiRlbGVtZW50WzBdLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHRoaXMuJGVsZW1lbnRbMF0pO2lmKGIuaXNEZWZhdWx0UHJldmVudGVkKCl8fCFkKXJldHVybjt2YXIgZT10aGlzLGY9dGhpcy50aXAoKSxnPXRoaXMuZ2V0VUlEKHRoaXMudHlwZSk7dGhpcy5zZXRDb250ZW50KCksZi5hdHRyKFwiaWRcIixnKSx0aGlzLiRlbGVtZW50LmF0dHIoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsZyksdGhpcy5vcHRpb25zLmFuaW1hdGlvbiYmZi5hZGRDbGFzcyhcImZhZGVcIik7dmFyIGg9XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5vcHRpb25zLnBsYWNlbWVudD90aGlzLm9wdGlvbnMucGxhY2VtZW50LmNhbGwodGhpcyxmWzBdLHRoaXMuJGVsZW1lbnRbMF0pOnRoaXMub3B0aW9ucy5wbGFjZW1lbnQsaT0vXFxzP2F1dG8/XFxzPy9pLGo9aS50ZXN0KGgpO2omJihoPWgucmVwbGFjZShpLFwiXCIpfHxcInRvcFwiKSxmLmRldGFjaCgpLmNzcyh7dG9wOjAsbGVmdDowLGRpc3BsYXk6XCJibG9ja1wifSkuYWRkQ2xhc3MoaCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSx0aGlzKSx0aGlzLm9wdGlvbnMuY29udGFpbmVyP2YuYXBwZW5kVG8odGhpcy5vcHRpb25zLmNvbnRhaW5lcik6Zi5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJpbnNlcnRlZC5icy5cIit0aGlzLnR5cGUpO3ZhciBrPXRoaXMuZ2V0UG9zaXRpb24oKSxsPWZbMF0ub2Zmc2V0V2lkdGgsbT1mWzBdLm9mZnNldEhlaWdodDtpZihqKXt2YXIgbj1oLG89dGhpcy5nZXRQb3NpdGlvbih0aGlzLiR2aWV3cG9ydCk7aD1cImJvdHRvbVwiPT1oJiZrLmJvdHRvbSttPm8uYm90dG9tP1widG9wXCI6XCJ0b3BcIj09aCYmay50b3AtbTxvLnRvcD9cImJvdHRvbVwiOlwicmlnaHRcIj09aCYmay5yaWdodCtsPm8ud2lkdGg/XCJsZWZ0XCI6XCJsZWZ0XCI9PWgmJmsubGVmdC1sPG8ubGVmdD9cInJpZ2h0XCI6aCxmLnJlbW92ZUNsYXNzKG4pLmFkZENsYXNzKGgpfXZhciBwPXRoaXMuZ2V0Q2FsY3VsYXRlZE9mZnNldChoLGssbCxtKTt0aGlzLmFwcGx5UGxhY2VtZW50KHAsaCk7dmFyIHE9ZnVuY3Rpb24oKXt2YXIgYT1lLmhvdmVyU3RhdGU7ZS4kZWxlbWVudC50cmlnZ2VyKFwic2hvd24uYnMuXCIrZS50eXBlKSxlLmhvdmVyU3RhdGU9bnVsbCxcIm91dFwiPT1hJiZlLmxlYXZlKGUpfTthLnN1cHBvcnQudHJhbnNpdGlvbiYmdGhpcy4kdGlwLmhhc0NsYXNzKFwiZmFkZVwiKT9mLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLHEpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGMuVFJBTlNJVElPTl9EVVJBVElPTik6cSgpfX0sYy5wcm90b3R5cGUuYXBwbHlQbGFjZW1lbnQ9ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLnRpcCgpLGU9ZFswXS5vZmZzZXRXaWR0aCxmPWRbMF0ub2Zmc2V0SGVpZ2h0LGc9cGFyc2VJbnQoZC5jc3MoXCJtYXJnaW4tdG9wXCIpLDEwKSxoPXBhcnNlSW50KGQuY3NzKFwibWFyZ2luLWxlZnRcIiksMTApO2lzTmFOKGcpJiYoZz0wKSxpc05hTihoKSYmKGg9MCksYi50b3ArPWcsYi5sZWZ0Kz1oLGEub2Zmc2V0LnNldE9mZnNldChkWzBdLGEuZXh0ZW5kKHt1c2luZzpmdW5jdGlvbihhKXtkLmNzcyh7dG9wOk1hdGgucm91bmQoYS50b3ApLGxlZnQ6TWF0aC5yb3VuZChhLmxlZnQpfSl9fSxiKSwwKSxkLmFkZENsYXNzKFwiaW5cIik7dmFyIGk9ZFswXS5vZmZzZXRXaWR0aCxqPWRbMF0ub2Zmc2V0SGVpZ2h0O1widG9wXCI9PWMmJmohPWYmJihiLnRvcD1iLnRvcCtmLWopO3ZhciBrPXRoaXMuZ2V0Vmlld3BvcnRBZGp1c3RlZERlbHRhKGMsYixpLGopO2subGVmdD9iLmxlZnQrPWsubGVmdDpiLnRvcCs9ay50b3A7dmFyIGw9L3RvcHxib3R0b20vLnRlc3QoYyksbT1sPzIqay5sZWZ0LWUraToyKmsudG9wLWYraixuPWw/XCJvZmZzZXRXaWR0aFwiOlwib2Zmc2V0SGVpZ2h0XCI7ZC5vZmZzZXQoYiksdGhpcy5yZXBsYWNlQXJyb3cobSxkWzBdW25dLGwpfSxjLnByb3RvdHlwZS5yZXBsYWNlQXJyb3c9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuYXJyb3coKS5jc3MoYz9cImxlZnRcIjpcInRvcFwiLDUwKigxLWEvYikrXCIlXCIpLmNzcyhjP1widG9wXCI6XCJsZWZ0XCIsXCJcIil9LGMucHJvdG90eXBlLnNldENvbnRlbnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnRpcCgpLGI9dGhpcy5nZXRUaXRsZSgpO2EuZmluZChcIi50b29sdGlwLWlubmVyXCIpW3RoaXMub3B0aW9ucy5odG1sP1wiaHRtbFwiOlwidGV4dFwiXShiKSxhLnJlbW92ZUNsYXNzKFwiZmFkZSBpbiB0b3AgYm90dG9tIGxlZnQgcmlnaHRcIil9LGMucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gZCgpe1wiaW5cIiE9ZS5ob3ZlclN0YXRlJiZmLmRldGFjaCgpLGUuJGVsZW1lbnQucmVtb3ZlQXR0cihcImFyaWEtZGVzY3JpYmVkYnlcIikudHJpZ2dlcihcImhpZGRlbi5icy5cIitlLnR5cGUpLGImJmIoKX12YXIgZT10aGlzLGY9YSh0aGlzLiR0aXApLGc9YS5FdmVudChcImhpZGUuYnMuXCIrdGhpcy50eXBlKTtyZXR1cm4gdGhpcy4kZWxlbWVudC50cmlnZ2VyKGcpLGcuaXNEZWZhdWx0UHJldmVudGVkKCk/dm9pZCAwOihmLnJlbW92ZUNsYXNzKFwiaW5cIiksYS5zdXBwb3J0LnRyYW5zaXRpb24mJmYuaGFzQ2xhc3MoXCJmYWRlXCIpP2Yub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsZCkuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5UUkFOU0lUSU9OX0RVUkFUSU9OKTpkKCksdGhpcy5ob3ZlclN0YXRlPW51bGwsdGhpcyl9LGMucHJvdG90eXBlLmZpeFRpdGxlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy4kZWxlbWVudDsoYS5hdHRyKFwidGl0bGVcIil8fFwic3RyaW5nXCIhPXR5cGVvZiBhLmF0dHIoXCJkYXRhLW9yaWdpbmFsLXRpdGxlXCIpKSYmYS5hdHRyKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiLGEuYXR0cihcInRpdGxlXCIpfHxcIlwiKS5hdHRyKFwidGl0bGVcIixcIlwiKX0sYy5wcm90b3R5cGUuaGFzQ29udGVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFRpdGxlKCl9LGMucHJvdG90eXBlLmdldFBvc2l0aW9uPWZ1bmN0aW9uKGIpe2I9Ynx8dGhpcy4kZWxlbWVudDt2YXIgYz1iWzBdLGQ9XCJCT0RZXCI9PWMudGFnTmFtZSxlPWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7bnVsbD09ZS53aWR0aCYmKGU9YS5leHRlbmQoe30sZSx7d2lkdGg6ZS5yaWdodC1lLmxlZnQsaGVpZ2h0OmUuYm90dG9tLWUudG9wfSkpO3ZhciBmPWQ/e3RvcDowLGxlZnQ6MH06Yi5vZmZzZXQoKSxnPXtzY3JvbGw6ZD9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wfHxkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDpiLnNjcm9sbFRvcCgpfSxoPWQ/e3dpZHRoOmEod2luZG93KS53aWR0aCgpLGhlaWdodDphKHdpbmRvdykuaGVpZ2h0KCl9Om51bGw7cmV0dXJuIGEuZXh0ZW5kKHt9LGUsZyxoLGYpfSxjLnByb3RvdHlwZS5nZXRDYWxjdWxhdGVkT2Zmc2V0PWZ1bmN0aW9uKGEsYixjLGQpe3JldHVyblwiYm90dG9tXCI9PWE/e3RvcDpiLnRvcCtiLmhlaWdodCxsZWZ0OmIubGVmdCtiLndpZHRoLzItYy8yfTpcInRvcFwiPT1hP3t0b3A6Yi50b3AtZCxsZWZ0OmIubGVmdCtiLndpZHRoLzItYy8yfTpcImxlZnRcIj09YT97dG9wOmIudG9wK2IuaGVpZ2h0LzItZC8yLGxlZnQ6Yi5sZWZ0LWN9Ont0b3A6Yi50b3ArYi5oZWlnaHQvMi1kLzIsbGVmdDpiLmxlZnQrYi53aWR0aH19LGMucHJvdG90eXBlLmdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT17dG9wOjAsbGVmdDowfTtpZighdGhpcy4kdmlld3BvcnQpcmV0dXJuIGU7dmFyIGY9dGhpcy5vcHRpb25zLnZpZXdwb3J0JiZ0aGlzLm9wdGlvbnMudmlld3BvcnQucGFkZGluZ3x8MCxnPXRoaXMuZ2V0UG9zaXRpb24odGhpcy4kdmlld3BvcnQpO2lmKC9yaWdodHxsZWZ0Ly50ZXN0KGEpKXt2YXIgaD1iLnRvcC1mLWcuc2Nyb2xsLGk9Yi50b3ArZi1nLnNjcm9sbCtkO2g8Zy50b3A/ZS50b3A9Zy50b3AtaDppPmcudG9wK2cuaGVpZ2h0JiYoZS50b3A9Zy50b3ArZy5oZWlnaHQtaSl9ZWxzZXt2YXIgaj1iLmxlZnQtZixrPWIubGVmdCtmK2M7ajxnLmxlZnQ/ZS5sZWZ0PWcubGVmdC1qOms+Zy5yaWdodCYmKGUubGVmdD1nLmxlZnQrZy53aWR0aC1rKX1yZXR1cm4gZX0sYy5wcm90b3R5cGUuZ2V0VGl0bGU9ZnVuY3Rpb24oKXt2YXIgYSxiPXRoaXMuJGVsZW1lbnQsYz10aGlzLm9wdGlvbnM7cmV0dXJuIGE9Yi5hdHRyKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGMudGl0bGU/Yy50aXRsZS5jYWxsKGJbMF0pOmMudGl0bGUpfSxjLnByb3RvdHlwZS5nZXRVSUQ9ZnVuY3Rpb24oYSl7ZG8gYSs9fn4oMWU2Kk1hdGgucmFuZG9tKCkpO3doaWxlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpKTtyZXR1cm4gYX0sYy5wcm90b3R5cGUudGlwPWZ1bmN0aW9uKCl7aWYoIXRoaXMuJHRpcCYmKHRoaXMuJHRpcD1hKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSksMSE9dGhpcy4kdGlwLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKHRoaXMudHlwZStcIiBgdGVtcGxhdGVgIG9wdGlvbiBtdXN0IGNvbnNpc3Qgb2YgZXhhY3RseSAxIHRvcC1sZXZlbCBlbGVtZW50IVwiKTtyZXR1cm4gdGhpcy4kdGlwfSxjLnByb3RvdHlwZS5hcnJvdz1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRhcnJvdz10aGlzLiRhcnJvd3x8dGhpcy50aXAoKS5maW5kKFwiLnRvb2x0aXAtYXJyb3dcIil9LGMucHJvdG90eXBlLmVuYWJsZT1mdW5jdGlvbigpe3RoaXMuZW5hYmxlZD0hMH0sYy5wcm90b3R5cGUuZGlzYWJsZT1mdW5jdGlvbigpe3RoaXMuZW5hYmxlZD0hMX0sYy5wcm90b3R5cGUudG9nZ2xlRW5hYmxlZD1mdW5jdGlvbigpe3RoaXMuZW5hYmxlZD0hdGhpcy5lbmFibGVkfSxjLnByb3RvdHlwZS50b2dnbGU9ZnVuY3Rpb24oYil7dmFyIGM9dGhpcztiJiYoYz1hKGIuY3VycmVudFRhcmdldCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSksY3x8KGM9bmV3IHRoaXMuY29uc3RydWN0b3IoYi5jdXJyZW50VGFyZ2V0LHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpLGEoYi5jdXJyZW50VGFyZ2V0KS5kYXRhKFwiYnMuXCIrdGhpcy50eXBlLGMpKSksYj8oYy5pblN0YXRlLmNsaWNrPSFjLmluU3RhdGUuY2xpY2ssYy5pc0luU3RhdGVUcnVlKCk/Yy5lbnRlcihjKTpjLmxlYXZlKGMpKTpjLnRpcCgpLmhhc0NsYXNzKFwiaW5cIik/Yy5sZWF2ZShjKTpjLmVudGVyKGMpfSxjLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KSx0aGlzLmhpZGUoZnVuY3Rpb24oKXthLiRlbGVtZW50Lm9mZihcIi5cIithLnR5cGUpLnJlbW92ZURhdGEoXCJicy5cIithLnR5cGUpLGEuJHRpcCYmYS4kdGlwLmRldGFjaCgpLGEuJHRpcD1udWxsLGEuJGFycm93PW51bGwsYS4kdmlld3BvcnQ9bnVsbH0pfTt2YXIgZD1hLmZuLnRvb2x0aXA7YS5mbi50b29sdGlwPWIsYS5mbi50b29sdGlwLkNvbnN0cnVjdG9yPWMsYS5mbi50b29sdGlwLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi50b29sdGlwPWQsdGhpc319KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy5wb3BvdmVyXCIpLGY9XCJvYmplY3RcIj09dHlwZW9mIGImJmI7KGV8fCEvZGVzdHJveXxoaWRlLy50ZXN0KGIpKSYmKGV8fGQuZGF0YShcImJzLnBvcG92ZXJcIixlPW5ldyBjKHRoaXMsZikpLFwic3RyaW5nXCI9PXR5cGVvZiBiJiZlW2JdKCkpfSl9dmFyIGM9ZnVuY3Rpb24oYSxiKXt0aGlzLmluaXQoXCJwb3BvdmVyXCIsYSxiKX07aWYoIWEuZm4udG9vbHRpcCl0aHJvdyBuZXcgRXJyb3IoXCJQb3BvdmVyIHJlcXVpcmVzIHRvb2x0aXAuanNcIik7Yy5WRVJTSU9OPVwiMy4zLjVcIixjLkRFRkFVTFRTPWEuZXh0ZW5kKHt9LGEuZm4udG9vbHRpcC5Db25zdHJ1Y3Rvci5ERUZBVUxUUyx7cGxhY2VtZW50OlwicmlnaHRcIix0cmlnZ2VyOlwiY2xpY2tcIixjb250ZW50OlwiXCIsdGVtcGxhdGU6JzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwiYXJyb3dcIj48L2Rpdj48aDMgY2xhc3M9XCJwb3BvdmVyLXRpdGxlXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1jb250ZW50XCI+PC9kaXY+PC9kaXY+J30pLGMucHJvdG90eXBlPWEuZXh0ZW5kKHt9LGEuZm4udG9vbHRpcC5Db25zdHJ1Y3Rvci5wcm90b3R5cGUpLGMucHJvdG90eXBlLmNvbnN0cnVjdG9yPWMsYy5wcm90b3R5cGUuZ2V0RGVmYXVsdHM9ZnVuY3Rpb24oKXtyZXR1cm4gYy5ERUZBVUxUU30sYy5wcm90b3R5cGUuc2V0Q29udGVudD1mdW5jdGlvbigpe3ZhciBhPXRoaXMudGlwKCksYj10aGlzLmdldFRpdGxlKCksYz10aGlzLmdldENvbnRlbnQoKTthLmZpbmQoXCIucG9wb3Zlci10aXRsZVwiKVt0aGlzLm9wdGlvbnMuaHRtbD9cImh0bWxcIjpcInRleHRcIl0oYiksYS5maW5kKFwiLnBvcG92ZXItY29udGVudFwiKS5jaGlsZHJlbigpLmRldGFjaCgpLmVuZCgpW3RoaXMub3B0aW9ucy5odG1sP1wic3RyaW5nXCI9PXR5cGVvZiBjP1wiaHRtbFwiOlwiYXBwZW5kXCI6XCJ0ZXh0XCJdKGMpLGEucmVtb3ZlQ2xhc3MoXCJmYWRlIHRvcCBib3R0b20gbGVmdCByaWdodCBpblwiKSxhLmZpbmQoXCIucG9wb3Zlci10aXRsZVwiKS5odG1sKCl8fGEuZmluZChcIi5wb3BvdmVyLXRpdGxlXCIpLmhpZGUoKX0sYy5wcm90b3R5cGUuaGFzQ29udGVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFRpdGxlKCl8fHRoaXMuZ2V0Q29udGVudCgpfSxjLnByb3RvdHlwZS5nZXRDb250ZW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy4kZWxlbWVudCxiPXRoaXMub3B0aW9ucztyZXR1cm4gYS5hdHRyKFwiZGF0YS1jb250ZW50XCIpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgYi5jb250ZW50P2IuY29udGVudC5jYWxsKGFbMF0pOmIuY29udGVudCl9LGMucHJvdG90eXBlLmFycm93PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGFycm93PXRoaXMuJGFycm93fHx0aGlzLnRpcCgpLmZpbmQoXCIuYXJyb3dcIil9O3ZhciBkPWEuZm4ucG9wb3ZlcjthLmZuLnBvcG92ZXI9YixhLmZuLnBvcG92ZXIuQ29uc3RydWN0b3I9YyxhLmZuLnBvcG92ZXIubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLnBvcG92ZXI9ZCx0aGlzfX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihjLGQpe3RoaXMuJGJvZHk9YShkb2N1bWVudC5ib2R5KSx0aGlzLiRzY3JvbGxFbGVtZW50PWEoYShjKS5pcyhkb2N1bWVudC5ib2R5KT93aW5kb3c6YyksdGhpcy5vcHRpb25zPWEuZXh0ZW5kKHt9LGIuREVGQVVMVFMsZCksdGhpcy5zZWxlY3Rvcj0odGhpcy5vcHRpb25zLnRhcmdldHx8XCJcIikrXCIgLm5hdiBsaSA+IGFcIix0aGlzLm9mZnNldHM9W10sdGhpcy50YXJnZXRzPVtdLHRoaXMuYWN0aXZlVGFyZ2V0PW51bGwsdGhpcy5zY3JvbGxIZWlnaHQ9MCx0aGlzLiRzY3JvbGxFbGVtZW50Lm9uKFwic2Nyb2xsLmJzLnNjcm9sbHNweVwiLGEucHJveHkodGhpcy5wcm9jZXNzLHRoaXMpKSx0aGlzLnJlZnJlc2goKSx0aGlzLnByb2Nlc3MoKX1mdW5jdGlvbiBjKGMpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZD1hKHRoaXMpLGU9ZC5kYXRhKFwiYnMuc2Nyb2xsc3B5XCIpLGY9XCJvYmplY3RcIj09dHlwZW9mIGMmJmM7ZXx8ZC5kYXRhKFwiYnMuc2Nyb2xsc3B5XCIsZT1uZXcgYih0aGlzLGYpKSxcInN0cmluZ1wiPT10eXBlb2YgYyYmZVtjXSgpfSl9Yi5WRVJTSU9OPVwiMy4zLjVcIixiLkRFRkFVTFRTPXtvZmZzZXQ6MTB9LGIucHJvdG90eXBlLmdldFNjcm9sbEhlaWdodD1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRzY3JvbGxFbGVtZW50WzBdLnNjcm9sbEhlaWdodHx8TWF0aC5tYXgodGhpcy4kYm9keVswXS5zY3JvbGxIZWlnaHQsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCl9LGIucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLGM9XCJvZmZzZXRcIixkPTA7dGhpcy5vZmZzZXRzPVtdLHRoaXMudGFyZ2V0cz1bXSx0aGlzLnNjcm9sbEhlaWdodD10aGlzLmdldFNjcm9sbEhlaWdodCgpLGEuaXNXaW5kb3codGhpcy4kc2Nyb2xsRWxlbWVudFswXSl8fChjPVwicG9zaXRpb25cIixkPXRoaXMuJHNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wKCkpLHRoaXMuJGJvZHkuZmluZCh0aGlzLnNlbGVjdG9yKS5tYXAoZnVuY3Rpb24oKXt2YXIgYj1hKHRoaXMpLGU9Yi5kYXRhKFwidGFyZ2V0XCIpfHxiLmF0dHIoXCJocmVmXCIpLGY9L14jLi8udGVzdChlKSYmYShlKTtyZXR1cm4gZiYmZi5sZW5ndGgmJmYuaXMoXCI6dmlzaWJsZVwiKSYmW1tmW2NdKCkudG9wK2QsZV1dfHxudWxsfSkuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhWzBdLWJbMF19KS5lYWNoKGZ1bmN0aW9uKCl7Yi5vZmZzZXRzLnB1c2godGhpc1swXSksYi50YXJnZXRzLnB1c2godGhpc1sxXSl9KX0sYi5wcm90b3R5cGUucHJvY2Vzcz1mdW5jdGlvbigpe3ZhciBhLGI9dGhpcy4kc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3AoKSt0aGlzLm9wdGlvbnMub2Zmc2V0LGM9dGhpcy5nZXRTY3JvbGxIZWlnaHQoKSxkPXRoaXMub3B0aW9ucy5vZmZzZXQrYy10aGlzLiRzY3JvbGxFbGVtZW50LmhlaWdodCgpLGU9dGhpcy5vZmZzZXRzLGY9dGhpcy50YXJnZXRzLGc9dGhpcy5hY3RpdmVUYXJnZXQ7aWYodGhpcy5zY3JvbGxIZWlnaHQhPWMmJnRoaXMucmVmcmVzaCgpLGI+PWQpcmV0dXJuIGchPShhPWZbZi5sZW5ndGgtMV0pJiZ0aGlzLmFjdGl2YXRlKGEpO2lmKGcmJmI8ZVswXSlyZXR1cm4gdGhpcy5hY3RpdmVUYXJnZXQ9bnVsbCx0aGlzLmNsZWFyKCk7Zm9yKGE9ZS5sZW5ndGg7YS0tOylnIT1mW2FdJiZiPj1lW2FdJiYodm9pZCAwPT09ZVthKzFdfHxiPGVbYSsxXSkmJnRoaXMuYWN0aXZhdGUoZlthXSl9LGIucHJvdG90eXBlLmFjdGl2YXRlPWZ1bmN0aW9uKGIpe3RoaXMuYWN0aXZlVGFyZ2V0PWIsdGhpcy5jbGVhcigpO3ZhciBjPXRoaXMuc2VsZWN0b3IrJ1tkYXRhLXRhcmdldD1cIicrYisnXCJdLCcrdGhpcy5zZWxlY3RvcisnW2hyZWY9XCInK2IrJ1wiXScsZD1hKGMpLnBhcmVudHMoXCJsaVwiKS5hZGRDbGFzcyhcImFjdGl2ZVwiKTtkLnBhcmVudChcIi5kcm9wZG93bi1tZW51XCIpLmxlbmd0aCYmKGQ9ZC5jbG9zZXN0KFwibGkuZHJvcGRvd25cIikuYWRkQ2xhc3MoXCJhY3RpdmVcIikpLFxuICAgIGQudHJpZ2dlcihcImFjdGl2YXRlLmJzLnNjcm9sbHNweVwiKX0sYi5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXthKHRoaXMuc2VsZWN0b3IpLnBhcmVudHNVbnRpbCh0aGlzLm9wdGlvbnMudGFyZ2V0LFwiLmFjdGl2ZVwiKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKX07dmFyIGQ9YS5mbi5zY3JvbGxzcHk7YS5mbi5zY3JvbGxzcHk9YyxhLmZuLnNjcm9sbHNweS5Db25zdHJ1Y3Rvcj1iLGEuZm4uc2Nyb2xsc3B5Lm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5zY3JvbGxzcHk9ZCx0aGlzfSxhKHdpbmRvdykub24oXCJsb2FkLmJzLnNjcm9sbHNweS5kYXRhLWFwaVwiLGZ1bmN0aW9uKCl7YSgnW2RhdGEtc3B5PVwic2Nyb2xsXCJdJykuZWFjaChmdW5jdGlvbigpe3ZhciBiPWEodGhpcyk7Yy5jYWxsKGIsYi5kYXRhKCkpfSl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLnRhYlwiKTtlfHxkLmRhdGEoXCJicy50YWJcIixlPW5ldyBjKHRoaXMpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZVtiXSgpfSl9dmFyIGM9ZnVuY3Rpb24oYil7dGhpcy5lbGVtZW50PWEoYil9O2MuVkVSU0lPTj1cIjMuMy41XCIsYy5UUkFOU0lUSU9OX0RVUkFUSU9OPTE1MCxjLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5lbGVtZW50LGM9Yi5jbG9zZXN0KFwidWw6bm90KC5kcm9wZG93bi1tZW51KVwiKSxkPWIuZGF0YShcInRhcmdldFwiKTtpZihkfHwoZD1iLmF0dHIoXCJocmVmXCIpLGQ9ZCYmZC5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLFwiXCIpKSwhYi5wYXJlbnQoXCJsaVwiKS5oYXNDbGFzcyhcImFjdGl2ZVwiKSl7dmFyIGU9Yy5maW5kKFwiLmFjdGl2ZTpsYXN0IGFcIiksZj1hLkV2ZW50KFwiaGlkZS5icy50YWJcIix7cmVsYXRlZFRhcmdldDpiWzBdfSksZz1hLkV2ZW50KFwic2hvdy5icy50YWJcIix7cmVsYXRlZFRhcmdldDplWzBdfSk7aWYoZS50cmlnZ2VyKGYpLGIudHJpZ2dlcihnKSwhZy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSYmIWYuaXNEZWZhdWx0UHJldmVudGVkKCkpe3ZhciBoPWEoZCk7dGhpcy5hY3RpdmF0ZShiLmNsb3Nlc3QoXCJsaVwiKSxjKSx0aGlzLmFjdGl2YXRlKGgsaC5wYXJlbnQoKSxmdW5jdGlvbigpe2UudHJpZ2dlcih7dHlwZTpcImhpZGRlbi5icy50YWJcIixyZWxhdGVkVGFyZ2V0OmJbMF19KSxiLnRyaWdnZXIoe3R5cGU6XCJzaG93bi5icy50YWJcIixyZWxhdGVkVGFyZ2V0OmVbMF19KX0pfX19LGMucHJvdG90eXBlLmFjdGl2YXRlPWZ1bmN0aW9uKGIsZCxlKXtmdW5jdGlvbiBmKCl7Zy5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKS5maW5kKFwiPiAuZHJvcGRvd24tbWVudSA+IC5hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIikuZW5kKCkuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJykuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMSksYi5hZGRDbGFzcyhcImFjdGl2ZVwiKS5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCEwKSxoPyhiWzBdLm9mZnNldFdpZHRoLGIuYWRkQ2xhc3MoXCJpblwiKSk6Yi5yZW1vdmVDbGFzcyhcImZhZGVcIiksYi5wYXJlbnQoXCIuZHJvcGRvd24tbWVudVwiKS5sZW5ndGgmJmIuY2xvc2VzdChcImxpLmRyb3Bkb3duXCIpLmFkZENsYXNzKFwiYWN0aXZlXCIpLmVuZCgpLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITApLGUmJmUoKX12YXIgZz1kLmZpbmQoXCI+IC5hY3RpdmVcIiksaD1lJiZhLnN1cHBvcnQudHJhbnNpdGlvbiYmKGcubGVuZ3RoJiZnLmhhc0NsYXNzKFwiZmFkZVwiKXx8ISFkLmZpbmQoXCI+IC5mYWRlXCIpLmxlbmd0aCk7Zy5sZW5ndGgmJmg/Zy5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixmKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLlRSQU5TSVRJT05fRFVSQVRJT04pOmYoKSxnLnJlbW92ZUNsYXNzKFwiaW5cIil9O3ZhciBkPWEuZm4udGFiO2EuZm4udGFiPWIsYS5mbi50YWIuQ29uc3RydWN0b3I9YyxhLmZuLnRhYi5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4udGFiPWQsdGhpc307dmFyIGU9ZnVuY3Rpb24oYyl7Yy5wcmV2ZW50RGVmYXVsdCgpLGIuY2FsbChhKHRoaXMpLFwic2hvd1wiKX07YShkb2N1bWVudCkub24oXCJjbGljay5icy50YWIuZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJyxlKS5vbihcImNsaWNrLmJzLnRhYi5kYXRhLWFwaVwiLCdbZGF0YS10b2dnbGU9XCJwaWxsXCJdJyxlKX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLmFmZml4XCIpLGY9XCJvYmplY3RcIj09dHlwZW9mIGImJmI7ZXx8ZC5kYXRhKFwiYnMuYWZmaXhcIixlPW5ldyBjKHRoaXMsZikpLFwic3RyaW5nXCI9PXR5cGVvZiBiJiZlW2JdKCl9KX12YXIgYz1mdW5jdGlvbihiLGQpe3RoaXMub3B0aW9ucz1hLmV4dGVuZCh7fSxjLkRFRkFVTFRTLGQpLHRoaXMuJHRhcmdldD1hKHRoaXMub3B0aW9ucy50YXJnZXQpLm9uKFwic2Nyb2xsLmJzLmFmZml4LmRhdGEtYXBpXCIsYS5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb24sdGhpcykpLm9uKFwiY2xpY2suYnMuYWZmaXguZGF0YS1hcGlcIixhLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbldpdGhFdmVudExvb3AsdGhpcykpLHRoaXMuJGVsZW1lbnQ9YShiKSx0aGlzLmFmZml4ZWQ9bnVsbCx0aGlzLnVucGluPW51bGwsdGhpcy5waW5uZWRPZmZzZXQ9bnVsbCx0aGlzLmNoZWNrUG9zaXRpb24oKX07Yy5WRVJTSU9OPVwiMy4zLjVcIixjLlJFU0VUPVwiYWZmaXggYWZmaXgtdG9wIGFmZml4LWJvdHRvbVwiLGMuREVGQVVMVFM9e29mZnNldDowLHRhcmdldDp3aW5kb3d9LGMucHJvdG90eXBlLmdldFN0YXRlPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuJHRhcmdldC5zY3JvbGxUb3AoKSxmPXRoaXMuJGVsZW1lbnQub2Zmc2V0KCksZz10aGlzLiR0YXJnZXQuaGVpZ2h0KCk7aWYobnVsbCE9YyYmXCJ0b3BcIj09dGhpcy5hZmZpeGVkKXJldHVybiBjPmU/XCJ0b3BcIjohMTtpZihcImJvdHRvbVwiPT10aGlzLmFmZml4ZWQpcmV0dXJuIG51bGwhPWM/ZSt0aGlzLnVucGluPD1mLnRvcD8hMTpcImJvdHRvbVwiOmEtZD49ZStnPyExOlwiYm90dG9tXCI7dmFyIGg9bnVsbD09dGhpcy5hZmZpeGVkLGk9aD9lOmYudG9wLGo9aD9nOmI7cmV0dXJuIG51bGwhPWMmJmM+PWU/XCJ0b3BcIjpudWxsIT1kJiZpK2o+PWEtZD9cImJvdHRvbVwiOiExfSxjLnByb3RvdHlwZS5nZXRQaW5uZWRPZmZzZXQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBpbm5lZE9mZnNldClyZXR1cm4gdGhpcy5waW5uZWRPZmZzZXQ7dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhjLlJFU0VUKS5hZGRDbGFzcyhcImFmZml4XCIpO3ZhciBhPXRoaXMuJHRhcmdldC5zY3JvbGxUb3AoKSxiPXRoaXMuJGVsZW1lbnQub2Zmc2V0KCk7cmV0dXJuIHRoaXMucGlubmVkT2Zmc2V0PWIudG9wLWF9LGMucHJvdG90eXBlLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wPWZ1bmN0aW9uKCl7c2V0VGltZW91dChhLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbix0aGlzKSwxKX0sYy5wcm90b3R5cGUuY2hlY2tQb3NpdGlvbj1mdW5jdGlvbigpe2lmKHRoaXMuJGVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKSl7dmFyIGI9dGhpcy4kZWxlbWVudC5oZWlnaHQoKSxkPXRoaXMub3B0aW9ucy5vZmZzZXQsZT1kLnRvcCxmPWQuYm90dG9tLGc9TWF0aC5tYXgoYShkb2N1bWVudCkuaGVpZ2h0KCksYShkb2N1bWVudC5ib2R5KS5oZWlnaHQoKSk7XCJvYmplY3RcIiE9dHlwZW9mIGQmJihmPWU9ZCksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmKGU9ZC50b3AodGhpcy4kZWxlbWVudCkpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGYmJihmPWQuYm90dG9tKHRoaXMuJGVsZW1lbnQpKTt2YXIgaD10aGlzLmdldFN0YXRlKGcsYixlLGYpO2lmKHRoaXMuYWZmaXhlZCE9aCl7bnVsbCE9dGhpcy51bnBpbiYmdGhpcy4kZWxlbWVudC5jc3MoXCJ0b3BcIixcIlwiKTt2YXIgaT1cImFmZml4XCIrKGg/XCItXCIraDpcIlwiKSxqPWEuRXZlbnQoaStcIi5icy5hZmZpeFwiKTtpZih0aGlzLiRlbGVtZW50LnRyaWdnZXIoaiksai5pc0RlZmF1bHRQcmV2ZW50ZWQoKSlyZXR1cm47dGhpcy5hZmZpeGVkPWgsdGhpcy51bnBpbj1cImJvdHRvbVwiPT1oP3RoaXMuZ2V0UGlubmVkT2Zmc2V0KCk6bnVsbCx0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKGMuUkVTRVQpLmFkZENsYXNzKGkpLnRyaWdnZXIoaS5yZXBsYWNlKFwiYWZmaXhcIixcImFmZml4ZWRcIikrXCIuYnMuYWZmaXhcIil9XCJib3R0b21cIj09aCYmdGhpcy4kZWxlbWVudC5vZmZzZXQoe3RvcDpnLWItZn0pfX07dmFyIGQ9YS5mbi5hZmZpeDthLmZuLmFmZml4PWIsYS5mbi5hZmZpeC5Db25zdHJ1Y3Rvcj1jLGEuZm4uYWZmaXgubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLmFmZml4PWQsdGhpc30sYSh3aW5kb3cpLm9uKFwibG9hZFwiLGZ1bmN0aW9uKCl7YSgnW2RhdGEtc3B5PVwiYWZmaXhcIl0nKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGM9YSh0aGlzKSxkPWMuZGF0YSgpO2Qub2Zmc2V0PWQub2Zmc2V0fHx7fSxudWxsIT1kLm9mZnNldEJvdHRvbSYmKGQub2Zmc2V0LmJvdHRvbT1kLm9mZnNldEJvdHRvbSksbnVsbCE9ZC5vZmZzZXRUb3AmJihkLm9mZnNldC50b3A9ZC5vZmZzZXRUb3ApLGIuY2FsbChjLGQpfSl9KX0oalF1ZXJ5KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWRpdGFibGUvanMvYm9vdHN0cmFwLm1pbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\n/*!\n * jQuery JavaScript Library v3.2.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2017-03-20T18:59Z\n */\n(function (global, factory) {\n\n\t"use strict";\n\n\tif (( false ? "undefined" : _typeof(module)) === "object" && _typeof(module.exports) === "object") {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require("jquery")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ? factory(global, true) : function (w) {\n\t\t\tif (!w.document) {\n\t\t\t\tthrow new Error("jQuery requires a window with a document");\n\t\t\t}\n\t\t\treturn factory(w);\n\t\t};\n\t} else {\n\t\tfactory(global);\n\t}\n\n\t// Pass this if window is not defined yet\n})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {\n\n\t// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n\t// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n\t// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n\t// enough that all such attempts are guarded in a try block.\n\t"use strict";\n\n\tvar arr = [];\n\n\tvar document = window.document;\n\n\tvar getProto = Object.getPrototypeOf;\n\n\tvar _slice = arr.slice;\n\n\tvar concat = arr.concat;\n\n\tvar push = arr.push;\n\n\tvar indexOf = arr.indexOf;\n\n\tvar class2type = {};\n\n\tvar toString = class2type.toString;\n\n\tvar hasOwn = class2type.hasOwnProperty;\n\n\tvar fnToString = hasOwn.toString;\n\n\tvar ObjectFunctionString = fnToString.call(Object);\n\n\tvar support = {};\n\n\tfunction DOMEval(code, doc) {\n\t\tdoc = doc || document;\n\n\t\tvar script = doc.createElement("script");\n\n\t\tscript.text = code;\n\t\tdoc.head.appendChild(script).parentNode.removeChild(script);\n\t}\n\t/* global Symbol */\n\t// Defining this global in .eslintrc.json would create a danger of using the global\n\t// unguarded in another place, it seems safer to define global only for this module\n\n\n\tvar version = "3.2.1",\n\n\n\t// Define a local copy of jQuery\n\tjQuery = function jQuery(selector, context) {\n\n\t\t// The jQuery object is actually just the init constructor \'enhanced\'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init(selector, context);\n\t},\n\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\t    rdashAlpha = /-([a-z])/g,\n\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function fcamelCase(all, letter) {\n\t\treturn letter.toUpperCase();\n\t};\n\n\tjQuery.fn = jQuery.prototype = {\n\n\t\t// The current version of jQuery being used\n\t\tjquery: version,\n\n\t\tconstructor: jQuery,\n\n\t\t// The default length of a jQuery object is 0\n\t\tlength: 0,\n\n\t\ttoArray: function toArray() {\n\t\t\treturn _slice.call(this);\n\t\t},\n\n\t\t// Get the Nth element in the matched element set OR\n\t\t// Get the whole matched element set as a clean array\n\t\tget: function get(num) {\n\n\t\t\t// Return all the elements in a clean array\n\t\t\tif (num == null) {\n\t\t\t\treturn _slice.call(this);\n\t\t\t}\n\n\t\t\t// Return just the one element from the set\n\t\t\treturn num < 0 ? this[num + this.length] : this[num];\n\t\t},\n\n\t\t// Take an array of elements and push it onto the stack\n\t\t// (returning the new matched element set)\n\t\tpushStack: function pushStack(elems) {\n\n\t\t\t// Build a new jQuery matched element set\n\t\t\tvar ret = jQuery.merge(this.constructor(), elems);\n\n\t\t\t// Add the old object onto the stack (as a reference)\n\t\t\tret.prevObject = this;\n\n\t\t\t// Return the newly-formed element set\n\t\t\treturn ret;\n\t\t},\n\n\t\t// Execute a callback for every element in the matched set.\n\t\teach: function each(callback) {\n\t\t\treturn jQuery.each(this, callback);\n\t\t},\n\n\t\tmap: function map(callback) {\n\t\t\treturn this.pushStack(jQuery.map(this, function (elem, i) {\n\t\t\t\treturn callback.call(elem, i, elem);\n\t\t\t}));\n\t\t},\n\n\t\tslice: function slice() {\n\t\t\treturn this.pushStack(_slice.apply(this, arguments));\n\t\t},\n\n\t\tfirst: function first() {\n\t\t\treturn this.eq(0);\n\t\t},\n\n\t\tlast: function last() {\n\t\t\treturn this.eq(-1);\n\t\t},\n\n\t\teq: function eq(i) {\n\t\t\tvar len = this.length,\n\t\t\t    j = +i + (i < 0 ? len : 0);\n\t\t\treturn this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n\t\t},\n\n\t\tend: function end() {\n\t\t\treturn this.prevObject || this.constructor();\n\t\t},\n\n\t\t// For internal use only.\n\t\t// Behaves like an Array\'s method, not like a jQuery method.\n\t\tpush: push,\n\t\tsort: arr.sort,\n\t\tsplice: arr.splice\n\t};\n\n\tjQuery.extend = jQuery.fn.extend = function () {\n\t\tvar options,\n\t\t    name,\n\t\t    src,\n\t\t    copy,\n\t\t    copyIsArray,\n\t\t    clone,\n\t\t    target = arguments[0] || {},\n\t\t    i = 1,\n\t\t    length = arguments.length,\n\t\t    deep = false;\n\n\t\t// Handle a deep copy situation\n\t\tif (typeof target === "boolean") {\n\t\t\tdeep = target;\n\n\t\t\t// Skip the boolean and the target\n\t\t\ttarget = arguments[i] || {};\n\t\t\ti++;\n\t\t}\n\n\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\tif ((typeof target === "undefined" ? "undefined" : _typeof(target)) !== "object" && !jQuery.isFunction(target)) {\n\t\t\ttarget = {};\n\t\t}\n\n\t\t// Extend jQuery itself if only one argument is passed\n\t\tif (i === length) {\n\t\t\ttarget = this;\n\t\t\ti--;\n\t\t}\n\n\t\tfor (; i < length; i++) {\n\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif ((options = arguments[i]) != null) {\n\n\t\t\t\t// Extend the base object\n\t\t\t\tfor (name in options) {\n\t\t\t\t\tsrc = target[name];\n\t\t\t\t\tcopy = options[name];\n\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif (target === copy) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Recurse if we\'re merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && Array.isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = jQuery.extend(deep, clone, copy);\n\n\t\t\t\t\t\t// Don\'t bring in undefined values\n\t\t\t\t\t} else if (copy !== undefined) {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\n\tjQuery.extend({\n\n\t\t// Unique for each copy of jQuery on the page\n\t\texpando: "jQuery" + (version + Math.random()).replace(/\\D/g, ""),\n\n\t\t// Assume jQuery is ready without the ready module\n\t\tisReady: true,\n\n\t\terror: function error(msg) {\n\t\t\tthrow new Error(msg);\n\t\t},\n\n\t\tnoop: function noop() {},\n\n\t\tisFunction: function isFunction(obj) {\n\t\t\treturn jQuery.type(obj) === "function";\n\t\t},\n\n\t\tisWindow: function isWindow(obj) {\n\t\t\treturn obj != null && obj === obj.window;\n\t\t},\n\n\t\tisNumeric: function isNumeric(obj) {\n\n\t\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t\t// strings and numbers (primitives or objects)\n\t\t\t// that can be coerced to finite numbers (gh-2662)\n\t\t\tvar type = jQuery.type(obj);\n\t\t\treturn (type === "number" || type === "string") &&\n\n\t\t\t// parseFloat NaNs numeric-cast false positives ("")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals ("0x...")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t!isNaN(obj - parseFloat(obj));\n\t\t},\n\n\t\tisPlainObject: function isPlainObject(obj) {\n\t\t\tvar proto, Ctor;\n\n\t\t\t// Detect obvious negatives\n\t\t\t// Use toString instead of jQuery.type to catch host objects\n\t\t\tif (!obj || toString.call(obj) !== "[object Object]") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tproto = getProto(obj);\n\n\t\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\t\tif (!proto) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\t\tCtor = hasOwn.call(proto, "constructor") && proto.constructor;\n\t\t\treturn typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;\n\t\t},\n\n\t\tisEmptyObject: function isEmptyObject(obj) {\n\n\t\t\t/* eslint-disable no-unused-vars */\n\t\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\t\tvar name;\n\n\t\t\tfor (name in obj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\ttype: function type(obj) {\n\t\t\tif (obj == null) {\n\t\t\t\treturn obj + "";\n\t\t\t}\n\n\t\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\t\treturn (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj === "undefined" ? "undefined" : _typeof(obj);\n\t\t},\n\n\t\t// Evaluates a script in a global context\n\t\tglobalEval: function globalEval(code) {\n\t\t\tDOMEval(code);\n\t\t},\n\n\t\t// Convert dashed to camelCase; used by the css and data modules\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Microsoft forgot to hump their vendor prefix (#9572)\n\t\tcamelCase: function camelCase(string) {\n\t\t\treturn string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);\n\t\t},\n\n\t\teach: function each(obj, callback) {\n\t\t\tvar length,\n\t\t\t    i = 0;\n\n\t\t\tif (isArrayLike(obj)) {\n\t\t\t\tlength = obj.length;\n\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\tif (callback.call(obj[i], i, obj[i]) === false) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i in obj) {\n\t\t\t\t\tif (callback.call(obj[i], i, obj[i]) === false) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t},\n\n\t\t// Support: Android <=4.0 only\n\t\ttrim: function trim(text) {\n\t\t\treturn text == null ? "" : (text + "").replace(rtrim, "");\n\t\t},\n\n\t\t// results is for internal usage only\n\t\tmakeArray: function makeArray(arr, results) {\n\t\t\tvar ret = results || [];\n\n\t\t\tif (arr != null) {\n\t\t\t\tif (isArrayLike(Object(arr))) {\n\t\t\t\t\tjQuery.merge(ret, typeof arr === "string" ? [arr] : arr);\n\t\t\t\t} else {\n\t\t\t\t\tpush.call(ret, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t},\n\n\t\tinArray: function inArray(elem, arr, i) {\n\t\t\treturn arr == null ? -1 : indexOf.call(arr, elem, i);\n\t\t},\n\n\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\tmerge: function merge(first, second) {\n\t\t\tvar len = +second.length,\n\t\t\t    j = 0,\n\t\t\t    i = first.length;\n\n\t\t\tfor (; j < len; j++) {\n\t\t\t\tfirst[i++] = second[j];\n\t\t\t}\n\n\t\t\tfirst.length = i;\n\n\t\t\treturn first;\n\t\t},\n\n\t\tgrep: function grep(elems, callback, invert) {\n\t\t\tvar callbackInverse,\n\t\t\t    matches = [],\n\t\t\t    i = 0,\n\t\t\t    length = elems.length,\n\t\t\t    callbackExpect = !invert;\n\n\t\t\t// Go through the array, only saving the items\n\t\t\t// that pass the validator function\n\t\t\tfor (; i < length; i++) {\n\t\t\t\tcallbackInverse = !callback(elems[i], i);\n\t\t\t\tif (callbackInverse !== callbackExpect) {\n\t\t\t\t\tmatches.push(elems[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn matches;\n\t\t},\n\n\t\t// arg is for internal usage only\n\t\tmap: function map(elems, callback, arg) {\n\t\t\tvar length,\n\t\t\t    value,\n\t\t\t    i = 0,\n\t\t\t    ret = [];\n\n\t\t\t// Go through the array, translating each of the items to their new values\n\t\t\tif (isArrayLike(elems)) {\n\t\t\t\tlength = elems.length;\n\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\tvalue = callback(elems[i], i, arg);\n\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tret.push(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Go through every key on the object,\n\t\t\t} else {\n\t\t\t\tfor (i in elems) {\n\t\t\t\t\tvalue = callback(elems[i], i, arg);\n\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tret.push(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Flatten any nested arrays\n\t\t\treturn concat.apply([], ret);\n\t\t},\n\n\t\t// A global GUID counter for objects\n\t\tguid: 1,\n\n\t\t// Bind a function to a context, optionally partially applying any\n\t\t// arguments.\n\t\tproxy: function proxy(fn, context) {\n\t\t\tvar tmp, args, proxy;\n\n\t\t\tif (typeof context === "string") {\n\t\t\t\ttmp = fn[context];\n\t\t\t\tcontext = fn;\n\t\t\t\tfn = tmp;\n\t\t\t}\n\n\t\t\t// Quick check to determine if target is callable, in the spec\n\t\t\t// this throws a TypeError, but we will just return undefined.\n\t\t\tif (!jQuery.isFunction(fn)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t// Simulated bind\n\t\t\targs = _slice.call(arguments, 2);\n\t\t\tproxy = function proxy() {\n\t\t\t\treturn fn.apply(context || this, args.concat(_slice.call(arguments)));\n\t\t\t};\n\n\t\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\t\treturn proxy;\n\t\t},\n\n\t\tnow: Date.now,\n\n\t\t// jQuery.support is not used in Core but other projects attach their\n\t\t// properties to it so it needs to exist.\n\t\tsupport: support\n\t});\n\n\tif (typeof Symbol === "function") {\n\t\tjQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\n\t}\n\n\t// Populate the class2type map\n\tjQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {\n\t\tclass2type["[object " + name + "]"] = name.toLowerCase();\n\t});\n\n\tfunction isArrayLike(obj) {\n\n\t\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t\t// `in` check used to prevent JIT error (gh-2145)\n\t\t// hasOwn isn\'t used here due to false negatives\n\t\t// regarding Nodelist length in IE\n\t\tvar length = !!obj && "length" in obj && obj.length,\n\t\t    type = jQuery.type(obj);\n\n\t\tif (type === "function" || jQuery.isWindow(obj)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;\n\t}\n\tvar Sizzle =\n\t/*!\n  * Sizzle CSS Selector Engine v2.3.3\n  * https://sizzlejs.com/\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license\n  * http://jquery.org/license\n  *\n  * Date: 2016-08-08\n  */\n\tfunction (window) {\n\n\t\tvar i,\n\t\t    support,\n\t\t    Expr,\n\t\t    getText,\n\t\t    isXML,\n\t\t    tokenize,\n\t\t    compile,\n\t\t    select,\n\t\t    outermostContext,\n\t\t    sortInput,\n\t\t    hasDuplicate,\n\n\n\t\t// Local document vars\n\t\tsetDocument,\n\t\t    document,\n\t\t    docElem,\n\t\t    documentIsHTML,\n\t\t    rbuggyQSA,\n\t\t    rbuggyMatches,\n\t\t    matches,\n\t\t    contains,\n\n\n\t\t// Instance-specific data\n\t\texpando = "sizzle" + 1 * new Date(),\n\t\t    preferredDoc = window.document,\n\t\t    dirruns = 0,\n\t\t    done = 0,\n\t\t    classCache = createCache(),\n\t\t    tokenCache = createCache(),\n\t\t    compilerCache = createCache(),\n\t\t    sortOrder = function sortOrder(a, b) {\n\t\t\tif (a === b) {\n\t\t\t\thasDuplicate = true;\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\n\t\t// Instance methods\n\t\thasOwn = {}.hasOwnProperty,\n\t\t    arr = [],\n\t\t    pop = arr.pop,\n\t\t    push_native = arr.push,\n\t\t    push = arr.push,\n\t\t    slice = arr.slice,\n\n\t\t// Use a stripped-down indexOf as it\'s faster than native\n\t\t// https://jsperf.com/thor-indexof-vs-for/5\n\t\tindexOf = function indexOf(list, elem) {\n\t\t\tvar i = 0,\n\t\t\t    len = list.length;\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tif (list[i] === elem) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\t\t    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",\n\n\n\t\t// Regular expressions\n\n\t\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\t\twhitespace = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n\n\n\t\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\t\tidentifier = "(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+",\n\n\n\t\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\t\tattributes = "\\\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +\n\t\t// Operator (capture 2)\n\t\t"*([*^$|!~]?=)" + whitespace +\n\t\t// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"\n\t\t"*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(" + identifier + "))|)" + whitespace + "*\\\\]",\n\t\t    pseudos = ":(" + identifier + ")(?:\\\\((" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t"(\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|" +\n\t\t// 2. simple (capture 6)\n\t\t"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + attributes + ")*)|" +\n\t\t// 3. anything else (capture 2)\n\t\t".*" + ")\\\\)|)",\n\n\n\t\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\t\trwhitespace = new RegExp(whitespace + "+", "g"),\n\t\t    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + whitespace + "+$", "g"),\n\t\t    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),\n\t\t    rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),\n\t\t    rattributeQuotes = new RegExp("=" + whitespace + "*([^\\\\]\'\\"]*?)" + whitespace + "*\\\\]", "g"),\n\t\t    rpseudo = new RegExp(pseudos),\n\t\t    ridentifier = new RegExp("^" + identifier + "$"),\n\t\t    matchExpr = {\n\t\t\t"ID": new RegExp("^#(" + identifier + ")"),\n\t\t\t"CLASS": new RegExp("^\\\\.(" + identifier + ")"),\n\t\t\t"TAG": new RegExp("^(" + identifier + "|[*])"),\n\t\t\t"ATTR": new RegExp("^" + attributes),\n\t\t\t"PSEUDO": new RegExp("^" + pseudos),\n\t\t\t"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + whitespace + "*(even|odd|(([+-]|)(\\\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\\\d+)|))" + whitespace + "*\\\\)|)", "i"),\n\t\t\t"bool": new RegExp("^(?:" + booleans + ")$", "i"),\n\t\t\t// For use in libraries implementing .is()\n\t\t\t// We use this for POS matching in `select`\n\t\t\t"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" + whitespace + "*((?:-\\\\d)?\\\\d*)" + whitespace + "*\\\\)|)(?=[^-]|$)", "i")\n\t\t},\n\t\t    rinputs = /^(?:input|select|textarea|button)$/i,\n\t\t    rheader = /^h\\d$/i,\n\t\t    rnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\n\t\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\t\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\t\t    rsibling = /[+~]/,\n\n\n\t\t// CSS escapes\n\t\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\t\trunescape = new RegExp("\\\\\\\\([\\\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),\n\t\t    funescape = function funescape(_, escaped, escapedWhitespace) {\n\t\t\tvar high = "0x" + escaped - 0x10000;\n\t\t\t// NaN means non-codepoint\n\t\t\t// Support: Firefox<24\n\t\t\t// Workaround erroneous numeric interpretation of +"0x"\n\t\t\treturn high !== high || escapedWhitespace ? escaped : high < 0 ?\n\t\t\t// BMP codepoint\n\t\t\tString.fromCharCode(high + 0x10000) :\n\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\tString.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n\t\t},\n\n\n\t\t// CSS string/identifier serialization\n\t\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\t\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\t\t    fcssescape = function fcssescape(ch, asCodePoint) {\n\t\t\tif (asCodePoint) {\n\n\t\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\t\tif (ch === "\\0") {\n\t\t\t\t\treturn "\\uFFFD";\n\t\t\t\t}\n\n\t\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\t\treturn ch.slice(0, -1) + "\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";\n\t\t\t}\n\n\t\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\t\treturn "\\\\" + ch;\n\t\t},\n\n\n\t\t// Used for iframes\n\t\t// See setDocument()\n\t\t// Removing the function wrapper causes a "Permission Denied"\n\t\t// error in IE\n\t\tunloadHandler = function unloadHandler() {\n\t\t\tsetDocument();\n\t\t},\n\t\t    disabledAncestor = addCombinator(function (elem) {\n\t\t\treturn elem.disabled === true && ("form" in elem || "label" in elem);\n\t\t}, { dir: "parentNode", next: "legend" });\n\n\t\t// Optimize for push.apply( _, NodeList )\n\t\ttry {\n\t\t\tpush.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);\n\t\t\t// Support: Android<4.0\n\t\t\t// Detect silently failing push.apply\n\t\t\tarr[preferredDoc.childNodes.length].nodeType;\n\t\t} catch (e) {\n\t\t\tpush = { apply: arr.length ?\n\n\t\t\t\t// Leverage slice if possible\n\t\t\t\tfunction (target, els) {\n\t\t\t\t\tpush_native.apply(target, slice.call(els));\n\t\t\t\t} :\n\n\t\t\t\t// Support: IE<9\n\t\t\t\t// Otherwise append directly\n\t\t\t\tfunction (target, els) {\n\t\t\t\t\tvar j = target.length,\n\t\t\t\t\t    i = 0;\n\t\t\t\t\t// Can\'t trust NodeList.length\n\t\t\t\t\twhile (target[j++] = els[i++]) {}\n\t\t\t\t\ttarget.length = j - 1;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction Sizzle(selector, context, results, seed) {\n\t\t\tvar m,\n\t\t\t    i,\n\t\t\t    elem,\n\t\t\t    nid,\n\t\t\t    match,\n\t\t\t    groups,\n\t\t\t    newSelector,\n\t\t\t    newContext = context && context.ownerDocument,\n\n\n\t\t\t// nodeType defaults to 9, since context defaults to document\n\t\t\tnodeType = context ? context.nodeType : 9;\n\n\t\t\tresults = results || [];\n\n\t\t\t// Return early from calls with invalid selector or context\n\t\t\tif (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n\n\t\t\t\treturn results;\n\t\t\t}\n\n\t\t\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\t\t\tif (!seed) {\n\n\t\t\t\tif ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n\t\t\t\t\tsetDocument(context);\n\t\t\t\t}\n\t\t\t\tcontext = context || document;\n\n\t\t\t\tif (documentIsHTML) {\n\n\t\t\t\t\t// If the selector is sufficiently simple, try using a "get*By*" DOM method\n\t\t\t\t\t// (excepting DocumentFragment context, where the methods don\'t exist)\n\t\t\t\t\tif (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n\n\t\t\t\t\t\t// ID selector\n\t\t\t\t\t\tif (m = match[1]) {\n\n\t\t\t\t\t\t\t// Document context\n\t\t\t\t\t\t\tif (nodeType === 9) {\n\t\t\t\t\t\t\t\tif (elem = context.getElementById(m)) {\n\n\t\t\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\t\t\tif (elem.id === m) {\n\t\t\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Element context\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\t\tif (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n\n\t\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Type selector\n\t\t\t\t\t\t} else if (match[2]) {\n\t\t\t\t\t\t\tpush.apply(results, context.getElementsByTagName(selector));\n\t\t\t\t\t\t\treturn results;\n\n\t\t\t\t\t\t\t// Class selector\n\t\t\t\t\t\t} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n\n\t\t\t\t\t\t\tpush.apply(results, context.getElementsByClassName(m));\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Take advantage of querySelectorAll\n\t\t\t\t\tif (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n\n\t\t\t\t\t\tif (nodeType !== 1) {\n\t\t\t\t\t\t\tnewContext = context;\n\t\t\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t\t\t\t// Support: IE <=8\n\t\t\t\t\t\t\t// Exclude object elements\n\t\t\t\t\t\t} else if (context.nodeName.toLowerCase() !== "object") {\n\n\t\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\t\tif (nid = context.getAttribute("id")) {\n\t\t\t\t\t\t\t\tnid = nid.replace(rcssescape, fcssescape);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontext.setAttribute("id", nid = expando);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\t\t\tgroups = tokenize(selector);\n\t\t\t\t\t\t\ti = groups.length;\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tgroups[i] = "#" + nid + " " + toSelector(groups[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnewSelector = groups.join(",");\n\n\t\t\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\t\t\tnewContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (newSelector) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tpush.apply(results, newContext.querySelectorAll(newSelector));\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t} catch (qsaError) {} finally {\n\t\t\t\t\t\t\t\tif (nid === expando) {\n\t\t\t\t\t\t\t\t\tcontext.removeAttribute("id");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// All others\n\t\t\treturn select(selector.replace(rtrim, "$1"), context, results, seed);\n\t\t}\n\n\t\t/**\n   * Create key-value caches of limited size\n   * @returns {function(string, object)} Returns the Object data after storing it on itself with\n   *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n   *\tdeleting the oldest entry\n   */\n\t\tfunction createCache() {\n\t\t\tvar keys = [];\n\n\t\t\tfunction cache(key, value) {\n\t\t\t\t// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)\n\t\t\t\tif (keys.push(key + " ") > Expr.cacheLength) {\n\t\t\t\t\t// Only keep the most recent entries\n\t\t\t\t\tdelete cache[keys.shift()];\n\t\t\t\t}\n\t\t\t\treturn cache[key + " "] = value;\n\t\t\t}\n\t\t\treturn cache;\n\t\t}\n\n\t\t/**\n   * Mark a function for special use by Sizzle\n   * @param {Function} fn The function to mark\n   */\n\t\tfunction markFunction(fn) {\n\t\t\tfn[expando] = true;\n\t\t\treturn fn;\n\t\t}\n\n\t\t/**\n   * Support testing using an element\n   * @param {Function} fn Passed the created element and returns a boolean result\n   */\n\t\tfunction assert(fn) {\n\t\t\tvar el = document.createElement("fieldset");\n\n\t\t\ttry {\n\t\t\t\treturn !!fn(el);\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t} finally {\n\t\t\t\t// Remove from its parent by default\n\t\t\t\tif (el.parentNode) {\n\t\t\t\t\tel.parentNode.removeChild(el);\n\t\t\t\t}\n\t\t\t\t// release memory in IE\n\t\t\t\tel = null;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Adds the same handler for all of the specified attrs\n   * @param {String} attrs Pipe-separated list of attributes\n   * @param {Function} handler The method that will be applied\n   */\n\t\tfunction addHandle(attrs, handler) {\n\t\t\tvar arr = attrs.split("|"),\n\t\t\t    i = arr.length;\n\n\t\t\twhile (i--) {\n\t\t\t\tExpr.attrHandle[arr[i]] = handler;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Checks document order of two siblings\n   * @param {Element} a\n   * @param {Element} b\n   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n   */\n\t\tfunction siblingCheck(a, b) {\n\t\t\tvar cur = b && a,\n\t\t\t    diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;\n\n\t\t\t// Use IE sourceIndex if available on both nodes\n\t\t\tif (diff) {\n\t\t\t\treturn diff;\n\t\t\t}\n\n\t\t\t// Check if b follows a\n\t\t\tif (cur) {\n\t\t\t\twhile (cur = cur.nextSibling) {\n\t\t\t\t\tif (cur === b) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn a ? 1 : -1;\n\t\t}\n\n\t\t/**\n   * Returns a function to use in pseudos for input types\n   * @param {String} type\n   */\n\t\tfunction createInputPseudo(type) {\n\t\t\treturn function (elem) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn name === "input" && elem.type === type;\n\t\t\t};\n\t\t}\n\n\t\t/**\n   * Returns a function to use in pseudos for buttons\n   * @param {String} type\n   */\n\t\tfunction createButtonPseudo(type) {\n\t\t\treturn function (elem) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn (name === "input" || name === "button") && elem.type === type;\n\t\t\t};\n\t\t}\n\n\t\t/**\n   * Returns a function to use in pseudos for :enabled/:disabled\n   * @param {Boolean} disabled true for :disabled; false for :enabled\n   */\n\t\tfunction createDisabledPseudo(disabled) {\n\n\t\t\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\t\t\treturn function (elem) {\n\n\t\t\t\t// Only certain elements can match :enabled or :disabled\n\t\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\t\t\tif ("form" in elem) {\n\n\t\t\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t\t\t// * option elements in a disabled optgroup\n\t\t\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t\t\t// All such elements have a "form" property.\n\t\t\t\t\tif (elem.parentNode && elem.disabled === false) {\n\n\t\t\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\t\t\tif ("label" in elem) {\n\t\t\t\t\t\t\tif ("label" in elem.parentNode) {\n\t\t\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\t\telem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elem.disabled === disabled;\n\n\t\t\t\t\t// Try to winnow out elements that can\'t be disabled before trusting the disabled property.\n\t\t\t\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn\'t\n\t\t\t\t\t// even exist on them, let alone have a boolean value.\n\t\t\t\t} else if ("label" in elem) {\n\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t}\n\n\t\t\t\t// Remaining elements are neither :enabled nor :disabled\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}\n\n\t\t/**\n   * Returns a function to use in pseudos for positionals\n   * @param {Function} fn\n   */\n\t\tfunction createPositionalPseudo(fn) {\n\t\t\treturn markFunction(function (argument) {\n\t\t\t\targument = +argument;\n\t\t\t\treturn markFunction(function (seed, matches) {\n\t\t\t\t\tvar j,\n\t\t\t\t\t    matchIndexes = fn([], seed.length, argument),\n\t\t\t\t\t    i = matchIndexes.length;\n\n\t\t\t\t\t// Match elements found at the specified indexes\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (seed[j = matchIndexes[i]]) {\n\t\t\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * Checks a node for validity as a Sizzle context\n   * @param {Element|Object=} context\n   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n   */\n\t\tfunction testContext(context) {\n\t\t\treturn context && typeof context.getElementsByTagName !== "undefined" && context;\n\t\t}\n\n\t\t// Expose support vars for convenience\n\t\tsupport = Sizzle.support = {};\n\n\t\t/**\n   * Detects XML nodes\n   * @param {Element|Object} elem An element or a document\n   * @returns {Boolean} True iff elem is a non-HTML XML node\n   */\n\t\tisXML = Sizzle.isXML = function (elem) {\n\t\t\t// documentElement is verified for cases where it doesn\'t yet exist\n\t\t\t// (such as loading iframes in IE - #4833)\n\t\t\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\t\t\treturn documentElement ? documentElement.nodeName !== "HTML" : false;\n\t\t};\n\n\t\t/**\n   * Sets document-related variables once based on the current document\n   * @param {Element|Object} [doc] An element or document object to use to set the document\n   * @returns {Object} Returns the current document\n   */\n\t\tsetDocument = Sizzle.setDocument = function (node) {\n\t\t\tvar hasCompare,\n\t\t\t    subWindow,\n\t\t\t    doc = node ? node.ownerDocument || node : preferredDoc;\n\n\t\t\t// Return early if doc is invalid or already selected\n\t\t\tif (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n\t\t\t\treturn document;\n\t\t\t}\n\n\t\t\t// Update global variables\n\t\t\tdocument = doc;\n\t\t\tdocElem = document.documentElement;\n\t\t\tdocumentIsHTML = !isXML(document);\n\n\t\t\t// Support: IE 9-11, Edge\n\t\t\t// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)\n\t\t\tif (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n\n\t\t\t\t// Support: IE 11, Edge\n\t\t\t\tif (subWindow.addEventListener) {\n\t\t\t\t\tsubWindow.addEventListener("unload", unloadHandler, false);\n\n\t\t\t\t\t// Support: IE 9 - 10 only\n\t\t\t\t} else if (subWindow.attachEvent) {\n\t\t\t\t\tsubWindow.attachEvent("onunload", unloadHandler);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Attributes\n   ---------------------------------------------------------------------- */\n\n\t\t\t// Support: IE<8\n\t\t\t// Verify that getAttribute really returns attributes and not properties\n\t\t\t// (excepting IE8 booleans)\n\t\t\tsupport.attributes = assert(function (el) {\n\t\t\t\tel.className = "i";\n\t\t\t\treturn !el.getAttribute("className");\n\t\t\t});\n\n\t\t\t/* getElement(s)By*\n   ---------------------------------------------------------------------- */\n\n\t\t\t// Check if getElementsByTagName("*") returns only elements\n\t\t\tsupport.getElementsByTagName = assert(function (el) {\n\t\t\t\tel.appendChild(document.createComment(""));\n\t\t\t\treturn !el.getElementsByTagName("*").length;\n\t\t\t});\n\n\t\t\t// Support: IE<9\n\t\t\tsupport.getElementsByClassName = rnative.test(document.getElementsByClassName);\n\n\t\t\t// Support: IE<10\n\t\t\t// Check if getElementById returns elements by name\n\t\t\t// The broken getElementById methods don\'t pick up programmatically-set names,\n\t\t\t// so use a roundabout getElementsByName test\n\t\t\tsupport.getById = assert(function (el) {\n\t\t\t\tdocElem.appendChild(el).id = expando;\n\t\t\t\treturn !document.getElementsByName || !document.getElementsByName(expando).length;\n\t\t\t});\n\n\t\t\t// ID filter and find\n\t\t\tif (support.getById) {\n\t\t\t\tExpr.filter["ID"] = function (id) {\n\t\t\t\t\tvar attrId = id.replace(runescape, funescape);\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\treturn elem.getAttribute("id") === attrId;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tExpr.find["ID"] = function (id, context) {\n\t\t\t\t\tif (typeof context.getElementById !== "undefined" && documentIsHTML) {\n\t\t\t\t\t\tvar elem = context.getElementById(id);\n\t\t\t\t\t\treturn elem ? [elem] : [];\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tExpr.filter["ID"] = function (id) {\n\t\t\t\t\tvar attrId = id.replace(runescape, funescape);\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\tvar node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");\n\t\t\t\t\t\treturn node && node.value === attrId;\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Support: IE 6 - 7 only\n\t\t\t\t// getElementById is not reliable as a find shortcut\n\t\t\t\tExpr.find["ID"] = function (id, context) {\n\t\t\t\t\tif (typeof context.getElementById !== "undefined" && documentIsHTML) {\n\t\t\t\t\t\tvar node,\n\t\t\t\t\t\t    i,\n\t\t\t\t\t\t    elems,\n\t\t\t\t\t\t    elem = context.getElementById(id);\n\n\t\t\t\t\t\tif (elem) {\n\n\t\t\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\t\t\tnode = elem.getAttributeNode("id");\n\t\t\t\t\t\t\tif (node && node.value === id) {\n\t\t\t\t\t\t\t\treturn [elem];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\t\t\telems = context.getElementsByName(id);\n\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\t\twhile (elem = elems[i++]) {\n\t\t\t\t\t\t\t\tnode = elem.getAttributeNode("id");\n\t\t\t\t\t\t\t\tif (node && node.value === id) {\n\t\t\t\t\t\t\t\t\treturn [elem];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Tag\n\t\t\tExpr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {\n\t\t\t\tif (typeof context.getElementsByTagName !== "undefined") {\n\t\t\t\t\treturn context.getElementsByTagName(tag);\n\n\t\t\t\t\t// DocumentFragment nodes don\'t have gEBTN\n\t\t\t\t} else if (support.qsa) {\n\t\t\t\t\treturn context.querySelectorAll(tag);\n\t\t\t\t}\n\t\t\t} : function (tag, context) {\n\t\t\t\tvar elem,\n\t\t\t\t    tmp = [],\n\t\t\t\t    i = 0,\n\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName(tag);\n\n\t\t\t\t// Filter out possible comments\n\t\t\t\tif (tag === "*") {\n\t\t\t\t\twhile (elem = results[i++]) {\n\t\t\t\t\t\tif (elem.nodeType === 1) {\n\t\t\t\t\t\t\ttmp.push(elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tmp;\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\n\t\t\t// Class\n\t\t\tExpr.find["CLASS"] = support.getElementsByClassName && function (className, context) {\n\t\t\t\tif (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {\n\t\t\t\t\treturn context.getElementsByClassName(className);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/* QSA/matchesSelector\n   ---------------------------------------------------------------------- */\n\n\t\t\t// QSA and matchesSelector support\n\n\t\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\t\t\trbuggyMatches = [];\n\n\t\t\t// qSa(:focus) reports false when true (Chrome 21)\n\t\t\t// We allow this because of a bug in IE8/9 that throws an error\n\t\t\t// whenever `document.activeElement` is accessed on an iframe\n\t\t\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t\t\t// See https://bugs.jquery.com/ticket/13378\n\t\t\trbuggyQSA = [];\n\n\t\t\tif (support.qsa = rnative.test(document.querySelectorAll)) {\n\t\t\t\t// Build QSA regex\n\t\t\t\t// Regex strategy adopted from Diego Perini\n\t\t\t\tassert(function (el) {\n\t\t\t\t\t// Select is set to empty string on purpose\n\t\t\t\t\t// This is to test IE\'s treatment of not explicitly\n\t\t\t\t\t// setting a boolean content attribute,\n\t\t\t\t\t// since its presence should be enough\n\t\t\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\t\t\tdocElem.appendChild(el).innerHTML = "<a id=\'" + expando + "\'></a>" + "<select id=\'" + expando + "-\\r\\\\\' msallowcapture=\'\'>" + "<option selected=\'\'></option></select>";\n\n\t\t\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t\t\t// The test attribute must be unknown in Opera but "safe" for WinRT\n\t\t\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\t\t\tif (el.querySelectorAll("[msallowcapture^=\'\']").length) {\n\t\t\t\t\t\trbuggyQSA.push("[*^$]=" + whitespace + "*(?:\'\'|\\"\\")");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: IE8\n\t\t\t\t\t// Boolean attributes and "value" are not treated correctly\n\t\t\t\t\tif (!el.querySelectorAll("[selected]").length) {\n\t\t\t\t\t\trbuggyQSA.push("\\\\[" + whitespace + "*(?:value|" + booleans + ")");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\t\t\tif (!el.querySelectorAll("[id~=" + expando + "-]").length) {\n\t\t\t\t\t\trbuggyQSA.push("~=");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\t\tif (!el.querySelectorAll(":checked").length) {\n\t\t\t\t\t\trbuggyQSA.push(":checked");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\t\t\tif (!el.querySelectorAll("a#" + expando + "+*").length) {\n\t\t\t\t\t\trbuggyQSA.push(".#.+[+~]");\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tassert(function (el) {\n\t\t\t\t\tel.innerHTML = "<a href=\'\' disabled=\'disabled\'></a>" + "<select disabled=\'disabled\'><option/></select>";\n\n\t\t\t\t\t// Support: Windows 8 Native Apps\n\t\t\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\t\t\tvar input = document.createElement("input");\n\t\t\t\t\tinput.setAttribute("type", "hidden");\n\t\t\t\t\tel.appendChild(input).setAttribute("name", "D");\n\n\t\t\t\t\t// Support: IE8\n\t\t\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\t\t\tif (el.querySelectorAll("[name=d]").length) {\n\t\t\t\t\t\trbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");\n\t\t\t\t\t}\n\n\t\t\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\t\tif (el.querySelectorAll(":enabled").length !== 2) {\n\t\t\t\t\t\trbuggyQSA.push(":enabled", ":disabled");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: IE9-11+\n\t\t\t\t\t// IE\'s :disabled selector does not pick up the children of disabled fieldsets\n\t\t\t\t\tdocElem.appendChild(el).disabled = true;\n\t\t\t\t\tif (el.querySelectorAll(":disabled").length !== 2) {\n\t\t\t\t\t\trbuggyQSA.push(":enabled", ":disabled");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\t\t\tel.querySelectorAll("*,:x");\n\t\t\t\t\trbuggyQSA.push(",.*:");\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n\n\t\t\t\tassert(function (el) {\n\t\t\t\t\t// Check to see if it\'s possible to do matchesSelector\n\t\t\t\t\t// on a disconnected node (IE 9)\n\t\t\t\t\tsupport.disconnectedMatch = matches.call(el, "*");\n\n\t\t\t\t\t// This should fail with an exception\n\t\t\t\t\t// Gecko does not error, returns false instead\n\t\t\t\t\tmatches.call(el, "[s!=\'\']:x");\n\t\t\t\t\trbuggyMatches.push("!=", pseudos);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\trbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));\n\t\t\trbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));\n\n\t\t\t/* Contains\n   ---------------------------------------------------------------------- */\n\t\t\thasCompare = rnative.test(docElem.compareDocumentPosition);\n\n\t\t\t// Element contains another\n\t\t\t// Purposefully self-exclusive\n\t\t\t// As in, an element does not contain itself\n\t\t\tcontains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n\t\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\t    bup = b && b.parentNode;\n\t\t\t\treturn a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n\t\t\t} : function (a, b) {\n\t\t\t\tif (b) {\n\t\t\t\t\twhile (b = b.parentNode) {\n\t\t\t\t\t\tif (b === a) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\n\t\t\t/* Sorting\n   ---------------------------------------------------------------------- */\n\n\t\t\t// Document order sorting\n\t\t\tsortOrder = hasCompare ? function (a, b) {\n\n\t\t\t\t// Flag for duplicate removal\n\t\t\t\tif (a === b) {\n\t\t\t\t\thasDuplicate = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\t\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\t\t\tif (compare) {\n\t\t\t\t\treturn compare;\n\t\t\t\t}\n\n\t\t\t\t// Calculate position if both inputs belong to the same document\n\t\t\t\tcompare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :\n\n\t\t\t\t// Otherwise we know they are disconnected\n\t\t\t\t1;\n\n\t\t\t\t// Disconnected nodes\n\t\t\t\tif (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n\n\t\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\t\tif (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Maintain original order\n\t\t\t\t\treturn sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n\t\t\t\t}\n\n\t\t\t\treturn compare & 4 ? -1 : 1;\n\t\t\t} : function (a, b) {\n\t\t\t\t// Exit early if the nodes are identical\n\t\t\t\tif (a === b) {\n\t\t\t\t\thasDuplicate = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tvar cur,\n\t\t\t\t    i = 0,\n\t\t\t\t    aup = a.parentNode,\n\t\t\t\t    bup = b.parentNode,\n\t\t\t\t    ap = [a],\n\t\t\t\t    bp = [b];\n\n\t\t\t\t// Parentless nodes are either documents or disconnected\n\t\t\t\tif (!aup || !bup) {\n\t\t\t\t\treturn a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n\n\t\t\t\t\t// If the nodes are siblings, we can do a quick check\n\t\t\t\t} else if (aup === bup) {\n\t\t\t\t\treturn siblingCheck(a, b);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\t\t\tcur = a;\n\t\t\t\twhile (cur = cur.parentNode) {\n\t\t\t\t\tap.unshift(cur);\n\t\t\t\t}\n\t\t\t\tcur = b;\n\t\t\t\twhile (cur = cur.parentNode) {\n\t\t\t\t\tbp.unshift(cur);\n\t\t\t\t}\n\n\t\t\t\t// Walk down the tree looking for a discrepancy\n\t\t\t\twhile (ap[i] === bp[i]) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\treturn i ?\n\t\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\t\tsiblingCheck(ap[i], bp[i]) :\n\n\t\t\t\t// Otherwise nodes in our document sort first\n\t\t\t\tap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n\t\t\t};\n\n\t\t\treturn document;\n\t\t};\n\n\t\tSizzle.matches = function (expr, elements) {\n\t\t\treturn Sizzle(expr, null, null, elements);\n\t\t};\n\n\t\tSizzle.matchesSelector = function (elem, expr) {\n\t\t\t// Set document vars if needed\n\t\t\tif ((elem.ownerDocument || elem) !== document) {\n\t\t\t\tsetDocument(elem);\n\t\t\t}\n\n\t\t\t// Make sure that attribute selectors are quoted\n\t\t\texpr = expr.replace(rattributeQuotes, "=\'$1\']");\n\n\t\t\tif (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n\n\t\t\t\ttry {\n\t\t\t\t\tvar ret = matches.call(elem, expr);\n\n\t\t\t\t\t// IE 9\'s matchesSelector returns false on disconnected nodes\n\t\t\t\t\tif (ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\n\t\t\treturn Sizzle(expr, document, null, [elem]).length > 0;\n\t\t};\n\n\t\tSizzle.contains = function (context, elem) {\n\t\t\t// Set document vars if needed\n\t\t\tif ((context.ownerDocument || context) !== document) {\n\t\t\t\tsetDocument(context);\n\t\t\t}\n\t\t\treturn contains(context, elem);\n\t\t};\n\n\t\tSizzle.attr = function (elem, name) {\n\t\t\t// Set document vars if needed\n\t\t\tif ((elem.ownerDocument || elem) !== document) {\n\t\t\t\tsetDocument(elem);\n\t\t\t}\n\n\t\t\tvar fn = Expr.attrHandle[name.toLowerCase()],\n\n\t\t\t// Don\'t get fooled by Object.prototype properties (jQuery #13807)\n\t\t\tval = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n\n\t\t\treturn val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n\t\t};\n\n\t\tSizzle.escape = function (sel) {\n\t\t\treturn (sel + "").replace(rcssescape, fcssescape);\n\t\t};\n\n\t\tSizzle.error = function (msg) {\n\t\t\tthrow new Error("Syntax error, unrecognized expression: " + msg);\n\t\t};\n\n\t\t/**\n   * Document sorting and removing duplicates\n   * @param {ArrayLike} results\n   */\n\t\tSizzle.uniqueSort = function (results) {\n\t\t\tvar elem,\n\t\t\t    duplicates = [],\n\t\t\t    j = 0,\n\t\t\t    i = 0;\n\n\t\t\t// Unless we *know* we can detect duplicates, assume their presence\n\t\t\thasDuplicate = !support.detectDuplicates;\n\t\t\tsortInput = !support.sortStable && results.slice(0);\n\t\t\tresults.sort(sortOrder);\n\n\t\t\tif (hasDuplicate) {\n\t\t\t\twhile (elem = results[i++]) {\n\t\t\t\t\tif (elem === results[i]) {\n\t\t\t\t\t\tj = duplicates.push(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (j--) {\n\t\t\t\t\tresults.splice(duplicates[j], 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear input after sorting to release objects\n\t\t\t// See https://github.com/jquery/sizzle/pull/225\n\t\t\tsortInput = null;\n\n\t\t\treturn results;\n\t\t};\n\n\t\t/**\n   * Utility function for retrieving the text value of an array of DOM nodes\n   * @param {Array|Element} elem\n   */\n\t\tgetText = Sizzle.getText = function (elem) {\n\t\t\tvar node,\n\t\t\t    ret = "",\n\t\t\t    i = 0,\n\t\t\t    nodeType = elem.nodeType;\n\n\t\t\tif (!nodeType) {\n\t\t\t\t// If no nodeType, this is expected to be an array\n\t\t\t\twhile (node = elem[i++]) {\n\t\t\t\t\t// Do not traverse comment nodes\n\t\t\t\t\tret += getText(node);\n\t\t\t\t}\n\t\t\t} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n\t\t\t\t// Use textContent for elements\n\t\t\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\t\t\tif (typeof elem.textContent === "string") {\n\t\t\t\t\treturn elem.textContent;\n\t\t\t\t} else {\n\t\t\t\t\t// Traverse its children\n\t\t\t\t\tfor (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n\t\t\t\t\t\tret += getText(elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (nodeType === 3 || nodeType === 4) {\n\t\t\t\treturn elem.nodeValue;\n\t\t\t}\n\t\t\t// Do not include comment or processing instruction nodes\n\n\t\t\treturn ret;\n\t\t};\n\n\t\tExpr = Sizzle.selectors = {\n\n\t\t\t// Can be adjusted by the user\n\t\t\tcacheLength: 50,\n\n\t\t\tcreatePseudo: markFunction,\n\n\t\t\tmatch: matchExpr,\n\n\t\t\tattrHandle: {},\n\n\t\t\tfind: {},\n\n\t\t\trelative: {\n\t\t\t\t">": { dir: "parentNode", first: true },\n\t\t\t\t" ": { dir: "parentNode" },\n\t\t\t\t"+": { dir: "previousSibling", first: true },\n\t\t\t\t"~": { dir: "previousSibling" }\n\t\t\t},\n\n\t\t\tpreFilter: {\n\t\t\t\t"ATTR": function ATTR(match) {\n\t\t\t\t\tmatch[1] = match[1].replace(runescape, funescape);\n\n\t\t\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\t\t\tmatch[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);\n\n\t\t\t\t\tif (match[2] === "~=") {\n\t\t\t\t\t\tmatch[3] = " " + match[3] + " ";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn match.slice(0, 4);\n\t\t\t\t},\n\n\t\t\t\t"CHILD": function CHILD(match) {\n\t\t\t\t\t/* matches from matchExpr["CHILD"]\n     \t1 type (only|nth|...)\n     \t2 what (child|of-type)\n     \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n     \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n     \t5 sign of xn-component\n     \t6 x of xn-component\n     \t7 sign of y-component\n     \t8 y of y-component\n     */\n\t\t\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\t\t\tif (match[1].slice(0, 3) === "nth") {\n\t\t\t\t\t\t// nth-* requires argument\n\t\t\t\t\t\tif (!match[3]) {\n\t\t\t\t\t\t\tSizzle.error(match[0]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\t\t\tmatch[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));\n\t\t\t\t\t\tmatch[5] = +(match[7] + match[8] || match[3] === "odd");\n\n\t\t\t\t\t\t// other types prohibit arguments\n\t\t\t\t\t} else if (match[3]) {\n\t\t\t\t\t\tSizzle.error(match[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn match;\n\t\t\t\t},\n\n\t\t\t\t"PSEUDO": function PSEUDO(match) {\n\t\t\t\t\tvar excess,\n\t\t\t\t\t    unquoted = !match[6] && match[2];\n\n\t\t\t\t\tif (matchExpr["CHILD"].test(match[0])) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Accept quoted arguments as-is\n\t\t\t\t\tif (match[3]) {\n\t\t\t\t\t\tmatch[2] = match[4] || match[5] || "";\n\n\t\t\t\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t\t\t} else if (unquoted && rpseudo.test(unquoted) && (\n\t\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t\texcess = tokenize(unquoted, true)) && (\n\t\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t\texcess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {\n\n\t\t\t\t\t\t// excess is a negative index\n\t\t\t\t\t\tmatch[0] = match[0].slice(0, excess);\n\t\t\t\t\t\tmatch[2] = unquoted.slice(0, excess);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\t\t\treturn match.slice(0, 3);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tfilter: {\n\n\t\t\t\t"TAG": function TAG(nodeNameSelector) {\n\t\t\t\t\tvar nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n\t\t\t\t\treturn nodeNameSelector === "*" ? function () {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} : function (elem) {\n\t\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t"CLASS": function CLASS(className) {\n\t\t\t\t\tvar pattern = classCache[className + " "];\n\n\t\t\t\t\treturn pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {\n\t\t\t\t\t\treturn pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\t"ATTR": function ATTR(name, operator, check) {\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\tvar result = Sizzle.attr(elem, name);\n\n\t\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\t\treturn operator === "!=";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!operator) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult += "";\n\n\t\t\t\t\t\treturn operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t"CHILD": function CHILD(type, what, argument, first, last) {\n\t\t\t\t\tvar simple = type.slice(0, 3) !== "nth",\n\t\t\t\t\t    forward = type.slice(-4) !== "last",\n\t\t\t\t\t    ofType = what === "of-type";\n\n\t\t\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\t\tfunction (elem) {\n\t\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t\t} : function (elem, context, xml) {\n\t\t\t\t\t\tvar cache,\n\t\t\t\t\t\t    uniqueCache,\n\t\t\t\t\t\t    outerCache,\n\t\t\t\t\t\t    node,\n\t\t\t\t\t\t    nodeIndex,\n\t\t\t\t\t\t    start,\n\t\t\t\t\t\t    dir = simple !== forward ? "nextSibling" : "previousSibling",\n\t\t\t\t\t\t    parent = elem.parentNode,\n\t\t\t\t\t\t    name = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\t    useCache = !xml && !ofType,\n\t\t\t\t\t\t    diff = false;\n\n\t\t\t\t\t\tif (parent) {\n\n\t\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\t\tif (simple) {\n\t\t\t\t\t\t\t\twhile (dir) {\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\twhile (node = node[dir]) {\n\t\t\t\t\t\t\t\t\t\tif (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven\'t yet done so)\n\t\t\t\t\t\t\t\t\tstart = dir = type === "only" && !start && "nextSibling";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstart = [forward ? parent.firstChild : parent.lastChild];\n\n\t\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\t\tif (forward && useCache) {\n\n\t\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[type] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\t\tdiff = nodeIndex && cache[2];\n\t\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[nodeIndex];\n\n\t\t\t\t\t\t\t\twhile (node = ++nodeIndex && node && node[dir] || (\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\tdiff = nodeIndex = 0) || start.pop()) {\n\n\t\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\t\tif (node.nodeType === 1 && ++diff && node === elem) {\n\t\t\t\t\t\t\t\t\t\tuniqueCache[type] = [dirruns, nodeIndex, diff];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\t\tif (useCache) {\n\t\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {});\n\n\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n\t\t\t\t\t\t\t\t\tcache = uniqueCache[type] || [];\n\t\t\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\t\tif (diff === false) {\n\t\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\t\twhile (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n\n\t\t\t\t\t\t\t\t\t\tif ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n\n\t\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\t\tif (useCache) {\n\t\t\t\t\t\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t\tuniqueCache[type] = [dirruns, diff];\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (node === elem) {\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\t\treturn diff === first || diff % first === 0 && diff / first >= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t"PSEUDO": function PSEUDO(pseudo, argument) {\n\t\t\t\t\t// pseudo-class names are case-insensitive\n\t\t\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\t\t\tvar args,\n\t\t\t\t\t    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);\n\n\t\t\t\t\t// The user may use createPseudo to indicate that\n\t\t\t\t\t// arguments are needed to create the filter function\n\t\t\t\t\t// just as Sizzle does\n\t\t\t\t\tif (fn[expando]) {\n\t\t\t\t\t\treturn fn(argument);\n\t\t\t\t\t}\n\n\t\t\t\t\t// But maintain support for old signatures\n\t\t\t\t\tif (fn.length > 1) {\n\t\t\t\t\t\targs = [pseudo, pseudo, "", argument];\n\t\t\t\t\t\treturn Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n\t\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\t    matched = fn(seed, argument),\n\t\t\t\t\t\t\t    i = matched.length;\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tidx = indexOf(seed, matched[i]);\n\t\t\t\t\t\t\t\tseed[idx] = !(matches[idx] = matched[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}) : function (elem) {\n\t\t\t\t\t\t\treturn fn(elem, 0, args);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fn;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tpseudos: {\n\t\t\t\t// Potentially complex pseudos\n\t\t\t\t"not": markFunction(function (selector) {\n\t\t\t\t\t// Trim the selector passed to compile\n\t\t\t\t\t// to avoid treating leading and trailing\n\t\t\t\t\t// spaces as combinators\n\t\t\t\t\tvar input = [],\n\t\t\t\t\t    results = [],\n\t\t\t\t\t    matcher = compile(selector.replace(rtrim, "$1"));\n\n\t\t\t\t\treturn matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n\t\t\t\t\t\tvar elem,\n\t\t\t\t\t\t    unmatched = matcher(seed, null, xml, []),\n\t\t\t\t\t\t    i = seed.length;\n\n\t\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (elem = unmatched[i]) {\n\t\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}) : function (elem, context, xml) {\n\t\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\t\tmatcher(input, null, xml, results);\n\t\t\t\t\t\t// Don\'t keep the element (issue #299)\n\t\t\t\t\t\tinput[0] = null;\n\t\t\t\t\t\treturn !results.pop();\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t"has": markFunction(function (selector) {\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\treturn Sizzle(selector, elem).length > 0;\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t"contains": markFunction(function (text) {\n\t\t\t\t\ttext = text.replace(runescape, funescape);\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\treturn (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t// "Whether an element is represented by a :lang() selector\n\t\t\t\t// is based solely on the element\'s language value\n\t\t\t\t// being equal to the identifier C,\n\t\t\t\t// or beginning with the identifier C immediately followed by "-".\n\t\t\t\t// The matching of C against the element\'s language value is performed case-insensitively.\n\t\t\t\t// The identifier C does not have to be a valid language name."\n\t\t\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\t\t"lang": markFunction(function (lang) {\n\t\t\t\t\t// lang value must be a valid identifier\n\t\t\t\t\tif (!ridentifier.test(lang || "")) {\n\t\t\t\t\t\tSizzle.error("unsupported lang: " + lang);\n\t\t\t\t\t}\n\t\t\t\t\tlang = lang.replace(runescape, funescape).toLowerCase();\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\tvar elemLang;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {\n\n\t\t\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf(lang + "-") === 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while ((elem = elem.parentNode) && elem.nodeType === 1);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t// Miscellaneous\n\t\t\t\t"target": function target(elem) {\n\t\t\t\t\tvar hash = window.location && window.location.hash;\n\t\t\t\t\treturn hash && hash.slice(1) === elem.id;\n\t\t\t\t},\n\n\t\t\t\t"root": function root(elem) {\n\t\t\t\t\treturn elem === docElem;\n\t\t\t\t},\n\n\t\t\t\t"focus": function focus(elem) {\n\t\t\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t\t\t},\n\n\t\t\t\t// Boolean properties\n\t\t\t\t"enabled": createDisabledPseudo(false),\n\t\t\t\t"disabled": createDisabledPseudo(true),\n\n\t\t\t\t"checked": function checked(elem) {\n\t\t\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\t\t\treturn nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;\n\t\t\t\t},\n\n\t\t\t\t"selected": function selected(elem) {\n\t\t\t\t\t// Accessing this property makes selected-by-default\n\t\t\t\t\t// options in Safari work properly\n\t\t\t\t\tif (elem.parentNode) {\n\t\t\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elem.selected === true;\n\t\t\t\t},\n\n\t\t\t\t// Contents\n\t\t\t\t"empty": function empty(elem) {\n\t\t\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\t\t\tfor (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n\t\t\t\t\t\tif (elem.nodeType < 6) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t"parent": function parent(elem) {\n\t\t\t\t\treturn !Expr.pseudos["empty"](elem);\n\t\t\t\t},\n\n\t\t\t\t// Element/input types\n\t\t\t\t"header": function header(elem) {\n\t\t\t\t\treturn rheader.test(elem.nodeName);\n\t\t\t\t},\n\n\t\t\t\t"input": function input(elem) {\n\t\t\t\t\treturn rinputs.test(elem.nodeName);\n\t\t\t\t},\n\n\t\t\t\t"button": function button(elem) {\n\t\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\t\treturn name === "input" && elem.type === "button" || name === "button";\n\t\t\t\t},\n\n\t\t\t\t"text": function text(elem) {\n\t\t\t\t\tvar attr;\n\t\t\t\t\treturn elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (\n\n\t\t\t\t\t// Support: IE<8\n\t\t\t\t\t// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"\n\t\t\t\t\t(attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");\n\t\t\t\t},\n\n\t\t\t\t// Position-in-collection\n\t\t\t\t"first": createPositionalPseudo(function () {\n\t\t\t\t\treturn [0];\n\t\t\t\t}),\n\n\t\t\t\t"last": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\t\treturn [length - 1];\n\t\t\t\t}),\n\n\t\t\t\t"eq": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\t\treturn [argument < 0 ? argument + length : argument];\n\t\t\t\t}),\n\n\t\t\t\t"even": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\t\tvar i = 0;\n\t\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t}),\n\n\t\t\t\t"odd": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\t\tvar i = 1;\n\t\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t}),\n\n\t\t\t\t"lt": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\t\tfor (; --i >= 0;) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t}),\n\n\t\t\t\t"gt": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\t\tfor (; ++i < length;) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t})\n\t\t\t}\n\t\t};\n\n\t\tExpr.pseudos["nth"] = Expr.pseudos["eq"];\n\n\t\t// Add button/input type pseudos\n\t\tfor (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {\n\t\t\tExpr.pseudos[i] = createInputPseudo(i);\n\t\t}\n\t\tfor (i in { submit: true, reset: true }) {\n\t\t\tExpr.pseudos[i] = createButtonPseudo(i);\n\t\t}\n\n\t\t// Easy API for creating new setFilters\n\t\tfunction setFilters() {}\n\t\tsetFilters.prototype = Expr.filters = Expr.pseudos;\n\t\tExpr.setFilters = new setFilters();\n\n\t\ttokenize = Sizzle.tokenize = function (selector, parseOnly) {\n\t\t\tvar matched,\n\t\t\t    match,\n\t\t\t    tokens,\n\t\t\t    type,\n\t\t\t    soFar,\n\t\t\t    groups,\n\t\t\t    preFilters,\n\t\t\t    cached = tokenCache[selector + " "];\n\n\t\t\tif (cached) {\n\t\t\t\treturn parseOnly ? 0 : cached.slice(0);\n\t\t\t}\n\n\t\t\tsoFar = selector;\n\t\t\tgroups = [];\n\t\t\tpreFilters = Expr.preFilter;\n\n\t\t\twhile (soFar) {\n\n\t\t\t\t// Comma and first run\n\t\t\t\tif (!matched || (match = rcomma.exec(soFar))) {\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\t// Don\'t consume trailing commas as valid\n\t\t\t\t\t\tsoFar = soFar.slice(match[0].length) || soFar;\n\t\t\t\t\t}\n\t\t\t\t\tgroups.push(tokens = []);\n\t\t\t\t}\n\n\t\t\t\tmatched = false;\n\n\t\t\t\t// Combinators\n\t\t\t\tif (match = rcombinators.exec(soFar)) {\n\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\ttokens.push({\n\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\t// Cast descendant combinators to space\n\t\t\t\t\t\ttype: match[0].replace(rtrim, " ")\n\t\t\t\t\t});\n\t\t\t\t\tsoFar = soFar.slice(matched.length);\n\t\t\t\t}\n\n\t\t\t\t// Filters\n\t\t\t\tfor (type in Expr.filter) {\n\t\t\t\t\tif ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n\t\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\t\ttokens.push({\n\t\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\t\tmatches: match\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsoFar = soFar.slice(matched.length);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!matched) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return the length of the invalid excess\n\t\t\t// if we\'re just parsing\n\t\t\t// Otherwise, throw an error or return tokens\n\t\t\treturn parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache(selector, groups).slice(0);\n\t\t};\n\n\t\tfunction toSelector(tokens) {\n\t\t\tvar i = 0,\n\t\t\t    len = tokens.length,\n\t\t\t    selector = "";\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tselector += tokens[i].value;\n\t\t\t}\n\t\t\treturn selector;\n\t\t}\n\n\t\tfunction addCombinator(matcher, combinator, base) {\n\t\t\tvar dir = combinator.dir,\n\t\t\t    skip = combinator.next,\n\t\t\t    key = skip || dir,\n\t\t\t    checkNonElements = base && key === "parentNode",\n\t\t\t    doneName = done++;\n\n\t\t\treturn combinator.first ?\n\t\t\t// Check against closest ancestor/preceding element\n\t\t\tfunction (elem, context, xml) {\n\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\treturn matcher(elem, context, xml);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} :\n\n\t\t\t// Check against all ancestor/preceding elements\n\t\t\tfunction (elem, context, xml) {\n\t\t\t\tvar oldCache,\n\t\t\t\t    uniqueCache,\n\t\t\t\t    outerCache,\n\t\t\t\t    newCache = [dirruns, doneName];\n\n\t\t\t\t// We can\'t set arbitrary data on XML nodes, so they don\'t benefit from combinator caching\n\t\t\t\tif (xml) {\n\t\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\t\tif (matcher(elem, context, xml)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\t\touterCache = elem[expando] || (elem[expando] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n\t\t\t\t\t\t\tif (skip && skip === elem.nodeName.toLowerCase()) {\n\t\t\t\t\t\t\t\telem = elem[dir] || elem;\n\t\t\t\t\t\t\t} else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n\n\t\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\treturn newCache[2] = oldCache[2];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\tuniqueCache[key] = newCache;\n\n\t\t\t\t\t\t\t\t// A match means we\'re done; a fail means we have to keep checking\n\t\t\t\t\t\t\t\tif (newCache[2] = matcher(elem, context, xml)) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}\n\n\t\tfunction elementMatcher(matchers) {\n\t\t\treturn matchers.length > 1 ? function (elem, context, xml) {\n\t\t\t\tvar i = matchers.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (!matchers[i](elem, context, xml)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} : matchers[0];\n\t\t}\n\n\t\tfunction multipleContexts(selector, contexts, results) {\n\t\t\tvar i = 0,\n\t\t\t    len = contexts.length;\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tSizzle(selector, contexts[i], results);\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\n\t\tfunction condense(unmatched, map, filter, context, xml) {\n\t\t\tvar elem,\n\t\t\t    newUnmatched = [],\n\t\t\t    i = 0,\n\t\t\t    len = unmatched.length,\n\t\t\t    mapped = map != null;\n\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tif (elem = unmatched[i]) {\n\t\t\t\t\tif (!filter || filter(elem, context, xml)) {\n\t\t\t\t\t\tnewUnmatched.push(elem);\n\t\t\t\t\t\tif (mapped) {\n\t\t\t\t\t\t\tmap.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newUnmatched;\n\t\t}\n\n\t\tfunction setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n\t\t\tif (postFilter && !postFilter[expando]) {\n\t\t\t\tpostFilter = setMatcher(postFilter);\n\t\t\t}\n\t\t\tif (postFinder && !postFinder[expando]) {\n\t\t\t\tpostFinder = setMatcher(postFinder, postSelector);\n\t\t\t}\n\t\t\treturn markFunction(function (seed, results, context, xml) {\n\t\t\t\tvar temp,\n\t\t\t\t    i,\n\t\t\t\t    elem,\n\t\t\t\t    preMap = [],\n\t\t\t\t    postMap = [],\n\t\t\t\t    preexisting = results.length,\n\n\n\t\t\t\t// Get initial elements from seed or context\n\t\t\t\telems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),\n\n\n\t\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\t\tmatcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n\t\t\t\t    matcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || (seed ? preFilter : preexisting || postFilter) ?\n\n\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t[] :\n\n\t\t\t\t// ...otherwise use results directly\n\t\t\t\tresults : matcherIn;\n\n\t\t\t\t// Find primary matches\n\t\t\t\tif (matcher) {\n\t\t\t\t\tmatcher(matcherIn, matcherOut, context, xml);\n\t\t\t\t}\n\n\t\t\t\t// Apply postFilter\n\t\t\t\tif (postFilter) {\n\t\t\t\t\ttemp = condense(matcherOut, postMap);\n\t\t\t\t\tpostFilter(temp, [], context, xml);\n\n\t\t\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\t\t\ti = temp.length;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (elem = temp[i]) {\n\t\t\t\t\t\t\tmatcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (seed) {\n\t\t\t\t\tif (postFinder || preFilter) {\n\t\t\t\t\t\tif (postFinder) {\n\t\t\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\t\t\ttemp = [];\n\t\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tif (elem = matcherOut[i]) {\n\t\t\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\t\t\ttemp.push(matcherIn[i] = elem);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpostFinder(null, matcherOut = [], temp, xml);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n\n\t\t\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add elements to results, through postFinder if defined\n\t\t\t\t} else {\n\t\t\t\t\tmatcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\t\t\t\t\tif (postFinder) {\n\t\t\t\t\t\tpostFinder(null, results, matcherOut, xml);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpush.apply(results, matcherOut);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfunction matcherFromTokens(tokens) {\n\t\t\tvar checkContext,\n\t\t\t    matcher,\n\t\t\t    j,\n\t\t\t    len = tokens.length,\n\t\t\t    leadingRelative = Expr.relative[tokens[0].type],\n\t\t\t    implicitRelative = leadingRelative || Expr.relative[" "],\n\t\t\t    i = leadingRelative ? 1 : 0,\n\n\n\t\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\t\tmatchContext = addCombinator(function (elem) {\n\t\t\t\treturn elem === checkContext;\n\t\t\t}, implicitRelative, true),\n\t\t\t    matchAnyContext = addCombinator(function (elem) {\n\t\t\t\treturn indexOf(checkContext, elem) > -1;\n\t\t\t}, implicitRelative, true),\n\t\t\t    matchers = [function (elem, context, xml) {\n\t\t\t\tvar ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));\n\t\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\t\tcheckContext = null;\n\t\t\t\treturn ret;\n\t\t\t}];\n\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tif (matcher = Expr.relative[tokens[i].type]) {\n\t\t\t\t\tmatchers = [addCombinator(elementMatcher(matchers), matcher)];\n\t\t\t\t} else {\n\t\t\t\t\tmatcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\n\n\t\t\t\t\t// Return special upon seeing a positional matcher\n\t\t\t\t\tif (matcher[expando]) {\n\t\t\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\t\t\tj = ++i;\n\t\t\t\t\t\tfor (; j < len; j++) {\n\t\t\t\t\t\t\tif (Expr.relative[tokens[j].type]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === " " ? "*" : "" })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n\t\t\t\t\t}\n\t\t\t\t\tmatchers.push(matcher);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn elementMatcher(matchers);\n\t\t}\n\n\t\tfunction matcherFromGroupMatchers(elementMatchers, setMatchers) {\n\t\t\tvar bySet = setMatchers.length > 0,\n\t\t\t    byElement = elementMatchers.length > 0,\n\t\t\t    superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n\t\t\t\tvar elem,\n\t\t\t\t    j,\n\t\t\t\t    matcher,\n\t\t\t\t    matchedCount = 0,\n\t\t\t\t    i = "0",\n\t\t\t\t    unmatched = seed && [],\n\t\t\t\t    setMatched = [],\n\t\t\t\t    contextBackup = outermostContext,\n\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find["TAG"]("*", outermost),\n\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n\t\t\t\t    len = elems.length;\n\n\t\t\t\tif (outermost) {\n\t\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t\t}\n\n\t\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t\t// Support: IE<9, Safari\n\t\t\t\t// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id\n\t\t\t\tfor (; i !== len && (elem = elems[i]) != null; i++) {\n\t\t\t\t\tif (byElement && elem) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\tif (!context && elem.ownerDocument !== document) {\n\t\t\t\t\t\t\tsetDocument(elem);\n\t\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (matcher = elementMatchers[j++]) {\n\t\t\t\t\t\t\tif (matcher(elem, context || document, xml)) {\n\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outermost) {\n\t\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\t\tif (bySet) {\n\t\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\t\tif (elem = !matcher && elem) {\n\t\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\t\tif (seed) {\n\t\t\t\t\t\t\tunmatched.push(elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t\t// makes the latter nonnegative.\n\t\t\t\tmatchedCount += i;\n\n\t\t\t\t// Apply set filters to unmatched elements\n\t\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t\t// equals `i`), unless we didn\'t visit _any_ elements in the above loop because we have\n\t\t\t\t// no element matchers and no seed.\n\t\t\t\t// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that\n\t\t\t\t// case, which will result in a "00" `matchedCount` that differs from `i` but is also\n\t\t\t\t// numerically zero.\n\t\t\t\tif (bySet && i !== matchedCount) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile (matcher = setMatchers[j++]) {\n\t\t\t\t\t\tmatcher(unmatched, setMatched, context, xml);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (seed) {\n\t\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\t\tif (matchedCount > 0) {\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tif (!(unmatched[i] || setMatched[i])) {\n\t\t\t\t\t\t\t\t\tsetMatched[i] = pop.call(results);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\t\tsetMatched = condense(setMatched);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add matches to results\n\t\t\t\t\tpush.apply(results, setMatched);\n\n\t\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\t\tif (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n\n\t\t\t\t\t\tSizzle.uniqueSort(results);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override manipulation of globals by nested matchers\n\t\t\t\tif (outermost) {\n\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\toutermostContext = contextBackup;\n\t\t\t\t}\n\n\t\t\t\treturn unmatched;\n\t\t\t};\n\n\t\t\treturn bySet ? markFunction(superMatcher) : superMatcher;\n\t\t}\n\n\t\tcompile = Sizzle.compile = function (selector, match /* Internal Use Only */) {\n\t\t\tvar i,\n\t\t\t    setMatchers = [],\n\t\t\t    elementMatchers = [],\n\t\t\t    cached = compilerCache[selector + " "];\n\n\t\t\tif (!cached) {\n\t\t\t\t// Generate a function of recursive functions that can be used to check each element\n\t\t\t\tif (!match) {\n\t\t\t\t\tmatch = tokenize(selector);\n\t\t\t\t}\n\t\t\t\ti = match.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tcached = matcherFromTokens(match[i]);\n\t\t\t\t\tif (cached[expando]) {\n\t\t\t\t\t\tsetMatchers.push(cached);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telementMatchers.push(cached);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Cache the compiled function\n\t\t\t\tcached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\n\n\t\t\t\t// Save selector and tokenization\n\t\t\t\tcached.selector = selector;\n\t\t\t}\n\t\t\treturn cached;\n\t\t};\n\n\t\t/**\n   * A low-level selection function that works with Sizzle\'s compiled\n   *  selector functions\n   * @param {String|Function} selector A selector or a pre-compiled\n   *  selector function built with Sizzle.compile\n   * @param {Element} context\n   * @param {Array} [results]\n   * @param {Array} [seed] A set of elements to match against\n   */\n\t\tselect = Sizzle.select = function (selector, context, results, seed) {\n\t\t\tvar i,\n\t\t\t    tokens,\n\t\t\t    token,\n\t\t\t    type,\n\t\t\t    find,\n\t\t\t    compiled = typeof selector === "function" && selector,\n\t\t\t    match = !seed && tokenize(selector = compiled.selector || selector);\n\n\t\t\tresults = results || [];\n\n\t\t\t// Try to minimize operations if there is only one selector in the list and no seed\n\t\t\t// (the latter of which guarantees us context)\n\t\t\tif (match.length === 1) {\n\n\t\t\t\t// Reduce context if the leading compound selector is an ID\n\t\t\t\ttokens = match[0] = match[0].slice(0);\n\t\t\t\tif (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n\n\t\t\t\t\tcontext = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\t\t\t\t\tif (!context) {\n\t\t\t\t\t\treturn results;\n\n\t\t\t\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t\t\t} else if (compiled) {\n\t\t\t\t\t\tcontext = context.parentNode;\n\t\t\t\t\t}\n\n\t\t\t\t\tselector = selector.slice(tokens.shift().value.length);\n\t\t\t\t}\n\n\t\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\t\ti = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t\t// Abort if we hit a combinator\n\t\t\t\t\tif (Expr.relative[type = token.type]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (find = Expr.find[type]) {\n\t\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\t\tif (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n\n\t\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\t\ttokens.splice(i, 1);\n\t\t\t\t\t\t\tselector = seed.length && toSelector(tokens);\n\t\t\t\t\t\t\tif (!selector) {\n\t\t\t\t\t\t\t\tpush.apply(results, seed);\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Compile and execute a filtering function if one is not provided\n\t\t\t// Provide `match` to avoid retokenization if we modified the selector above\n\t\t\t(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n\t\t\treturn results;\n\t\t};\n\n\t\t// One-time assignments\n\n\t\t// Sort stability\n\t\tsupport.sortStable = expando.split("").sort(sortOrder).join("") === expando;\n\n\t\t// Support: Chrome 14-35+\n\t\t// Always assume duplicates if they aren\'t passed to the comparison function\n\t\tsupport.detectDuplicates = !!hasDuplicate;\n\n\t\t// Initialize against the default document\n\t\tsetDocument();\n\n\t\t// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n\t\t// Detached nodes confoundingly follow *each other*\n\t\tsupport.sortDetached = assert(function (el) {\n\t\t\t// Should return 1, but returns 4 (following)\n\t\t\treturn el.compareDocumentPosition(document.createElement("fieldset")) & 1;\n\t\t});\n\n\t\t// Support: IE<8\n\t\t// Prevent attribute/property "interpolation"\n\t\t// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\t\tif (!assert(function (el) {\n\t\t\tel.innerHTML = "<a href=\'#\'></a>";\n\t\t\treturn el.firstChild.getAttribute("href") === "#";\n\t\t})) {\n\t\t\taddHandle("type|href|height|width", function (elem, name, isXML) {\n\t\t\t\tif (!isXML) {\n\t\t\t\t\treturn elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Use defaultValue in place of getAttribute("value")\n\t\tif (!support.attributes || !assert(function (el) {\n\t\t\tel.innerHTML = "<input/>";\n\t\t\tel.firstChild.setAttribute("value", "");\n\t\t\treturn el.firstChild.getAttribute("value") === "";\n\t\t})) {\n\t\t\taddHandle("value", function (elem, name, isXML) {\n\t\t\t\tif (!isXML && elem.nodeName.toLowerCase() === "input") {\n\t\t\t\t\treturn elem.defaultValue;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Use getAttributeNode to fetch booleans when getAttribute lies\n\t\tif (!assert(function (el) {\n\t\t\treturn el.getAttribute("disabled") == null;\n\t\t})) {\n\t\t\taddHandle(booleans, function (elem, name, isXML) {\n\t\t\t\tvar val;\n\t\t\t\tif (!isXML) {\n\t\t\t\t\treturn elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn Sizzle;\n\t}(window);\n\n\tjQuery.find = Sizzle;\n\tjQuery.expr = Sizzle.selectors;\n\n\t// Deprecated\n\tjQuery.expr[":"] = jQuery.expr.pseudos;\n\tjQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n\tjQuery.text = Sizzle.getText;\n\tjQuery.isXMLDoc = Sizzle.isXML;\n\tjQuery.contains = Sizzle.contains;\n\tjQuery.escapeSelector = Sizzle.escape;\n\n\tvar dir = function dir(elem, _dir, until) {\n\t\tvar matched = [],\n\t\t    truncate = until !== undefined;\n\n\t\twhile ((elem = elem[_dir]) && elem.nodeType !== 9) {\n\t\t\tif (elem.nodeType === 1) {\n\t\t\t\tif (truncate && jQuery(elem).is(until)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push(elem);\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t};\n\n\tvar _siblings = function _siblings(n, elem) {\n\t\tvar matched = [];\n\n\t\tfor (; n; n = n.nextSibling) {\n\t\t\tif (n.nodeType === 1 && n !== elem) {\n\t\t\t\tmatched.push(n);\n\t\t\t}\n\t\t}\n\n\t\treturn matched;\n\t};\n\n\tvar rneedsContext = jQuery.expr.match.needsContext;\n\n\tfunction nodeName(elem, name) {\n\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t};\n\tvar rsingleTag = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i;\n\n\tvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n\t// Implement the identical functionality for filter and not\n\tfunction winnow(elements, qualifier, not) {\n\t\tif (jQuery.isFunction(qualifier)) {\n\t\t\treturn jQuery.grep(elements, function (elem, i) {\n\t\t\t\treturn !!qualifier.call(elem, i, elem) !== not;\n\t\t\t});\n\t\t}\n\n\t\t// Single element\n\t\tif (qualifier.nodeType) {\n\t\t\treturn jQuery.grep(elements, function (elem) {\n\t\t\t\treturn elem === qualifier !== not;\n\t\t\t});\n\t\t}\n\n\t\t// Arraylike of elements (jQuery, arguments, Array)\n\t\tif (typeof qualifier !== "string") {\n\t\t\treturn jQuery.grep(elements, function (elem) {\n\t\t\t\treturn indexOf.call(qualifier, elem) > -1 !== not;\n\t\t\t});\n\t\t}\n\n\t\t// Simple selector that can be filtered directly, removing non-Elements\n\t\tif (risSimple.test(qualifier)) {\n\t\t\treturn jQuery.filter(qualifier, elements, not);\n\t\t}\n\n\t\t// Complex selector, compare the two sets, removing non-Elements\n\t\tqualifier = jQuery.filter(qualifier, elements);\n\t\treturn jQuery.grep(elements, function (elem) {\n\t\t\treturn indexOf.call(qualifier, elem) > -1 !== not && elem.nodeType === 1;\n\t\t});\n\t}\n\n\tjQuery.filter = function (expr, elems, not) {\n\t\tvar elem = elems[0];\n\n\t\tif (not) {\n\t\t\texpr = ":not(" + expr + ")";\n\t\t}\n\n\t\tif (elems.length === 1 && elem.nodeType === 1) {\n\t\t\treturn jQuery.find.matchesSelector(elem, expr) ? [elem] : [];\n\t\t}\n\n\t\treturn jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\n\t\t\treturn elem.nodeType === 1;\n\t\t}));\n\t};\n\n\tjQuery.fn.extend({\n\t\tfind: function find(selector) {\n\t\t\tvar i,\n\t\t\t    ret,\n\t\t\t    len = this.length,\n\t\t\t    self = this;\n\n\t\t\tif (typeof selector !== "string") {\n\t\t\t\treturn this.pushStack(jQuery(selector).filter(function () {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (jQuery.contains(self[i], this)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tret = this.pushStack([]);\n\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tjQuery.find(selector, self[i], ret);\n\t\t\t}\n\n\t\t\treturn len > 1 ? jQuery.uniqueSort(ret) : ret;\n\t\t},\n\t\tfilter: function filter(selector) {\n\t\t\treturn this.pushStack(winnow(this, selector || [], false));\n\t\t},\n\t\tnot: function not(selector) {\n\t\t\treturn this.pushStack(winnow(this, selector || [], true));\n\t\t},\n\t\tis: function is(selector) {\n\t\t\treturn !!winnow(this,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $("p:first").is("p:last") won\'t return true for a doc with two "p".\n\t\t\ttypeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n\t\t}\n\t});\n\n\t// Initialize a jQuery object\n\n\n\t// A central reference to the root jQuery(document)\n\tvar rootjQuery,\n\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\t    init = jQuery.fn.init = function (selector, context, root) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(""), $(null), $(undefined), $(false)\n\t\tif (!selector) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif (typeof selector === "string") {\n\t\t\tif (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [null, selector, null];\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec(selector);\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif (match && (match[1] || !context)) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif (match[1]) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n\t\t\t\t\t\tfor (match in context) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif (jQuery.isFunction(this[match])) {\n\t\t\t\t\t\t\t\tthis[match](context[match]);\n\n\t\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr(match, context[match]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById(match[2]);\n\n\t\t\t\t\tif (elem) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if (!context || context.jquery) {\n\t\t\t\treturn (context || root).find(selector);\n\n\t\t\t\t// HANDLE: $(expr, context)\n\t\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor(context).find(selector);\n\t\t\t}\n\n\t\t\t// HANDLE: $(DOMElement)\n\t\t} else if (selector.nodeType) {\n\t\t\tthis[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t\t// HANDLE: $(function)\n\t\t\t// Shortcut for document ready\n\t\t} else if (jQuery.isFunction(selector)) {\n\t\t\treturn root.ready !== undefined ? root.ready(selector) :\n\n\t\t\t// Execute immediately if ready is not present\n\t\t\tselector(jQuery);\n\t\t}\n\n\t\treturn jQuery.makeArray(selector, this);\n\t};\n\n\t// Give the init function the jQuery prototype for later instantiation\n\tinit.prototype = jQuery.fn;\n\n\t// Initialize central reference\n\trootjQuery = jQuery(document);\n\n\tvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\n\tjQuery.fn.extend({\n\t\thas: function has(target) {\n\t\t\tvar targets = jQuery(target, this),\n\t\t\t    l = targets.length;\n\n\t\t\treturn this.filter(function () {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\tif (jQuery.contains(this, targets[i])) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tclosest: function closest(selectors, context) {\n\t\t\tvar cur,\n\t\t\t    i = 0,\n\t\t\t    l = this.length,\n\t\t\t    matched = [],\n\t\t\t    targets = typeof selectors !== "string" && jQuery(selectors);\n\n\t\t\t// Positional selectors never match, since there\'s no _selection_ context\n\t\t\tif (!rneedsContext.test(selectors)) {\n\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\tfor (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n\n\t\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\t\tif (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 :\n\n\t\t\t\t\t\t// Don\'t pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n\n\t\t\t\t\t\t\tmatched.push(cur);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\n\t\t},\n\n\t\t// Determine the position of an element within the set\n\t\tindex: function index(elem) {\n\n\t\t\t// No argument, return index in parent\n\t\t\tif (!elem) {\n\t\t\t\treturn this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n\t\t\t}\n\n\t\t\t// Index in selector\n\t\t\tif (typeof elem === "string") {\n\t\t\t\treturn indexOf.call(jQuery(elem), this[0]);\n\t\t\t}\n\n\t\t\t// Locate the position of the desired element\n\t\t\treturn indexOf.call(this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[0] : elem);\n\t\t},\n\n\t\tadd: function add(selector, context) {\n\t\t\treturn this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\n\t\t},\n\n\t\taddBack: function addBack(selector) {\n\t\t\treturn this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n\t\t}\n\t});\n\n\tfunction sibling(cur, dir) {\n\t\twhile ((cur = cur[dir]) && cur.nodeType !== 1) {}\n\t\treturn cur;\n\t}\n\n\tjQuery.each({\n\t\tparent: function parent(elem) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t\t},\n\t\tparents: function parents(elem) {\n\t\t\treturn dir(elem, "parentNode");\n\t\t},\n\t\tparentsUntil: function parentsUntil(elem, i, until) {\n\t\t\treturn dir(elem, "parentNode", until);\n\t\t},\n\t\tnext: function next(elem) {\n\t\t\treturn sibling(elem, "nextSibling");\n\t\t},\n\t\tprev: function prev(elem) {\n\t\t\treturn sibling(elem, "previousSibling");\n\t\t},\n\t\tnextAll: function nextAll(elem) {\n\t\t\treturn dir(elem, "nextSibling");\n\t\t},\n\t\tprevAll: function prevAll(elem) {\n\t\t\treturn dir(elem, "previousSibling");\n\t\t},\n\t\tnextUntil: function nextUntil(elem, i, until) {\n\t\t\treturn dir(elem, "nextSibling", until);\n\t\t},\n\t\tprevUntil: function prevUntil(elem, i, until) {\n\t\t\treturn dir(elem, "previousSibling", until);\n\t\t},\n\t\tsiblings: function siblings(elem) {\n\t\t\treturn _siblings((elem.parentNode || {}).firstChild, elem);\n\t\t},\n\t\tchildren: function children(elem) {\n\t\t\treturn _siblings(elem.firstChild);\n\t\t},\n\t\tcontents: function contents(elem) {\n\t\t\tif (nodeName(elem, "iframe")) {\n\t\t\t\treturn elem.contentDocument;\n\t\t\t}\n\n\t\t\t// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n\t\t\t// Treat the template element as a regular one in browsers that\n\t\t\t// don\'t support it.\n\t\t\tif (nodeName(elem, "template")) {\n\t\t\t\telem = elem.content || elem;\n\t\t\t}\n\n\t\t\treturn jQuery.merge([], elem.childNodes);\n\t\t}\n\t}, function (name, fn) {\n\t\tjQuery.fn[name] = function (until, selector) {\n\t\t\tvar matched = jQuery.map(this, fn, until);\n\n\t\t\tif (name.slice(-5) !== "Until") {\n\t\t\t\tselector = until;\n\t\t\t}\n\n\t\t\tif (selector && typeof selector === "string") {\n\t\t\t\tmatched = jQuery.filter(selector, matched);\n\t\t\t}\n\n\t\t\tif (this.length > 1) {\n\n\t\t\t\t// Remove duplicates\n\t\t\t\tif (!guaranteedUnique[name]) {\n\t\t\t\t\tjQuery.uniqueSort(matched);\n\t\t\t\t}\n\n\t\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\t\tif (rparentsprev.test(name)) {\n\t\t\t\t\tmatched.reverse();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.pushStack(matched);\n\t\t};\n\t});\n\tvar rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\n\t// Convert String-formatted options into Object-formatted ones\n\tfunction createOptions(options) {\n\t\tvar object = {};\n\t\tjQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {\n\t\t\tobject[flag] = true;\n\t\t});\n\t\treturn object;\n\t}\n\n\t/*\n  * Create a callback list using the following parameters:\n  *\n  *\toptions: an optional list of space-separated options that will change how\n  *\t\t\tthe callback list behaves or a more traditional option object\n  *\n  * By default a callback list will act like an event callback list and can be\n  * "fired" multiple times.\n  *\n  * Possible options:\n  *\n  *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n  *\n  *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n  *\t\t\t\t\tafter the list has been fired right away with the latest "memorized"\n  *\t\t\t\t\tvalues (like a Deferred)\n  *\n  *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n  *\n  *\tstopOnFalse:\tinterrupt callings when a callback returns false\n  *\n  */\n\tjQuery.Callbacks = function (options) {\n\n\t\t// Convert options from String-formatted to Object-formatted if needed\n\t\t// (we check in cache first)\n\t\toptions = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);\n\n\t\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\n\t\t// Flag to know if list was already fired\n\t\t_fired,\n\n\n\t\t// Flag to prevent firing\n\t\t_locked,\n\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\n\t\t// Fire callbacks\n\t\tfire = function fire() {\n\n\t\t\t// Enforce single-firing\n\t\t\t_locked = _locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\t_fired = firing = true;\n\t\t\tfor (; queue.length; firingIndex = -1) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile (++firingIndex < list.length) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn\'t re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we\'re done with it\n\t\t\tif (!options.memory) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we\'re done firing for good\n\t\t\tif (_locked) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif (memory) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = "";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function add() {\n\t\t\t\tif (list) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif (memory && !firing) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push(memory);\n\t\t\t\t\t}\n\n\t\t\t\t\t(function add(args) {\n\t\t\t\t\t\tjQuery.each(args, function (_, arg) {\n\t\t\t\t\t\t\tif (jQuery.isFunction(arg)) {\n\t\t\t\t\t\t\t\tif (!options.unique || !self.has(arg)) {\n\t\t\t\t\t\t\t\t\tlist.push(arg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (arg && arg.length && jQuery.type(arg) !== "string") {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd(arg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})(arguments);\n\n\t\t\t\t\tif (memory && !firing) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function remove() {\n\t\t\t\tjQuery.each(arguments, function (_, arg) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ((index = jQuery.inArray(arg, list, index)) > -1) {\n\t\t\t\t\t\tlist.splice(index, 1);\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif (index <= firingIndex) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function has(fn) {\n\t\t\t\treturn fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function empty() {\n\t\t\t\tif (list) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function disable() {\n\t\t\t\t_locked = queue = [];\n\t\t\t\tlist = memory = "";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function disabled() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function lock() {\n\t\t\t\t_locked = queue = [];\n\t\t\t\tif (!memory && !firing) {\n\t\t\t\t\tlist = memory = "";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function locked() {\n\t\t\t\treturn !!_locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function fireWith(context, args) {\n\t\t\t\tif (!_locked) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [context, args.slice ? args.slice() : args];\n\t\t\t\t\tqueue.push(args);\n\t\t\t\t\tif (!firing) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function fire() {\n\t\t\t\tself.fireWith(this, arguments);\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function fired() {\n\t\t\t\treturn !!_fired;\n\t\t\t}\n\t\t};\n\n\t\treturn self;\n\t};\n\n\tfunction Identity(v) {\n\t\treturn v;\n\t}\n\tfunction Thrower(ex) {\n\t\tthrow ex;\n\t}\n\n\tfunction adoptValue(value, resolve, reject, noValue) {\n\t\tvar method;\n\n\t\ttry {\n\n\t\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\t\tif (value && jQuery.isFunction(method = value.promise)) {\n\t\t\t\tmethod.call(value).done(resolve).fail(reject);\n\n\t\t\t\t// Other thenables\n\t\t\t} else if (value && jQuery.isFunction(method = value.then)) {\n\t\t\t\tmethod.call(value, resolve, reject);\n\n\t\t\t\t// Other non-thenables\n\t\t\t} else {\n\n\t\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\t\tresolve.apply(undefined, [value].slice(noValue));\n\t\t\t}\n\n\t\t\t// For Promises/A+, convert exceptions into rejections\n\t\t\t// Since jQuery.when doesn\'t unwrap thenables, we can skip the extra checks appearing in\n\t\t\t// Deferred#then to conditionally suppress rejection.\n\t\t} catch (value) {\n\n\t\t\t// Support: Android 4.0 only\n\t\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\t\treject.apply(undefined, [value]);\n\t\t}\n\t}\n\n\tjQuery.extend({\n\n\t\tDeferred: function Deferred(func) {\n\t\t\tvar tuples = [\n\n\t\t\t// action, add listener, callbacks,\n\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],\n\t\t\t    _state = "pending",\n\t\t\t    _promise = {\n\t\t\t\tstate: function state() {\n\t\t\t\t\treturn _state;\n\t\t\t\t},\n\t\t\t\talways: function always() {\n\t\t\t\t\tdeferred.done(arguments).fail(arguments);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t"catch": function _catch(fn) {\n\t\t\t\t\treturn _promise.then(null, fn);\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function pipe() /* fnDone, fnFail, fnProgress */{\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred(function (newDefer) {\n\t\t\t\t\t\tjQuery.each(tuples, function (i, tuple) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[tuple[1]](function () {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply(this, arguments);\n\t\t\t\t\t\t\t\tif (returned && jQuery.isFunction(returned.promise)) {\n\t\t\t\t\t\t\t\t\treturned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\tthen: function then(onFulfilled, onRejected, onProgress) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve(depth, deferred, handler, special) {\n\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t    args = arguments,\n\t\t\t\t\t\t\t    mightThrow = function mightThrow() {\n\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\tif (depth < maxDepth) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturned = handler.apply(that, args);\n\n\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\tif (returned === deferred.promise()) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError("Thenable self-resolution");\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\tthen = returned && (\n\n\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t(typeof returned === "undefined" ? "undefined" : _typeof(returned)) === "object" || typeof returned === "function") && returned.then;\n\n\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\tif (jQuery.isFunction(then)) {\n\n\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\tif (special) {\n\t\t\t\t\t\t\t\t\t\tthen.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\tthen.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\tif (handler !== Identity) {\n\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\targs = [returned];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t(special || deferred.resolveWith)(that, args);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\n\n\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\tprocess = special ? mightThrow : function () {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t} catch (e) {\n\n\t\t\t\t\t\t\t\t\tif (jQuery.Deferred.exceptionHook) {\n\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook(e, process.stackTrace);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\tif (depth + 1 >= maxDepth) {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif (handler !== Thrower) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [e];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith(that, args);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif (depth) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it\'s otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif (jQuery.Deferred.getStackHook) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout(process);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred(function (newDefer) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity));\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower));\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function promise(obj) {\n\t\t\t\t\treturn obj != null ? jQuery.extend(obj, _promise) : _promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\t    deferred = {};\n\n\t\t\t// Add list-specific methods\n\t\t\tjQuery.each(tuples, function (i, tuple) {\n\t\t\t\tvar list = tuple[2],\n\t\t\t\t    stateString = tuple[5];\n\n\t\t\t\t// promise.progress = list.add\n\t\t\t\t// promise.done = list.add\n\t\t\t\t// promise.fail = list.add\n\t\t\t\t_promise[tuple[1]] = list.add;\n\n\t\t\t\t// Handle state\n\t\t\t\tif (stateString) {\n\t\t\t\t\tlist.add(function () {\n\n\t\t\t\t\t\t// state = "resolved" (i.e., fulfilled)\n\t\t\t\t\t\t// state = "rejected"\n\t\t\t\t\t\t_state = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[3 - i][2].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[0][2].lock);\n\t\t\t\t}\n\n\t\t\t\t// progress_handlers.fire\n\t\t\t\t// fulfilled_handlers.fire\n\t\t\t\t// rejected_handlers.fire\n\t\t\t\tlist.add(tuple[3].fire);\n\n\t\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\t\tdeferred[tuple[0]] = function () {\n\t\t\t\t\tdeferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\n\t\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\t\tdeferred[tuple[0] + "With"] = list.fireWith;\n\t\t\t});\n\n\t\t\t// Make the deferred a promise\n\t\t\t_promise.promise(deferred);\n\n\t\t\t// Call given func if any\n\t\t\tif (func) {\n\t\t\t\tfunc.call(deferred, deferred);\n\t\t\t}\n\n\t\t\t// All done!\n\t\t\treturn deferred;\n\t\t},\n\n\t\t// Deferred helper\n\t\twhen: function when(singleValue) {\n\t\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array(i),\n\t\t\t    resolveValues = _slice.call(arguments),\n\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function updateFunc(i) {\n\t\t\t\treturn function (value) {\n\t\t\t\t\tresolveContexts[i] = this;\n\t\t\t\t\tresolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;\n\t\t\t\t\tif (! --remaining) {\n\t\t\t\t\t\tmaster.resolveWith(resolveContexts, resolveValues);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\t\tif (remaining <= 1) {\n\t\t\t\tadoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);\n\n\t\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\t\tif (master.state() === "pending" || jQuery.isFunction(resolveValues[i] && resolveValues[i].then)) {\n\n\t\t\t\t\treturn master.then();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\t\twhile (i--) {\n\t\t\t\tadoptValue(resolveValues[i], updateFunc(i), master.reject);\n\t\t\t}\n\n\t\t\treturn master.promise();\n\t\t}\n\t});\n\n\t// These usually indicate a programmer mistake during development,\n\t// warn about them ASAP rather than swallowing them by default.\n\tvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\n\tjQuery.Deferred.exceptionHook = function (error, stack) {\n\n\t\t// Support: IE 8 - 9 only\n\t\t// Console exists when dev tools are open, which can happen at any time\n\t\tif (window.console && window.console.warn && error && rerrorNames.test(error.name)) {\n\t\t\twindow.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);\n\t\t}\n\t};\n\n\tjQuery.readyException = function (error) {\n\t\twindow.setTimeout(function () {\n\t\t\tthrow error;\n\t\t});\n\t};\n\n\t// The deferred used on DOM ready\n\tvar readyList = jQuery.Deferred();\n\n\tjQuery.fn.ready = function (fn) {\n\n\t\treadyList.then(fn)\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch(function (error) {\n\t\t\tjQuery.readyException(error);\n\t\t});\n\n\t\treturn this;\n\t};\n\n\tjQuery.extend({\n\n\t\t// Is the DOM ready to be used? Set to true once it occurs.\n\t\tisReady: false,\n\n\t\t// A counter to track how many items to wait for before\n\t\t// the ready event fires. See #6781\n\t\treadyWait: 1,\n\n\t\t// Handle when the DOM is ready\n\t\tready: function ready(wait) {\n\n\t\t\t// Abort if there are pending holds or we\'re already ready\n\t\t\tif (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\n\t\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\t\tif (wait !== true && --jQuery.readyWait > 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If there are functions bound, to execute\n\t\t\treadyList.resolveWith(document, [jQuery]);\n\t\t}\n\t});\n\n\tjQuery.ready.then = readyList.then;\n\n\t// The ready event handler and self cleanup method\n\tfunction completed() {\n\t\tdocument.removeEventListener("DOMContentLoaded", completed);\n\t\twindow.removeEventListener("load", completed);\n\t\tjQuery.ready();\n\t}\n\n\t// Catch cases where $(document).ready() is called\n\t// after the browser event has already occurred.\n\t// Support: IE <=9 - 10 only\n\t// Older IE sometimes signals "interactive" too soon\n\tif (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {\n\n\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\twindow.setTimeout(jQuery.ready);\n\t} else {\n\n\t\t// Use the handy event callback\n\t\tdocument.addEventListener("DOMContentLoaded", completed);\n\n\t\t// A fallback to window.onload, that will always work\n\t\twindow.addEventListener("load", completed);\n\t}\n\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it\'s a function\n\tvar access = function access(elems, fn, key, value, chainable, emptyGet, raw) {\n\t\tvar i = 0,\n\t\t    len = elems.length,\n\t\t    bulk = key == null;\n\n\t\t// Sets many values\n\t\tif (jQuery.type(key) === "object") {\n\t\t\tchainable = true;\n\t\t\tfor (i in key) {\n\t\t\t\taccess(elems, fn, i, key[i], true, emptyGet, raw);\n\t\t\t}\n\n\t\t\t// Sets one value\n\t\t} else if (value !== undefined) {\n\t\t\tchainable = true;\n\n\t\t\tif (!jQuery.isFunction(value)) {\n\t\t\t\traw = true;\n\t\t\t}\n\n\t\t\tif (bulk) {\n\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif (raw) {\n\t\t\t\t\tfn.call(elems, value);\n\t\t\t\t\tfn = null;\n\n\t\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function fn(elem, key, value) {\n\t\t\t\t\t\treturn bulk.call(jQuery(elem), value);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fn) {\n\t\t\t\tfor (; i < len; i++) {\n\t\t\t\t\tfn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (chainable) {\n\t\t\treturn elems;\n\t\t}\n\n\t\t// Gets\n\t\tif (bulk) {\n\t\t\treturn fn.call(elems);\n\t\t}\n\n\t\treturn len ? fn(elems[0], key) : emptyGet;\n\t};\n\tvar acceptData = function acceptData(owner) {\n\n\t\t// Accepts only:\n\t\t//  - Node\n\t\t//    - Node.ELEMENT_NODE\n\t\t//    - Node.DOCUMENT_NODE\n\t\t//  - Object\n\t\t//    - Any\n\t\treturn owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\n\t};\n\n\tfunction Data() {\n\t\tthis.expando = jQuery.expando + Data.uid++;\n\t}\n\n\tData.uid = 1;\n\n\tData.prototype = {\n\n\t\tcache: function cache(owner) {\n\n\t\t\t// Check if the owner object already has a cache\n\t\t\tvar value = owner[this.expando];\n\n\t\t\t// If not, create one\n\t\t\tif (!value) {\n\t\t\t\tvalue = {};\n\n\t\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t\t// but we should not, see #8335.\n\t\t\t\t// Always return an empty object.\n\t\t\t\tif (acceptData(owner)) {\n\n\t\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t\t// use plain assignment\n\t\t\t\t\tif (owner.nodeType) {\n\t\t\t\t\t\towner[this.expando] = value;\n\n\t\t\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t\t\t// deleted when data is removed\n\t\t\t\t\t} else {\n\t\t\t\t\t\tObject.defineProperty(owner, this.expando, {\n\t\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t},\n\t\tset: function set(owner, data, value) {\n\t\t\tvar prop,\n\t\t\t    cache = this.cache(owner);\n\n\t\t\t// Handle: [ owner, key, value ] args\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\tif (typeof data === "string") {\n\t\t\t\tcache[jQuery.camelCase(data)] = value;\n\n\t\t\t\t// Handle: [ owner, { properties } ] args\n\t\t\t} else {\n\n\t\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\t\tfor (prop in data) {\n\t\t\t\t\tcache[jQuery.camelCase(prop)] = data[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cache;\n\t\t},\n\t\tget: function get(owner, key) {\n\t\t\treturn key === undefined ? this.cache(owner) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[this.expando] && owner[this.expando][jQuery.camelCase(key)];\n\t\t},\n\t\taccess: function access(owner, key, value) {\n\n\t\t\t// In cases where either:\n\t\t\t//\n\t\t\t//   1. No key was specified\n\t\t\t//   2. A string key was specified, but no value provided\n\t\t\t//\n\t\t\t// Take the "read" path and allow the get method to determine\n\t\t\t// which value to return, respectively either:\n\t\t\t//\n\t\t\t//   1. The entire cache object\n\t\t\t//   2. The data stored at the key\n\t\t\t//\n\t\t\tif (key === undefined || key && typeof key === "string" && value === undefined) {\n\n\t\t\t\treturn this.get(owner, key);\n\t\t\t}\n\n\t\t\t// When the key is not a string, or both a key and value\n\t\t\t// are specified, set or extend (existing objects) with either:\n\t\t\t//\n\t\t\t//   1. An object of properties\n\t\t\t//   2. A key and value\n\t\t\t//\n\t\t\tthis.set(owner, key, value);\n\n\t\t\t// Since the "set" path can have two possible entry points\n\t\t\t// return the expected data based on which path was taken[*]\n\t\t\treturn value !== undefined ? value : key;\n\t\t},\n\t\tremove: function remove(owner, key) {\n\t\t\tvar i,\n\t\t\t    cache = owner[this.expando];\n\n\t\t\tif (cache === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (key !== undefined) {\n\n\t\t\t\t// Support array or space separated string of keys\n\t\t\t\tif (Array.isArray(key)) {\n\n\t\t\t\t\t// If key is an array of keys...\n\t\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\t\tkey = key.map(jQuery.camelCase);\n\t\t\t\t} else {\n\t\t\t\t\tkey = jQuery.camelCase(key);\n\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tkey = key in cache ? [key] : key.match(rnothtmlwhite) || [];\n\t\t\t\t}\n\n\t\t\t\ti = key.length;\n\n\t\t\t\twhile (i--) {\n\t\t\t\t\tdelete cache[key[i]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove the expando if there\'s no more data\n\t\t\tif (key === undefined || jQuery.isEmptyObject(cache)) {\n\n\t\t\t\t// Support: Chrome <=35 - 45\n\t\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\t\tif (owner.nodeType) {\n\t\t\t\t\towner[this.expando] = undefined;\n\t\t\t\t} else {\n\t\t\t\t\tdelete owner[this.expando];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thasData: function hasData(owner) {\n\t\t\tvar cache = owner[this.expando];\n\t\t\treturn cache !== undefined && !jQuery.isEmptyObject(cache);\n\t\t}\n\t};\n\tvar dataPriv = new Data();\n\n\tvar dataUser = new Data();\n\n\t//\tImplementation Summary\n\t//\n\t//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t//\t2. Improve the module\'s maintainability by reducing the storage\n\t//\t\tpaths to a single mechanism.\n\t//\t3. Use the same single mechanism to support "private" and "user" data.\n\t//\t4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)\n\t//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\n\tvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\t    rmultiDash = /[A-Z]/g;\n\n\tfunction getData(data) {\n\t\tif (data === "true") {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (data === "false") {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (data === "null") {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Only convert to a number if it doesn\'t change the string\n\t\tif (data === +data + "") {\n\t\t\treturn +data;\n\t\t}\n\n\t\tif (rbrace.test(data)) {\n\t\t\treturn JSON.parse(data);\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tfunction dataAttr(elem, key, data) {\n\t\tvar name;\n\n\t\t// If nothing was found internally, try to fetch any\n\t\t// data from the HTML5 data-* attribute\n\t\tif (data === undefined && elem.nodeType === 1) {\n\t\t\tname = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();\n\t\t\tdata = elem.getAttribute(name);\n\n\t\t\tif (typeof data === "string") {\n\t\t\t\ttry {\n\t\t\t\t\tdata = getData(data);\n\t\t\t\t} catch (e) {}\n\n\t\t\t\t// Make sure we set the data so it isn\'t changed later\n\t\t\t\tdataUser.set(elem, key, data);\n\t\t\t} else {\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}\n\n\tjQuery.extend({\n\t\thasData: function hasData(elem) {\n\t\t\treturn dataUser.hasData(elem) || dataPriv.hasData(elem);\n\t\t},\n\n\t\tdata: function data(elem, name, _data) {\n\t\t\treturn dataUser.access(elem, name, _data);\n\t\t},\n\n\t\tremoveData: function removeData(elem, name) {\n\t\t\tdataUser.remove(elem, name);\n\t\t},\n\n\t\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t\t// with direct calls to dataPriv methods, these can be deprecated.\n\t\t_data: function _data(elem, name, data) {\n\t\t\treturn dataPriv.access(elem, name, data);\n\t\t},\n\n\t\t_removeData: function _removeData(elem, name) {\n\t\t\tdataPriv.remove(elem, name);\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tdata: function data(key, value) {\n\t\t\tvar i,\n\t\t\t    name,\n\t\t\t    data,\n\t\t\t    elem = this[0],\n\t\t\t    attrs = elem && elem.attributes;\n\n\t\t\t// Gets all values\n\t\t\tif (key === undefined) {\n\t\t\t\tif (this.length) {\n\t\t\t\t\tdata = dataUser.get(elem);\n\n\t\t\t\t\tif (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {\n\t\t\t\t\t\ti = attrs.length;\n\t\t\t\t\t\twhile (i--) {\n\n\t\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\t\tif (attrs[i]) {\n\t\t\t\t\t\t\t\tname = attrs[i].name;\n\t\t\t\t\t\t\t\tif (name.indexOf("data-") === 0) {\n\t\t\t\t\t\t\t\t\tname = jQuery.camelCase(name.slice(5));\n\t\t\t\t\t\t\t\t\tdataAttr(elem, name, data[name]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataPriv.set(elem, "hasDataAttrs", true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\t// Sets multiple values\n\t\t\tif ((typeof key === "undefined" ? "undefined" : _typeof(key)) === "object") {\n\t\t\t\treturn this.each(function () {\n\t\t\t\t\tdataUser.set(this, key);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn access(this, function (value) {\n\t\t\t\tvar data;\n\n\t\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\t\tif (elem && value === undefined) {\n\n\t\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\t\tdata = dataUser.get(elem, key);\n\t\t\t\t\tif (data !== undefined) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Attempt to "discover" the data in\n\t\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\t\tdata = dataAttr(elem, key);\n\t\t\t\t\tif (data !== undefined) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We tried really hard, but the data doesn\'t exist.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Set the data...\n\t\t\t\tthis.each(function () {\n\n\t\t\t\t\t// We always store the camelCased key\n\t\t\t\t\tdataUser.set(this, key, value);\n\t\t\t\t});\n\t\t\t}, null, value, arguments.length > 1, null, true);\n\t\t},\n\n\t\tremoveData: function removeData(key) {\n\t\t\treturn this.each(function () {\n\t\t\t\tdataUser.remove(this, key);\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tqueue: function queue(elem, type, data) {\n\t\t\tvar queue;\n\n\t\t\tif (elem) {\n\t\t\t\ttype = (type || "fx") + "queue";\n\t\t\t\tqueue = dataPriv.get(elem, type);\n\n\t\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\t\tif (data) {\n\t\t\t\t\tif (!queue || Array.isArray(data)) {\n\t\t\t\t\t\tqueue = dataPriv.access(elem, type, jQuery.makeArray(data));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueue.push(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn queue || [];\n\t\t\t}\n\t\t},\n\n\t\tdequeue: function dequeue(elem, type) {\n\t\t\ttype = type || "fx";\n\n\t\t\tvar queue = jQuery.queue(elem, type),\n\t\t\t    startLength = queue.length,\n\t\t\t    fn = queue.shift(),\n\t\t\t    hooks = jQuery._queueHooks(elem, type),\n\t\t\t    next = function next() {\n\t\t\t\tjQuery.dequeue(elem, type);\n\t\t\t};\n\n\t\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\t\tif (fn === "inprogress") {\n\t\t\t\tfn = queue.shift();\n\t\t\t\tstartLength--;\n\t\t\t}\n\n\t\t\tif (fn) {\n\n\t\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t\t// automatically dequeued\n\t\t\t\tif (type === "fx") {\n\t\t\t\t\tqueue.unshift("inprogress");\n\t\t\t\t}\n\n\t\t\t\t// Clear up the last queue stop function\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tfn.call(elem, next, hooks);\n\t\t\t}\n\n\t\t\tif (!startLength && hooks) {\n\t\t\t\thooks.empty.fire();\n\t\t\t}\n\t\t},\n\n\t\t// Not public - generate a queueHooks object, or return the current one\n\t\t_queueHooks: function _queueHooks(elem, type) {\n\t\t\tvar key = type + "queueHooks";\n\t\t\treturn dataPriv.get(elem, key) || dataPriv.access(elem, key, {\n\t\t\t\tempty: jQuery.Callbacks("once memory").add(function () {\n\t\t\t\t\tdataPriv.remove(elem, [type + "queue", key]);\n\t\t\t\t})\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tqueue: function queue(type, data) {\n\t\t\tvar setter = 2;\n\n\t\t\tif (typeof type !== "string") {\n\t\t\t\tdata = type;\n\t\t\t\ttype = "fx";\n\t\t\t\tsetter--;\n\t\t\t}\n\n\t\t\tif (arguments.length < setter) {\n\t\t\t\treturn jQuery.queue(this[0], type);\n\t\t\t}\n\n\t\t\treturn data === undefined ? this : this.each(function () {\n\t\t\t\tvar queue = jQuery.queue(this, type, data);\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks(this, type);\n\n\t\t\t\tif (type === "fx" && queue[0] !== "inprogress") {\n\t\t\t\t\tjQuery.dequeue(this, type);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tdequeue: function dequeue(type) {\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.dequeue(this, type);\n\t\t\t});\n\t\t},\n\t\tclearQueue: function clearQueue(type) {\n\t\t\treturn this.queue(type || "fx", []);\n\t\t},\n\n\t\t// Get a promise resolved when queues of a certain type\n\t\t// are emptied (fx is the type by default)\n\t\tpromise: function promise(type, obj) {\n\t\t\tvar tmp,\n\t\t\t    count = 1,\n\t\t\t    defer = jQuery.Deferred(),\n\t\t\t    elements = this,\n\t\t\t    i = this.length,\n\t\t\t    resolve = function resolve() {\n\t\t\t\tif (! --count) {\n\t\t\t\t\tdefer.resolveWith(elements, [elements]);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (typeof type !== "string") {\n\t\t\t\tobj = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\ttype = type || "fx";\n\n\t\t\twhile (i--) {\n\t\t\t\ttmp = dataPriv.get(elements[i], type + "queueHooks");\n\t\t\t\tif (tmp && tmp.empty) {\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp.empty.add(resolve);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresolve();\n\t\t\treturn defer.promise(obj);\n\t\t}\n\t});\n\tvar pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n\n\tvar rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");\n\n\tvar cssExpand = ["Top", "Right", "Bottom", "Left"];\n\n\tvar isHiddenWithinTree = function isHiddenWithinTree(elem, el) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === "none" || elem.style.display === "" &&\n\n\t\t// Otherwise, check computed style\n\t\t// Support: Firefox <=43 - 45\n\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t// in the document.\n\t\tjQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";\n\t};\n\n\tvar swap = function swap(elem, options, callback, args) {\n\t\tvar ret,\n\t\t    name,\n\t\t    old = {};\n\n\t\t// Remember the old values, and insert the new ones\n\t\tfor (name in options) {\n\t\t\told[name] = elem.style[name];\n\t\t\telem.style[name] = options[name];\n\t\t}\n\n\t\tret = callback.apply(elem, args || []);\n\n\t\t// Revert the old values\n\t\tfor (name in options) {\n\t\t\telem.style[name] = old[name];\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\tfunction adjustCSS(elem, prop, valueParts, tween) {\n\t\tvar adjusted,\n\t\t    scale = 1,\n\t\t    maxIterations = 20,\n\t\t    currentValue = tween ? function () {\n\t\t\treturn tween.cur();\n\t\t} : function () {\n\t\t\treturn jQuery.css(elem, prop, "");\n\t\t},\n\t\t    initial = currentValue(),\n\t\t    unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),\n\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));\n\n\t\tif (initialInUnit && initialInUnit[3] !== unit) {\n\n\t\t\t// Trust units reported by jQuery.css\n\t\t\tunit = unit || initialInUnit[3];\n\n\t\t\t// Make sure we update the tween properties later on\n\t\t\tvalueParts = valueParts || [];\n\n\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\tinitialInUnit = +initial || 1;\n\n\t\t\tdo {\n\n\t\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t\t// Use string for doubling so we don\'t accidentally see scale as unchanged below\n\t\t\t\tscale = scale || ".5";\n\n\t\t\t\t// Adjust and apply\n\t\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\t\tjQuery.style(elem, prop, initialInUnit + unit);\n\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t\t// Break the loop if scale is unchanged or perfect, or if we\'ve just had enough.\n\t\t\t} while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);\n\t\t}\n\n\t\tif (valueParts) {\n\t\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t\t// Apply relative offset (+=/-=) if specified\n\t\t\tadjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];\n\t\t\tif (tween) {\n\t\t\t\ttween.unit = unit;\n\t\t\t\ttween.start = initialInUnit;\n\t\t\t\ttween.end = adjusted;\n\t\t\t}\n\t\t}\n\t\treturn adjusted;\n\t}\n\n\tvar defaultDisplayMap = {};\n\n\tfunction getDefaultDisplay(elem) {\n\t\tvar temp,\n\t\t    doc = elem.ownerDocument,\n\t\t    nodeName = elem.nodeName,\n\t\t    display = defaultDisplayMap[nodeName];\n\n\t\tif (display) {\n\t\t\treturn display;\n\t\t}\n\n\t\ttemp = doc.body.appendChild(doc.createElement(nodeName));\n\t\tdisplay = jQuery.css(temp, "display");\n\n\t\ttemp.parentNode.removeChild(temp);\n\n\t\tif (display === "none") {\n\t\t\tdisplay = "block";\n\t\t}\n\t\tdefaultDisplayMap[nodeName] = display;\n\n\t\treturn display;\n\t}\n\n\tfunction showHide(elements, show) {\n\t\tvar display,\n\t\t    elem,\n\t\t    values = [],\n\t\t    index = 0,\n\t\t    length = elements.length;\n\n\t\t// Determine new display value for elements that need to change\n\t\tfor (; index < length; index++) {\n\t\t\telem = elements[index];\n\t\t\tif (!elem.style) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdisplay = elem.style.display;\n\t\t\tif (show) {\n\n\t\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t\t// inline or about-to-be-restored)\n\t\t\t\tif (display === "none") {\n\t\t\t\t\tvalues[index] = dataPriv.get(elem, "display") || null;\n\t\t\t\t\tif (!values[index]) {\n\t\t\t\t\t\telem.style.display = "";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (elem.style.display === "" && isHiddenWithinTree(elem)) {\n\t\t\t\t\tvalues[index] = getDefaultDisplay(elem);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (display !== "none") {\n\t\t\t\t\tvalues[index] = "none";\n\n\t\t\t\t\t// Remember what we\'re overwriting\n\t\t\t\t\tdataPriv.set(elem, "display", display);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set the display of the elements in a second loop to avoid constant reflow\n\t\tfor (index = 0; index < length; index++) {\n\t\t\tif (values[index] != null) {\n\t\t\t\telements[index].style.display = values[index];\n\t\t\t}\n\t\t}\n\n\t\treturn elements;\n\t}\n\n\tjQuery.fn.extend({\n\t\tshow: function show() {\n\t\t\treturn showHide(this, true);\n\t\t},\n\t\thide: function hide() {\n\t\t\treturn showHide(this);\n\t\t},\n\t\ttoggle: function toggle(state) {\n\t\t\tif (typeof state === "boolean") {\n\t\t\t\treturn state ? this.show() : this.hide();\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tif (isHiddenWithinTree(this)) {\n\t\t\t\t\tjQuery(this).show();\n\t\t\t\t} else {\n\t\t\t\t\tjQuery(this).hide();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\tvar rcheckableType = /^(?:checkbox|radio)$/i;\n\n\tvar rtagName = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i;\n\n\tvar rscriptType = /^$|\\/(?:java|ecma)script/i;\n\n\t// We have to close these tags to support XHTML (#13200)\n\tvar wrapMap = {\n\n\t\t// Support: IE <=9 only\n\t\toption: [1, "<select multiple=\'multiple\'>", "</select>"],\n\n\t\t// XHTML parsers do not magically insert elements in the\n\t\t// same way that tag soup parsers do. So we cannot shorten\n\t\t// this by omitting <tbody> or other required elements.\n\t\tthead: [1, "<table>", "</table>"],\n\t\tcol: [2, "<table><colgroup>", "</colgroup></table>"],\n\t\ttr: [2, "<table><tbody>", "</tbody></table>"],\n\t\ttd: [3, "<table><tbody><tr>", "</tr></tbody></table>"],\n\n\t\t_default: [0, "", ""]\n\t};\n\n\t// Support: IE <=9 only\n\twrapMap.optgroup = wrapMap.option;\n\n\twrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n\twrapMap.th = wrapMap.td;\n\n\tfunction getAll(context, tag) {\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\t\tvar ret;\n\n\t\tif (typeof context.getElementsByTagName !== "undefined") {\n\t\t\tret = context.getElementsByTagName(tag || "*");\n\t\t} else if (typeof context.querySelectorAll !== "undefined") {\n\t\t\tret = context.querySelectorAll(tag || "*");\n\t\t} else {\n\t\t\tret = [];\n\t\t}\n\n\t\tif (tag === undefined || tag && nodeName(context, tag)) {\n\t\t\treturn jQuery.merge([context], ret);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t// Mark scripts as having already been evaluated\n\tfunction setGlobalEval(elems, refElements) {\n\t\tvar i = 0,\n\t\t    l = elems.length;\n\n\t\tfor (; i < l; i++) {\n\t\t\tdataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));\n\t\t}\n\t}\n\n\tvar rhtml = /<|&#?\\w+;/;\n\n\tfunction buildFragment(elems, context, scripts, selection, ignored) {\n\t\tvar elem,\n\t\t    tmp,\n\t\t    tag,\n\t\t    wrap,\n\t\t    contains,\n\t\t    j,\n\t\t    fragment = context.createDocumentFragment(),\n\t\t    nodes = [],\n\t\t    i = 0,\n\t\t    l = elems.length;\n\n\t\tfor (; i < l; i++) {\n\t\t\telem = elems[i];\n\n\t\t\tif (elem || elem === 0) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif (jQuery.type(elem) === "object") {\n\n\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge(nodes, elem.nodeType ? [elem] : elem);\n\n\t\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if (!rhtml.test(elem)) {\n\t\t\t\t\tnodes.push(context.createTextNode(elem));\n\n\t\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild(context.createElement("div"));\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();\n\t\t\t\t\twrap = wrapMap[tag] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[0];\n\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge(nodes, tmp.childNodes);\n\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\t\ttmp.textContent = "";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = "";\n\n\t\ti = 0;\n\t\twhile (elem = nodes[i++]) {\n\n\t\t\t// Skip elements already in the context collection (trac-4087)\n\t\t\tif (selection && jQuery.inArray(elem, selection) > -1) {\n\t\t\t\tif (ignored) {\n\t\t\t\t\tignored.push(elem);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains(elem.ownerDocument, elem);\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll(fragment.appendChild(elem), "script");\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif (contains) {\n\t\t\t\tsetGlobalEval(tmp);\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif (scripts) {\n\t\t\t\tj = 0;\n\t\t\t\twhile (elem = tmp[j++]) {\n\t\t\t\t\tif (rscriptType.test(elem.type || "")) {\n\t\t\t\t\t\tscripts.push(elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fragment;\n\t}\n\n\t(function () {\n\t\tvar fragment = document.createDocumentFragment(),\n\t\t    div = fragment.appendChild(document.createElement("div")),\n\t\t    input = document.createElement("input");\n\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Check state lost if the name is set (#11217)\n\t\t// Support: Windows Web Apps (WWA)\n\t\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\t\tinput.setAttribute("type", "radio");\n\t\tinput.setAttribute("checked", "checked");\n\t\tinput.setAttribute("name", "t");\n\n\t\tdiv.appendChild(input);\n\n\t\t// Support: Android <=4.1 only\n\t\t// Older WebKit doesn\'t clone checked state correctly in fragments\n\t\tsupport.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;\n\n\t\t// Support: IE <=11 only\n\t\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t\tdiv.innerHTML = "<textarea>x</textarea>";\n\t\tsupport.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\n\t})();\n\tvar documentElement = document.documentElement;\n\n\tvar rkeyEvent = /^key/,\n\t    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\t    rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n\tfunction returnTrue() {\n\t\treturn true;\n\t}\n\n\tfunction returnFalse() {\n\t\treturn false;\n\t}\n\n\t// Support: IE <=9 only\n\t// See #13393 for more info\n\tfunction safeActiveElement() {\n\t\ttry {\n\t\t\treturn document.activeElement;\n\t\t} catch (err) {}\n\t}\n\n\tfunction _on(elem, types, selector, data, fn, one) {\n\t\tvar origFn, type;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {\n\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif (typeof selector !== "string") {\n\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor (type in types) {\n\t\t\t\t_on(elem, type, selector, data, types[type], one);\n\t\t\t}\n\t\t\treturn elem;\n\t\t}\n\n\t\tif (data == null && fn == null) {\n\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if (fn == null) {\n\t\t\tif (typeof selector === "string") {\n\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif (fn === false) {\n\t\t\tfn = returnFalse;\n\t\t} else if (!fn) {\n\t\t\treturn elem;\n\t\t}\n\n\t\tif (one === 1) {\n\t\t\torigFn = fn;\n\t\t\tfn = function fn(event) {\n\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off(event);\n\t\t\t\treturn origFn.apply(this, arguments);\n\t\t\t};\n\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n\t\t}\n\t\treturn elem.each(function () {\n\t\t\tjQuery.event.add(this, types, fn, data, selector);\n\t\t});\n\t}\n\n\t/*\n  * Helper functions for managing events -- not part of the public interface.\n  * Props to Dean Edwards\' addEvent library for many of the ideas.\n  */\n\tjQuery.event = {\n\n\t\tglobal: {},\n\n\t\tadd: function add(elem, types, handler, data, selector) {\n\n\t\t\tvar handleObjIn,\n\t\t\t    eventHandle,\n\t\t\t    tmp,\n\t\t\t    events,\n\t\t\t    t,\n\t\t\t    handleObj,\n\t\t\t    special,\n\t\t\t    handlers,\n\t\t\t    type,\n\t\t\t    namespaces,\n\t\t\t    origType,\n\t\t\t    elemData = dataPriv.get(elem);\n\n\t\t\t// Don\'t attach events to noData or text/comment nodes (but allow plain objects)\n\t\t\tif (!elemData) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\t\tif (handler.handler) {\n\t\t\t\thandleObjIn = handler;\n\t\t\t\thandler = handleObjIn.handler;\n\t\t\t\tselector = handleObjIn.selector;\n\t\t\t}\n\n\t\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\t\tif (selector) {\n\t\t\t\tjQuery.find.matchesSelector(documentElement, selector);\n\t\t\t}\n\n\t\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\t\tif (!handler.guid) {\n\t\t\t\thandler.guid = jQuery.guid++;\n\t\t\t}\n\n\t\t\t// Init the element\'s event structure and main handler, if this is the first\n\t\t\tif (!(events = elemData.events)) {\n\t\t\t\tevents = elemData.events = {};\n\t\t\t}\n\t\t\tif (!(eventHandle = elemData.handle)) {\n\t\t\t\teventHandle = elemData.handle = function (e) {\n\n\t\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\t\treturn typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Handle multiple events separated by a space\n\t\t\ttypes = (types || "").match(rnothtmlwhite) || [""];\n\t\t\tt = types.length;\n\t\t\twhile (t--) {\n\t\t\t\ttmp = rtypenamespace.exec(types[t]) || [];\n\t\t\t\ttype = origType = tmp[1];\n\t\t\t\tnamespaces = (tmp[2] || "").split(".").sort();\n\n\t\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\t\tif (!type) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\t\tspecial = jQuery.event.special[type] || {};\n\n\t\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\t\ttype = (selector ? special.delegateType : special.bindType) || type;\n\n\t\t\t\t// Update special based on newly reset type\n\t\t\t\tspecial = jQuery.event.special[type] || {};\n\n\t\t\t\t// handleObj is passed to all event handlers\n\t\t\t\thandleObj = jQuery.extend({\n\t\t\t\t\ttype: type,\n\t\t\t\t\torigType: origType,\n\t\t\t\t\tdata: data,\n\t\t\t\t\thandler: handler,\n\t\t\t\t\tguid: handler.guid,\n\t\t\t\t\tselector: selector,\n\t\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test(selector),\n\t\t\t\t\tnamespace: namespaces.join(".")\n\t\t\t\t}, handleObjIn);\n\n\t\t\t\t// Init the event handler queue if we\'re the first\n\t\t\t\tif (!(handlers = events[type])) {\n\t\t\t\t\thandlers = events[type] = [];\n\t\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\t\tif (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n\n\t\t\t\t\t\tif (elem.addEventListener) {\n\t\t\t\t\t\t\telem.addEventListener(type, eventHandle);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (special.add) {\n\t\t\t\t\tspecial.add.call(elem, handleObj);\n\n\t\t\t\t\tif (!handleObj.handler.guid) {\n\t\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add to the element\'s handler list, delegates in front\n\t\t\t\tif (selector) {\n\t\t\t\t\thandlers.splice(handlers.delegateCount++, 0, handleObj);\n\t\t\t\t} else {\n\t\t\t\t\thandlers.push(handleObj);\n\t\t\t\t}\n\n\t\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\t\tjQuery.event.global[type] = true;\n\t\t\t}\n\t\t},\n\n\t\t// Detach an event or set of events from an element\n\t\tremove: function remove(elem, types, handler, selector, mappedTypes) {\n\n\t\t\tvar j,\n\t\t\t    origCount,\n\t\t\t    tmp,\n\t\t\t    events,\n\t\t\t    t,\n\t\t\t    handleObj,\n\t\t\t    special,\n\t\t\t    handlers,\n\t\t\t    type,\n\t\t\t    namespaces,\n\t\t\t    origType,\n\t\t\t    elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\n\n\t\t\tif (!elemData || !(events = elemData.events)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Once for each type.namespace in types; type may be omitted\n\t\t\ttypes = (types || "").match(rnothtmlwhite) || [""];\n\t\t\tt = types.length;\n\t\t\twhile (t--) {\n\t\t\t\ttmp = rtypenamespace.exec(types[t]) || [];\n\t\t\t\ttype = origType = tmp[1];\n\t\t\t\tnamespaces = (tmp[2] || "").split(".").sort();\n\n\t\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\t\tif (!type) {\n\t\t\t\t\tfor (type in events) {\n\t\t\t\t\t\tjQuery.event.remove(elem, type + types[t], handler, selector, true);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tspecial = jQuery.event.special[type] || {};\n\t\t\t\ttype = (selector ? special.delegateType : special.bindType) || type;\n\t\t\t\thandlers = events[type] || [];\n\t\t\t\ttmp = tmp[2] && new RegExp("(^|\\\\.)" + namespaces.join("\\\\.(?:.*\\\\.|)") + "(\\\\.|$)");\n\n\t\t\t\t// Remove matching events\n\t\t\t\torigCount = j = handlers.length;\n\t\t\t\twhile (j--) {\n\t\t\t\t\thandleObj = handlers[j];\n\n\t\t\t\t\tif ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {\n\t\t\t\t\t\thandlers.splice(j, 1);\n\n\t\t\t\t\t\tif (handleObj.selector) {\n\t\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (special.remove) {\n\t\t\t\t\t\t\tspecial.remove.call(elem, handleObj);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\t\tif (origCount && !handlers.length) {\n\t\t\t\t\tif (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n\n\t\t\t\t\t\tjQuery.removeEvent(elem, type, elemData.handle);\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete events[type];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove data and the expando if it\'s no longer used\n\t\t\tif (jQuery.isEmptyObject(events)) {\n\t\t\t\tdataPriv.remove(elem, "handle events");\n\t\t\t}\n\t\t},\n\n\t\tdispatch: function dispatch(nativeEvent) {\n\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tvar event = jQuery.event.fix(nativeEvent);\n\n\t\t\tvar i,\n\t\t\t    j,\n\t\t\t    ret,\n\t\t\t    matched,\n\t\t\t    handleObj,\n\t\t\t    handlerQueue,\n\t\t\t    args = new Array(arguments.length),\n\t\t\t    handlers = (dataPriv.get(this, "events") || {})[event.type] || [],\n\t\t\t    special = jQuery.event.special[event.type] || {};\n\n\t\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\t\targs[0] = event;\n\n\t\t\tfor (i = 1; i < arguments.length; i++) {\n\t\t\t\targs[i] = arguments[i];\n\t\t\t}\n\n\t\t\tevent.delegateTarget = this;\n\n\t\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\t\tif (special.preDispatch && special.preDispatch.call(this, event) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Determine handlers\n\t\t\thandlerQueue = jQuery.event.handlers.call(this, event, handlers);\n\n\t\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\t\ti = 0;\n\t\t\twhile ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n\t\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\t\tj = 0;\n\t\t\t\twhile ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n\n\t\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\t\tif (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {\n\n\t\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\t\tret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n\t\t\t\t\t\tif (ret !== undefined) {\n\t\t\t\t\t\t\tif ((event.result = ret) === false) {\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Call the postDispatch hook for the mapped type\n\t\t\tif (special.postDispatch) {\n\t\t\t\tspecial.postDispatch.call(this, event);\n\t\t\t}\n\n\t\t\treturn event.result;\n\t\t},\n\n\t\thandlers: function handlers(event, _handlers) {\n\t\t\tvar i,\n\t\t\t    handleObj,\n\t\t\t    sel,\n\t\t\t    matchedHandlers,\n\t\t\t    matchedSelectors,\n\t\t\t    handlerQueue = [],\n\t\t\t    delegateCount = _handlers.delegateCount,\n\t\t\t    cur = event.target;\n\n\t\t\t// Find delegate handlers\n\t\t\tif (delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!(event.type === "click" && event.button >= 1)) {\n\n\t\t\t\tfor (; cur !== this; cur = cur.parentNode || this) {\n\n\t\t\t\t\t// Don\'t check non-elements (#13208)\n\t\t\t\t\t// Don\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\t\tif (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {\n\t\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\t\tfor (i = 0; i < delegateCount; i++) {\n\t\t\t\t\t\t\thandleObj = _handlers[i];\n\n\t\t\t\t\t\t\t// Don\'t conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\t\tsel = handleObj.selector + " ";\n\n\t\t\t\t\t\t\tif (matchedSelectors[sel] === undefined) {\n\t\t\t\t\t\t\t\tmatchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (matchedSelectors[sel]) {\n\t\t\t\t\t\t\t\tmatchedHandlers.push(handleObj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (matchedHandlers.length) {\n\t\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matchedHandlers });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the remaining (directly-bound) handlers\n\t\t\tcur = this;\n\t\t\tif (delegateCount < _handlers.length) {\n\t\t\t\thandlerQueue.push({ elem: cur, handlers: _handlers.slice(delegateCount) });\n\t\t\t}\n\n\t\t\treturn handlerQueue;\n\t\t},\n\n\t\taddProp: function addProp(name, hook) {\n\t\t\tObject.defineProperty(jQuery.Event.prototype, name, {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\n\t\t\t\tget: jQuery.isFunction(hook) ? function () {\n\t\t\t\t\tif (this.originalEvent) {\n\t\t\t\t\t\treturn hook(this.originalEvent);\n\t\t\t\t\t}\n\t\t\t\t} : function () {\n\t\t\t\t\tif (this.originalEvent) {\n\t\t\t\t\t\treturn this.originalEvent[name];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tset: function set(value) {\n\t\t\t\t\tObject.defineProperty(this, name, {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tfix: function fix(originalEvent) {\n\t\t\treturn originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);\n\t\t},\n\n\t\tspecial: {\n\t\t\tload: {\n\n\t\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\t\tnoBubble: true\n\t\t\t},\n\t\t\tfocus: {\n\n\t\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\t\ttrigger: function trigger() {\n\t\t\t\t\tif (this !== safeActiveElement() && this.focus) {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: "focusin"\n\t\t\t},\n\t\t\tblur: {\n\t\t\t\ttrigger: function trigger() {\n\t\t\t\t\tif (this === safeActiveElement() && this.blur) {\n\t\t\t\t\t\tthis.blur();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: "focusout"\n\t\t\t},\n\t\t\tclick: {\n\n\t\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\t\ttrigger: function trigger() {\n\t\t\t\t\tif (this.type === "checkbox" && this.click && nodeName(this, "input")) {\n\t\t\t\t\t\tthis.click();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// For cross-browser consistency, don\'t fire native .click() on links\n\t\t\t\t_default: function _default(event) {\n\t\t\t\t\treturn nodeName(event.target, "a");\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tbeforeunload: {\n\t\t\t\tpostDispatch: function postDispatch(event) {\n\n\t\t\t\t\t// Support: Firefox 20+\n\t\t\t\t\t// Firefox doesn\'t alert if the returnValue field is not set.\n\t\t\t\t\tif (event.result !== undefined && event.originalEvent) {\n\t\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.removeEvent = function (elem, type, handle) {\n\n\t\t// This "if" is needed for plain objects\n\t\tif (elem.removeEventListener) {\n\t\t\telem.removeEventListener(type, handle);\n\t\t}\n\t};\n\n\tjQuery.Event = function (src, props) {\n\n\t\t// Allow instantiation without the \'new\' keyword\n\t\tif (!(this instanceof jQuery.Event)) {\n\t\t\treturn new jQuery.Event(src, props);\n\t\t}\n\n\t\t// Event object\n\t\tif (src && src.type) {\n\t\t\tthis.originalEvent = src;\n\t\t\tthis.type = src.type;\n\n\t\t\t// Events bubbling up the document may have been marked as prevented\n\t\t\t// by a handler lower down the tree; reflect the correct value.\n\t\t\tthis.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&\n\n\t\t\t// Support: Android <=2.3 only\n\t\t\tsrc.returnValue === false ? returnTrue : returnFalse;\n\n\t\t\t// Create target properties\n\t\t\t// Support: Safari <=6 - 7 only\n\t\t\t// Target should not be a text node (#504, #13143)\n\t\t\tthis.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;\n\n\t\t\tthis.currentTarget = src.currentTarget;\n\t\t\tthis.relatedTarget = src.relatedTarget;\n\n\t\t\t// Event type\n\t\t} else {\n\t\t\tthis.type = src;\n\t\t}\n\n\t\t// Put explicitly provided properties onto the event object\n\t\tif (props) {\n\t\t\tjQuery.extend(this, props);\n\t\t}\n\n\t\t// Create a timestamp if incoming event doesn\'t have one\n\t\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t\t// Mark it as fixed\n\t\tthis[jQuery.expando] = true;\n\t};\n\n\t// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\t// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tjQuery.Event.prototype = {\n\t\tconstructor: jQuery.Event,\n\t\tisDefaultPrevented: returnFalse,\n\t\tisPropagationStopped: returnFalse,\n\t\tisImmediatePropagationStopped: returnFalse,\n\t\tisSimulated: false,\n\n\t\tpreventDefault: function preventDefault() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\t\tif (e && !this.isSimulated) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t},\n\t\tstopPropagation: function stopPropagation() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isPropagationStopped = returnTrue;\n\n\t\t\tif (e && !this.isSimulated) {\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\t\t},\n\t\tstopImmediatePropagation: function stopImmediatePropagation() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\t\tif (e && !this.isSimulated) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t}\n\n\t\t\tthis.stopPropagation();\n\t\t}\n\t};\n\n\t// Includes all common event props including KeyEvent and MouseEvent specific props\n\tjQuery.each({\n\t\taltKey: true,\n\t\tbubbles: true,\n\t\tcancelable: true,\n\t\tchangedTouches: true,\n\t\tctrlKey: true,\n\t\tdetail: true,\n\t\teventPhase: true,\n\t\tmetaKey: true,\n\t\tpageX: true,\n\t\tpageY: true,\n\t\tshiftKey: true,\n\t\tview: true,\n\t\t"char": true,\n\t\tcharCode: true,\n\t\tkey: true,\n\t\tkeyCode: true,\n\t\tbutton: true,\n\t\tbuttons: true,\n\t\tclientX: true,\n\t\tclientY: true,\n\t\toffsetX: true,\n\t\toffsetY: true,\n\t\tpointerId: true,\n\t\tpointerType: true,\n\t\tscreenX: true,\n\t\tscreenY: true,\n\t\ttargetTouches: true,\n\t\ttoElement: true,\n\t\ttouches: true,\n\n\t\twhich: function which(event) {\n\t\t\tvar button = event.button;\n\n\t\t\t// Add which for key events\n\t\t\tif (event.which == null && rkeyEvent.test(event.type)) {\n\t\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\tif (!event.which && button !== undefined && rmouseEvent.test(event.type)) {\n\t\t\t\tif (button & 1) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tif (button & 2) {\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\n\t\t\t\tif (button & 4) {\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\treturn event.which;\n\t\t}\n\t}, jQuery.event.addProp);\n\n\t// Create mouseenter/leave events using mouseover/out and event-time checks\n\t// so that event delegation works in jQuery.\n\t// Do the same for pointerenter/pointerleave and pointerover/pointerout\n\t//\n\t// Support: Safari 7 only\n\t// Safari sends mouseenter too often; see:\n\t// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n\t// for the description of the bug (it existed in older Chrome versions as well).\n\tjQuery.each({\n\t\tmouseenter: "mouseover",\n\t\tmouseleave: "mouseout",\n\t\tpointerenter: "pointerover",\n\t\tpointerleave: "pointerout"\n\t}, function (orig, fix) {\n\t\tjQuery.event.special[orig] = {\n\t\t\tdelegateType: fix,\n\t\t\tbindType: fix,\n\n\t\t\thandle: function handle(event) {\n\t\t\t\tvar ret,\n\t\t\t\t    target = this,\n\t\t\t\t    related = event.relatedTarget,\n\t\t\t\t    handleObj = event.handleObj;\n\n\t\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\t\tif (!related || related !== target && !jQuery.contains(target, related)) {\n\t\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\t\tret = handleObj.handler.apply(this, arguments);\n\t\t\t\t\tevent.type = fix;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t};\n\t});\n\n\tjQuery.fn.extend({\n\n\t\ton: function on(types, selector, data, fn) {\n\t\t\treturn _on(this, types, selector, data, fn);\n\t\t},\n\t\tone: function one(types, selector, data, fn) {\n\t\t\treturn _on(this, types, selector, data, fn, 1);\n\t\t},\n\t\toff: function off(types, selector, fn) {\n\t\t\tvar handleObj, type;\n\t\t\tif (types && types.preventDefault && types.handleObj) {\n\n\t\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\t\thandleObj = types.handleObj;\n\t\t\t\tjQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {\n\n\t\t\t\t// ( types-object [, selector] )\n\t\t\t\tfor (type in types) {\n\t\t\t\t\tthis.off(type, selector, types[type]);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif (selector === false || typeof selector === "function") {\n\n\t\t\t\t// ( types [, fn] )\n\t\t\t\tfn = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tif (fn === false) {\n\t\t\t\tfn = returnFalse;\n\t\t\t}\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.event.remove(this, types, fn, selector);\n\t\t\t});\n\t\t}\n\t});\n\n\tvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\n\t// checked="checked" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\t    rscriptTypeMasked = /^true\\/(.*)/,\n\t    rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n\t// Prefer a tbody over its parent table for containing new rows\n\tfunction manipulationTarget(elem, content) {\n\t\tif (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {\n\n\t\t\treturn jQuery(">tbody", elem)[0] || elem;\n\t\t}\n\n\t\treturn elem;\n\t}\n\n\t// Replace/restore the type attribute of script elements for safe DOM manipulation\n\tfunction disableScript(elem) {\n\t\telem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;\n\t\treturn elem;\n\t}\n\tfunction restoreScript(elem) {\n\t\tvar match = rscriptTypeMasked.exec(elem.type);\n\n\t\tif (match) {\n\t\t\telem.type = match[1];\n\t\t} else {\n\t\t\telem.removeAttribute("type");\n\t\t}\n\n\t\treturn elem;\n\t}\n\n\tfunction cloneCopyEvent(src, dest) {\n\t\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\t\tif (dest.nodeType !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\t// 1. Copy private data: events, handlers, etc.\n\t\tif (dataPriv.hasData(src)) {\n\t\t\tpdataOld = dataPriv.access(src);\n\t\t\tpdataCur = dataPriv.set(dest, pdataOld);\n\t\t\tevents = pdataOld.events;\n\n\t\t\tif (events) {\n\t\t\t\tdelete pdataCur.handle;\n\t\t\t\tpdataCur.events = {};\n\n\t\t\t\tfor (type in events) {\n\t\t\t\t\tfor (i = 0, l = events[type].length; i < l; i++) {\n\t\t\t\t\t\tjQuery.event.add(dest, type, events[type][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2. Copy user data\n\t\tif (dataUser.hasData(src)) {\n\t\t\tudataOld = dataUser.access(src);\n\t\t\tudataCur = jQuery.extend({}, udataOld);\n\n\t\t\tdataUser.set(dest, udataCur);\n\t\t}\n\t}\n\n\t// Fix IE bugs, see support tests\n\tfunction fixInput(src, dest) {\n\t\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\t\tif (nodeName === "input" && rcheckableType.test(src.type)) {\n\t\t\tdest.checked = src.checked;\n\n\t\t\t// Fails to return the selected option to the default selected state when cloning options\n\t\t} else if (nodeName === "input" || nodeName === "textarea") {\n\t\t\tdest.defaultValue = src.defaultValue;\n\t\t}\n\t}\n\n\tfunction domManip(collection, args, callback, ignored) {\n\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply([], args);\n\n\t\tvar fragment,\n\t\t    first,\n\t\t    scripts,\n\t\t    hasScripts,\n\t\t    node,\n\t\t    doc,\n\t\t    i = 0,\n\t\t    l = collection.length,\n\t\t    iNoClone = l - 1,\n\t\t    value = args[0],\n\t\t    isFunction = jQuery.isFunction(value);\n\n\t\t// We can\'t cloneNode fragments that contain checked, in WebKit\n\t\tif (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {\n\t\t\treturn collection.each(function (index) {\n\t\t\t\tvar self = collection.eq(index);\n\t\t\t\tif (isFunction) {\n\t\t\t\t\targs[0] = value.call(this, index, self.html());\n\t\t\t\t}\n\t\t\t\tdomManip(self, args, callback, ignored);\n\t\t\t});\n\t\t}\n\n\t\tif (l) {\n\t\t\tfragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif (fragment.childNodes.length === 1) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\t\tif (first || ignored) {\n\t\t\t\tscripts = jQuery.map(getAll(fragment, "script"), disableScript);\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item\n\t\t\t\t// instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif (i !== iNoClone) {\n\t\t\t\t\t\tnode = jQuery.clone(node, true, true);\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif (hasScripts) {\n\n\t\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\t\tjQuery.merge(scripts, getAll(node, "script"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call(collection[i], node, i);\n\t\t\t\t}\n\n\t\t\t\tif (hasScripts) {\n\t\t\t\t\tdoc = scripts[scripts.length - 1].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map(scripts, restoreScript);\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor (i = 0; i < hasScripts; i++) {\n\t\t\t\t\t\tnode = scripts[i];\n\t\t\t\t\t\tif (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {\n\n\t\t\t\t\t\t\tif (node.src) {\n\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won\'t run scripts if not present\n\t\t\t\t\t\t\t\tif (jQuery._evalUrl) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl(node.src);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDOMEval(node.textContent.replace(rcleanScript, ""), doc);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn collection;\n\t}\n\n\tfunction _remove(elem, selector, keepData) {\n\t\tvar node,\n\t\t    nodes = selector ? jQuery.filter(selector, elem) : elem,\n\t\t    i = 0;\n\n\t\tfor (; (node = nodes[i]) != null; i++) {\n\t\t\tif (!keepData && node.nodeType === 1) {\n\t\t\t\tjQuery.cleanData(getAll(node));\n\t\t\t}\n\n\t\t\tif (node.parentNode) {\n\t\t\t\tif (keepData && jQuery.contains(node.ownerDocument, node)) {\n\t\t\t\t\tsetGlobalEval(getAll(node, "script"));\n\t\t\t\t}\n\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t}\n\t\t}\n\n\t\treturn elem;\n\t}\n\n\tjQuery.extend({\n\t\thtmlPrefilter: function htmlPrefilter(html) {\n\t\t\treturn html.replace(rxhtmlTag, "<$1></$2>");\n\t\t},\n\n\t\tclone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n\t\t\tvar i,\n\t\t\t    l,\n\t\t\t    srcElements,\n\t\t\t    destElements,\n\t\t\t    clone = elem.cloneNode(true),\n\t\t\t    inPage = jQuery.contains(elem.ownerDocument, elem);\n\n\t\t\t// Fix IE cloning issues\n\t\t\tif (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n\n\t\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\t\tdestElements = getAll(clone);\n\t\t\t\tsrcElements = getAll(elem);\n\n\t\t\t\tfor (i = 0, l = srcElements.length; i < l; i++) {\n\t\t\t\t\tfixInput(srcElements[i], destElements[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Copy the events from the original to the clone\n\t\t\tif (dataAndEvents) {\n\t\t\t\tif (deepDataAndEvents) {\n\t\t\t\t\tsrcElements = srcElements || getAll(elem);\n\t\t\t\t\tdestElements = destElements || getAll(clone);\n\n\t\t\t\t\tfor (i = 0, l = srcElements.length; i < l; i++) {\n\t\t\t\t\t\tcloneCopyEvent(srcElements[i], destElements[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcloneCopyEvent(elem, clone);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Preserve script evaluation history\n\t\t\tdestElements = getAll(clone, "script");\n\t\t\tif (destElements.length > 0) {\n\t\t\t\tsetGlobalEval(destElements, !inPage && getAll(elem, "script"));\n\t\t\t}\n\n\t\t\t// Return the cloned set\n\t\t\treturn clone;\n\t\t},\n\n\t\tcleanData: function cleanData(elems) {\n\t\t\tvar data,\n\t\t\t    elem,\n\t\t\t    type,\n\t\t\t    special = jQuery.event.special,\n\t\t\t    i = 0;\n\n\t\t\tfor (; (elem = elems[i]) !== undefined; i++) {\n\t\t\t\tif (acceptData(elem)) {\n\t\t\t\t\tif (data = elem[dataPriv.expando]) {\n\t\t\t\t\t\tif (data.events) {\n\t\t\t\t\t\t\tfor (type in data.events) {\n\t\t\t\t\t\t\t\tif (special[type]) {\n\t\t\t\t\t\t\t\t\tjQuery.event.remove(elem, type);\n\n\t\t\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove\'s overhead\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.removeEvent(elem, type, data.handle);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\t\telem[dataPriv.expando] = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tif (elem[dataUser.expando]) {\n\n\t\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\t\telem[dataUser.expando] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tdetach: function detach(selector) {\n\t\t\treturn _remove(this, selector, true);\n\t\t},\n\n\t\tremove: function remove(selector) {\n\t\t\treturn _remove(this, selector);\n\t\t},\n\n\t\ttext: function text(value) {\n\t\t\treturn access(this, function (value) {\n\t\t\t\treturn value === undefined ? jQuery.text(this) : this.empty().each(function () {\n\t\t\t\t\tif (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, null, value, arguments.length);\n\t\t},\n\n\t\tappend: function append() {\n\t\t\treturn domManip(this, arguments, function (elem) {\n\t\t\t\tif (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n\t\t\t\t\tvar target = manipulationTarget(this, elem);\n\t\t\t\t\ttarget.appendChild(elem);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tprepend: function prepend() {\n\t\t\treturn domManip(this, arguments, function (elem) {\n\t\t\t\tif (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n\t\t\t\t\tvar target = manipulationTarget(this, elem);\n\t\t\t\t\ttarget.insertBefore(elem, target.firstChild);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tbefore: function before() {\n\t\t\treturn domManip(this, arguments, function (elem) {\n\t\t\t\tif (this.parentNode) {\n\t\t\t\t\tthis.parentNode.insertBefore(elem, this);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tafter: function after() {\n\t\t\treturn domManip(this, arguments, function (elem) {\n\t\t\t\tif (this.parentNode) {\n\t\t\t\t\tthis.parentNode.insertBefore(elem, this.nextSibling);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tempty: function empty() {\n\t\t\tvar elem,\n\t\t\t    i = 0;\n\n\t\t\tfor (; (elem = this[i]) != null; i++) {\n\t\t\t\tif (elem.nodeType === 1) {\n\n\t\t\t\t\t// Prevent memory leaks\n\t\t\t\t\tjQuery.cleanData(getAll(elem, false));\n\n\t\t\t\t\t// Remove any remaining nodes\n\t\t\t\t\telem.textContent = "";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tclone: function clone(dataAndEvents, deepDataAndEvents) {\n\t\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\t\treturn this.map(function () {\n\t\t\t\treturn jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n\t\t\t});\n\t\t},\n\n\t\thtml: function html(value) {\n\t\t\treturn access(this, function (value) {\n\t\t\t\tvar elem = this[0] || {},\n\t\t\t\t    i = 0,\n\t\t\t\t    l = this.length;\n\n\t\t\t\tif (value === undefined && elem.nodeType === 1) {\n\t\t\t\t\treturn elem.innerHTML;\n\t\t\t\t}\n\n\t\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\t\tif (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {\n\n\t\t\t\t\tvalue = jQuery.htmlPrefilter(value);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\t\t\telem = this[i] || {};\n\n\t\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\t\tif (elem.nodeType === 1) {\n\t\t\t\t\t\t\t\tjQuery.cleanData(getAll(elem, false));\n\t\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telem = 0;\n\n\t\t\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t}\n\n\t\t\t\tif (elem) {\n\t\t\t\t\tthis.empty().append(value);\n\t\t\t\t}\n\t\t\t}, null, value, arguments.length);\n\t\t},\n\n\t\treplaceWith: function replaceWith() {\n\t\t\tvar ignored = [];\n\n\t\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\t\treturn domManip(this, arguments, function (elem) {\n\t\t\t\tvar parent = this.parentNode;\n\n\t\t\t\tif (jQuery.inArray(this, ignored) < 0) {\n\t\t\t\t\tjQuery.cleanData(getAll(this));\n\t\t\t\t\tif (parent) {\n\t\t\t\t\t\tparent.replaceChild(elem, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Force callback invocation\n\t\t\t}, ignored);\n\t\t}\n\t});\n\n\tjQuery.each({\n\t\tappendTo: "append",\n\t\tprependTo: "prepend",\n\t\tinsertBefore: "before",\n\t\tinsertAfter: "after",\n\t\treplaceAll: "replaceWith"\n\t}, function (name, original) {\n\t\tjQuery.fn[name] = function (selector) {\n\t\t\tvar elems,\n\t\t\t    ret = [],\n\t\t\t    insert = jQuery(selector),\n\t\t\t    last = insert.length - 1,\n\t\t\t    i = 0;\n\n\t\t\tfor (; i <= last; i++) {\n\t\t\t\telems = i === last ? this : this.clone(true);\n\t\t\t\tjQuery(insert[i])[original](elems);\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tpush.apply(ret, elems.get());\n\t\t\t}\n\n\t\t\treturn this.pushStack(ret);\n\t\t};\n\t});\n\tvar rmargin = /^margin/;\n\n\tvar rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");\n\n\tvar getStyles = function getStyles(elem) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif (!view || !view.opener) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle(elem);\n\t};\n\n\t(function () {\n\n\t\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t\t// so they\'re executed at the same time to save the second computation.\n\t\tfunction computeStyleTests() {\n\n\t\t\t// This is a singleton, we need to execute it only once\n\t\t\tif (!div) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdiv.style.cssText = "box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";\n\t\t\tdiv.innerHTML = "";\n\t\t\tdocumentElement.appendChild(container);\n\n\t\t\tvar divStyle = window.getComputedStyle(div);\n\t\t\tpixelPositionVal = divStyle.top !== "1%";\n\n\t\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\t\treliableMarginLeftVal = divStyle.marginLeft === "2px";\n\t\t\tboxSizingReliableVal = divStyle.width === "4px";\n\n\t\t\t// Support: Android 4.0 - 4.3 only\n\t\t\t// Some styles come back with percentage values, even though they shouldn\'t\n\t\t\tdiv.style.marginRight = "50%";\n\t\t\tpixelMarginRightVal = divStyle.marginRight === "4px";\n\n\t\t\tdocumentElement.removeChild(container);\n\n\t\t\t// Nullify the div so it wouldn\'t be stored in the memory and\n\t\t\t// it will also be a sign that checks already performed\n\t\t\tdiv = null;\n\t\t}\n\n\t\tvar pixelPositionVal,\n\t\t    boxSizingReliableVal,\n\t\t    pixelMarginRightVal,\n\t\t    reliableMarginLeftVal,\n\t\t    container = document.createElement("div"),\n\t\t    div = document.createElement("div");\n\n\t\t// Finish early in limited (non-browser) environments\n\t\tif (!div.style) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// Style of cloned element affects source element cloned (#8908)\n\t\tdiv.style.backgroundClip = "content-box";\n\t\tdiv.cloneNode(true).style.backgroundClip = "";\n\t\tsupport.clearCloneStyle = div.style.backgroundClip === "content-box";\n\n\t\tcontainer.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";\n\t\tcontainer.appendChild(div);\n\n\t\tjQuery.extend(support, {\n\t\t\tpixelPosition: function pixelPosition() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\t\t\tboxSizingReliable: function boxSizingReliable() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\t\t\tpixelMarginRight: function pixelMarginRight() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn pixelMarginRightVal;\n\t\t\t},\n\t\t\treliableMarginLeft: function reliableMarginLeft() {\n\t\t\t\tcomputeStyleTests();\n\t\t\t\treturn reliableMarginLeftVal;\n\t\t\t}\n\t\t});\n\t})();\n\n\tfunction curCSS(elem, name, computed) {\n\t\tvar width,\n\t\t    minWidth,\n\t\t    maxWidth,\n\t\t    ret,\n\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\t\tcomputed = computed || getStyles(elem);\n\n\t\t// getPropertyValue is needed for:\n\t\t//   .css(\'filter\') (IE 9 only, #12537)\n\t\t//   .css(\'--customProperty) (#3144)\n\t\tif (computed) {\n\t\t\tret = computed.getPropertyValue(name) || computed[name];\n\n\t\t\tif (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {\n\t\t\t\tret = jQuery.style(elem, name);\n\t\t\t}\n\n\t\t\t// A tribute to the "awesome hack by Dean Edwards"\n\t\t\t// Android Browser returns percentage for some values,\n\t\t\t// but width seems to be reliably pixels.\n\t\t\t// This is against the CSSOM draft spec:\n\t\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\t\tif (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {\n\n\t\t\t\t// Remember the original values\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\n\t\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + "" : ret;\n\t}\n\n\tfunction addGetHookIf(conditionFn, hookFn) {\n\n\t\t// Define the hook, we\'ll check on the first run if it\'s really needed.\n\t\treturn {\n\t\t\tget: function get() {\n\t\t\t\tif (conditionFn()) {\n\n\t\t\t\t\t// Hook not needed (or it\'s not possible to use it due\n\t\t\t\t\t// to missing dependency), remove it.\n\t\t\t\t\tdelete this.get;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\t\treturn (this.get = hookFn).apply(this, arguments);\n\t\t\t}\n\t\t};\n\t}\n\n\tvar\n\n\t// Swappable if display is none or starts with table\n\t// except "table", "table-cell", or "table-caption"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\t    rcustomProp = /^--/,\n\t    cssShow = { position: "absolute", visibility: "hidden", display: "block" },\n\t    cssNormalTransform = {\n\t\tletterSpacing: "0",\n\t\tfontWeight: "400"\n\t},\n\t    cssPrefixes = ["Webkit", "Moz", "ms"],\n\t    emptyStyle = document.createElement("div").style;\n\n\t// Return a css property mapped to a potentially vendor prefixed property\n\tfunction vendorPropName(name) {\n\n\t\t// Shortcut for names that are not vendor prefixed\n\t\tif (name in emptyStyle) {\n\t\t\treturn name;\n\t\t}\n\n\t\t// Check for vendor prefixed names\n\t\tvar capName = name[0].toUpperCase() + name.slice(1),\n\t\t    i = cssPrefixes.length;\n\n\t\twhile (i--) {\n\t\t\tname = cssPrefixes[i] + capName;\n\t\t\tif (name in emptyStyle) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return a property mapped along what jQuery.cssProps suggests or to\n\t// a vendor prefixed property.\n\tfunction finalPropName(name) {\n\t\tvar ret = jQuery.cssProps[name];\n\t\tif (!ret) {\n\t\t\tret = jQuery.cssProps[name] = vendorPropName(name) || name;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tfunction setPositiveNumber(elem, value, subtract) {\n\n\t\t// Any relative (+/-) values have already been\n\t\t// normalized at this point\n\t\tvar matches = rcssNum.exec(value);\n\t\treturn matches ?\n\n\t\t// Guard against undefined "subtract", e.g., when used as in cssHooks\n\t\tMath.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;\n\t}\n\n\tfunction augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n\t\tvar i,\n\t\t    val = 0;\n\n\t\t// If we already have the right measurement, avoid augmentation\n\t\tif (extra === (isBorderBox ? "border" : "content")) {\n\t\t\ti = 4;\n\n\t\t\t// Otherwise initialize for horizontal or vertical properties\n\t\t} else {\n\t\t\ti = name === "width" ? 1 : 0;\n\t\t}\n\n\t\tfor (; i < 4; i += 2) {\n\n\t\t\t// Both box models exclude margin, so add it if we want it\n\t\t\tif (extra === "margin") {\n\t\t\t\tval += jQuery.css(elem, extra + cssExpand[i], true, styles);\n\t\t\t}\n\n\t\t\tif (isBorderBox) {\n\n\t\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\t\tif (extra === "content") {\n\t\t\t\t\tval -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);\n\t\t\t\t}\n\n\t\t\t\t// At this point, extra isn\'t border nor margin, so remove border\n\t\t\t\tif (extra !== "margin") {\n\t\t\t\t\tval -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// At this point, extra isn\'t content, so add padding\n\t\t\t\tval += jQuery.css(elem, "padding" + cssExpand[i], true, styles);\n\n\t\t\t\t// At this point, extra isn\'t content nor padding, so add border\n\t\t\t\tif (extra !== "padding") {\n\t\t\t\t\tval += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn val;\n\t}\n\n\tfunction getWidthOrHeight(elem, name, extra) {\n\n\t\t// Start with computed style\n\t\tvar valueIsBorderBox,\n\t\t    styles = getStyles(elem),\n\t\t    val = curCSS(elem, name, styles),\n\t\t    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif (rnumnonpx.test(val)) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);\n\n\t\t// Fall back to offsetWidth/Height when value is "auto"\n\t\t// This happens for inline elements with no explicit setting (gh-3571)\n\t\tif (val === "auto") {\n\t\t\tval = elem["offset" + name[0].toUpperCase() + name.slice(1)];\n\t\t}\n\n\t\t// Normalize "", auto, and prepare for extra\n\t\tval = parseFloat(val) || 0;\n\n\t\t// Use the active box-sizing model to add/subtract irrelevant styles\n\t\treturn val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";\n\t}\n\n\tjQuery.extend({\n\n\t\t// Add in style property hooks for overriding the default\n\t\t// behavior of getting and setting a style property\n\t\tcssHooks: {\n\t\t\topacity: {\n\t\t\t\tget: function get(elem, computed) {\n\t\t\t\t\tif (computed) {\n\n\t\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\t\tvar ret = curCSS(elem, "opacity");\n\t\t\t\t\t\treturn ret === "" ? "1" : ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Don\'t automatically add "px" to these possibly-unitless properties\n\t\tcssNumber: {\n\t\t\t"animationIterationCount": true,\n\t\t\t"columnCount": true,\n\t\t\t"fillOpacity": true,\n\t\t\t"flexGrow": true,\n\t\t\t"flexShrink": true,\n\t\t\t"fontWeight": true,\n\t\t\t"lineHeight": true,\n\t\t\t"opacity": true,\n\t\t\t"order": true,\n\t\t\t"orphans": true,\n\t\t\t"widows": true,\n\t\t\t"zIndex": true,\n\t\t\t"zoom": true\n\t\t},\n\n\t\t// Add in properties whose names you wish to fix before\n\t\t// setting or getting the value\n\t\tcssProps: {\n\t\t\t"float": "cssFloat"\n\t\t},\n\n\t\t// Get and set the style property on a DOM Node\n\t\tstyle: function style(elem, name, value, extra) {\n\n\t\t\t// Don\'t set styles on text and comment nodes\n\t\t\tif (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Make sure that we\'re working with the right name\n\t\t\tvar ret,\n\t\t\t    type,\n\t\t\t    hooks,\n\t\t\t    origName = jQuery.camelCase(name),\n\t\t\t    isCustomProp = rcustomProp.test(name),\n\t\t\t    style = elem.style;\n\n\t\t\t// Make sure that we\'re working with the right name. We don\'t\n\t\t\t// want to query the value if it is a CSS custom property\n\t\t\t// since they are user-defined.\n\t\t\tif (!isCustomProp) {\n\t\t\t\tname = finalPropName(origName);\n\t\t\t}\n\n\t\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\t\thooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n\n\t\t\t// Check if we\'re setting a value\n\t\t\tif (value !== undefined) {\n\t\t\t\ttype = typeof value === "undefined" ? "undefined" : _typeof(value);\n\n\t\t\t\t// Convert "+=" or "-=" to relative numbers (#7345)\n\t\t\t\tif (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {\n\t\t\t\t\tvalue = adjustCSS(elem, name, ret);\n\n\t\t\t\t\t// Fixes bug #9237\n\t\t\t\t\ttype = "number";\n\t\t\t\t}\n\n\t\t\t\t// Make sure that null and NaN values aren\'t set (#7116)\n\t\t\t\tif (value == null || value !== value) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t\tif (type === "number") {\n\t\t\t\t\tvalue += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");\n\t\t\t\t}\n\n\t\t\t\t// background-* props affect original clone\'s values\n\t\t\t\tif (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {\n\t\t\t\t\tstyle[name] = "inherit";\n\t\t\t\t}\n\n\t\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\t\tif (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n\n\t\t\t\t\tif (isCustomProp) {\n\t\t\t\t\t\tstyle.setProperty(name, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstyle[name] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\t\tif (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise just get the value from the style object\n\t\t\t\treturn style[name];\n\t\t\t}\n\t\t},\n\n\t\tcss: function css(elem, name, extra, styles) {\n\t\t\tvar val,\n\t\t\t    num,\n\t\t\t    hooks,\n\t\t\t    origName = jQuery.camelCase(name),\n\t\t\t    isCustomProp = rcustomProp.test(name);\n\n\t\t\t// Make sure that we\'re working with the right name. We don\'t\n\t\t\t// want to modify the value if it is a CSS custom property\n\t\t\t// since they are user-defined.\n\t\t\tif (!isCustomProp) {\n\t\t\t\tname = finalPropName(origName);\n\t\t\t}\n\n\t\t\t// Try prefixed name followed by the unprefixed name\n\t\t\thooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n\n\t\t\t// If a hook was provided get the computed value from there\n\t\t\tif (hooks && "get" in hooks) {\n\t\t\t\tval = hooks.get(elem, true, extra);\n\t\t\t}\n\n\t\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\t\tif (val === undefined) {\n\t\t\t\tval = curCSS(elem, name, styles);\n\t\t\t}\n\n\t\t\t// Convert "normal" to computed value\n\t\t\tif (val === "normal" && name in cssNormalTransform) {\n\t\t\t\tval = cssNormalTransform[name];\n\t\t\t}\n\n\t\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\t\tif (extra === "" || extra) {\n\t\t\t\tnum = parseFloat(val);\n\t\t\t\treturn extra === true || isFinite(num) ? num || 0 : val;\n\t\t\t}\n\n\t\t\treturn val;\n\t\t}\n\t});\n\n\tjQuery.each(["height", "width"], function (i, name) {\n\t\tjQuery.cssHooks[name] = {\n\t\t\tget: function get(elem, computed, extra) {\n\t\t\t\tif (computed) {\n\n\t\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\t\treturn rdisplayswap.test(jQuery.css(elem, "display")) && (\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {\n\t\t\t\t\t\treturn getWidthOrHeight(elem, name, extra);\n\t\t\t\t\t}) : getWidthOrHeight(elem, name, extra);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset: function set(elem, value, extra) {\n\t\t\t\tvar matches,\n\t\t\t\t    styles = extra && getStyles(elem),\n\t\t\t\t    subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);\n\n\t\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\t\tif (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {\n\n\t\t\t\t\telem.style[name] = value;\n\t\t\t\t\tvalue = jQuery.css(elem, name);\n\t\t\t\t}\n\n\t\t\t\treturn setPositiveNumber(elem, value, subtract);\n\t\t\t}\n\t\t};\n\t});\n\n\tjQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\n\t\tif (computed) {\n\t\t\treturn (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {\n\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t})) + "px";\n\t\t}\n\t});\n\n\t// These hooks are used by animate to expand properties\n\tjQuery.each({\n\t\tmargin: "",\n\t\tpadding: "",\n\t\tborder: "Width"\n\t}, function (prefix, suffix) {\n\t\tjQuery.cssHooks[prefix + suffix] = {\n\t\t\texpand: function expand(value) {\n\t\t\t\tvar i = 0,\n\t\t\t\t    expanded = {},\n\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === "string" ? value.split(" ") : [value];\n\n\t\t\t\tfor (; i < 4; i++) {\n\t\t\t\t\texpanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n\t\t\t\t}\n\n\t\t\t\treturn expanded;\n\t\t\t}\n\t\t};\n\n\t\tif (!rmargin.test(prefix)) {\n\t\t\tjQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tcss: function css(name, value) {\n\t\t\treturn access(this, function (elem, name, value) {\n\t\t\t\tvar styles,\n\t\t\t\t    len,\n\t\t\t\t    map = {},\n\t\t\t\t    i = 0;\n\n\t\t\t\tif (Array.isArray(name)) {\n\t\t\t\t\tstyles = getStyles(elem);\n\t\t\t\t\tlen = name.length;\n\n\t\t\t\t\tfor (; i < len; i++) {\n\t\t\t\t\t\tmap[name[i]] = jQuery.css(elem, name[i], false, styles);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\n\t\t\t\treturn value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n\t\t\t}, name, value, arguments.length > 1);\n\t\t}\n\t});\n\n\tfunction Tween(elem, options, prop, end, easing) {\n\t\treturn new Tween.prototype.init(elem, options, prop, end, easing);\n\t}\n\tjQuery.Tween = Tween;\n\n\tTween.prototype = {\n\t\tconstructor: Tween,\n\t\tinit: function init(elem, options, prop, end, easing, unit) {\n\t\t\tthis.elem = elem;\n\t\t\tthis.prop = prop;\n\t\t\tthis.easing = easing || jQuery.easing._default;\n\t\t\tthis.options = options;\n\t\t\tthis.start = this.now = this.cur();\n\t\t\tthis.end = end;\n\t\t\tthis.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");\n\t\t},\n\t\tcur: function cur() {\n\t\t\tvar hooks = Tween.propHooks[this.prop];\n\n\t\t\treturn hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n\t\t},\n\t\trun: function run(percent) {\n\t\t\tvar eased,\n\t\t\t    hooks = Tween.propHooks[this.prop];\n\n\t\t\tif (this.options.duration) {\n\t\t\t\tthis.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n\t\t\t} else {\n\t\t\t\tthis.pos = eased = percent;\n\t\t\t}\n\t\t\tthis.now = (this.end - this.start) * eased + this.start;\n\n\t\t\tif (this.options.step) {\n\t\t\t\tthis.options.step.call(this.elem, this.now, this);\n\t\t\t}\n\n\t\t\tif (hooks && hooks.set) {\n\t\t\t\thooks.set(this);\n\t\t\t} else {\n\t\t\t\tTween.propHooks._default.set(this);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t};\n\n\tTween.prototype.init.prototype = Tween.prototype;\n\n\tTween.propHooks = {\n\t\t_default: {\n\t\t\tget: function get(tween) {\n\t\t\t\tvar result;\n\n\t\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t\t// or when there is no matching style property that exists.\n\t\t\t\tif (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {\n\t\t\t\t\treturn tween.elem[tween.prop];\n\t\t\t\t}\n\n\t\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t\t// Simple values such as "10px" are parsed to Float;\n\t\t\t\t// complex values such as "rotate(1rad)" are returned as-is.\n\t\t\t\tresult = jQuery.css(tween.elem, tween.prop, "");\n\n\t\t\t\t// Empty strings, null, undefined and "auto" are converted to 0.\n\t\t\t\treturn !result || result === "auto" ? 0 : result;\n\t\t\t},\n\t\t\tset: function set(tween) {\n\n\t\t\t\t// Use step hook for back compat.\n\t\t\t\t// Use cssHook if its there.\n\t\t\t\t// Use .style if available and use plain properties where available.\n\t\t\t\tif (jQuery.fx.step[tween.prop]) {\n\t\t\t\t\tjQuery.fx.step[tween.prop](tween);\n\t\t\t\t} else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {\n\t\t\t\t\tjQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n\t\t\t\t} else {\n\t\t\t\t\ttween.elem[tween.prop] = tween.now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Support: IE <=9 only\n\t// Panic based approach to setting things on disconnected nodes\n\tTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\t\tset: function set(tween) {\n\t\t\tif (tween.elem.nodeType && tween.elem.parentNode) {\n\t\t\t\ttween.elem[tween.prop] = tween.now;\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.easing = {\n\t\tlinear: function linear(p) {\n\t\t\treturn p;\n\t\t},\n\t\tswing: function swing(p) {\n\t\t\treturn 0.5 - Math.cos(p * Math.PI) / 2;\n\t\t},\n\t\t_default: "swing"\n\t};\n\n\tjQuery.fx = Tween.prototype.init;\n\n\t// Back compat <1.8 extension point\n\tjQuery.fx.step = {};\n\n\tvar fxNow,\n\t    inProgress,\n\t    rfxtypes = /^(?:toggle|show|hide)$/,\n\t    rrun = /queueHooks$/;\n\n\tfunction schedule() {\n\t\tif (inProgress) {\n\t\t\tif (document.hidden === false && window.requestAnimationFrame) {\n\t\t\t\twindow.requestAnimationFrame(schedule);\n\t\t\t} else {\n\t\t\t\twindow.setTimeout(schedule, jQuery.fx.interval);\n\t\t\t}\n\n\t\t\tjQuery.fx.tick();\n\t\t}\n\t}\n\n\t// Animations created synchronously will run synchronously\n\tfunction createFxNow() {\n\t\twindow.setTimeout(function () {\n\t\t\tfxNow = undefined;\n\t\t});\n\t\treturn fxNow = jQuery.now();\n\t}\n\n\t// Generate parameters to create a standard animation\n\tfunction genFx(type, includeWidth) {\n\t\tvar which,\n\t\t    i = 0,\n\t\t    attrs = { height: type };\n\n\t\t// If we include width, step value is 1 to do all cssExpand values,\n\t\t// otherwise step value is 2 to skip over Left and Right\n\t\tincludeWidth = includeWidth ? 1 : 0;\n\t\tfor (; i < 4; i += 2 - includeWidth) {\n\t\t\twhich = cssExpand[i];\n\t\t\tattrs["margin" + which] = attrs["padding" + which] = type;\n\t\t}\n\n\t\tif (includeWidth) {\n\t\t\tattrs.opacity = attrs.width = type;\n\t\t}\n\n\t\treturn attrs;\n\t}\n\n\tfunction createTween(value, prop, animation) {\n\t\tvar tween,\n\t\t    collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),\n\t\t    index = 0,\n\t\t    length = collection.length;\n\t\tfor (; index < length; index++) {\n\t\t\tif (tween = collection[index].call(animation, prop, value)) {\n\n\t\t\t\t// We\'re done with this property\n\t\t\t\treturn tween;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction defaultPrefilter(elem, props, opts) {\n\t\tvar prop,\n\t\t    value,\n\t\t    toggle,\n\t\t    hooks,\n\t\t    oldfire,\n\t\t    propTween,\n\t\t    restoreDisplay,\n\t\t    display,\n\t\t    isBox = "width" in props || "height" in props,\n\t\t    anim = this,\n\t\t    orig = {},\n\t\t    style = elem.style,\n\t\t    hidden = elem.nodeType && isHiddenWithinTree(elem),\n\t\t    dataShow = dataPriv.get(elem, "fxshow");\n\n\t\t// Queue-skipping animations hijack the fx hooks\n\t\tif (!opts.queue) {\n\t\t\thooks = jQuery._queueHooks(elem, "fx");\n\t\t\tif (hooks.unqueued == null) {\n\t\t\t\thooks.unqueued = 0;\n\t\t\t\toldfire = hooks.empty.fire;\n\t\t\t\thooks.empty.fire = function () {\n\t\t\t\t\tif (!hooks.unqueued) {\n\t\t\t\t\t\toldfire();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\thooks.unqueued++;\n\n\t\t\tanim.always(function () {\n\n\t\t\t\t// Ensure the complete handler is called before this completes\n\t\t\t\tanim.always(function () {\n\t\t\t\t\thooks.unqueued--;\n\t\t\t\t\tif (!jQuery.queue(elem, "fx").length) {\n\t\t\t\t\t\thooks.empty.fire();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// Detect show/hide animations\n\t\tfor (prop in props) {\n\t\t\tvalue = props[prop];\n\t\t\tif (rfxtypes.test(value)) {\n\t\t\t\tdelete props[prop];\n\t\t\t\ttoggle = toggle || value === "toggle";\n\t\t\t\tif (value === (hidden ? "hide" : "show")) {\n\n\t\t\t\t\t// Pretend to be hidden if this is a "show" and\n\t\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\t\tif (value === "show" && dataShow && dataShow[prop] !== undefined) {\n\t\t\t\t\t\thidden = true;\n\n\t\t\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\torig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\n\t\t\t}\n\t\t}\n\n\t\t// Bail out if this is a no-op like .hide().hide()\n\t\tpropTween = !jQuery.isEmptyObject(props);\n\t\tif (!propTween && jQuery.isEmptyObject(orig)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Restrict "overflow" and "display" styles during box animations\n\t\tif (isBox && elem.nodeType === 1) {\n\n\t\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t\t// from identically-valued overflowX and overflowY\n\t\t\topts.overflow = [style.overflow, style.overflowX, style.overflowY];\n\n\t\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\t\trestoreDisplay = dataShow && dataShow.display;\n\t\t\tif (restoreDisplay == null) {\n\t\t\t\trestoreDisplay = dataPriv.get(elem, "display");\n\t\t\t}\n\t\t\tdisplay = jQuery.css(elem, "display");\n\t\t\tif (display === "none") {\n\t\t\t\tif (restoreDisplay) {\n\t\t\t\t\tdisplay = restoreDisplay;\n\t\t\t\t} else {\n\n\t\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\t\tshowHide([elem], true);\n\t\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\t\tdisplay = jQuery.css(elem, "display");\n\t\t\t\t\tshowHide([elem]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Animate inline elements as inline-block\n\t\t\tif (display === "inline" || display === "inline-block" && restoreDisplay != null) {\n\t\t\t\tif (jQuery.css(elem, "float") === "none") {\n\n\t\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\t\tif (!propTween) {\n\t\t\t\t\t\tanim.done(function () {\n\t\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (restoreDisplay == null) {\n\t\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\t\trestoreDisplay = display === "none" ? "" : display;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstyle.display = "inline-block";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (opts.overflow) {\n\t\t\tstyle.overflow = "hidden";\n\t\t\tanim.always(function () {\n\t\t\t\tstyle.overflow = opts.overflow[0];\n\t\t\t\tstyle.overflowX = opts.overflow[1];\n\t\t\t\tstyle.overflowY = opts.overflow[2];\n\t\t\t});\n\t\t}\n\n\t\t// Implement show/hide animations\n\t\tpropTween = false;\n\t\tfor (prop in orig) {\n\n\t\t\t// General show/hide setup for this element animation\n\t\t\tif (!propTween) {\n\t\t\t\tif (dataShow) {\n\t\t\t\t\tif ("hidden" in dataShow) {\n\t\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });\n\t\t\t\t}\n\n\t\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` "reverses"\n\t\t\t\tif (toggle) {\n\t\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t\t}\n\n\t\t\t\t// Show elements before animating them\n\t\t\t\tif (hidden) {\n\t\t\t\t\tshowHide([elem], true);\n\t\t\t\t}\n\n\t\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\t\tanim.done(function () {\n\n\t\t\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t\t// The final step of a "hide" animation is actually hiding the element\n\t\t\t\t\tif (!hidden) {\n\t\t\t\t\t\tshowHide([elem]);\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.remove(elem, "fxshow");\n\t\t\t\t\tfor (prop in orig) {\n\t\t\t\t\t\tjQuery.style(elem, prop, orig[prop]);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Per-property setup\n\t\t\tpropTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n\t\t\tif (!(prop in dataShow)) {\n\t\t\t\tdataShow[prop] = propTween.start;\n\t\t\t\tif (hidden) {\n\t\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\t\tpropTween.start = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction propFilter(props, specialEasing) {\n\t\tvar index, name, easing, value, hooks;\n\n\t\t// camelCase, specialEasing and expand cssHook pass\n\t\tfor (index in props) {\n\t\t\tname = jQuery.camelCase(index);\n\t\t\teasing = specialEasing[name];\n\t\t\tvalue = props[index];\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\teasing = value[1];\n\t\t\t\tvalue = props[index] = value[0];\n\t\t\t}\n\n\t\t\tif (index !== name) {\n\t\t\t\tprops[name] = value;\n\t\t\t\tdelete props[index];\n\t\t\t}\n\n\t\t\thooks = jQuery.cssHooks[name];\n\t\t\tif (hooks && "expand" in hooks) {\n\t\t\t\tvalue = hooks.expand(value);\n\t\t\t\tdelete props[name];\n\n\t\t\t\t// Not quite $.extend, this won\'t overwrite existing keys.\n\t\t\t\t// Reusing \'index\' because we have the correct "name"\n\t\t\t\tfor (index in value) {\n\t\t\t\t\tif (!(index in props)) {\n\t\t\t\t\t\tprops[index] = value[index];\n\t\t\t\t\t\tspecialEasing[index] = easing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tspecialEasing[name] = easing;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction Animation(elem, properties, options) {\n\t\tvar result,\n\t\t    stopped,\n\t\t    index = 0,\n\t\t    length = Animation.prefilters.length,\n\t\t    deferred = jQuery.Deferred().always(function () {\n\n\t\t\t// Don\'t match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\t    tick = function tick() {\n\t\t\tif (stopped) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n\n\n\t\t\t// Support: Android 2.3 only\n\t\t\t// Archaic crash bug won\'t allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t    percent = 1 - temp,\n\t\t\t    index = 0,\n\t\t\t    length = animation.tweens.length;\n\n\t\t\tfor (; index < length; index++) {\n\t\t\t\tanimation.tweens[index].run(percent);\n\t\t\t}\n\n\t\t\tdeferred.notifyWith(elem, [animation, percent, remaining]);\n\n\t\t\t// If there\'s more to do, yield\n\t\t\tif (percent < 1 && length) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif (!length) {\n\t\t\t\tdeferred.notifyWith(elem, [animation, 1, 0]);\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith(elem, [animation]);\n\t\t\treturn false;\n\t\t},\n\t\t    animation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend({}, properties),\n\t\t\topts: jQuery.extend(true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function createTween(prop, end) {\n\t\t\t\tvar tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n\t\t\t\tanimation.tweens.push(tween);\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function stop(gotoEnd) {\n\t\t\t\tvar index = 0,\n\n\n\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t// otherwise we skip this part\n\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif (stopped) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor (; index < length; index++) {\n\t\t\t\t\tanimation.tweens[index].run(1);\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif (gotoEnd) {\n\t\t\t\t\tdeferred.notifyWith(elem, [animation, 1, 0]);\n\t\t\t\t\tdeferred.resolveWith(elem, [animation, gotoEnd]);\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith(elem, [animation, gotoEnd]);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\t    props = animation.props;\n\n\t\tpropFilter(props, animation.opts.specialEasing);\n\n\t\tfor (; index < length; index++) {\n\t\t\tresult = Animation.prefilters[index].call(animation, elem, props, animation.opts);\n\t\t\tif (result) {\n\t\t\t\tif (jQuery.isFunction(result.stop)) {\n\t\t\t\t\tjQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tjQuery.map(props, createTween, animation);\n\n\t\tif (jQuery.isFunction(animation.opts.start)) {\n\t\t\tanimation.opts.start.call(elem, animation);\n\t\t}\n\n\t\t// Attach callbacks from options\n\t\tanimation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n\n\t\tjQuery.fx.timer(jQuery.extend(tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t}));\n\n\t\treturn animation;\n\t}\n\n\tjQuery.Animation = jQuery.extend(Animation, {\n\n\t\ttweeners: {\n\t\t\t"*": [function (prop, value) {\n\t\t\t\tvar tween = this.createTween(prop, value);\n\t\t\t\tadjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\n\t\t\t\treturn tween;\n\t\t\t}]\n\t\t},\n\n\t\ttweener: function tweener(props, callback) {\n\t\t\tif (jQuery.isFunction(props)) {\n\t\t\t\tcallback = props;\n\t\t\t\tprops = ["*"];\n\t\t\t} else {\n\t\t\t\tprops = props.match(rnothtmlwhite);\n\t\t\t}\n\n\t\t\tvar prop,\n\t\t\t    index = 0,\n\t\t\t    length = props.length;\n\n\t\t\tfor (; index < length; index++) {\n\t\t\t\tprop = props[index];\n\t\t\t\tAnimation.tweeners[prop] = Animation.tweeners[prop] || [];\n\t\t\t\tAnimation.tweeners[prop].unshift(callback);\n\t\t\t}\n\t\t},\n\n\t\tprefilters: [defaultPrefilter],\n\n\t\tprefilter: function prefilter(callback, prepend) {\n\t\t\tif (prepend) {\n\t\t\t\tAnimation.prefilters.unshift(callback);\n\t\t\t} else {\n\t\t\t\tAnimation.prefilters.push(callback);\n\t\t\t}\n\t\t}\n\t});\n\n\tjQuery.speed = function (speed, easing, fn) {\n\t\tvar opt = speed && (typeof speed === "undefined" ? "undefined" : _typeof(speed)) === "object" ? jQuery.extend({}, speed) : {\n\t\t\tcomplete: fn || !fn && easing || jQuery.isFunction(speed) && speed,\n\t\t\tduration: speed,\n\t\t\teasing: fn && easing || easing && !jQuery.isFunction(easing) && easing\n\t\t};\n\n\t\t// Go to the end state if fx are off\n\t\tif (jQuery.fx.off) {\n\t\t\topt.duration = 0;\n\t\t} else {\n\t\t\tif (typeof opt.duration !== "number") {\n\t\t\t\tif (opt.duration in jQuery.fx.speeds) {\n\t\t\t\t\topt.duration = jQuery.fx.speeds[opt.duration];\n\t\t\t\t} else {\n\t\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Normalize opt.queue - true/undefined/null -> "fx"\n\t\tif (opt.queue == null || opt.queue === true) {\n\t\t\topt.queue = "fx";\n\t\t}\n\n\t\t// Queueing\n\t\topt.old = opt.complete;\n\n\t\topt.complete = function () {\n\t\t\tif (jQuery.isFunction(opt.old)) {\n\t\t\t\topt.old.call(this);\n\t\t\t}\n\n\t\t\tif (opt.queue) {\n\t\t\t\tjQuery.dequeue(this, opt.queue);\n\t\t\t}\n\t\t};\n\n\t\treturn opt;\n\t};\n\n\tjQuery.fn.extend({\n\t\tfadeTo: function fadeTo(speed, to, easing, callback) {\n\n\t\t\t// Show any hidden elements after setting opacity to 0\n\t\t\treturn this.filter(isHiddenWithinTree).css("opacity", 0).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback);\n\t\t},\n\t\tanimate: function animate(prop, speed, easing, callback) {\n\t\t\tvar empty = jQuery.isEmptyObject(prop),\n\t\t\t    optall = jQuery.speed(speed, easing, callback),\n\t\t\t    doAnimation = function doAnimation() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won\'t be lost\n\t\t\t\tvar anim = Animation(this, jQuery.extend({}, prop), optall);\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif (empty || dataPriv.get(this, "finish")) {\n\t\t\t\t\tanim.stop(true);\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\t\treturn empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n\t\t},\n\t\tstop: function stop(type, clearQueue, gotoEnd) {\n\t\t\tvar stopQueue = function stopQueue(hooks) {\n\t\t\t\tvar stop = hooks.stop;\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tstop(gotoEnd);\n\t\t\t};\n\n\t\t\tif (typeof type !== "string") {\n\t\t\t\tgotoEnd = clearQueue;\n\t\t\t\tclearQueue = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\tif (clearQueue && type !== false) {\n\t\t\t\tthis.queue(type || "fx", []);\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tvar dequeue = true,\n\t\t\t\t    index = type != null && type + "queueHooks",\n\t\t\t\t    timers = jQuery.timers,\n\t\t\t\t    data = dataPriv.get(this);\n\n\t\t\t\tif (index) {\n\t\t\t\t\tif (data[index] && data[index].stop) {\n\t\t\t\t\t\tstopQueue(data[index]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (index in data) {\n\t\t\t\t\t\tif (data[index] && data[index].stop && rrun.test(index)) {\n\t\t\t\t\t\t\tstopQueue(data[index]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (index = timers.length; index--;) {\n\t\t\t\t\tif (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n\n\t\t\t\t\t\ttimers[index].anim.stop(gotoEnd);\n\t\t\t\t\t\tdequeue = false;\n\t\t\t\t\t\ttimers.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Start the next in the queue if the last step wasn\'t forced.\n\t\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\t\tif (dequeue || !gotoEnd) {\n\t\t\t\t\tjQuery.dequeue(this, type);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tfinish: function finish(type) {\n\t\t\tif (type !== false) {\n\t\t\t\ttype = type || "fx";\n\t\t\t}\n\t\t\treturn this.each(function () {\n\t\t\t\tvar index,\n\t\t\t\t    data = dataPriv.get(this),\n\t\t\t\t    queue = data[type + "queue"],\n\t\t\t\t    hooks = data[type + "queueHooks"],\n\t\t\t\t    timers = jQuery.timers,\n\t\t\t\t    length = queue ? queue.length : 0;\n\n\t\t\t\t// Enable finishing flag on private data\n\t\t\t\tdata.finish = true;\n\n\t\t\t\t// Empty the queue first\n\t\t\t\tjQuery.queue(this, type, []);\n\n\t\t\t\tif (hooks && hooks.stop) {\n\t\t\t\t\thooks.stop.call(this, true);\n\t\t\t\t}\n\n\t\t\t\t// Look for any active animations, and finish them\n\t\t\t\tfor (index = timers.length; index--;) {\n\t\t\t\t\tif (timers[index].elem === this && timers[index].queue === type) {\n\t\t\t\t\t\ttimers[index].anim.stop(true);\n\t\t\t\t\t\ttimers.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Look for any animations in the old queue and finish them\n\t\t\t\tfor (index = 0; index < length; index++) {\n\t\t\t\t\tif (queue[index] && queue[index].finish) {\n\t\t\t\t\t\tqueue[index].finish.call(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Turn off finishing flag\n\t\t\t\tdelete data.finish;\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.each(["toggle", "show", "hide"], function (i, name) {\n\t\tvar cssFn = jQuery.fn[name];\n\t\tjQuery.fn[name] = function (speed, easing, callback) {\n\t\t\treturn speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n\t\t};\n\t});\n\n\t// Generate shortcuts for custom animations\n\tjQuery.each({\n\t\tslideDown: genFx("show"),\n\t\tslideUp: genFx("hide"),\n\t\tslideToggle: genFx("toggle"),\n\t\tfadeIn: { opacity: "show" },\n\t\tfadeOut: { opacity: "hide" },\n\t\tfadeToggle: { opacity: "toggle" }\n\t}, function (name, props) {\n\t\tjQuery.fn[name] = function (speed, easing, callback) {\n\t\t\treturn this.animate(props, speed, easing, callback);\n\t\t};\n\t});\n\n\tjQuery.timers = [];\n\tjQuery.fx.tick = function () {\n\t\tvar timer,\n\t\t    i = 0,\n\t\t    timers = jQuery.timers;\n\n\t\tfxNow = jQuery.now();\n\n\t\tfor (; i < timers.length; i++) {\n\t\t\ttimer = timers[i];\n\n\t\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\t\tif (!timer() && timers[i] === timer) {\n\t\t\t\ttimers.splice(i--, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (!timers.length) {\n\t\t\tjQuery.fx.stop();\n\t\t}\n\t\tfxNow = undefined;\n\t};\n\n\tjQuery.fx.timer = function (timer) {\n\t\tjQuery.timers.push(timer);\n\t\tjQuery.fx.start();\n\t};\n\n\tjQuery.fx.interval = 13;\n\tjQuery.fx.start = function () {\n\t\tif (inProgress) {\n\t\t\treturn;\n\t\t}\n\n\t\tinProgress = true;\n\t\tschedule();\n\t};\n\n\tjQuery.fx.stop = function () {\n\t\tinProgress = null;\n\t};\n\n\tjQuery.fx.speeds = {\n\t\tslow: 600,\n\t\tfast: 200,\n\n\t\t// Default speed\n\t\t_default: 400\n\t};\n\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tjQuery.fn.delay = function (time, type) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n\t\ttype = type || "fx";\n\n\t\treturn this.queue(type, function (next, hooks) {\n\t\t\tvar timeout = window.setTimeout(next, time);\n\t\t\thooks.stop = function () {\n\t\t\t\twindow.clearTimeout(timeout);\n\t\t\t};\n\t\t});\n\t};\n\n\t(function () {\n\t\tvar input = document.createElement("input"),\n\t\t    select = document.createElement("select"),\n\t\t    opt = select.appendChild(document.createElement("option"));\n\n\t\tinput.type = "checkbox";\n\n\t\t// Support: Android <=4.3 only\n\t\t// Default value for a checkbox should be "on"\n\t\tsupport.checkOn = input.value !== "";\n\n\t\t// Support: IE <=11 only\n\t\t// Must access selectedIndex to make default options select\n\t\tsupport.optSelected = opt.selected;\n\n\t\t// Support: IE <=11 only\n\t\t// An input loses its value after becoming a radio\n\t\tinput = document.createElement("input");\n\t\tinput.value = "t";\n\t\tinput.type = "radio";\n\t\tsupport.radioValue = input.value === "t";\n\t})();\n\n\tvar boolHook,\n\t    attrHandle = jQuery.expr.attrHandle;\n\n\tjQuery.fn.extend({\n\t\tattr: function attr(name, value) {\n\t\t\treturn access(this, jQuery.attr, name, value, arguments.length > 1);\n\t\t},\n\n\t\tremoveAttr: function removeAttr(name) {\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.removeAttr(this, name);\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tattr: function attr(elem, name, value) {\n\t\t\tvar ret,\n\t\t\t    hooks,\n\t\t\t    nType = elem.nodeType;\n\n\t\t\t// Don\'t get/set attributes on text, comment and attribute nodes\n\t\t\tif (nType === 3 || nType === 8 || nType === 2) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Fallback to prop when attributes are not supported\n\t\t\tif (typeof elem.getAttribute === "undefined") {\n\t\t\t\treturn jQuery.prop(elem, name, value);\n\t\t\t}\n\n\t\t\t// Attribute hooks are determined by the lowercase version\n\t\t\t// Grab necessary hook if one is defined\n\t\t\tif (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n\t\t\t\thooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\n\t\t\t}\n\n\t\t\tif (value !== undefined) {\n\t\t\t\tif (value === null) {\n\t\t\t\t\tjQuery.removeAttr(elem, name);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\telem.setAttribute(name, value + "");\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = jQuery.find.attr(elem, name);\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ? undefined : ret;\n\t\t},\n\n\t\tattrHooks: {\n\t\t\ttype: {\n\t\t\t\tset: function set(elem, value) {\n\t\t\t\t\tif (!support.radioValue && value === "radio" && nodeName(elem, "input")) {\n\t\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\t\telem.setAttribute("type", value);\n\t\t\t\t\t\tif (val) {\n\t\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tremoveAttr: function removeAttr(elem, value) {\n\t\t\tvar name,\n\t\t\t    i = 0,\n\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match(rnothtmlwhite);\n\n\t\t\tif (attrNames && elem.nodeType === 1) {\n\t\t\t\twhile (name = attrNames[i++]) {\n\t\t\t\t\telem.removeAttribute(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Hooks for boolean attributes\n\tboolHook = {\n\t\tset: function set(elem, value, name) {\n\t\t\tif (value === false) {\n\n\t\t\t\t// Remove boolean attributes when set to false\n\t\t\t\tjQuery.removeAttr(elem, name);\n\t\t\t} else {\n\t\t\t\telem.setAttribute(name, name);\n\t\t\t}\n\t\t\treturn name;\n\t\t}\n\t};\n\n\tjQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (i, name) {\n\t\tvar getter = attrHandle[name] || jQuery.find.attr;\n\n\t\tattrHandle[name] = function (elem, name, isXML) {\n\t\t\tvar ret,\n\t\t\t    handle,\n\t\t\t    lowercaseName = name.toLowerCase();\n\n\t\t\tif (!isXML) {\n\n\t\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\t\thandle = attrHandle[lowercaseName];\n\t\t\t\tattrHandle[lowercaseName] = ret;\n\t\t\t\tret = getter(elem, name, isXML) != null ? lowercaseName : null;\n\t\t\t\tattrHandle[lowercaseName] = handle;\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t});\n\n\tvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\t    rclickable = /^(?:a|area)$/i;\n\n\tjQuery.fn.extend({\n\t\tprop: function prop(name, value) {\n\t\t\treturn access(this, jQuery.prop, name, value, arguments.length > 1);\n\t\t},\n\n\t\tremoveProp: function removeProp(name) {\n\t\t\treturn this.each(function () {\n\t\t\t\tdelete this[jQuery.propFix[name] || name];\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tprop: function prop(elem, name, value) {\n\t\t\tvar ret,\n\t\t\t    hooks,\n\t\t\t    nType = elem.nodeType;\n\n\t\t\t// Don\'t get/set properties on text, comment and attribute nodes\n\t\t\tif (nType === 3 || nType === 8 || nType === 2) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n\n\t\t\t\t// Fix name and attach hooks\n\t\t\t\tname = jQuery.propFix[name] || name;\n\t\t\t\thooks = jQuery.propHooks[name];\n\t\t\t}\n\n\t\t\tif (value !== undefined) {\n\t\t\t\tif (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\treturn elem[name] = value;\n\t\t\t}\n\n\t\t\tif (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn elem[name];\n\t\t},\n\n\t\tpropHooks: {\n\t\t\ttabIndex: {\n\t\t\t\tget: function get(elem) {\n\n\t\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t\t// elem.tabIndex doesn\'t always return the\n\t\t\t\t\t// correct value when it hasn\'t been explicitly set\n\t\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\t\tvar tabindex = jQuery.find.attr(elem, "tabindex");\n\n\t\t\t\t\tif (tabindex) {\n\t\t\t\t\t\treturn parseInt(tabindex, 10);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tpropFix: {\n\t\t\t"for": "htmlFor",\n\t\t\t"class": "className"\n\t\t}\n\t});\n\n\t// Support: IE <=11 only\n\t// Accessing the selectedIndex property\n\t// forces the browser to respect setting selected\n\t// on the option\n\t// The getter ensures a default option is selected\n\t// when in an optgroup\n\t// eslint rule "no-unused-expressions" is disabled for this code\n\t// since it considers such accessions noop\n\tif (!support.optSelected) {\n\t\tjQuery.propHooks.selected = {\n\t\t\tget: function get(elem) {\n\n\t\t\t\t/* eslint no-unused-expressions: "off" */\n\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif (parent && parent.parentNode) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\tset: function set(elem) {\n\n\t\t\t\t/* eslint no-unused-expressions: "off" */\n\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif (parent) {\n\t\t\t\t\tparent.selectedIndex;\n\n\t\t\t\t\tif (parent.parentNode) {\n\t\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tjQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {\n\t\tjQuery.propFix[this.toLowerCase()] = this;\n\t});\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\tfunction stripAndCollapse(value) {\n\t\tvar tokens = value.match(rnothtmlwhite) || [];\n\t\treturn tokens.join(" ");\n\t}\n\n\tfunction getClass(elem) {\n\t\treturn elem.getAttribute && elem.getAttribute("class") || "";\n\t}\n\n\tjQuery.fn.extend({\n\t\taddClass: function addClass(value) {\n\t\t\tvar classes,\n\t\t\t    elem,\n\t\t\t    cur,\n\t\t\t    curValue,\n\t\t\t    clazz,\n\t\t\t    j,\n\t\t\t    finalValue,\n\t\t\t    i = 0;\n\n\t\t\tif (jQuery.isFunction(value)) {\n\t\t\t\treturn this.each(function (j) {\n\t\t\t\t\tjQuery(this).addClass(value.call(this, j, getClass(this)));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (typeof value === "string" && value) {\n\t\t\t\tclasses = value.match(rnothtmlwhite) || [];\n\n\t\t\t\twhile (elem = this[i++]) {\n\t\t\t\t\tcurValue = getClass(elem);\n\t\t\t\t\tcur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";\n\n\t\t\t\t\tif (cur) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile (clazz = classes[j++]) {\n\t\t\t\t\t\t\tif (cur.indexOf(" " + clazz + " ") < 0) {\n\t\t\t\t\t\t\t\tcur += clazz + " ";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = stripAndCollapse(cur);\n\t\t\t\t\t\tif (curValue !== finalValue) {\n\t\t\t\t\t\t\telem.setAttribute("class", finalValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tremoveClass: function removeClass(value) {\n\t\t\tvar classes,\n\t\t\t    elem,\n\t\t\t    cur,\n\t\t\t    curValue,\n\t\t\t    clazz,\n\t\t\t    j,\n\t\t\t    finalValue,\n\t\t\t    i = 0;\n\n\t\t\tif (jQuery.isFunction(value)) {\n\t\t\t\treturn this.each(function (j) {\n\t\t\t\t\tjQuery(this).removeClass(value.call(this, j, getClass(this)));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!arguments.length) {\n\t\t\t\treturn this.attr("class", "");\n\t\t\t}\n\n\t\t\tif (typeof value === "string" && value) {\n\t\t\t\tclasses = value.match(rnothtmlwhite) || [];\n\n\t\t\t\twhile (elem = this[i++]) {\n\t\t\t\t\tcurValue = getClass(elem);\n\n\t\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\t\tcur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";\n\n\t\t\t\t\tif (cur) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile (clazz = classes[j++]) {\n\n\t\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\t\twhile (cur.indexOf(" " + clazz + " ") > -1) {\n\t\t\t\t\t\t\t\tcur = cur.replace(" " + clazz + " ", " ");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = stripAndCollapse(cur);\n\t\t\t\t\t\tif (curValue !== finalValue) {\n\t\t\t\t\t\t\telem.setAttribute("class", finalValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\ttoggleClass: function toggleClass(value, stateVal) {\n\t\t\tvar type = typeof value === "undefined" ? "undefined" : _typeof(value);\n\n\t\t\tif (typeof stateVal === "boolean" && type === "string") {\n\t\t\t\treturn stateVal ? this.addClass(value) : this.removeClass(value);\n\t\t\t}\n\n\t\t\tif (jQuery.isFunction(value)) {\n\t\t\t\treturn this.each(function (i) {\n\t\t\t\t\tjQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tvar className, i, self, classNames;\n\n\t\t\t\tif (type === "string") {\n\n\t\t\t\t\t// Toggle individual class names\n\t\t\t\t\ti = 0;\n\t\t\t\t\tself = jQuery(this);\n\t\t\t\t\tclassNames = value.match(rnothtmlwhite) || [];\n\n\t\t\t\t\twhile (className = classNames[i++]) {\n\n\t\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\t\tif (self.hasClass(className)) {\n\t\t\t\t\t\t\tself.removeClass(className);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.addClass(className);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Toggle whole class name\n\t\t\t\t} else if (value === undefined || type === "boolean") {\n\t\t\t\t\tclassName = getClass(this);\n\t\t\t\t\tif (className) {\n\n\t\t\t\t\t\t// Store className if set\n\t\t\t\t\t\tdataPriv.set(this, "__className__", className);\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the element has a class name or if we\'re passed `false`,\n\t\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\t\tif (this.setAttribute) {\n\t\t\t\t\t\tthis.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\thasClass: function hasClass(selector) {\n\t\t\tvar className,\n\t\t\t    elem,\n\t\t\t    i = 0;\n\n\t\t\tclassName = " " + selector + " ";\n\t\t\twhile (elem = this[i++]) {\n\t\t\t\tif (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t});\n\n\tvar rreturn = /\\r/g;\n\n\tjQuery.fn.extend({\n\t\tval: function val(value) {\n\t\t\tvar hooks,\n\t\t\t    ret,\n\t\t\t    isFunction,\n\t\t\t    elem = this[0];\n\n\t\t\tif (!arguments.length) {\n\t\t\t\tif (elem) {\n\t\t\t\t\thooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n\t\t\t\t\tif (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\n\t\t\t\t\tret = elem.value;\n\n\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\tif (typeof ret === "string") {\n\t\t\t\t\t\treturn ret.replace(rreturn, "");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\treturn ret == null ? "" : ret;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tisFunction = jQuery.isFunction(value);\n\n\t\t\treturn this.each(function (i) {\n\t\t\t\tvar val;\n\n\t\t\t\tif (this.nodeType !== 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isFunction) {\n\t\t\t\t\tval = value.call(this, i, jQuery(this).val());\n\t\t\t\t} else {\n\t\t\t\t\tval = value;\n\t\t\t\t}\n\n\t\t\t\t// Treat null/undefined as ""; convert numbers to string\n\t\t\t\tif (val == null) {\n\t\t\t\t\tval = "";\n\t\t\t\t} else if (typeof val === "number") {\n\t\t\t\t\tval += "";\n\t\t\t\t} else if (Array.isArray(val)) {\n\t\t\t\t\tval = jQuery.map(val, function (value) {\n\t\t\t\t\t\treturn value == null ? "" : value + "";\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\thooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];\n\n\t\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\t\tif (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {\n\t\t\t\t\tthis.value = val;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tvalHooks: {\n\t\t\toption: {\n\t\t\t\tget: function get(elem) {\n\n\t\t\t\t\tvar val = jQuery.find.attr(elem, "value");\n\t\t\t\t\treturn val != null ? val :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse(jQuery.text(elem));\n\t\t\t\t}\n\t\t\t},\n\t\t\tselect: {\n\t\t\t\tget: function get(elem) {\n\t\t\t\t\tvar value,\n\t\t\t\t\t    option,\n\t\t\t\t\t    i,\n\t\t\t\t\t    options = elem.options,\n\t\t\t\t\t    index = elem.selectedIndex,\n\t\t\t\t\t    one = elem.type === "select-one",\n\t\t\t\t\t    values = one ? null : [],\n\t\t\t\t\t    max = one ? index + 1 : options.length;\n\n\t\t\t\t\tif (index < 0) {\n\t\t\t\t\t\ti = max;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Loop through all the selected options\n\t\t\t\t\tfor (; i < max; i++) {\n\t\t\t\t\t\toption = options[i];\n\n\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t// IE8-9 doesn\'t update selected after form reset (#2551)\n\t\t\t\t\t\tif ((option.selected || i === index) &&\n\n\t\t\t\t\t\t// Don\'t return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t!option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {\n\n\t\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\t\tvalue = jQuery(option).val();\n\n\t\t\t\t\t\t\t// We don\'t need an array for one selects\n\t\t\t\t\t\t\tif (one) {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\t\tvalues.push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn values;\n\t\t\t\t},\n\n\t\t\t\tset: function set(elem, value) {\n\t\t\t\t\tvar optionSet,\n\t\t\t\t\t    option,\n\t\t\t\t\t    options = elem.options,\n\t\t\t\t\t    values = jQuery.makeArray(value),\n\t\t\t\t\t    i = options.length;\n\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\toption = options[i];\n\n\t\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\t\tif (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {\n\t\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t\t}\n\n\t\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\t\tif (!optionSet) {\n\t\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn values;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Radios and checkboxes getter/setter\n\tjQuery.each(["radio", "checkbox"], function () {\n\t\tjQuery.valHooks[this] = {\n\t\t\tset: function set(elem, value) {\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\treturn elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (!support.checkOn) {\n\t\t\tjQuery.valHooks[this].get = function (elem) {\n\t\t\t\treturn elem.getAttribute("value") === null ? "on" : elem.value;\n\t\t\t};\n\t\t}\n\t});\n\n\t// Return jQuery for attributes-only inclusion\n\n\n\tvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\n\tjQuery.extend(jQuery.event, {\n\n\t\ttrigger: function trigger(event, data, elem, onlyHandlers) {\n\n\t\t\tvar i,\n\t\t\t    cur,\n\t\t\t    tmp,\n\t\t\t    bubbleType,\n\t\t\t    ontype,\n\t\t\t    handle,\n\t\t\t    special,\n\t\t\t    eventPath = [elem || document],\n\t\t\t    type = hasOwn.call(event, "type") ? event.type : event,\n\t\t\t    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];\n\n\t\t\tcur = tmp = elem = elem || document;\n\n\t\t\t// Don\'t do events on text and comment nodes\n\t\t\tif (elem.nodeType === 3 || elem.nodeType === 8) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// focus/blur morphs to focusin/out; ensure we\'re not firing them right now\n\t\t\tif (rfocusMorph.test(type + jQuery.event.triggered)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (type.indexOf(".") > -1) {\n\n\t\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\t\tnamespaces = type.split(".");\n\t\t\t\ttype = namespaces.shift();\n\t\t\t\tnamespaces.sort();\n\t\t\t}\n\t\t\tontype = type.indexOf(":") < 0 && "on" + type;\n\n\t\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\t\tevent = event[jQuery.expando] ? event : new jQuery.Event(type, (typeof event === "undefined" ? "undefined" : _typeof(event)) === "object" && event);\n\n\t\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\t\tevent.namespace = namespaces.join(".");\n\t\t\tevent.rnamespace = event.namespace ? new RegExp("(^|\\\\.)" + namespaces.join("\\\\.(?:.*\\\\.|)") + "(\\\\.|$)") : null;\n\n\t\t\t// Clean up the event in case it is being reused\n\t\t\tevent.result = undefined;\n\t\t\tif (!event.target) {\n\t\t\t\tevent.target = elem;\n\t\t\t}\n\n\t\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\t\tdata = data == null ? [event] : jQuery.makeArray(data, [event]);\n\n\t\t\t// Allow special events to draw outside the lines\n\t\t\tspecial = jQuery.event.special[type] || {};\n\t\t\tif (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\t\tif (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {\n\n\t\t\t\tbubbleType = special.delegateType || type;\n\t\t\t\tif (!rfocusMorph.test(bubbleType + type)) {\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t}\n\t\t\t\tfor (; cur; cur = cur.parentNode) {\n\t\t\t\t\teventPath.push(cur);\n\t\t\t\t\ttmp = cur;\n\t\t\t\t}\n\n\t\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\t\tif (tmp === (elem.ownerDocument || document)) {\n\t\t\t\t\teventPath.push(tmp.defaultView || tmp.parentWindow || window);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fire handlers on the event path\n\t\t\ti = 0;\n\t\t\twhile ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n\n\t\t\t\tevent.type = i > 1 ? bubbleType : special.bindType || type;\n\n\t\t\t\t// jQuery handler\n\t\t\t\thandle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");\n\t\t\t\tif (handle) {\n\t\t\t\t\thandle.apply(cur, data);\n\t\t\t\t}\n\n\t\t\t\t// Native handler\n\t\t\t\thandle = ontype && cur[ontype];\n\t\t\t\tif (handle && handle.apply && acceptData(cur)) {\n\t\t\t\t\tevent.result = handle.apply(cur, data);\n\t\t\t\t\tif (event.result === false) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent.type = type;\n\n\t\t\t// If nobody prevented the default action, do it now\n\t\t\tif (!onlyHandlers && !event.isDefaultPrevented()) {\n\n\t\t\t\tif ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {\n\n\t\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t\t// Don\'t do default actions on window, that\'s where global variables be (#6170)\n\t\t\t\t\tif (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {\n\n\t\t\t\t\t\t// Don\'t re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\t\ttmp = elem[ontype];\n\n\t\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t\telem[ontype] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\t\telem[type]();\n\t\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t\telem[ontype] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn event.result;\n\t\t},\n\n\t\t// Piggyback on a donor event to simulate a different one\n\t\t// Used only for `focus(in | out)` events\n\t\tsimulate: function simulate(type, elem, event) {\n\t\t\tvar e = jQuery.extend(new jQuery.Event(), event, {\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t});\n\n\t\t\tjQuery.event.trigger(e, null, elem);\n\t\t}\n\n\t});\n\n\tjQuery.fn.extend({\n\n\t\ttrigger: function trigger(type, data) {\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.event.trigger(type, data, this);\n\t\t\t});\n\t\t},\n\t\ttriggerHandler: function triggerHandler(type, data) {\n\t\t\tvar elem = this[0];\n\t\t\tif (elem) {\n\t\t\t\treturn jQuery.event.trigger(type, data, elem, true);\n\t\t\t}\n\t\t}\n\t});\n\n\tjQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (i, name) {\n\n\t\t// Handle event binding\n\t\tjQuery.fn[name] = function (data, fn) {\n\t\t\treturn arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n\t\t};\n\t});\n\n\tjQuery.fn.extend({\n\t\thover: function hover(fnOver, fnOut) {\n\t\t\treturn this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n\t\t}\n\t});\n\n\tsupport.focusin = "onfocusin" in window;\n\n\t// Support: Firefox <=44\n\t// Firefox doesn\'t have focus(in | out) events\n\t// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n\t//\n\t// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n\t// focus(in | out) events fire after focus & blur events,\n\t// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n\t// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n\tif (!support.focusin) {\n\t\tjQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {\n\n\t\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\t\tvar handler = function handler(event) {\n\t\t\t\tjQuery.event.simulate(fix, event.target, jQuery.event.fix(event));\n\t\t\t};\n\n\t\t\tjQuery.event.special[fix] = {\n\t\t\t\tsetup: function setup() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t    attaches = dataPriv.access(doc, fix);\n\n\t\t\t\t\tif (!attaches) {\n\t\t\t\t\t\tdoc.addEventListener(orig, handler, true);\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.access(doc, fix, (attaches || 0) + 1);\n\t\t\t\t},\n\t\t\t\tteardown: function teardown() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t    attaches = dataPriv.access(doc, fix) - 1;\n\n\t\t\t\t\tif (!attaches) {\n\t\t\t\t\t\tdoc.removeEventListener(orig, handler, true);\n\t\t\t\t\t\tdataPriv.remove(doc, fix);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdataPriv.access(doc, fix, attaches);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\tvar location = window.location;\n\n\tvar nonce = jQuery.now();\n\n\tvar rquery = /\\?/;\n\n\t// Cross-browser xml parsing\n\tjQuery.parseXML = function (data) {\n\t\tvar xml;\n\t\tif (!data || typeof data !== "string") {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Support: IE 9 - 11 only\n\t\t// IE throws on parseFromString with invalid input.\n\t\ttry {\n\t\t\txml = new window.DOMParser().parseFromString(data, "text/xml");\n\t\t} catch (e) {\n\t\t\txml = undefined;\n\t\t}\n\n\t\tif (!xml || xml.getElementsByTagName("parsererror").length) {\n\t\t\tjQuery.error("Invalid XML: " + data);\n\t\t}\n\t\treturn xml;\n\t};\n\n\tvar rbracket = /\\[\\]$/,\n\t    rCRLF = /\\r?\\n/g,\n\t    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\t    rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n\tfunction buildParams(prefix, obj, traditional, add) {\n\t\tvar name;\n\n\t\tif (Array.isArray(obj)) {\n\n\t\t\t// Serialize array item.\n\t\t\tjQuery.each(obj, function (i, v) {\n\t\t\t\tif (traditional || rbracket.test(prefix)) {\n\n\t\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\t\tadd(prefix, v);\n\t\t\t\t} else {\n\n\t\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\t\tbuildParams(prefix + "[" + ((typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" && v != null ? i : "") + "]", v, traditional, add);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (!traditional && jQuery.type(obj) === "object") {\n\n\t\t\t// Serialize object item.\n\t\t\tfor (name in obj) {\n\t\t\t\tbuildParams(prefix + "[" + name + "]", obj[name], traditional, add);\n\t\t\t}\n\t\t} else {\n\n\t\t\t// Serialize scalar item.\n\t\t\tadd(prefix, obj);\n\t\t}\n\t}\n\n\t// Serialize an array of form elements or a set of\n\t// key/values into a query string\n\tjQuery.param = function (a, traditional) {\n\t\tvar prefix,\n\t\t    s = [],\n\t\t    add = function add(key, valueOrFunction) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;\n\n\t\t\ts[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);\n\t\t};\n\n\t\t// If an array was passed in, assume that it is an array of form elements.\n\t\tif (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n\n\t\t\t// Serialize the form elements\n\t\t\tjQuery.each(a, function () {\n\t\t\t\tadd(this.name, this.value);\n\t\t\t});\n\t\t} else {\n\n\t\t\t// If traditional, encode the "old" way (the way 1.3.2 or older\n\t\t\t// did it), otherwise encode params recursively.\n\t\t\tfor (prefix in a) {\n\t\t\t\tbuildParams(prefix, a[prefix], traditional, add);\n\t\t\t}\n\t\t}\n\n\t\t// Return the resulting serialization\n\t\treturn s.join("&");\n\t};\n\n\tjQuery.fn.extend({\n\t\tserialize: function serialize() {\n\t\t\treturn jQuery.param(this.serializeArray());\n\t\t},\n\t\tserializeArray: function serializeArray() {\n\t\t\treturn this.map(function () {\n\n\t\t\t\t// Can add propHook for "elements" to filter or add form elements\n\t\t\t\tvar elements = jQuery.prop(this, "elements");\n\t\t\t\treturn elements ? jQuery.makeArray(elements) : this;\n\t\t\t}).filter(function () {\n\t\t\t\tvar type = this.type;\n\n\t\t\t\t// Use .is( ":disabled" ) so that fieldset[disabled] works\n\t\t\t\treturn this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n\t\t\t}).map(function (i, elem) {\n\t\t\t\tvar val = jQuery(this).val();\n\n\t\t\t\tif (val == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\treturn jQuery.map(val, function (val) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace(rCRLF, "\\r\\n") };\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn { name: elem.name, value: val.replace(rCRLF, "\\r\\n") };\n\t\t\t}).get();\n\t\t}\n\t});\n\n\tvar r20 = /%20/g,\n\t    rhash = /#.*$/,\n\t    rantiCache = /([?&])_=[^&]*/,\n\t    rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\t    rnoContent = /^(?:GET|HEAD)$/,\n\t    rprotocol = /^\\/\\//,\n\n\n\t/* Prefilters\n  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n  * 2) These are called:\n  *    - BEFORE asking for a transport\n  *    - AFTER param serialization (s.data is a string if s.processData is true)\n  * 3) key is the dataType\n  * 4) the catchall symbol "*" can be used\n  * 5) execution will start with transport dataType and THEN continue down to "*" if needed\n  */\n\tprefilters = {},\n\n\n\t/* Transports bindings\n  * 1) key is the dataType\n  * 2) the catchall symbol "*" can be used\n  * 3) selection will start with transport dataType and THEN go to "*" if needed\n  */\n\ttransports = {},\n\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = "*/".concat("*"),\n\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement("a");\n\toriginAnchor.href = location.href;\n\n\t// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\tfunction addToPrefiltersOrTransports(structure) {\n\n\t\t// dataTypeExpression is optional and defaults to "*"\n\t\treturn function (dataTypeExpression, func) {\n\n\t\t\tif (typeof dataTypeExpression !== "string") {\n\t\t\t\tfunc = dataTypeExpression;\n\t\t\t\tdataTypeExpression = "*";\n\t\t\t}\n\n\t\t\tvar dataType,\n\t\t\t    i = 0,\n\t\t\t    dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\n\n\t\t\tif (jQuery.isFunction(func)) {\n\n\t\t\t\t// For each dataType in the dataTypeExpression\n\t\t\t\twhile (dataType = dataTypes[i++]) {\n\n\t\t\t\t\t// Prepend if requested\n\t\t\t\t\tif (dataType[0] === "+") {\n\t\t\t\t\t\tdataType = dataType.slice(1) || "*";\n\t\t\t\t\t\t(structure[dataType] = structure[dataType] || []).unshift(func);\n\n\t\t\t\t\t\t// Otherwise append\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(structure[dataType] = structure[dataType] || []).push(func);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Base inspection function for prefilters and transports\n\tfunction inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n\n\t\tvar inspected = {},\n\t\t    seekingTransport = structure === transports;\n\n\t\tfunction inspect(dataType) {\n\t\t\tvar selected;\n\t\t\tinspected[dataType] = true;\n\t\t\tjQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n\t\t\t\tvar dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\t\t\t\tif (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n\n\t\t\t\t\toptions.dataTypes.unshift(dataTypeOrTransport);\n\t\t\t\t\tinspect(dataTypeOrTransport);\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (seekingTransport) {\n\t\t\t\t\treturn !(selected = dataTypeOrTransport);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn selected;\n\t\t}\n\n\t\treturn inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");\n\t}\n\n\t// A special extend for ajax options\n\t// that takes "flat" options (not to be deep extended)\n\t// Fixes #9887\n\tfunction ajaxExtend(target, src) {\n\t\tvar key,\n\t\t    deep,\n\t\t    flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\t\tfor (key in src) {\n\t\t\tif (src[key] !== undefined) {\n\t\t\t\t(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n\t\t\t}\n\t\t}\n\t\tif (deep) {\n\t\t\tjQuery.extend(true, target, deep);\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/* Handles responses to an ajax request:\n  * - finds the right dataType (mediates between content-type and expected dataType)\n  * - returns the corresponding response\n  */\n\tfunction ajaxHandleResponses(s, jqXHR, responses) {\n\n\t\tvar ct,\n\t\t    type,\n\t\t    finalDataType,\n\t\t    firstDataType,\n\t\t    contents = s.contents,\n\t\t    dataTypes = s.dataTypes;\n\n\t\t// Remove auto dataType and get content-type in the process\n\t\twhile (dataTypes[0] === "*") {\n\t\t\tdataTypes.shift();\n\t\t\tif (ct === undefined) {\n\t\t\t\tct = s.mimeType || jqXHR.getResponseHeader("Content-Type");\n\t\t\t}\n\t\t}\n\n\t\t// Check if we\'re dealing with a known content-type\n\t\tif (ct) {\n\t\t\tfor (type in contents) {\n\t\t\t\tif (contents[type] && contents[type].test(ct)) {\n\t\t\t\t\tdataTypes.unshift(type);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check to see if we have a response for the expected dataType\n\t\tif (dataTypes[0] in responses) {\n\t\t\tfinalDataType = dataTypes[0];\n\t\t} else {\n\n\t\t\t// Try convertible dataTypes\n\t\t\tfor (type in responses) {\n\t\t\t\tif (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {\n\t\t\t\t\tfinalDataType = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!firstDataType) {\n\t\t\t\t\tfirstDataType = type;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Or just use first one\n\t\t\tfinalDataType = finalDataType || firstDataType;\n\t\t}\n\n\t\t// If we found a dataType\n\t\t// We add the dataType to the list if needed\n\t\t// and return the corresponding response\n\t\tif (finalDataType) {\n\t\t\tif (finalDataType !== dataTypes[0]) {\n\t\t\t\tdataTypes.unshift(finalDataType);\n\t\t\t}\n\t\t\treturn responses[finalDataType];\n\t\t}\n\t}\n\n\t/* Chain conversions given the request and the original response\n  * Also sets the responseXXX fields on the jqXHR instance\n  */\n\tfunction ajaxConvert(s, response, jqXHR, isSuccess) {\n\t\tvar conv2,\n\t\t    current,\n\t\t    conv,\n\t\t    tmp,\n\t\t    prev,\n\t\t    converters = {},\n\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t\t// Create converters map with lowercased keys\n\t\tif (dataTypes[1]) {\n\t\t\tfor (conv in s.converters) {\n\t\t\t\tconverters[conv.toLowerCase()] = s.converters[conv];\n\t\t\t}\n\t\t}\n\n\t\tcurrent = dataTypes.shift();\n\n\t\t// Convert to each sequential dataType\n\t\twhile (current) {\n\n\t\t\tif (s.responseFields[current]) {\n\t\t\t\tjqXHR[s.responseFields[current]] = response;\n\t\t\t}\n\n\t\t\t// Apply the dataFilter if provided\n\t\t\tif (!prev && isSuccess && s.dataFilter) {\n\t\t\t\tresponse = s.dataFilter(response, s.dataType);\n\t\t\t}\n\n\t\t\tprev = current;\n\t\t\tcurrent = dataTypes.shift();\n\n\t\t\tif (current) {\n\n\t\t\t\t// There\'s only work to do if current dataType is non-auto\n\t\t\t\tif (current === "*") {\n\n\t\t\t\t\tcurrent = prev;\n\n\t\t\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t\t} else if (prev !== "*" && prev !== current) {\n\n\t\t\t\t\t// Seek a direct converter\n\t\t\t\t\tconv = converters[prev + " " + current] || converters["* " + current];\n\n\t\t\t\t\t// If none found, seek a pair\n\t\t\t\t\tif (!conv) {\n\t\t\t\t\t\tfor (conv2 in converters) {\n\n\t\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\t\ttmp = conv2.split(" ");\n\t\t\t\t\t\t\tif (tmp[1] === current) {\n\n\t\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\t\tconv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];\n\t\t\t\t\t\t\t\tif (conv) {\n\n\t\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\t\tif (conv === true) {\n\t\t\t\t\t\t\t\t\t\tconv = converters[conv2];\n\n\t\t\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t\t} else if (converters[conv2] !== true) {\n\t\t\t\t\t\t\t\t\t\tcurrent = tmp[0];\n\t\t\t\t\t\t\t\t\t\tdataTypes.unshift(tmp[1]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\t\tif (conv !== true) {\n\n\t\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\t\tif (conv && s.throws) {\n\t\t\t\t\t\t\tresponse = conv(response);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresponse = conv(response);\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tstate: "parsererror",\n\t\t\t\t\t\t\t\t\terror: conv ? e : "No conversion from " + prev + " to " + current\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { state: "success", data: response };\n\t}\n\n\tjQuery.extend({\n\n\t\t// Counter for holding the number of active queries\n\t\tactive: 0,\n\n\t\t// Last-Modified header cache for next request\n\t\tlastModified: {},\n\t\tetag: {},\n\n\t\tajaxSettings: {\n\t\t\turl: location.href,\n\t\t\ttype: "GET",\n\t\t\tisLocal: rlocalProtocol.test(location.protocol),\n\t\t\tglobal: true,\n\t\t\tprocessData: true,\n\t\t\tasync: true,\n\t\t\tcontentType: "application/x-www-form-urlencoded; charset=UTF-8",\n\n\t\t\t/*\n   timeout: 0,\n   data: null,\n   dataType: null,\n   username: null,\n   password: null,\n   cache: null,\n   throws: false,\n   traditional: false,\n   headers: {},\n   */\n\n\t\t\taccepts: {\n\t\t\t\t"*": allTypes,\n\t\t\t\ttext: "text/plain",\n\t\t\t\thtml: "text/html",\n\t\t\t\txml: "application/xml, text/xml",\n\t\t\t\tjson: "application/json, text/javascript"\n\t\t\t},\n\n\t\t\tcontents: {\n\t\t\t\txml: /\\bxml\\b/,\n\t\t\t\thtml: /\\bhtml/,\n\t\t\t\tjson: /\\bjson\\b/\n\t\t\t},\n\n\t\t\tresponseFields: {\n\t\t\t\txml: "responseXML",\n\t\t\t\ttext: "responseText",\n\t\t\t\tjson: "responseJSON"\n\t\t\t},\n\n\t\t\t// Data converters\n\t\t\t// Keys separate source (or catchall "*") and destination types with a single space\n\t\t\tconverters: {\n\n\t\t\t\t// Convert anything to text\n\t\t\t\t"* text": String,\n\n\t\t\t\t// Text to html (true = no transformation)\n\t\t\t\t"text html": true,\n\n\t\t\t\t// Evaluate text as a json expression\n\t\t\t\t"text json": JSON.parse,\n\n\t\t\t\t// Parse text as xml\n\t\t\t\t"text xml": jQuery.parseXML\n\t\t\t},\n\n\t\t\t// For options that shouldn\'t be deep extended:\n\t\t\t// you can add your own custom options here if\n\t\t\t// and when you create one that shouldn\'t be\n\t\t\t// deep extended (see ajaxExtend)\n\t\t\tflatOptions: {\n\t\t\t\turl: true,\n\t\t\t\tcontext: true\n\t\t\t}\n\t\t},\n\n\t\t// Creates a full fledged settings object into target\n\t\t// with both ajaxSettings and settings fields.\n\t\t// If target is omitted, writes into ajaxSettings.\n\t\tajaxSetup: function ajaxSetup(target, settings) {\n\t\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend(jQuery.ajaxSettings, target);\n\t\t},\n\n\t\tajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n\t\tajaxTransport: addToPrefiltersOrTransports(transports),\n\n\t\t// Main method\n\t\tajax: function ajax(url, options) {\n\n\t\t\t// If url is an object, simulate pre-1.5 signature\n\t\t\tif ((typeof url === "undefined" ? "undefined" : _typeof(url)) === "object") {\n\t\t\t\toptions = url;\n\t\t\t\turl = undefined;\n\t\t\t}\n\n\t\t\t// Force options to be an object\n\t\t\toptions = options || {};\n\n\t\t\tvar transport,\n\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\t    responseHeaders,\n\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup({}, options),\n\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\t    completeDeferred = jQuery.Callbacks("once memory"),\n\n\n\t\t\t// Status-dependent callbacks\n\t\t\t_statusCode = s.statusCode || {},\n\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\t    requestHeadersNames = {},\n\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = "canceled",\n\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function getResponseHeader(key) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif (completed) {\n\t\t\t\t\t\tif (!responseHeaders) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile (match = rheaders.exec(responseHeadersString)) {\n\t\t\t\t\t\t\t\tresponseHeaders[match[1].toLowerCase()] = match[2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[key.toLowerCase()];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function getAllResponseHeaders() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function setRequestHeader(name, value) {\n\t\t\t\t\tif (completed == null) {\n\t\t\t\t\t\tname = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;\n\t\t\t\t\t\trequestHeaders[name] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function overrideMimeType(type) {\n\t\t\t\t\tif (completed == null) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function statusCode(map) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif (map) {\n\t\t\t\t\t\tif (completed) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always(map[jqXHR.status]);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor (code in map) {\n\t\t\t\t\t\t\t\t_statusCode[code] = [_statusCode[code], map[code]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function abort(statusText) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif (transport) {\n\t\t\t\t\t\ttransport.abort(finalText);\n\t\t\t\t\t}\n\t\t\t\t\tdone(0, finalText);\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Attach deferreds\n\t\t\tdeferred.promise(jqXHR);\n\n\t\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t\t// We also use the url parameter if available\n\t\t\ts.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");\n\n\t\t\t// Alias method option to type as per ticket #12004\n\t\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t\t// Extract dataTypes list\n\t\t\ts.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];\n\n\t\t\t// A cross-domain request is in order when the origin doesn\'t match the current origin.\n\t\t\tif (s.crossDomain == null) {\n\t\t\t\turlAnchor = document.createElement("a");\n\n\t\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t\t// e.g. http://example.com:80x/\n\t\t\t\ttry {\n\t\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t\t// Anchor\'s host property isn\'t correctly set when s.url is relative\n\t\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\t\ts.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\t\ts.crossDomain = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Convert data if not already a string\n\t\t\tif (s.data && s.processData && typeof s.data !== "string") {\n\t\t\t\ts.data = jQuery.param(s.data, s.traditional);\n\t\t\t}\n\n\t\t\t// Apply prefilters\n\t\t\tinspectPrefiltersOrTransports(prefilters, s, options, jqXHR);\n\n\t\t\t// If request was aborted inside a prefilter, stop there\n\t\t\tif (completed) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// We can fire global events as of now if asked to\n\t\t\t// Don\'t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t\t// Watch for a new set of requests\n\t\t\tif (fireGlobals && jQuery.active++ === 0) {\n\t\t\t\tjQuery.event.trigger("ajaxStart");\n\t\t\t}\n\n\t\t\t// Uppercase the type\n\t\t\ts.type = s.type.toUpperCase();\n\n\t\t\t// Determine if request has content\n\t\t\ts.hasContent = !rnoContent.test(s.type);\n\n\t\t\t// Save the URL in case we\'re toying with the If-Modified-Since\n\t\t\t// and/or If-None-Match header later on\n\t\t\t// Remove hash to simplify url manipulation\n\t\t\tcacheURL = s.url.replace(rhash, "");\n\n\t\t\t// More options handling for requests with no content\n\t\t\tif (!s.hasContent) {\n\n\t\t\t\t// Remember the hash so we can put it back\n\t\t\t\tuncached = s.url.slice(cacheURL.length);\n\n\t\t\t\t// If data is available, append data to url\n\t\t\t\tif (s.data) {\n\t\t\t\t\tcacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;\n\n\t\t\t\t\t// #9682: remove data so that it\'s not used in an eventual retry\n\t\t\t\t\tdelete s.data;\n\t\t\t\t}\n\n\t\t\t\t// Add or update anti-cache param if needed\n\t\t\t\tif (s.cache === false) {\n\t\t\t\t\tcacheURL = cacheURL.replace(rantiCache, "$1");\n\t\t\t\t\tuncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;\n\t\t\t\t}\n\n\t\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\t\ts.url = cacheURL + uncached;\n\n\t\t\t\t// Change \'%20\' to \'+\' if this is encoded form body content (gh-2658)\n\t\t\t} else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {\n\t\t\t\ts.data = s.data.replace(r20, "+");\n\t\t\t}\n\n\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\tif (s.ifModified) {\n\t\t\t\tif (jQuery.lastModified[cacheURL]) {\n\t\t\t\t\tjqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);\n\t\t\t\t}\n\t\t\t\tif (jQuery.etag[cacheURL]) {\n\t\t\t\t\tjqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the correct header, if data is being sent\n\t\t\tif (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n\t\t\t\tjqXHR.setRequestHeader("Content-Type", s.contentType);\n\t\t\t}\n\n\t\t\t// Set the Accepts header for the server, depending on the dataType\n\t\t\tjqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);\n\n\t\t\t// Check for headers option\n\t\t\tfor (i in s.headers) {\n\t\t\t\tjqXHR.setRequestHeader(i, s.headers[i]);\n\t\t\t}\n\n\t\t\t// Allow custom headers/mimetypes and early abort\n\t\t\tif (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\n\n\t\t\t\t// Abort if not done already and return\n\t\t\t\treturn jqXHR.abort();\n\t\t\t}\n\n\t\t\t// Aborting is no longer a cancellation\n\t\t\tstrAbort = "abort";\n\n\t\t\t// Install callbacks on deferreds\n\t\t\tcompleteDeferred.add(s.complete);\n\t\t\tjqXHR.done(s.success);\n\t\t\tjqXHR.fail(s.error);\n\n\t\t\t// Get transport\n\t\t\ttransport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);\n\n\t\t\t// If no transport, we auto-abort\n\t\t\tif (!transport) {\n\t\t\t\tdone(-1, "No Transport");\n\t\t\t} else {\n\t\t\t\tjqXHR.readyState = 1;\n\n\t\t\t\t// Send global event\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger("ajaxSend", [jqXHR, s]);\n\t\t\t\t}\n\n\t\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\t\tif (completed) {\n\t\t\t\t\treturn jqXHR;\n\t\t\t\t}\n\n\t\t\t\t// Timeout\n\t\t\t\tif (s.async && s.timeout > 0) {\n\t\t\t\t\ttimeoutTimer = window.setTimeout(function () {\n\t\t\t\t\t\tjqXHR.abort("timeout");\n\t\t\t\t\t}, s.timeout);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tcompleted = false;\n\t\t\t\t\ttransport.send(requestHeaders, done);\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\t\tif (completed) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Propagate others as results\n\t\t\t\t\tdone(-1, e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Callback for when everything is done\n\t\t\tfunction done(status, nativeStatusText, responses, headers) {\n\t\t\t\tvar isSuccess,\n\t\t\t\t    success,\n\t\t\t\t    error,\n\t\t\t\t    response,\n\t\t\t\t    modified,\n\t\t\t\t    statusText = nativeStatusText;\n\n\t\t\t\t// Ignore repeat invocations\n\t\t\t\tif (completed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcompleted = true;\n\n\t\t\t\t// Clear timeout if it exists\n\t\t\t\tif (timeoutTimer) {\n\t\t\t\t\twindow.clearTimeout(timeoutTimer);\n\t\t\t\t}\n\n\t\t\t\t// Dereference transport for early garbage collection\n\t\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\t\ttransport = undefined;\n\n\t\t\t\t// Cache response headers\n\t\t\t\tresponseHeadersString = headers || "";\n\n\t\t\t\t// Set readyState\n\t\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t\t// Determine if successful\n\t\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t\t// Get response data\n\t\t\t\tif (responses) {\n\t\t\t\t\tresponse = ajaxHandleResponses(s, jqXHR, responses);\n\t\t\t\t}\n\n\t\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\t\tresponse = ajaxConvert(s, response, jqXHR, isSuccess);\n\n\t\t\t\t// If successful, handle type chaining\n\t\t\t\tif (isSuccess) {\n\n\t\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\t\tif (s.ifModified) {\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader("Last-Modified");\n\t\t\t\t\t\tif (modified) {\n\t\t\t\t\t\t\tjQuery.lastModified[cacheURL] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader("etag");\n\t\t\t\t\t\tif (modified) {\n\t\t\t\t\t\t\tjQuery.etag[cacheURL] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// if no content\n\t\t\t\t\tif (status === 204 || s.type === "HEAD") {\n\t\t\t\t\t\tstatusText = "nocontent";\n\n\t\t\t\t\t\t// if not modified\n\t\t\t\t\t} else if (status === 304) {\n\t\t\t\t\t\tstatusText = "notmodified";\n\n\t\t\t\t\t\t// If we have data, let\'s convert it\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\t\terror = response.error;\n\t\t\t\t\t\tisSuccess = !error;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\t\terror = statusText;\n\t\t\t\t\tif (status || !statusText) {\n\t\t\t\t\t\tstatusText = "error";\n\t\t\t\t\t\tif (status < 0) {\n\t\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set data for the fake xhr object\n\t\t\t\tjqXHR.status = status;\n\t\t\t\tjqXHR.statusText = (nativeStatusText || statusText) + "";\n\n\t\t\t\t// Success/Error\n\t\t\t\tif (isSuccess) {\n\t\t\t\t\tdeferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n\t\t\t\t}\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tjqXHR.statusCode(_statusCode);\n\t\t\t\t_statusCode = undefined;\n\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);\n\t\t\t\t}\n\n\t\t\t\t// Complete\n\t\t\t\tcompleteDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger("ajaxComplete", [jqXHR, s]);\n\n\t\t\t\t\t// Handle the global AJAX counter\n\t\t\t\t\tif (! --jQuery.active) {\n\t\t\t\t\t\tjQuery.event.trigger("ajaxStop");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn jqXHR;\n\t\t},\n\n\t\tgetJSON: function getJSON(url, data, callback) {\n\t\t\treturn jQuery.get(url, data, callback, "json");\n\t\t},\n\n\t\tgetScript: function getScript(url, callback) {\n\t\t\treturn jQuery.get(url, undefined, callback, "script");\n\t\t}\n\t});\n\n\tjQuery.each(["get", "post"], function (i, method) {\n\t\tjQuery[method] = function (url, data, callback, type) {\n\n\t\t\t// Shift arguments if data argument was omitted\n\t\t\tif (jQuery.isFunction(data)) {\n\t\t\t\ttype = type || callback;\n\t\t\t\tcallback = data;\n\t\t\t\tdata = undefined;\n\t\t\t}\n\n\t\t\t// The url can be an options object (which then must have .url)\n\t\t\treturn jQuery.ajax(jQuery.extend({\n\t\t\t\turl: url,\n\t\t\t\ttype: method,\n\t\t\t\tdataType: type,\n\t\t\t\tdata: data,\n\t\t\t\tsuccess: callback\n\t\t\t}, jQuery.isPlainObject(url) && url));\n\t\t};\n\t});\n\n\tjQuery._evalUrl = function (url) {\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\t\ttype: "GET",\n\t\t\tdataType: "script",\n\t\t\tcache: true,\n\t\t\tasync: false,\n\t\t\tglobal: false,\n\t\t\t"throws": true\n\t\t});\n\t};\n\n\tjQuery.fn.extend({\n\t\twrapAll: function wrapAll(html) {\n\t\t\tvar wrap;\n\n\t\t\tif (this[0]) {\n\t\t\t\tif (jQuery.isFunction(html)) {\n\t\t\t\t\thtml = html.call(this[0]);\n\t\t\t\t}\n\n\t\t\t\t// The elements to wrap the target around\n\t\t\t\twrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n\t\t\t\tif (this[0].parentNode) {\n\t\t\t\t\twrap.insertBefore(this[0]);\n\t\t\t\t}\n\n\t\t\t\twrap.map(function () {\n\t\t\t\t\tvar elem = this;\n\n\t\t\t\t\twhile (elem.firstElementChild) {\n\t\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elem;\n\t\t\t\t}).append(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\twrapInner: function wrapInner(html) {\n\t\t\tif (jQuery.isFunction(html)) {\n\t\t\t\treturn this.each(function (i) {\n\t\t\t\t\tjQuery(this).wrapInner(html.call(this, i));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tvar self = jQuery(this),\n\t\t\t\t    contents = self.contents();\n\n\t\t\t\tif (contents.length) {\n\t\t\t\t\tcontents.wrapAll(html);\n\t\t\t\t} else {\n\t\t\t\t\tself.append(html);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\twrap: function wrap(html) {\n\t\t\tvar isFunction = jQuery.isFunction(html);\n\n\t\t\treturn this.each(function (i) {\n\t\t\t\tjQuery(this).wrapAll(isFunction ? html.call(this, i) : html);\n\t\t\t});\n\t\t},\n\n\t\tunwrap: function unwrap(selector) {\n\t\t\tthis.parent(selector).not("body").each(function () {\n\t\t\t\tjQuery(this).replaceWith(this.childNodes);\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t});\n\n\tjQuery.expr.pseudos.hidden = function (elem) {\n\t\treturn !jQuery.expr.pseudos.visible(elem);\n\t};\n\tjQuery.expr.pseudos.visible = function (elem) {\n\t\treturn !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\n\t};\n\n\tjQuery.ajaxSettings.xhr = function () {\n\t\ttry {\n\t\t\treturn new window.XMLHttpRequest();\n\t\t} catch (e) {}\n\t};\n\n\tvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\t    xhrSupported = jQuery.ajaxSettings.xhr();\n\n\tsupport.cors = !!xhrSupported && "withCredentials" in xhrSupported;\n\tsupport.ajax = xhrSupported = !!xhrSupported;\n\n\tjQuery.ajaxTransport(function (options) {\n\t\tvar _callback, errorCallback;\n\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif (support.cors || xhrSupported && !options.crossDomain) {\n\t\t\treturn {\n\t\t\t\tsend: function send(headers, complete) {\n\t\t\t\t\tvar i,\n\t\t\t\t\t    xhr = options.xhr();\n\n\t\t\t\t\txhr.open(options.type, options.url, options.async, options.username, options.password);\n\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif (options.xhrFields) {\n\t\t\t\t\t\tfor (i in options.xhrFields) {\n\t\t\t\t\t\t\txhr[i] = options.xhrFields[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif (options.mimeType && xhr.overrideMimeType) {\n\t\t\t\t\t\txhr.overrideMimeType(options.mimeType);\n\t\t\t\t\t}\n\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won\'t change header if already provided.\n\t\t\t\t\tif (!options.crossDomain && !headers["X-Requested-With"]) {\n\t\t\t\t\t\theaders["X-Requested-With"] = "XMLHttpRequest";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set headers\n\t\t\t\t\tfor (i in headers) {\n\t\t\t\t\t\txhr.setRequestHeader(i, headers[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Callback\n\t\t\t\t\t_callback = function callback(type) {\n\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\tif (_callback) {\n\t\t\t\t\t\t\t\t_callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\t\tif (type === "abort") {\n\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t} else if (type === "error") {\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\t\tif (typeof xhr.status !== "number") {\n\t\t\t\t\t\t\t\t\t\tcomplete(0, "error");\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status, xhr.statusText);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t(xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\t// Listen to events\n\t\t\t\t\txhr.onload = _callback();\n\t\t\t\t\terrorCallback = xhr.onerror = _callback("error");\n\n\t\t\t\t\t// Support: IE 9 only\n\t\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t\t// to handle uncaught aborts\n\t\t\t\t\tif (xhr.onabort !== undefined) {\n\t\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t\t} else {\n\t\t\t\t\t\txhr.onreadystatechange = function () {\n\n\t\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\t\tif (xhr.readyState === 4) {\n\n\t\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\t\twindow.setTimeout(function () {\n\t\t\t\t\t\t\t\t\tif (_callback) {\n\t\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create the abort callback\n\t\t\t\t\t_callback = _callback("abort");\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\t\txhr.send(options.hasContent && options.data || null);\n\t\t\t\t\t} catch (e) {\n\n\t\t\t\t\t\t// #14683: Only rethrow if this hasn\'t been notified as an error yet\n\t\t\t\t\t\tif (_callback) {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tabort: function abort() {\n\t\t\t\t\tif (_callback) {\n\t\t\t\t\t\t_callback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\n\t// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n\tjQuery.ajaxPrefilter(function (s) {\n\t\tif (s.crossDomain) {\n\t\t\ts.contents.script = false;\n\t\t}\n\t});\n\n\t// Install script dataType\n\tjQuery.ajaxSetup({\n\t\taccepts: {\n\t\t\tscript: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"\n\t\t},\n\t\tcontents: {\n\t\t\tscript: /\\b(?:java|ecma)script\\b/\n\t\t},\n\t\tconverters: {\n\t\t\t"text script": function textScript(text) {\n\t\t\t\tjQuery.globalEval(text);\n\t\t\t\treturn text;\n\t\t\t}\n\t\t}\n\t});\n\n\t// Handle cache\'s special case and crossDomain\n\tjQuery.ajaxPrefilter("script", function (s) {\n\t\tif (s.cache === undefined) {\n\t\t\ts.cache = false;\n\t\t}\n\t\tif (s.crossDomain) {\n\t\t\ts.type = "GET";\n\t\t}\n\t});\n\n\t// Bind script tag hack transport\n\tjQuery.ajaxTransport("script", function (s) {\n\n\t\t// This transport only deals with cross domain requests\n\t\tif (s.crossDomain) {\n\t\t\tvar script, _callback2;\n\t\t\treturn {\n\t\t\t\tsend: function send(_, complete) {\n\t\t\t\t\tscript = jQuery("<script>").prop({\n\t\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\t\tsrc: s.url\n\t\t\t\t\t}).on("load error", _callback2 = function callback(evt) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\t_callback2 = null;\n\t\t\t\t\t\tif (evt) {\n\t\t\t\t\t\t\tcomplete(evt.type === "error" ? 404 : 200, evt.type);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\t\tdocument.head.appendChild(script[0]);\n\t\t\t\t},\n\t\t\t\tabort: function abort() {\n\t\t\t\t\tif (_callback2) {\n\t\t\t\t\t\t_callback2();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\n\tvar oldCallbacks = [],\n\t    rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n\t// Default jsonp settings\n\tjQuery.ajaxSetup({\n\t\tjsonp: "callback",\n\t\tjsonpCallback: function jsonpCallback() {\n\t\t\tvar callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;\n\t\t\tthis[callback] = true;\n\t\t\treturn callback;\n\t\t}\n\t});\n\n\t// Detect, normalize options and install callbacks for jsonp requests\n\tjQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {\n\n\t\tvar callbackName,\n\t\t    overwritten,\n\t\t    responseContainer,\n\t\t    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");\n\n\t\t// Handle iff the expected data type is "jsonp" or we have a parameter to set\n\t\tif (jsonProp || s.dataTypes[0] === "jsonp") {\n\n\t\t\t// Get callback name, remembering preexisting value associated with it\n\t\t\tcallbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;\n\n\t\t\t// Insert callback into url or form data\n\t\t\tif (jsonProp) {\n\t\t\t\ts[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);\n\t\t\t} else if (s.jsonp !== false) {\n\t\t\t\ts.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;\n\t\t\t}\n\n\t\t\t// Use data converter to retrieve json after script execution\n\t\t\ts.converters["script json"] = function () {\n\t\t\t\tif (!responseContainer) {\n\t\t\t\t\tjQuery.error(callbackName + " was not called");\n\t\t\t\t}\n\t\t\t\treturn responseContainer[0];\n\t\t\t};\n\n\t\t\t// Force json dataType\n\t\t\ts.dataTypes[0] = "json";\n\n\t\t\t// Install callback\n\t\t\toverwritten = window[callbackName];\n\t\t\twindow[callbackName] = function () {\n\t\t\t\tresponseContainer = arguments;\n\t\t\t};\n\n\t\t\t// Clean-up function (fires after converters)\n\t\t\tjqXHR.always(function () {\n\n\t\t\t\t// If previous value didn\'t exist - remove it\n\t\t\t\tif (overwritten === undefined) {\n\t\t\t\t\tjQuery(window).removeProp(callbackName);\n\n\t\t\t\t\t// Otherwise restore preexisting value\n\t\t\t\t} else {\n\t\t\t\t\twindow[callbackName] = overwritten;\n\t\t\t\t}\n\n\t\t\t\t// Save back as free\n\t\t\t\tif (s[callbackName]) {\n\n\t\t\t\t\t// Make sure that re-using the options doesn\'t screw things around\n\t\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t\t// Save the callback name for future use\n\t\t\t\t\toldCallbacks.push(callbackName);\n\t\t\t\t}\n\n\t\t\t\t// Call if it was a function and we have a response\n\t\t\t\tif (responseContainer && jQuery.isFunction(overwritten)) {\n\t\t\t\t\toverwritten(responseContainer[0]);\n\t\t\t\t}\n\n\t\t\t\tresponseContainer = overwritten = undefined;\n\t\t\t});\n\n\t\t\t// Delegate to script\n\t\t\treturn "script";\n\t\t}\n\t});\n\n\t// Support: Safari 8 only\n\t// In Safari 8 documents created via document.implementation.createHTMLDocument\n\t// collapse sibling forms: the second one becomes a child of the first one.\n\t// Because of that, this security measure has to be disabled in Safari 8.\n\t// https://bugs.webkit.org/show_bug.cgi?id=137337\n\tsupport.createHTMLDocument = function () {\n\t\tvar body = document.implementation.createHTMLDocument("").body;\n\t\tbody.innerHTML = "<form></form><form></form>";\n\t\treturn body.childNodes.length === 2;\n\t}();\n\n\t// Argument "data" should be string of html\n\t// context (optional): If specified, the fragment will be created in this context,\n\t// defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tjQuery.parseHTML = function (data, context, keepScripts) {\n\t\tif (typeof data !== "string") {\n\t\t\treturn [];\n\t\t}\n\t\tif (typeof context === "boolean") {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\n\t\tvar base, parsed, scripts;\n\n\t\tif (!context) {\n\n\t\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t\t// by using document.implementation\n\t\t\tif (support.createHTMLDocument) {\n\t\t\t\tcontext = document.implementation.createHTMLDocument("");\n\n\t\t\t\t// Set the base href for the created document\n\t\t\t\t// so any parsed elements with URLs\n\t\t\t\t// are based on the document\'s URL (gh-2965)\n\t\t\t\tbase = context.createElement("base");\n\t\t\t\tbase.href = document.location.href;\n\t\t\t\tcontext.head.appendChild(base);\n\t\t\t} else {\n\t\t\t\tcontext = document;\n\t\t\t}\n\t\t}\n\n\t\tparsed = rsingleTag.exec(data);\n\t\tscripts = !keepScripts && [];\n\n\t\t// Single tag\n\t\tif (parsed) {\n\t\t\treturn [context.createElement(parsed[1])];\n\t\t}\n\n\t\tparsed = buildFragment([data], context, scripts);\n\n\t\tif (scripts && scripts.length) {\n\t\t\tjQuery(scripts).remove();\n\t\t}\n\n\t\treturn jQuery.merge([], parsed.childNodes);\n\t};\n\n\t/**\n  * Load a url into a page\n  */\n\tjQuery.fn.load = function (url, params, callback) {\n\t\tvar selector,\n\t\t    type,\n\t\t    response,\n\t\t    self = this,\n\t\t    off = url.indexOf(" ");\n\n\t\tif (off > -1) {\n\t\t\tselector = stripAndCollapse(url.slice(off));\n\t\t\turl = url.slice(0, off);\n\t\t}\n\n\t\t// If it\'s a function\n\t\tif (jQuery.isFunction(params)) {\n\n\t\t\t// We assume that it\'s the callback\n\t\t\tcallback = params;\n\t\t\tparams = undefined;\n\n\t\t\t// Otherwise, build a param string\n\t\t} else if (params && (typeof params === "undefined" ? "undefined" : _typeof(params)) === "object") {\n\t\t\ttype = "POST";\n\t\t}\n\n\t\t// If we have elements to modify, make the request\n\t\tif (self.length > 0) {\n\t\t\tjQuery.ajax({\n\t\t\t\turl: url,\n\n\t\t\t\t// If "type" variable is undefined, then "GET" method will be used.\n\t\t\t\t// Make value of this field explicit since\n\t\t\t\t// user can override it through ajaxSetup method\n\t\t\t\ttype: type || "GET",\n\t\t\t\tdataType: "html",\n\t\t\t\tdata: params\n\t\t\t}).done(function (responseText) {\n\n\t\t\t\t// Save response for use in complete callback\n\t\t\t\tresponse = arguments;\n\n\t\t\t\tself.html(selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE \'Permission Denied\' errors\n\t\t\t\tjQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText);\n\n\t\t\t\t// If the request succeeds, this function gets "data", "status", "jqXHR"\n\t\t\t\t// but they are ignored because response was set above.\n\t\t\t\t// If it fails, this function gets "jqXHR", "status", "error"\n\t\t\t}).always(callback && function (jqXHR, status) {\n\t\t\t\tself.each(function () {\n\t\t\t\t\tcallback.apply(this, response || [jqXHR.responseText, status, jqXHR]);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t// Attach a bunch of functions for handling common AJAX events\n\tjQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {\n\t\tjQuery.fn[type] = function (fn) {\n\t\t\treturn this.on(type, fn);\n\t\t};\n\t});\n\n\tjQuery.expr.pseudos.animated = function (elem) {\n\t\treturn jQuery.grep(jQuery.timers, function (fn) {\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t};\n\n\tjQuery.offset = {\n\t\tsetOffset: function setOffset(elem, options, i) {\n\t\t\tvar curPosition,\n\t\t\t    curLeft,\n\t\t\t    curCSSTop,\n\t\t\t    curTop,\n\t\t\t    curOffset,\n\t\t\t    curCSSLeft,\n\t\t\t    calculatePosition,\n\t\t\t    position = jQuery.css(elem, "position"),\n\t\t\t    curElem = jQuery(elem),\n\t\t\t    props = {};\n\n\t\t\t// Set position first, in-case top/left are set even on static elem\n\t\t\tif (position === "static") {\n\t\t\t\telem.style.position = "relative";\n\t\t\t}\n\n\t\t\tcurOffset = curElem.offset();\n\t\t\tcurCSSTop = jQuery.css(elem, "top");\n\t\t\tcurCSSLeft = jQuery.css(elem, "left");\n\t\t\tcalculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;\n\n\t\t\t// Need to be able to calculate position if either\n\t\t\t// top or left is auto and position is either absolute or fixed\n\t\t\tif (calculatePosition) {\n\t\t\t\tcurPosition = curElem.position();\n\t\t\t\tcurTop = curPosition.top;\n\t\t\t\tcurLeft = curPosition.left;\n\t\t\t} else {\n\t\t\t\tcurTop = parseFloat(curCSSTop) || 0;\n\t\t\t\tcurLeft = parseFloat(curCSSLeft) || 0;\n\t\t\t}\n\n\t\t\tif (jQuery.isFunction(options)) {\n\n\t\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\t\toptions = options.call(elem, i, jQuery.extend({}, curOffset));\n\t\t\t}\n\n\t\t\tif (options.top != null) {\n\t\t\t\tprops.top = options.top - curOffset.top + curTop;\n\t\t\t}\n\t\t\tif (options.left != null) {\n\t\t\t\tprops.left = options.left - curOffset.left + curLeft;\n\t\t\t}\n\n\t\t\tif ("using" in options) {\n\t\t\t\toptions.using.call(elem, props);\n\t\t\t} else {\n\t\t\t\tcurElem.css(props);\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.fn.extend({\n\t\toffset: function offset(options) {\n\n\t\t\t// Preserve chaining for setter\n\t\t\tif (arguments.length) {\n\t\t\t\treturn options === undefined ? this : this.each(function (i) {\n\t\t\t\t\tjQuery.offset.setOffset(this, options, i);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar doc,\n\t\t\t    docElem,\n\t\t\t    rect,\n\t\t\t    win,\n\t\t\t    elem = this[0];\n\n\t\t\tif (!elem) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t\t// Support: IE <=11 only\n\t\t\t// Running getBoundingClientRect on a\n\t\t\t// disconnected node in IE throws an error\n\t\t\tif (!elem.getClientRects().length) {\n\t\t\t\treturn { top: 0, left: 0 };\n\t\t\t}\n\n\t\t\trect = elem.getBoundingClientRect();\n\n\t\t\tdoc = elem.ownerDocument;\n\t\t\tdocElem = doc.documentElement;\n\t\t\twin = doc.defaultView;\n\n\t\t\treturn {\n\t\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t\t};\n\t\t},\n\n\t\tposition: function position() {\n\t\t\tif (!this[0]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar offsetParent,\n\t\t\t    offset,\n\t\t\t    elem = this[0],\n\t\t\t    parentOffset = { top: 0, left: 0 };\n\n\t\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t\t// because it is its only offset parent\n\t\t\tif (jQuery.css(elem, "position") === "fixed") {\n\n\t\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\t\toffset = elem.getBoundingClientRect();\n\t\t\t} else {\n\n\t\t\t\t// Get *real* offsetParent\n\t\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t\t// Get correct offsets\n\t\t\t\toffset = this.offset();\n\t\t\t\tif (!nodeName(offsetParent[0], "html")) {\n\t\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t\t}\n\n\t\t\t\t// Add offsetParent borders\n\t\t\t\tparentOffset = {\n\t\t\t\t\ttop: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", true),\n\t\t\t\t\tleft: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", true)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Subtract parent offsets and element margins\n\t\t\treturn {\n\t\t\t\ttop: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),\n\t\t\t\tleft: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)\n\t\t\t};\n\t\t},\n\n\t\t// This method will return documentElement in the following cases:\n\t\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t\t//    documentElement of the parent window\n\t\t// 2) For the hidden or detached element\n\t\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t\t//\n\t\t// but those exceptions were never presented as a real life use-cases\n\t\t// and might be considered as more preferable results.\n\t\t//\n\t\t// This logic, however, is not guaranteed and can change at any point in the future\n\t\toffsetParent: function offsetParent() {\n\t\t\treturn this.map(function () {\n\t\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\t\twhile (offsetParent && jQuery.css(offsetParent, "position") === "static") {\n\t\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t\t}\n\n\t\t\t\treturn offsetParent || documentElement;\n\t\t\t});\n\t\t}\n\t});\n\n\t// Create scrollLeft and scrollTop methods\n\tjQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {\n\t\tvar top = "pageYOffset" === prop;\n\n\t\tjQuery.fn[method] = function (val) {\n\t\t\treturn access(this, function (elem, method, val) {\n\n\t\t\t\t// Coalesce documents and windows\n\t\t\t\tvar win;\n\t\t\t\tif (jQuery.isWindow(elem)) {\n\t\t\t\t\twin = elem;\n\t\t\t\t} else if (elem.nodeType === 9) {\n\t\t\t\t\twin = elem.defaultView;\n\t\t\t\t}\n\n\t\t\t\tif (val === undefined) {\n\t\t\t\t\treturn win ? win[prop] : elem[method];\n\t\t\t\t}\n\n\t\t\t\tif (win) {\n\t\t\t\t\twin.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);\n\t\t\t\t} else {\n\t\t\t\t\telem[method] = val;\n\t\t\t\t}\n\t\t\t}, method, val, arguments.length);\n\t\t};\n\t});\n\n\t// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n\t// Add the top/left cssHooks using jQuery.fn.position\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n\t// getComputedStyle returns percent when specified for top/left/bottom/right;\n\t// rather than make the css module depend on the offset module, just check for it here\n\tjQuery.each(["top", "left"], function (i, prop) {\n\t\tjQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n\t\t\tif (computed) {\n\t\t\t\tcomputed = curCSS(elem, prop);\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;\n\t\t\t}\n\t\t});\n\t});\n\n\t// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\tjQuery.each({ Height: "height", Width: "width" }, function (name, type) {\n\t\tjQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function (defaultExtra, funcName) {\n\n\t\t\t// Margin is only for outerHeight, outerWidth\n\t\t\tjQuery.fn[funcName] = function (margin, value) {\n\t\t\t\tvar chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),\n\t\t\t\t    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");\n\n\t\t\t\treturn access(this, function (elem, type, value) {\n\t\t\t\t\tvar doc;\n\n\t\t\t\t\tif (jQuery.isWindow(elem)) {\n\n\t\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\t\treturn funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get document width or height\n\t\t\t\t\tif (elem.nodeType === 9) {\n\t\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t\t// whichever is greatest\n\t\t\t\t\t\treturn Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css(elem, type, extra) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style(elem, type, value, extra);\n\t\t\t\t}, type, chainable ? margin : undefined, chainable);\n\t\t\t};\n\t\t});\n\t});\n\n\tjQuery.fn.extend({\n\n\t\tbind: function bind(types, data, fn) {\n\t\t\treturn this.on(types, null, data, fn);\n\t\t},\n\t\tunbind: function unbind(types, fn) {\n\t\t\treturn this.off(types, null, fn);\n\t\t},\n\n\t\tdelegate: function delegate(selector, types, data, fn) {\n\t\t\treturn this.on(types, selector, data, fn);\n\t\t},\n\t\tundelegate: function undelegate(selector, types, fn) {\n\n\t\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\t\treturn arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);\n\t\t}\n\t});\n\n\tjQuery.holdReady = function (hold) {\n\t\tif (hold) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready(true);\n\t\t}\n\t};\n\tjQuery.isArray = Array.isArray;\n\tjQuery.parseJSON = JSON.parse;\n\tjQuery.nodeName = nodeName;\n\n\t// Register as a named AMD module, since jQuery can be concatenated with other\n\t// files that may use define, but not via a proper concatenation script that\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\n\t// way to register. Lowercase jquery is used because AMD module names are\n\t// derived from file names, and jQuery is normally delivered in a lowercase\n\t// file name. Do this after creating the global so that if an AMD module wants\n\t// to call noConflict to hide this version of jQuery, it will work.\n\n\t// Note that for maximum portability, libraries that are not jQuery should\n\t// declare themselves as anonymous modules, and avoid setting a global if an\n\t// AMD loader is present. jQuery is a special case. For more information, see\n\t// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n\tif (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t\t\treturn jQuery;\n\t\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\n\tvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\n\tjQuery.noConflict = function (deep) {\n\t\tif (window.$ === jQuery) {\n\t\t\twindow.$ = _$;\n\t\t}\n\n\t\tif (deep && window.jQuery === jQuery) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\n\t\treturn jQuery;\n\t};\n\n\t// Expose jQuery and $ identifiers, even in AMD\n\t// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n\t// and CommonJS for browser emulators (#13566)\n\tif (!noGlobal) {\n\t\twindow.jQuery = window.$ = jQuery;\n\t}\n\n\treturn jQuery;\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(20)(module)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvanMvanF1ZXJ5LmpzPzMzNmYiXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkb2N1bWVudCIsInciLCJFcnJvciIsIndpbmRvdyIsIm5vR2xvYmFsIiwiYXJyIiwiZ2V0UHJvdG8iLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsInNsaWNlIiwiY29uY2F0IiwicHVzaCIsImluZGV4T2YiLCJjbGFzczJ0eXBlIiwidG9TdHJpbmciLCJoYXNPd24iLCJoYXNPd25Qcm9wZXJ0eSIsImZuVG9TdHJpbmciLCJPYmplY3RGdW5jdGlvblN0cmluZyIsImNhbGwiLCJzdXBwb3J0IiwiRE9NRXZhbCIsImNvZGUiLCJkb2MiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50IiwidGV4dCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInZlcnNpb24iLCJqUXVlcnkiLCJzZWxlY3RvciIsImNvbnRleHQiLCJmbiIsImluaXQiLCJydHJpbSIsInJtc1ByZWZpeCIsInJkYXNoQWxwaGEiLCJmY2FtZWxDYXNlIiwiYWxsIiwibGV0dGVyIiwidG9VcHBlckNhc2UiLCJwcm90b3R5cGUiLCJqcXVlcnkiLCJjb25zdHJ1Y3RvciIsImxlbmd0aCIsInRvQXJyYXkiLCJnZXQiLCJudW0iLCJwdXNoU3RhY2siLCJlbGVtcyIsInJldCIsIm1lcmdlIiwicHJldk9iamVjdCIsImVhY2giLCJjYWxsYmFjayIsIm1hcCIsImVsZW0iLCJpIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJmaXJzdCIsImVxIiwibGFzdCIsImxlbiIsImoiLCJlbmQiLCJzb3J0Iiwic3BsaWNlIiwiZXh0ZW5kIiwib3B0aW9ucyIsIm5hbWUiLCJzcmMiLCJjb3B5IiwiY29weUlzQXJyYXkiLCJjbG9uZSIsInRhcmdldCIsImRlZXAiLCJpc0Z1bmN0aW9uIiwiaXNQbGFpbk9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsImV4cGFuZG8iLCJNYXRoIiwicmFuZG9tIiwicmVwbGFjZSIsImlzUmVhZHkiLCJlcnJvciIsIm1zZyIsIm5vb3AiLCJvYmoiLCJ0eXBlIiwiaXNXaW5kb3ciLCJpc051bWVyaWMiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJwcm90byIsIkN0b3IiLCJpc0VtcHR5T2JqZWN0IiwiZ2xvYmFsRXZhbCIsImNhbWVsQ2FzZSIsInN0cmluZyIsImlzQXJyYXlMaWtlIiwidHJpbSIsIm1ha2VBcnJheSIsInJlc3VsdHMiLCJpbkFycmF5Iiwic2Vjb25kIiwiZ3JlcCIsImludmVydCIsImNhbGxiYWNrSW52ZXJzZSIsIm1hdGNoZXMiLCJjYWxsYmFja0V4cGVjdCIsImFyZyIsInZhbHVlIiwiZ3VpZCIsInByb3h5IiwidG1wIiwiYXJncyIsIm5vdyIsIkRhdGUiLCJTeW1ib2wiLCJpdGVyYXRvciIsInNwbGl0IiwidG9Mb3dlckNhc2UiLCJTaXp6bGUiLCJFeHByIiwiZ2V0VGV4dCIsImlzWE1MIiwidG9rZW5pemUiLCJjb21waWxlIiwic2VsZWN0Iiwib3V0ZXJtb3N0Q29udGV4dCIsInNvcnRJbnB1dCIsImhhc0R1cGxpY2F0ZSIsInNldERvY3VtZW50IiwiZG9jRWxlbSIsImRvY3VtZW50SXNIVE1MIiwicmJ1Z2d5UVNBIiwicmJ1Z2d5TWF0Y2hlcyIsImNvbnRhaW5zIiwicHJlZmVycmVkRG9jIiwiZGlycnVucyIsImRvbmUiLCJjbGFzc0NhY2hlIiwiY3JlYXRlQ2FjaGUiLCJ0b2tlbkNhY2hlIiwiY29tcGlsZXJDYWNoZSIsInNvcnRPcmRlciIsImEiLCJiIiwicG9wIiwicHVzaF9uYXRpdmUiLCJsaXN0IiwiYm9vbGVhbnMiLCJ3aGl0ZXNwYWNlIiwiaWRlbnRpZmllciIsImF0dHJpYnV0ZXMiLCJwc2V1ZG9zIiwicndoaXRlc3BhY2UiLCJSZWdFeHAiLCJyY29tbWEiLCJyY29tYmluYXRvcnMiLCJyYXR0cmlidXRlUXVvdGVzIiwicnBzZXVkbyIsInJpZGVudGlmaWVyIiwibWF0Y2hFeHByIiwicmlucHV0cyIsInJoZWFkZXIiLCJybmF0aXZlIiwicnF1aWNrRXhwciIsInJzaWJsaW5nIiwicnVuZXNjYXBlIiwiZnVuZXNjYXBlIiwiXyIsImVzY2FwZWQiLCJlc2NhcGVkV2hpdGVzcGFjZSIsImhpZ2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJyY3NzZXNjYXBlIiwiZmNzc2VzY2FwZSIsImNoIiwiYXNDb2RlUG9pbnQiLCJjaGFyQ29kZUF0IiwidW5sb2FkSGFuZGxlciIsImRpc2FibGVkQW5jZXN0b3IiLCJhZGRDb21iaW5hdG9yIiwiZGlzYWJsZWQiLCJkaXIiLCJuZXh0IiwiY2hpbGROb2RlcyIsIm5vZGVUeXBlIiwiZSIsImVscyIsInNlZWQiLCJtIiwibmlkIiwibWF0Y2giLCJncm91cHMiLCJuZXdTZWxlY3RvciIsIm5ld0NvbnRleHQiLCJvd25lckRvY3VtZW50IiwiZXhlYyIsImdldEVsZW1lbnRCeUlkIiwiaWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJxc2EiLCJ0ZXN0Iiwibm9kZU5hbWUiLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJ0b1NlbGVjdG9yIiwiam9pbiIsInRlc3RDb250ZXh0IiwicXVlcnlTZWxlY3RvckFsbCIsInFzYUVycm9yIiwicmVtb3ZlQXR0cmlidXRlIiwia2V5cyIsImNhY2hlIiwia2V5IiwiY2FjaGVMZW5ndGgiLCJzaGlmdCIsIm1hcmtGdW5jdGlvbiIsImFzc2VydCIsImVsIiwiYWRkSGFuZGxlIiwiYXR0cnMiLCJoYW5kbGVyIiwiYXR0ckhhbmRsZSIsInNpYmxpbmdDaGVjayIsImN1ciIsImRpZmYiLCJzb3VyY2VJbmRleCIsIm5leHRTaWJsaW5nIiwiY3JlYXRlSW5wdXRQc2V1ZG8iLCJjcmVhdGVCdXR0b25Qc2V1ZG8iLCJjcmVhdGVEaXNhYmxlZFBzZXVkbyIsImlzRGlzYWJsZWQiLCJjcmVhdGVQb3NpdGlvbmFsUHNldWRvIiwiYXJndW1lbnQiLCJtYXRjaEluZGV4ZXMiLCJkb2N1bWVudEVsZW1lbnQiLCJub2RlIiwiaGFzQ29tcGFyZSIsInN1YldpbmRvdyIsImRlZmF1bHRWaWV3IiwidG9wIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiY2xhc3NOYW1lIiwiY3JlYXRlQ29tbWVudCIsImdldEJ5SWQiLCJnZXRFbGVtZW50c0J5TmFtZSIsImZpbHRlciIsImF0dHJJZCIsImZpbmQiLCJnZXRBdHRyaWJ1dGVOb2RlIiwidGFnIiwiaW5uZXJIVE1MIiwiaW5wdXQiLCJtYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJkaXNjb25uZWN0ZWRNYXRjaCIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiYWRvd24iLCJidXAiLCJjb21wYXJlIiwic29ydERldGFjaGVkIiwiYXVwIiwiYXAiLCJicCIsInVuc2hpZnQiLCJleHByIiwiZWxlbWVudHMiLCJhdHRyIiwidmFsIiwic3BlY2lmaWVkIiwiZXNjYXBlIiwic2VsIiwidW5pcXVlU29ydCIsImR1cGxpY2F0ZXMiLCJkZXRlY3REdXBsaWNhdGVzIiwic29ydFN0YWJsZSIsInRleHRDb250ZW50IiwiZmlyc3RDaGlsZCIsIm5vZGVWYWx1ZSIsInNlbGVjdG9ycyIsImNyZWF0ZVBzZXVkbyIsInJlbGF0aXZlIiwicHJlRmlsdGVyIiwiZXhjZXNzIiwidW5xdW90ZWQiLCJub2RlTmFtZVNlbGVjdG9yIiwicGF0dGVybiIsIm9wZXJhdG9yIiwiY2hlY2siLCJyZXN1bHQiLCJ3aGF0Iiwic2ltcGxlIiwiZm9yd2FyZCIsIm9mVHlwZSIsInhtbCIsInVuaXF1ZUNhY2hlIiwib3V0ZXJDYWNoZSIsIm5vZGVJbmRleCIsInN0YXJ0IiwicGFyZW50IiwidXNlQ2FjaGUiLCJsYXN0Q2hpbGQiLCJ1bmlxdWVJRCIsInBzZXVkbyIsInNldEZpbHRlcnMiLCJpZHgiLCJtYXRjaGVkIiwibWF0Y2hlciIsInVubWF0Y2hlZCIsImlubmVyVGV4dCIsImxhbmciLCJlbGVtTGFuZyIsImhhc2giLCJsb2NhdGlvbiIsImFjdGl2ZUVsZW1lbnQiLCJoYXNGb2N1cyIsImhyZWYiLCJ0YWJJbmRleCIsImNoZWNrZWQiLCJzZWxlY3RlZCIsInNlbGVjdGVkSW5kZXgiLCJyYWRpbyIsImNoZWNrYm94IiwiZmlsZSIsInBhc3N3b3JkIiwiaW1hZ2UiLCJzdWJtaXQiLCJyZXNldCIsImZpbHRlcnMiLCJwYXJzZU9ubHkiLCJ0b2tlbnMiLCJzb0ZhciIsInByZUZpbHRlcnMiLCJjYWNoZWQiLCJjb21iaW5hdG9yIiwiYmFzZSIsInNraXAiLCJjaGVja05vbkVsZW1lbnRzIiwiZG9uZU5hbWUiLCJvbGRDYWNoZSIsIm5ld0NhY2hlIiwiZWxlbWVudE1hdGNoZXIiLCJtYXRjaGVycyIsIm11bHRpcGxlQ29udGV4dHMiLCJjb250ZXh0cyIsImNvbmRlbnNlIiwibmV3VW5tYXRjaGVkIiwibWFwcGVkIiwic2V0TWF0Y2hlciIsInBvc3RGaWx0ZXIiLCJwb3N0RmluZGVyIiwicG9zdFNlbGVjdG9yIiwidGVtcCIsInByZU1hcCIsInBvc3RNYXAiLCJwcmVleGlzdGluZyIsIm1hdGNoZXJJbiIsIm1hdGNoZXJPdXQiLCJtYXRjaGVyRnJvbVRva2VucyIsImNoZWNrQ29udGV4dCIsImxlYWRpbmdSZWxhdGl2ZSIsImltcGxpY2l0UmVsYXRpdmUiLCJtYXRjaENvbnRleHQiLCJtYXRjaEFueUNvbnRleHQiLCJtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMiLCJlbGVtZW50TWF0Y2hlcnMiLCJzZXRNYXRjaGVycyIsImJ5U2V0IiwiYnlFbGVtZW50Iiwic3VwZXJNYXRjaGVyIiwib3V0ZXJtb3N0IiwibWF0Y2hlZENvdW50Iiwic2V0TWF0Y2hlZCIsImNvbnRleHRCYWNrdXAiLCJkaXJydW5zVW5pcXVlIiwidG9rZW4iLCJjb21waWxlZCIsImRlZmF1bHRWYWx1ZSIsInVuaXF1ZSIsImlzWE1MRG9jIiwiZXNjYXBlU2VsZWN0b3IiLCJ1bnRpbCIsInRydW5jYXRlIiwiaXMiLCJzaWJsaW5ncyIsIm4iLCJybmVlZHNDb250ZXh0IiwibmVlZHNDb250ZXh0IiwicnNpbmdsZVRhZyIsInJpc1NpbXBsZSIsIndpbm5vdyIsInF1YWxpZmllciIsIm5vdCIsInNlbGYiLCJyb290alF1ZXJ5Iiwicm9vdCIsInBhcnNlSFRNTCIsInJlYWR5IiwicnBhcmVudHNwcmV2IiwiZ3VhcmFudGVlZFVuaXF1ZSIsImNoaWxkcmVuIiwiY29udGVudHMiLCJwcmV2IiwiaGFzIiwidGFyZ2V0cyIsImwiLCJjbG9zZXN0IiwiaW5kZXgiLCJwcmV2QWxsIiwiYWRkIiwiYWRkQmFjayIsInNpYmxpbmciLCJwYXJlbnRzIiwicGFyZW50c1VudGlsIiwibmV4dEFsbCIsIm5leHRVbnRpbCIsInByZXZVbnRpbCIsImNvbnRlbnREb2N1bWVudCIsImNvbnRlbnQiLCJyZXZlcnNlIiwicm5vdGh0bWx3aGl0ZSIsImNyZWF0ZU9wdGlvbnMiLCJvYmplY3QiLCJmbGFnIiwiQ2FsbGJhY2tzIiwiZmlyaW5nIiwibWVtb3J5IiwiZmlyZWQiLCJsb2NrZWQiLCJxdWV1ZSIsImZpcmluZ0luZGV4IiwiZmlyZSIsIm9uY2UiLCJzdG9wT25GYWxzZSIsInJlbW92ZSIsImVtcHR5IiwiZGlzYWJsZSIsImxvY2siLCJmaXJlV2l0aCIsIklkZW50aXR5IiwidiIsIlRocm93ZXIiLCJleCIsImFkb3B0VmFsdWUiLCJyZXNvbHZlIiwicmVqZWN0Iiwibm9WYWx1ZSIsIm1ldGhvZCIsInByb21pc2UiLCJmYWlsIiwidGhlbiIsIkRlZmVycmVkIiwiZnVuYyIsInR1cGxlcyIsInN0YXRlIiwiYWx3YXlzIiwiZGVmZXJyZWQiLCJwaXBlIiwiZm5zIiwibmV3RGVmZXIiLCJ0dXBsZSIsInJldHVybmVkIiwicHJvZ3Jlc3MiLCJub3RpZnkiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJvblByb2dyZXNzIiwibWF4RGVwdGgiLCJkZXB0aCIsInNwZWNpYWwiLCJ0aGF0IiwibWlnaHRUaHJvdyIsIlR5cGVFcnJvciIsIm5vdGlmeVdpdGgiLCJyZXNvbHZlV2l0aCIsInByb2Nlc3MiLCJleGNlcHRpb25Ib29rIiwic3RhY2tUcmFjZSIsInJlamVjdFdpdGgiLCJnZXRTdGFja0hvb2siLCJzZXRUaW1lb3V0Iiwic3RhdGVTdHJpbmciLCJ3aGVuIiwic2luZ2xlVmFsdWUiLCJyZW1haW5pbmciLCJyZXNvbHZlQ29udGV4dHMiLCJyZXNvbHZlVmFsdWVzIiwibWFzdGVyIiwidXBkYXRlRnVuYyIsInJlcnJvck5hbWVzIiwic3RhY2siLCJjb25zb2xlIiwid2FybiIsIm1lc3NhZ2UiLCJyZWFkeUV4Y2VwdGlvbiIsInJlYWR5TGlzdCIsImNhdGNoIiwicmVhZHlXYWl0Iiwid2FpdCIsImNvbXBsZXRlZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWFkeVN0YXRlIiwiZG9TY3JvbGwiLCJhY2Nlc3MiLCJjaGFpbmFibGUiLCJlbXB0eUdldCIsInJhdyIsImJ1bGsiLCJhY2NlcHREYXRhIiwib3duZXIiLCJEYXRhIiwidWlkIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJzZXQiLCJkYXRhIiwicHJvcCIsImhhc0RhdGEiLCJkYXRhUHJpdiIsImRhdGFVc2VyIiwicmJyYWNlIiwicm11bHRpRGFzaCIsImdldERhdGEiLCJKU09OIiwicGFyc2UiLCJkYXRhQXR0ciIsInJlbW92ZURhdGEiLCJfZGF0YSIsIl9yZW1vdmVEYXRhIiwiZGVxdWV1ZSIsInN0YXJ0TGVuZ3RoIiwiaG9va3MiLCJfcXVldWVIb29rcyIsInN0b3AiLCJzZXR0ZXIiLCJjbGVhclF1ZXVlIiwiY291bnQiLCJkZWZlciIsInBudW0iLCJzb3VyY2UiLCJyY3NzTnVtIiwiY3NzRXhwYW5kIiwiaXNIaWRkZW5XaXRoaW5UcmVlIiwic3R5bGUiLCJkaXNwbGF5IiwiY3NzIiwic3dhcCIsIm9sZCIsImFkanVzdENTUyIsInZhbHVlUGFydHMiLCJ0d2VlbiIsImFkanVzdGVkIiwic2NhbGUiLCJtYXhJdGVyYXRpb25zIiwiY3VycmVudFZhbHVlIiwiaW5pdGlhbCIsInVuaXQiLCJjc3NOdW1iZXIiLCJpbml0aWFsSW5Vbml0IiwiZGVmYXVsdERpc3BsYXlNYXAiLCJnZXREZWZhdWx0RGlzcGxheSIsImJvZHkiLCJzaG93SGlkZSIsInNob3ciLCJ2YWx1ZXMiLCJoaWRlIiwidG9nZ2xlIiwicmNoZWNrYWJsZVR5cGUiLCJydGFnTmFtZSIsInJzY3JpcHRUeXBlIiwid3JhcE1hcCIsIm9wdGlvbiIsInRoZWFkIiwiY29sIiwidHIiLCJ0ZCIsIl9kZWZhdWx0Iiwib3B0Z3JvdXAiLCJ0Ym9keSIsInRmb290IiwiY29sZ3JvdXAiLCJjYXB0aW9uIiwidGgiLCJnZXRBbGwiLCJzZXRHbG9iYWxFdmFsIiwicmVmRWxlbWVudHMiLCJyaHRtbCIsImJ1aWxkRnJhZ21lbnQiLCJzY3JpcHRzIiwic2VsZWN0aW9uIiwiaWdub3JlZCIsIndyYXAiLCJmcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJub2RlcyIsImNyZWF0ZVRleHROb2RlIiwiaHRtbFByZWZpbHRlciIsImRpdiIsImNoZWNrQ2xvbmUiLCJjbG9uZU5vZGUiLCJub0Nsb25lQ2hlY2tlZCIsInJrZXlFdmVudCIsInJtb3VzZUV2ZW50IiwicnR5cGVuYW1lc3BhY2UiLCJyZXR1cm5UcnVlIiwicmV0dXJuRmFsc2UiLCJzYWZlQWN0aXZlRWxlbWVudCIsImVyciIsIm9uIiwidHlwZXMiLCJvbmUiLCJvcmlnRm4iLCJldmVudCIsIm9mZiIsImhhbmRsZU9iakluIiwiZXZlbnRIYW5kbGUiLCJldmVudHMiLCJ0IiwiaGFuZGxlT2JqIiwiaGFuZGxlcnMiLCJuYW1lc3BhY2VzIiwib3JpZ1R5cGUiLCJlbGVtRGF0YSIsImhhbmRsZSIsInRyaWdnZXJlZCIsImRpc3BhdGNoIiwiZGVsZWdhdGVUeXBlIiwiYmluZFR5cGUiLCJuYW1lc3BhY2UiLCJkZWxlZ2F0ZUNvdW50Iiwic2V0dXAiLCJtYXBwZWRUeXBlcyIsIm9yaWdDb3VudCIsInRlYXJkb3duIiwicmVtb3ZlRXZlbnQiLCJuYXRpdmVFdmVudCIsImZpeCIsImhhbmRsZXJRdWV1ZSIsImRlbGVnYXRlVGFyZ2V0IiwicHJlRGlzcGF0Y2giLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImN1cnJlbnRUYXJnZXQiLCJpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCIsInJuYW1lc3BhY2UiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInBvc3REaXNwYXRjaCIsIm1hdGNoZWRIYW5kbGVycyIsIm1hdGNoZWRTZWxlY3RvcnMiLCJidXR0b24iLCJhZGRQcm9wIiwiaG9vayIsIkV2ZW50IiwiZW51bWVyYWJsZSIsIm9yaWdpbmFsRXZlbnQiLCJ3cml0YWJsZSIsImxvYWQiLCJub0J1YmJsZSIsImZvY3VzIiwidHJpZ2dlciIsImJsdXIiLCJjbGljayIsImJlZm9yZXVubG9hZCIsInJldHVyblZhbHVlIiwicHJvcHMiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJkZWZhdWx0UHJldmVudGVkIiwicmVsYXRlZFRhcmdldCIsInRpbWVTdGFtcCIsImlzU2ltdWxhdGVkIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiYWx0S2V5IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjaGFuZ2VkVG91Y2hlcyIsImN0cmxLZXkiLCJkZXRhaWwiLCJldmVudFBoYXNlIiwibWV0YUtleSIsInBhZ2VYIiwicGFnZVkiLCJzaGlmdEtleSIsInZpZXciLCJjaGFyQ29kZSIsImtleUNvZGUiLCJidXR0b25zIiwiY2xpZW50WCIsImNsaWVudFkiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInBvaW50ZXJJZCIsInBvaW50ZXJUeXBlIiwic2NyZWVuWCIsInNjcmVlblkiLCJ0YXJnZXRUb3VjaGVzIiwidG9FbGVtZW50IiwidG91Y2hlcyIsIndoaWNoIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVybGVhdmUiLCJvcmlnIiwicmVsYXRlZCIsInJ4aHRtbFRhZyIsInJub0lubmVyaHRtbCIsInJjaGVja2VkIiwicnNjcmlwdFR5cGVNYXNrZWQiLCJyY2xlYW5TY3JpcHQiLCJtYW5pcHVsYXRpb25UYXJnZXQiLCJkaXNhYmxlU2NyaXB0IiwicmVzdG9yZVNjcmlwdCIsImNsb25lQ29weUV2ZW50IiwiZGVzdCIsInBkYXRhT2xkIiwicGRhdGFDdXIiLCJ1ZGF0YU9sZCIsInVkYXRhQ3VyIiwiZml4SW5wdXQiLCJkb21NYW5pcCIsImNvbGxlY3Rpb24iLCJoYXNTY3JpcHRzIiwiaU5vQ2xvbmUiLCJodG1sIiwiX2V2YWxVcmwiLCJrZWVwRGF0YSIsImNsZWFuRGF0YSIsImRhdGFBbmRFdmVudHMiLCJkZWVwRGF0YUFuZEV2ZW50cyIsInNyY0VsZW1lbnRzIiwiZGVzdEVsZW1lbnRzIiwiaW5QYWdlIiwiZGV0YWNoIiwiYXBwZW5kIiwicHJlcGVuZCIsImluc2VydEJlZm9yZSIsImJlZm9yZSIsImFmdGVyIiwicmVwbGFjZVdpdGgiLCJyZXBsYWNlQ2hpbGQiLCJhcHBlbmRUbyIsInByZXBlbmRUbyIsImluc2VydEFmdGVyIiwicmVwbGFjZUFsbCIsIm9yaWdpbmFsIiwiaW5zZXJ0Iiwicm1hcmdpbiIsInJudW1ub25weCIsImdldFN0eWxlcyIsIm9wZW5lciIsImdldENvbXB1dGVkU3R5bGUiLCJjb21wdXRlU3R5bGVUZXN0cyIsImNzc1RleHQiLCJjb250YWluZXIiLCJkaXZTdHlsZSIsInBpeGVsUG9zaXRpb25WYWwiLCJyZWxpYWJsZU1hcmdpbkxlZnRWYWwiLCJtYXJnaW5MZWZ0IiwiYm94U2l6aW5nUmVsaWFibGVWYWwiLCJ3aWR0aCIsIm1hcmdpblJpZ2h0IiwicGl4ZWxNYXJnaW5SaWdodFZhbCIsImJhY2tncm91bmRDbGlwIiwiY2xlYXJDbG9uZVN0eWxlIiwicGl4ZWxQb3NpdGlvbiIsImJveFNpemluZ1JlbGlhYmxlIiwicGl4ZWxNYXJnaW5SaWdodCIsInJlbGlhYmxlTWFyZ2luTGVmdCIsImN1ckNTUyIsImNvbXB1dGVkIiwibWluV2lkdGgiLCJtYXhXaWR0aCIsImdldFByb3BlcnR5VmFsdWUiLCJhZGRHZXRIb29rSWYiLCJjb25kaXRpb25GbiIsImhvb2tGbiIsInJkaXNwbGF5c3dhcCIsInJjdXN0b21Qcm9wIiwiY3NzU2hvdyIsInBvc2l0aW9uIiwidmlzaWJpbGl0eSIsImNzc05vcm1hbFRyYW5zZm9ybSIsImxldHRlclNwYWNpbmciLCJmb250V2VpZ2h0IiwiY3NzUHJlZml4ZXMiLCJlbXB0eVN0eWxlIiwidmVuZG9yUHJvcE5hbWUiLCJjYXBOYW1lIiwiZmluYWxQcm9wTmFtZSIsImNzc1Byb3BzIiwic2V0UG9zaXRpdmVOdW1iZXIiLCJzdWJ0cmFjdCIsIm1heCIsImF1Z21lbnRXaWR0aE9ySGVpZ2h0IiwiZXh0cmEiLCJpc0JvcmRlckJveCIsInN0eWxlcyIsImdldFdpZHRoT3JIZWlnaHQiLCJ2YWx1ZUlzQm9yZGVyQm94IiwiY3NzSG9va3MiLCJvcGFjaXR5Iiwib3JpZ05hbWUiLCJpc0N1c3RvbVByb3AiLCJzZXRQcm9wZXJ0eSIsImlzRmluaXRlIiwiZ2V0Q2xpZW50UmVjdHMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJsZWZ0IiwibWFyZ2luIiwicGFkZGluZyIsImJvcmRlciIsInByZWZpeCIsInN1ZmZpeCIsImV4cGFuZCIsImV4cGFuZGVkIiwicGFydHMiLCJUd2VlbiIsImVhc2luZyIsInByb3BIb29rcyIsInJ1biIsInBlcmNlbnQiLCJlYXNlZCIsImR1cmF0aW9uIiwicG9zIiwic3RlcCIsImZ4Iiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsImxpbmVhciIsInAiLCJzd2luZyIsImNvcyIsIlBJIiwiZnhOb3ciLCJpblByb2dyZXNzIiwicmZ4dHlwZXMiLCJycnVuIiwic2NoZWR1bGUiLCJoaWRkZW4iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJpbnRlcnZhbCIsInRpY2siLCJjcmVhdGVGeE5vdyIsImdlbkZ4IiwiaW5jbHVkZVdpZHRoIiwiaGVpZ2h0IiwiY3JlYXRlVHdlZW4iLCJhbmltYXRpb24iLCJBbmltYXRpb24iLCJ0d2VlbmVycyIsImRlZmF1bHRQcmVmaWx0ZXIiLCJvcHRzIiwib2xkZmlyZSIsInByb3BUd2VlbiIsInJlc3RvcmVEaXNwbGF5IiwiaXNCb3giLCJhbmltIiwiZGF0YVNob3ciLCJ1bnF1ZXVlZCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwicHJvcEZpbHRlciIsInNwZWNpYWxFYXNpbmciLCJwcm9wZXJ0aWVzIiwic3RvcHBlZCIsInByZWZpbHRlcnMiLCJjdXJyZW50VGltZSIsInN0YXJ0VGltZSIsInR3ZWVucyIsIm9yaWdpbmFsUHJvcGVydGllcyIsIm9yaWdpbmFsT3B0aW9ucyIsImdvdG9FbmQiLCJjb21wbGV0ZSIsInRpbWVyIiwidHdlZW5lciIsInByZWZpbHRlciIsInNwZWVkIiwib3B0Iiwic3BlZWRzIiwiZmFkZVRvIiwidG8iLCJhbmltYXRlIiwib3B0YWxsIiwiZG9BbmltYXRpb24iLCJmaW5pc2giLCJzdG9wUXVldWUiLCJ0aW1lcnMiLCJjc3NGbiIsInNsaWRlRG93biIsInNsaWRlVXAiLCJzbGlkZVRvZ2dsZSIsImZhZGVJbiIsImZhZGVPdXQiLCJmYWRlVG9nZ2xlIiwic2xvdyIsImZhc3QiLCJkZWxheSIsInRpbWUiLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY2hlY2tPbiIsIm9wdFNlbGVjdGVkIiwicmFkaW9WYWx1ZSIsImJvb2xIb29rIiwicmVtb3ZlQXR0ciIsIm5UeXBlIiwiYXR0ckhvb2tzIiwiYm9vbCIsImF0dHJOYW1lcyIsImdldHRlciIsImxvd2VyY2FzZU5hbWUiLCJyZm9jdXNhYmxlIiwicmNsaWNrYWJsZSIsInJlbW92ZVByb3AiLCJwcm9wRml4IiwidGFiaW5kZXgiLCJwYXJzZUludCIsInN0cmlwQW5kQ29sbGFwc2UiLCJnZXRDbGFzcyIsImFkZENsYXNzIiwiY2xhc3NlcyIsImN1clZhbHVlIiwiY2xhenoiLCJmaW5hbFZhbHVlIiwicmVtb3ZlQ2xhc3MiLCJ0b2dnbGVDbGFzcyIsInN0YXRlVmFsIiwiY2xhc3NOYW1lcyIsImhhc0NsYXNzIiwicnJldHVybiIsInZhbEhvb2tzIiwib3B0aW9uU2V0IiwicmZvY3VzTW9ycGgiLCJvbmx5SGFuZGxlcnMiLCJidWJibGVUeXBlIiwib250eXBlIiwiZXZlbnRQYXRoIiwiaXNUcmlnZ2VyIiwicGFyZW50V2luZG93Iiwic2ltdWxhdGUiLCJ0cmlnZ2VySGFuZGxlciIsImhvdmVyIiwiZm5PdmVyIiwiZm5PdXQiLCJmb2N1c2luIiwiYXR0YWNoZXMiLCJub25jZSIsInJxdWVyeSIsInBhcnNlWE1MIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwicmJyYWNrZXQiLCJyQ1JMRiIsInJzdWJtaXR0ZXJUeXBlcyIsInJzdWJtaXR0YWJsZSIsImJ1aWxkUGFyYW1zIiwidHJhZGl0aW9uYWwiLCJwYXJhbSIsInMiLCJ2YWx1ZU9yRnVuY3Rpb24iLCJlbmNvZGVVUklDb21wb25lbnQiLCJzZXJpYWxpemUiLCJzZXJpYWxpemVBcnJheSIsInIyMCIsInJoYXNoIiwicmFudGlDYWNoZSIsInJoZWFkZXJzIiwicmxvY2FsUHJvdG9jb2wiLCJybm9Db250ZW50IiwicnByb3RvY29sIiwidHJhbnNwb3J0cyIsImFsbFR5cGVzIiwib3JpZ2luQW5jaG9yIiwiYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzIiwic3RydWN0dXJlIiwiZGF0YVR5cGVFeHByZXNzaW9uIiwiZGF0YVR5cGUiLCJkYXRhVHlwZXMiLCJpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyIsImpxWEhSIiwiaW5zcGVjdGVkIiwic2Vla2luZ1RyYW5zcG9ydCIsImluc3BlY3QiLCJwcmVmaWx0ZXJPckZhY3RvcnkiLCJkYXRhVHlwZU9yVHJhbnNwb3J0IiwiYWpheEV4dGVuZCIsImZsYXRPcHRpb25zIiwiYWpheFNldHRpbmdzIiwiYWpheEhhbmRsZVJlc3BvbnNlcyIsInJlc3BvbnNlcyIsImN0IiwiZmluYWxEYXRhVHlwZSIsImZpcnN0RGF0YVR5cGUiLCJtaW1lVHlwZSIsImdldFJlc3BvbnNlSGVhZGVyIiwiY29udmVydGVycyIsImFqYXhDb252ZXJ0IiwicmVzcG9uc2UiLCJpc1N1Y2Nlc3MiLCJjb252MiIsImN1cnJlbnQiLCJjb252IiwicmVzcG9uc2VGaWVsZHMiLCJkYXRhRmlsdGVyIiwidGhyb3dzIiwiYWN0aXZlIiwibGFzdE1vZGlmaWVkIiwiZXRhZyIsInVybCIsImlzTG9jYWwiLCJwcm90b2NvbCIsInByb2Nlc3NEYXRhIiwiYXN5bmMiLCJjb250ZW50VHlwZSIsImFjY2VwdHMiLCJqc29uIiwiYWpheFNldHVwIiwic2V0dGluZ3MiLCJhamF4UHJlZmlsdGVyIiwiYWpheFRyYW5zcG9ydCIsImFqYXgiLCJ0cmFuc3BvcnQiLCJjYWNoZVVSTCIsInJlc3BvbnNlSGVhZGVyc1N0cmluZyIsInJlc3BvbnNlSGVhZGVycyIsInRpbWVvdXRUaW1lciIsInVybEFuY2hvciIsImZpcmVHbG9iYWxzIiwidW5jYWNoZWQiLCJjYWxsYmFja0NvbnRleHQiLCJnbG9iYWxFdmVudENvbnRleHQiLCJjb21wbGV0ZURlZmVycmVkIiwic3RhdHVzQ29kZSIsInJlcXVlc3RIZWFkZXJzIiwicmVxdWVzdEhlYWRlcnNOYW1lcyIsInN0ckFib3J0IiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwic2V0UmVxdWVzdEhlYWRlciIsIm92ZXJyaWRlTWltZVR5cGUiLCJzdGF0dXMiLCJhYm9ydCIsInN0YXR1c1RleHQiLCJmaW5hbFRleHQiLCJjcm9zc0RvbWFpbiIsImhvc3QiLCJoYXNDb250ZW50IiwiaWZNb2RpZmllZCIsImhlYWRlcnMiLCJiZWZvcmVTZW5kIiwic3VjY2VzcyIsInNlbmQiLCJuYXRpdmVTdGF0dXNUZXh0IiwibW9kaWZpZWQiLCJnZXRKU09OIiwiZ2V0U2NyaXB0Iiwid3JhcEFsbCIsImZpcnN0RWxlbWVudENoaWxkIiwid3JhcElubmVyIiwidW53cmFwIiwidmlzaWJsZSIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJ4aHJTdWNjZXNzU3RhdHVzIiwieGhyU3VwcG9ydGVkIiwiY29ycyIsImVycm9yQ2FsbGJhY2siLCJvcGVuIiwidXNlcm5hbWUiLCJ4aHJGaWVsZHMiLCJvbmxvYWQiLCJvbmVycm9yIiwib25hYm9ydCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlc3BvbnNlVHlwZSIsInJlc3BvbnNlVGV4dCIsImJpbmFyeSIsImNoYXJzZXQiLCJzY3JpcHRDaGFyc2V0IiwiZXZ0Iiwib2xkQ2FsbGJhY2tzIiwicmpzb25wIiwianNvbnAiLCJqc29ucENhbGxiYWNrIiwib3JpZ2luYWxTZXR0aW5ncyIsImNhbGxiYWNrTmFtZSIsIm92ZXJ3cml0dGVuIiwicmVzcG9uc2VDb250YWluZXIiLCJqc29uUHJvcCIsImNyZWF0ZUhUTUxEb2N1bWVudCIsImltcGxlbWVudGF0aW9uIiwia2VlcFNjcmlwdHMiLCJwYXJzZWQiLCJwYXJhbXMiLCJhbmltYXRlZCIsIm9mZnNldCIsInNldE9mZnNldCIsImN1clBvc2l0aW9uIiwiY3VyTGVmdCIsImN1ckNTU1RvcCIsImN1clRvcCIsImN1ck9mZnNldCIsImN1ckNTU0xlZnQiLCJjYWxjdWxhdGVQb3NpdGlvbiIsImN1ckVsZW0iLCJ1c2luZyIsInJlY3QiLCJ3aW4iLCJwYWdlWU9mZnNldCIsImNsaWVudFRvcCIsInBhZ2VYT2Zmc2V0IiwiY2xpZW50TGVmdCIsIm9mZnNldFBhcmVudCIsInBhcmVudE9mZnNldCIsInNjcm9sbFRvIiwiSGVpZ2h0IiwiV2lkdGgiLCJkZWZhdWx0RXh0cmEiLCJmdW5jTmFtZSIsImJpbmQiLCJ1bmJpbmQiLCJkZWxlZ2F0ZSIsInVuZGVsZWdhdGUiLCJob2xkUmVhZHkiLCJob2xkIiwicGFyc2VKU09OIiwiZGVmaW5lIiwiX2pRdWVyeSIsIl8kIiwiJCIsIm5vQ29uZmxpY3QiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7Ozs7QUFhQSxDQUFFLFVBQVVBLE1BQVYsRUFBa0JDLE9BQWxCLEVBQTRCOztBQUU3Qjs7QUFFQSxLQUFLLGdDQUFP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RUFBa0Q7QUFDakRrNkIsRUFBQSxpQ0FBa0IsRUFBbEIsa0NBQXNCLFlBQVc7QUFDaEMsVUFBT3ZsQyxNQUFQO0FBQ0EsR0FGRDtBQUFBO0FBR0E7O0FBS0Q7O0FBRUM7QUFDQXdsQyxXQUFVcm5DLE9BQU82QixNQUhsQjs7O0FBS0M7QUFDQXlsQyxNQUFLdG5DLE9BQU91bkMsQ0FOYjs7QUFRQTFsQyxRQUFPMmxDLFVBQVAsR0FBb0IsVUFBVTVpQyxJQUFWLEVBQWlCO0FBQ3BDLE1BQUs1RSxPQUFPdW5DLENBQVAsS0FBYTFsQyxNQUFsQixFQUEyQjtBQUMxQjdCLFVBQU91bkMsQ0FBUCxHQUFXRCxFQUFYO0FBQ0E7O0FBRUQsTUFBSzFpQyxRQUFRNUUsT0FBTzZCLE1BQVAsS0FBa0JBLE1BQS9CLEVBQXdDO0FBQ3ZDN0IsVUFBTzZCLE1BQVAsR0FBZ0J3bEMsT0FBaEI7QUFDQTs7QUFFRCxTQUFPeGxDLE1BQVA7QUFDQSxFQVZEOztBQVlBO0FBQ0E7QUFDQTtBQUNBLEtBQUssQ0FBQzVCLFFBQU4sRUFBaUI7QUFDaEJELFNBQU82QixNQUFQLEdBQWdCN0IsT0FBT3VuQyxDQUFQLEdBQVcxbEMsTUFBM0I7QUFDQTs7QUFLRCxRQUFPQSxNQUFQO0FBQ0MsQ0EvL1RELEUiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4yLjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE3LTAzLTIwVDE4OjU5WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy4yLjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nLFxuXG5cdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZmNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBhbGwsIGxldHRlciApIHtcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBBcnJheS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJmdW5jdGlvblwiO1xuXHR9LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0XHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdFx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0XHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xuXHR9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy82MTI1XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdERPTUV2YWwoIGNvZGUgKTtcblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTNcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogRGF0ZS5ub3csXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4zXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wOC0wOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRkaXNhYmxlZEFuY2VzdG9yID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcImZvcm1cIiBpbiBlbGVtIHx8IFwibGFiZWxcIiBpbiBlbGVtKTtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGRpc2FibGVkQW5jZXN0b3IoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbXBsZSBzZWxlY3RvciB0aGF0IGNhbiBiZSBmaWx0ZXJlZCBkaXJlY3RseSwgcmVtb3Zpbmcgbm9uLUVsZW1lbnRzXG5cdGlmICggcmlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0fVxuXG5cdC8vIENvbXBsZXggc2VsZWN0b3IsIGNvbXBhcmUgdGhlIHR3byBzZXRzLCByZW1vdmluZyBub24tRWxlbWVudHNcblx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90ICYmIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwiaWZyYW1lXCIgKSApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuICAgICAgICAvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCBpdC5cbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG4gICAgICAgICAgICBlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgalF1ZXJ5LnR5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgalF1ZXJ5LmNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0Ly8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cblx0XHR9IHdoaWxlIChcblx0XHRcdHNjYWxlICE9PSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsICkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zXG5cdFx0KTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIGpRdWVyeS50eXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGpRdWVyeS5pc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblxuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksXG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBcIj50Ym9keVwiLCBlbGVtIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJtYXJnaW4gPSAoIC9ebWFyZ2luLyApO1xuXG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBwaXhlbE1hcmdpblJpZ2h0VmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7d2lkdGg6OHB4O2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDtcIiArXG5cdFx0XCJwYWRkaW5nOjA7bWFyZ2luLXRvcDoxcHg7cG9zaXRpb246YWJzb2x1dGVcIjtcblx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsTWFyZ2luUmlnaHRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxNYXJnaW5SaWdodCgpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH0sXG5cblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwcm9wZXJ0eSBtYXBwZWQgYWxvbmcgd2hhdCBqUXVlcnkuY3NzUHJvcHMgc3VnZ2VzdHMgb3IgdG9cbi8vIGEgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5LlxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdO1xuXHRpZiAoICFyZXQgKSB7XG5cdFx0cmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG5cdH1cblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzICkge1xuXHR2YXIgaSxcblx0XHR2YWwgPSAwO1xuXG5cdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRpZiAoIGV4dHJhID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0aSA9IDQ7XG5cblx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHR9IGVsc2Uge1xuXHRcdGkgPSBuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpbiwgc28gYWRkIGl0IGlmIHdlIHdhbnQgaXRcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdGlmICggaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxuXHRcdFx0aWYgKCBleHRyYSA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcblx0XHRcdGlmICggZXh0cmEgIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciB2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG5cdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuXHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgbmFtZSBdICk7XG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL0hlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0aWYgKCB2YWwgPT09IFwiYXV0b1wiICkge1xuXHRcdHZhbCA9IGVsZW1bIFwib2Zmc2V0XCIgKyBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSBdO1xuXHR9XG5cblx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG5cdHJldHVybiAoIHZhbCArXG5cdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0bmFtZSxcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXNcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCk7XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHxcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1lcblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdGpRdWVyeS5wcm94eSggcmVzdWx0LnN0b3AsIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTNcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFwidGhyb3dzXCI6IHRydWVcblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciBkb2MsIGRvY0VsZW0sIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0d2luID0gZG9jLmRlZmF1bHRWaWV3O1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxuXHRcdH07XG5cdH0sXG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sXG5cdFx0Ly8gYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIW5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdHBhcmVudE9mZnNldCA9IHtcblx0XHRcdFx0dG9wOiBwYXJlbnRPZmZzZXQudG9wICsgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApLFxuXHRcdFx0XHRsZWZ0OiBwYXJlbnRPZmZzZXQubGVmdCArIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlIClcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lZGl0YWJsZS9qcy9qcXVlcnkuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n')},function(module,exports){eval('var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {\n  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);\n};\n\nvar wysihtml5 = {\n  version: "0.3.0",\n\n  // namespaces\n  commands: {},\n  dom: {},\n  quirks: {},\n  toolbar: {},\n  lang: {},\n  selection: {},\n  views: {},\n\n  INVISIBLE_SPACE: "\\uFEFF",\n\n  EMPTY_FUNCTION: function EMPTY_FUNCTION() {},\n\n  ELEMENT_NODE: 1,\n  TEXT_NODE: 3,\n\n  BACKSPACE_KEY: 8,\n  ENTER_KEY: 13,\n  ESCAPE_KEY: 27,\n  SPACE_KEY: 32,\n  DELETE_KEY: 46\n}; /**\n   * @license Rangy, a cross-browser JavaScript range and selection library\n   * http://code.google.com/p/rangy/\n   *\n   * Copyright 2011, Tim Down\n   * Licensed under the MIT license.\n   * Version: 1.2.2\n   * Build date: 13 November 2011\n   */\nwindow[\'rangy\'] = function () {\n\n  var OBJECT = "object",\n      FUNCTION = "function",\n      UNDEFINED = "undefined";\n\n  var domRangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed", "commonAncestorContainer", "START_TO_START", "START_TO_END", "END_TO_START", "END_TO_END"];\n\n  var domRangeMethods = ["setStart", "setStartBefore", "setStartAfter", "setEnd", "setEndBefore", "setEndAfter", "collapse", "selectNode", "selectNodeContents", "compareBoundaryPoints", "deleteContents", "extractContents", "cloneContents", "insertNode", "surroundContents", "cloneRange", "toString", "detach"];\n\n  var textRangeProperties = ["boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "htmlText", "text"];\n\n  // Subset of TextRange\'s full set of methods that we\'re interested in\n  var textRangeMethods = ["collapse", "compareEndPoints", "duplicate", "getBookmark", "moveToBookmark", "moveToElementText", "parentElement", "pasteHTML", "select", "setEndPoint", "getBoundingClientRect"];\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Trio of functions taken from Peter Michaux\'s article:\n  // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting\n  function isHostMethod(o, p) {\n    var t = _typeof(o[p]);\n    return t == FUNCTION || !!(t == OBJECT && o[p]) || t == "unknown";\n  }\n\n  function isHostObject(o, p) {\n    return !!(_typeof(o[p]) == OBJECT && o[p]);\n  }\n\n  function isHostProperty(o, p) {\n    return _typeof(o[p]) != UNDEFINED;\n  }\n\n  // Creates a convenience function to save verbose repeated calls to tests functions\n  function createMultiplePropertyTest(testFunc) {\n    return function (o, props) {\n      var i = props.length;\n      while (i--) {\n        if (!testFunc(o, props[i])) {\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n\n  // Next trio of functions are a convenience to save verbose repeated calls to previous two functions\n  var areHostMethods = createMultiplePropertyTest(isHostMethod);\n  var areHostObjects = createMultiplePropertyTest(isHostObject);\n  var areHostProperties = createMultiplePropertyTest(isHostProperty);\n\n  function isTextRange(range) {\n    return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);\n  }\n\n  var api = {\n    version: "1.2.2",\n    initialized: false,\n    supported: true,\n\n    util: {\n      isHostMethod: isHostMethod,\n      isHostObject: isHostObject,\n      isHostProperty: isHostProperty,\n      areHostMethods: areHostMethods,\n      areHostObjects: areHostObjects,\n      areHostProperties: areHostProperties,\n      isTextRange: isTextRange\n    },\n\n    features: {},\n\n    modules: {},\n    config: {\n      alertOnWarn: false,\n      preferTextRange: false\n    }\n  };\n\n  function fail(reason) {\n    window.alert("Rangy not supported in your browser. Reason: " + reason);\n    api.initialized = true;\n    api.supported = false;\n  }\n\n  api.fail = fail;\n\n  function warn(msg) {\n    var warningMessage = "Rangy warning: " + msg;\n    if (api.config.alertOnWarn) {\n      window.alert(warningMessage);\n    } else if (_typeof(window.console) != UNDEFINED && _typeof(window.console.log) != UNDEFINED) {\n      window.console.log(warningMessage);\n    }\n  }\n\n  api.warn = warn;\n\n  if ({}.hasOwnProperty) {\n    api.util.extend = function (o, props) {\n      for (var i in props) {\n        if (props.hasOwnProperty(i)) {\n          o[i] = props[i];\n        }\n      }\n    };\n  } else {\n    fail("hasOwnProperty not supported");\n  }\n\n  var initListeners = [];\n  var moduleInitializers = [];\n\n  // Initialization\n  function init() {\n    if (api.initialized) {\n      return;\n    }\n    var testRange;\n    var implementsDomRange = false,\n        implementsTextRange = false;\n\n    // First, perform basic feature tests\n\n    if (isHostMethod(document, "createRange")) {\n      testRange = document.createRange();\n      if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {\n        implementsDomRange = true;\n      }\n      testRange.detach();\n    }\n\n    var body = isHostObject(document, "body") ? document.body : document.getElementsByTagName("body")[0];\n\n    if (body && isHostMethod(body, "createTextRange")) {\n      testRange = body.createTextRange();\n      if (isTextRange(testRange)) {\n        implementsTextRange = true;\n      }\n    }\n\n    if (!implementsDomRange && !implementsTextRange) {\n      fail("Neither Range nor TextRange are implemented");\n    }\n\n    api.initialized = true;\n    api.features = {\n      implementsDomRange: implementsDomRange,\n      implementsTextRange: implementsTextRange\n    };\n\n    // Initialize modules and call init listeners\n    var allListeners = moduleInitializers.concat(initListeners);\n    for (var i = 0, len = allListeners.length; i < len; ++i) {\n      try {\n        allListeners[i](api);\n      } catch (ex) {\n        if (isHostObject(window, "console") && isHostMethod(window.console, "log")) {\n          window.console.log("Init listener threw an exception. Continuing.", ex);\n        }\n      }\n    }\n  }\n\n  // Allow external scripts to initialize this library in case it\'s loaded after the document has loaded\n  api.init = init;\n\n  // Execute listener immediately if already initialized\n  api.addInitListener = function (listener) {\n    if (api.initialized) {\n      listener(api);\n    } else {\n      initListeners.push(listener);\n    }\n  };\n\n  var createMissingNativeApiListeners = [];\n\n  api.addCreateMissingNativeApiListener = function (listener) {\n    createMissingNativeApiListeners.push(listener);\n  };\n\n  function createMissingNativeApi(win) {\n    win = win || window;\n    init();\n\n    // Notify listeners\n    for (var i = 0, len = createMissingNativeApiListeners.length; i < len; ++i) {\n      createMissingNativeApiListeners[i](win);\n    }\n  }\n\n  api.createMissingNativeApi = createMissingNativeApi;\n\n  /**\n   * @constructor\n   */\n  function Module(name) {\n    this.name = name;\n    this.initialized = false;\n    this.supported = false;\n  }\n\n  Module.prototype.fail = function (reason) {\n    this.initialized = true;\n    this.supported = false;\n\n    throw new Error("Module \'" + this.name + "\' failed to load: " + reason);\n  };\n\n  Module.prototype.warn = function (msg) {\n    api.warn("Module " + this.name + ": " + msg);\n  };\n\n  Module.prototype.createError = function (msg) {\n    return new Error("Error in Rangy " + this.name + " module: " + msg);\n  };\n\n  api.createModule = function (name, initFunc) {\n    var module = new Module(name);\n    api.modules[name] = module;\n\n    moduleInitializers.push(function (api) {\n      initFunc(api, module);\n      module.initialized = true;\n      module.supported = true;\n    });\n  };\n\n  api.requireModules = function (modules) {\n    for (var i = 0, len = modules.length, module, moduleName; i < len; ++i) {\n      moduleName = modules[i];\n      module = api.modules[moduleName];\n      if (!module || !(module instanceof Module)) {\n        throw new Error("Module \'" + moduleName + "\' not found");\n      }\n      if (!module.supported) {\n        throw new Error("Module \'" + moduleName + "\' not supported");\n      }\n    }\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Wait for document to load before running tests\n\n  var docReady = false;\n\n  var loadHandler = function loadHandler(e) {\n\n    if (!docReady) {\n      docReady = true;\n      if (!api.initialized) {\n        init();\n      }\n    }\n  };\n\n  // Test whether we have window and document objects that we will need\n  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) == UNDEFINED) {\n    fail("No window found");\n    return;\n  }\n  if ((typeof document === "undefined" ? "undefined" : _typeof(document)) == UNDEFINED) {\n    fail("No document found");\n    return;\n  }\n\n  if (isHostMethod(document, "addEventListener")) {\n    document.addEventListener("DOMContentLoaded", loadHandler, false);\n  }\n\n  // Add a fallback in case the DOMContentLoaded event isn\'t supported\n  if (isHostMethod(window, "addEventListener")) {\n    window.addEventListener("load", loadHandler, false);\n  } else if (isHostMethod(window, "attachEvent")) {\n    window.attachEvent("onload", loadHandler);\n  } else {\n    fail("Window does not have required addEventListener or attachEvent method");\n  }\n\n  return api;\n}();\nrangy.createModule("DomUtil", function (api, module) {\n\n  var UNDEF = "undefined";\n  var util = api.util;\n\n  // Perform feature tests\n  if (!util.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {\n    module.fail("document missing a Node creation method");\n  }\n\n  if (!util.isHostMethod(document, "getElementsByTagName")) {\n    module.fail("document missing getElementsByTagName method");\n  }\n\n  var el = document.createElement("div");\n  if (!util.areHostMethods(el, ["insertBefore", "appendChild", "cloneNode"] || !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]))) {\n    module.fail("Incomplete Element implementation");\n  }\n\n  // innerHTML is required for Range\'s createContextualFragment method\n  if (!util.isHostProperty(el, "innerHTML")) {\n    module.fail("Element is missing innerHTML property");\n  }\n\n  var textNode = document.createTextNode("test");\n  if (!util.areHostMethods(textNode, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"] || !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]) || !util.areHostProperties(textNode, ["data"]))) {\n    module.fail("Incomplete Text Node implementation");\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven\'t been\n  // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that\n  // contains just the document as a single element and the value searched for is the document.\n  var arrayContains = /*Array.prototype.indexOf ?\n                      function(arr, val) {\n                      return arr.indexOf(val) > -1;\n                      }:*/\n\n  function arrayContains(arr, val) {\n    var i = arr.length;\n    while (i--) {\n      if (arr[i] === val) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI\n  function isHtmlNamespace(node) {\n    var ns;\n    return _typeof(node.namespaceURI) == UNDEF || (ns = node.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml";\n  }\n\n  function parentElement(node) {\n    var parent = node.parentNode;\n    return parent.nodeType == 1 ? parent : null;\n  }\n\n  function getNodeIndex(node) {\n    var i = 0;\n    while (node = node.previousSibling) {\n      i++;\n    }\n    return i;\n  }\n\n  function getNodeLength(node) {\n    var childNodes;\n    return isCharacterDataNode(node) ? node.length : (childNodes = node.childNodes) ? childNodes.length : 0;\n  }\n\n  function getCommonAncestor(node1, node2) {\n    var ancestors = [],\n        n;\n    for (n = node1; n; n = n.parentNode) {\n      ancestors.push(n);\n    }\n\n    for (n = node2; n; n = n.parentNode) {\n      if (arrayContains(ancestors, n)) {\n        return n;\n      }\n    }\n\n    return null;\n  }\n\n  function isAncestorOf(ancestor, descendant, selfIsAncestor) {\n    var n = selfIsAncestor ? descendant : descendant.parentNode;\n    while (n) {\n      if (n === ancestor) {\n        return true;\n      } else {\n        n = n.parentNode;\n      }\n    }\n    return false;\n  }\n\n  function getClosestAncestorIn(node, ancestor, selfIsAncestor) {\n    var p,\n        n = selfIsAncestor ? node : node.parentNode;\n    while (n) {\n      p = n.parentNode;\n      if (p === ancestor) {\n        return n;\n      }\n      n = p;\n    }\n    return null;\n  }\n\n  function isCharacterDataNode(node) {\n    var t = node.nodeType;\n    return t == 3 || t == 4 || t == 8; // Text, CDataSection or Comment\n  }\n\n  function insertAfter(node, precedingNode) {\n    var nextNode = precedingNode.nextSibling,\n        parent = precedingNode.parentNode;\n    if (nextNode) {\n      parent.insertBefore(node, nextNode);\n    } else {\n      parent.appendChild(node);\n    }\n    return node;\n  }\n\n  // Note that we cannot use splitText() because it is bugridden in IE 9.\n  function splitDataNode(node, index) {\n    var newNode = node.cloneNode(false);\n    newNode.deleteData(0, index);\n    node.deleteData(index, node.length - index);\n    insertAfter(newNode, node);\n    return newNode;\n  }\n\n  function getDocument(node) {\n    if (node.nodeType == 9) {\n      return node;\n    } else if (_typeof(node.ownerDocument) != UNDEF) {\n      return node.ownerDocument;\n    } else if (_typeof(node.document) != UNDEF) {\n      return node.document;\n    } else if (node.parentNode) {\n      return getDocument(node.parentNode);\n    } else {\n      throw new Error("getDocument: no document found for node");\n    }\n  }\n\n  function getWindow(node) {\n    var doc = getDocument(node);\n    if (_typeof(doc.defaultView) != UNDEF) {\n      return doc.defaultView;\n    } else if (_typeof(doc.parentWindow) != UNDEF) {\n      return doc.parentWindow;\n    } else {\n      throw new Error("Cannot get a window object for node");\n    }\n  }\n\n  function getIframeDocument(iframeEl) {\n    if (_typeof(iframeEl.contentDocument) != UNDEF) {\n      return iframeEl.contentDocument;\n    } else if (_typeof(iframeEl.contentWindow) != UNDEF) {\n      return iframeEl.contentWindow.document;\n    } else {\n      throw new Error("getIframeWindow: No Document object found for iframe element");\n    }\n  }\n\n  function getIframeWindow(iframeEl) {\n    if (_typeof(iframeEl.contentWindow) != UNDEF) {\n      return iframeEl.contentWindow;\n    } else if (_typeof(iframeEl.contentDocument) != UNDEF) {\n      return iframeEl.contentDocument.defaultView;\n    } else {\n      throw new Error("getIframeWindow: No Window object found for iframe element");\n    }\n  }\n\n  function getBody(doc) {\n    return util.isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];\n  }\n\n  function getRootContainer(node) {\n    var parent;\n    while (parent = node.parentNode) {\n      node = parent;\n    }\n    return node;\n  }\n\n  function comparePoints(nodeA, offsetA, nodeB, offsetB) {\n    // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing\n    var nodeC, root, childA, childB, n;\n    if (nodeA == nodeB) {\n\n      // Case 1: nodes are the same\n      return offsetA === offsetB ? 0 : offsetA < offsetB ? -1 : 1;\n    } else if (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) {\n\n      // Case 2: node C (container B or an ancestor) is a child node of A\n      return offsetA <= getNodeIndex(nodeC) ? -1 : 1;\n    } else if (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) {\n\n      // Case 3: node C (container A or an ancestor) is a child node of B\n      return getNodeIndex(nodeC) < offsetB ? -1 : 1;\n    } else {\n\n      // Case 4: containers are siblings or descendants of siblings\n      root = getCommonAncestor(nodeA, nodeB);\n      childA = nodeA === root ? root : getClosestAncestorIn(nodeA, root, true);\n      childB = nodeB === root ? root : getClosestAncestorIn(nodeB, root, true);\n\n      if (childA === childB) {\n        // This shouldn\'t be possible\n\n        throw new Error("comparePoints got to case 4 and childA and childB are the same!");\n      } else {\n        n = root.firstChild;\n        while (n) {\n          if (n === childA) {\n            return -1;\n          } else if (n === childB) {\n            return 1;\n          }\n          n = n.nextSibling;\n        }\n        throw new Error("Should not be here!");\n      }\n    }\n  }\n\n  function fragmentFromNodeChildren(node) {\n    var fragment = getDocument(node).createDocumentFragment(),\n        child;\n    while (child = node.firstChild) {\n      fragment.appendChild(child);\n    }\n    return fragment;\n  }\n\n  function inspectNode(node) {\n    if (!node) {\n      return "[No node]";\n    }\n    if (isCharacterDataNode(node)) {\n      return \'"\' + node.data + \'"\';\n    } else if (node.nodeType == 1) {\n      var idAttr = node.id ? \' id="\' + node.id + \'"\' : "";\n      return "<" + node.nodeName + idAttr + ">[" + node.childNodes.length + "]";\n    } else {\n      return node.nodeName;\n    }\n  }\n\n  /**\n   * @constructor\n   */\n  function NodeIterator(root) {\n    this.root = root;\n    this._next = root;\n  }\n\n  NodeIterator.prototype = {\n    _current: null,\n\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n\n    next: function next() {\n      var n = this._current = this._next;\n      var child, next;\n      if (this._current) {\n        child = n.firstChild;\n        if (child) {\n          this._next = child;\n        } else {\n          next = null;\n          while (n !== this.root && !(next = n.nextSibling)) {\n            n = n.parentNode;\n          }\n          this._next = next;\n        }\n      }\n      return this._current;\n    },\n\n    detach: function detach() {\n      this._current = this._next = this.root = null;\n    }\n  };\n\n  function createIterator(root) {\n    return new NodeIterator(root);\n  }\n\n  /**\n   * @constructor\n   */\n  function DomPosition(node, offset) {\n    this.node = node;\n    this.offset = offset;\n  }\n\n  DomPosition.prototype = {\n    equals: function equals(pos) {\n      return this.node === pos.node & this.offset == pos.offset;\n    },\n\n    inspect: function inspect() {\n      return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";\n    }\n  };\n\n  /**\n   * @constructor\n   */\n  function DOMException(codeName) {\n    this.code = this[codeName];\n    this.codeName = codeName;\n    this.message = "DOMException: " + this.codeName;\n  }\n\n  DOMException.prototype = {\n    INDEX_SIZE_ERR: 1,\n    HIERARCHY_REQUEST_ERR: 3,\n    WRONG_DOCUMENT_ERR: 4,\n    NO_MODIFICATION_ALLOWED_ERR: 7,\n    NOT_FOUND_ERR: 8,\n    NOT_SUPPORTED_ERR: 9,\n    INVALID_STATE_ERR: 11\n  };\n\n  DOMException.prototype.toString = function () {\n    return this.message;\n  };\n\n  api.dom = {\n    arrayContains: arrayContains,\n    isHtmlNamespace: isHtmlNamespace,\n    parentElement: parentElement,\n    getNodeIndex: getNodeIndex,\n    getNodeLength: getNodeLength,\n    getCommonAncestor: getCommonAncestor,\n    isAncestorOf: isAncestorOf,\n    getClosestAncestorIn: getClosestAncestorIn,\n    isCharacterDataNode: isCharacterDataNode,\n    insertAfter: insertAfter,\n    splitDataNode: splitDataNode,\n    getDocument: getDocument,\n    getWindow: getWindow,\n    getIframeWindow: getIframeWindow,\n    getIframeDocument: getIframeDocument,\n    getBody: getBody,\n    getRootContainer: getRootContainer,\n    comparePoints: comparePoints,\n    inspectNode: inspectNode,\n    fragmentFromNodeChildren: fragmentFromNodeChildren,\n    createIterator: createIterator,\n    DomPosition: DomPosition\n  };\n\n  api.DOMException = DOMException;\n});rangy.createModule("DomRange", function (api, module) {\n  api.requireModules(["DomUtil"]);\n\n  var dom = api.dom;\n  var DomPosition = dom.DomPosition;\n  var DOMException = api.DOMException;\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Utility functions\n\n  function isNonTextPartiallySelected(node, range) {\n    return node.nodeType != 3 && (dom.isAncestorOf(node, range.startContainer, true) || dom.isAncestorOf(node, range.endContainer, true));\n  }\n\n  function getRangeDocument(range) {\n    return dom.getDocument(range.startContainer);\n  }\n\n  function dispatchEvent(range, type, args) {\n    var listeners = range._listeners[type];\n    if (listeners) {\n      for (var i = 0, len = listeners.length; i < len; ++i) {\n        listeners[i].call(range, { target: range, args: args });\n      }\n    }\n  }\n\n  function getBoundaryBeforeNode(node) {\n    return new DomPosition(node.parentNode, dom.getNodeIndex(node));\n  }\n\n  function getBoundaryAfterNode(node) {\n    return new DomPosition(node.parentNode, dom.getNodeIndex(node) + 1);\n  }\n\n  function insertNodeAtPosition(node, n, o) {\n    var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;\n    if (dom.isCharacterDataNode(n)) {\n      if (o == n.length) {\n        dom.insertAfter(node, n);\n      } else {\n        n.parentNode.insertBefore(node, o == 0 ? n : dom.splitDataNode(n, o));\n      }\n    } else if (o >= n.childNodes.length) {\n      n.appendChild(node);\n    } else {\n      n.insertBefore(node, n.childNodes[o]);\n    }\n    return firstNodeInserted;\n  }\n\n  function cloneSubtree(iterator) {\n    var partiallySelected;\n    for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {\n      partiallySelected = iterator.isPartiallySelectedSubtree();\n\n      node = node.cloneNode(!partiallySelected);\n      if (partiallySelected) {\n        subIterator = iterator.getSubtreeIterator();\n        node.appendChild(cloneSubtree(subIterator));\n        subIterator.detach(true);\n      }\n\n      if (node.nodeType == 10) {\n        // DocumentType\n        throw new DOMException("HIERARCHY_REQUEST_ERR");\n      }\n      frag.appendChild(node);\n    }\n    return frag;\n  }\n\n  function iterateSubtree(rangeIterator, func, iteratorState) {\n    var it, n;\n    iteratorState = iteratorState || { stop: false };\n    for (var node, subRangeIterator; node = rangeIterator.next();) {\n      //log.debug("iterateSubtree, partially selected: " + rangeIterator.isPartiallySelectedSubtree(), nodeToString(node));\n      if (rangeIterator.isPartiallySelectedSubtree()) {\n        // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of the\n        // node selected by the Range.\n        if (func(node) === false) {\n          iteratorState.stop = true;\n          return;\n        } else {\n          subRangeIterator = rangeIterator.getSubtreeIterator();\n          iterateSubtree(subRangeIterator, func, iteratorState);\n          subRangeIterator.detach(true);\n          if (iteratorState.stop) {\n            return;\n          }\n        }\n      } else {\n        // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its\n        // descendant\n        it = dom.createIterator(node);\n        while (n = it.next()) {\n          if (func(n) === false) {\n            iteratorState.stop = true;\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  function deleteSubtree(iterator) {\n    var subIterator;\n    while (iterator.next()) {\n      if (iterator.isPartiallySelectedSubtree()) {\n        subIterator = iterator.getSubtreeIterator();\n        deleteSubtree(subIterator);\n        subIterator.detach(true);\n      } else {\n        iterator.remove();\n      }\n    }\n  }\n\n  function extractSubtree(iterator) {\n\n    for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {\n\n      if (iterator.isPartiallySelectedSubtree()) {\n        node = node.cloneNode(false);\n        subIterator = iterator.getSubtreeIterator();\n        node.appendChild(extractSubtree(subIterator));\n        subIterator.detach(true);\n      } else {\n        iterator.remove();\n      }\n      if (node.nodeType == 10) {\n        // DocumentType\n        throw new DOMException("HIERARCHY_REQUEST_ERR");\n      }\n      frag.appendChild(node);\n    }\n    return frag;\n  }\n\n  function getNodesInRange(range, nodeTypes, filter) {\n    //log.info("getNodesInRange, " + nodeTypes.join(","));\n    var filterNodeTypes = !!(nodeTypes && nodeTypes.length),\n        regex;\n    var filterExists = !!filter;\n    if (filterNodeTypes) {\n      regex = new RegExp("^(" + nodeTypes.join("|") + ")$");\n    }\n\n    var nodes = [];\n    iterateSubtree(new RangeIterator(range, false), function (node) {\n      if ((!filterNodeTypes || regex.test(node.nodeType)) && (!filterExists || filter(node))) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  }\n\n  function _inspect(range) {\n    var name = typeof range.getName == "undefined" ? "Range" : range.getName();\n    return "[" + name + "(" + dom.inspectNode(range.startContainer) + ":" + range.startOffset + ", " + dom.inspectNode(range.endContainer) + ":" + range.endOffset + ")]";\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)\n\n  /**\n   * @constructor\n   */\n  function RangeIterator(range, clonePartiallySelectedTextNodes) {\n    this.range = range;\n    this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n    if (!range.collapsed) {\n      this.sc = range.startContainer;\n      this.so = range.startOffset;\n      this.ec = range.endContainer;\n      this.eo = range.endOffset;\n      var root = range.commonAncestorContainer;\n\n      if (this.sc === this.ec && dom.isCharacterDataNode(this.sc)) {\n        this.isSingleCharacterDataNode = true;\n        this._first = this._last = this._next = this.sc;\n      } else {\n        this._first = this._next = this.sc === root && !dom.isCharacterDataNode(this.sc) ? this.sc.childNodes[this.so] : dom.getClosestAncestorIn(this.sc, root, true);\n        this._last = this.ec === root && !dom.isCharacterDataNode(this.ec) ? this.ec.childNodes[this.eo - 1] : dom.getClosestAncestorIn(this.ec, root, true);\n      }\n    }\n  }\n\n  RangeIterator.prototype = {\n    _current: null,\n    _next: null,\n    _first: null,\n    _last: null,\n    isSingleCharacterDataNode: false,\n\n    reset: function reset() {\n      this._current = null;\n      this._next = this._first;\n    },\n\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n\n    next: function next() {\n      // Move to next node\n      var current = this._current = this._next;\n      if (current) {\n        this._next = current !== this._last ? current.nextSibling : null;\n\n        // Check for partially selected text nodes\n        if (dom.isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n          if (current === this.ec) {\n\n            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n          }\n          if (this._current === this.sc) {\n\n            (current = current.cloneNode(true)).deleteData(0, this.so);\n          }\n        }\n      }\n\n      return current;\n    },\n\n    remove: function remove() {\n      var current = this._current,\n          start,\n          end;\n\n      if (dom.isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {\n        start = current === this.sc ? this.so : 0;\n        end = current === this.ec ? this.eo : current.length;\n        if (start != end) {\n          current.deleteData(start, end - start);\n        }\n      } else {\n        if (current.parentNode) {\n          current.parentNode.removeChild(current);\n        } else {}\n      }\n    },\n\n    // Checks if the current node is partially selected\n    isPartiallySelectedSubtree: function isPartiallySelectedSubtree() {\n      var current = this._current;\n      return isNonTextPartiallySelected(current, this.range);\n    },\n\n    getSubtreeIterator: function getSubtreeIterator() {\n      var subRange;\n      if (this.isSingleCharacterDataNode) {\n        subRange = this.range.cloneRange();\n        subRange.collapse();\n      } else {\n        subRange = new Range(getRangeDocument(this.range));\n        var current = this._current;\n        var startContainer = current,\n            startOffset = 0,\n            endContainer = current,\n            endOffset = dom.getNodeLength(current);\n\n        if (dom.isAncestorOf(current, this.sc, true)) {\n          startContainer = this.sc;\n          startOffset = this.so;\n        }\n        if (dom.isAncestorOf(current, this.ec, true)) {\n          endContainer = this.ec;\n          endOffset = this.eo;\n        }\n\n        updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);\n      }\n      return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);\n    },\n\n    detach: function detach(detachRange) {\n      if (detachRange) {\n        this.range.detach();\n      }\n      this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;\n    }\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Exceptions\n\n  /**\n   * @constructor\n   */\n  function RangeException(codeName) {\n    this.code = this[codeName];\n    this.codeName = codeName;\n    this.message = "RangeException: " + this.codeName;\n  }\n\n  RangeException.prototype = {\n    BAD_BOUNDARYPOINTS_ERR: 1,\n    INVALID_NODE_TYPE_ERR: 2\n  };\n\n  RangeException.prototype.toString = function () {\n    return this.message;\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  /**\n   * Currently iterates through all nodes in the range on creation until I think of a decent way to do it\n   * TODO: Look into making this a proper iterator, not requiring preloading everything first\n   * @constructor\n   */\n  function RangeNodeIterator(range, nodeTypes, filter) {\n    this.nodes = getNodesInRange(range, nodeTypes, filter);\n    this._next = this.nodes[0];\n    this._position = 0;\n  }\n\n  RangeNodeIterator.prototype = {\n    _current: null,\n\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n\n    next: function next() {\n      this._current = this._next;\n      this._next = this.nodes[++this._position];\n      return this._current;\n    },\n\n    detach: function detach() {\n      this._current = this._next = this.nodes = null;\n    }\n  };\n\n  var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];\n  var rootContainerNodeTypes = [2, 9, 11];\n  var readonlyNodeTypes = [5, 6, 10, 12];\n  var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];\n  var surroundNodeTypes = [1, 3, 4, 5, 7, 8];\n\n  function createAncestorFinder(nodeTypes) {\n    return function (node, selfIsAncestor) {\n      var t,\n          n = selfIsAncestor ? node : node.parentNode;\n      while (n) {\n        t = n.nodeType;\n        if (dom.arrayContains(nodeTypes, t)) {\n          return n;\n        }\n        n = n.parentNode;\n      }\n      return null;\n    };\n  }\n\n  var getRootContainer = dom.getRootContainer;\n  var getDocumentOrFragmentContainer = createAncestorFinder([9, 11]);\n  var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);\n  var getDocTypeNotationEntityAncestor = createAncestorFinder([6, 10, 12]);\n\n  function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {\n    if (getDocTypeNotationEntityAncestor(node, allowSelf)) {\n      throw new RangeException("INVALID_NODE_TYPE_ERR");\n    }\n  }\n\n  function assertNotDetached(range) {\n    if (!range.startContainer) {\n      throw new DOMException("INVALID_STATE_ERR");\n    }\n  }\n\n  function assertValidNodeType(node, invalidTypes) {\n    if (!dom.arrayContains(invalidTypes, node.nodeType)) {\n      throw new RangeException("INVALID_NODE_TYPE_ERR");\n    }\n  }\n\n  function assertValidOffset(node, offset) {\n    if (offset < 0 || offset > (dom.isCharacterDataNode(node) ? node.length : node.childNodes.length)) {\n      throw new DOMException("INDEX_SIZE_ERR");\n    }\n  }\n\n  function assertSameDocumentOrFragment(node1, node2) {\n    if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {\n      throw new DOMException("WRONG_DOCUMENT_ERR");\n    }\n  }\n\n  function assertNodeNotReadOnly(node) {\n    if (getReadonlyAncestor(node, true)) {\n      throw new DOMException("NO_MODIFICATION_ALLOWED_ERR");\n    }\n  }\n\n  function assertNode(node, codeName) {\n    if (!node) {\n      throw new DOMException(codeName);\n    }\n  }\n\n  function isOrphan(node) {\n    return !dom.arrayContains(rootContainerNodeTypes, node.nodeType) && !getDocumentOrFragmentContainer(node, true);\n  }\n\n  function isValidOffset(node, offset) {\n    return offset <= (dom.isCharacterDataNode(node) ? node.length : node.childNodes.length);\n  }\n\n  function assertRangeValid(range) {\n    assertNotDetached(range);\n    if (isOrphan(range.startContainer) || isOrphan(range.endContainer) || !isValidOffset(range.startContainer, range.startOffset) || !isValidOffset(range.endContainer, range.endOffset)) {\n      throw new Error("Range error: Range is no longer valid after DOM mutation (" + range.inspect() + ")");\n    }\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Test the browser\'s innerHTML support to decide how to implement createContextualFragment\n  var styleEl = document.createElement("style");\n  var htmlParsingConforms = false;\n  try {\n    styleEl.innerHTML = "<b>x</b>";\n    htmlParsingConforms = styleEl.firstChild.nodeType == 3; // Opera incorrectly creates an element node\n  } catch (e) {\n    // IE 6 and 7 throw\n  }\n\n  api.features.htmlParsingConforms = htmlParsingConforms;\n\n  var createContextualFragment = htmlParsingConforms ?\n\n  // Implementation as per HTML parsing spec, trusting in the browser\'s implementation of innerHTML. See\n  // discussion and base code for this implementation at issue 67.\n  // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface\n  // Thanks to Aleks Williams.\n  function (fragmentStr) {\n    // "Let node the context object\'s start\'s node."\n    var node = this.startContainer;\n    var doc = dom.getDocument(node);\n\n    // "If the context object\'s start\'s node is null, raise an INVALID_STATE_ERR\n    // exception and abort these steps."\n    if (!node) {\n      throw new DOMException("INVALID_STATE_ERR");\n    }\n\n    // "Let element be as follows, depending on node\'s interface:"\n    // Document, Document Fragment: null\n    var el = null;\n\n    // "Element: node"\n    if (node.nodeType == 1) {\n      el = node;\n\n      // "Text, Comment: node\'s parentElement"\n    } else if (dom.isCharacterDataNode(node)) {\n      el = dom.parentElement(node);\n    }\n\n    // "If either element is null or element\'s ownerDocument is an HTML document\n    // and element\'s local name is "html" and element\'s namespace is the HTML\n    // namespace"\n    if (el === null || el.nodeName == "HTML" && dom.isHtmlNamespace(dom.getDocument(el).documentElement) && dom.isHtmlNamespace(el)) {\n\n      // "let element be a new Element with "body" as its local name and the HTML\n      // namespace as its namespace.""\n      el = doc.createElement("body");\n    } else {\n      el = el.cloneNode(false);\n    }\n\n    // "If the node\'s document is an HTML document: Invoke the HTML fragment parsing algorithm."\n    // "If the node\'s document is an XML document: Invoke the XML fragment parsing algorithm."\n    // "In either case, the algorithm must be invoked with fragment as the input\n    // and element as the context element."\n    el.innerHTML = fragmentStr;\n\n    // "If this raises an exception, then abort these steps. Otherwise, let new\n    // children be the nodes returned."\n\n    // "Let fragment be a new DocumentFragment."\n    // "Append all new children to fragment."\n    // "Return fragment."\n    return dom.fragmentFromNodeChildren(el);\n  } :\n\n  // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that\n  // previous versions of Rangy used (with the exception of using a body element rather than a div)\n  function (fragmentStr) {\n    assertNotDetached(this);\n    var doc = getRangeDocument(this);\n    var el = doc.createElement("body");\n    el.innerHTML = fragmentStr;\n\n    return dom.fragmentFromNodeChildren(el);\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  var rangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed", "commonAncestorContainer"];\n\n  var s2s = 0,\n      s2e = 1,\n      e2e = 2,\n      e2s = 3;\n  var n_b = 0,\n      n_a = 1,\n      n_b_a = 2,\n      n_i = 3;\n\n  function RangePrototype() {}\n\n  RangePrototype.prototype = {\n    attachListener: function attachListener(type, listener) {\n      this._listeners[type].push(listener);\n    },\n\n    compareBoundaryPoints: function compareBoundaryPoints(how, range) {\n      assertRangeValid(this);\n      assertSameDocumentOrFragment(this.startContainer, range.startContainer);\n\n      var nodeA, offsetA, nodeB, offsetB;\n      var prefixA = how == e2s || how == s2s ? "start" : "end";\n      var prefixB = how == s2e || how == s2s ? "start" : "end";\n      nodeA = this[prefixA + "Container"];\n      offsetA = this[prefixA + "Offset"];\n      nodeB = range[prefixB + "Container"];\n      offsetB = range[prefixB + "Offset"];\n      return dom.comparePoints(nodeA, offsetA, nodeB, offsetB);\n    },\n\n    insertNode: function insertNode(node) {\n      assertRangeValid(this);\n      assertValidNodeType(node, insertableNodeTypes);\n      assertNodeNotReadOnly(this.startContainer);\n\n      if (dom.isAncestorOf(node, this.startContainer, true)) {\n        throw new DOMException("HIERARCHY_REQUEST_ERR");\n      }\n\n      // No check for whether the container of the start of the Range is of a type that does not allow\n      // children of the type of node: the browser\'s DOM implementation should do this for us when we attempt\n      // to add the node\n\n      var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);\n      this.setStartBefore(firstNodeInserted);\n    },\n\n    cloneContents: function cloneContents() {\n      assertRangeValid(this);\n\n      var clone, frag;\n      if (this.collapsed) {\n        return getRangeDocument(this).createDocumentFragment();\n      } else {\n        if (this.startContainer === this.endContainer && dom.isCharacterDataNode(this.startContainer)) {\n          clone = this.startContainer.cloneNode(true);\n          clone.data = clone.data.slice(this.startOffset, this.endOffset);\n          frag = getRangeDocument(this).createDocumentFragment();\n          frag.appendChild(clone);\n          return frag;\n        } else {\n          var iterator = new RangeIterator(this, true);\n          clone = cloneSubtree(iterator);\n          iterator.detach();\n        }\n        return clone;\n      }\n    },\n\n    canSurroundContents: function canSurroundContents() {\n      assertRangeValid(this);\n      assertNodeNotReadOnly(this.startContainer);\n      assertNodeNotReadOnly(this.endContainer);\n\n      // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n      // no non-text nodes.\n      var iterator = new RangeIterator(this, true);\n      var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);\n      iterator.detach();\n      return !boundariesInvalid;\n    },\n\n    surroundContents: function surroundContents(node) {\n      assertValidNodeType(node, surroundNodeTypes);\n\n      if (!this.canSurroundContents()) {\n        throw new RangeException("BAD_BOUNDARYPOINTS_ERR");\n      }\n\n      // Extract the contents\n      var content = this.extractContents();\n\n      // Clear the children of the node\n      if (node.hasChildNodes()) {\n        while (node.lastChild) {\n          node.removeChild(node.lastChild);\n        }\n      }\n\n      // Insert the new node and add the extracted contents\n      insertNodeAtPosition(node, this.startContainer, this.startOffset);\n      node.appendChild(content);\n\n      this.selectNode(node);\n    },\n\n    cloneRange: function cloneRange() {\n      assertRangeValid(this);\n      var range = new Range(getRangeDocument(this));\n      var i = rangeProperties.length,\n          prop;\n      while (i--) {\n        prop = rangeProperties[i];\n        range[prop] = this[prop];\n      }\n      return range;\n    },\n\n    toString: function toString() {\n      assertRangeValid(this);\n      var sc = this.startContainer;\n      if (sc === this.endContainer && dom.isCharacterDataNode(sc)) {\n        return sc.nodeType == 3 || sc.nodeType == 4 ? sc.data.slice(this.startOffset, this.endOffset) : "";\n      } else {\n        var textBits = [],\n            iterator = new RangeIterator(this, true);\n\n        iterateSubtree(iterator, function (node) {\n          // Accept only text or CDATA nodes, not comments\n\n          if (node.nodeType == 3 || node.nodeType == 4) {\n            textBits.push(node.data);\n          }\n        });\n        iterator.detach();\n        return textBits.join("");\n      }\n    },\n\n    // The methods below are all non-standard. The following batch were introduced by Mozilla but have since\n    // been removed from Mozilla.\n\n    compareNode: function compareNode(node) {\n      assertRangeValid(this);\n\n      var parent = node.parentNode;\n      var nodeIndex = dom.getNodeIndex(node);\n\n      if (!parent) {\n        throw new DOMException("NOT_FOUND_ERR");\n      }\n\n      var startComparison = this.comparePoint(parent, nodeIndex),\n          endComparison = this.comparePoint(parent, nodeIndex + 1);\n\n      if (startComparison < 0) {\n        // Node starts before\n        return endComparison > 0 ? n_b_a : n_b;\n      } else {\n        return endComparison > 0 ? n_a : n_i;\n      }\n    },\n\n    comparePoint: function comparePoint(node, offset) {\n      assertRangeValid(this);\n      assertNode(node, "HIERARCHY_REQUEST_ERR");\n      assertSameDocumentOrFragment(node, this.startContainer);\n\n      if (dom.comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {\n        return -1;\n      } else if (dom.comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {\n        return 1;\n      }\n      return 0;\n    },\n\n    createContextualFragment: createContextualFragment,\n\n    toHtml: function toHtml() {\n      assertRangeValid(this);\n      var container = getRangeDocument(this).createElement("div");\n      container.appendChild(this.cloneContents());\n      return container.innerHTML;\n    },\n\n    // touchingIsIntersecting determines whether this method considers a node that borders a range intersects\n    // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)\n    intersectsNode: function intersectsNode(node, touchingIsIntersecting) {\n      assertRangeValid(this);\n      assertNode(node, "NOT_FOUND_ERR");\n      if (dom.getDocument(node) !== getRangeDocument(this)) {\n        return false;\n      }\n\n      var parent = node.parentNode,\n          offset = dom.getNodeIndex(node);\n      assertNode(parent, "NOT_FOUND_ERR");\n\n      var startComparison = dom.comparePoints(parent, offset, this.endContainer, this.endOffset),\n          endComparison = dom.comparePoints(parent, offset + 1, this.startContainer, this.startOffset);\n\n      return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n    },\n\n    isPointInRange: function isPointInRange(node, offset) {\n      assertRangeValid(this);\n      assertNode(node, "HIERARCHY_REQUEST_ERR");\n      assertSameDocumentOrFragment(node, this.startContainer);\n\n      return dom.comparePoints(node, offset, this.startContainer, this.startOffset) >= 0 && dom.comparePoints(node, offset, this.endContainer, this.endOffset) <= 0;\n    },\n\n    // The methods below are non-standard and invented by me.\n\n    // Sharing a boundary start-to-end or end-to-start does not count as intersection.\n    intersectsRange: function intersectsRange(range, touchingIsIntersecting) {\n      assertRangeValid(this);\n\n      if (getRangeDocument(range) != getRangeDocument(this)) {\n        throw new DOMException("WRONG_DOCUMENT_ERR");\n      }\n\n      var startComparison = dom.comparePoints(this.startContainer, this.startOffset, range.endContainer, range.endOffset),\n          endComparison = dom.comparePoints(this.endContainer, this.endOffset, range.startContainer, range.startOffset);\n\n      return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n    },\n\n    intersection: function intersection(range) {\n      if (this.intersectsRange(range)) {\n        var startComparison = dom.comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),\n            endComparison = dom.comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);\n\n        var intersectionRange = this.cloneRange();\n\n        if (startComparison == -1) {\n          intersectionRange.setStart(range.startContainer, range.startOffset);\n        }\n        if (endComparison == 1) {\n          intersectionRange.setEnd(range.endContainer, range.endOffset);\n        }\n        return intersectionRange;\n      }\n      return null;\n    },\n\n    union: function union(range) {\n      if (this.intersectsRange(range, true)) {\n        var unionRange = this.cloneRange();\n        if (dom.comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {\n          unionRange.setStart(range.startContainer, range.startOffset);\n        }\n        if (dom.comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {\n          unionRange.setEnd(range.endContainer, range.endOffset);\n        }\n        return unionRange;\n      } else {\n        throw new RangeException("Ranges do not intersect");\n      }\n    },\n\n    containsNode: function containsNode(node, allowPartial) {\n      if (allowPartial) {\n        return this.intersectsNode(node, false);\n      } else {\n        return this.compareNode(node) == n_i;\n      }\n    },\n\n    containsNodeContents: function containsNodeContents(node) {\n      return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, dom.getNodeLength(node)) <= 0;\n    },\n\n    containsRange: function containsRange(range) {\n      return this.intersection(range).equals(range);\n    },\n\n    containsNodeText: function containsNodeText(node) {\n      var nodeRange = this.cloneRange();\n      nodeRange.selectNode(node);\n      var textNodes = nodeRange.getNodes([3]);\n      if (textNodes.length > 0) {\n        nodeRange.setStart(textNodes[0], 0);\n        var lastTextNode = textNodes.pop();\n        nodeRange.setEnd(lastTextNode, lastTextNode.length);\n        var contains = this.containsRange(nodeRange);\n        nodeRange.detach();\n        return contains;\n      } else {\n        return this.containsNodeContents(node);\n      }\n    },\n\n    createNodeIterator: function createNodeIterator(nodeTypes, filter) {\n      assertRangeValid(this);\n      return new RangeNodeIterator(this, nodeTypes, filter);\n    },\n\n    getNodes: function getNodes(nodeTypes, filter) {\n      assertRangeValid(this);\n      return getNodesInRange(this, nodeTypes, filter);\n    },\n\n    getDocument: function getDocument() {\n      return getRangeDocument(this);\n    },\n\n    collapseBefore: function collapseBefore(node) {\n      assertNotDetached(this);\n\n      this.setEndBefore(node);\n      this.collapse(false);\n    },\n\n    collapseAfter: function collapseAfter(node) {\n      assertNotDetached(this);\n\n      this.setStartAfter(node);\n      this.collapse(true);\n    },\n\n    getName: function getName() {\n      return "DomRange";\n    },\n\n    equals: function equals(range) {\n      return Range.rangesEqual(this, range);\n    },\n\n    inspect: function inspect() {\n      return _inspect(this);\n    }\n  };\n\n  function copyComparisonConstantsToObject(obj) {\n    obj.START_TO_START = s2s;\n    obj.START_TO_END = s2e;\n    obj.END_TO_END = e2e;\n    obj.END_TO_START = e2s;\n\n    obj.NODE_BEFORE = n_b;\n    obj.NODE_AFTER = n_a;\n    obj.NODE_BEFORE_AND_AFTER = n_b_a;\n    obj.NODE_INSIDE = n_i;\n  }\n\n  function copyComparisonConstants(constructor) {\n    copyComparisonConstantsToObject(constructor);\n    copyComparisonConstantsToObject(constructor.prototype);\n  }\n\n  function createRangeContentRemover(remover, boundaryUpdater) {\n    return function () {\n      assertRangeValid(this);\n\n      var sc = this.startContainer,\n          so = this.startOffset,\n          root = this.commonAncestorContainer;\n\n      var iterator = new RangeIterator(this, true);\n\n      // Work out where to position the range after content removal\n      var node, boundary;\n      if (sc !== root) {\n        node = dom.getClosestAncestorIn(sc, root, true);\n        boundary = getBoundaryAfterNode(node);\n        sc = boundary.node;\n        so = boundary.offset;\n      }\n\n      // Check none of the range is read-only\n      iterateSubtree(iterator, assertNodeNotReadOnly);\n\n      iterator.reset();\n\n      // Remove the content\n      var returnValue = remover(iterator);\n      iterator.detach();\n\n      // Move to the new position\n      boundaryUpdater(this, sc, so, sc, so);\n\n      return returnValue;\n    };\n  }\n\n  function createPrototypeRange(constructor, boundaryUpdater, detacher) {\n    function createBeforeAfterNodeSetter(isBefore, isStart) {\n      return function (node) {\n        assertNotDetached(this);\n        assertValidNodeType(node, beforeAfterNodeTypes);\n        assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);\n\n        var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);\n        (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);\n      };\n    }\n\n    function setRangeStart(range, node, offset) {\n      var ec = range.endContainer,\n          eo = range.endOffset;\n      if (node !== range.startContainer || offset !== range.startOffset) {\n        // Check the root containers of the range and the new boundary, and also check whether the new boundary\n        // is after the current end. In either case, collapse the range to the new position\n        if (getRootContainer(node) != getRootContainer(ec) || dom.comparePoints(node, offset, ec, eo) == 1) {\n          ec = node;\n          eo = offset;\n        }\n        boundaryUpdater(range, node, offset, ec, eo);\n      }\n    }\n\n    function setRangeEnd(range, node, offset) {\n      var sc = range.startContainer,\n          so = range.startOffset;\n      if (node !== range.endContainer || offset !== range.endOffset) {\n        // Check the root containers of the range and the new boundary, and also check whether the new boundary\n        // is after the current end. In either case, collapse the range to the new position\n        if (getRootContainer(node) != getRootContainer(sc) || dom.comparePoints(node, offset, sc, so) == -1) {\n          sc = node;\n          so = offset;\n        }\n        boundaryUpdater(range, sc, so, node, offset);\n      }\n    }\n\n    function setRangeStartAndEnd(range, node, offset) {\n      if (node !== range.startContainer || offset !== range.startOffset || node !== range.endContainer || offset !== range.endOffset) {\n        boundaryUpdater(range, node, offset, node, offset);\n      }\n    }\n\n    constructor.prototype = new RangePrototype();\n\n    api.util.extend(constructor.prototype, {\n      setStart: function setStart(node, offset) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n\n        setRangeStart(this, node, offset);\n      },\n\n      setEnd: function setEnd(node, offset) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n\n        setRangeEnd(this, node, offset);\n      },\n\n      setStartBefore: createBeforeAfterNodeSetter(true, true),\n      setStartAfter: createBeforeAfterNodeSetter(false, true),\n      setEndBefore: createBeforeAfterNodeSetter(true, false),\n      setEndAfter: createBeforeAfterNodeSetter(false, false),\n\n      collapse: function collapse(isStart) {\n        assertRangeValid(this);\n        if (isStart) {\n          boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);\n        } else {\n          boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);\n        }\n      },\n\n      selectNodeContents: function selectNodeContents(node) {\n        // This doesn\'t seem well specified: the spec talks only about selecting the node\'s contents, which\n        // could be taken to mean only its children. However, browsers implement this the same as selectNode for\n        // text nodes, so I shall do likewise\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n\n        boundaryUpdater(this, node, 0, node, dom.getNodeLength(node));\n      },\n\n      selectNode: function selectNode(node) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, false);\n        assertValidNodeType(node, beforeAfterNodeTypes);\n\n        var start = getBoundaryBeforeNode(node),\n            end = getBoundaryAfterNode(node);\n        boundaryUpdater(this, start.node, start.offset, end.node, end.offset);\n      },\n\n      extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),\n\n      deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),\n\n      canSurroundContents: function canSurroundContents() {\n        assertRangeValid(this);\n        assertNodeNotReadOnly(this.startContainer);\n        assertNodeNotReadOnly(this.endContainer);\n\n        // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n        // no non-text nodes.\n        var iterator = new RangeIterator(this, true);\n        var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);\n        iterator.detach();\n        return !boundariesInvalid;\n      },\n\n      detach: function detach() {\n        detacher(this);\n      },\n\n      splitBoundaries: function splitBoundaries() {\n        assertRangeValid(this);\n\n        var sc = this.startContainer,\n            so = this.startOffset,\n            ec = this.endContainer,\n            eo = this.endOffset;\n        var startEndSame = sc === ec;\n\n        if (dom.isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n          dom.splitDataNode(ec, eo);\n        }\n\n        if (dom.isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n\n          sc = dom.splitDataNode(sc, so);\n          if (startEndSame) {\n            eo -= so;\n            ec = sc;\n          } else if (ec == sc.parentNode && eo >= dom.getNodeIndex(sc)) {\n            eo++;\n          }\n          so = 0;\n        }\n        boundaryUpdater(this, sc, so, ec, eo);\n      },\n\n      normalizeBoundaries: function normalizeBoundaries() {\n        assertRangeValid(this);\n\n        var sc = this.startContainer,\n            so = this.startOffset,\n            ec = this.endContainer,\n            eo = this.endOffset;\n\n        var mergeForward = function mergeForward(node) {\n          var sibling = node.nextSibling;\n          if (sibling && sibling.nodeType == node.nodeType) {\n            ec = node;\n            eo = node.length;\n            node.appendData(sibling.data);\n            sibling.parentNode.removeChild(sibling);\n          }\n        };\n\n        var mergeBackward = function mergeBackward(node) {\n          var sibling = node.previousSibling;\n          if (sibling && sibling.nodeType == node.nodeType) {\n            sc = node;\n            var nodeLength = node.length;\n            so = sibling.length;\n            node.insertData(0, sibling.data);\n            sibling.parentNode.removeChild(sibling);\n            if (sc == ec) {\n              eo += so;\n              ec = sc;\n            } else if (ec == node.parentNode) {\n              var nodeIndex = dom.getNodeIndex(node);\n              if (eo == nodeIndex) {\n                ec = node;\n                eo = nodeLength;\n              } else if (eo > nodeIndex) {\n                eo--;\n              }\n            }\n          }\n        };\n\n        var normalizeStart = true;\n\n        if (dom.isCharacterDataNode(ec)) {\n          if (ec.length == eo) {\n            mergeForward(ec);\n          }\n        } else {\n          if (eo > 0) {\n            var endNode = ec.childNodes[eo - 1];\n            if (endNode && dom.isCharacterDataNode(endNode)) {\n              mergeForward(endNode);\n            }\n          }\n          normalizeStart = !this.collapsed;\n        }\n\n        if (normalizeStart) {\n          if (dom.isCharacterDataNode(sc)) {\n            if (so == 0) {\n              mergeBackward(sc);\n            }\n          } else {\n            if (so < sc.childNodes.length) {\n              var startNode = sc.childNodes[so];\n              if (startNode && dom.isCharacterDataNode(startNode)) {\n                mergeBackward(startNode);\n              }\n            }\n          }\n        } else {\n          sc = ec;\n          so = eo;\n        }\n\n        boundaryUpdater(this, sc, so, ec, eo);\n      },\n\n      collapseToPoint: function collapseToPoint(node, offset) {\n        assertNotDetached(this);\n\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n\n        setRangeStartAndEnd(this, node, offset);\n      }\n    });\n\n    copyComparisonConstants(constructor);\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Updates commonAncestorContainer and collapsed after boundary change\n  function updateCollapsedAndCommonAncestor(range) {\n    range.collapsed = range.startContainer === range.endContainer && range.startOffset === range.endOffset;\n    range.commonAncestorContainer = range.collapsed ? range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);\n  }\n\n  function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {\n    var startMoved = range.startContainer !== startContainer || range.startOffset !== startOffset;\n    var endMoved = range.endContainer !== endContainer || range.endOffset !== endOffset;\n\n    range.startContainer = startContainer;\n    range.startOffset = startOffset;\n    range.endContainer = endContainer;\n    range.endOffset = endOffset;\n\n    updateCollapsedAndCommonAncestor(range);\n    dispatchEvent(range, "boundarychange", { startMoved: startMoved, endMoved: endMoved });\n  }\n\n  function detach(range) {\n    assertNotDetached(range);\n    range.startContainer = range.startOffset = range.endContainer = range.endOffset = null;\n    range.collapsed = range.commonAncestorContainer = null;\n    dispatchEvent(range, "detach", null);\n    range._listeners = null;\n  }\n\n  /**\n   * @constructor\n   */\n  function Range(doc) {\n    this.startContainer = doc;\n    this.startOffset = 0;\n    this.endContainer = doc;\n    this.endOffset = 0;\n    this._listeners = {\n      boundarychange: [],\n      detach: []\n    };\n    updateCollapsedAndCommonAncestor(this);\n  }\n\n  createPrototypeRange(Range, updateBoundaries, detach);\n\n  api.rangePrototype = RangePrototype.prototype;\n\n  Range.rangeProperties = rangeProperties;\n  Range.RangeIterator = RangeIterator;\n  Range.copyComparisonConstants = copyComparisonConstants;\n  Range.createPrototypeRange = createPrototypeRange;\n  Range.inspect = _inspect;\n  Range.getRangeDocument = getRangeDocument;\n  Range.rangesEqual = function (r1, r2) {\n    return r1.startContainer === r2.startContainer && r1.startOffset === r2.startOffset && r1.endContainer === r2.endContainer && r1.endOffset === r2.endOffset;\n  };\n\n  api.DomRange = Range;\n  api.RangeException = RangeException;\n});rangy.createModule("WrappedRange", function (api, module) {\n  api.requireModules(["DomUtil", "DomRange"]);\n\n  /**\n   * @constructor\n   */\n  var WrappedRange;\n  var dom = api.dom;\n  var DomPosition = dom.DomPosition;\n  var DomRange = api.DomRange;\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  /*\n  This is a workaround for a bug where IE returns the wrong container element from the TextRange\'s parentElement()\n  method. For example, in the following (where pipes denote the selection boundaries):\n   <ul id="ul"><li id="a">| a </li><li id="b"> b |</li></ul>\n   var range = document.selection.createRange();\n  alert(range.parentElement().id); // Should alert "ul" but alerts "b"\n   This method returns the common ancestor node of the following:\n  - the parentElement() of the textRange\n  - the parentElement() of the textRange after calling collapse(true)\n  - the parentElement() of the textRange after calling collapse(false)\n   */\n  function getTextRangeContainerElement(textRange) {\n    var parentEl = textRange.parentElement();\n\n    var range = textRange.duplicate();\n    range.collapse(true);\n    var startEl = range.parentElement();\n    range = textRange.duplicate();\n    range.collapse(false);\n    var endEl = range.parentElement();\n    var startEndContainer = startEl == endEl ? startEl : dom.getCommonAncestor(startEl, endEl);\n\n    return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);\n  }\n\n  function textRangeIsCollapsed(textRange) {\n    return textRange.compareEndPoints("StartToEnd", textRange) == 0;\n  }\n\n  // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started out as\n  // an improved version of code found in Tim Cameron Ryan\'s IERange (http://code.google.com/p/ierange/) but has\n  // grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange bugs, handling\n  // for inputs and images, plus optimizations.\n  function getTextRangeBoundaryPosition(textRange, wholeRangeContainerElement, isStart, isCollapsed) {\n    var workingRange = textRange.duplicate();\n\n    workingRange.collapse(isStart);\n    var containerElement = workingRange.parentElement();\n\n    // Sometimes collapsing a TextRange that\'s at the start of a text node can move it into the previous node, so\n    // check for that\n    // TODO: Find out when. Workaround for wholeRangeContainerElement may break this\n    if (!dom.isAncestorOf(wholeRangeContainerElement, containerElement, true)) {\n      containerElement = wholeRangeContainerElement;\n    }\n\n    // Deal with nodes that cannot "contain rich HTML markup". In practice, this means form inputs, images and\n    // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx\n    if (!containerElement.canHaveHTML) {\n      return new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));\n    }\n\n    var workingNode = dom.getDocument(containerElement).createElement("span");\n    var comparison,\n        workingComparisonType = isStart ? "StartToStart" : "StartToEnd";\n    var previousNode, nextNode, boundaryPosition, boundaryNode;\n\n    // Move the working range through the container\'s children, starting at the end and working backwards, until the\n    // working range reaches or goes past the boundary we\'re interested in\n    do {\n      containerElement.insertBefore(workingNode, workingNode.previousSibling);\n      workingRange.moveToElementText(workingNode);\n    } while ((comparison = workingRange.compareEndPoints(workingComparisonType, textRange)) > 0 && workingNode.previousSibling);\n\n    // We\'ve now reached or gone past the boundary of the text range we\'re interested in\n    // so have identified the node we want\n    boundaryNode = workingNode.nextSibling;\n\n    if (comparison == -1 && boundaryNode && dom.isCharacterDataNode(boundaryNode)) {\n      // This is a character data node (text, comment, cdata). The working range is collapsed at the start of the\n      // node containing the text range\'s boundary, so we move the end of the working range to the boundary point\n      // and measure the length of its text to get the boundary\'s offset within the node.\n      workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);\n\n      var offset;\n\n      if (/[\\r\\n]/.test(boundaryNode.data)) {\n        /*\n        For the particular case of a boundary within a text node containing line breaks (within a <pre> element,\n        for example), we need a slightly complicated approach to get the boundary\'s offset in IE. The facts:\n         - Each line break is represented as \\r in the text node\'s data/nodeValue properties\n        - Each line break is represented as \\r\\n in the TextRange\'s \'text\' property\n        - The \'text\' property of the TextRange does not contain trailing line breaks\n         To get round the problem presented by the final fact above, we can use the fact that TextRange\'s\n        moveStart() and moveEnd() methods return the actual number of characters moved, which is not necessarily\n        the same as the number of characters it was instructed to move. The simplest approach is to use this to\n        store the characters moved when moving both the start and end of the range to the start of the document\n        body and subtracting the start offset from the end offset (the "move-negative-gazillion" method).\n        However, this is extremely slow when the document is large and the range is near the end of it. Clearly\n        doing the mirror image (i.e. moving the range boundaries to the end of the document) has the same\n        problem.\n         Another approach that works is to use moveStart() to move the start boundary of the range up to the end\n        boundary one character at a time and incrementing a counter with the value returned by the moveStart()\n        call. However, the check for whether the start boundary has reached the end boundary is expensive, so\n        this method is slow (although unlike "move-negative-gazillion" is largely unaffected by the location of\n        the range within the document).\n         The method below is a hybrid of the two methods above. It uses the fact that a string containing the\n        TextRange\'s \'text\' property with each \\r\\n converted to a single \\r character cannot be longer than the\n        text of the TextRange, so the start of the range is moved that length initially and then a character at\n        a time to make up for any trailing line breaks not contained in the \'text\' property. This has good\n        performance in most situations compared to the previous two methods.\n        */\n        var tempRange = workingRange.duplicate();\n        var rangeLength = tempRange.text.replace(/\\r\\n/g, "\\r").length;\n\n        offset = tempRange.moveStart("character", rangeLength);\n        while ((comparison = tempRange.compareEndPoints("StartToEnd", tempRange)) == -1) {\n          offset++;\n          tempRange.moveStart("character", 1);\n        }\n      } else {\n        offset = workingRange.text.length;\n      }\n      boundaryPosition = new DomPosition(boundaryNode, offset);\n    } else {\n\n      // If the boundary immediately follows a character data node and this is the end boundary, we should favour\n      // a position within that, and likewise for a start boundary preceding a character data node\n      previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;\n      nextNode = (isCollapsed || isStart) && workingNode.nextSibling;\n\n      if (nextNode && dom.isCharacterDataNode(nextNode)) {\n        boundaryPosition = new DomPosition(nextNode, 0);\n      } else if (previousNode && dom.isCharacterDataNode(previousNode)) {\n        boundaryPosition = new DomPosition(previousNode, previousNode.length);\n      } else {\n        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));\n      }\n    }\n\n    // Clean up\n    workingNode.parentNode.removeChild(workingNode);\n\n    return boundaryPosition;\n  }\n\n  // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that node.\n  // This function started out as an optimized version of code found in Tim Cameron Ryan\'s IERange\n  // (http://code.google.com/p/ierange/)\n  function createBoundaryTextRange(boundaryPosition, isStart) {\n    var boundaryNode,\n        boundaryParent,\n        boundaryOffset = boundaryPosition.offset;\n    var doc = dom.getDocument(boundaryPosition.node);\n    var workingNode,\n        childNodes,\n        workingRange = doc.body.createTextRange();\n    var nodeIsDataNode = dom.isCharacterDataNode(boundaryPosition.node);\n\n    if (nodeIsDataNode) {\n      boundaryNode = boundaryPosition.node;\n      boundaryParent = boundaryNode.parentNode;\n    } else {\n      childNodes = boundaryPosition.node.childNodes;\n      boundaryNode = boundaryOffset < childNodes.length ? childNodes[boundaryOffset] : null;\n      boundaryParent = boundaryPosition.node;\n    }\n\n    // Position the range immediately before the node containing the boundary\n    workingNode = doc.createElement("span");\n\n    // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within the\n    // element rather than immediately before or after it, which is what we want\n    workingNode.innerHTML = "&#feff;";\n\n    // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report\n    // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12\n    if (boundaryNode) {\n      boundaryParent.insertBefore(workingNode, boundaryNode);\n    } else {\n      boundaryParent.appendChild(workingNode);\n    }\n\n    workingRange.moveToElementText(workingNode);\n    workingRange.collapse(!isStart);\n\n    // Clean up\n    boundaryParent.removeChild(workingNode);\n\n    // Move the working range to the text offset, if required\n    if (nodeIsDataNode) {\n      workingRange[isStart ? "moveStart" : "moveEnd"]("character", boundaryOffset);\n    }\n\n    return workingRange;\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  if (api.features.implementsDomRange && (!api.features.implementsTextRange || !api.config.preferTextRange)) {\n    // This is a wrapper around the browser\'s native DOM Range. It has two aims:\n    // - Provide workarounds for specific browser bugs\n    // - provide convenient extensions, which are inherited from Rangy\'s DomRange\n\n    (function () {\n      var rangeProto;\n      var rangeProperties = DomRange.rangeProperties;\n      var canSetRangeStartAfterEnd;\n\n      function updateRangeProperties(range) {\n        var i = rangeProperties.length,\n            prop;\n        while (i--) {\n          prop = rangeProperties[i];\n          range[prop] = range.nativeRange[prop];\n        }\n      }\n\n      function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {\n        var startMoved = range.startContainer !== startContainer || range.startOffset != startOffset;\n        var endMoved = range.endContainer !== endContainer || range.endOffset != endOffset;\n\n        // Always set both boundaries for the benefit of IE9 (see issue 35)\n        if (startMoved || endMoved) {\n          range.setEnd(endContainer, endOffset);\n          range.setStart(startContainer, startOffset);\n        }\n      }\n\n      function detach(range) {\n        range.nativeRange.detach();\n        range.detached = true;\n        var i = rangeProperties.length,\n            prop;\n        while (i--) {\n          prop = rangeProperties[i];\n          range[prop] = null;\n        }\n      }\n\n      var createBeforeAfterNodeSetter;\n\n      WrappedRange = function WrappedRange(range) {\n        if (!range) {\n          throw new Error("Range must be specified");\n        }\n        this.nativeRange = range;\n        updateRangeProperties(this);\n      };\n\n      DomRange.createPrototypeRange(WrappedRange, updateNativeRange, detach);\n\n      rangeProto = WrappedRange.prototype;\n\n      rangeProto.selectNode = function (node) {\n        this.nativeRange.selectNode(node);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.deleteContents = function () {\n        this.nativeRange.deleteContents();\n        updateRangeProperties(this);\n      };\n\n      rangeProto.extractContents = function () {\n        var frag = this.nativeRange.extractContents();\n        updateRangeProperties(this);\n        return frag;\n      };\n\n      rangeProto.cloneContents = function () {\n        return this.nativeRange.cloneContents();\n      };\n\n      // TODO: Until I can find a way to programmatically trigger the Firefox bug (apparently long-standing, still\n      // present in 3.6.8) that throws "Index or size is negative or greater than the allowed amount" for\n      // insertNode in some circumstances, all browsers will have to use the Rangy\'s own implementation of\n      // insertNode, which works but is almost certainly slower than the native implementation.\n      /*\n                  rangeProto.insertNode = function(node) {\n                      this.nativeRange.insertNode(node);\n                      updateRangeProperties(this);\n                  };\n      */\n\n      rangeProto.surroundContents = function (node) {\n        this.nativeRange.surroundContents(node);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.collapse = function (isStart) {\n        this.nativeRange.collapse(isStart);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.cloneRange = function () {\n        return new WrappedRange(this.nativeRange.cloneRange());\n      };\n\n      rangeProto.refresh = function () {\n        updateRangeProperties(this);\n      };\n\n      rangeProto.toString = function () {\n        return this.nativeRange.toString();\n      };\n\n      // Create test range and node for feature detection\n\n      var testTextNode = document.createTextNode("test");\n      dom.getBody(document).appendChild(testTextNode);\n      var range = document.createRange();\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and\n      // correct for it\n\n      range.setStart(testTextNode, 0);\n      range.setEnd(testTextNode, 0);\n\n      try {\n        range.setStart(testTextNode, 1);\n        canSetRangeStartAfterEnd = true;\n\n        rangeProto.setStart = function (node, offset) {\n          this.nativeRange.setStart(node, offset);\n          updateRangeProperties(this);\n        };\n\n        rangeProto.setEnd = function (node, offset) {\n          this.nativeRange.setEnd(node, offset);\n          updateRangeProperties(this);\n        };\n\n        createBeforeAfterNodeSetter = function createBeforeAfterNodeSetter(name) {\n          return function (node) {\n            this.nativeRange[name](node);\n            updateRangeProperties(this);\n          };\n        };\n      } catch (ex) {\n\n        canSetRangeStartAfterEnd = false;\n\n        rangeProto.setStart = function (node, offset) {\n          try {\n            this.nativeRange.setStart(node, offset);\n          } catch (ex) {\n            this.nativeRange.setEnd(node, offset);\n            this.nativeRange.setStart(node, offset);\n          }\n          updateRangeProperties(this);\n        };\n\n        rangeProto.setEnd = function (node, offset) {\n          try {\n            this.nativeRange.setEnd(node, offset);\n          } catch (ex) {\n            this.nativeRange.setStart(node, offset);\n            this.nativeRange.setEnd(node, offset);\n          }\n          updateRangeProperties(this);\n        };\n\n        createBeforeAfterNodeSetter = function createBeforeAfterNodeSetter(name, oppositeName) {\n          return function (node) {\n            try {\n              this.nativeRange[name](node);\n            } catch (ex) {\n              this.nativeRange[oppositeName](node);\n              this.nativeRange[name](node);\n            }\n            updateRangeProperties(this);\n          };\n        };\n      }\n\n      rangeProto.setStartBefore = createBeforeAfterNodeSetter("setStartBefore", "setEndBefore");\n      rangeProto.setStartAfter = createBeforeAfterNodeSetter("setStartAfter", "setEndAfter");\n      rangeProto.setEndBefore = createBeforeAfterNodeSetter("setEndBefore", "setStartBefore");\n      rangeProto.setEndAfter = createBeforeAfterNodeSetter("setEndAfter", "setStartAfter");\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for and correct Firefox 2 behaviour with selectNodeContents on text nodes: it collapses the range to\n      // the 0th character of the text node\n      range.selectNodeContents(testTextNode);\n      if (range.startContainer == testTextNode && range.endContainer == testTextNode && range.startOffset == 0 && range.endOffset == testTextNode.length) {\n        rangeProto.selectNodeContents = function (node) {\n          this.nativeRange.selectNodeContents(node);\n          updateRangeProperties(this);\n        };\n      } else {\n        rangeProto.selectNodeContents = function (node) {\n          this.setStart(node, 0);\n          this.setEnd(node, DomRange.getEndOffset(node));\n        };\n      }\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for WebKit bug that has the beahviour of compareBoundaryPoints round the wrong way for constants\n      // START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738\n\n      range.selectNodeContents(testTextNode);\n      range.setEnd(testTextNode, 3);\n\n      var range2 = document.createRange();\n      range2.selectNodeContents(testTextNode);\n      range2.setEnd(testTextNode, 4);\n      range2.setStart(testTextNode, 2);\n\n      if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 & range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {\n        // This is the wrong way round, so correct for it\n\n\n        rangeProto.compareBoundaryPoints = function (type, range) {\n          range = range.nativeRange || range;\n          if (type == range.START_TO_END) {\n            type = range.END_TO_START;\n          } else if (type == range.END_TO_START) {\n            type = range.START_TO_END;\n          }\n          return this.nativeRange.compareBoundaryPoints(type, range);\n        };\n      } else {\n        rangeProto.compareBoundaryPoints = function (type, range) {\n          return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);\n        };\n      }\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for existence of createContextualFragment and delegate to it if it exists\n      if (api.util.isHostMethod(range, "createContextualFragment")) {\n        rangeProto.createContextualFragment = function (fragmentStr) {\n          return this.nativeRange.createContextualFragment(fragmentStr);\n        };\n      }\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Clean up\n      dom.getBody(document).removeChild(testTextNode);\n      range.detach();\n      range2.detach();\n    })();\n\n    api.createNativeRange = function (doc) {\n      doc = doc || document;\n      return doc.createRange();\n    };\n  } else if (api.features.implementsTextRange) {\n    // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy\'s DomRange as a\n    // prototype\n\n    WrappedRange = function WrappedRange(textRange) {\n      this.textRange = textRange;\n      this.refresh();\n    };\n\n    WrappedRange.prototype = new DomRange(document);\n\n    WrappedRange.prototype.refresh = function () {\n      var start, end;\n\n      // TextRange\'s parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.\n      var rangeContainerElement = getTextRangeContainerElement(this.textRange);\n\n      if (textRangeIsCollapsed(this.textRange)) {\n        end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, true);\n      } else {\n\n        start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);\n        end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false);\n      }\n\n      this.setStart(start.node, start.offset);\n      this.setEnd(end.node, end.offset);\n    };\n\n    DomRange.copyComparisonConstants(WrappedRange);\n\n    // Add WrappedRange as the Range property of the global object to allow expression like Range.END_TO_END to work\n    var globalObj = function () {\n      return this;\n    }();\n    if (typeof globalObj.Range == "undefined") {\n      globalObj.Range = WrappedRange;\n    }\n\n    api.createNativeRange = function (doc) {\n      doc = doc || document;\n      return doc.body.createTextRange();\n    };\n  }\n\n  if (api.features.implementsTextRange) {\n    WrappedRange.rangeToTextRange = function (range) {\n      if (range.collapsed) {\n        var tr = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n\n        return tr;\n\n        //return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n      } else {\n        var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n        var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);\n        var textRange = dom.getDocument(range.startContainer).body.createTextRange();\n        textRange.setEndPoint("StartToStart", startRange);\n        textRange.setEndPoint("EndToEnd", endRange);\n        return textRange;\n      }\n    };\n  }\n\n  WrappedRange.prototype.getName = function () {\n    return "WrappedRange";\n  };\n\n  api.WrappedRange = WrappedRange;\n\n  api.createRange = function (doc) {\n    doc = doc || document;\n    return new WrappedRange(api.createNativeRange(doc));\n  };\n\n  api.createRangyRange = function (doc) {\n    doc = doc || document;\n    return new DomRange(doc);\n  };\n\n  api.createIframeRange = function (iframeEl) {\n    return api.createRange(dom.getIframeDocument(iframeEl));\n  };\n\n  api.createIframeRangyRange = function (iframeEl) {\n    return api.createRangyRange(dom.getIframeDocument(iframeEl));\n  };\n\n  api.addCreateMissingNativeApiListener(function (win) {\n    var doc = win.document;\n    if (typeof doc.createRange == "undefined") {\n      doc.createRange = function () {\n        return api.createRange(this);\n      };\n    }\n    doc = win = null;\n  });\n});rangy.createModule("WrappedSelection", function (api, module) {\n  // This will create a selection object wrapper that follows the Selection object found in the WHATWG draft DOM Range\n  // spec (http://html5.org/specs/dom-range.html)\n\n  api.requireModules(["DomUtil", "DomRange", "WrappedRange"]);\n\n  api.config.checkSelectionRanges = true;\n\n  var BOOLEAN = "boolean",\n      windowPropertyName = "_rangySelection",\n      dom = api.dom,\n      util = api.util,\n      DomRange = api.DomRange,\n      WrappedRange = api.WrappedRange,\n      DOMException = api.DOMException,\n      DomPosition = dom.DomPosition,\n      getSelection,\n      selectionIsCollapsed,\n      CONTROL = "Control";\n\n  function getWinSelection(winParam) {\n    return (winParam || window).getSelection();\n  }\n\n  function getDocSelection(winParam) {\n    return (winParam || window).document.selection;\n  }\n\n  // Test for the Range/TextRange and Selection features required\n  // Test for ability to retrieve selection\n  var implementsWinGetSelection = api.util.isHostMethod(window, "getSelection"),\n      implementsDocSelection = api.util.isHostObject(document, "selection");\n\n  var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);\n\n  if (useDocumentSelection) {\n    getSelection = getDocSelection;\n    api.isSelectionValid = function (winParam) {\n      var doc = (winParam || window).document,\n          nativeSel = doc.selection;\n\n      // Check whether the selection TextRange is actually contained within the correct document\n      return nativeSel.type != "None" || dom.getDocument(nativeSel.createRange().parentElement()) == doc;\n    };\n  } else if (implementsWinGetSelection) {\n    getSelection = getWinSelection;\n    api.isSelectionValid = function () {\n      return true;\n    };\n  } else {\n    module.fail("Neither document.selection or window.getSelection() detected.");\n  }\n\n  api.getNativeSelection = getSelection;\n\n  var testSelection = getSelection();\n  var testRange = api.createNativeRange(document);\n  var body = dom.getBody(document);\n\n  // Obtaining a range from a selection\n  var selectionHasAnchorAndFocus = util.areHostObjects(testSelection, ["anchorNode", "focusNode"] && util.areHostProperties(testSelection, ["anchorOffset", "focusOffset"]));\n  api.features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;\n\n  // Test for existence of native selection extend() method\n  var selectionHasExtend = util.isHostMethod(testSelection, "extend");\n  api.features.selectionHasExtend = selectionHasExtend;\n\n  // Test if rangeCount exists\n  var selectionHasRangeCount = typeof testSelection.rangeCount == "number";\n  api.features.selectionHasRangeCount = selectionHasRangeCount;\n\n  var selectionSupportsMultipleRanges = false;\n  var collapsedNonEditableSelectionsSupported = true;\n\n  if (util.areHostMethods(testSelection, ["addRange", "getRangeAt", "removeAllRanges"]) && typeof testSelection.rangeCount == "number" && api.features.implementsDomRange) {\n\n    (function () {\n      var iframe = document.createElement("iframe");\n      body.appendChild(iframe);\n\n      var iframeDoc = dom.getIframeDocument(iframe);\n      iframeDoc.open();\n      iframeDoc.write("<html><head></head><body>12</body></html>");\n      iframeDoc.close();\n\n      var sel = dom.getIframeWindow(iframe).getSelection();\n      var docEl = iframeDoc.documentElement;\n      var iframeBody = docEl.lastChild,\n          textNode = iframeBody.firstChild;\n\n      // Test whether the native selection will allow a collapsed selection within a non-editable element\n      var r1 = iframeDoc.createRange();\n      r1.setStart(textNode, 1);\n      r1.collapse(true);\n      sel.addRange(r1);\n      collapsedNonEditableSelectionsSupported = sel.rangeCount == 1;\n      sel.removeAllRanges();\n\n      // Test whether the native selection is capable of supporting multiple ranges\n      var r2 = r1.cloneRange();\n      r1.setStart(textNode, 0);\n      r2.setEnd(textNode, 2);\n      sel.addRange(r1);\n      sel.addRange(r2);\n\n      selectionSupportsMultipleRanges = sel.rangeCount == 2;\n\n      // Clean up\n      r1.detach();\n      r2.detach();\n\n      body.removeChild(iframe);\n    })();\n  }\n\n  api.features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;\n  api.features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;\n\n  // ControlRanges\n  var implementsControlRange = false,\n      testControlRange;\n\n  if (body && util.isHostMethod(body, "createControlRange")) {\n    testControlRange = body.createControlRange();\n    if (util.areHostProperties(testControlRange, ["item", "add"])) {\n      implementsControlRange = true;\n    }\n  }\n  api.features.implementsControlRange = implementsControlRange;\n\n  // Selection collapsedness\n  if (selectionHasAnchorAndFocus) {\n    selectionIsCollapsed = function selectionIsCollapsed(sel) {\n      return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;\n    };\n  } else {\n    selectionIsCollapsed = function selectionIsCollapsed(sel) {\n      return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;\n    };\n  }\n\n  function updateAnchorAndFocusFromRange(sel, range, backwards) {\n    var anchorPrefix = backwards ? "end" : "start",\n        focusPrefix = backwards ? "start" : "end";\n    sel.anchorNode = range[anchorPrefix + "Container"];\n    sel.anchorOffset = range[anchorPrefix + "Offset"];\n    sel.focusNode = range[focusPrefix + "Container"];\n    sel.focusOffset = range[focusPrefix + "Offset"];\n  }\n\n  function updateAnchorAndFocusFromNativeSelection(sel) {\n    var nativeSel = sel.nativeSelection;\n    sel.anchorNode = nativeSel.anchorNode;\n    sel.anchorOffset = nativeSel.anchorOffset;\n    sel.focusNode = nativeSel.focusNode;\n    sel.focusOffset = nativeSel.focusOffset;\n  }\n\n  function updateEmptySelection(sel) {\n    sel.anchorNode = sel.focusNode = null;\n    sel.anchorOffset = sel.focusOffset = 0;\n    sel.rangeCount = 0;\n    sel.isCollapsed = true;\n    sel._ranges.length = 0;\n  }\n\n  function getNativeRange(range) {\n    var nativeRange;\n    if (range instanceof DomRange) {\n      nativeRange = range._selectionNativeRange;\n      if (!nativeRange) {\n        nativeRange = api.createNativeRange(dom.getDocument(range.startContainer));\n        nativeRange.setEnd(range.endContainer, range.endOffset);\n        nativeRange.setStart(range.startContainer, range.startOffset);\n        range._selectionNativeRange = nativeRange;\n        range.attachListener("detach", function () {\n\n          this._selectionNativeRange = null;\n        });\n      }\n    } else if (range instanceof WrappedRange) {\n      nativeRange = range.nativeRange;\n    } else if (api.features.implementsDomRange && range instanceof dom.getWindow(range.startContainer).Range) {\n      nativeRange = range;\n    }\n    return nativeRange;\n  }\n\n  function rangeContainsSingleElement(rangeNodes) {\n    if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {\n      return false;\n    }\n    for (var i = 1, len = rangeNodes.length; i < len; ++i) {\n      if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function getSingleElementFromRange(range) {\n    var nodes = range.getNodes();\n    if (!rangeContainsSingleElement(nodes)) {\n      throw new Error("getSingleElementFromRange: range " + range.inspect() + " did not consist of a single element");\n    }\n    return nodes[0];\n  }\n\n  function isTextRange(range) {\n    return !!range && typeof range.text != "undefined";\n  }\n\n  function updateFromTextRange(sel, range) {\n    // Create a Range from the selected TextRange\n    var wrappedRange = new WrappedRange(range);\n    sel._ranges = [wrappedRange];\n\n    updateAnchorAndFocusFromRange(sel, wrappedRange, false);\n    sel.rangeCount = 1;\n    sel.isCollapsed = wrappedRange.collapsed;\n  }\n\n  function updateControlSelection(sel) {\n    // Update the wrapped selection based on what\'s now in the native selection\n    sel._ranges.length = 0;\n    if (sel.docSelection.type == "None") {\n      updateEmptySelection(sel);\n    } else {\n      var controlRange = sel.docSelection.createRange();\n      if (isTextRange(controlRange)) {\n        // This case (where the selection type is "Control" and calling createRange() on the selection returns\n        // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected\n        // ControlRange have been removed from the ControlRange and removed from the document.\n        updateFromTextRange(sel, controlRange);\n      } else {\n        sel.rangeCount = controlRange.length;\n        var range,\n            doc = dom.getDocument(controlRange.item(0));\n        for (var i = 0; i < sel.rangeCount; ++i) {\n          range = api.createRange(doc);\n          range.selectNode(controlRange.item(i));\n          sel._ranges.push(range);\n        }\n        sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;\n        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);\n      }\n    }\n  }\n\n  function addRangeToControlSelection(sel, range) {\n    var controlRange = sel.docSelection.createRange();\n    var rangeElement = getSingleElementFromRange(range);\n\n    // Create a new ControlRange containing all the elements in the selected ControlRange plus the element\n    // contained by the supplied range\n    var doc = dom.getDocument(controlRange.item(0));\n    var newControlRange = dom.getBody(doc).createControlRange();\n    for (var i = 0, len = controlRange.length; i < len; ++i) {\n      newControlRange.add(controlRange.item(i));\n    }\n    try {\n      newControlRange.add(rangeElement);\n    } catch (ex) {\n      throw new Error("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");\n    }\n    newControlRange.select();\n\n    // Update the wrapped selection based on what\'s now in the native selection\n    updateControlSelection(sel);\n  }\n\n  var getSelectionRangeAt;\n\n  if (util.isHostMethod(testSelection, "getRangeAt")) {\n    getSelectionRangeAt = function getSelectionRangeAt(sel, index) {\n      try {\n        return sel.getRangeAt(index);\n      } catch (ex) {\n        return null;\n      }\n    };\n  } else if (selectionHasAnchorAndFocus) {\n    getSelectionRangeAt = function getSelectionRangeAt(sel) {\n      var doc = dom.getDocument(sel.anchorNode);\n      var range = api.createRange(doc);\n      range.setStart(sel.anchorNode, sel.anchorOffset);\n      range.setEnd(sel.focusNode, sel.focusOffset);\n\n      // Handle the case when the selection was selected backwards (from the end to the start in the\n      // document)\n      if (range.collapsed !== this.isCollapsed) {\n        range.setStart(sel.focusNode, sel.focusOffset);\n        range.setEnd(sel.anchorNode, sel.anchorOffset);\n      }\n\n      return range;\n    };\n  }\n\n  /**\n   * @constructor\n   */\n  function WrappedSelection(selection, docSelection, win) {\n    this.nativeSelection = selection;\n    this.docSelection = docSelection;\n    this._ranges = [];\n    this.win = win;\n    this.refresh();\n  }\n\n  api.getSelection = function (win) {\n    win = win || window;\n    var sel = win[windowPropertyName];\n    var nativeSel = getSelection(win),\n        docSel = implementsDocSelection ? getDocSelection(win) : null;\n    if (sel) {\n      sel.nativeSelection = nativeSel;\n      sel.docSelection = docSel;\n      sel.refresh(win);\n    } else {\n      sel = new WrappedSelection(nativeSel, docSel, win);\n      win[windowPropertyName] = sel;\n    }\n    return sel;\n  };\n\n  api.getIframeSelection = function (iframeEl) {\n    return api.getSelection(dom.getIframeWindow(iframeEl));\n  };\n\n  var selProto = WrappedSelection.prototype;\n\n  function createControlSelection(sel, ranges) {\n    // Ensure that the selection becomes of type "Control"\n    var doc = dom.getDocument(ranges[0].startContainer);\n    var controlRange = dom.getBody(doc).createControlRange();\n    for (var i = 0, el; i < rangeCount; ++i) {\n      el = getSingleElementFromRange(ranges[i]);\n      try {\n        controlRange.add(el);\n      } catch (ex) {\n        throw new Error("setRanges(): Element within the one of the specified Ranges could not be added to control selection (does it have layout?)");\n      }\n    }\n    controlRange.select();\n\n    // Update the wrapped selection based on what\'s now in the native selection\n    updateControlSelection(sel);\n  }\n\n  // Selecting a range\n  if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, ["removeAllRanges", "addRange"])) {\n    selProto.removeAllRanges = function () {\n      this.nativeSelection.removeAllRanges();\n      updateEmptySelection(this);\n    };\n\n    var addRangeBackwards = function addRangeBackwards(sel, range) {\n      var doc = DomRange.getRangeDocument(range);\n      var endRange = api.createRange(doc);\n      endRange.collapseToPoint(range.endContainer, range.endOffset);\n      sel.nativeSelection.addRange(getNativeRange(endRange));\n      sel.nativeSelection.extend(range.startContainer, range.startOffset);\n      sel.refresh();\n    };\n\n    if (selectionHasRangeCount) {\n      selProto.addRange = function (range, backwards) {\n        if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n          addRangeToControlSelection(this, range);\n        } else {\n          if (backwards && selectionHasExtend) {\n            addRangeBackwards(this, range);\n          } else {\n            var previousRangeCount;\n            if (selectionSupportsMultipleRanges) {\n              previousRangeCount = this.rangeCount;\n            } else {\n              this.removeAllRanges();\n              previousRangeCount = 0;\n            }\n            this.nativeSelection.addRange(getNativeRange(range));\n\n            // Check whether adding the range was successful\n            this.rangeCount = this.nativeSelection.rangeCount;\n\n            if (this.rangeCount == previousRangeCount + 1) {\n              // The range was added successfully\n\n              // Check whether the range that we added to the selection is reflected in the last range extracted from\n              // the selection\n              if (api.config.checkSelectionRanges) {\n                var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);\n                if (nativeRange && !DomRange.rangesEqual(nativeRange, range)) {\n                  // Happens in WebKit with, for example, a selection placed at the start of a text node\n                  range = new WrappedRange(nativeRange);\n                }\n              }\n              this._ranges[this.rangeCount - 1] = range;\n              updateAnchorAndFocusFromRange(this, range, selectionIsBackwards(this.nativeSelection));\n              this.isCollapsed = selectionIsCollapsed(this);\n            } else {\n              // The range was not added successfully. The simplest thing is to refresh\n              this.refresh();\n            }\n          }\n        }\n      };\n    } else {\n      selProto.addRange = function (range, backwards) {\n        if (backwards && selectionHasExtend) {\n          addRangeBackwards(this, range);\n        } else {\n          this.nativeSelection.addRange(getNativeRange(range));\n          this.refresh();\n        }\n      };\n    }\n\n    selProto.setRanges = function (ranges) {\n      if (implementsControlRange && ranges.length > 1) {\n        createControlSelection(this, ranges);\n      } else {\n        this.removeAllRanges();\n        for (var i = 0, len = ranges.length; i < len; ++i) {\n          this.addRange(ranges[i]);\n        }\n      }\n    };\n  } else if (util.isHostMethod(testSelection, "empty") && util.isHostMethod(testRange, "select") && implementsControlRange && useDocumentSelection) {\n\n    selProto.removeAllRanges = function () {\n      // Added try/catch as fix for issue #21\n      try {\n        this.docSelection.empty();\n\n        // Check for empty() not working (issue #24)\n        if (this.docSelection.type != "None") {\n          // Work around failure to empty a control selection by instead selecting a TextRange and then\n          // calling empty()\n          var doc;\n          if (this.anchorNode) {\n            doc = dom.getDocument(this.anchorNode);\n          } else if (this.docSelection.type == CONTROL) {\n            var controlRange = this.docSelection.createRange();\n            if (controlRange.length) {\n              doc = dom.getDocument(controlRange.item(0)).body.createTextRange();\n            }\n          }\n          if (doc) {\n            var textRange = doc.body.createTextRange();\n            textRange.select();\n            this.docSelection.empty();\n          }\n        }\n      } catch (ex) {}\n      updateEmptySelection(this);\n    };\n\n    selProto.addRange = function (range) {\n      if (this.docSelection.type == CONTROL) {\n        addRangeToControlSelection(this, range);\n      } else {\n        WrappedRange.rangeToTextRange(range).select();\n        this._ranges[0] = range;\n        this.rangeCount = 1;\n        this.isCollapsed = this._ranges[0].collapsed;\n        updateAnchorAndFocusFromRange(this, range, false);\n      }\n    };\n\n    selProto.setRanges = function (ranges) {\n      this.removeAllRanges();\n      var rangeCount = ranges.length;\n      if (rangeCount > 1) {\n        createControlSelection(this, ranges);\n      } else if (rangeCount) {\n        this.addRange(ranges[0]);\n      }\n    };\n  } else {\n    module.fail("No means of selecting a Range or TextRange was found");\n    return false;\n  }\n\n  selProto.getRangeAt = function (index) {\n    if (index < 0 || index >= this.rangeCount) {\n      throw new DOMException("INDEX_SIZE_ERR");\n    } else {\n      return this._ranges[index];\n    }\n  };\n\n  var refreshSelection;\n\n  if (useDocumentSelection) {\n    refreshSelection = function refreshSelection(sel) {\n      var range;\n      if (api.isSelectionValid(sel.win)) {\n        range = sel.docSelection.createRange();\n      } else {\n        range = dom.getBody(sel.win.document).createTextRange();\n        range.collapse(true);\n      }\n\n      if (sel.docSelection.type == CONTROL) {\n        updateControlSelection(sel);\n      } else if (isTextRange(range)) {\n        updateFromTextRange(sel, range);\n      } else {\n        updateEmptySelection(sel);\n      }\n    };\n  } else if (util.isHostMethod(testSelection, "getRangeAt") && typeof testSelection.rangeCount == "number") {\n    refreshSelection = function refreshSelection(sel) {\n      if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {\n        updateControlSelection(sel);\n      } else {\n        sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;\n        if (sel.rangeCount) {\n          for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));\n          }\n          updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackwards(sel.nativeSelection));\n          sel.isCollapsed = selectionIsCollapsed(sel);\n        } else {\n          updateEmptySelection(sel);\n        }\n      }\n    };\n  } else if (selectionHasAnchorAndFocus && _typeof(testSelection.isCollapsed) == BOOLEAN && _typeof(testRange.collapsed) == BOOLEAN && api.features.implementsDomRange) {\n    refreshSelection = function refreshSelection(sel) {\n      var range,\n          nativeSel = sel.nativeSelection;\n      if (nativeSel.anchorNode) {\n        range = getSelectionRangeAt(nativeSel, 0);\n        sel._ranges = [range];\n        sel.rangeCount = 1;\n        updateAnchorAndFocusFromNativeSelection(sel);\n        sel.isCollapsed = selectionIsCollapsed(sel);\n      } else {\n        updateEmptySelection(sel);\n      }\n    };\n  } else {\n    module.fail("No means of obtaining a Range or TextRange from the user\'s selection was found");\n    return false;\n  }\n\n  selProto.refresh = function (checkForChanges) {\n    var oldRanges = checkForChanges ? this._ranges.slice(0) : null;\n    refreshSelection(this);\n    if (checkForChanges) {\n      var i = oldRanges.length;\n      if (i != this._ranges.length) {\n        return false;\n      }\n      while (i--) {\n        if (!DomRange.rangesEqual(oldRanges[i], this._ranges[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  };\n\n  // Removal of a single range\n  var removeRangeManually = function removeRangeManually(sel, range) {\n    var ranges = sel.getAllRanges(),\n        removed = false;\n    sel.removeAllRanges();\n    for (var i = 0, len = ranges.length; i < len; ++i) {\n      if (removed || range !== ranges[i]) {\n        sel.addRange(ranges[i]);\n      } else {\n        // According to the draft WHATWG Range spec, the same range may be added to the selection multiple\n        // times. removeRange should only remove the first instance, so the following ensures only the first\n        // instance is removed\n        removed = true;\n      }\n    }\n    if (!sel.rangeCount) {\n      updateEmptySelection(sel);\n    }\n  };\n\n  if (implementsControlRange) {\n    selProto.removeRange = function (range) {\n      if (this.docSelection.type == CONTROL) {\n        var controlRange = this.docSelection.createRange();\n        var rangeElement = getSingleElementFromRange(range);\n\n        // Create a new ControlRange containing all the elements in the selected ControlRange minus the\n        // element contained by the supplied range\n        var doc = dom.getDocument(controlRange.item(0));\n        var newControlRange = dom.getBody(doc).createControlRange();\n        var el,\n            removed = false;\n        for (var i = 0, len = controlRange.length; i < len; ++i) {\n          el = controlRange.item(i);\n          if (el !== rangeElement || removed) {\n            newControlRange.add(controlRange.item(i));\n          } else {\n            removed = true;\n          }\n        }\n        newControlRange.select();\n\n        // Update the wrapped selection based on what\'s now in the native selection\n        updateControlSelection(this);\n      } else {\n        removeRangeManually(this, range);\n      }\n    };\n  } else {\n    selProto.removeRange = function (range) {\n      removeRangeManually(this, range);\n    };\n  }\n\n  // Detecting if a selection is backwards\n  var selectionIsBackwards;\n  if (!useDocumentSelection && selectionHasAnchorAndFocus && api.features.implementsDomRange) {\n    selectionIsBackwards = function selectionIsBackwards(sel) {\n      var backwards = false;\n      if (sel.anchorNode) {\n        backwards = dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1;\n      }\n      return backwards;\n    };\n\n    selProto.isBackwards = function () {\n      return selectionIsBackwards(this);\n    };\n  } else {\n    selectionIsBackwards = selProto.isBackwards = function () {\n      return false;\n    };\n  }\n\n  // Selection text\n  // This is conformant to the new WHATWG DOM Range draft spec but differs from WebKit and Mozilla\'s implementation\n  selProto.toString = function () {\n\n    var rangeTexts = [];\n    for (var i = 0, len = this.rangeCount; i < len; ++i) {\n      rangeTexts[i] = "" + this._ranges[i];\n    }\n    return rangeTexts.join("");\n  };\n\n  function assertNodeInSameDocument(sel, node) {\n    if (sel.anchorNode && dom.getDocument(sel.anchorNode) !== dom.getDocument(node)) {\n      throw new DOMException("WRONG_DOCUMENT_ERR");\n    }\n  }\n\n  // No current browsers conform fully to the HTML 5 draft spec for this method, so Rangy\'s own method is always used\n  selProto.collapse = function (node, offset) {\n    assertNodeInSameDocument(this, node);\n    var range = api.createRange(dom.getDocument(node));\n    range.collapseToPoint(node, offset);\n    this.removeAllRanges();\n    this.addRange(range);\n    this.isCollapsed = true;\n  };\n\n  selProto.collapseToStart = function () {\n    if (this.rangeCount) {\n      var range = this._ranges[0];\n      this.collapse(range.startContainer, range.startOffset);\n    } else {\n      throw new DOMException("INVALID_STATE_ERR");\n    }\n  };\n\n  selProto.collapseToEnd = function () {\n    if (this.rangeCount) {\n      var range = this._ranges[this.rangeCount - 1];\n      this.collapse(range.endContainer, range.endOffset);\n    } else {\n      throw new DOMException("INVALID_STATE_ERR");\n    }\n  };\n\n  // The HTML 5 spec is very specific on how selectAllChildren should be implemented so the native implementation is\n  // never used by Rangy.\n  selProto.selectAllChildren = function (node) {\n    assertNodeInSameDocument(this, node);\n    var range = api.createRange(dom.getDocument(node));\n    range.selectNodeContents(node);\n    this.removeAllRanges();\n    this.addRange(range);\n  };\n\n  selProto.deleteFromDocument = function () {\n    // Sepcial behaviour required for Control selections\n    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n      var controlRange = this.docSelection.createRange();\n      var element;\n      while (controlRange.length) {\n        element = controlRange.item(0);\n        controlRange.remove(element);\n        element.parentNode.removeChild(element);\n      }\n      this.refresh();\n    } else if (this.rangeCount) {\n      var ranges = this.getAllRanges();\n      this.removeAllRanges();\n      for (var i = 0, len = ranges.length; i < len; ++i) {\n        ranges[i].deleteContents();\n      }\n      // The HTML5 spec says nothing about what the selection should contain after calling deleteContents on each\n      // range. Firefox moves the selection to where the final selected range was, so we emulate that\n      this.addRange(ranges[len - 1]);\n    }\n  };\n\n  // The following are non-standard extensions\n  selProto.getAllRanges = function () {\n    return this._ranges.slice(0);\n  };\n\n  selProto.setSingleRange = function (range) {\n    this.setRanges([range]);\n  };\n\n  selProto.containsNode = function (node, allowPartial) {\n    for (var i = 0, len = this._ranges.length; i < len; ++i) {\n      if (this._ranges[i].containsNode(node, allowPartial)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  selProto.toHtml = function () {\n    var html = "";\n    if (this.rangeCount) {\n      var container = DomRange.getRangeDocument(this._ranges[0]).createElement("div");\n      for (var i = 0, len = this._ranges.length; i < len; ++i) {\n        container.appendChild(this._ranges[i].cloneContents());\n      }\n      html = container.innerHTML;\n    }\n    return html;\n  };\n\n  function inspect(sel) {\n    var rangeInspects = [];\n    var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);\n    var focus = new DomPosition(sel.focusNode, sel.focusOffset);\n    var name = typeof sel.getName == "function" ? sel.getName() : "Selection";\n\n    if (typeof sel.rangeCount != "undefined") {\n      for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n        rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));\n      }\n    }\n    return "[" + name + "(Ranges: " + rangeInspects.join(", ") + ")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";\n  }\n\n  selProto.getName = function () {\n    return "WrappedSelection";\n  };\n\n  selProto.inspect = function () {\n    return inspect(this);\n  };\n\n  selProto.detach = function () {\n    this.win[windowPropertyName] = null;\n    this.win = this.anchorNode = this.focusNode = null;\n  };\n\n  WrappedSelection.inspect = inspect;\n\n  api.Selection = WrappedSelection;\n\n  api.selectionPrototype = selProto;\n\n  api.addCreateMissingNativeApiListener(function (win) {\n    if (typeof win.getSelection == "undefined") {\n      win.getSelection = function () {\n        return api.getSelection(this);\n      };\n    }\n    win = null;\n  });\n});\n/*\n\tBase.js, version 1.1a\n\tCopyright 2006-2010, Dean Edwards\n\tLicense: http://www.opensource.org/licenses/mit-license.php\n*/\n\nvar Base = function Base() {\n  // dummy\n};\n\nBase.extend = function (_instance, _static) {\n  // subclass\n  var extend = Base.prototype.extend;\n\n  // build the prototype\n  Base._prototyping = true;\n  var proto = new this();\n  extend.call(proto, _instance);\n  proto.base = function () {\n    // call this method from any other method to invoke that method\'s ancestor\n  };\n  delete Base._prototyping;\n\n  // create the wrapper for the constructor function\n  //var constructor = proto.constructor.valueOf(); //-dean\n  var constructor = proto.constructor;\n  var klass = proto.constructor = function () {\n    if (!Base._prototyping) {\n      if (this._constructing || this.constructor == klass) {\n        // instantiation\n        this._constructing = true;\n        constructor.apply(this, arguments);\n        delete this._constructing;\n      } else if (arguments[0] != null) {\n        // casting\n        return (arguments[0].extend || extend).call(arguments[0], proto);\n      }\n    }\n  };\n\n  // build the class interface\n  klass.ancestor = this;\n  klass.extend = this.extend;\n  klass.forEach = this.forEach;\n  klass.implement = this.implement;\n  klass.prototype = proto;\n  klass.toString = this.toString;\n  klass.valueOf = function (type) {\n    //return (type == "object") ? klass : constructor; //-dean\n    return type == "object" ? klass : constructor.valueOf();\n  };\n  extend.call(klass, _static);\n  // class initialisation\n  if (typeof klass.init == "function") klass.init();\n  return klass;\n};\n\nBase.prototype = {\n  extend: function extend(source, value) {\n    if (arguments.length > 1) {\n      // extending with a name/value pair\n      var ancestor = this[source];\n      if (ancestor && typeof value == "function" && ( // overriding a method?\n      // the valueOf() comparison is to avoid circular references\n      !ancestor.valueOf || ancestor.valueOf() != value.valueOf()) && /\\bbase\\b/.test(value)) {\n        // get the underlying method\n        var method = value.valueOf();\n        // override\n        value = function value() {\n          var previous = this.base || Base.prototype.base;\n          this.base = ancestor;\n          var returnValue = method.apply(this, arguments);\n          this.base = previous;\n          return returnValue;\n        };\n        // point to the underlying method\n        value.valueOf = function (type) {\n          return type == "object" ? value : method;\n        };\n        value.toString = Base.toString;\n      }\n      this[source] = value;\n    } else if (source) {\n      // extending with an object literal\n      var extend = Base.prototype.extend;\n      // if this object has a customised extend method then use it\n      if (!Base._prototyping && typeof this != "function") {\n        extend = this.extend || extend;\n      }\n      var proto = { toSource: null };\n      // do the "toString" and other methods manually\n      var hidden = ["constructor", "toString", "valueOf"];\n      // if we are prototyping then include the constructor\n      var i = Base._prototyping ? 0 : 1;\n      while (key = hidden[i++]) {\n        if (source[key] != proto[key]) {\n          extend.call(this, key, source[key]);\n        }\n      }\n      // copy each of the source object\'s properties to this object\n      for (var key in source) {\n        if (!proto[key]) extend.call(this, key, source[key]);\n      }\n    }\n    return this;\n  }\n};\n\n// initialise\nBase = Base.extend({\n  constructor: function constructor() {\n    this.extend(arguments[0]);\n  }\n}, {\n  ancestor: Object,\n  version: "1.1",\n\n  forEach: function forEach(object, block, context) {\n    for (var key in object) {\n      if (this.prototype[key] === undefined) {\n        block.call(context, object[key], key, object);\n      }\n    }\n  },\n\n  implement: function implement() {\n    for (var i = 0; i < arguments.length; i++) {\n      if (typeof arguments[i] == "function") {\n        // if it\'s a function, call it\n        arguments[i](this.prototype);\n      } else {\n        // add the interface using the extend method\n        this.prototype.extend(arguments[i]);\n      }\n    }\n    return this;\n  },\n\n  toString: function toString() {\n    return String(this.valueOf());\n  }\n}); /**\n    * Detect browser support for specific features\n    */\nwysihtml5.browser = function () {\n  var userAgent = navigator.userAgent,\n      testElement = document.createElement("div"),\n\n\n  // Browser sniffing is unfortunately needed since some behaviors are impossible to feature detect\n  isIE = userAgent.indexOf("MSIE") !== -1 && userAgent.indexOf("Opera") === -1,\n      isGecko = userAgent.indexOf("Gecko") !== -1 && userAgent.indexOf("KHTML") === -1,\n      isWebKit = userAgent.indexOf("AppleWebKit/") !== -1,\n      isChrome = userAgent.indexOf("Chrome/") !== -1,\n      isOpera = userAgent.indexOf("Opera/") !== -1;\n\n  function iosVersion(userAgent) {\n    return (/ipad|iphone|ipod/.test(userAgent) && userAgent.match(/ os (\\d+).+? like mac os x/) || [, 0])[1];\n  }\n\n  return {\n    // Static variable needed, publicly accessible, to be able override it in unit tests\n    USER_AGENT: userAgent,\n\n    /**\n     * Exclude browsers that are not capable of displaying and handling\n     * contentEditable as desired:\n     *    - iPhone, iPad (tested iOS 4.2.2) and Android (tested 2.2) refuse to make contentEditables focusable\n     *    - IE < 8 create invalid markup and crash randomly from time to time\n     *\n     * @return {Boolean}\n     */\n    supported: function supported() {\n      var userAgent = this.USER_AGENT.toLowerCase(),\n\n\n      // Essential for making html elements editable\n      hasContentEditableSupport = "contentEditable" in testElement,\n\n\n      // Following methods are needed in order to interact with the contentEditable area\n      hasEditingApiSupport = document.execCommand && document.queryCommandSupported && document.queryCommandState,\n\n\n      // document selector apis are only supported by IE 8+, Safari 4+, Chrome and Firefox 3.5+\n      hasQuerySelectorSupport = document.querySelector && document.querySelectorAll,\n\n\n      // contentEditable is unusable in mobile browsers (tested iOS 4.2.2, Android 2.2, Opera Mobile, WebOS 3.05)\n      isIncompatibleMobileBrowser = this.isIos() && iosVersion(userAgent) < 5 || userAgent.indexOf("opera mobi") !== -1 || userAgent.indexOf("hpwos/") !== -1;\n\n      return hasContentEditableSupport && hasEditingApiSupport && hasQuerySelectorSupport && !isIncompatibleMobileBrowser;\n    },\n\n    isTouchDevice: function isTouchDevice() {\n      return this.supportsEvent("touchmove");\n    },\n\n    isIos: function isIos() {\n      var userAgent = this.USER_AGENT.toLowerCase();\n      return userAgent.indexOf("webkit") !== -1 && userAgent.indexOf("mobile") !== -1;\n    },\n\n    /**\n     * Whether the browser supports sandboxed iframes\n     * Currently only IE 6+ offers such feature <iframe security="restricted">\n     *\n     * http://msdn.microsoft.com/en-us/library/ms534622(v=vs.85).aspx\n     * http://blogs.msdn.com/b/ie/archive/2008/01/18/using-frames-more-securely.aspx\n     *\n     * HTML5 sandboxed iframes are still buggy and their DOM is not reachable from the outside (except when using postMessage)\n     */\n    supportsSandboxedIframes: function supportsSandboxedIframes() {\n      return isIE;\n    },\n\n    /**\n     * IE6+7 throw a mixed content warning when the src of an iframe\n     * is empty/unset or about:blank\n     * window.querySelector is implemented as of IE8\n     */\n    throwsMixedContentWarningWhenIframeSrcIsEmpty: function throwsMixedContentWarningWhenIframeSrcIsEmpty() {\n      return !("querySelector" in document);\n    },\n\n    /**\n     * Whether the caret is correctly displayed in contentEditable elements\n     * Firefox sometimes shows a huge caret in the beginning after focusing\n     */\n    displaysCaretInEmptyContentEditableCorrectly: function displaysCaretInEmptyContentEditableCorrectly() {\n      return !isGecko;\n    },\n\n    /**\n     * Opera and IE are the only browsers who offer the css value\n     * in the original unit, thx to the currentStyle object\n     * All other browsers provide the computed style in px via window.getComputedStyle\n     */\n    hasCurrentStyleProperty: function hasCurrentStyleProperty() {\n      return "currentStyle" in testElement;\n    },\n\n    /**\n     * Whether the browser inserts a <br> when pressing enter in a contentEditable element\n     */\n    insertsLineBreaksOnReturn: function insertsLineBreaksOnReturn() {\n      return isGecko;\n    },\n\n    supportsPlaceholderAttributeOn: function supportsPlaceholderAttributeOn(element) {\n      return "placeholder" in element;\n    },\n\n    supportsEvent: function supportsEvent(eventName) {\n      return "on" + eventName in testElement || function () {\n        testElement.setAttribute("on" + eventName, "return;");\n        return typeof testElement["on" + eventName] === "function";\n      }();\n    },\n\n    /**\n     * Opera doesn\'t correctly fire focus/blur events when clicking in- and outside of iframe\n     */\n    supportsEventsInIframeCorrectly: function supportsEventsInIframeCorrectly() {\n      return !isOpera;\n    },\n\n    /**\n     * Chrome & Safari only fire the ondrop/ondragend/... events when the ondragover event is cancelled\n     * with event.preventDefault\n     * Firefox 3.6 fires those events anyway, but the mozilla doc says that the dragover/dragenter event needs\n     * to be cancelled\n     */\n    firesOnDropOnlyWhenOnDragOverIsCancelled: function firesOnDropOnlyWhenOnDragOverIsCancelled() {\n      return isWebKit || isGecko;\n    },\n\n    /**\n     * Whether the browser supports the event.dataTransfer property in a proper way\n     */\n    supportsDataTransfer: function supportsDataTransfer() {\n      try {\n        // Firefox doesn\'t support dataTransfer in a safe way, it doesn\'t strip script code in the html payload (like Chrome does)\n        return isWebKit && (window.Clipboard || window.DataTransfer).prototype.getData;\n      } catch (e) {\n        return false;\n      }\n    },\n\n    /**\n     * Everything below IE9 doesn\'t know how to treat HTML5 tags\n     *\n     * @param {Object} context The document object on which to check HTML5 support\n     *\n     * @example\n     *    wysihtml5.browser.supportsHTML5Tags(document);\n     */\n    supportsHTML5Tags: function supportsHTML5Tags(context) {\n      var element = context.createElement("div"),\n          html5 = "<article>foo</article>";\n      element.innerHTML = html5;\n      return element.innerHTML.toLowerCase() === html5;\n    },\n\n    /**\n     * Checks whether a document supports a certain queryCommand\n     * In particular, Opera needs a reference to a document that has a contentEditable in it\'s dom tree\n     * in oder to report correct results\n     *\n     * @param {Object} doc Document object on which to check for a query command\n     * @param {String} command The query command to check for\n     * @return {Boolean}\n     *\n     * @example\n     *    wysihtml5.browser.supportsCommand(document, "bold");\n     */\n    supportsCommand: function () {\n      // Following commands are supported but contain bugs in some browsers\n      var buggyCommands = {\n        // formatBlock fails with some tags (eg. <blockquote>)\n        "formatBlock": isIE,\n        // When inserting unordered or ordered lists in Firefox, Chrome or Safari, the current selection or line gets\n        // converted into a list (<ul><li>...</li></ul>, <ol><li>...</li></ol>)\n        // IE and Opera act a bit different here as they convert the entire content of the current block element into a list\n        "insertUnorderedList": isIE || isOpera || isWebKit,\n        "insertOrderedList": isIE || isOpera || isWebKit\n      };\n\n      // Firefox throws errors for queryCommandSupported, so we have to build up our own object of supported commands\n      var supported = {\n        "insertHTML": isGecko\n      };\n\n      return function (doc, command) {\n        var isBuggy = buggyCommands[command];\n        if (!isBuggy) {\n          // Firefox throws errors when invoking queryCommandSupported or queryCommandEnabled\n          try {\n            return doc.queryCommandSupported(command);\n          } catch (e1) {}\n\n          try {\n            return doc.queryCommandEnabled(command);\n          } catch (e2) {\n            return !!supported[command];\n          }\n        }\n        return false;\n      };\n    }(),\n\n    /**\n     * IE: URLs starting with:\n     *    www., http://, https://, ftp://, gopher://, mailto:, new:, snews:, telnet:, wasis:, file://,\n     *    nntp://, newsrc:, ldap://, ldaps://, outlook:, mic:// and url:\n     * will automatically be auto-linked when either the user inserts them via copy&paste or presses the\n     * space bar when the caret is directly after such an url.\n     * This behavior cannot easily be avoided in IE < 9 since the logic is hardcoded in the mshtml.dll\n     * (related blog post on msdn\n     * http://blogs.msdn.com/b/ieinternals/archive/2009/09/17/prevent-automatic-hyperlinking-in-contenteditable-html.aspx).\n     */\n    doesAutoLinkingInContentEditable: function doesAutoLinkingInContentEditable() {\n      return isIE;\n    },\n\n    /**\n     * As stated above, IE auto links urls typed into contentEditable elements\n     * Since IE9 it\'s possible to prevent this behavior\n     */\n    canDisableAutoLinking: function canDisableAutoLinking() {\n      return this.supportsCommand(document, "AutoUrlDetect");\n    },\n\n    /**\n     * IE leaves an empty paragraph in the contentEditable element after clearing it\n     * Chrome/Safari sometimes an empty <div>\n     */\n    clearsContentEditableCorrectly: function clearsContentEditableCorrectly() {\n      return isGecko || isOpera || isWebKit;\n    },\n\n    /**\n     * IE gives wrong results for getAttribute\n     */\n    supportsGetAttributeCorrectly: function supportsGetAttributeCorrectly() {\n      var td = document.createElement("td");\n      return td.getAttribute("rowspan") != "1";\n    },\n\n    /**\n     * When clicking on images in IE, Opera and Firefox, they are selected, which makes it easy to interact with them.\n     * Chrome and Safari both don\'t support this\n     */\n    canSelectImagesInContentEditable: function canSelectImagesInContentEditable() {\n      return isGecko || isIE || isOpera;\n    },\n\n    /**\n     * When the caret is in an empty list (<ul><li>|</li></ul>) which is the first child in an contentEditable container\n     * pressing backspace doesn\'t remove the entire list as done in other browsers\n     */\n    clearsListsInContentEditableCorrectly: function clearsListsInContentEditableCorrectly() {\n      return isGecko || isIE || isWebKit;\n    },\n\n    /**\n     * All browsers except Safari and Chrome automatically scroll the range/caret position into view\n     */\n    autoScrollsToCaret: function autoScrollsToCaret() {\n      return !isWebKit;\n    },\n\n    /**\n     * Check whether the browser automatically closes tags that don\'t need to be opened\n     */\n    autoClosesUnclosedTags: function autoClosesUnclosedTags() {\n      var clonedTestElement = testElement.cloneNode(false),\n          returnValue,\n          innerHTML;\n\n      clonedTestElement.innerHTML = "<p><div></div>";\n      innerHTML = clonedTestElement.innerHTML.toLowerCase();\n      returnValue = innerHTML === "<p></p><div></div>" || innerHTML === "<p><div></div></p>";\n\n      // Cache result by overwriting current function\n      this.autoClosesUnclosedTags = function () {\n        return returnValue;\n      };\n\n      return returnValue;\n    },\n\n    /**\n     * Whether the browser supports the native document.getElementsByClassName which returns live NodeLists\n     */\n    supportsNativeGetElementsByClassName: function supportsNativeGetElementsByClassName() {\n      return String(document.getElementsByClassName).indexOf("[native code]") !== -1;\n    },\n\n    /**\n     * As of now (19.04.2011) only supported by Firefox 4 and Chrome\n     * See https://developer.mozilla.org/en/DOM/Selection/modify\n     */\n    supportsSelectionModify: function supportsSelectionModify() {\n      return "getSelection" in window && "modify" in window.getSelection();\n    },\n\n    /**\n     * Whether the browser supports the classList object for fast className manipulation\n     * See https://developer.mozilla.org/en/DOM/element.classList\n     */\n    supportsClassList: function supportsClassList() {\n      return "classList" in testElement;\n    },\n\n    /**\n     * Opera needs a white space after a <br> in order to position the caret correctly\n     */\n    needsSpaceAfterLineBreak: function needsSpaceAfterLineBreak() {\n      return isOpera;\n    },\n\n    /**\n     * Whether the browser supports the speech api on the given element\n     * See http://mikepultz.com/2011/03/accessing-google-speech-api-chrome-11/\n     *\n     * @example\n     *    var input = document.createElement("input");\n     *    if (wysihtml5.browser.supportsSpeechApiOn(input)) {\n     *      // ...\n     *    }\n     */\n    supportsSpeechApiOn: function supportsSpeechApiOn(input) {\n      var chromeVersion = userAgent.match(/Chrome\\/(\\d+)/) || [, 0];\n      return chromeVersion[1] >= 11 && ("onwebkitspeechchange" in input || "speech" in input);\n    },\n\n    /**\n     * IE9 crashes when setting a getter via Object.defineProperty on XMLHttpRequest or XDomainRequest\n     * See https://connect.microsoft.com/ie/feedback/details/650112\n     * or try the POC http://tifftiff.de/ie9_crash/\n     */\n    crashesWhenDefineProperty: function crashesWhenDefineProperty(property) {\n      return isIE && (property === "XMLHttpRequest" || property === "XDomainRequest");\n    },\n\n    /**\n     * IE is the only browser who fires the "focus" event not immediately when .focus() is called on an element\n     */\n    doesAsyncFocus: function doesAsyncFocus() {\n      return isIE;\n    },\n\n    /**\n     * In IE it\'s impssible for the user and for the selection library to set the caret after an <img> when it\'s the lastChild in the document\n     */\n    hasProblemsSettingCaretAfterImg: function hasProblemsSettingCaretAfterImg() {\n      return isIE;\n    },\n\n    hasUndoInContextMenu: function hasUndoInContextMenu() {\n      return isGecko || isChrome || isOpera;\n    }\n  };\n}();wysihtml5.lang.array = function (arr) {\n  return {\n    /**\n     * Check whether a given object exists in an array\n     *\n     * @example\n     *    wysihtml5.lang.array([1, 2]).contains(1);\n     *    // => true\n     */\n    contains: function contains(needle) {\n      if (arr.indexOf) {\n        return arr.indexOf(needle) !== -1;\n      } else {\n        for (var i = 0, length = arr.length; i < length; i++) {\n          if (arr[i] === needle) {\n            return true;\n          }\n        }\n        return false;\n      }\n    },\n\n    /**\n     * Substract one array from another\n     *\n     * @example\n     *    wysihtml5.lang.array([1, 2, 3, 4]).without([3, 4]);\n     *    // => [1, 2]\n     */\n    without: function without(arrayToSubstract) {\n      arrayToSubstract = wysihtml5.lang.array(arrayToSubstract);\n      var newArr = [],\n          i = 0,\n          length = arr.length;\n      for (; i < length; i++) {\n        if (!arrayToSubstract.contains(arr[i])) {\n          newArr.push(arr[i]);\n        }\n      }\n      return newArr;\n    },\n\n    /**\n     * Return a clean native array\n     * \n     * Following will convert a Live NodeList to a proper Array\n     * @example\n     *    var childNodes = wysihtml5.lang.array(document.body.childNodes).get();\n     */\n    get: function get() {\n      var i = 0,\n          length = arr.length,\n          newArray = [];\n      for (; i < length; i++) {\n        newArray.push(arr[i]);\n      }\n      return newArray;\n    }\n  };\n};wysihtml5.lang.Dispatcher = Base.extend(\n/** @scope wysihtml5.lang.Dialog.prototype */{\n  observe: function observe(eventName, handler) {\n    this.events = this.events || {};\n    this.events[eventName] = this.events[eventName] || [];\n    this.events[eventName].push(handler);\n    return this;\n  },\n\n  on: function on() {\n    return this.observe.apply(this, wysihtml5.lang.array(arguments).get());\n  },\n\n  fire: function fire(eventName, payload) {\n    this.events = this.events || {};\n    var handlers = this.events[eventName] || [],\n        i = 0;\n    for (; i < handlers.length; i++) {\n      handlers[i].call(this, payload);\n    }\n    return this;\n  },\n\n  stopObserving: function stopObserving(eventName, handler) {\n    this.events = this.events || {};\n    var i = 0,\n        handlers,\n        newHandlers;\n    if (eventName) {\n      handlers = this.events[eventName] || [], newHandlers = [];\n      for (; i < handlers.length; i++) {\n        if (handlers[i] !== handler && handler) {\n          newHandlers.push(handlers[i]);\n        }\n      }\n      this.events[eventName] = newHandlers;\n    } else {\n      // Clean up all events\n      this.events = {};\n    }\n    return this;\n  }\n});wysihtml5.lang.object = function (obj) {\n  return {\n    /**\n     * @example\n     *    wysihtml5.lang.object({ foo: 1, bar: 1 }).merge({ bar: 2, baz: 3 }).get();\n     *    // => { foo: 1, bar: 2, baz: 3 }\n     */\n    merge: function merge(otherObj) {\n      for (var i in otherObj) {\n        obj[i] = otherObj[i];\n      }\n      return this;\n    },\n\n    get: function get() {\n      return obj;\n    },\n\n    /**\n     * @example\n     *    wysihtml5.lang.object({ foo: 1 }).clone();\n     *    // => { foo: 1 }\n     */\n    clone: function clone() {\n      var newObj = {},\n          i;\n      for (i in obj) {\n        newObj[i] = obj[i];\n      }\n      return newObj;\n    },\n\n    /**\n     * @example\n     *    wysihtml5.lang.object([]).isArray();\n     *    // => true\n     */\n    isArray: function isArray() {\n      return Object.prototype.toString.call(obj) === "[object Array]";\n    }\n  };\n};(function () {\n  var WHITE_SPACE_START = /^\\s+/,\n      WHITE_SPACE_END = /\\s+$/;\n  wysihtml5.lang.string = function (str) {\n    str = String(str);\n    return {\n      /**\n       * @example\n       *    wysihtml5.lang.string("   foo   ").trim();\n       *    // => "foo"\n       */\n      trim: function trim() {\n        return str.replace(WHITE_SPACE_START, "").replace(WHITE_SPACE_END, "");\n      },\n\n      /**\n       * @example\n       *    wysihtml5.lang.string("Hello #{name}").interpolate({ name: "Christopher" });\n       *    // => "Hello Christopher"\n       */\n      interpolate: function interpolate(vars) {\n        for (var i in vars) {\n          str = this.replace("#{" + i + "}").by(vars[i]);\n        }\n        return str;\n      },\n\n      /**\n       * @example\n       *    wysihtml5.lang.string("Hello Tom").replace("Tom").with("Hans");\n       *    // => "Hello Hans"\n       */\n      replace: function replace(search) {\n        return {\n          by: function by(replace) {\n            return str.split(search).join(replace);\n          }\n        };\n      }\n    };\n  };\n})(); /**\n      * Find urls in descendant text nodes of an element and auto-links them\n      * Inspired by http://james.padolsey.com/javascript/find-and-replace-text-with-javascript/\n      *\n      * @param {Element} element Container element in which to search for urls\n      *\n      * @example\n      *    <div id="text-container">Please click here: www.google.com</div>\n      *    <script>wysihtml5.dom.autoLink(document.getElementById("text-container"));<\/script>\n      */\n(function (wysihtml5) {\n  var /**\n       * Don\'t auto-link urls that are contained in the following elements:\n       */\n  IGNORE_URLS_IN = wysihtml5.lang.array(["CODE", "PRE", "A", "SCRIPT", "HEAD", "TITLE", "STYLE"]),\n\n\n  /**\n   * revision 1:\n   *    /(\\S+\\.{1}[^\\s\\,\\.\\!]+)/g\n   *\n   * revision 2:\n   *    /(\\b(((https?|ftp):\\/\\/)|(www\\.))[-A-Z0-9+&@#\\/%?=~_|!:,.;\\[\\]]*[-A-Z0-9+&@#\\/%=~_|])/gim\n   *\n   * put this in the beginning if you don\'t wan\'t to match within a word\n   *    (^|[\\>\\(\\{\\[\\s\\>])\n   */\n  URL_REG_EXP = /((https?:\\/\\/|www\\.)[^\\s<]{3,})/gi,\n      TRAILING_CHAR_REG_EXP = /([^\\w\\/\\-](,?))$/i,\n      MAX_DISPLAY_LENGTH = 100,\n      BRACKETS = { ")": "(", "]": "[", "}": "{" };\n\n  function autoLink(element) {\n    if (_hasParentThatShouldBeIgnored(element)) {\n      return element;\n    }\n\n    if (element === element.ownerDocument.documentElement) {\n      element = element.ownerDocument.body;\n    }\n\n    return _parseNode(element);\n  }\n\n  /**\n   * This is basically a rebuild of\n   * the rails auto_link_urls text helper\n   */\n  function _convertUrlsToLinks(str) {\n    return str.replace(URL_REG_EXP, function (match, url) {\n      var punctuation = (url.match(TRAILING_CHAR_REG_EXP) || [])[1] || "",\n          opening = BRACKETS[punctuation];\n      url = url.replace(TRAILING_CHAR_REG_EXP, "");\n\n      if (url.split(opening).length > url.split(punctuation).length) {\n        url = url + punctuation;\n        punctuation = "";\n      }\n      var realUrl = url,\n          displayUrl = url;\n      if (url.length > MAX_DISPLAY_LENGTH) {\n        displayUrl = displayUrl.substr(0, MAX_DISPLAY_LENGTH) + "...";\n      }\n      // Add http prefix if necessary\n      if (realUrl.substr(0, 4) === "www.") {\n        realUrl = "http://" + realUrl;\n      }\n\n      return \'<a href="\' + realUrl + \'">\' + realUrl + \'</a>\' + punctuation;\n    });\n  }\n\n  /**\n   * Creates or (if already cached) returns a temp element\n   * for the given document object\n   */\n  function _getTempElement(context) {\n    var tempElement = context._wysihtml5_tempElement;\n    if (!tempElement) {\n      tempElement = context._wysihtml5_tempElement = context.createElement("div");\n    }\n    return tempElement;\n  }\n\n  /**\n   * Replaces the original text nodes with the newly auto-linked dom tree\n   */\n  function _wrapMatchesInNode(textNode) {\n    var parentNode = textNode.parentNode,\n        tempElement = _getTempElement(parentNode.ownerDocument);\n\n    // We need to insert an empty/temporary <span /> to fix IE quirks\n    // Elsewise IE would strip white space in the beginning\n    tempElement.innerHTML = "<span></span>" + _convertUrlsToLinks(textNode.data);\n    tempElement.removeChild(tempElement.firstChild);\n\n    while (tempElement.firstChild) {\n      // inserts tempElement.firstChild before textNode\n      parentNode.insertBefore(tempElement.firstChild, textNode);\n    }\n    parentNode.removeChild(textNode);\n  }\n\n  function _hasParentThatShouldBeIgnored(node) {\n    var nodeName;\n    while (node.parentNode) {\n      node = node.parentNode;\n      nodeName = node.nodeName;\n      if (IGNORE_URLS_IN.contains(nodeName)) {\n        return true;\n      } else if (nodeName === "body") {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  function _parseNode(element) {\n    if (IGNORE_URLS_IN.contains(element.nodeName)) {\n      return;\n    }\n\n    if (element.nodeType === wysihtml5.TEXT_NODE && element.data.match(URL_REG_EXP)) {\n      _wrapMatchesInNode(element);\n      return;\n    }\n\n    var childNodes = wysihtml5.lang.array(element.childNodes).get(),\n        childNodesLength = childNodes.length,\n        i = 0;\n\n    for (; i < childNodesLength; i++) {\n      _parseNode(childNodes[i]);\n    }\n\n    return element;\n  }\n\n  wysihtml5.dom.autoLink = autoLink;\n\n  // Reveal url reg exp to the outside\n  wysihtml5.dom.autoLink.URL_REG_EXP = URL_REG_EXP;\n})(wysihtml5);(function (wysihtml5) {\n  var supportsClassList = wysihtml5.browser.supportsClassList(),\n      api = wysihtml5.dom;\n\n  api.addClass = function (element, className) {\n    if (supportsClassList) {\n      return element.classList.add(className);\n    }\n    if (api.hasClass(element, className)) {\n      return;\n    }\n    element.className += " " + className;\n  };\n\n  api.removeClass = function (element, className) {\n    if (supportsClassList) {\n      return element.classList.remove(className);\n    }\n\n    element.className = element.className.replace(new RegExp("(^|\\\\s+)" + className + "(\\\\s+|$)"), " ");\n  };\n\n  api.hasClass = function (element, className) {\n    if (supportsClassList) {\n      return element.classList.contains(className);\n    }\n\n    var elementClassName = element.className;\n    return elementClassName.length > 0 && (elementClassName == className || new RegExp("(^|\\\\s)" + className + "(\\\\s|$)").test(elementClassName));\n  };\n})(wysihtml5);\nwysihtml5.dom.contains = function () {\n  var documentElement = document.documentElement;\n  if (documentElement.contains) {\n    return function (container, element) {\n      if (element.nodeType !== wysihtml5.ELEMENT_NODE) {\n        element = element.parentNode;\n      }\n      return container !== element && container.contains(element);\n    };\n  } else if (documentElement.compareDocumentPosition) {\n    return function (container, element) {\n      // https://developer.mozilla.org/en/DOM/Node.compareDocumentPosition\n      return !!(container.compareDocumentPosition(element) & 16);\n    };\n  }\n}(); /**\n     * Converts an HTML fragment/element into a unordered/ordered list\n     *\n     * @param {Element} element The element which should be turned into a list\n     * @param {String} listType The list type in which to convert the tree (either "ul" or "ol")\n     * @return {Element} The created list\n     *\n     * @example\n     *    \x3c!-- Assume the following dom: --\x3e\n     *    <span id="pseudo-list">\n     *      eminem<br>\n     *      dr. dre\n     *      <div>50 Cent</div>\n     *    </span>\n     *\n     *    <script>\n     *      wysihtml5.dom.convertToList(document.getElementById("pseudo-list"), "ul");\n     *    <\/script>\n     *\n     *    \x3c!-- Will result in: --\x3e\n     *    <ul>\n     *      <li>eminem</li>\n     *      <li>dr. dre</li>\n     *      <li>50 Cent</li>\n     *    </ul>\n     */\nwysihtml5.dom.convertToList = function () {\n  function _createListItem(doc, list) {\n    var listItem = doc.createElement("li");\n    list.appendChild(listItem);\n    return listItem;\n  }\n\n  function _createList(doc, type) {\n    return doc.createElement(type);\n  }\n\n  function convertToList(element, listType) {\n    if (element.nodeName === "UL" || element.nodeName === "OL" || element.nodeName === "MENU") {\n      // Already a list\n      return element;\n    }\n\n    var doc = element.ownerDocument,\n        list = _createList(doc, listType),\n        lineBreaks = element.querySelectorAll("br"),\n        lineBreaksLength = lineBreaks.length,\n        childNodes,\n        childNodesLength,\n        childNode,\n        lineBreak,\n        parentNode,\n        isBlockElement,\n        isLineBreak,\n        currentListItem,\n        i;\n\n    // First find <br> at the end of inline elements and move them behind them\n    for (i = 0; i < lineBreaksLength; i++) {\n      lineBreak = lineBreaks[i];\n      while ((parentNode = lineBreak.parentNode) && parentNode !== element && parentNode.lastChild === lineBreak) {\n        if (wysihtml5.dom.getStyle("display").from(parentNode) === "block") {\n          parentNode.removeChild(lineBreak);\n          break;\n        }\n        wysihtml5.dom.insert(lineBreak).after(lineBreak.parentNode);\n      }\n    }\n\n    childNodes = wysihtml5.lang.array(element.childNodes).get();\n    childNodesLength = childNodes.length;\n\n    for (i = 0; i < childNodesLength; i++) {\n      currentListItem = currentListItem || _createListItem(doc, list);\n      childNode = childNodes[i];\n      isBlockElement = wysihtml5.dom.getStyle("display").from(childNode) === "block";\n      isLineBreak = childNode.nodeName === "BR";\n\n      if (isBlockElement) {\n        // Append blockElement to current <li> if empty, otherwise create a new one\n        currentListItem = currentListItem.firstChild ? _createListItem(doc, list) : currentListItem;\n        currentListItem.appendChild(childNode);\n        currentListItem = null;\n        continue;\n      }\n\n      if (isLineBreak) {\n        // Only create a new list item in the next iteration when the current one has already content\n        currentListItem = currentListItem.firstChild ? null : currentListItem;\n        continue;\n      }\n\n      currentListItem.appendChild(childNode);\n    }\n\n    element.parentNode.replaceChild(list, element);\n    return list;\n  }\n\n  return convertToList;\n}(); /**\n     * Copy a set of attributes from one element to another\n     *\n     * @param {Array} attributesToCopy List of attributes which should be copied\n     * @return {Object} Returns an object which offers the "from" method which can be invoked with the element where to\n     *    copy the attributes from., this again returns an object which provides a method named "to" which can be invoked \n     *    with the element where to copy the attributes to (see example)\n     *\n     * @example\n     *    var textarea    = document.querySelector("textarea"),\n     *        div         = document.querySelector("div[contenteditable=true]"),\n     *        anotherDiv  = document.querySelector("div.preview");\n     *    wysihtml5.dom.copyAttributes(["spellcheck", "value", "placeholder"]).from(textarea).to(div).andTo(anotherDiv);\n     *\n     */\nwysihtml5.dom.copyAttributes = function (attributesToCopy) {\n  return {\n    from: function from(elementToCopyFrom) {\n      return {\n        to: function to(elementToCopyTo) {\n          var attribute,\n              i = 0,\n              length = attributesToCopy.length;\n          for (; i < length; i++) {\n            attribute = attributesToCopy[i];\n            if (typeof elementToCopyFrom[attribute] !== "undefined" && elementToCopyFrom[attribute] !== "") {\n              elementToCopyTo[attribute] = elementToCopyFrom[attribute];\n            }\n          }\n          return { andTo: arguments.callee };\n        }\n      };\n    }\n  };\n}; /**\n   * Copy a set of styles from one element to another\n   * Please note that this only works properly across browsers when the element from which to copy the styles\n   * is in the dom\n   *\n   * Interesting article on how to copy styles\n   *\n   * @param {Array} stylesToCopy List of styles which should be copied\n   * @return {Object} Returns an object which offers the "from" method which can be invoked with the element where to\n   *    copy the styles from., this again returns an object which provides a method named "to" which can be invoked \n   *    with the element where to copy the styles to (see example)\n   *\n   * @example\n   *    var textarea    = document.querySelector("textarea"),\n   *        div         = document.querySelector("div[contenteditable=true]"),\n   *        anotherDiv  = document.querySelector("div.preview");\n   *    wysihtml5.dom.copyStyles(["overflow-y", "width", "height"]).from(textarea).to(div).andTo(anotherDiv);\n   *\n   */\n(function (dom) {\n\n  /**\n   * Mozilla, WebKit and Opera recalculate the computed width when box-sizing: boder-box; is set\n   * So if an element has "width: 200px; -moz-box-sizing: border-box; border: 1px;" then \n   * its computed css width will be 198px\n   */\n  var BOX_SIZING_PROPERTIES = ["-webkit-box-sizing", "-moz-box-sizing", "-ms-box-sizing", "box-sizing"];\n\n  var shouldIgnoreBoxSizingBorderBox = function shouldIgnoreBoxSizingBorderBox(element) {\n    if (hasBoxSizingBorderBox(element)) {\n      return parseInt(dom.getStyle("width").from(element), 10) < element.offsetWidth;\n    }\n    return false;\n  };\n\n  var hasBoxSizingBorderBox = function hasBoxSizingBorderBox(element) {\n    var i = 0,\n        length = BOX_SIZING_PROPERTIES.length;\n    for (; i < length; i++) {\n      if (dom.getStyle(BOX_SIZING_PROPERTIES[i]).from(element) === "border-box") {\n        return BOX_SIZING_PROPERTIES[i];\n      }\n    }\n  };\n\n  dom.copyStyles = function (stylesToCopy) {\n    return {\n      from: function from(element) {\n        if (shouldIgnoreBoxSizingBorderBox(element)) {\n          stylesToCopy = wysihtml5.lang.array(stylesToCopy).without(BOX_SIZING_PROPERTIES);\n        }\n\n        var cssText = "",\n            length = stylesToCopy.length,\n            i = 0,\n            property;\n        for (; i < length; i++) {\n          property = stylesToCopy[i];\n          cssText += property + ":" + dom.getStyle(property).from(element) + ";";\n        }\n\n        return {\n          to: function to(element) {\n            var height_r = /\\;height\\:/;\n            if (cssText.match(height_r) && element) {\n              list = cssText.split(height_r);\n              height = parseInt(list[1], 10);\n              if (element.offsetHeight > height) {\n                cssText = list[0] + \'height:\' + element.offsetHeight + \'px;\';\n              }\n            }\n            dom.setStyles(cssText).on(element);\n            return { andTo: arguments.callee };\n          }\n        };\n      }\n    };\n  };\n})(wysihtml5.dom); /**\n                   * Event Delegation\n                   *\n                   * @example\n                   *    wysihtml5.dom.delegate(document.body, "a", "click", function() {\n                   *      // foo\n                   *    });\n                   */\n(function (wysihtml5) {\n\n  wysihtml5.dom.delegate = function (container, selector, eventName, handler) {\n    return wysihtml5.dom.observe(container, eventName, function (event) {\n      var target = event.target,\n          match = wysihtml5.lang.array(container.querySelectorAll(selector));\n\n      while (target && target !== container) {\n        if (match.contains(target)) {\n          handler.call(target, event);\n          break;\n        }\n        target = target.parentNode;\n      }\n    });\n  };\n})(wysihtml5); /**\n               * Returns the given html wrapped in a div element\n               *\n               * Fixing IE\'s inability to treat unknown elements (HTML5 section, article, ...) correctly\n               * when inserted via innerHTML\n               * \n               * @param {String} html The html which should be wrapped in a dom element\n               * @param {Obejct} [context] Document object of the context the html belongs to\n               *\n               * @example\n               *    wysihtml5.dom.getAsDom("<article>foo</article>");\n               */\nwysihtml5.dom.getAsDom = function () {\n\n  var _innerHTMLShiv = function _innerHTMLShiv(html, context) {\n    var tempElement = context.createElement("div");\n    tempElement.style.display = "none";\n    context.body.appendChild(tempElement);\n    // IE throws an exception when trying to insert <frameset></frameset> via innerHTML\n    try {\n      tempElement.innerHTML = html;\n    } catch (e) {}\n    context.body.removeChild(tempElement);\n    return tempElement;\n  };\n\n  /**\n   * Make sure IE supports HTML5 tags, which is accomplished by simply creating one instance of each element\n   */\n  var _ensureHTML5Compatibility = function _ensureHTML5Compatibility(context) {\n    if (context._wysihtml5_supportsHTML5Tags) {\n      return;\n    }\n    for (var i = 0, length = HTML5_ELEMENTS.length; i < length; i++) {\n      context.createElement(HTML5_ELEMENTS[i]);\n    }\n    context._wysihtml5_supportsHTML5Tags = true;\n  };\n\n  /**\n   * List of html5 tags\n   * taken from http://simon.html5.org/html5-elements\n   */\n  var HTML5_ELEMENTS = ["abbr", "article", "aside", "audio", "bdi", "canvas", "command", "datalist", "details", "figcaption", "figure", "footer", "header", "hgroup", "keygen", "mark", "meter", "nav", "output", "progress", "rp", "rt", "ruby", "svg", "section", "source", "summary", "time", "track", "video", "wbr"];\n\n  return function (html, context) {\n    context = context || document;\n    var tempElement;\n    if ((typeof html === "undefined" ? "undefined" : _typeof(html)) === "object" && html.nodeType) {\n      tempElement = context.createElement("div");\n      tempElement.appendChild(html);\n    } else if (wysihtml5.browser.supportsHTML5Tags(context)) {\n      tempElement = context.createElement("div");\n      tempElement.innerHTML = html;\n    } else {\n      _ensureHTML5Compatibility(context);\n      tempElement = _innerHTMLShiv(html, context);\n    }\n    return tempElement;\n  };\n}(); /**\n     * Walks the dom tree from the given node up until it finds a match\n     * Designed for optimal performance.\n     *\n     * @param {Element} node The from which to check the parent nodes\n     * @param {Object} matchingSet Object to match against (possible properties: nodeName, className, classRegExp)\n     * @param {Number} [levels] How many parents should the function check up from the current node (defaults to 50)\n     * @return {null|Element} Returns the first element that matched the desiredNodeName(s)\n     * @example\n     *    var listElement = wysihtml5.dom.getParentElement(document.querySelector("li"), { nodeName: ["MENU", "UL", "OL"] });\n     *    // ... or ...\n     *    var unorderedListElement = wysihtml5.dom.getParentElement(document.querySelector("li"), { nodeName: "UL" });\n     *    // ... or ...\n     *    var coloredElement = wysihtml5.dom.getParentElement(myTextNode, { nodeName: "SPAN", className: "wysiwyg-color-red", classRegExp: /wysiwyg-color-[a-z]/g });\n     */\nwysihtml5.dom.getParentElement = function () {\n\n  function _isSameNodeName(nodeName, desiredNodeNames) {\n    if (!desiredNodeNames || !desiredNodeNames.length) {\n      return true;\n    }\n\n    if (typeof desiredNodeNames === "string") {\n      return nodeName === desiredNodeNames;\n    } else {\n      return wysihtml5.lang.array(desiredNodeNames).contains(nodeName);\n    }\n  }\n\n  function _isElement(node) {\n    return node.nodeType === wysihtml5.ELEMENT_NODE;\n  }\n\n  function _hasClassName(element, className, classRegExp) {\n    var classNames = (element.className || "").match(classRegExp) || [];\n    if (!className) {\n      return !!classNames.length;\n    }\n    return classNames[classNames.length - 1] === className;\n  }\n\n  function _getParentElementWithNodeName(node, nodeName, levels) {\n    while (levels-- && node && node.nodeName !== "BODY") {\n      if (_isSameNodeName(node.nodeName, nodeName)) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n    return null;\n  }\n\n  function _getParentElementWithNodeNameAndClassName(node, nodeName, className, classRegExp, levels) {\n    while (levels-- && node && node.nodeName !== "BODY") {\n      if (_isElement(node) && _isSameNodeName(node.nodeName, nodeName) && _hasClassName(node, className, classRegExp)) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n    return null;\n  }\n\n  return function (node, matchingSet, levels) {\n    levels = levels || 50; // Go max 50 nodes upwards from current node\n    if (matchingSet.className || matchingSet.classRegExp) {\n      return _getParentElementWithNodeNameAndClassName(node, matchingSet.nodeName, matchingSet.className, matchingSet.classRegExp, levels);\n    } else {\n      return _getParentElementWithNodeName(node, matchingSet.nodeName, levels);\n    }\n  };\n}();\n/**\n * Get element\'s style for a specific css property\n *\n * @param {Element} element The element on which to retrieve the style\n * @param {String} property The CSS property to retrieve ("float", "display", "text-align", ...)\n *\n * @example\n *    wysihtml5.dom.getStyle("display").from(document.body);\n *    // => "block"\n */\nwysihtml5.dom.getStyle = function () {\n  var stylePropertyMapping = {\n    "float": "styleFloat" in document.createElement("div").style ? "styleFloat" : "cssFloat"\n  },\n      REG_EXP_CAMELIZE = /\\-[a-z]/g;\n\n  function camelize(str) {\n    return str.replace(REG_EXP_CAMELIZE, function (match) {\n      return match.charAt(1).toUpperCase();\n    });\n  }\n\n  return function (property) {\n    return {\n      from: function from(element) {\n        if (element.nodeType !== wysihtml5.ELEMENT_NODE) {\n          return;\n        }\n\n        var doc = element.ownerDocument,\n            camelizedProperty = stylePropertyMapping[property] || camelize(property),\n            style = element.style,\n            currentStyle = element.currentStyle,\n            styleValue = style[camelizedProperty];\n        if (styleValue) {\n          return styleValue;\n        }\n\n        // currentStyle is no standard and only supported by Opera and IE but it has one important advantage over the standard-compliant\n        // window.getComputedStyle, since it returns css property values in their original unit:\n        // If you set an elements width to "50%", window.getComputedStyle will give you it\'s current width in px while currentStyle\n        // gives you the original "50%".\n        // Opera supports both, currentStyle and window.getComputedStyle, that\'s why checking for currentStyle should have higher prio\n        if (currentStyle) {\n          try {\n            return currentStyle[camelizedProperty];\n          } catch (e) {\n            //ie will occasionally fail for unknown reasons. swallowing exception\n          }\n        }\n\n        var win = doc.defaultView || doc.parentWindow,\n            needsOverflowReset = (property === "height" || property === "width") && element.nodeName === "TEXTAREA",\n            originalOverflow,\n            returnValue;\n\n        if (win.getComputedStyle) {\n          // Chrome and Safari both calculate a wrong width and height for textareas when they have scroll bars\n          // therfore we remove and restore the scrollbar and calculate the value in between\n          if (needsOverflowReset) {\n            originalOverflow = style.overflow;\n            style.overflow = "hidden";\n          }\n          returnValue = win.getComputedStyle(element, null).getPropertyValue(property);\n          if (needsOverflowReset) {\n            style.overflow = originalOverflow || "";\n          }\n          return returnValue;\n        }\n      }\n    };\n  };\n}(); /**\n     * High performant way to check whether an element with a specific tag name is in the given document\n     * Optimized for being heavily executed\n     * Unleashes the power of live node lists\n     *\n     * @param {Object} doc The document object of the context where to check\n     * @param {String} tagName Upper cased tag name\n     * @example\n     *    wysihtml5.dom.hasElementWithTagName(document, "IMG");\n     */\nwysihtml5.dom.hasElementWithTagName = function () {\n  var LIVE_CACHE = {},\n      DOCUMENT_IDENTIFIER = 1;\n\n  function _getDocumentIdentifier(doc) {\n    return doc._wysihtml5_identifier || (doc._wysihtml5_identifier = DOCUMENT_IDENTIFIER++);\n  }\n\n  return function (doc, tagName) {\n    var key = _getDocumentIdentifier(doc) + ":" + tagName,\n        cacheEntry = LIVE_CACHE[key];\n    if (!cacheEntry) {\n      cacheEntry = LIVE_CACHE[key] = doc.getElementsByTagName(tagName);\n    }\n\n    return cacheEntry.length > 0;\n  };\n}(); /**\n     * High performant way to check whether an element with a specific class name is in the given document\n     * Optimized for being heavily executed\n     * Unleashes the power of live node lists\n     *\n     * @param {Object} doc The document object of the context where to check\n     * @param {String} tagName Upper cased tag name\n     * @example\n     *    wysihtml5.dom.hasElementWithClassName(document, "foobar");\n     */\n(function (wysihtml5) {\n  var LIVE_CACHE = {},\n      DOCUMENT_IDENTIFIER = 1;\n\n  function _getDocumentIdentifier(doc) {\n    return doc._wysihtml5_identifier || (doc._wysihtml5_identifier = DOCUMENT_IDENTIFIER++);\n  }\n\n  wysihtml5.dom.hasElementWithClassName = function (doc, className) {\n    // getElementsByClassName is not supported by IE<9\n    // but is sometimes mocked via library code (which then doesn\'t return live node lists)\n    if (!wysihtml5.browser.supportsNativeGetElementsByClassName()) {\n      return !!doc.querySelector("." + className);\n    }\n\n    var key = _getDocumentIdentifier(doc) + ":" + className,\n        cacheEntry = LIVE_CACHE[key];\n    if (!cacheEntry) {\n      cacheEntry = LIVE_CACHE[key] = doc.getElementsByClassName(className);\n    }\n\n    return cacheEntry.length > 0;\n  };\n})(wysihtml5);\nwysihtml5.dom.insert = function (elementToInsert) {\n  return {\n    after: function after(element) {\n      element.parentNode.insertBefore(elementToInsert, element.nextSibling);\n    },\n\n    before: function before(element) {\n      element.parentNode.insertBefore(elementToInsert, element);\n    },\n\n    into: function into(element) {\n      element.appendChild(elementToInsert);\n    }\n  };\n};wysihtml5.dom.insertCSS = function (rules) {\n  rules = rules.join("\\n");\n\n  return {\n    into: function into(doc) {\n      var head = doc.head || doc.getElementsByTagName("head")[0],\n          styleElement = doc.createElement("style");\n\n      styleElement.type = "text/css";\n\n      if (styleElement.styleSheet) {\n        styleElement.styleSheet.cssText = rules;\n      } else {\n        styleElement.appendChild(doc.createTextNode(rules));\n      }\n\n      if (head) {\n        head.appendChild(styleElement);\n      }\n    }\n  };\n}; /**\n   * Method to set dom events\n   *\n   * @example\n   *    wysihtml5.dom.observe(iframe.contentWindow.document.body, ["focus", "blur"], function() { ... });\n   */\nwysihtml5.dom.observe = function (element, eventNames, handler) {\n  eventNames = typeof eventNames === "string" ? [eventNames] : eventNames;\n\n  var handlerWrapper,\n      eventName,\n      i = 0,\n      length = eventNames.length;\n\n  for (; i < length; i++) {\n    eventName = eventNames[i];\n    if (element.addEventListener) {\n      element.addEventListener(eventName, handler, false);\n    } else {\n      handlerWrapper = function handlerWrapper(event) {\n        if (!("target" in event)) {\n          event.target = event.srcElement;\n        }\n        event.preventDefault = event.preventDefault || function () {\n          this.returnValue = false;\n        };\n        event.stopPropagation = event.stopPropagation || function () {\n          this.cancelBubble = true;\n        };\n        handler.call(element, event);\n      };\n      element.attachEvent("on" + eventName, handlerWrapper);\n    }\n  }\n\n  return {\n    stop: function stop() {\n      var eventName,\n          i = 0,\n          length = eventNames.length;\n      for (; i < length; i++) {\n        eventName = eventNames[i];\n        if (element.removeEventListener) {\n          element.removeEventListener(eventName, handler, false);\n        } else {\n          element.detachEvent("on" + eventName, handlerWrapper);\n        }\n      }\n    }\n  };\n};\n/**\n * HTML Sanitizer\n * Rewrites the HTML based on given rules\n *\n * @param {Element|String} elementOrHtml HTML String to be sanitized OR element whose content should be sanitized\n * @param {Object} [rules] List of rules for rewriting the HTML, if there\'s no rule for an element it will\n *    be converted to a "span". Each rule is a key/value pair where key is the tag to convert, and value the\n *    desired substitution.\n * @param {Object} context Document object in which to parse the html, needed to sandbox the parsing\n *\n * @return {Element|String} Depends on the elementOrHtml parameter. When html then the sanitized html as string elsewise the element.\n *\n * @example\n *    var userHTML = \'<div id="foo" onclick="alert(1);"><p><font color="red">foo</font><script>alert(1);<\/script></p></div>\';\n *    wysihtml5.dom.parse(userHTML, {\n *      tags {\n *        p:      "div",      // Rename p tags to div tags\n *        font:   "span"      // Rename font tags to span tags\n *        div:    true,       // Keep them, also possible (same result when passing: "div" or true)\n *        script: undefined   // Remove script elements\n *      }\n *    });\n *    // => <div><div><span>foo bar</span></div></div>\n *\n *    var userHTML = \'<table><tbody><tr><td>I\'m a table!</td></tr></tbody></table>\';\n *    wysihtml5.dom.parse(userHTML);\n *    // => \'<span><span><span><span>I\'m a table!</span></span></span></span>\'\n *\n *    var userHTML = \'<div>foobar<br>foobar</div>\';\n *    wysihtml5.dom.parse(userHTML, {\n *      tags: {\n *        div: undefined,\n *        br:  true\n *      }\n *    });\n *    // => \'\'\n *\n *    var userHTML = \'<div class="red">foo</div><div class="pink">bar</div>\';\n *    wysihtml5.dom.parse(userHTML, {\n *      classes: {\n *        red:    1,\n *        green:  1\n *      },\n *      tags: {\n *        div: {\n *          rename_tag:     "p"\n *        }\n *      }\n *    });\n *    // => \'<p class="red">foo</p><p>bar</p>\'\n */\nwysihtml5.dom.parse = function () {\n\n  /**\n   * It\'s not possible to use a XMLParser/DOMParser as HTML5 is not always well-formed XML\n   * new DOMParser().parseFromString(\'<img src="foo.gif">\') will cause a parseError since the\n   * node isn\'t closed\n   *\n   * Therefore we\'ve to use the browser\'s ordinary HTML parser invoked by setting innerHTML.\n   */\n  var NODE_TYPE_MAPPING = {\n    "1": _handleElement,\n    "3": _handleText\n  },\n\n\n  // Rename unknown tags to this\n  DEFAULT_NODE_NAME = "span",\n      WHITE_SPACE_REG_EXP = /\\s+/,\n      defaultRules = { tags: {}, classes: {} },\n      currentRules = {};\n\n  /**\n   * Iterates over all childs of the element, recreates them, appends them into a document fragment\n   * which later replaces the entire body content\n   */\n  function parse(elementOrHtml, rules, context, cleanUp) {\n    wysihtml5.lang.object(currentRules).merge(defaultRules).merge(rules).get();\n\n    context = context || elementOrHtml.ownerDocument || document;\n    var fragment = context.createDocumentFragment(),\n        isString = typeof elementOrHtml === "string",\n        element,\n        newNode,\n        firstChild;\n\n    if (isString) {\n      element = wysihtml5.dom.getAsDom(elementOrHtml, context);\n    } else {\n      element = elementOrHtml;\n    }\n\n    while (element.firstChild) {\n      firstChild = element.firstChild;\n      element.removeChild(firstChild);\n      newNode = _convert(firstChild, cleanUp);\n      if (newNode) {\n        fragment.appendChild(newNode);\n      }\n    }\n\n    // Clear element contents\n    element.innerHTML = "";\n\n    // Insert new DOM tree\n    element.appendChild(fragment);\n\n    return isString ? wysihtml5.quirks.getCorrectInnerHTML(element) : element;\n  }\n\n  function _convert(oldNode, cleanUp) {\n    var oldNodeType = oldNode.nodeType,\n        oldChilds = oldNode.childNodes,\n        oldChildsLength = oldChilds.length,\n        newNode,\n        method = NODE_TYPE_MAPPING[oldNodeType],\n        i = 0;\n\n    newNode = method && method(oldNode);\n\n    if (!newNode) {\n      return null;\n    }\n\n    for (i = 0; i < oldChildsLength; i++) {\n      newChild = _convert(oldChilds[i], cleanUp);\n      if (newChild) {\n        newNode.appendChild(newChild);\n      }\n    }\n\n    // Cleanup senseless <span> elements\n    if (cleanUp && newNode.childNodes.length <= 1 && newNode.nodeName.toLowerCase() === DEFAULT_NODE_NAME && !newNode.attributes.length) {\n      return newNode.firstChild;\n    }\n\n    return newNode;\n  }\n\n  function _handleElement(oldNode) {\n    var rule,\n        newNode,\n        endTag,\n        tagRules = currentRules.tags,\n        nodeName = oldNode.nodeName.toLowerCase(),\n        scopeName = oldNode.scopeName;\n\n    /**\n     * We already parsed that element\n     * ignore it! (yes, this sometimes happens in IE8 when the html is invalid)\n     */\n    if (oldNode._wysihtml5) {\n      return null;\n    }\n    oldNode._wysihtml5 = 1;\n\n    if (oldNode.className === "wysihtml5-temp") {\n      return null;\n    }\n\n    /**\n     * IE is the only browser who doesn\'t include the namespace in the\n     * nodeName, that\'s why we have to prepend it by ourselves\n     * scopeName is a proprietary IE feature\n     * read more here http://msdn.microsoft.com/en-us/library/ms534388(v=vs.85).aspx\n     */\n    if (scopeName && scopeName != "HTML") {\n      nodeName = scopeName + ":" + nodeName;\n    }\n\n    /**\n     * Repair node\n     * IE is a bit bitchy when it comes to invalid nested markup which includes unclosed tags\n     * A <p> doesn\'t need to be closed according HTML4-5 spec, we simply replace it with a <div> to preserve its content and layout\n     */\n    if ("outerHTML" in oldNode) {\n      if (!wysihtml5.browser.autoClosesUnclosedTags() && oldNode.nodeName === "P" && oldNode.outerHTML.slice(-4).toLowerCase() !== "</p>") {\n        nodeName = "div";\n      }\n    }\n\n    if (nodeName in tagRules) {\n      rule = tagRules[nodeName];\n      if (!rule || rule.remove) {\n        return null;\n      }\n\n      rule = typeof rule === "string" ? { rename_tag: rule } : rule;\n    } else if (oldNode.firstChild) {\n      rule = { rename_tag: DEFAULT_NODE_NAME };\n    } else {\n      // Remove empty unknown elements\n      return null;\n    }\n\n    newNode = oldNode.ownerDocument.createElement(rule.rename_tag || nodeName);\n    _handleAttributes(oldNode, newNode, rule);\n\n    oldNode = null;\n    return newNode;\n  }\n\n  function _handleAttributes(oldNode, newNode, rule) {\n    var attributes = {},\n\n    // fresh new set of attributes to set on newNode\n    setClass = rule.set_class,\n\n    // classes to set\n    addClass = rule.add_class,\n\n    // add classes based on existing attributes\n    setAttributes = rule.set_attributes,\n\n    // attributes to set on the current node\n    checkAttributes = rule.check_attributes,\n\n    // check/convert values of attributes\n    allowedClasses = currentRules.classes,\n        i = 0,\n        classes = [],\n        newClasses = [],\n        newUniqueClasses = [],\n        oldClasses = [],\n        classesLength,\n        newClassesLength,\n        currentClass,\n        newClass,\n        attributeName,\n        newAttributeValue,\n        method;\n\n    if (setAttributes) {\n      attributes = wysihtml5.lang.object(setAttributes).clone();\n    }\n\n    if (checkAttributes) {\n      for (attributeName in checkAttributes) {\n        method = attributeCheckMethods[checkAttributes[attributeName]];\n        if (!method) {\n          continue;\n        }\n        newAttributeValue = method(_getAttribute(oldNode, attributeName));\n        if (typeof newAttributeValue === "string") {\n          attributes[attributeName] = newAttributeValue;\n        }\n      }\n    }\n\n    if (setClass) {\n      classes.push(setClass);\n    }\n\n    if (addClass) {\n      for (attributeName in addClass) {\n        method = addClassMethods[addClass[attributeName]];\n        if (!method) {\n          continue;\n        }\n        newClass = method(_getAttribute(oldNode, attributeName));\n        if (typeof newClass === "string") {\n          classes.push(newClass);\n        }\n      }\n    }\n\n    // make sure that wysihtml5 temp class doesn\'t get stripped out\n    allowedClasses["_wysihtml5-temp-placeholder"] = 1;\n\n    // add old classes last\n    oldClasses = oldNode.getAttribute("class");\n    if (oldClasses) {\n      classes = classes.concat(oldClasses.split(WHITE_SPACE_REG_EXP));\n    }\n    classesLength = classes.length;\n    for (; i < classesLength; i++) {\n      currentClass = classes[i];\n      if (allowedClasses[currentClass]) {\n        newClasses.push(currentClass);\n      }\n    }\n\n    // remove duplicate entries and preserve class specificity\n    newClassesLength = newClasses.length;\n    while (newClassesLength--) {\n      currentClass = newClasses[newClassesLength];\n      if (!wysihtml5.lang.array(newUniqueClasses).contains(currentClass)) {\n        newUniqueClasses.unshift(currentClass);\n      }\n    }\n\n    if (newUniqueClasses.length) {\n      attributes["class"] = newUniqueClasses.join(" ");\n    }\n\n    // set attributes on newNode\n    for (attributeName in attributes) {\n      // Setting attributes can cause a js error in IE under certain circumstances\n      // eg. on a <img> under https when it\'s new attribute value is non-https\n      // TODO: Investigate this further and check for smarter handling\n      try {\n        newNode.setAttribute(attributeName, attributes[attributeName]);\n      } catch (e) {}\n    }\n\n    // IE8 sometimes loses the width/height attributes when those are set before the "src"\n    // so we make sure to set them again\n    if (attributes.src) {\n      if (typeof attributes.width !== "undefined") {\n        newNode.setAttribute("width", attributes.width);\n      }\n      if (typeof attributes.height !== "undefined") {\n        newNode.setAttribute("height", attributes.height);\n      }\n    }\n  }\n\n  /**\n   * IE gives wrong results for hasAttribute/getAttribute, for example:\n   *    var td = document.createElement("td");\n   *    td.getAttribute("rowspan"); // => "1" in IE\n   *\n   * Therefore we have to check the element\'s outerHTML for the attribute\n   */\n  var HAS_GET_ATTRIBUTE_BUG = !wysihtml5.browser.supportsGetAttributeCorrectly();\n  function _getAttribute(node, attributeName) {\n    attributeName = attributeName.toLowerCase();\n    var nodeName = node.nodeName;\n    if (nodeName == "IMG" && attributeName == "src" && _isLoadedImage(node) === true) {\n      // Get \'src\' attribute value via object property since this will always contain the\n      // full absolute url (http://...)\n      // this fixes a very annoying bug in firefox (ver 3.6 & 4) and IE 8 where images copied from the same host\n      // will have relative paths, which the sanitizer strips out (see attributeCheckMethods.url)\n      return node.src;\n    } else if (HAS_GET_ATTRIBUTE_BUG && "outerHTML" in node) {\n      // Don\'t trust getAttribute/hasAttribute in IE 6-8, instead check the element\'s outerHTML\n      var outerHTML = node.outerHTML.toLowerCase(),\n\n\n      // TODO: This might not work for attributes without value: <input disabled>\n      hasAttribute = outerHTML.indexOf(" " + attributeName + "=") != -1;\n\n      return hasAttribute ? node.getAttribute(attributeName) : null;\n    } else {\n      return node.getAttribute(attributeName);\n    }\n  }\n\n  /**\n   * Check whether the given node is a proper loaded image\n   * FIXME: Returns undefined when unknown (Chrome, Safari)\n   */\n  function _isLoadedImage(node) {\n    try {\n      return node.complete && !node.mozMatchesSelector(":-moz-broken");\n    } catch (e) {\n      if (node.complete && node.readyState === "complete") {\n        return true;\n      }\n    }\n  }\n\n  function _handleText(oldNode) {\n    return oldNode.ownerDocument.createTextNode(oldNode.data);\n  }\n\n  // ------------ attribute checks ------------ \\\\\n  var attributeCheckMethods = {\n    url: function () {\n      var REG_EXP = /^https?:\\/\\//i;\n      return function (attributeValue) {\n        if (!attributeValue || !attributeValue.match(REG_EXP)) {\n          return null;\n        }\n        return attributeValue.replace(REG_EXP, function (match) {\n          return match.toLowerCase();\n        });\n      };\n    }(),\n\n    alt: function () {\n      var REG_EXP = /[^ a-z0-9_\\-]/gi;\n      return function (attributeValue) {\n        if (!attributeValue) {\n          return "";\n        }\n        return attributeValue.replace(REG_EXP, "");\n      };\n    }(),\n\n    numbers: function () {\n      var REG_EXP = /\\D/g;\n      return function (attributeValue) {\n        attributeValue = (attributeValue || "").replace(REG_EXP, "");\n        return attributeValue || null;\n      };\n    }()\n  };\n\n  // ------------ class converter (converts an html attribute to a class name) ------------ \\\\\n  var addClassMethods = {\n    align_img: function () {\n      var mapping = {\n        left: "wysiwyg-float-left",\n        right: "wysiwyg-float-right"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).toLowerCase()];\n      };\n    }(),\n\n    align_text: function () {\n      var mapping = {\n        left: "wysiwyg-text-align-left",\n        right: "wysiwyg-text-align-right",\n        center: "wysiwyg-text-align-center",\n        justify: "wysiwyg-text-align-justify"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).toLowerCase()];\n      };\n    }(),\n\n    clear_br: function () {\n      var mapping = {\n        left: "wysiwyg-clear-left",\n        right: "wysiwyg-clear-right",\n        both: "wysiwyg-clear-both",\n        all: "wysiwyg-clear-both"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).toLowerCase()];\n      };\n    }(),\n\n    size_font: function () {\n      var mapping = {\n        "1": "wysiwyg-font-size-xx-small",\n        "2": "wysiwyg-font-size-small",\n        "3": "wysiwyg-font-size-medium",\n        "4": "wysiwyg-font-size-large",\n        "5": "wysiwyg-font-size-x-large",\n        "6": "wysiwyg-font-size-xx-large",\n        "7": "wysiwyg-font-size-xx-large",\n        "-": "wysiwyg-font-size-smaller",\n        "+": "wysiwyg-font-size-larger"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).charAt(0)];\n      };\n    }()\n  };\n\n  return parse;\n}(); /**\n     * Checks for empty text node childs and removes them\n     *\n     * @param {Element} node The element in which to cleanup\n     * @example\n     *    wysihtml5.dom.removeEmptyTextNodes(element);\n     */\nwysihtml5.dom.removeEmptyTextNodes = function (node) {\n  var childNode,\n      childNodes = wysihtml5.lang.array(node.childNodes).get(),\n      childNodesLength = childNodes.length,\n      i = 0;\n  for (; i < childNodesLength; i++) {\n    childNode = childNodes[i];\n    if (childNode.nodeType === wysihtml5.TEXT_NODE && childNode.data === "") {\n      childNode.parentNode.removeChild(childNode);\n    }\n  }\n};\n/**\n * Renames an element (eg. a <div> to a <p>) and keeps its childs\n *\n * @param {Element} element The list element which should be renamed\n * @param {Element} newNodeName The desired tag name\n *\n * @example\n *    \x3c!-- Assume the following dom: --\x3e\n *    <ul id="list">\n *      <li>eminem</li>\n *      <li>dr. dre</li>\n *      <li>50 Cent</li>\n *    </ul>\n *\n *    <script>\n *      wysihtml5.dom.renameElement(document.getElementById("list"), "ol");\n *    <\/script>\n *\n *    \x3c!-- Will result in: --\x3e\n *    <ol>\n *      <li>eminem</li>\n *      <li>dr. dre</li>\n *      <li>50 Cent</li>\n *    </ol>\n */\nwysihtml5.dom.renameElement = function (element, newNodeName) {\n  var newElement = element.ownerDocument.createElement(newNodeName),\n      firstChild;\n  while (firstChild = element.firstChild) {\n    newElement.appendChild(firstChild);\n  }\n  wysihtml5.dom.copyAttributes(["align", "className"]).from(element).to(newElement);\n  element.parentNode.replaceChild(newElement, element);\n  return newElement;\n}; /**\n   * Takes an element, removes it and replaces it with it\'s childs\n   * \n   * @param {Object} node The node which to replace with it\'s child nodes\n   * @example\n   *    <div id="foo">\n   *      <span>hello</span>\n   *    </div>\n   *    <script>\n   *      // Remove #foo and replace with it\'s children\n   *      wysihtml5.dom.replaceWithChildNodes(document.getElementById("foo"));\n   *    <\/script>\n   */\nwysihtml5.dom.replaceWithChildNodes = function (node) {\n  if (!node.parentNode) {\n    return;\n  }\n\n  if (!node.firstChild) {\n    node.parentNode.removeChild(node);\n    return;\n  }\n\n  var fragment = node.ownerDocument.createDocumentFragment();\n  while (node.firstChild) {\n    fragment.appendChild(node.firstChild);\n  }\n  node.parentNode.replaceChild(fragment, node);\n  node = fragment = null;\n};\n/**\n * Unwraps an unordered/ordered list\n *\n * @param {Element} element The list element which should be unwrapped\n *\n * @example\n *    \x3c!-- Assume the following dom: --\x3e\n *    <ul id="list">\n *      <li>eminem</li>\n *      <li>dr. dre</li>\n *      <li>50 Cent</li>\n *    </ul>\n *\n *    <script>\n *      wysihtml5.dom.resolveList(document.getElementById("list"));\n *    <\/script>\n *\n *    \x3c!-- Will result in: --\x3e\n *    eminem<br>\n *    dr. dre<br>\n *    50 Cent<br>\n */\n(function (dom) {\n  function _isBlockElement(node) {\n    return dom.getStyle("display").from(node) === "block";\n  }\n\n  function _isLineBreak(node) {\n    return node.nodeName === "BR";\n  }\n\n  function _appendLineBreak(element) {\n    var lineBreak = element.ownerDocument.createElement("br");\n    element.appendChild(lineBreak);\n  }\n\n  function resolveList(list) {\n    if (list.nodeName !== "MENU" && list.nodeName !== "UL" && list.nodeName !== "OL") {\n      return;\n    }\n\n    var doc = list.ownerDocument,\n        fragment = doc.createDocumentFragment(),\n        previousSibling = list.previousElementSibling || list.previousSibling,\n        firstChild,\n        lastChild,\n        isLastChild,\n        shouldAppendLineBreak,\n        listItem;\n\n    if (previousSibling && !_isBlockElement(previousSibling)) {\n      _appendLineBreak(fragment);\n    }\n\n    while (listItem = list.firstChild) {\n      lastChild = listItem.lastChild;\n      while (firstChild = listItem.firstChild) {\n        isLastChild = firstChild === lastChild;\n        // This needs to be done before appending it to the fragment, as it otherwise will loose style information\n        shouldAppendLineBreak = isLastChild && !_isBlockElement(firstChild) && !_isLineBreak(firstChild);\n        fragment.appendChild(firstChild);\n        if (shouldAppendLineBreak) {\n          _appendLineBreak(fragment);\n        }\n      }\n\n      listItem.parentNode.removeChild(listItem);\n    }\n    list.parentNode.replaceChild(fragment, list);\n  }\n\n  dom.resolveList = resolveList;\n})(wysihtml5.dom); /**\n                   * Sandbox for executing javascript, parsing css styles and doing dom operations in a secure way\n                   *\n                   * Browser Compatibility:\n                   *  - Secure in MSIE 6+, but only when the user hasn\'t made changes to his security level "restricted"\n                   *  - Partially secure in other browsers (Firefox, Opera, Safari, Chrome, ...)\n                   *\n                   * Please note that this class can\'t benefit from the HTML5 sandbox attribute for the following reasons:\n                   *    - sandboxing doesn\'t work correctly with inlined content (src="javascript:\'<html>...</html>\'")\n                   *    - sandboxing of physical documents causes that the dom isn\'t accessible anymore from the outside (iframe.contentWindow, ...)\n                   *    - setting the "allow-same-origin" flag would fix that, but then still javascript and dom events refuse to fire\n                   *    - therefore the "allow-scripts" flag is needed, which then would deactivate any security, as the js executed inside the iframe\n                   *      can do anything as if the sandbox attribute wasn\'t set\n                   *\n                   * @param {Function} [readyCallback] Method that gets invoked when the sandbox is ready\n                   * @param {Object} [config] Optional parameters\n                   *\n                   * @example\n                   *    new wysihtml5.dom.Sandbox(function(sandbox) {\n                   *      sandbox.getWindow().document.body.innerHTML = \'<img src=foo.gif onerror="alert(document.cookie)">\';\n                   *    });\n                   */\n(function (wysihtml5) {\n  var /**\n       * Default configuration\n       */\n  doc = document,\n\n\n  /**\n   * Properties to unset/protect on the window object\n   */\n  windowProperties = ["parent", "top", "opener", "frameElement", "frames", "localStorage", "globalStorage", "sessionStorage", "indexedDB"],\n\n\n  /**\n   * Properties on the window object which are set to an empty function\n   */\n  windowProperties2 = ["open", "close", "openDialog", "showModalDialog", "alert", "confirm", "prompt", "openDatabase", "postMessage", "XMLHttpRequest", "XDomainRequest"],\n\n\n  /**\n   * Properties to unset/protect on the document object\n   */\n  documentProperties = ["referrer", "write", "open", "close"];\n\n  wysihtml5.dom.Sandbox = Base.extend(\n  /** @scope wysihtml5.dom.Sandbox.prototype */{\n\n    constructor: function constructor(readyCallback, config) {\n      this.callback = readyCallback || wysihtml5.EMPTY_FUNCTION;\n      this.config = wysihtml5.lang.object({}).merge(config).get();\n      this.iframe = this._createIframe();\n    },\n\n    insertInto: function insertInto(element) {\n      if (typeof element === "string") {\n        element = doc.getElementById(element);\n      }\n\n      element.appendChild(this.iframe);\n    },\n\n    getIframe: function getIframe() {\n      return this.iframe;\n    },\n\n    getWindow: function getWindow() {\n      this._readyError();\n    },\n\n    getDocument: function getDocument() {\n      this._readyError();\n    },\n\n    destroy: function destroy() {\n      var iframe = this.getIframe();\n      iframe.parentNode.removeChild(iframe);\n    },\n\n    _readyError: function _readyError() {\n      throw new Error("wysihtml5.Sandbox: Sandbox iframe isn\'t loaded yet");\n    },\n\n    /**\n     * Creates the sandbox iframe\n     *\n     * Some important notes:\n     *  - We can\'t use HTML5 sandbox for now:\n     *    setting it causes that the iframe\'s dom can\'t be accessed from the outside\n     *    Therefore we need to set the "allow-same-origin" flag which enables accessing the iframe\'s dom\n     *    But then there\'s another problem, DOM events (focus, blur, change, keypress, ...) aren\'t fired.\n     *    In order to make this happen we need to set the "allow-scripts" flag.\n     *    A combination of allow-scripts and allow-same-origin is almost the same as setting no sandbox attribute at all.\n     *  - Chrome & Safari, doesn\'t seem to support sandboxing correctly when the iframe\'s html is inlined (no physical document)\n     *  - IE needs to have the security="restricted" attribute set before the iframe is \n     *    inserted into the dom tree\n     *  - Believe it or not but in IE "security" in document.createElement("iframe") is false, even\n     *    though it supports it\n     *  - When an iframe has security="restricted", in IE eval() & execScript() don\'t work anymore\n     *  - IE doesn\'t fire the onload event when the content is inlined in the src attribute, therefore we rely\n     *    on the onreadystatechange event\n     */\n    _createIframe: function _createIframe() {\n      var that = this,\n          iframe = doc.createElement("iframe");\n      iframe.className = "wysihtml5-sandbox";\n      wysihtml5.dom.setAttributes({\n        "security": "restricted",\n        "allowtransparency": "true",\n        "frameborder": 0,\n        "width": 0,\n        "height": 0,\n        "marginwidth": 0,\n        "marginheight": 0\n      }).on(iframe);\n\n      // Setting the src like this prevents ssl warnings in IE6\n      if (wysihtml5.browser.throwsMixedContentWarningWhenIframeSrcIsEmpty()) {\n        iframe.src = "javascript:\'<html></html>\'";\n      }\n\n      iframe.onload = function () {\n        iframe.onreadystatechange = iframe.onload = null;\n        that._onLoadIframe(iframe);\n      };\n\n      iframe.onreadystatechange = function () {\n        if (/loaded|complete/.test(iframe.readyState)) {\n          iframe.onreadystatechange = iframe.onload = null;\n          that._onLoadIframe(iframe);\n        }\n      };\n\n      return iframe;\n    },\n\n    /**\n     * Callback for when the iframe has finished loading\n     */\n    _onLoadIframe: function _onLoadIframe(iframe) {\n      // don\'t resume when the iframe got unloaded (eg. by removing it from the dom)\n      if (!wysihtml5.dom.contains(doc.documentElement, iframe)) {\n        return;\n      }\n\n      var that = this,\n          iframeWindow = iframe.contentWindow,\n          iframeDocument = iframe.contentWindow.document,\n          charset = doc.characterSet || doc.charset || "utf-8",\n          sandboxHtml = this._getHtml({\n        charset: charset,\n        stylesheets: this.config.stylesheets\n      });\n\n      // Create the basic dom tree including proper DOCTYPE and charset\n      iframeDocument.open("text/html", "replace");\n      iframeDocument.write(sandboxHtml);\n      iframeDocument.close();\n\n      this.getWindow = function () {\n        return iframe.contentWindow;\n      };\n      this.getDocument = function () {\n        return iframe.contentWindow.document;\n      };\n\n      // Catch js errors and pass them to the parent\'s onerror event\n      // addEventListener("error") doesn\'t work properly in some browsers\n      // TODO: apparently this doesn\'t work in IE9!\n      iframeWindow.onerror = function (errorMessage, fileName, lineNumber) {\n        throw new Error("wysihtml5.Sandbox: " + errorMessage, fileName, lineNumber);\n      };\n\n      if (!wysihtml5.browser.supportsSandboxedIframes()) {\n        // Unset a bunch of sensitive variables\n        // Please note: This isn\'t hack safe!  \n        // It more or less just takes care of basic attacks and prevents accidental theft of sensitive information\n        // IE is secure though, which is the most important thing, since IE is the only browser, who\n        // takes over scripts & styles into contentEditable elements when copied from external websites\n        // or applications (Microsoft Word, ...)\n        var i, length;\n        for (i = 0, length = windowProperties.length; i < length; i++) {\n          this._unset(iframeWindow, windowProperties[i]);\n        }\n        for (i = 0, length = windowProperties2.length; i < length; i++) {\n          this._unset(iframeWindow, windowProperties2[i], wysihtml5.EMPTY_FUNCTION);\n        }\n        for (i = 0, length = documentProperties.length; i < length; i++) {\n          this._unset(iframeDocument, documentProperties[i]);\n        }\n        // This doesn\'t work in Safari 5 \n        // See http://stackoverflow.com/questions/992461/is-it-possible-to-override-document-cookie-in-webkit\n        this._unset(iframeDocument, "cookie", "", true);\n      }\n\n      this.loaded = true;\n\n      // Trigger the callback\n      setTimeout(function () {\n        that.callback(that);\n      }, 0);\n    },\n\n    _getHtml: function _getHtml(templateVars) {\n      var stylesheets = templateVars.stylesheets,\n          html = "",\n          i = 0,\n          length;\n      stylesheets = typeof stylesheets === "string" ? [stylesheets] : stylesheets;\n      if (stylesheets) {\n        length = stylesheets.length;\n        for (; i < length; i++) {\n          html += \'<link rel="stylesheet" href="\' + stylesheets[i] + \'">\';\n        }\n      }\n      templateVars.stylesheets = html;\n\n      return wysihtml5.lang.string(\'<!DOCTYPE html><html><head>\' + \'<meta charset="#{charset}">#{stylesheets}</head>\' + \'<body></body></html>\').interpolate(templateVars);\n    },\n\n    /**\n     * Method to unset/override existing variables\n     * @example\n     *    // Make cookie unreadable and unwritable\n     *    this._unset(document, "cookie", "", true);\n     */\n    _unset: function _unset(object, property, value, setter) {\n      try {\n        object[property] = value;\n      } catch (e) {}\n\n      try {\n        object.__defineGetter__(property, function () {\n          return value;\n        });\n      } catch (e) {}\n      if (setter) {\n        try {\n          object.__defineSetter__(property, function () {});\n        } catch (e) {}\n      }\n\n      if (!wysihtml5.browser.crashesWhenDefineProperty(property)) {\n        try {\n          var config = {\n            get: function get() {\n              return value;\n            }\n          };\n          if (setter) {\n            config.set = function () {};\n          }\n          Object.defineProperty(object, property, config);\n        } catch (e) {}\n      }\n    }\n  });\n})(wysihtml5);\n(function () {\n  var mapping = {\n    "className": "class"\n  };\n  wysihtml5.dom.setAttributes = function (attributes) {\n    return {\n      on: function on(element) {\n        for (var i in attributes) {\n          element.setAttribute(mapping[i] || i, attributes[i]);\n        }\n      }\n    };\n  };\n})();wysihtml5.dom.setStyles = function (styles) {\n  return {\n    on: function on(element) {\n      var style = element.style;\n      if (typeof styles === "string") {\n        style.cssText += ";" + styles;\n        return;\n      }\n      for (var i in styles) {\n        if (i === "float") {\n          style.cssFloat = styles[i];\n          style.styleFloat = styles[i];\n        } else {\n          style[i] = styles[i];\n        }\n      }\n    }\n  };\n}; /**\n   * Simulate HTML5 placeholder attribute\n   *\n   * Needed since\n   *    - div[contentEditable] elements don\'t support it\n   *    - older browsers (such as IE8 and Firefox 3.6) don\'t support it at all\n   *\n   * @param {Object} parent Instance of main wysihtml5.Editor class\n   * @param {Element} view Instance of wysihtml5.views.* class\n   * @param {String} placeholderText\n   *\n   * @example\n   *    wysihtml.dom.simulatePlaceholder(this, composer, "Foobar");\n   */\n(function (dom) {\n  dom.simulatePlaceholder = function (editor, view, placeholderText) {\n    var CLASS_NAME = "placeholder",\n        unset = function unset() {\n      if (view.hasPlaceholderSet()) {\n        view.clear();\n      }\n      dom.removeClass(view.element, CLASS_NAME);\n    },\n        set = function set() {\n      if (view.isEmpty()) {\n        view.setValue(placeholderText);\n        dom.addClass(view.element, CLASS_NAME);\n      }\n    };\n\n    editor.observe("set_placeholder", set).observe("unset_placeholder", unset).observe("focus:composer", unset).observe("paste:composer", unset).observe("blur:composer", set);\n\n    set();\n  };\n})(wysihtml5.dom);\n(function (dom) {\n  var documentElement = document.documentElement;\n  if ("textContent" in documentElement) {\n    dom.setTextContent = function (element, text) {\n      element.textContent = text;\n    };\n\n    dom.getTextContent = function (element) {\n      return element.textContent;\n    };\n  } else if ("innerText" in documentElement) {\n    dom.setTextContent = function (element, text) {\n      element.innerText = text;\n    };\n\n    dom.getTextContent = function (element) {\n      return element.innerText;\n    };\n  } else {\n    dom.setTextContent = function (element, text) {\n      element.nodeValue = text;\n    };\n\n    dom.getTextContent = function (element) {\n      return element.nodeValue;\n    };\n  }\n})(wysihtml5.dom);\n\n/**\n * Fix most common html formatting misbehaviors of browsers implementation when inserting\n * content via copy & paste contentEditable\n *\n * @author Christopher Blum\n */\nwysihtml5.quirks.cleanPastedHTML = function () {\n  // TODO: We probably need more rules here\n  var defaultRules = {\n    // When pasting underlined links <a> into a contentEditable, IE thinks, it has to insert <u> to keep the styling\n    "a u": wysihtml5.dom.replaceWithChildNodes\n  };\n\n  function cleanPastedHTML(elementOrHtml, rules, context) {\n    rules = rules || defaultRules;\n    context = context || elementOrHtml.ownerDocument || document;\n\n    var element,\n        isString = typeof elementOrHtml === "string",\n        method,\n        matches,\n        matchesLength,\n        i,\n        j = 0;\n    if (isString) {\n      element = wysihtml5.dom.getAsDom(elementOrHtml, context);\n    } else {\n      element = elementOrHtml;\n    }\n    if (element.querySelectorAll) {\n      element.innerHTML = element.innerHTML.replace(/\\n/g, \'</br>\');\n      var els = element.querySelectorAll(\'style\');\n      for (var i = 0; i < els.length; i++) {\n        var el = els[i];\n        el.parentElement.removeChild(el);\n      }\n      var divs = element.querySelectorAll(\'div\');\n      for (var i = 0; i < divs.length; i++) {\n        var div = divs[i];\n        var new_div = document.createElement(\'p\');\n        new_div.innerText = div.innerText;\n        div.replaceWith(new_div);\n      }\n      var p_els = element.querySelectorAll(\'p\');\n      for (var i = 0; i < p_els.length; i++) {\n        var el = p_els[i];\n        if (!$.trim(el.innerText).length) {\n          el.parentElement.removeChild(el);\n        }\n      }\n      var br_els = element.querySelectorAll(\'br\');\n      var i = 0;\n      while (i < br_els.length - 1) {\n        var br = br_els[i];\n        while (br.nextSibling == br_els[i + 1]) {\n          var el = br_els[i + 1];\n          el.parentElement.removeChild(el);\n          i++;\n        }\n        i++;\n      }\n      for (var i = 0; i < br_els.length - 1; i++) {\n        br_els[i];\n      }\n    }\n\n    for (i in rules) {\n      matches = element.querySelectorAll(i);\n      method = rules[i];\n      matchesLength = matches.length;\n      for (; j < matchesLength; j++) {\n        method(matches[j]);\n      }\n    }\n\n    matches = elementOrHtml = rules = null;\n\n    return isString ? element.innerHTML : element;\n  }\n\n  return cleanPastedHTML;\n}(); /**\n     * IE and Opera leave an empty paragraph in the contentEditable element after clearing it\n     *\n     * @param {Object} contentEditableElement The contentEditable element to observe for clearing events\n     * @exaple\n     *    wysihtml5.quirks.ensureProperClearing(myContentEditableElement);\n     */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom;\n\n  wysihtml5.quirks.ensureProperClearing = function () {\n    var clearIfNecessary = function clearIfNecessary(event) {\n      var element = this;\n      setTimeout(function () {\n        var innerHTML = element.innerHTML.toLowerCase();\n        if (innerHTML == "<p>&nbsp;</p>" || innerHTML == "<p>&nbsp;</p><p>&nbsp;</p>") {\n          element.innerHTML = "";\n        }\n      }, 0);\n    };\n\n    return function (composer) {\n      dom.observe(composer.element, ["cut", "keydown"], clearIfNecessary);\n    };\n  }();\n\n  /**\n   * In Opera when the caret is in the first and only item of a list (<ul><li>|</li></ul>) and the list is the first child of the contentEditable element, it\'s impossible to delete the list by hitting backspace\n   *\n   * @param {Object} contentEditableElement The contentEditable element to observe for clearing events\n   * @exaple\n   *    wysihtml5.quirks.ensureProperClearing(myContentEditableElement);\n   */\n  wysihtml5.quirks.ensureProperClearingOfLists = function () {\n    var ELEMENTS_THAT_CONTAIN_LI = ["OL", "UL", "MENU"];\n\n    var clearIfNecessary = function clearIfNecessary(element, contentEditableElement) {\n      if (!contentEditableElement.firstChild || !wysihtml5.lang.array(ELEMENTS_THAT_CONTAIN_LI).contains(contentEditableElement.firstChild.nodeName)) {\n        return;\n      }\n\n      var list = dom.getParentElement(element, { nodeName: ELEMENTS_THAT_CONTAIN_LI });\n      if (!list) {\n        return;\n      }\n\n      var listIsFirstChildOfContentEditable = list == contentEditableElement.firstChild;\n      if (!listIsFirstChildOfContentEditable) {\n        return;\n      }\n\n      var hasOnlyOneListItem = list.childNodes.length <= 1;\n      if (!hasOnlyOneListItem) {\n        return;\n      }\n\n      var onlyListItemIsEmpty = list.firstChild ? list.firstChild.innerHTML === "" : true;\n      if (!onlyListItemIsEmpty) {\n        return;\n      }\n\n      list.parentNode.removeChild(list);\n    };\n\n    return function (composer) {\n      dom.observe(composer.element, "keydown", function (event) {\n        if (event.keyCode !== wysihtml5.BACKSPACE_KEY) {\n          return;\n        }\n\n        var element = composer.selection.getSelectedNode();\n        clearIfNecessary(element, composer.element);\n      });\n    };\n  }();\n})(wysihtml5);\n// See https://bugzilla.mozilla.org/show_bug.cgi?id=664398\n//\n// In Firefox this:\n//      var d = document.createElement("div");\n//      d.innerHTML =\'<a href="~"></a>\';\n//      d.innerHTML;\n// will result in:\n//      <a href="%7E"></a>\n// which is wrong\n(function (wysihtml5) {\n  var TILDE_ESCAPED = "%7E";\n  wysihtml5.quirks.getCorrectInnerHTML = function (element) {\n    var innerHTML = element.innerHTML;\n    if (innerHTML.indexOf(TILDE_ESCAPED) === -1) {\n      return innerHTML;\n    }\n\n    var elementsWithTilde = element.querySelectorAll("[href*=\'~\'], [src*=\'~\']"),\n        url,\n        urlToSearch,\n        length,\n        i;\n    for (i = 0, length = elementsWithTilde.length; i < length; i++) {\n      url = elementsWithTilde[i].href || elementsWithTilde[i].src;\n      urlToSearch = wysihtml5.lang.string(url).replace("~").by(TILDE_ESCAPED);\n      innerHTML = wysihtml5.lang.string(innerHTML).replace(urlToSearch).by(url);\n    }\n    return innerHTML;\n  };\n})(wysihtml5); /**\n               * Some browsers don\'t insert line breaks when hitting return in a contentEditable element\n               *    - Opera & IE insert new <p> on return\n               *    - Chrome & Safari insert new <div> on return\n               *    - Firefox inserts <br> on return (yippie!)\n               *\n               * @param {Element} element\n               *\n               * @example\n               *    wysihtml5.quirks.insertLineBreakOnReturn(element);\n               */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      USE_NATIVE_LINE_BREAK_WHEN_CARET_INSIDE_TAGS = ["LI", "P", "H1", "H2", "H3", "H4", "H5", "H6"],\n      LIST_TAGS = ["UL", "OL", "MENU"];\n\n  wysihtml5.quirks.insertLineBreakOnReturn = function (composer) {\n    function unwrap(selectedNode) {\n      var parentElement = dom.getParentElement(selectedNode, { nodeName: ["P", "DIV"] }, 2);\n      if (!parentElement) {\n        return;\n      }\n\n      var invisibleSpace = document.createTextNode(wysihtml5.INVISIBLE_SPACE);\n      dom.insert(invisibleSpace).before(parentElement);\n      dom.replaceWithChildNodes(parentElement);\n      composer.selection.selectNode(invisibleSpace);\n    }\n\n    function keyDown(event) {\n      var keyCode = event.keyCode;\n      if (event.shiftKey || keyCode !== wysihtml5.ENTER_KEY && keyCode !== wysihtml5.BACKSPACE_KEY) {\n        return;\n      }\n\n      var element = event.target,\n          selectedNode = composer.selection.getSelectedNode(),\n          blockElement = dom.getParentElement(selectedNode, { nodeName: USE_NATIVE_LINE_BREAK_WHEN_CARET_INSIDE_TAGS }, 4);\n      if (blockElement) {\n        // Some browsers create <p> elements after leaving a list\n        // check after keydown of backspace and return whether a <p> got inserted and unwrap it\n        if (blockElement.nodeName === "LI" && (keyCode === wysihtml5.ENTER_KEY || keyCode === wysihtml5.BACKSPACE_KEY)) {\n          setTimeout(function () {\n            var selectedNode = composer.selection.getSelectedNode(),\n                list,\n                div;\n            if (!selectedNode) {\n              return;\n            }\n\n            list = dom.getParentElement(selectedNode, {\n              nodeName: LIST_TAGS\n            }, 2);\n\n            if (list) {\n              return;\n            }\n\n            unwrap(selectedNode);\n          }, 0);\n        } else if (blockElement.nodeName.match(/H[1-6]/) && keyCode === wysihtml5.ENTER_KEY) {\n          setTimeout(function () {\n            unwrap(composer.selection.getSelectedNode());\n          }, 0);\n        }\n        return;\n      }\n\n      if (keyCode === wysihtml5.ENTER_KEY && !wysihtml5.browser.insertsLineBreaksOnReturn()) {\n        composer.commands.exec("insertLineBreak");\n        event.preventDefault();\n      }\n    }\n\n    // keypress doesn\'t fire when you hit backspace\n    dom.observe(composer.element.ownerDocument, "keydown", keyDown);\n  };\n})(wysihtml5); /**\n               * Force rerendering of a given element\n               * Needed to fix display misbehaviors of IE\n               *\n               * @param {Element} element The element object which needs to be rerendered\n               * @example\n               *    wysihtml5.quirks.redraw(document.body);\n               */\n(function (wysihtml5) {\n  var CLASS_NAME = "wysihtml5-quirks-redraw";\n\n  wysihtml5.quirks.redraw = function (element) {\n    wysihtml5.dom.addClass(element, CLASS_NAME);\n    wysihtml5.dom.removeClass(element, CLASS_NAME);\n\n    // Following hack is needed for firefox to make sure that image resize handles are properly removed\n    try {\n      var doc = element.ownerDocument;\n      doc.execCommand("italic", false, null);\n      doc.execCommand("italic", false, null);\n    } catch (e) {}\n  };\n})(wysihtml5); /**\n               * Selection API\n               *\n               * @example\n               *    var selection = new wysihtml5.Selection(editor);\n               */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom;\n\n  function _getCumulativeOffsetTop(element) {\n    var top = 0;\n    if (element.parentNode) {\n      do {\n        top += element.offsetTop || 0;\n        element = element.offsetParent;\n      } while (element);\n    }\n    return top;\n  }\n\n  wysihtml5.Selection = Base.extend(\n  /** @scope wysihtml5.Selection.prototype */{\n    constructor: function constructor(editor) {\n      // Make sure that our external range library is initialized\n      window.rangy.init();\n\n      this.editor = editor;\n      this.composer = editor.composer;\n      this.doc = this.composer.doc;\n    },\n\n    /**\n     * Get the current selection as a bookmark to be able to later restore it\n     *\n     * @return {Object} An object that represents the current selection\n     */\n    getBookmark: function getBookmark() {\n      var range = this.getRange();\n      return range && range.cloneRange();\n    },\n\n    /**\n     * Restore a selection retrieved via wysihtml5.Selection.prototype.getBookmark\n     *\n     * @param {Object} bookmark An object that represents the current selection\n     */\n    setBookmark: function setBookmark(bookmark) {\n      if (!bookmark) {\n        return;\n      }\n\n      this.setSelection(bookmark);\n    },\n\n    /**\n     * Set the caret in front of the given node\n     *\n     * @param {Object} node The element or text node where to position the caret in front of\n     * @example\n     *    selection.setBefore(myElement);\n     */\n    setBefore: function setBefore(node) {\n      var range = rangy.createRange(this.doc);\n      range.setStartBefore(node);\n      range.setEndBefore(node);\n      return this.setSelection(range);\n    },\n\n    /**\n     * Set the caret after the given node\n     *\n     * @param {Object} node The element or text node where to position the caret in front of\n     * @example\n     *    selection.setBefore(myElement);\n     */\n    setAfter: function setAfter(node) {\n      var range = rangy.createRange(this.doc);\n      range.setStartAfter(node);\n      range.setEndAfter(node);\n      return this.setSelection(range);\n    },\n\n    /**\n     * Ability to select/mark nodes\n     *\n     * @param {Element} node The node/element to select\n     * @example\n     *    selection.selectNode(document.getElementById("my-image"));\n     */\n    selectNode: function selectNode(node) {\n      var range = rangy.createRange(this.doc),\n          isElement = node.nodeType === wysihtml5.ELEMENT_NODE,\n          canHaveHTML = "canHaveHTML" in node ? node.canHaveHTML : node.nodeName !== "IMG",\n          content = isElement ? node.innerHTML : node.data,\n          isEmpty = content === "" || content === wysihtml5.INVISIBLE_SPACE,\n          displayStyle = dom.getStyle("display").from(node),\n          isBlockElement = displayStyle === "block" || displayStyle === "list-item";\n\n      if (isEmpty && isElement && canHaveHTML) {\n        // Make sure that caret is visible in node by inserting a zero width no breaking space\n        try {\n          node.innerHTML = wysihtml5.INVISIBLE_SPACE;\n        } catch (e) {}\n      }\n\n      if (canHaveHTML) {\n        range.selectNodeContents(node);\n      } else {\n        range.selectNode(node);\n      }\n\n      if (canHaveHTML && isEmpty && isElement) {\n        range.collapse(isBlockElement);\n      } else if (canHaveHTML && isEmpty) {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n\n      this.setSelection(range);\n    },\n\n    /**\n     * Get the node which contains the selection\n     *\n     * @param {Boolean} [controlRange] (only IE) Whether it should return the selected ControlRange element when the selection type is a "ControlRange"\n     * @return {Object} The node that contains the caret\n     * @example\n     *    var nodeThatContainsCaret = selection.getSelectedNode();\n     */\n    getSelectedNode: function getSelectedNode(controlRange) {\n      var selection, range;\n\n      if (controlRange && this.doc.selection && this.doc.selection.type === "Control") {\n        range = this.doc.selection.createRange();\n        if (range && range.length) {\n          return range.item(0);\n        }\n      }\n\n      selection = this.getSelection(this.doc);\n      if (selection.focusNode === selection.anchorNode) {\n        return selection.focusNode;\n      } else {\n        range = this.getRange(this.doc);\n        return range ? range.commonAncestorContainer : this.doc.body;\n      }\n    },\n\n    executeAndRestore: function executeAndRestore(method, restoreScrollPosition) {\n      var body = this.doc.body,\n          oldScrollTop = restoreScrollPosition && body.scrollTop,\n          oldScrollLeft = restoreScrollPosition && body.scrollLeft,\n          className = "_wysihtml5-temp-placeholder",\n          placeholderHTML = \'<span class="\' + className + \'">\' + wysihtml5.INVISIBLE_SPACE + \'</span>\',\n          range = this.getRange(this.doc),\n          newRange;\n\n      // Nothing selected, execute and say goodbye\n      if (!range) {\n        method(body, body);\n        return;\n      }\n\n      var node = range.createContextualFragment(placeholderHTML);\n      range.insertNode(node);\n\n      // Make sure that a potential error doesn\'t cause our placeholder element to be left as a placeholder\n      try {\n        method(range.startContainer, range.endContainer);\n      } catch (e3) {\n        setTimeout(function () {\n          throw e3;\n        }, 0);\n      }\n\n      caretPlaceholder = this.doc.querySelector("." + className);\n      if (caretPlaceholder) {\n        newRange = rangy.createRange(this.doc);\n        newRange.selectNode(caretPlaceholder);\n        newRange.deleteContents();\n        this.setSelection(newRange);\n      } else {\n        // fallback for when all hell breaks loose\n        body.focus();\n      }\n\n      if (restoreScrollPosition) {\n        body.scrollTop = oldScrollTop;\n        body.scrollLeft = oldScrollLeft;\n      }\n\n      // Remove it again, just to make sure that the placeholder is definitely out of the dom tree\n      try {\n        caretPlaceholder.parentNode.removeChild(caretPlaceholder);\n      } catch (e4) {}\n    },\n\n    /**\n     * Different approach of preserving the selection (doesn\'t modify the dom)\n     * Takes all text nodes in the selection and saves the selection position in the first and last one\n     */\n    executeAndRestoreSimple: function executeAndRestoreSimple(method) {\n      var range = this.getRange(),\n          body = this.doc.body,\n          newRange,\n          firstNode,\n          lastNode,\n          textNodes,\n          rangeBackup;\n\n      // Nothing selected, execute and say goodbye\n      if (!range) {\n        method(body, body);\n        return;\n      }\n\n      textNodes = range.getNodes([3]);\n      firstNode = textNodes[0] || range.startContainer;\n      lastNode = textNodes[textNodes.length - 1] || range.endContainer;\n\n      rangeBackup = {\n        collapsed: range.collapsed,\n        startContainer: firstNode,\n        startOffset: firstNode === range.startContainer ? range.startOffset : 0,\n        endContainer: lastNode,\n        endOffset: lastNode === range.endContainer ? range.endOffset : lastNode.length\n      };\n\n      try {\n        method(range.startContainer, range.endContainer);\n      } catch (e) {\n        setTimeout(function () {\n          throw e;\n        }, 0);\n      }\n\n      newRange = rangy.createRange(this.doc);\n      try {\n        newRange.setStart(rangeBackup.startContainer, rangeBackup.startOffset);\n      } catch (e1) {}\n      try {\n        newRange.setEnd(rangeBackup.endContainer, rangeBackup.endOffset);\n      } catch (e2) {}\n      try {\n        this.setSelection(newRange);\n      } catch (e3) {}\n    },\n\n    /**\n     * Insert html at the caret position and move the cursor after the inserted html\n     *\n     * @param {String} html HTML string to insert\n     * @example\n     *    selection.insertHTML("<p>foobar</p>");\n     */\n    insertHTML: function insertHTML(html) {\n      var range = rangy.createRange(this.doc),\n          node = range.createContextualFragment(html),\n          lastChild = node.lastChild;\n      this.insertNode(node);\n      if (lastChild) {\n        this.setAfter(lastChild);\n      }\n    },\n\n    /**\n     * Insert a node at the caret position and move the cursor behind it\n     *\n     * @param {Object} node HTML string to insert\n     * @example\n     *    selection.insertNode(document.createTextNode("foobar"));\n     */\n    insertNode: function insertNode(node) {\n      var range = this.getRange();\n      if (range) {\n        range.insertNode(node);\n      }\n    },\n\n    /**\n     * Wraps current selection with the given node\n     *\n     * @param {Object} node The node to surround the selected elements with\n     */\n    surround: function surround(node) {\n      var range = this.getRange();\n      if (!range) {\n        return;\n      }\n\n      try {\n        // This only works when the range boundaries are not overlapping other elements\n        range.surroundContents(node);\n        this.selectNode(node);\n      } catch (e) {\n        // fallback\n        node.appendChild(range.extractContents());\n        range.insertNode(node);\n      }\n    },\n\n    /**\n     * Scroll the current caret position into the view\n     * FIXME: This is a bit hacky, there might be a smarter way of doing this\n     *\n     * @example\n     *    selection.scrollIntoView();\n     */\n    scrollIntoView: function scrollIntoView() {\n      var doc = this.doc,\n          hasScrollBars = doc.documentElement.scrollHeight > doc.documentElement.offsetHeight,\n          tempElement = doc._wysihtml5ScrollIntoViewElement = doc._wysihtml5ScrollIntoViewElement || function () {\n        var element = doc.createElement("span");\n        // The element needs content in order to be able to calculate it\'s position properly\n        element.innerHTML = wysihtml5.INVISIBLE_SPACE;\n        return element;\n      }(),\n          offsetTop;\n\n      if (hasScrollBars) {\n        this.insertNode(tempElement);\n        offsetTop = _getCumulativeOffsetTop(tempElement);\n        tempElement.parentNode.removeChild(tempElement);\n        if (offsetTop > doc.body.scrollTop) {\n          doc.body.scrollTop = offsetTop;\n        }\n      }\n    },\n\n    /**\n     * Select line where the caret is in\n     */\n    selectLine: function selectLine() {\n      if (wysihtml5.browser.supportsSelectionModify()) {\n        this._selectLine_W3C();\n      } else if (this.doc.selection) {\n        this._selectLine_MSIE();\n      }\n    },\n\n    /**\n     * See https://developer.mozilla.org/en/DOM/Selection/modify\n     */\n    _selectLine_W3C: function _selectLine_W3C() {\n      var win = this.doc.defaultView,\n          selection = win.getSelection();\n      selection.modify("extend", "left", "lineboundary");\n      selection.modify("extend", "right", "lineboundary");\n    },\n\n    _selectLine_MSIE: function _selectLine_MSIE() {\n      var range = this.doc.selection.createRange(),\n          rangeTop = range.boundingTop,\n          rangeHeight = range.boundingHeight,\n          scrollWidth = this.doc.body.scrollWidth,\n          rangeBottom,\n          rangeEnd,\n          measureNode,\n          i,\n          j;\n\n      if (!range.moveToPoint) {\n        return;\n      }\n\n      if (rangeTop === 0) {\n        // Don\'t know why, but when the selection ends at the end of a line\n        // range.boundingTop is 0\n        measureNode = this.doc.createElement("span");\n        this.insertNode(measureNode);\n        rangeTop = measureNode.offsetTop;\n        measureNode.parentNode.removeChild(measureNode);\n      }\n\n      rangeTop += 1;\n\n      for (i = -10; i < scrollWidth; i += 2) {\n        try {\n          range.moveToPoint(i, rangeTop);\n          break;\n        } catch (e1) {}\n      }\n\n      // Investigate the following in order to handle multi line selections\n      // rangeBottom = rangeTop + (rangeHeight ? (rangeHeight - 1) : 0);\n      rangeBottom = rangeTop;\n      rangeEnd = this.doc.selection.createRange();\n      for (j = scrollWidth; j >= 0; j--) {\n        try {\n          rangeEnd.moveToPoint(j, rangeBottom);\n          break;\n        } catch (e2) {}\n      }\n\n      range.setEndPoint("EndToEnd", rangeEnd);\n      range.select();\n    },\n\n    getText: function getText() {\n      var selection = this.getSelection();\n      return selection ? selection.toString() : "";\n    },\n\n    getNodes: function getNodes(nodeType, filter) {\n      var range = this.getRange();\n      if (range) {\n        return range.getNodes([nodeType], filter);\n      } else {\n        return [];\n      }\n    },\n\n    getRange: function getRange() {\n      var selection = this.getSelection();\n      return selection && selection.rangeCount && selection.getRangeAt(0);\n    },\n\n    getSelection: function getSelection() {\n      return rangy.getSelection(this.doc.defaultView || this.doc.parentWindow);\n    },\n\n    setSelection: function setSelection(range) {\n      var win = this.doc.defaultView || this.doc.parentWindow,\n          selection = rangy.getSelection(win);\n      return selection.setSingleRange(range);\n    }\n  });\n})(wysihtml5);\n/**\n * Inspired by the rangy CSS Applier module written by Tim Down and licensed under the MIT license.\n * http://code.google.com/p/rangy/\n *\n * changed in order to be able ...\n *    - to use custom tags\n *    - to detect and replace similar css classes via reg exp\n */\n(function (wysihtml5, rangy) {\n  var defaultTagName = "span";\n\n  var REG_EXP_WHITE_SPACE = /\\s+/g;\n\n  function hasClass(el, cssClass, regExp) {\n    if (!el.className) {\n      return false;\n    }\n\n    var matchingClassNames = el.className.match(regExp) || [];\n    return matchingClassNames[matchingClassNames.length - 1] === cssClass;\n  }\n\n  function addClass(el, cssClass, regExp) {\n    if (el.className) {\n      removeClass(el, regExp);\n      el.className += " " + cssClass;\n    } else {\n      el.className = cssClass;\n    }\n  }\n\n  function removeClass(el, regExp) {\n    if (el.className) {\n      el.className = el.className.replace(regExp, "");\n    }\n  }\n\n  function hasSameClasses(el1, el2) {\n    return el1.className.replace(REG_EXP_WHITE_SPACE, " ") == el2.className.replace(REG_EXP_WHITE_SPACE, " ");\n  }\n\n  function replaceWithOwnChildren(el) {\n    var parent = el.parentNode;\n    while (el.firstChild) {\n      parent.insertBefore(el.firstChild, el);\n    }\n    parent.removeChild(el);\n  }\n\n  function elementsHaveSameNonClassAttributes(el1, el2) {\n    if (el1.attributes.length != el2.attributes.length) {\n      return false;\n    }\n    for (var i = 0, len = el1.attributes.length, attr1, attr2, name; i < len; ++i) {\n      attr1 = el1.attributes[i];\n      name = attr1.name;\n      if (name != "class") {\n        attr2 = el2.attributes.getNamedItem(name);\n        if (attr1.specified != attr2.specified) {\n          return false;\n        }\n        if (attr1.specified && attr1.nodeValue !== attr2.nodeValue) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  function isSplitPoint(node, offset) {\n    if (rangy.dom.isCharacterDataNode(node)) {\n      if (offset == 0) {\n        return !!node.previousSibling;\n      } else if (offset == node.length) {\n        return !!node.nextSibling;\n      } else {\n        return true;\n      }\n    }\n\n    return offset > 0 && offset < node.childNodes.length;\n  }\n\n  function splitNodeAt(node, descendantNode, descendantOffset) {\n    var newNode;\n    if (rangy.dom.isCharacterDataNode(descendantNode)) {\n      if (descendantOffset == 0) {\n        descendantOffset = rangy.dom.getNodeIndex(descendantNode);\n        descendantNode = descendantNode.parentNode;\n      } else if (descendantOffset == descendantNode.length) {\n        descendantOffset = rangy.dom.getNodeIndex(descendantNode) + 1;\n        descendantNode = descendantNode.parentNode;\n      } else {\n        newNode = rangy.dom.splitDataNode(descendantNode, descendantOffset);\n      }\n    }\n    if (!newNode) {\n      newNode = descendantNode.cloneNode(false);\n      if (newNode.id) {\n        newNode.removeAttribute("id");\n      }\n      var child;\n      while (child = descendantNode.childNodes[descendantOffset]) {\n        newNode.appendChild(child);\n      }\n      rangy.dom.insertAfter(newNode, descendantNode);\n    }\n    return descendantNode == node ? newNode : splitNodeAt(node, newNode.parentNode, rangy.dom.getNodeIndex(newNode));\n  }\n\n  function Merge(firstNode) {\n    this.isElementMerge = firstNode.nodeType == wysihtml5.ELEMENT_NODE;\n    this.firstTextNode = this.isElementMerge ? firstNode.lastChild : firstNode;\n    this.textNodes = [this.firstTextNode];\n  }\n\n  Merge.prototype = {\n    doMerge: function doMerge() {\n      var textBits = [],\n          textNode,\n          parent,\n          text;\n      for (var i = 0, len = this.textNodes.length; i < len; ++i) {\n        textNode = this.textNodes[i];\n        parent = textNode.parentNode;\n        textBits[i] = textNode.data;\n        if (i) {\n          parent.removeChild(textNode);\n          if (!parent.hasChildNodes()) {\n            parent.parentNode.removeChild(parent);\n          }\n        }\n      }\n      this.firstTextNode.data = text = textBits.join("");\n      return text;\n    },\n\n    getLength: function getLength() {\n      var i = this.textNodes.length,\n          len = 0;\n      while (i--) {\n        len += this.textNodes[i].length;\n      }\n      return len;\n    },\n\n    toString: function toString() {\n      var textBits = [];\n      for (var i = 0, len = this.textNodes.length; i < len; ++i) {\n        textBits[i] = "\'" + this.textNodes[i].data + "\'";\n      }\n      return "[Merge(" + textBits.join(",") + ")]";\n    }\n  };\n\n  function HTMLApplier(tagNames, cssClass, similarClassRegExp, normalize) {\n    this.tagNames = tagNames || [defaultTagName];\n    this.cssClass = cssClass || "";\n    this.similarClassRegExp = similarClassRegExp;\n    this.normalize = normalize;\n    this.applyToAnyTagName = false;\n  }\n\n  HTMLApplier.prototype = {\n    getAncestorWithClass: function getAncestorWithClass(node) {\n      var cssClassMatch;\n      while (node) {\n        cssClassMatch = this.cssClass ? hasClass(node, this.cssClass, this.similarClassRegExp) : true;\n        if (node.nodeType == wysihtml5.ELEMENT_NODE && rangy.dom.arrayContains(this.tagNames, node.tagName.toLowerCase()) && cssClassMatch) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return false;\n    },\n\n    // Normalizes nodes after applying a CSS class to a Range.\n    postApply: function postApply(textNodes, range) {\n      var firstNode = textNodes[0],\n          lastNode = textNodes[textNodes.length - 1];\n\n      var merges = [],\n          currentMerge;\n\n      var rangeStartNode = firstNode,\n          rangeEndNode = lastNode;\n      var rangeStartOffset = 0,\n          rangeEndOffset = lastNode.length;\n\n      var textNode, precedingTextNode;\n\n      for (var i = 0, len = textNodes.length; i < len; ++i) {\n        textNode = textNodes[i];\n        precedingTextNode = this.getAdjacentMergeableTextNode(textNode.parentNode, false);\n        if (precedingTextNode) {\n          if (!currentMerge) {\n            currentMerge = new Merge(precedingTextNode);\n            merges.push(currentMerge);\n          }\n          currentMerge.textNodes.push(textNode);\n          if (textNode === firstNode) {\n            rangeStartNode = currentMerge.firstTextNode;\n            rangeStartOffset = rangeStartNode.length;\n          }\n          if (textNode === lastNode) {\n            rangeEndNode = currentMerge.firstTextNode;\n            rangeEndOffset = currentMerge.getLength();\n          }\n        } else {\n          currentMerge = null;\n        }\n      }\n\n      // Test whether the first node after the range needs merging\n      var nextTextNode = this.getAdjacentMergeableTextNode(lastNode.parentNode, true);\n      if (nextTextNode) {\n        if (!currentMerge) {\n          currentMerge = new Merge(lastNode);\n          merges.push(currentMerge);\n        }\n        currentMerge.textNodes.push(nextTextNode);\n      }\n\n      // Do the merges\n      if (merges.length) {\n        for (i = 0, len = merges.length; i < len; ++i) {\n          merges[i].doMerge();\n        }\n        // Set the range boundaries\n        range.setStart(rangeStartNode, rangeStartOffset);\n        range.setEnd(rangeEndNode, rangeEndOffset);\n      }\n    },\n\n    getAdjacentMergeableTextNode: function getAdjacentMergeableTextNode(node, forward) {\n      var isTextNode = node.nodeType == wysihtml5.TEXT_NODE;\n      var el = isTextNode ? node.parentNode : node;\n      var adjacentNode;\n      var propName = forward ? "nextSibling" : "previousSibling";\n      if (isTextNode) {\n        // Can merge if the node\'s previous/next sibling is a text node\n        adjacentNode = node[propName];\n        if (adjacentNode && adjacentNode.nodeType == wysihtml5.TEXT_NODE) {\n          return adjacentNode;\n        }\n      } else {\n        // Compare element with its sibling\n        adjacentNode = el[propName];\n        if (adjacentNode && this.areElementsMergeable(node, adjacentNode)) {\n          return adjacentNode[forward ? "firstChild" : "lastChild"];\n        }\n      }\n      return null;\n    },\n\n    areElementsMergeable: function areElementsMergeable(el1, el2) {\n      return rangy.dom.arrayContains(this.tagNames, (el1.tagName || "").toLowerCase()) && rangy.dom.arrayContains(this.tagNames, (el2.tagName || "").toLowerCase()) && hasSameClasses(el1, el2) && elementsHaveSameNonClassAttributes(el1, el2);\n    },\n\n    createContainer: function createContainer(doc) {\n      var el = doc.createElement(this.tagNames[0]);\n      if (this.cssClass) {\n        el.className = this.cssClass;\n      }\n      return el;\n    },\n\n    applyToTextNode: function applyToTextNode(textNode) {\n      var parent = textNode.parentNode;\n      if (parent.childNodes.length == 1 && rangy.dom.arrayContains(this.tagNames, parent.tagName.toLowerCase())) {\n        if (this.cssClass) {\n          addClass(parent, this.cssClass, this.similarClassRegExp);\n        }\n      } else {\n        var el = this.createContainer(rangy.dom.getDocument(textNode));\n        textNode.parentNode.insertBefore(el, textNode);\n        el.appendChild(textNode);\n      }\n    },\n\n    isRemovable: function isRemovable(el) {\n      return rangy.dom.arrayContains(this.tagNames, el.tagName.toLowerCase()) && wysihtml5.lang.string(el.className).trim() == this.cssClass;\n    },\n\n    undoToTextNode: function undoToTextNode(textNode, range, ancestorWithClass) {\n      if (!range.containsNode(ancestorWithClass)) {\n        // Split out the portion of the ancestor from which we can remove the CSS class\n        var ancestorRange = range.cloneRange();\n        ancestorRange.selectNode(ancestorWithClass);\n\n        if (ancestorRange.isPointInRange(range.endContainer, range.endOffset) && isSplitPoint(range.endContainer, range.endOffset)) {\n          splitNodeAt(ancestorWithClass, range.endContainer, range.endOffset);\n          range.setEndAfter(ancestorWithClass);\n        }\n        if (ancestorRange.isPointInRange(range.startContainer, range.startOffset) && isSplitPoint(range.startContainer, range.startOffset)) {\n          ancestorWithClass = splitNodeAt(ancestorWithClass, range.startContainer, range.startOffset);\n        }\n      }\n\n      if (this.similarClassRegExp) {\n        removeClass(ancestorWithClass, this.similarClassRegExp);\n      }\n      if (this.isRemovable(ancestorWithClass)) {\n        replaceWithOwnChildren(ancestorWithClass);\n      }\n    },\n\n    applyToRange: function applyToRange(range) {\n      var textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n      if (!textNodes.length) {\n        try {\n          var node = this.createContainer(range.endContainer.ownerDocument);\n          range.surroundContents(node);\n          this.selectNode(range, node);\n          return;\n        } catch (e) {}\n      }\n\n      range.splitBoundaries();\n      textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n\n      if (textNodes.length) {\n        var textNode;\n\n        for (var i = 0, len = textNodes.length; i < len; ++i) {\n          textNode = textNodes[i];\n          if (!this.getAncestorWithClass(textNode)) {\n            this.applyToTextNode(textNode);\n          }\n        }\n\n        range.setStart(textNodes[0], 0);\n        textNode = textNodes[textNodes.length - 1];\n        range.setEnd(textNode, textNode.length);\n\n        if (this.normalize) {\n          this.postApply(textNodes, range);\n        }\n      }\n    },\n\n    undoToRange: function undoToRange(range) {\n      var textNodes = range.getNodes([wysihtml5.TEXT_NODE]),\n          textNode,\n          ancestorWithClass;\n      if (textNodes.length) {\n        range.splitBoundaries();\n        textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n      } else {\n        var doc = range.endContainer.ownerDocument,\n            node = doc.createTextNode(wysihtml5.INVISIBLE_SPACE);\n        range.insertNode(node);\n        range.selectNode(node);\n        textNodes = [node];\n      }\n\n      for (var i = 0, len = textNodes.length; i < len; ++i) {\n        textNode = textNodes[i];\n        ancestorWithClass = this.getAncestorWithClass(textNode);\n        if (ancestorWithClass) {\n          this.undoToTextNode(textNode, range, ancestorWithClass);\n        }\n      }\n\n      if (len == 1) {\n        this.selectNode(range, textNodes[0]);\n      } else {\n        range.setStart(textNodes[0], 0);\n        textNode = textNodes[textNodes.length - 1];\n        range.setEnd(textNode, textNode.length);\n\n        if (this.normalize) {\n          this.postApply(textNodes, range);\n        }\n      }\n    },\n\n    selectNode: function selectNode(range, node) {\n      var isElement = node.nodeType === wysihtml5.ELEMENT_NODE,\n          canHaveHTML = "canHaveHTML" in node ? node.canHaveHTML : true,\n          content = isElement ? node.innerHTML : node.data,\n          isEmpty = content === "" || content === wysihtml5.INVISIBLE_SPACE;\n\n      if (isEmpty && isElement && canHaveHTML) {\n        // Make sure that caret is visible in node by inserting a zero width no breaking space\n        try {\n          node.innerHTML = wysihtml5.INVISIBLE_SPACE;\n        } catch (e) {}\n      }\n      range.selectNodeContents(node);\n      if (isEmpty && isElement) {\n        range.collapse(false);\n      } else if (isEmpty) {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n    },\n\n    getTextSelectedByRange: function getTextSelectedByRange(textNode, range) {\n      var textRange = range.cloneRange();\n      textRange.selectNodeContents(textNode);\n\n      var intersectionRange = textRange.intersection(range);\n      var text = intersectionRange ? intersectionRange.toString() : "";\n      textRange.detach();\n\n      return text;\n    },\n\n    isAppliedToRange: function isAppliedToRange(range) {\n      var ancestors = [],\n          ancestor,\n          textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n      if (!textNodes.length) {\n        ancestor = this.getAncestorWithClass(range.startContainer);\n        return ancestor ? [ancestor] : false;\n      }\n\n      for (var i = 0, len = textNodes.length, selectedText; i < len; ++i) {\n        selectedText = this.getTextSelectedByRange(textNodes[i], range);\n        ancestor = this.getAncestorWithClass(textNodes[i]);\n        if (selectedText != "" && !ancestor) {\n          return false;\n        } else {\n          ancestors.push(ancestor);\n        }\n      }\n      return ancestors;\n    },\n\n    toggleRange: function toggleRange(range) {\n      if (this.isAppliedToRange(range)) {\n        this.undoToRange(range);\n      } else {\n        this.applyToRange(range);\n      }\n    }\n  };\n\n  wysihtml5.selection.HTMLApplier = HTMLApplier;\n})(wysihtml5, rangy); /**\n                      * Rich Text Query/Formatting Commands\n                      * \n                      * @example\n                      *    var commands = new wysihtml5.Commands(editor);\n                      */\nwysihtml5.Commands = Base.extend(\n/** @scope wysihtml5.Commands.prototype */{\n  constructor: function constructor(editor) {\n    this.editor = editor;\n    this.composer = editor.composer;\n    this.doc = this.composer.doc;\n  },\n\n  /**\n   * Check whether the browser supports the given command\n   *\n   * @param {String} command The command string which to check (eg. "bold", "italic", "insertUnorderedList")\n   * @example\n   *    commands.supports("createLink");\n   */\n  support: function support(command) {\n    return wysihtml5.browser.supportsCommand(this.doc, command);\n  },\n\n  /**\n   * Check whether the browser supports the given command\n   *\n   * @param {String} command The command string which to execute (eg. "bold", "italic", "insertUnorderedList")\n   * @param {String} [value] The command value parameter, needed for some commands ("createLink", "insertImage", ...), optional for commands that don\'t require one ("bold", "underline", ...)\n   * @example\n   *    commands.exec("insertImage", "http://a1.twimg.com/profile_images/113868655/schrei_twitter_reasonably_small.jpg");\n   */\n  exec: function exec(command, value) {\n    var obj = wysihtml5.commands[command],\n        args = wysihtml5.lang.array(arguments).get(),\n        method = obj && obj.exec,\n        result = null;\n\n    this.editor.fire("beforecommand:composer");\n\n    if (method) {\n      args.unshift(this.composer);\n      result = method.apply(obj, args);\n    } else {\n      try {\n        // try/catch for buggy firefox\n        result = this.doc.execCommand(command, false, value);\n      } catch (e) {}\n    }\n\n    this.editor.fire("aftercommand:composer");\n    return result;\n  },\n\n  /**\n   * Check whether the current command is active\n   * If the caret is within a bold text, then calling this with command "bold" should return true\n   *\n   * @param {String} command The command string which to check (eg. "bold", "italic", "insertUnorderedList")\n   * @param {String} [commandValue] The command value parameter (eg. for "insertImage" the image src)\n   * @return {Boolean} Whether the command is active\n   * @example\n   *    var isCurrentSelectionBold = commands.state("bold");\n   */\n  state: function state(command, commandValue) {\n    var obj = wysihtml5.commands[command],\n        args = wysihtml5.lang.array(arguments).get(),\n        method = obj && obj.state;\n    if (method) {\n      args.unshift(this.composer);\n      return method.apply(obj, args);\n    } else {\n      try {\n        // try/catch for buggy firefox\n        return this.doc.queryCommandState(command);\n      } catch (e) {\n        return false;\n      }\n    }\n  },\n\n  /**\n   * Get the current command\'s value\n   *\n   * @param {String} command The command string which to check (eg. "formatBlock")\n   * @return {String} The command value\n   * @example\n   *    var currentBlockElement = commands.value("formatBlock");\n   */\n  value: function value(command) {\n    var obj = wysihtml5.commands[command],\n        method = obj && obj.value;\n    if (method) {\n      return method.call(obj, this.composer, command);\n    } else {\n      try {\n        // try/catch for buggy firefox\n        return this.doc.queryCommandValue(command);\n      } catch (e) {\n        return null;\n      }\n    }\n  }\n});\n(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.bold = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatInline.exec(composer, command, "b");\n    },\n\n    state: function state(composer, command, color) {\n      // element.ownerDocument.queryCommandState("bold") results:\n      // firefox: only <b>\n      // chrome:  <b>, <strong>, <h1>, <h2>, ...\n      // ie:      <b>, <strong>\n      // opera:   <b>, <strong>\n      return wysihtml5.commands.formatInline.state(composer, command, "b");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);\n\n(function (wysihtml5) {\n  var undef,\n      NODE_NAME = "A",\n      dom = wysihtml5.dom;\n\n  function _removeFormat(composer, anchors) {\n    var length = anchors.length,\n        i = 0,\n        anchor,\n        codeElement,\n        textContent;\n    for (; i < length; i++) {\n      anchor = anchors[i];\n      codeElement = dom.getParentElement(anchor, { nodeName: "code" });\n      textContent = dom.getTextContent(anchor);\n\n      // if <a> contains url-like text content, rename it to <code> to prevent re-autolinking\n      // else replace <a> with its childNodes\n      if (textContent.match(dom.autoLink.URL_REG_EXP) && !codeElement) {\n        // <code> element is used to prevent later auto-linking of the content\n        codeElement = dom.renameElement(anchor, "code");\n      } else {\n        dom.replaceWithChildNodes(anchor);\n      }\n    }\n  }\n\n  function _format(composer, attributes) {\n    var doc = composer.doc,\n        tempClass = "_wysihtml5-temp-" + +new Date(),\n        tempClassRegExp = /non-matching-class/g,\n        i = 0,\n        length,\n        anchors,\n        anchor,\n        hasElementChild,\n        isEmpty,\n        elementToSetCaretAfter,\n        textContent,\n        whiteSpace,\n        j;\n    wysihtml5.commands.formatInline.exec(composer, undef, NODE_NAME, tempClass, tempClassRegExp);\n    anchors = doc.querySelectorAll(NODE_NAME + "." + tempClass);\n    length = anchors.length;\n    for (; i < length; i++) {\n      anchor = anchors[i];\n      anchor.removeAttribute("class");\n      for (j in attributes) {\n        anchor.setAttribute(j, attributes[j]);\n      }\n    }\n\n    elementToSetCaretAfter = anchor;\n    if (length === 1) {\n      textContent = dom.getTextContent(anchor);\n      hasElementChild = !!anchor.querySelector("*");\n      isEmpty = textContent === "" || textContent === wysihtml5.INVISIBLE_SPACE;\n      if (!hasElementChild && isEmpty) {\n        dom.setTextContent(anchor, attributes.text || anchor.href);\n        whiteSpace = doc.createTextNode(" ");\n        composer.selection.setAfter(anchor);\n        composer.selection.insertNode(whiteSpace);\n        elementToSetCaretAfter = whiteSpace;\n      }\n    }\n    composer.selection.setAfter(elementToSetCaretAfter);\n  }\n\n  wysihtml5.commands.createLink = {\n    /**\n     * TODO: Use HTMLApplier or formatInline here\n     *\n     * Turns selection into a link\n     * If selection is already a link, it removes the link and wraps it with a <code> element\n     * The <code> element is needed to avoid auto linking\n     * \n     * @example\n     *    // either ...\n     *    wysihtml5.commands.createLink.exec(composer, "createLink", "http://www.google.de");\n     *    // ... or ...\n     *    wysihtml5.commands.createLink.exec(composer, "createLink", { href: "http://www.google.de", target: "_blank" });\n     */\n    exec: function exec(composer, command, value) {\n      var anchors = this.state(composer, command);\n      if (anchors) {\n        // Selection contains links\n        composer.selection.executeAndRestore(function () {\n          _removeFormat(composer, anchors);\n        });\n      } else {\n        // Create links\n        value = (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" ? value : { href: value };\n        _format(composer, value);\n      }\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatInline.state(composer, command, "A");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5); /**\n               * document.execCommand("fontSize") will create either inline styles (firefox, chrome) or use font tags\n               * which we don\'t want\n               * Instead we set a css class\n               */\n(function (wysihtml5) {\n  var undef,\n      REG_EXP = /wysiwyg-font-size-[a-z\\-]+/g;\n\n  wysihtml5.commands.fontSize = {\n    exec: function exec(composer, command, size) {\n      return wysihtml5.commands.formatInline.exec(composer, command, "span", "wysiwyg-font-size-" + size, REG_EXP);\n    },\n\n    state: function state(composer, command, size) {\n      return wysihtml5.commands.formatInline.state(composer, command, "span", "wysiwyg-font-size-" + size, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);\n/**\n * document.execCommand("foreColor") will create either inline styles (firefox, chrome) or use font tags\n * which we don\'t want\n * Instead we set a css class\n */\n(function (wysihtml5) {\n  var undef,\n      REG_EXP = /wysiwyg-color-[a-z]+/g;\n\n  wysihtml5.commands.foreColor = {\n    exec: function exec(composer, command, color) {\n      return wysihtml5.commands.formatInline.exec(composer, command, "span", "wysiwyg-color-" + color, REG_EXP);\n    },\n\n    state: function state(composer, command, color) {\n      return wysihtml5.commands.formatInline.state(composer, command, "span", "wysiwyg-color-" + color, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      dom = wysihtml5.dom,\n      DEFAULT_NODE_NAME = "DIV",\n\n\n  // Following elements are grouped\n  // when the caret is within a H1 and the H4 is invoked, the H1 should turn into H4\n  // instead of creating a H4 within a H1 which would result in semantically invalid html\n  BLOCK_ELEMENTS_GROUP = ["H1", "H2", "H3", "H4", "H5", "H6", "P", "BLOCKQUOTE", DEFAULT_NODE_NAME];\n\n  /**\n   * Remove similiar classes (based on classRegExp)\n   * and add the desired class name\n   */\n  function _addClass(element, className, classRegExp) {\n    if (element.className) {\n      _removeClass(element, classRegExp);\n      element.className += " " + className;\n    } else {\n      element.className = className;\n    }\n  }\n\n  function _removeClass(element, classRegExp) {\n    element.className = element.className.replace(classRegExp, "");\n  }\n\n  /**\n   * Check whether given node is a text node and whether it\'s empty\n   */\n  function _isBlankTextNode(node) {\n    return node.nodeType === wysihtml5.TEXT_NODE && !wysihtml5.lang.string(node.data).trim();\n  }\n\n  /**\n   * Returns previous sibling node that is not a blank text node\n   */\n  function _getPreviousSiblingThatIsNotBlank(node) {\n    var previousSibling = node.previousSibling;\n    while (previousSibling && _isBlankTextNode(previousSibling)) {\n      previousSibling = previousSibling.previousSibling;\n    }\n    return previousSibling;\n  }\n\n  /**\n   * Returns next sibling node that is not a blank text node\n   */\n  function _getNextSiblingThatIsNotBlank(node) {\n    var nextSibling = node.nextSibling;\n    while (nextSibling && _isBlankTextNode(nextSibling)) {\n      nextSibling = nextSibling.nextSibling;\n    }\n    return nextSibling;\n  }\n\n  /**\n   * Adds line breaks before and after the given node if the previous and next siblings\n   * aren\'t already causing a visual line break (block element or <br>)\n   */\n  function _addLineBreakBeforeAndAfter(node) {\n    var doc = node.ownerDocument,\n        nextSibling = _getNextSiblingThatIsNotBlank(node),\n        previousSibling = _getPreviousSiblingThatIsNotBlank(node);\n\n    if (nextSibling && !_isLineBreakOrBlockElement(nextSibling)) {\n      node.parentNode.insertBefore(doc.createElement("br"), nextSibling);\n    }\n    if (previousSibling && !_isLineBreakOrBlockElement(previousSibling)) {\n      node.parentNode.insertBefore(doc.createElement("br"), node);\n    }\n  }\n\n  /**\n   * Removes line breaks before and after the given node\n   */\n  function _removeLineBreakBeforeAndAfter(node) {\n    var nextSibling = _getNextSiblingThatIsNotBlank(node),\n        previousSibling = _getPreviousSiblingThatIsNotBlank(node);\n\n    if (nextSibling && _isLineBreak(nextSibling)) {\n      nextSibling.parentNode.removeChild(nextSibling);\n    }\n    if (previousSibling && _isLineBreak(previousSibling)) {\n      previousSibling.parentNode.removeChild(previousSibling);\n    }\n  }\n\n  function _removeLastChildIfLineBreak(node) {\n    var lastChild = node.lastChild;\n    if (lastChild && _isLineBreak(lastChild)) {\n      lastChild.parentNode.removeChild(lastChild);\n    }\n  }\n\n  function _isLineBreak(node) {\n    return node.nodeName === "BR";\n  }\n\n  /**\n   * Checks whether the elment causes a visual line break\n   * (<br> or block elements)\n   */\n  function _isLineBreakOrBlockElement(element) {\n    if (_isLineBreak(element)) {\n      return true;\n    }\n\n    if (dom.getStyle("display").from(element) === "block") {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Execute native query command\n   * and if necessary modify the inserted node\'s className\n   */\n  function _execCommand(doc, command, nodeName, className) {\n    if (className) {\n      var eventListener = dom.observe(doc, "DOMNodeInserted", function (event) {\n        var target = event.target,\n            displayStyle;\n        if (target.nodeType !== wysihtml5.ELEMENT_NODE) {\n          return;\n        }\n        displayStyle = dom.getStyle("display").from(target);\n        if (displayStyle.substr(0, 6) !== "inline") {\n          // Make sure that only block elements receive the given class\n          target.className += " " + className;\n        }\n      });\n    }\n    doc.execCommand(command, false, nodeName);\n    if (eventListener) {\n      eventListener.stop();\n    }\n  }\n\n  function _selectLineAndWrap(composer, element) {\n    composer.selection.selectLine();\n    composer.selection.surround(element);\n    _removeLineBreakBeforeAndAfter(element);\n    _removeLastChildIfLineBreak(element);\n    composer.selection.selectNode(element);\n  }\n\n  function _hasClasses(element) {\n    return !!wysihtml5.lang.string(element.className).trim();\n  }\n\n  wysihtml5.commands.formatBlock = {\n    exec: function exec(composer, command, nodeName, className, classRegExp) {\n      var doc = composer.doc,\n          blockElement = this.state(composer, command, nodeName, className, classRegExp),\n          selectedNode;\n\n      nodeName = typeof nodeName === "string" ? nodeName.toUpperCase() : nodeName;\n\n      if (blockElement) {\n        composer.selection.executeAndRestoreSimple(function () {\n          if (classRegExp) {\n            _removeClass(blockElement, classRegExp);\n          }\n          var hasClasses = _hasClasses(blockElement);\n          if (!hasClasses && blockElement.nodeName === (nodeName || DEFAULT_NODE_NAME)) {\n            // Insert a line break afterwards and beforewards when there are siblings\n            // that are not of type line break or block element\n            _addLineBreakBeforeAndAfter(blockElement);\n            dom.replaceWithChildNodes(blockElement);\n          } else if (hasClasses) {\n            // Make sure that styling is kept by renaming the element to <div> and copying over the class name\n            dom.renameElement(blockElement, DEFAULT_NODE_NAME);\n          }\n        });\n        return;\n      }\n\n      // Find similiar block element and rename it (<h2 class="foo"></h2>  =>  <h1 class="foo"></h1>)\n      if (nodeName === null || wysihtml5.lang.array(BLOCK_ELEMENTS_GROUP).contains(nodeName)) {\n        selectedNode = composer.selection.getSelectedNode();\n        blockElement = dom.getParentElement(selectedNode, {\n          nodeName: BLOCK_ELEMENTS_GROUP\n        });\n\n        if (blockElement) {\n          composer.selection.executeAndRestoreSimple(function () {\n            // Rename current block element to new block element and add class\n            if (nodeName) {\n              blockElement = dom.renameElement(blockElement, nodeName);\n            }\n            if (className) {\n              _addClass(blockElement, className, classRegExp);\n            }\n          });\n          return;\n        }\n      }\n\n      if (composer.commands.support(command)) {\n        _execCommand(doc, command, nodeName || DEFAULT_NODE_NAME, className);\n        return;\n      }\n\n      blockElement = doc.createElement(nodeName || DEFAULT_NODE_NAME);\n      if (className) {\n        blockElement.className = className;\n      }\n      _selectLineAndWrap(composer, blockElement);\n    },\n\n    state: function state(composer, command, nodeName, className, classRegExp) {\n      nodeName = typeof nodeName === "string" ? nodeName.toUpperCase() : nodeName;\n      var selectedNode = composer.selection.getSelectedNode();\n      return dom.getParentElement(selectedNode, {\n        nodeName: nodeName,\n        className: className,\n        classRegExp: classRegExp\n      });\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5); /**\n               * formatInline scenarios for tag "B" (| = caret, |foo| = selected text)\n               *\n               *   #1 caret in unformatted text:\n               *      abcdefg|\n               *   output:\n               *      abcdefg<b>|</b>\n               *   \n               *   #2 unformatted text selected:\n               *      abc|deg|h\n               *   output:\n               *      abc<b>|deg|</b>h\n               *   \n               *   #3 unformatted text selected across boundaries:\n               *      ab|c <span>defg|h</span>\n               *   output:\n               *      ab<b>|c </b><span><b>defg</b>|h</span>\n               *\n               *   #4 formatted text entirely selected\n               *      <b>|abc|</b>\n               *   output:\n               *      |abc|\n               *\n               *   #5 formatted text partially selected\n               *      <b>ab|c|</b>\n               *   output:\n               *      <b>ab</b>|c|\n               *\n               *   #6 formatted text selected across boundaries\n               *      <span>ab|c</span> <b>de|fgh</b>\n               *   output:\n               *      <span>ab|c</span> de|<b>fgh</b>\n               */\n(function (wysihtml5) {\n  var undef,\n\n\n  // Treat <b> as <strong> and vice versa\n  ALIAS_MAPPING = {\n    "strong": "b",\n    "em": "i",\n    "b": "strong",\n    "i": "em"\n  },\n      htmlApplier = {};\n\n  function _getTagNames(tagName) {\n    var alias = ALIAS_MAPPING[tagName];\n    return alias ? [tagName.toLowerCase(), alias.toLowerCase()] : [tagName.toLowerCase()];\n  }\n\n  function _formatClear(range) {\n    body = $(range.endContainer.ownerDocument.body);\n    $.each(body.children(\'font\'), function () {\n      font_el = $(this);\n      font_el.replaceWith(\'<span>\' + font_el.html() + \'</span>\');\n    });\n\n    $.each(body.children(\'span\'), function () {\n      span_el = $(this);\n      reduced_dimension(span_el);\n    });\n    not_span_list = $(\'tbody:first > tr\').not(\'td\').toArray();\n    while (not_span_list.length) {\n      not_span_list_item = not_span_list.pop();\n      $.each(not_span_list_item.children(), function () {\n        new_el = $(this);\n        if (new_el.is(\'span\')) {\n          reduced_dimension(new_el);\n        } else {\n          not_span_list.push(new_el);\n        }\n      });\n    }\n    $.each(body.find(\'span\'), function () {\n      el = $(this);\n      if (!$.trim(el.text()).length) {\n        el.remove();\n      }\n    });\n    range.endContainer.ownerDocument.getSelection().empty();\n  }\n\n  // make <span class=\'a\'>123<span class=\'b\'>4</span>5</span> become\n  // <span class=\'a\'>123</span> <span class=\'b\'>4</span> <span class=\'a\'>5</span>\n  function reduced_dimension(span) {\n    if (span.children(\'span\').length) {\n      class_name = $.trim(span.get(0).className);\n      for (var i = 0; i < span.children(\'span\').length; i++) {\n        child_span = $(span.children(\'span\')[i]);\n        reduced_dimension(child_span);\n      }\n\n      console.log(span.parents(\'span\').length);\n      html_text = span.html();\n      if (!class_name.length) {\n        class_name = \'wysiwyg-color-clear\';\n      }\n      html_text = html_text.replace(/<span\\ /, \'</span><span \');\n      html_text = html_text.replace(/<\\/span>(?![\\s\\S]*<\\/span>[\\s\\S]*$)/i, "</span><span class=\'" + class_name + "\'>");\n      html_text = "<span class=\'" + class_name + "\'>" + html_text + "</span>";\n      span.replaceWith(html_text);\n    } else {\n      return;\n    }\n  }\n\n  function _getApplier(tagName, className, classRegExp) {\n    var identifier = tagName + ":" + className;\n    if (!htmlApplier[identifier]) {\n      htmlApplier[identifier] = new wysihtml5.selection.HTMLApplier(_getTagNames(tagName), className, classRegExp, true);\n    }\n    return htmlApplier[identifier];\n  }\n\n  wysihtml5.commands.formatInline = {\n    exec: function exec(composer, command, tagName, className, classRegExp) {\n      var range = composer.selection.getRange();\n      if (!range) {\n        return false;\n      }\n      _getApplier(tagName, className, classRegExp).toggleRange(range);\n      composer.selection.setSelection(range);\n      _formatClear(range);\n    },\n\n    state: function state(composer, command, tagName, className, classRegExp) {\n      var doc = composer.doc,\n          aliasTagName = ALIAS_MAPPING[tagName] || tagName,\n          range;\n\n      // Check whether the document contains a node with the desired tagName\n      if (!wysihtml5.dom.hasElementWithTagName(doc, tagName) && !wysihtml5.dom.hasElementWithTagName(doc, aliasTagName)) {\n        return false;\n      }\n\n      // Check whether the document contains a node with the desired className\n      if (className && !wysihtml5.dom.hasElementWithClassName(doc, className)) {\n        return false;\n      }\n\n      range = composer.selection.getRange();\n      if (!range) {\n        return false;\n      }\n\n      return _getApplier(tagName, className, classRegExp).isAppliedToRange(range);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.insertHTML = {\n    exec: function exec(composer, command, html) {\n      if (composer.commands.support(command)) {\n        composer.doc.execCommand(command, false, html);\n      } else {\n        composer.selection.insertHTML(html);\n      }\n    },\n\n    state: function state() {\n      return false;\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var NODE_NAME = "IMG";\n\n  wysihtml5.commands.insertImage = {\n    /**\n     * Inserts an <img>\n     * If selection is already an image link, it removes it\n     * \n     * @example\n     *    // either ...\n     *    wysihtml5.commands.insertImage.exec(composer, "insertImage", "http://www.google.de/logo.jpg");\n     *    // ... or ...\n     *    wysihtml5.commands.insertImage.exec(composer, "insertImage", { src: "http://www.google.de/logo.jpg", title: "foo" });\n     */\n    exec: function exec(composer, command, value) {\n      value = (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" ? value : { src: value };\n\n      var doc = composer.doc,\n          image = this.state(composer),\n          textNode,\n          i,\n          parent;\n\n      if (image) {\n        // Image already selected, set the caret before it and delete it\n        composer.selection.setBefore(image);\n        parent = image.parentNode;\n        parent.removeChild(image);\n\n        // and it\'s parent <a> too if it hasn\'t got any other relevant child nodes\n        wysihtml5.dom.removeEmptyTextNodes(parent);\n        if (parent.nodeName === "A" && !parent.firstChild) {\n          composer.selection.setAfter(parent);\n          parent.parentNode.removeChild(parent);\n        }\n\n        // firefox and ie sometimes don\'t remove the image handles, even though the image got removed\n        wysihtml5.quirks.redraw(composer.element);\n        return;\n      }\n\n      image = doc.createElement(NODE_NAME);\n\n      for (i in value) {\n        image[i] = value[i];\n      }\n\n      composer.selection.insertNode(image);\n      if (wysihtml5.browser.hasProblemsSettingCaretAfterImg()) {\n        textNode = doc.createTextNode(wysihtml5.INVISIBLE_SPACE);\n        composer.selection.insertNode(textNode);\n        composer.selection.setAfter(textNode);\n      } else {\n        composer.selection.setAfter(image);\n      }\n    },\n\n    state: function state(composer) {\n      var doc = composer.doc,\n          selectedNode,\n          text,\n          imagesInSelection;\n\n      if (!wysihtml5.dom.hasElementWithTagName(doc, NODE_NAME)) {\n        return false;\n      }\n\n      selectedNode = composer.selection.getSelectedNode();\n      if (!selectedNode) {\n        return false;\n      }\n\n      if (selectedNode.nodeName === NODE_NAME) {\n        // This works perfectly in IE\n        return selectedNode;\n      }\n\n      if (selectedNode.nodeType !== wysihtml5.ELEMENT_NODE) {\n        return false;\n      }\n\n      text = composer.selection.getText();\n      text = wysihtml5.lang.string(text).trim();\n      if (text) {\n        return false;\n      }\n\n      imagesInSelection = composer.selection.getNodes(wysihtml5.ELEMENT_NODE, function (node) {\n        return node.nodeName === "IMG";\n      });\n\n      if (imagesInSelection.length !== 1) {\n        return false;\n      }\n\n      return imagesInSelection[0];\n    },\n\n    value: function value(composer) {\n      var image = this.state(composer);\n      return image && image.src;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      LINE_BREAK = "<br>" + (wysihtml5.browser.needsSpaceAfterLineBreak() ? " " : "");\n\n  wysihtml5.commands.insertLineBreak = {\n    exec: function exec(composer, command) {\n      if (composer.commands.support(command)) {\n        composer.doc.execCommand(command, false, null);\n        if (!wysihtml5.browser.autoScrollsToCaret()) {\n          composer.selection.scrollIntoView();\n        }\n      } else {\n        composer.commands.exec("insertHTML", LINE_BREAK);\n      }\n    },\n\n    state: function state() {\n      return false;\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n  //\n  // function _removeFormat(composer, anchors) {\n  //   var length  = anchors.length,\n  //       i       = 0,\n  //       anchor,\n  //       codeElement,\n  //       textContent;\n  //   for (; i<length; i++) {\n  //     anchor      = anchors[i];\n  //     codeElement = dom.getParentElement(anchor, { nodeName: "code" });\n  //     textContent = dom.getTextContent(anchor);\n  //\n  //     // if <a> contains url-like text content, rename it to <code> to prevent re-autolinking\n  //     // else replace <a> with its childNodes\n  //     if (textContent.match(dom.autoLink.URL_REG_EXP) && !codeElement) {\n  //       // <code> element is used to prevent later auto-linking of the content\n  //       codeElement = dom.renameElement(anchor, "code");\n  //     } else {\n  //       dom.replaceWithChildNodes(anchor);\n  //     }\n  //   }\n  // }\n  //\n  //\n  wysihtml5.commands.clear = {\n    exec: function exec(composer, command) {\n      composer.doc.execCommand(\'removeFormat\');\n      REG_EXP = /wysiwyg-color-[a-z]+/g;\n      wysihtml5.commands.formatInline.exec(composer, command, "span", "", REG_EXP);\n    }\n  };\n  wysihtml5.commands.insertOrderedList = {\n    exec: function exec(composer, command) {\n      var doc = composer.doc,\n          selectedNode = composer.selection.getSelectedNode(),\n          list = wysihtml5.dom.getParentElement(selectedNode, { nodeName: "OL" }),\n          otherList = wysihtml5.dom.getParentElement(selectedNode, { nodeName: "UL" }),\n          tempClassName = "_wysihtml5-temp-" + new Date().getTime(),\n          isEmpty,\n          tempElement;\n\n      if (composer.commands.support(command)) {\n        doc.execCommand(command, false, null);\n        return;\n      }\n\n      if (list) {\n        // Unwrap list\n        // <ol><li>foo</li><li>bar</li></ol>\n        // becomes:\n        // foo<br>bar<br>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.resolveList(list);\n        });\n      } else if (otherList) {\n        // Turn an unordered list into an ordered list\n        // <ul><li>foo</li><li>bar</li></ul>\n        // becomes:\n        // <ol><li>foo</li><li>bar</li></ol>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.renameElement(otherList, "ol");\n        });\n      } else {\n        // Create list\n        composer.commands.exec("formatBlock", "div", tempClassName);\n        tempElement = doc.querySelector("." + tempClassName);\n        isEmpty = tempElement.innerHTML === "" || tempElement.innerHTML === wysihtml5.INVISIBLE_SPACE;\n        composer.selection.executeAndRestoreSimple(function () {\n          list = wysihtml5.dom.convertToList(tempElement, "ol");\n        });\n        if (isEmpty) {\n          composer.selection.selectNode(list.querySelector("li"));\n        }\n      }\n    },\n\n    state: function state(composer) {\n      var selectedNode = composer.selection.getSelectedNode();\n      return wysihtml5.dom.getParentElement(selectedNode, { nodeName: "OL" });\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.insertUnorderedList = {\n    exec: function exec(composer, command) {\n      var doc = composer.doc,\n          selectedNode = composer.selection.getSelectedNode(),\n          list = wysihtml5.dom.getParentElement(selectedNode, { nodeName: "UL" }),\n          otherList = wysihtml5.dom.getParentElement(selectedNode, { nodeName: "OL" }),\n          tempClassName = "_wysihtml5-temp-" + new Date().getTime(),\n          isEmpty,\n          tempElement;\n\n      if (composer.commands.support(command)) {\n        doc.execCommand(command, false, null);\n        return;\n      }\n\n      if (list) {\n        // Unwrap list\n        // <ul><li>foo</li><li>bar</li></ul>\n        // becomes:\n        // foo<br>bar<br>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.resolveList(list);\n        });\n      } else if (otherList) {\n        // Turn an ordered list into an unordered list\n        // <ol><li>foo</li><li>bar</li></ol>\n        // becomes:\n        // <ul><li>foo</li><li>bar</li></ul>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.renameElement(otherList, "ul");\n        });\n      } else {\n        // Create list\n        composer.commands.exec("formatBlock", "div", tempClassName);\n        tempElement = doc.querySelector("." + tempClassName);\n        isEmpty = tempElement.innerHTML === "" || tempElement.innerHTML === wysihtml5.INVISIBLE_SPACE;\n        composer.selection.executeAndRestoreSimple(function () {\n          list = wysihtml5.dom.convertToList(tempElement, "ul");\n        });\n        if (isEmpty) {\n          composer.selection.selectNode(list.querySelector("li"));\n        }\n      }\n    },\n\n    state: function state(composer) {\n      var selectedNode = composer.selection.getSelectedNode();\n      return wysihtml5.dom.getParentElement(selectedNode, { nodeName: "UL" });\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.italic = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatInline.exec(composer, command, "i");\n    },\n\n    state: function state(composer, command, color) {\n      // element.ownerDocument.queryCommandState("italic") results:\n      // firefox: only <i>\n      // chrome:  <i>, <em>, <blockquote>, ...\n      // ie:      <i>, <em>\n      // opera:   only <i>\n      return wysihtml5.commands.formatInline.state(composer, command, "i");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      CLASS_NAME = "wysiwyg-text-align-center",\n      REG_EXP = /wysiwyg-text-align-[a-z]+/g;\n\n  wysihtml5.commands.justifyCenter = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      CLASS_NAME = "wysiwyg-text-align-left",\n      REG_EXP = /wysiwyg-text-align-[a-z]+/g;\n\n  wysihtml5.commands.justifyLeft = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      CLASS_NAME = "wysiwyg-text-align-right",\n      REG_EXP = /wysiwyg-text-align-[a-z]+/g;\n\n  wysihtml5.commands.justifyRight = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n  wysihtml5.commands.underline = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatInline.exec(composer, command, "u");\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatInline.state(composer, command, "u");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5); /**\n               * Undo Manager for wysihtml5\n               * slightly inspired by http://rniwa.com/editing/undomanager.html#the-undomanager-interface\n               */\n(function (wysihtml5) {\n  var Z_KEY = 90,\n      Y_KEY = 89,\n      BACKSPACE_KEY = 8,\n      DELETE_KEY = 46,\n      MAX_HISTORY_ENTRIES = 40,\n      UNDO_HTML = \'<span id="_wysihtml5-undo" class="_wysihtml5-temp">\' + wysihtml5.INVISIBLE_SPACE + \'</span>\',\n      REDO_HTML = \'<span id="_wysihtml5-redo" class="_wysihtml5-temp">\' + wysihtml5.INVISIBLE_SPACE + \'</span>\',\n      dom = wysihtml5.dom;\n\n  function cleanTempElements(doc) {\n    var tempElement;\n    while (tempElement = doc.querySelector("._wysihtml5-temp")) {\n      tempElement.parentNode.removeChild(tempElement);\n    }\n  }\n\n  wysihtml5.UndoManager = wysihtml5.lang.Dispatcher.extend(\n  /** @scope wysihtml5.UndoManager.prototype */{\n    constructor: function constructor(editor) {\n      this.editor = editor;\n      this.composer = editor.composer;\n      this.element = this.composer.element;\n      this.history = [this.composer.getValue()];\n      this.position = 1;\n\n      // Undo manager currently only supported in browsers who have the insertHTML command (not IE)\n      if (this.composer.commands.support("insertHTML")) {\n        this._observe();\n      }\n    },\n\n    _observe: function _observe() {\n      var that = this,\n          doc = this.composer.sandbox.getDocument(),\n          lastKey;\n\n      // Catch CTRL+Z and CTRL+Y\n      dom.observe(this.element, "keydown", function (event) {\n        if (event.altKey || !event.ctrlKey && !event.metaKey) {\n          return;\n        }\n\n        var keyCode = event.keyCode,\n            isUndo = keyCode === Z_KEY && !event.shiftKey,\n            isRedo = keyCode === Z_KEY && event.shiftKey || keyCode === Y_KEY;\n\n        if (isUndo) {\n          that.undo();\n          event.preventDefault();\n        } else if (isRedo) {\n          that.redo();\n          event.preventDefault();\n        }\n      });\n\n      // Catch delete and backspace\n      dom.observe(this.element, "keydown", function (event) {\n        var keyCode = event.keyCode;\n        if (keyCode === lastKey) {\n          return;\n        }\n\n        lastKey = keyCode;\n\n        if (keyCode === BACKSPACE_KEY || keyCode === DELETE_KEY) {\n          that.transact();\n        }\n      });\n\n      // Now this is very hacky:\n      // These days browsers don\'t offer a undo/redo event which we could hook into\n      // to be notified when the user hits undo/redo in the contextmenu.\n      // Therefore we simply insert two elements as soon as the contextmenu gets opened.\n      // The last element being inserted will be immediately be removed again by a exexCommand("undo")\n      //  => When the second element appears in the dom tree then we know the user clicked "redo" in the context menu\n      //  => When the first element disappears from the dom tree then we know the user clicked "undo" in the context menu\n      if (wysihtml5.browser.hasUndoInContextMenu()) {\n        var interval,\n            observed,\n            cleanUp = function cleanUp() {\n          cleanTempElements(doc);\n          clearInterval(interval);\n        };\n\n        dom.observe(this.element, "contextmenu", function () {\n          cleanUp();\n          that.composer.selection.executeAndRestoreSimple(function () {\n            if (that.element.lastChild) {\n              that.composer.selection.setAfter(that.element.lastChild);\n            }\n\n            // enable undo button in context menu\n            doc.execCommand("insertHTML", false, UNDO_HTML);\n            // enable redo button in context menu\n            doc.execCommand("insertHTML", false, REDO_HTML);\n            doc.execCommand("undo", false, null);\n          });\n\n          interval = setInterval(function () {\n            if (doc.getElementById("_wysihtml5-redo")) {\n              cleanUp();\n              that.redo();\n            }\n          }, 400);\n\n          if (!observed) {\n            observed = true;\n            dom.observe(document, "mousedown", cleanUp);\n            dom.observe(doc, ["mousedown", "paste", "cut", "copy"], cleanUp);\n          }\n        });\n      }\n\n      this.editor.observe("newword:composer", function () {\n        that.transact();\n      }).observe("beforecommand:composer", function () {\n        that.transact();\n      });\n    },\n\n    transact: function transact() {\n      var previousHtml = this.history[this.position - 1],\n          currentHtml = this.composer.getValue();\n\n      if (currentHtml == previousHtml) {\n        return;\n      }\n\n      var length = this.history.length = this.position;\n      if (length > MAX_HISTORY_ENTRIES) {\n        this.history.shift();\n        this.position--;\n      }\n\n      this.position++;\n      this.history.push(currentHtml);\n    },\n\n    undo: function undo() {\n      this.transact();\n\n      if (this.position <= 1) {\n        return;\n      }\n\n      this.set(this.history[--this.position - 1]);\n      this.editor.fire("undo:composer");\n    },\n\n    redo: function redo() {\n      if (this.position >= this.history.length) {\n        return;\n      }\n\n      this.set(this.history[++this.position - 1]);\n      this.editor.fire("redo:composer");\n    },\n\n    set: function set(html) {\n      this.composer.setValue(html);\n      this.editor.focus(true);\n    }\n  });\n})(wysihtml5);\n/**\n * TODO: the following methods still need unit test coverage\n */\nwysihtml5.views.View = Base.extend(\n/** @scope wysihtml5.views.View.prototype */{\n  constructor: function constructor(parent, textareaElement, config) {\n    this.parent = parent;\n    this.element = textareaElement;\n    this.config = config;\n\n    this._observeViewChange();\n  },\n\n  _observeViewChange: function _observeViewChange() {\n    var that = this;\n    this.parent.observe("beforeload", function () {\n      that.parent.observe("change_view", function (view) {\n        if (view === that.name) {\n          that.parent.currentView = that;\n          that.show();\n          // Using tiny delay here to make sure that the placeholder is set before focusing\n          setTimeout(function () {\n            that.focus();\n          }, 0);\n        } else {\n          that.hide();\n        }\n      });\n    });\n  },\n\n  focus: function focus() {\n    if (this.element.ownerDocument.querySelector(":focus") === this.element) {\n      return;\n    }\n\n    try {\n      this.element.focus();\n    } catch (e) {}\n  },\n\n  hide: function hide() {\n    this.element.style.display = "none";\n  },\n\n  show: function show() {\n    this.element.style.display = "";\n  },\n\n  disable: function disable() {\n    this.element.setAttribute("disabled", "disabled");\n  },\n\n  enable: function enable() {\n    this.element.removeAttribute("disabled");\n  }\n});(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      browser = wysihtml5.browser;\n\n  wysihtml5.views.Composer = wysihtml5.views.View.extend(\n  /** @scope wysihtml5.views.Composer.prototype */{\n    name: "composer",\n\n    // Needed for firefox in order to display a proper caret in an empty contentEditable\n    CARET_HACK: "<br>",\n\n    constructor: function constructor(parent, textareaElement, config) {\n      this.base(parent, textareaElement, config);\n      this.textarea = this.parent.textarea;\n      this._initSandbox();\n    },\n\n    clear: function clear() {\n      this.element.innerHTML = browser.displaysCaretInEmptyContentEditableCorrectly() ? "" : this.CARET_HACK;\n    },\n\n    getValue: function getValue(parse) {\n      var value = this.isEmpty() ? "" : wysihtml5.quirks.getCorrectInnerHTML(this.element);\n\n      if (parse) {\n        value = this.parent.parse(value);\n      }\n\n      // Replace all "zero width no breaking space" chars\n      // which are used as hacks to enable some functionalities\n      // Also remove all CARET hacks that somehow got left\n      value = wysihtml5.lang.string(value).replace(wysihtml5.INVISIBLE_SPACE).by("");\n\n      return value;\n    },\n\n    setValue: function setValue(html, parse) {\n      if (parse) {\n        html = this.parent.parse(html);\n      }\n      this.element.innerHTML = html;\n    },\n\n    show: function show() {\n      this.iframe.style.display = this._displayStyle || "";\n\n      // Firefox needs this, otherwise contentEditable becomes uneditable\n      this.disable();\n      this.enable();\n    },\n\n    hide: function hide() {\n      this._displayStyle = dom.getStyle("display").from(this.iframe);\n      if (this._displayStyle === "none") {\n        this._displayStyle = null;\n      }\n      this.iframe.style.display = "none";\n    },\n\n    disable: function disable() {\n      this.element.removeAttribute("contentEditable");\n      this.base();\n    },\n\n    enable: function enable() {\n      this.element.setAttribute("contentEditable", "true");\n      this.base();\n    },\n\n    focus: function focus(setToEnd) {\n      // IE 8 fires the focus event after .focus()\n      // This is needed by our simulate_placeholder.js to work\n      // therefore we clear it ourselves this time\n      if (wysihtml5.browser.doesAsyncFocus() && this.hasPlaceholderSet()) {\n        this.clear();\n      }\n\n      this.base();\n\n      var lastChild = this.element.lastChild;\n      if (setToEnd && lastChild) {\n        if (lastChild.nodeName === "BR") {\n          this.selection.setBefore(this.element.lastChild);\n        } else {\n          this.selection.setAfter(this.element.lastChild);\n        }\n      }\n    },\n\n    getTextContent: function getTextContent() {\n      return dom.getTextContent(this.element);\n    },\n\n    hasPlaceholderSet: function hasPlaceholderSet() {\n      return this.getTextContent() == this.textarea.element.getAttribute("placeholder");\n    },\n\n    isEmpty: function isEmpty() {\n      var innerHTML = this.element.innerHTML,\n          elementsWithVisualValue = "blockquote, ul, ol, img, embed, object, table, iframe, svg, video, audio, button, input, select, textarea";\n      return innerHTML === "" || innerHTML === this.CARET_HACK || this.hasPlaceholderSet() || this.getTextContent() === "" && !this.element.querySelector(elementsWithVisualValue);\n    },\n\n    _initSandbox: function _initSandbox() {\n      var that = this;\n\n      this.sandbox = new dom.Sandbox(function () {\n        that._create();\n      }, {\n        stylesheets: this.config.stylesheets\n      });\n      this.iframe = this.sandbox.getIframe();\n\n      // Create hidden field which tells the server after submit, that the user used an wysiwyg editor\n      var hiddenField = document.createElement("input");\n      hiddenField.type = "hidden";\n      hiddenField.name = "_wysihtml5_mode";\n      hiddenField.value = 1;\n\n      // Store reference to current wysihtml5 instance on the textarea element\n      var textareaElement = this.textarea.element;\n      dom.insert(this.iframe).after(textareaElement);\n      dom.insert(hiddenField).after(textareaElement);\n    },\n\n    _create: function _create() {\n      var that = this;\n\n      this.doc = this.sandbox.getDocument();\n      this.element = this.doc.body;\n      this.textarea = this.parent.textarea;\n      this.element.innerHTML = this.textarea.getValue(true);\n      this.enable();\n\n      // Make sure our selection handler is ready\n      this.selection = new wysihtml5.Selection(this.parent);\n\n      // Make sure commands dispatcher is ready\n      this.commands = new wysihtml5.Commands(this.parent);\n\n      dom.copyAttributes(["className", "spellcheck", "title", "lang", "dir", "accessKey"]).from(this.textarea.element).to(this.element);\n\n      dom.addClass(this.element, this.config.composerClassName);\n\n      // Make the editor look like the original textarea, by syncing styles\n      if (this.config.style) {\n        this.style();\n      }\n\n      this.observe();\n\n      var name = this.config.name;\n      if (name) {\n        dom.addClass(this.element, name);\n        dom.addClass(this.iframe, name);\n      }\n\n      // Simulate html5 placeholder attribute on contentEditable element\n      var placeholderText = typeof this.config.placeholder === "string" ? this.config.placeholder : this.textarea.element.getAttribute("placeholder");\n      if (placeholderText) {\n        dom.simulatePlaceholder(this.parent, this, placeholderText);\n      }\n\n      // Make sure that the browser avoids using inline styles whenever possible\n      this.commands.exec("styleWithCSS", false);\n\n      this._initAutoLinking();\n      this._initObjectResizing();\n      this._initUndoManager();\n\n      // Simulate html5 autofocus on contentEditable element\n      if (this.textarea.element.hasAttribute("autofocus") || document.querySelector(":focus") == this.textarea.element) {\n        setTimeout(function () {\n          that.focus();\n        }, 100);\n      }\n\n      wysihtml5.quirks.insertLineBreakOnReturn(this);\n\n      // IE sometimes leaves a single paragraph, which can\'t be removed by the user\n      if (!browser.clearsContentEditableCorrectly()) {\n        wysihtml5.quirks.ensureProperClearing(this);\n      }\n\n      if (!browser.clearsListsInContentEditableCorrectly()) {\n        wysihtml5.quirks.ensureProperClearingOfLists(this);\n      }\n\n      // Set up a sync that makes sure that textarea and editor have the same content\n      if (this.initSync && this.config.sync) {\n        this.initSync();\n      }\n\n      // Okay hide the textarea, we are ready to go\n      this.textarea.hide();\n\n      // Fire global (before-)load event\n      this.parent.fire("beforeload").fire("load");\n    },\n\n    _initAutoLinking: function _initAutoLinking() {\n      var that = this,\n          supportsDisablingOfAutoLinking = browser.canDisableAutoLinking(),\n          supportsAutoLinking = browser.doesAutoLinkingInContentEditable();\n      if (supportsDisablingOfAutoLinking) {\n        this.commands.exec("autoUrlDetect", false);\n      }\n\n      if (!this.config.autoLink) {\n        return;\n      }\n\n      // Only do the auto linking by ourselves when the browser doesn\'t support auto linking\n      // OR when he supports auto linking but we were able to turn it off (IE9+)\n      if (!supportsAutoLinking || supportsAutoLinking && supportsDisablingOfAutoLinking) {\n        this.parent.observe("newword:composer", function () {\n          that.selection.executeAndRestore(function (startContainer, endContainer) {\n            dom.autoLink(endContainer.parentNode);\n          });\n        });\n      }\n\n      // Assuming we have the following:\n      //  <a href="http://www.google.de">http://www.google.de</a>\n      // If a user now changes the url in the innerHTML we want to make sure that\n      // it\'s synchronized with the href attribute (as long as the innerHTML is still a url)\n      var // Use a live NodeList to check whether there are any links in the document\n      links = this.sandbox.getDocument().getElementsByTagName("a"),\n\n\n      // The autoLink helper method reveals a reg exp to detect correct urls\n      urlRegExp = dom.autoLink.URL_REG_EXP,\n          getTextContent = function getTextContent(element) {\n        var textContent = wysihtml5.lang.string(dom.getTextContent(element)).trim();\n        if (textContent.substr(0, 4) === "www.") {\n          textContent = "http://" + textContent;\n        }\n        return textContent;\n      };\n\n      dom.observe(this.element, "keydown", function (event) {\n        if (!links.length) {\n          return;\n        }\n\n        var selectedNode = that.selection.getSelectedNode(event.target.ownerDocument),\n            link = dom.getParentElement(selectedNode, { nodeName: "A" }, 4),\n            textContent;\n\n        if (!link) {\n          return;\n        }\n\n        textContent = getTextContent(link);\n        // keydown is fired before the actual content is changed\n        // therefore we set a timeout to change the href\n        setTimeout(function () {\n          var newTextContent = getTextContent(link);\n          if (newTextContent === textContent) {\n            return;\n          }\n\n          // Only set href when new href looks like a valid url\n          if (newTextContent.match(urlRegExp)) {\n            link.setAttribute("href", newTextContent);\n          }\n        }, 0);\n      });\n    },\n\n    _initObjectResizing: function _initObjectResizing() {\n      var properties = ["width", "height"],\n          propertiesLength = properties.length,\n          element = this.element;\n\n      this.commands.exec("enableObjectResizing", this.config.allowObjectResizing);\n\n      if (this.config.allowObjectResizing) {\n        // IE sets inline styles after resizing objects\n        // The following lines make sure that the width/height css properties\n        // are copied over to the width/height attributes\n        if (browser.supportsEvent("resizeend")) {\n          dom.observe(element, "resizeend", function (event) {\n            var target = event.target || event.srcElement,\n                style = target.style,\n                i = 0,\n                property;\n            for (; i < propertiesLength; i++) {\n              property = properties[i];\n              if (style[property]) {\n                target.setAttribute(property, parseInt(style[property], 10));\n                style[property] = "";\n              }\n            }\n            // After resizing IE sometimes forgets to remove the old resize handles\n            wysihtml5.quirks.redraw(element);\n          });\n        }\n      } else {\n        if (browser.supportsEvent("resizestart")) {\n          dom.observe(element, "resizestart", function (event) {\n            event.preventDefault();\n          });\n        }\n      }\n    },\n\n    _initUndoManager: function _initUndoManager() {\n      new wysihtml5.UndoManager(this.parent);\n    }\n  });\n})(wysihtml5);(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      doc = document,\n      win = window,\n      HOST_TEMPLATE = doc.createElement("div"),\n\n\n  /**\n   * Styles to copy from textarea to the composer element\n   */\n  TEXT_FORMATTING = ["background-color", "color", "cursor", "font-family", "font-size", "font-style", "font-variant", "font-weight", "line-height", "letter-spacing", "text-align", "text-decoration", "text-indent", "text-rendering", "word-break", "word-wrap", "word-spacing"],\n\n\n  /**\n   * Styles to copy from textarea to the iframe\n   */\n  BOX_FORMATTING = ["background-color", "border-collapse", "border-bottom-color", "border-bottom-style", "border-bottom-width", "border-left-color", "border-left-style", "border-left-width", "border-right-color", "border-right-style", "border-right-width", "border-top-color", "border-top-style", "border-top-width", "clear", "display", "float", "margin-bottom", "margin-left", "margin-right", "margin-top", "outline-color", "outline-offset", "outline-width", "outline-style", "padding-left", "padding-right", "padding-top", "padding-bottom", "position", "top", "left", "right", "bottom", "z-index", "vertical-align", "text-align", "-webkit-box-sizing", "-moz-box-sizing", "-ms-box-sizing", "box-sizing", "-webkit-box-shadow", "-moz-box-shadow", "-ms-box-shadow", "box-shadow", "-webkit-border-top-right-radius", "-moz-border-radius-topright", "border-top-right-radius", "-webkit-border-bottom-right-radius", "-moz-border-radius-bottomright", "border-bottom-right-radius", "-webkit-border-bottom-left-radius", "-moz-border-radius-bottomleft", "border-bottom-left-radius", "-webkit-border-top-left-radius", "-moz-border-radius-topleft", "border-top-left-radius", "width", "height"],\n\n\n  /**\n   * Styles to sync while the window gets resized\n   */\n  RESIZE_STYLE = ["width", "height", "top", "left", "right", "bottom"],\n      ADDITIONAL_CSS_RULES = ["html             { height: 100%; }", "body             { min-height: 100%; padding: 0; margin: 0; margin-top: -1px; padding-top: 1px; white-space: pre-wrap; }", "._wysihtml5-temp { display: none; }", wysihtml5.browser.isGecko ? "body.placeholder { color: graytext !important; }" : "body.placeholder { color: #a9a9a9 !important; }", "body[disabled]   { background-color: #eee !important; color: #999 !important; cursor: default !important; }",\n  // Ensure that user see\'s broken images and can delete them\n  "img:-moz-broken  { -moz-force-broken-image-icon: 1; height: 24px; width: 24px; }"];\n\n  /**\n   * With "setActive" IE offers a smart way of focusing elements without scrolling them into view:\n   * http://msdn.microsoft.com/en-us/library/ms536738(v=vs.85).aspx\n   *\n   * Other browsers need a more hacky way: (pssst don\'t tell my mama)\n   * In order to prevent the element being scrolled into view when focusing it, we simply\n   * move it out of the scrollable area, focus it, and reset it\'s position\n   */\n  var focusWithoutScrolling = function focusWithoutScrolling(element) {\n    if (element.setActive) {\n      // Following line could cause a js error when the textarea is invisible\n      // See https://github.com/xing/wysihtml5/issues/9\n      try {\n        element.setActive();\n      } catch (e) {}\n    } else {\n      var elementStyle = element.style,\n          originalScrollTop = doc.documentElement.scrollTop || doc.body.scrollTop,\n          originalScrollLeft = doc.documentElement.scrollLeft || doc.body.scrollLeft,\n          originalStyles = {\n        position: elementStyle.position,\n        top: elementStyle.top,\n        left: elementStyle.left,\n        WebkitUserSelect: elementStyle.WebkitUserSelect\n      };\n\n      dom.setStyles({\n        position: "absolute",\n        top: "-99999px",\n        left: "-99999px",\n        // Don\'t ask why but temporarily setting -webkit-user-select to none makes the whole thing performing smoother\n        WebkitUserSelect: "none"\n      }).on(element);\n\n      element.focus();\n\n      dom.setStyles(originalStyles).on(element);\n\n      if (win.scrollTo) {\n        // Some browser extensions unset this method to prevent annoyances\n        // "Better PopUp Blocker" for Chrome http://code.google.com/p/betterpopupblocker/source/browse/trunk/blockStart.js#100\n        // Issue: http://code.google.com/p/betterpopupblocker/issues/detail?id=1\n        win.scrollTo(originalScrollLeft, originalScrollTop);\n      }\n    }\n  };\n\n  wysihtml5.views.Composer.prototype.style = function () {\n    var that = this,\n        originalActiveElement = doc.querySelector(":focus"),\n        textareaElement = this.textarea.element,\n        hasPlaceholder = textareaElement.hasAttribute("placeholder"),\n        originalPlaceholder = hasPlaceholder && textareaElement.getAttribute("placeholder");\n    this.focusStylesHost = this.focusStylesHost || HOST_TEMPLATE.cloneNode(false);\n    this.blurStylesHost = this.blurStylesHost || HOST_TEMPLATE.cloneNode(false);\n\n    // Remove placeholder before copying (as the placeholder has an affect on the computed style)\n    if (hasPlaceholder) {\n      textareaElement.removeAttribute("placeholder");\n    }\n\n    if (textareaElement === originalActiveElement) {\n      textareaElement.blur();\n    }\n\n    // --------- iframe styles (has to be set before editor styles, otherwise IE9 sets wrong fontFamily on blurStylesHost) ---------\n    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.iframe).andTo(this.blurStylesHost);\n\n    // --------- editor styles ---------\n    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.element).andTo(this.blurStylesHost);\n\n    // --------- apply standard rules ---------\n    dom.insertCSS(ADDITIONAL_CSS_RULES).into(this.element.ownerDocument);\n\n    // --------- :focus styles ---------\n    focusWithoutScrolling(textareaElement);\n    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.focusStylesHost);\n    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.focusStylesHost);\n\n    // Make sure that we don\'t change the display style of the iframe when copying styles oblur/onfocus\n    // this is needed for when the change_view event is fired where the iframe is hidden and then\n    // the blur event fires and re-displays it\n    var boxFormattingStyles = wysihtml5.lang.array(BOX_FORMATTING).without(["display"]);\n\n    // --------- restore focus ---------\n    if (originalActiveElement) {\n      originalActiveElement.focus();\n    } else {\n      textareaElement.blur();\n    }\n\n    // --------- restore placeholder ---------\n    if (hasPlaceholder) {\n      textareaElement.setAttribute("placeholder", originalPlaceholder);\n    }\n\n    // When copying styles, we only get the computed style which is never returned in percent unit\n    // Therefore we\'ve to recalculate style onresize\n    if (!wysihtml5.browser.hasCurrentStyleProperty()) {\n      var winObserver = dom.observe(win, "resize", function () {\n        // Remove event listener if composer doesn\'t exist anymore\n        if (!dom.contains(document.documentElement, that.iframe)) {\n          winObserver.stop();\n          return;\n        }\n        var originalTextareaDisplayStyle = dom.getStyle("display").from(textareaElement),\n            originalComposerDisplayStyle = dom.getStyle("display").from(that.iframe);\n        textareaElement.style.display = "";\n        that.iframe.style.display = "none";\n        dom.copyStyles(RESIZE_STYLE).from(textareaElement).to(that.iframe).andTo(that.focusStylesHost).andTo(that.blurStylesHost);\n        that.iframe.style.display = originalComposerDisplayStyle;\n        textareaElement.style.display = originalTextareaDisplayStyle;\n      });\n    }\n\n    // --------- Sync focus/blur styles ---------\n    this.parent.observe("focus:composer", function () {\n      dom.copyStyles(boxFormattingStyles).from(that.focusStylesHost).to(that.iframe);\n      dom.copyStyles(TEXT_FORMATTING).from(that.focusStylesHost).to(that.element);\n    });\n\n    this.parent.observe("blur:composer", function () {\n      dom.copyStyles(boxFormattingStyles).from(that.blurStylesHost).to(that.iframe);\n      dom.copyStyles(TEXT_FORMATTING).from(that.blurStylesHost).to(that.element);\n    });\n\n    return this;\n  };\n})(wysihtml5); /**\n               * Taking care of events\n               *  - Simulating \'change\' event on contentEditable element\n               *  - Handling drag & drop logic\n               *  - Catch paste events\n               *  - Dispatch proprietary newword:composer event\n               *  - Keyboard shortcuts\n               */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      browser = wysihtml5.browser,\n\n\n  /**\n   * Map keyCodes to query commands\n   */\n  shortcuts = {\n    "66": "bold", // B\n    "73": "italic", // I\n    "85": "underline" // U\n  };\n\n  wysihtml5.views.Composer.prototype.observe = function () {\n    var that = this,\n        state = this.getValue(),\n        iframe = this.sandbox.getIframe(),\n        element = this.element,\n        focusBlurElement = browser.supportsEventsInIframeCorrectly() ? element : this.sandbox.getWindow(),\n\n\n    // Firefox < 3.5 doesn\'t support the drop event, instead it supports a so called "dragdrop" event which behaves almost the same\n    pasteEvents = browser.supportsEvent("drop") ? ["drop", "paste"] : ["dragdrop", "paste"];\n\n    // --------- destroy:composer event ---------\n    dom.observe(iframe, "DOMNodeRemoved", function () {\n      clearInterval(domNodeRemovedInterval);\n      that.parent.fire("destroy:composer");\n    });\n\n    // DOMNodeRemoved event is not supported in IE 8\n    var domNodeRemovedInterval = setInterval(function () {\n      if (!dom.contains(document.documentElement, iframe)) {\n        clearInterval(domNodeRemovedInterval);\n        that.parent.fire("destroy:composer");\n      }\n    }, 250);\n\n    // --------- Focus & blur logic ---------\n    dom.observe(focusBlurElement, "focus", function () {\n      that.parent.fire("focus").fire("focus:composer");\n\n      // Delay storing of state until all focus handler are fired\n      // especially the one which resets the placeholder\n      setTimeout(function () {\n        state = that.getValue();\n      }, 0);\n    });\n\n    dom.observe(focusBlurElement, "blur", function () {\n      if (state !== that.getValue()) {\n        that.parent.fire("change").fire("change:composer");\n      }\n      that.parent.fire("blur").fire("blur:composer");\n    });\n\n    if (wysihtml5.browser.isIos()) {\n      // When on iPad/iPhone/IPod after clicking outside of editor, the editor loses focus\n      // but the UI still acts as if the editor has focus (blinking caret and onscreen keyboard visible)\n      // We prevent that by focusing a temporary input element which immediately loses focus\n      dom.observe(element, "blur", function () {\n        var input = element.ownerDocument.createElement("input"),\n            originalScrollTop = document.documentElement.scrollTop || document.body.scrollTop,\n            originalScrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n        try {\n          that.selection.insertNode(input);\n        } catch (e) {\n          element.appendChild(input);\n        }\n        input.focus();\n        input.parentNode.removeChild(input);\n\n        window.scrollTo(originalScrollLeft, originalScrollTop);\n      });\n    }\n\n    // --------- Drag & Drop logic ---------\n    dom.observe(element, "dragenter", function () {\n      that.parent.fire("unset_placeholder");\n    });\n\n    if (browser.firesOnDropOnlyWhenOnDragOverIsCancelled()) {\n      dom.observe(element, ["dragover", "dragenter"], function (event) {\n        event.preventDefault();\n      });\n    }\n\n    dom.observe(element, pasteEvents, function (event) {\n      var dataTransfer = event.dataTransfer,\n          data;\n\n      if (dataTransfer && browser.supportsDataTransfer()) {\n        data = dataTransfer.getData("text/html") || dataTransfer.getData("text/plain");\n      }\n      if (data) {\n        element.focus();\n        that.commands.exec("insertHTML", data);\n        that.parent.fire("paste").fire("paste:composer");\n        event.stopPropagation();\n        event.preventDefault();\n      } else {\n        setTimeout(function () {\n          that.parent.fire("paste").fire("paste:composer");\n        }, 0);\n      }\n    });\n\n    // --------- neword event ------+---\n    dom.observe(element, "keyup", function (event) {\n      var keyCode = event.keyCode;\n      if (keyCode === wysihtml5.ENTER_KEY) {\n        that.parent.fire("newword:composer");\n      }\n    });\n\n    this.parent.observe("paste:composer", function () {\n      setTimeout(function () {\n        that.parent.fire("newword:composer");\n      }, 0);\n    });\n\n    // --------- Make sure that images are selected when clicking on them ---------\n    if (!browser.canSelectImagesInContentEditable()) {\n      dom.observe(element, "mousedown", function (event) {\n        var target = event.target;\n        if (target.nodeName === "IMG") {\n          that.selection.selectNode(target);\n          event.preventDefault();\n        }\n      });\n    }\n\n    // --------- Shortcut logic ---------\n    dom.observe(element, "keydown", function (event) {\n      var keyCode = event.keyCode,\n          command = shortcuts[keyCode];\n      if ((event.ctrlKey || event.metaKey) && !event.altKey && command) {\n        that.commands.exec(command);\n        event.preventDefault();\n      }\n    });\n\n    // --------- Make sure that when pressing backspace/delete on selected images deletes the image and it\'s anchor ---------\n    dom.observe(element, "keydown", function (event) {\n      var target = that.selection.getSelectedNode(true),\n          keyCode = event.keyCode,\n          parent;\n      if (target && target.nodeName === "IMG" && (keyCode === wysihtml5.BACKSPACE_KEY || keyCode === wysihtml5.DELETE_KEY)) {\n        // 8 => backspace, 46 => delete\n        parent = target.parentNode;\n        // delete the <img>\n        parent.removeChild(target);\n        // and it\'s parent <a> too if it hasn\'t got any other child nodes\n        if (parent.nodeName === "A" && !parent.firstChild) {\n          parent.parentNode.removeChild(parent);\n        }\n\n        setTimeout(function () {\n          wysihtml5.quirks.redraw(element);\n        }, 0);\n        event.preventDefault();\n      }\n    });\n\n    // --------- Show url in tooltip when hovering links or images ---------\n    var titlePrefixes = {\n      IMG: "Image: ",\n      A: "Link: "\n    };\n\n    dom.observe(element, "mouseover", function (event) {\n      var target = event.target,\n          nodeName = target.nodeName,\n          title;\n      if (nodeName !== "A" && nodeName !== "IMG") {\n        return;\n      }\n      var hasTitle = target.hasAttribute("title");\n      if (!hasTitle) {\n        title = titlePrefixes[nodeName] + (target.getAttribute("href") || target.getAttribute("src"));\n        target.setAttribute("title", title);\n      }\n    });\n  };\n})(wysihtml5); /**\n               * Class that takes care that the value of the composer and the textarea is always in sync\n               */\n(function (wysihtml5) {\n  var INTERVAL = 400;\n\n  wysihtml5.views.Synchronizer = Base.extend(\n  /** @scope wysihtml5.views.Synchronizer.prototype */{\n\n    constructor: function constructor(editor, textarea, composer) {\n      this.editor = editor;\n      this.textarea = textarea;\n      this.composer = composer;\n\n      this._observe();\n    },\n\n    /**\n     * Sync html from composer to textarea\n     * Takes care of placeholders\n     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the textarea\n     */\n    fromComposerToTextarea: function fromComposerToTextarea(shouldParseHtml) {\n      this.textarea.setValue(wysihtml5.lang.string(this.composer.getValue()).trim(), shouldParseHtml);\n    },\n\n    /**\n     * Sync value of textarea to composer\n     * Takes care of placeholders\n     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the composer\n     */\n    fromTextareaToComposer: function fromTextareaToComposer(shouldParseHtml) {\n      var textareaValue = this.textarea.getValue();\n      if (textareaValue) {\n        this.composer.setValue(textareaValue, shouldParseHtml);\n      } else {\n        this.composer.clear();\n        this.editor.fire("set_placeholder");\n      }\n    },\n\n    /**\n     * Invoke syncing based on view state\n     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the composer/textarea\n     */\n    sync: function sync(shouldParseHtml) {\n      if (this.editor.currentView.name === "textarea") {\n        this.fromTextareaToComposer(shouldParseHtml);\n      } else {\n        this.fromComposerToTextarea(shouldParseHtml);\n      }\n    },\n\n    /**\n     * Initializes interval-based syncing\n     * also makes sure that on-submit the composer\'s content is synced with the textarea\n     * immediately when the form gets submitted\n     */\n    _observe: function _observe() {\n      var interval,\n          that = this,\n          form = this.textarea.element.form,\n          startInterval = function startInterval() {\n        interval = setInterval(function () {\n          that.fromComposerToTextarea();\n        }, INTERVAL);\n      },\n          stopInterval = function stopInterval() {\n        clearInterval(interval);\n        interval = null;\n      };\n\n      startInterval();\n\n      if (form) {\n        // If the textarea is in a form make sure that after onreset and onsubmit the composer\n        // has the correct state\n        wysihtml5.dom.observe(form, "submit", function () {\n          that.sync(true);\n        });\n        wysihtml5.dom.observe(form, "reset", function () {\n          setTimeout(function () {\n            that.fromTextareaToComposer();\n          }, 0);\n        });\n      }\n\n      this.editor.observe("change_view", function (view) {\n        if (view === "composer" && !interval) {\n          that.fromTextareaToComposer(true);\n          startInterval();\n        } else if (view === "textarea") {\n          that.fromComposerToTextarea(true);\n          stopInterval();\n        }\n      });\n\n      this.editor.observe("destroy:composer", stopInterval);\n    }\n  });\n})(wysihtml5);\nwysihtml5.views.Textarea = wysihtml5.views.View.extend(\n/** @scope wysihtml5.views.Textarea.prototype */{\n  name: "textarea",\n\n  constructor: function constructor(parent, textareaElement, config) {\n    this.base(parent, textareaElement, config);\n\n    this._observe();\n  },\n\n  clear: function clear() {\n    this.element.value = "";\n  },\n\n  getValue: function getValue(parse) {\n    var value = this.isEmpty() ? "" : this.element.value;\n    if (parse) {\n      value = this.parent.parse(value);\n    }\n    return value;\n  },\n\n  setValue: function setValue(html, parse) {\n    if (parse) {\n      html = this.parent.parse(html);\n    }\n    this.element.value = html;\n  },\n\n  hasPlaceholderSet: function hasPlaceholderSet() {\n    var supportsPlaceholder = wysihtml5.browser.supportsPlaceholderAttributeOn(this.element),\n        placeholderText = this.element.getAttribute("placeholder") || null,\n        value = this.element.value,\n        isEmpty = !value;\n    return supportsPlaceholder && isEmpty || value === placeholderText;\n  },\n\n  isEmpty: function isEmpty() {\n    return !wysihtml5.lang.string(this.element.value).trim() || this.hasPlaceholderSet();\n  },\n\n  _observe: function _observe() {\n    var element = this.element,\n        parent = this.parent,\n        eventMapping = {\n      focusin: "focus",\n      focusout: "blur"\n    },\n\n\n    /**\n     * Calling focus() or blur() on an element doesn\'t synchronously trigger the attached focus/blur events\n     * This is the case for focusin and focusout, so let\'s use them whenever possible, kkthxbai\n     */\n    events = wysihtml5.browser.supportsEvent("focusin") ? ["focusin", "focusout", "change"] : ["focus", "blur", "change"];\n\n    parent.observe("beforeload", function () {\n      wysihtml5.dom.observe(element, events, function (event) {\n        var eventName = eventMapping[event.type] || event.type;\n        parent.fire(eventName).fire(eventName + ":textarea");\n      });\n\n      wysihtml5.dom.observe(element, ["paste", "drop"], function () {\n        setTimeout(function () {\n          parent.fire("paste").fire("paste:textarea");\n        }, 0);\n      });\n    });\n  }\n}); /**\n    * Toolbar Dialog\n    *\n    * @param {Element} link The toolbar link which causes the dialog to show up\n    * @param {Element} container The dialog container\n    *\n    * @example\n    *    \x3c!-- Toolbar link --\x3e\n    *    <a data-wysihtml5-command="insertImage">insert an image</a>\n    *\n    *    \x3c!-- Dialog --\x3e\n    *    <div data-wysihtml5-dialog="insertImage" style="display: none;">\n    *      <label>\n    *        URL: <input data-wysihtml5-dialog-field="src" value="http://">\n    *      </label>\n    *      <label>\n    *        Alternative text: <input data-wysihtml5-dialog-field="alt" value="">\n    *      </label>\n    *    </div>\n    *\n    *    <script>\n    *      var dialog = new wysihtml5.toolbar.Dialog(\n    *        document.querySelector("[data-wysihtml5-command=\'insertImage\']"),\n    *        document.querySelector("[data-wysihtml5-dialog=\'insertImage\']")\n    *      );\n    *      dialog.observe("save", function(attributes) {\n    *        // do something\n    *      });\n    *    <\/script>\n    */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      CLASS_NAME_OPENED = "wysihtml5-command-dialog-opened",\n      SELECTOR_FORM_ELEMENTS = "input, select, textarea",\n      SELECTOR_FIELDS = "[data-wysihtml5-dialog-field]",\n      ATTRIBUTE_FIELDS = "data-wysihtml5-dialog-field";\n\n  wysihtml5.toolbar.Dialog = wysihtml5.lang.Dispatcher.extend(\n  /** @scope wysihtml5.toolbar.Dialog.prototype */{\n    constructor: function constructor(link, container) {\n      this.link = link;\n      this.container = container;\n    },\n\n    _observe: function _observe() {\n      if (this._observed) {\n        return;\n      }\n\n      var that = this,\n          callbackWrapper = function callbackWrapper(event) {\n        var attributes = that._serialize();\n        if (attributes == that.elementToChange) {\n          that.fire("edit", attributes);\n        } else {\n          that.fire("save", attributes);\n        }\n        that.hide();\n        event.preventDefault();\n        event.stopPropagation();\n      };\n\n      dom.observe(that.link, "click", function (event) {\n        if (dom.hasClass(that.link, CLASS_NAME_OPENED)) {\n          setTimeout(function () {\n            that.hide();\n          }, 0);\n        }\n      });\n\n      dom.observe(this.container, "keydown", function (event) {\n        var keyCode = event.keyCode;\n        if (keyCode === wysihtml5.ENTER_KEY) {\n          callbackWrapper(event);\n        }\n        if (keyCode === wysihtml5.ESCAPE_KEY) {\n          // that.hide();\n        }\n      });\n\n      dom.delegate(this.container, "[data-wysihtml5-dialog-action=save]", "click", callbackWrapper);\n\n      dom.delegate(this.container, "[data-wysihtml5-dialog-action=cancel]", "click", function (event) {\n        that.fire("cancel");\n        that.hide();\n        event.preventDefault();\n        event.stopPropagation();\n      });\n\n      var formElements = this.container.querySelectorAll(SELECTOR_FORM_ELEMENTS),\n          i = 0,\n          length = formElements.length,\n          _clearInterval = function _clearInterval() {\n        clearInterval(that.interval);\n      };\n      for (; i < length; i++) {\n        dom.observe(formElements[i], "change", _clearInterval);\n      }\n\n      this._observed = true;\n    },\n\n    /**\n     * Grabs all fields in the dialog and puts them in key=>value style in an object which\n     * then gets returned\n     */\n    _serialize: function _serialize() {\n      var data = this.elementToChange || {},\n          fields = this.container.querySelectorAll(SELECTOR_FIELDS),\n          length = fields.length,\n          i = 0;\n      for (; i < length; i++) {\n        data[fields[i].getAttribute(ATTRIBUTE_FIELDS)] = fields[i].value;\n      }\n      return data;\n    },\n\n    /**\n     * Takes the attributes of the "elementToChange"\n     * and inserts them in their corresponding dialog input fields\n     * \n     * Assume the "elementToChange" looks like this:\n     *    <a href="http://www.google.com" target="_blank">foo</a>\n     *\n     * and we have the following dialog:\n     *    <input type="text" data-wysihtml5-dialog-field="href" value="">\n     *    <input type="text" data-wysihtml5-dialog-field="target" value="">\n     * \n     * after calling _interpolate() the dialog will look like this\n     *    <input type="text" data-wysihtml5-dialog-field="href" value="http://www.google.com">\n     *    <input type="text" data-wysihtml5-dialog-field="target" value="_blank">\n     *\n     * Basically it adopted the attribute values into the corresponding input fields\n     *\n     */\n    _interpolate: function _interpolate(avoidHiddenFields) {\n      var field,\n          fieldName,\n          newValue,\n          focusedElement = document.querySelector(":focus"),\n          fields = this.container.querySelectorAll(SELECTOR_FIELDS),\n          length = fields.length,\n          i = 0;\n      for (; i < length; i++) {\n        field = fields[i];\n\n        // Never change elements where the user is currently typing in\n        if (field === focusedElement) {\n          continue;\n        }\n\n        // Don\'t update hidden fields\n        // See https://github.com/xing/wysihtml5/pull/14\n        if (avoidHiddenFields && field.type === "hidden") {\n          continue;\n        }\n\n        fieldName = field.getAttribute(ATTRIBUTE_FIELDS);\n        newValue = this.elementToChange ? this.elementToChange[fieldName] || "" : field.defaultValue;\n        field.value = newValue;\n      }\n    },\n\n    /**\n     * Show the dialog element\n     */\n    show: function show(elementToChange) {\n      var that = this,\n          firstField = this.container.querySelector(SELECTOR_FORM_ELEMENTS);\n      this.elementToChange = elementToChange;\n      this._observe();\n      this._interpolate();\n      if (elementToChange) {\n        this.interval = setInterval(function () {\n          that._interpolate(true);\n        }, 500);\n      }\n      dom.addClass(this.link, CLASS_NAME_OPENED);\n      this.container.style.display = "";\n      this.fire("show");\n      if (firstField && !elementToChange) {\n        try {\n          firstField.focus();\n        } catch (e) {}\n      }\n    },\n\n    /**\n     * Hide the dialog element\n     */\n    hide: function hide() {\n      clearInterval(this.interval);\n      this.elementToChange = null;\n      dom.removeClass(this.link, CLASS_NAME_OPENED);\n      this.container.style.display = "none";\n      this.fire("hide");\n    }\n  });\n})(wysihtml5);\n/**\n * Converts speech-to-text and inserts this into the editor\n * As of now (2011/03/25) this only is supported in Chrome >= 11\n *\n * Note that it sends the recorded audio to the google speech recognition api:\n * http://stackoverflow.com/questions/4361826/does-chrome-have-buil-in-speech-recognition-for-input-type-text-x-webkit-speec\n *\n * Current HTML5 draft can be found here\n * http://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Feb/att-0020/api-draft.html\n * \n * "Accessing Google Speech API Chrome 11"\n * http://mikepultz.com/2011/03/accessing-google-speech-api-chrome-11/\n */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom;\n\n  var linkStyles = {\n    position: "relative"\n  };\n\n  var wrapperStyles = {\n    left: 0,\n    margin: 0,\n    opacity: 0,\n    overflow: "hidden",\n    padding: 0,\n    position: "absolute",\n    top: 0,\n    zIndex: 1\n  };\n\n  var inputStyles = {\n    cursor: "inherit",\n    fontSize: "50px",\n    height: "50px",\n    marginTop: "-25px",\n    outline: 0,\n    padding: 0,\n    position: "absolute",\n    right: "-4px",\n    top: "50%"\n  };\n\n  var inputAttributes = {\n    "x-webkit-speech": "",\n    "speech": ""\n  };\n\n  wysihtml5.toolbar.Speech = function (parent, link) {\n    var input = document.createElement("input");\n    if (!wysihtml5.browser.supportsSpeechApiOn(input)) {\n      link.style.display = "none";\n      return;\n    }\n\n    var wrapper = document.createElement("div");\n\n    wysihtml5.lang.object(wrapperStyles).merge({\n      width: link.offsetWidth + "px",\n      height: link.offsetHeight + "px"\n    });\n\n    dom.insert(input).into(wrapper);\n    dom.insert(wrapper).into(link);\n\n    dom.setStyles(inputStyles).on(input);\n    dom.setAttributes(inputAttributes).on(input);\n\n    dom.setStyles(wrapperStyles).on(wrapper);\n    dom.setStyles(linkStyles).on(link);\n\n    var eventName = "onwebkitspeechchange" in input ? "webkitspeechchange" : "speechchange";\n    dom.observe(input, eventName, function () {\n      parent.execCommand("insertText", input.value);\n      input.value = "";\n    });\n\n    dom.observe(input, "click", function (event) {\n      if (dom.hasClass(link, "wysihtml5-command-disabled")) {\n        event.preventDefault();\n      }\n\n      event.stopPropagation();\n    });\n  };\n})(wysihtml5); /**\n               * Toolbar\n               *\n               * @param {Object} parent Reference to instance of Editor instance\n               * @param {Element} container Reference to the toolbar container element\n               *\n               * @example\n               *    <div id="toolbar">\n               *      <a data-wysihtml5-command="createLink">insert link</a>\n               *      <a data-wysihtml5-command="formatBlock" data-wysihtml5-command-value="h1">insert h1</a>\n               *    </div>\n               *\n               *    <script>\n               *      var toolbar = new wysihtml5.toolbar.Toolbar(editor, document.getElementById("toolbar"));\n               *    <\/script>\n               */\n(function (wysihtml5) {\n  var CLASS_NAME_COMMAND_DISABLED = "wysihtml5-command-disabled",\n      CLASS_NAME_COMMANDS_DISABLED = "wysihtml5-commands-disabled",\n      CLASS_NAME_COMMAND_ACTIVE = "wysihtml5-command-active",\n      CLASS_NAME_ACTION_ACTIVE = "wysihtml5-action-active",\n      dom = wysihtml5.dom;\n\n  wysihtml5.toolbar.Toolbar = Base.extend(\n  /** @scope wysihtml5.toolbar.Toolbar.prototype */{\n    constructor: function constructor(editor, container) {\n      this.editor = editor;\n      this.container = typeof container === "string" ? document.getElementById(container) : container;\n      this.composer = editor.composer;\n\n      this._getLinks("command");\n      this._getLinks("action");\n\n      this._observe();\n      this.show();\n\n      var speechInputLinks = this.container.querySelectorAll("[data-wysihtml5-command=insertSpeech]"),\n          length = speechInputLinks.length,\n          i = 0;\n      for (; i < length; i++) {\n        new wysihtml5.toolbar.Speech(this, speechInputLinks[i]);\n      }\n    },\n\n    _getLinks: function _getLinks(type) {\n      var links = this[type + "Links"] = wysihtml5.lang.array(this.container.querySelectorAll("[data-wysihtml5-" + type + "]")).get(),\n          length = links.length,\n          i = 0,\n          mapping = this[type + "Mapping"] = {},\n          link,\n          group,\n          name,\n          value,\n          dialog;\n      for (; i < length; i++) {\n        link = links[i];\n        name = link.getAttribute("data-wysihtml5-" + type);\n        value = link.getAttribute("data-wysihtml5-" + type + "-value");\n        group = this.container.querySelector("[data-wysihtml5-" + type + "-group=\'" + name + "\']");\n        dialog = this._getDialog(link, name);\n\n        mapping[name + ":" + value] = {\n          link: link,\n          group: group,\n          name: name,\n          value: value,\n          dialog: dialog,\n          state: false\n        };\n      }\n    },\n\n    _getDialog: function _getDialog(link, command) {\n      var that = this,\n          dialogElement = this.container.querySelector("[data-wysihtml5-dialog=\'" + command + "\']"),\n          dialog,\n          caretBookmark;\n\n      if (dialogElement) {\n        dialog = new wysihtml5.toolbar.Dialog(link, dialogElement);\n\n        dialog.observe("show", function () {\n          caretBookmark = that.composer.selection.getBookmark();\n\n          that.editor.fire("show:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });\n        });\n\n        dialog.observe("save", function (attributes) {\n          if (caretBookmark) {\n            that.composer.selection.setBookmark(caretBookmark);\n          }\n          that._execCommand(command, attributes);\n\n          that.editor.fire("save:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });\n        });\n\n        dialog.observe("cancel", function () {\n          that.editor.focus(false);\n          that.editor.fire("cancel:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });\n        });\n      }\n      return dialog;\n    },\n\n    /**\n     * @example\n     *    var toolbar = new wysihtml5.Toolbar();\n     *    // Insert a <blockquote> element or wrap current selection in <blockquote>\n     *    toolbar.execCommand("formatBlock", "blockquote");\n     */\n    execCommand: function execCommand(command, commandValue) {\n      if (this.commandsDisabled) {\n        return;\n      }\n\n      var commandObj = this.commandMapping[command + ":" + commandValue];\n\n      // Show dialog when available\n      if (commandObj && commandObj.dialog && !commandObj.state) {\n        commandObj.dialog.show();\n      } else {\n        this._execCommand(command, commandValue);\n      }\n    },\n\n    _execCommand: function _execCommand(command, commandValue) {\n      // Make sure that composer is focussed (false => don\'t move caret to the end)\n      this.editor.focus(false);\n\n      this.composer.commands.exec(command, commandValue);\n      this._updateLinkStates();\n    },\n\n    execAction: function execAction(action) {\n      var editor = this.editor;\n      switch (action) {\n        case "change_view":\n          if (editor.currentView === editor.textarea) {\n            editor.fire("change_view", "composer");\n          } else {\n            editor.fire("change_view", "textarea");\n          }\n          break;\n      }\n    },\n\n    _observe: function _observe() {\n      var that = this,\n          editor = this.editor,\n          container = this.container,\n          links = this.commandLinks.concat(this.actionLinks),\n          length = links.length,\n          i = 0;\n\n      for (; i < length; i++) {\n        // \'javascript:;\' and unselectable=on Needed for IE, but done in all browsers to make sure that all get the same css applied\n        // (you know, a:link { ... } doesn\'t match anchors with missing href attribute)\n        dom.setAttributes({\n          href: "javascript:;",\n          unselectable: "on"\n        }).on(links[i]);\n      }\n\n      // Needed for opera\n      dom.delegate(container, "[data-wysihtml5-command]", "mousedown", function (event) {\n        event.preventDefault();\n      });\n\n      dom.delegate(container, "[data-wysihtml5-command]", "click", function (event) {\n        var link = this,\n            command = link.getAttribute("data-wysihtml5-command"),\n            commandValue = link.getAttribute("data-wysihtml5-command-value");\n        that.execCommand(command, commandValue);\n        event.preventDefault();\n      });\n\n      dom.delegate(container, "[data-wysihtml5-action]", "click", function (event) {\n        var action = this.getAttribute("data-wysihtml5-action");\n        that.execAction(action);\n        event.preventDefault();\n      });\n\n      editor.observe("focus:composer", function () {\n        that.bookmark = null;\n        clearInterval(that.interval);\n        that.interval = setInterval(function () {\n          that._updateLinkStates();\n        }, 500);\n      });\n\n      editor.observe("blur:composer", function () {\n        clearInterval(that.interval);\n      });\n\n      editor.observe("destroy:composer", function () {\n        clearInterval(that.interval);\n      });\n\n      editor.observe("change_view", function (currentView) {\n        // Set timeout needed in order to let the blur event fire first\n        setTimeout(function () {\n          that.commandsDisabled = currentView !== "composer";\n          that._updateLinkStates();\n          if (that.commandsDisabled) {\n            dom.addClass(container, CLASS_NAME_COMMANDS_DISABLED);\n          } else {\n            dom.removeClass(container, CLASS_NAME_COMMANDS_DISABLED);\n          }\n        }, 0);\n      });\n    },\n\n    _updateLinkStates: function _updateLinkStates() {\n      var element = this.composer.element,\n          commandMapping = this.commandMapping,\n          actionMapping = this.actionMapping,\n          i,\n          state,\n          action,\n          command;\n      // every millisecond counts... this is executed quite often\n      for (i in commandMapping) {\n        command = commandMapping[i];\n        if (this.commandsDisabled) {\n          state = false;\n          dom.removeClass(command.link, CLASS_NAME_COMMAND_ACTIVE);\n          if (command.group) {\n            dom.removeClass(command.group, CLASS_NAME_COMMAND_ACTIVE);\n          }\n          if (command.dialog) {\n            command.dialog.hide();\n          }\n        } else {\n          state = this.composer.commands.state(command.name, command.value);\n          if (wysihtml5.lang.object(state).isArray()) {\n            // Grab first and only object/element in state array, otherwise convert state into boolean\n            // to avoid showing a dialog for multiple selected elements which may have different attributes\n            // eg. when two links with different href are selected, the state will be an array consisting of both link elements\n            // but the dialog interface can only update one\n            state = state.length === 1 ? state[0] : true;\n          }\n          dom.removeClass(command.link, CLASS_NAME_COMMAND_DISABLED);\n          if (command.group) {\n            dom.removeClass(command.group, CLASS_NAME_COMMAND_DISABLED);\n          }\n        }\n\n        if (command.state === state) {\n          continue;\n        }\n\n        command.state = state;\n        if (state) {\n          dom.addClass(command.link, CLASS_NAME_COMMAND_ACTIVE);\n          if (command.group) {\n            dom.addClass(command.group, CLASS_NAME_COMMAND_ACTIVE);\n          }\n          if (command.dialog) {\n            if ((typeof state === "undefined" ? "undefined" : _typeof(state)) === "object") {\n              command.dialog.show(state);\n            } else {\n              command.dialog.hide();\n            }\n          }\n        } else {\n          dom.removeClass(command.link, CLASS_NAME_COMMAND_ACTIVE);\n          if (command.group) {\n            dom.removeClass(command.group, CLASS_NAME_COMMAND_ACTIVE);\n          }\n          if (command.dialog) {\n            command.dialog.hide();\n          }\n        }\n      }\n\n      for (i in actionMapping) {\n        action = actionMapping[i];\n\n        if (action.name === "change_view") {\n          action.state = this.editor.currentView === this.editor.textarea;\n          if (action.state) {\n            dom.addClass(action.link, CLASS_NAME_ACTION_ACTIVE);\n          } else {\n            dom.removeClass(action.link, CLASS_NAME_ACTION_ACTIVE);\n          }\n        }\n      }\n    },\n\n    show: function show() {\n      this.container.style.display = "";\n    },\n\n    hide: function hide() {\n      this.container.style.display = "none";\n    }\n  });\n})(wysihtml5);\n/**\n * WYSIHTML5 Editor\n *\n * @param {Element} textareaElement Reference to the textarea which should be turned into a rich text interface\n * @param {Object} [config] See defaultConfig object below for explanation of each individual config option\n *\n * @events\n *    load\n *    beforeload (for internal use only)\n *    focus\n *    focus:composer\n *    focus:textarea\n *    blur\n *    blur:composer\n *    blur:textarea\n *    change\n *    change:composer\n *    change:textarea\n *    paste\n *    paste:composer\n *    paste:textarea\n *    newword:composer\n *    destroy:composer\n *    undo:composer\n *    redo:composer\n *    beforecommand:composer\n *    aftercommand:composer\n *    change_view\n */\n(function (wysihtml5) {\n  var undef;\n\n  var defaultConfig = {\n    // Give the editor a name, the name will also be set as class name on the iframe and on the iframe\'s body \n    name: undef,\n    // Whether the editor should look like the textarea (by adopting styles)\n    style: true,\n    // Id of the toolbar element, pass falsey value if you don\'t want any toolbar logic\n    toolbar: undef,\n    // Whether urls, entered by the user should automatically become clickable-links\n    autoLink: true,\n    // Object which includes parser rules to apply when html gets inserted via copy & paste\n    // See parser_rules/*.js for examples\n    parserRules: { tags: { br: {}, span: {}, div: {}, p: {} }, classes: {} },\n    // Parser method to use when the user inserts content via copy & paste\n    parser: wysihtml5.dom.parse,\n    // Class name which should be set on the contentEditable element in the created sandbox iframe, can be styled via the \'stylesheets\' option\n    composerClassName: "wysihtml5-editor",\n    // Class name to add to the body when the wysihtml5 editor is supported\n    bodyClassName: "wysihtml5-supported",\n    // Array (or single string) of stylesheet urls to be loaded in the editor\'s iframe\n    stylesheets: [],\n    // Placeholder text to use, defaults to the placeholder attribute on the textarea element\n    placeholderText: undef,\n    // Whether the composer should allow the user to manually resize images, tables etc.\n    allowObjectResizing: true,\n    // Whether the rich text editor should be rendered on touch devices (wysihtml5 >= 0.3.0 comes with basic support for iOS 5)\n    supportTouchDevices: true\n  };\n\n  wysihtml5.Editor = wysihtml5.lang.Dispatcher.extend(\n  /** @scope wysihtml5.Editor.prototype */{\n    constructor: function constructor(textareaElement, config) {\n      this.textareaElement = typeof textareaElement === "string" ? document.getElementById(textareaElement) : textareaElement;\n      this.config = wysihtml5.lang.object({}).merge(defaultConfig).merge(config).get();\n      this.textarea = new wysihtml5.views.Textarea(this, this.textareaElement, this.config);\n      this.currentView = this.textarea;\n      this._isCompatible = wysihtml5.browser.supported();\n\n      // Sort out unsupported/unwanted browsers here\n      if (!this._isCompatible || !this.config.supportTouchDevices && wysihtml5.browser.isTouchDevice()) {\n        var that = this;\n        setTimeout(function () {\n          that.fire("beforeload").fire("load");\n        }, 0);\n        return;\n      }\n\n      // Add class name to body, to indicate that the editor is supported\n      wysihtml5.dom.addClass(document.body, this.config.bodyClassName);\n\n      this.composer = new wysihtml5.views.Composer(this, this.textareaElement, this.config);\n      this.currentView = this.composer;\n\n      if (typeof this.config.parser === "function") {\n        this._initParser();\n      }\n\n      this.observe("beforeload", function () {\n        this.synchronizer = new wysihtml5.views.Synchronizer(this, this.textarea, this.composer);\n        if (this.config.toolbar) {\n          this.toolbar = new wysihtml5.toolbar.Toolbar(this, this.config.toolbar);\n        }\n      });\n\n      try {\n        console.log("Heya! This page is using wysihtml5 for rich text editing. Check out https://github.com/xing/wysihtml5");\n      } catch (e) {}\n    },\n\n    isCompatible: function isCompatible() {\n      return this._isCompatible;\n    },\n\n    clear: function clear() {\n      this.currentView.clear();\n      return this;\n    },\n\n    getValue: function getValue(parse) {\n      return this.currentView.getValue(parse);\n    },\n\n    setValue: function setValue(html, parse) {\n      if (!html) {\n        return this.clear();\n      }\n      this.currentView.setValue(html, parse);\n      return this;\n    },\n\n    focus: function focus(setToEnd) {\n      this.currentView.focus(setToEnd);\n      return this;\n    },\n\n    /**\n     * Deactivate editor (make it readonly)\n     */\n    disable: function disable() {\n      this.currentView.disable();\n      return this;\n    },\n\n    /**\n     * Activate editor\n     */\n    enable: function enable() {\n      this.currentView.enable();\n      return this;\n    },\n\n    isEmpty: function isEmpty() {\n      return this.currentView.isEmpty();\n    },\n\n    hasPlaceholderSet: function hasPlaceholderSet() {\n      return this.currentView.hasPlaceholderSet();\n    },\n\n    parse: function parse(htmlOrElement) {\n      var returnValue = this.config.parser(htmlOrElement, this.config.parserRules, this.composer.sandbox.getDocument(), true);\n      if ((typeof htmlOrElement === "undefined" ? "undefined" : _typeof(htmlOrElement)) === "object") {\n        wysihtml5.quirks.redraw(htmlOrElement);\n      }\n      return returnValue;\n    },\n\n    /**\n     * Prepare html parser logic\n     *  - Observes for paste and drop\n     */\n    _initParser: function _initParser() {\n      this.observe("paste:composer", function () {\n        var keepScrollPosition = true,\n            that = this;\n        that.composer.selection.executeAndRestore(function () {\n          wysihtml5.quirks.cleanPastedHTML(that.composer.element);\n          that.parse(that.composer.element);\n        }, keepScrollPosition);\n      });\n\n      this.observe("paste:textarea", function () {\n        var value = this.textarea.getValue(),\n            newValue;\n        newValue = this.parse(value);\n        this.textarea.setValue(newValue);\n      });\n    }\n  });\n})(wysihtml5);\n/**\nBootstrap wysihtml5 editor. Based on [bootstrap-wysihtml5](https://github.com/jhollingworth/bootstrap-wysihtml5).  \nYou should include **manually** distributives of `wysihtml5` and `bootstrap-wysihtml5`:\n\n    <link href="js/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/bootstrap-wysihtml5-0.0.2.css" rel="stylesheet" type="text/css"></link>  \n    <script src="js/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/wysihtml5-0.3.0.min.js"><\/script>  \n    <script src="js/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/bootstrap-wysihtml5-0.0.2.min.js"><\/script>\n    \nAnd also include `wysihtml5.js` from `inputs-ext` directory of x-editable:\n      \n    <script src="js/inputs-ext/wysihtml5/wysihtml5.js"><\/script>  \n\n**Note:** It\'s better to use fresh bootstrap-wysihtml5 from it\'s [master branch](https://github.com/jhollingworth/bootstrap-wysihtml5/tree/master/src) as there is update for correct image insertion.    \n    \n@class wysihtml5\n@extends abstractinput\n@final\n@since 1.4.0\n@example\n<div id="comments" data-type="wysihtml5" data-pk="1"><h2>awesome</h2> comment!</div>\n<script>\n$(function(){\n    $(\'#comments\').editable({\n        url: \'/post\',\n        title: \'Enter comments\'\n    });\n});\n<\/script>\n**/\n(function ($) {\n\n  window.Wysihtml5 = function Wysihtml5(options) {\n    this.init(\'wysihtml5\', options, Wysihtml5.defaults);\n\n    //extend wysihtml5 manually as $.extend not recursive \n    this.options.wysihtml5 = $.extend({}, Wysihtml5.defaults.wysihtml5, options.wysihtml5);\n  };\n\n  window.$.fn.editableutils.inherit(Wysihtml5, window.$.fn.editabletypes.abstractinput);\n\n  $.extend(Wysihtml5.prototype, {\n    render: function render() {\n      var deferred = $.Deferred(),\n          msieOld;\n\n      //generate unique id as it required for wysihtml5\n      this.$input.attr(\'id\', \'textarea_\' + new Date().getTime());\n\n      this.setClass();\n      this.setAttr(\'placeholder\');\n\n      //resolve deffered when widget loaded\n      $.extend(this.options.wysihtml5, {\n        events: {\n          load: function load() {\n            deferred.resolve();\n          }\n        }\n      });\n\n      this.$input.wysihtml5(this.options.wysihtml5);\n\n      /*\n       In IE8 wysihtml5 iframe stays on the same line with buttons toolbar (inside popover).\n       The only solution I found is to add <br>. If you fine better way, please send PR.   \n      */\n      msieOld = /msie\\s*(8|7|6)/.test(navigator.userAgent.toLowerCase());\n      if (msieOld) {\n        this.$input.before(\'<br><br>\');\n      }\n\n      return deferred.promise();\n    },\n\n    value2html: function value2html(value, element) {\n      $(element).html(value);\n    },\n\n    html2value: function html2value(html) {\n      return html;\n    },\n\n    value2input: function value2input(value) {\n      this.$input.data("wysihtml5").editor.setValue(value, true);\n    },\n\n    activate: function activate() {\n      this.$input.data("wysihtml5").editor.focus();\n    },\n\n    isEmpty: function isEmpty($element) {\n      if ($.trim($element.html()) === \'\') {\n        return true;\n      } else if ($.trim($element.text()) !== \'\') {\n        return false;\n      } else {\n        //e.g. \'<img>\', \'<br>\', \'<p></p>\'\n        return !$element.height() || !$element.width();\n      }\n    }\n  });\n\n  Wysihtml5.defaults = $.extend({}, window.$.fn.editabletypes.abstractinput.defaults, {\n    /**\n    @property tpl\n    @default <textarea></textarea>\n    **/\n    tpl: \'<textarea></textarea>\',\n    /**\n    @property inputclass\n    @default editable-wysihtml5\n    **/\n    inputclass: \'editable-wysihtml5\',\n    /**\n    Placeholder attribute of input. Shown when input is empty.\n     @property placeholder\n    @type string\n    @default null\n    **/\n    placeholder: null,\n    /**\n    Wysihtml5 default options.  \n    See https://github.com/jhollingworth/bootstrap-wysihtml5#options\n     @property wysihtml5\n    @type object\n    @default {stylesheets: false}\n    **/\n    wysihtml5: {\n      stylesheets: false\n    }\n  });\n\n  window.$.fn.editabletypes.wysihtml5 = Wysihtml5;\n})(window.jQuery);\n\n!function ($, wysi) {\n\n  var tpl = {\n    "font-styles": function fontStyles(locale, options) {\n      var size = options && options.size ? \' btn-\' + options.size : \'\';\n      return "<li class=\'dropdown\'>" + "<a class=\'btn btn-default dropdown-toggle" + size + "\' data-toggle=\'dropdown\' href=\'#\'>" + "<i class=\'fa fa-font\'></i>&nbsp;<span class=\'current-font\'>" + locale.font_styles.normal + "</span>&nbsp;<b class=\'caret\'></b>" + "</a>" + "<ul class=\'dropdown-menu\'>" + "<li><a data-wysihtml5-command=\'formatBlock\' data-wysihtml5-command-value=\'div\' tabindex=\'-1\'>" + locale.font_styles.normal + "</a></li>" + "<li><a data-wysihtml5-command=\'formatBlock\' data-wysihtml5-command-value=\'h1\' tabindex=\'-1\'>" + locale.font_styles.h1 + "</a></li>" + "<li><a data-wysihtml5-command=\'formatBlock\' data-wysihtml5-command-value=\'h2\' tabindex=\'-1\'>" + locale.font_styles.h2 + "</a></li>" + "<li><a data-wysihtml5-command=\'formatBlock\' data-wysihtml5-command-value=\'h3\' tabindex=\'-1\'>" + locale.font_styles.h3 + "</a></li>" + "</ul>" + "</li>";\n    },\n\n    "emphasis": function emphasis(locale, options) {\n      var size = options && options.size ? \' btn-\' + options.size : \'\';\n      return "<li>" + "<div class=\'btn-group\'>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'bold\' title=\'CTRL+B\' tabindex=\'-1\'>" + locale.emphasis.bold + "</a>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'italic\' title=\'CTRL+I\' tabindex=\'-1\'>" + locale.emphasis.italic + "</a>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'underline\' title=\'CTRL+U\' tabindex=\'-1\'>" + locale.emphasis.underline + "</a>" + "</div>" + "</li>";\n    },\n\n    "lists": function lists(locale, options) {\n      var size = options && options.size ? \' btn-\' + options.size : \'\';\n      return "<li>" + "<div class=\'btn-group\'>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'insertUnorderedList\' title=\'" + locale.lists.unordered + "\' tabindex=\'-1\'><i class=\'fa fa-list\'></i></a>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'insertOrderedList\' title=\'" + locale.lists.ordered + "\' tabindex=\'-1\'><i class=\'fa fa-th-list\'></i></a>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'clear\' title=\'ban\' tabindex=\'-1\'><i class=\'fa fa-ban\'></i></a>" + "</div>" + "</li>";\n    },\n\n    "link": function link(locale, options) {\n      var size = options && options.size ? \' btn-\' + options.size : \'\';\n      return "<li>" + "<div class=\'bootstrap-wysihtml5-insert-link-modal modal hide fade\'>" + "<div class=\'modal-header\'>" + "<a class=\'close\' data-dismiss=\'modal\'>&times;</a>" + "<h3>" + locale.link.insert + "</h3>" + "</div>" + "<div class=\'modal-body\'>" + "<input value=\'http://\' class=\'bootstrap-wysihtml5-insert-link-url input-xlarge\'>" + "</div>" + "<div class=\'modal-footer\'>" + "<a href=\'#\' class=\'btn btn-default\' data-dismiss=\'modal\'>" + locale.link.cancel + "</a>" + "<a href=\'#\' class=\'btn btn-primary\' data-dismiss=\'modal\'>" + locale.link.insert + "</a>" + "</div>" + "</div>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'createLink\' title=\'" + locale.link.insert + "\' tabindex=\'-1\'><i class=\'fa fa-share\'></i></a>" + "</li>";\n    },\n\n    "image": function image(locale, options) {\n      var size = options && options.size ? \' btn-\' + options.size : \'\';\n      return "<li>" + "<div class=\'bootstrap-wysihtml5-insert-image-modal modal hide fade\'>" + "<div class=\'modal-header\'>" + "<a class=\'close\' data-dismiss=\'modal\'>&times;</a>" + "<h3>" + locale.image.insert + "</h3>" + "</div>" + "<div class=\'modal-body\'>" + "<input value=\'http://\' class=\'bootstrap-wysihtml5-insert-image-url input-xlarge\'>" + "</div>" + "<div class=\'modal-footer\'>" + "<a href=\'#\' class=\'btn btn-default\' data-dismiss=\'modal\'>" + locale.image.cancel + "</a>" + "<a href=\'#\' class=\'btn btn-primary\' data-dismiss=\'modal\'>" + locale.image.insert + "</a>" + "</div>" + "</div>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'insertImage\' title=\'" + locale.image.insert + "\' tabindex=\'-1\'><i class=\'fa fa-picture\'></i></a>" + "</li>";\n    },\n\n    "html": function html(locale, options) {\n      var size = options && options.size ? \' btn-\' + options.size : \'\';\n      return "<li>" + "<div class=\'btn-group\'>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-action=\'change_view\' title=\'" + locale.html.edit + "\' tabindex=\'-1\'><i class=\'fa fa-pencil\'></i></a>" + "</div>" + "</li>";\n    },\n\n    "color": function color(locale, options) {\n      var size = options && options.size ? \' btn-\' + options.size : \'\';\n      return "<li class=\'dropdown\'>" + "<a class=\'btn btn-default dropdown-toggle" + size + "\' data-toggle=\'dropdown\' href=\'#\' tabindex=\'-1\'>" + "<span class=\'current-color\'>原色</span>&nbsp;<b class=\'caret\'></b>" + "</a>" + "<ul class=\'dropdown-menu\'>" + "<li><div class=\'wysihtml5-colors\' data-wysihtml5-command-value=\'clear\'></div><a class=\'wysihtml5-colors-title\' data-wysihtml5-command=\'foreColor\' data-wysihtml5-command-value=\'clear\'>" + locale.colours.clear + "</a></li>" + "<li><div class=\'wysihtml5-colors\' data-wysihtml5-command-value=\'first\'></div><a class=\'wysihtml5-colors-title\' data-wysihtml5-command=\'foreColor\' data-wysihtml5-command-value=\'first\'>" + locale.colours.first + "</a></li>" + "<li><div class=\'wysihtml5-colors\' data-wysihtml5-command-value=\'second\'></div><a class=\'wysihtml5-colors-title\' data-wysihtml5-command=\'foreColor\' data-wysihtml5-command-value=\'second\'>" + locale.colours.second + "</a></li>" + "<li><div class=\'wysihtml5-colors\' data-wysihtml5-command-value=\'three\'></div><a class=\'wysihtml5-colors-title\' data-wysihtml5-command=\'foreColor\' data-wysihtml5-command-value=\'three\'>" + locale.colours.three + "</a></li>" + "</ul>" + "</li>";\n    }\n  };\n\n  var templates = function templates(key, locale, options) {\n    return tpl[key](locale, options);\n  };\n\n  var Wysihtml5 = function Wysihtml5(el, options) {\n    this.el = el;\n    var toolbarOpts = options || defaultOptions;\n    for (var t in toolbarOpts.customTemplates) {\n      tpl[t] = toolbarOpts.customTemplates[t];\n    }\n    this.toolbar = this.createToolbar(el, toolbarOpts);\n    this.editor = this.createEditor(options);\n\n    window.editor = this.editor;\n\n    $(\'iframe.wysihtml5-sandbox\').each(function (i, el) {\n      $(el.contentWindow).off(\'focus.wysihtml5\').on({\n        \'focus.wysihtml5\': function focusWysihtml5() {\n          $(\'li.dropdown\').removeClass(\'open\');\n        }\n      });\n    });\n  };\n\n  Wysihtml5.prototype = {\n\n    constructor: Wysihtml5,\n\n    createEditor: function createEditor(options) {\n      options = options || {};\n\n      // Add the toolbar to a clone of the options object so multiple instances\n      // of the WYISYWG don\'t break because "toolbar" is already defined\n      options = $.extend(true, {}, options);\n      options.toolbar = this.toolbar[0];\n\n      var editor = new wysihtml5.Editor(this.el[0], options);\n\n      if (options && options.events) {\n        for (var eventName in options.events) {\n          editor.on(eventName, options.events[eventName]);\n        }\n      }\n      return editor;\n    },\n\n    createToolbar: function createToolbar(el, options) {\n      var self = this;\n      var toolbar = $("<ul/>", {\n        \'class\': "wysihtml5-toolbar",\n        \'style\': "display:none"\n      });\n      var culture = options.locale || defaultOptions.locale || "en";\n      for (var key in window.$.fn.wysihtml5.defaultOptions) {\n        var value = false;\n\n        if (options[key] !== undefined) {\n          if (options[key] === true) {\n            value = true;\n          }\n        } else {\n          value = defaultOptions[key];\n        }\n\n        if (value === true) {\n          toolbar.append(templates(key, locale[culture], options));\n\n          if (key === "html") {\n            this.initHtml(toolbar);\n          }\n\n          if (key === "link") {\n            this.initInsertLink(toolbar);\n          }\n\n          if (key === "image") {\n            this.initInsertImage(toolbar);\n          }\n        }\n      }\n\n      if (options.toolbar) {\n        for (key in options.toolbar) {\n          toolbar.append(options.toolbar[key]);\n        }\n      }\n\n      toolbar.find("a[data-wysihtml5-command=\'formatBlock\']").click(function (e) {\n        var target = e.target || e.srcElement;\n        var el = $(target);\n        self.toolbar.find(\'.current-font\').text(el.html());\n      });\n\n      toolbar.find("a[data-wysihtml5-command=\'foreColor\']").click(function (e) {\n        var target = e.target || e.srcElement;\n        var el = $(target);\n        self.toolbar.find(\'.current-color\').text(el.html());\n      });\n\n      this.el.before(toolbar);\n\n      return toolbar;\n    },\n\n    initHtml: function initHtml(toolbar) {\n      var changeViewSelector = "a[data-wysihtml5-action=\'change_view\']";\n      toolbar.find(changeViewSelector).click(function (e) {\n        toolbar.find(\'a.btn\').not(changeViewSelector).toggleClass(\'disabled\');\n      });\n    },\n\n    initInsertImage: function initInsertImage(toolbar) {\n      var self = this;\n      var insertImageModal = toolbar.find(\'.bootstrap-wysihtml5-insert-image-modal\');\n      var urlInput = insertImageModal.find(\'.bootstrap-wysihtml5-insert-image-url\');\n      var insertButton = insertImageModal.find(\'a.btn-primary\');\n      var initialValue = urlInput.val();\n      var caretBookmark;\n\n      var insertImage = function insertImage() {\n        var url = urlInput.val();\n        urlInput.val(initialValue);\n        self.editor.currentView.element.focus();\n        if (caretBookmark) {\n          self.editor.composer.selection.setBookmark(caretBookmark);\n          caretBookmark = null;\n        }\n        self.editor.composer.commands.exec("insertImage", url);\n      };\n\n      urlInput.keypress(function (e) {\n        if (e.which == 13) {\n          insertImage();\n          insertImageModal.modal(\'hide\');\n        }\n      });\n\n      insertButton.click(insertImage);\n\n      insertImageModal.on(\'shown\', function () {\n        urlInput.focus();\n      });\n\n      insertImageModal.on(\'hide\', function () {\n        self.editor.currentView.element.focus();\n      });\n\n      toolbar.find(\'a[data-wysihtml5-command=insertImage]\').click(function () {\n        var activeButton = $(this).hasClass("wysihtml5-command-active");\n\n        if (!activeButton) {\n          self.editor.currentView.element.focus(false);\n          caretBookmark = self.editor.composer.selection.getBookmark();\n          insertImageModal.appendTo(\'body\').modal(\'show\');\n          insertImageModal.on(\'click.dismiss.modal\', \'[data-dismiss="modal"]\', function (e) {\n            e.stopPropagation();\n          });\n          return false;\n        } else {\n          return true;\n        }\n      });\n    },\n\n    initInsertLink: function initInsertLink(toolbar) {\n      var self = this;\n      var insertLinkModal = toolbar.find(\'.bootstrap-wysihtml5-insert-link-modal\');\n      var urlInput = insertLinkModal.find(\'.bootstrap-wysihtml5-insert-link-url\');\n      var insertButton = insertLinkModal.find(\'a.btn-primary\');\n      var initialValue = urlInput.val();\n      var caretBookmark;\n\n      var insertLink = function insertLink() {\n        var url = urlInput.val();\n        urlInput.val(initialValue);\n        self.editor.currentView.element.focus();\n        if (caretBookmark) {\n          self.editor.composer.selection.setBookmark(caretBookmark);\n          caretBookmark = null;\n        }\n        self.editor.composer.commands.exec("createLink", {\n          href: url,\n          target: "_blank",\n          rel: "nofollow"\n        });\n      };\n      var pressedEnter = false;\n\n      urlInput.keypress(function (e) {\n        if (e.which == 13) {\n          insertLink();\n          insertLinkModal.modal(\'hide\');\n        }\n      });\n\n      insertButton.click(insertLink);\n\n      insertLinkModal.on(\'shown\', function () {\n        urlInput.focus();\n      });\n\n      insertLinkModal.on(\'hide\', function () {\n        self.editor.currentView.element.focus();\n      });\n\n      toolbar.find(\'a[data-wysihtml5-command=createLink]\').click(function () {\n        var activeButton = $(this).hasClass("wysihtml5-command-active");\n\n        if (!activeButton) {\n          self.editor.currentView.element.focus(false);\n          caretBookmark = self.editor.composer.selection.getBookmark();\n          insertLinkModal.appendTo(\'body\').modal(\'show\');\n          insertLinkModal.on(\'click.dismiss.modal\', \'[data-dismiss="modal"]\', function (e) {\n            e.stopPropagation();\n          });\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n  };\n\n  // these define our public api\n  var methods = {\n    resetDefaults: function resetDefaults() {\n      window.$.fn.wysihtml5.defaultOptions = $.extend(true, {}, window.$.fn.wysihtml5.defaultOptionsCache);\n    },\n    bypassDefaults: function bypassDefaults(options) {\n      return this.each(function () {\n        var $this = $(this);\n        $this.data(\'wysihtml5\', new Wysihtml5($this, options));\n      });\n    },\n    shallowExtend: function shallowExtend(options) {\n      var settings = $.extend({}, window.$.fn.wysihtml5.defaultOptions, options || {});\n      var that = this;\n      return methods.bypassDefaults.apply(that, [settings]);\n    },\n    deepExtend: function deepExtend(options) {\n      var settings = $.extend(true, {}, window.$.fn.wysihtml5.defaultOptions, options || {});\n      var that = this;\n      return methods.bypassDefaults.apply(that, [settings]);\n    },\n    init: function init(options) {\n      var that = this;\n      return methods.shallowExtend.apply(that, [options]);\n    }\n  };\n\n  window.$.fn.wysihtml5 = function (method) {\n    if (methods[method]) {\n      return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n    } else if ((typeof method === "undefined" ? "undefined" : _typeof(method)) === \'object\' || !method) {\n      return methods.init.apply(this, arguments);\n    } else {\n      $.error(\'Method \' + method + \' does not exist on jQuery.wysihtml5\');\n    }\n  };\n\n  window.$.fn.wysihtml5.Constructor = Wysihtml5;\n\n  window.$.fn.wysihtml5.defaultOptions = {\n    "font-styles": true,\n    "color": false,\n    "emphasis": true,\n    "lists": true,\n    "html": false,\n    "link": true,\n    "image": true,\n    events: {},\n    parserRules: {\n      classes: {\n        // (path_to_project/lib/css/wysiwyg-color.css)\n        "wysiwyg-color-clear": 1,\n        "wysiwyg-color-first": 1,\n        "wysiwyg-color-second": 1,\n        "wysiwyg-color-three": 1\n      },\n      tags: {\n        "b": {},\n        "i": {},\n        "br": {},\n        "ol": {},\n        "ul": {},\n        "li": {},\n        "h1": {},\n        "h2": {},\n        "h3": {},\n        "blockquote": {},\n        "u": 1,\n        "img": {\n          "check_attributes": {\n            "width": "numbers",\n            "alt": "alt",\n            "src": "url",\n            "height": "numbers"\n          }\n        },\n        "a": {\n          set_attributes: {\n            target: "_blank",\n            rel: "nofollow"\n          },\n          check_attributes: {\n            href: "url" // important to avoid XSS\n          }\n        },\n        "span": 1,\n        "div": 1,\n        // to allow save and edit files with code tag hacks\n        "code": 1,\n        "pre": 1\n      }\n    },\n    stylesheets: ["./lib/css/wysiwyg-color.css"], // (path_to_project/lib/css/wysiwyg-color.css)\n    locale: "en"\n  };\n\n  if (typeof window.$.fn.wysihtml5.defaultOptionsCache === \'undefined\') {\n    window.$.fn.wysihtml5.defaultOptionsCache = $.extend(true, {}, window.$.fn.wysihtml5.defaultOptions);\n  }\n\n  var locale = window.$.fn.wysihtml5.locale = {\n    en: {\n      font_styles: {\n        normal: "Normal text",\n        h1: "Heading 1",\n        h2: "Heading 2",\n        h3: "Heading 3"\n      },\n      emphasis: {\n        bold: "Bold",\n        italic: "Italic",\n        underline: "Underline"\n      },\n      lists: {\n        unordered: "Unordered list",\n        ordered: "Ordered list",\n        outdent: "Outdent",\n        indent: "Indent"\n      },\n      link: {\n        insert: "Insert link",\n        cancel: "Cancel"\n      },\n      image: {\n        insert: "Insert image",\n        cancel: "Cancel"\n      },\n      html: {\n        edit: "Edit HTML"\n      },\n      colours: {\n        clear: "Clear",\n        first: "首选",\n        second: "次选",\n        three: "备选",\n        black: "Black",\n        silver: "Silver",\n        gray: "Grey",\n        maroon: "Maroon",\n        red: "Red",\n        purple: "Purple",\n        green: "Green",\n        olive: "Olive",\n        navy: "Navy",\n        blue: "Blue",\n        orange: "Orange"\n      }\n    }\n  };\n}(window.jQuery, window.wysihtml5);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvanMvd3lzaWh0bWw1LmpzPzJiYjYiXSwibmFtZXMiOlsiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwib2JqIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJ3eXNpaHRtbDUiLCJ2ZXJzaW9uIiwiY29tbWFuZHMiLCJkb20iLCJxdWlya3MiLCJ0b29sYmFyIiwibGFuZyIsInNlbGVjdGlvbiIsInZpZXdzIiwiSU5WSVNJQkxFX1NQQUNFIiwiRU1QVFlfRlVOQ1RJT04iLCJFTEVNRU5UX05PREUiLCJURVhUX05PREUiLCJCQUNLU1BBQ0VfS0VZIiwiRU5URVJfS0VZIiwiRVNDQVBFX0tFWSIsIlNQQUNFX0tFWSIsIkRFTEVURV9LRVkiLCJ3aW5kb3ciLCJPQkpFQ1QiLCJGVU5DVElPTiIsIlVOREVGSU5FRCIsImRvbVJhbmdlUHJvcGVydGllcyIsImRvbVJhbmdlTWV0aG9kcyIsInRleHRSYW5nZVByb3BlcnRpZXMiLCJ0ZXh0UmFuZ2VNZXRob2RzIiwiaXNIb3N0TWV0aG9kIiwibyIsInAiLCJ0IiwiaXNIb3N0T2JqZWN0IiwiaXNIb3N0UHJvcGVydHkiLCJjcmVhdGVNdWx0aXBsZVByb3BlcnR5VGVzdCIsInRlc3RGdW5jIiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiYXJlSG9zdE1ldGhvZHMiLCJhcmVIb3N0T2JqZWN0cyIsImFyZUhvc3RQcm9wZXJ0aWVzIiwiaXNUZXh0UmFuZ2UiLCJyYW5nZSIsImFwaSIsImluaXRpYWxpemVkIiwic3VwcG9ydGVkIiwidXRpbCIsImZlYXR1cmVzIiwibW9kdWxlcyIsImNvbmZpZyIsImFsZXJ0T25XYXJuIiwicHJlZmVyVGV4dFJhbmdlIiwiZmFpbCIsInJlYXNvbiIsImFsZXJ0Iiwid2FybiIsIm1zZyIsIndhcm5pbmdNZXNzYWdlIiwiY29uc29sZSIsImxvZyIsImhhc093blByb3BlcnR5IiwiZXh0ZW5kIiwiaW5pdExpc3RlbmVycyIsIm1vZHVsZUluaXRpYWxpemVycyIsImluaXQiLCJ0ZXN0UmFuZ2UiLCJpbXBsZW1lbnRzRG9tUmFuZ2UiLCJpbXBsZW1lbnRzVGV4dFJhbmdlIiwiZG9jdW1lbnQiLCJjcmVhdGVSYW5nZSIsImRldGFjaCIsImJvZHkiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNyZWF0ZVRleHRSYW5nZSIsImFsbExpc3RlbmVycyIsImNvbmNhdCIsImxlbiIsImV4IiwiYWRkSW5pdExpc3RlbmVyIiwibGlzdGVuZXIiLCJwdXNoIiwiY3JlYXRlTWlzc2luZ05hdGl2ZUFwaUxpc3RlbmVycyIsImFkZENyZWF0ZU1pc3NpbmdOYXRpdmVBcGlMaXN0ZW5lciIsImNyZWF0ZU1pc3NpbmdOYXRpdmVBcGkiLCJ3aW4iLCJNb2R1bGUiLCJuYW1lIiwiRXJyb3IiLCJjcmVhdGVFcnJvciIsImNyZWF0ZU1vZHVsZSIsImluaXRGdW5jIiwibW9kdWxlIiwicmVxdWlyZU1vZHVsZXMiLCJtb2R1bGVOYW1lIiwiZG9jUmVhZHkiLCJsb2FkSGFuZGxlciIsImUiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJyYW5neSIsIlVOREVGIiwiZWwiLCJjcmVhdGVFbGVtZW50IiwidGV4dE5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsImFycmF5Q29udGFpbnMiLCJhcnIiLCJ2YWwiLCJpc0h0bWxOYW1lc3BhY2UiLCJub2RlIiwibnMiLCJuYW1lc3BhY2VVUkkiLCJwYXJlbnRFbGVtZW50IiwicGFyZW50IiwicGFyZW50Tm9kZSIsIm5vZGVUeXBlIiwiZ2V0Tm9kZUluZGV4IiwicHJldmlvdXNTaWJsaW5nIiwiZ2V0Tm9kZUxlbmd0aCIsImNoaWxkTm9kZXMiLCJpc0NoYXJhY3RlckRhdGFOb2RlIiwiZ2V0Q29tbW9uQW5jZXN0b3IiLCJub2RlMSIsIm5vZGUyIiwiYW5jZXN0b3JzIiwibiIsImlzQW5jZXN0b3JPZiIsImFuY2VzdG9yIiwiZGVzY2VuZGFudCIsInNlbGZJc0FuY2VzdG9yIiwiZ2V0Q2xvc2VzdEFuY2VzdG9ySW4iLCJpbnNlcnRBZnRlciIsInByZWNlZGluZ05vZGUiLCJuZXh0Tm9kZSIsIm5leHRTaWJsaW5nIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJzcGxpdERhdGFOb2RlIiwiaW5kZXgiLCJuZXdOb2RlIiwiY2xvbmVOb2RlIiwiZGVsZXRlRGF0YSIsImdldERvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsImdldFdpbmRvdyIsImRvYyIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwiZ2V0SWZyYW1lRG9jdW1lbnQiLCJpZnJhbWVFbCIsImNvbnRlbnREb2N1bWVudCIsImNvbnRlbnRXaW5kb3ciLCJnZXRJZnJhbWVXaW5kb3ciLCJnZXRCb2R5IiwiZ2V0Um9vdENvbnRhaW5lciIsImNvbXBhcmVQb2ludHMiLCJub2RlQSIsIm9mZnNldEEiLCJub2RlQiIsIm9mZnNldEIiLCJub2RlQyIsInJvb3QiLCJjaGlsZEEiLCJjaGlsZEIiLCJmaXJzdENoaWxkIiwiZnJhZ21lbnRGcm9tTm9kZUNoaWxkcmVuIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiY2hpbGQiLCJpbnNwZWN0Tm9kZSIsImRhdGEiLCJpZEF0dHIiLCJpZCIsIm5vZGVOYW1lIiwiTm9kZUl0ZXJhdG9yIiwiX25leHQiLCJfY3VycmVudCIsImhhc05leHQiLCJuZXh0IiwiY3JlYXRlSXRlcmF0b3IiLCJEb21Qb3NpdGlvbiIsIm9mZnNldCIsImVxdWFscyIsInBvcyIsImluc3BlY3QiLCJET01FeGNlcHRpb24iLCJjb2RlTmFtZSIsImNvZGUiLCJtZXNzYWdlIiwiSU5ERVhfU0laRV9FUlIiLCJISUVSQVJDSFlfUkVRVUVTVF9FUlIiLCJXUk9OR19ET0NVTUVOVF9FUlIiLCJOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlIiLCJOT1RfRk9VTkRfRVJSIiwiTk9UX1NVUFBPUlRFRF9FUlIiLCJJTlZBTElEX1NUQVRFX0VSUiIsInRvU3RyaW5nIiwiaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQiLCJzdGFydENvbnRhaW5lciIsImVuZENvbnRhaW5lciIsImdldFJhbmdlRG9jdW1lbnQiLCJkaXNwYXRjaEV2ZW50IiwidHlwZSIsImFyZ3MiLCJsaXN0ZW5lcnMiLCJfbGlzdGVuZXJzIiwiY2FsbCIsInRhcmdldCIsImdldEJvdW5kYXJ5QmVmb3JlTm9kZSIsImdldEJvdW5kYXJ5QWZ0ZXJOb2RlIiwiaW5zZXJ0Tm9kZUF0UG9zaXRpb24iLCJmaXJzdE5vZGVJbnNlcnRlZCIsImNsb25lU3VidHJlZSIsInBhcnRpYWxseVNlbGVjdGVkIiwiZnJhZyIsInN1Ykl0ZXJhdG9yIiwiaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUiLCJnZXRTdWJ0cmVlSXRlcmF0b3IiLCJpdGVyYXRlU3VidHJlZSIsInJhbmdlSXRlcmF0b3IiLCJmdW5jIiwiaXRlcmF0b3JTdGF0ZSIsIml0Iiwic3RvcCIsInN1YlJhbmdlSXRlcmF0b3IiLCJkZWxldGVTdWJ0cmVlIiwicmVtb3ZlIiwiZXh0cmFjdFN1YnRyZWUiLCJnZXROb2Rlc0luUmFuZ2UiLCJub2RlVHlwZXMiLCJmaWx0ZXIiLCJmaWx0ZXJOb2RlVHlwZXMiLCJyZWdleCIsImZpbHRlckV4aXN0cyIsIlJlZ0V4cCIsImpvaW4iLCJub2RlcyIsIlJhbmdlSXRlcmF0b3IiLCJ0ZXN0IiwiX2luc3BlY3QiLCJnZXROYW1lIiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJjbG9uZVBhcnRpYWxseVNlbGVjdGVkVGV4dE5vZGVzIiwiY29sbGFwc2VkIiwic2MiLCJzbyIsImVjIiwiZW8iLCJjb21tb25BbmNlc3RvckNvbnRhaW5lciIsImlzU2luZ2xlQ2hhcmFjdGVyRGF0YU5vZGUiLCJfZmlyc3QiLCJfbGFzdCIsInJlc2V0IiwiY3VycmVudCIsInN0YXJ0IiwiZW5kIiwicmVtb3ZlQ2hpbGQiLCJzdWJSYW5nZSIsImNsb25lUmFuZ2UiLCJjb2xsYXBzZSIsIlJhbmdlIiwidXBkYXRlQm91bmRhcmllcyIsImRldGFjaFJhbmdlIiwiUmFuZ2VFeGNlcHRpb24iLCJCQURfQk9VTkRBUllQT0lOVFNfRVJSIiwiSU5WQUxJRF9OT0RFX1RZUEVfRVJSIiwiUmFuZ2VOb2RlSXRlcmF0b3IiLCJfcG9zaXRpb24iLCJiZWZvcmVBZnRlck5vZGVUeXBlcyIsInJvb3RDb250YWluZXJOb2RlVHlwZXMiLCJyZWFkb25seU5vZGVUeXBlcyIsImluc2VydGFibGVOb2RlVHlwZXMiLCJzdXJyb3VuZE5vZGVUeXBlcyIsImNyZWF0ZUFuY2VzdG9yRmluZGVyIiwiZ2V0RG9jdW1lbnRPckZyYWdtZW50Q29udGFpbmVyIiwiZ2V0UmVhZG9ubHlBbmNlc3RvciIsImdldERvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yIiwiYXNzZXJ0Tm9Eb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3RvciIsImFsbG93U2VsZiIsImFzc2VydE5vdERldGFjaGVkIiwiYXNzZXJ0VmFsaWROb2RlVHlwZSIsImludmFsaWRUeXBlcyIsImFzc2VydFZhbGlkT2Zmc2V0IiwiYXNzZXJ0U2FtZURvY3VtZW50T3JGcmFnbWVudCIsImFzc2VydE5vZGVOb3RSZWFkT25seSIsImFzc2VydE5vZGUiLCJpc09ycGhhbiIsImlzVmFsaWRPZmZzZXQiLCJhc3NlcnRSYW5nZVZhbGlkIiwic3R5bGVFbCIsImh0bWxQYXJzaW5nQ29uZm9ybXMiLCJpbm5lckhUTUwiLCJjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQiLCJmcmFnbWVudFN0ciIsImRvY3VtZW50RWxlbWVudCIsInJhbmdlUHJvcGVydGllcyIsInMycyIsInMyZSIsImUyZSIsImUycyIsIm5fYiIsIm5fYSIsIm5fYl9hIiwibl9pIiwiUmFuZ2VQcm90b3R5cGUiLCJhdHRhY2hMaXN0ZW5lciIsImNvbXBhcmVCb3VuZGFyeVBvaW50cyIsImhvdyIsInByZWZpeEEiLCJwcmVmaXhCIiwiaW5zZXJ0Tm9kZSIsInNldFN0YXJ0QmVmb3JlIiwiY2xvbmVDb250ZW50cyIsImNsb25lIiwic2xpY2UiLCJjYW5TdXJyb3VuZENvbnRlbnRzIiwiYm91bmRhcmllc0ludmFsaWQiLCJzdXJyb3VuZENvbnRlbnRzIiwiY29udGVudCIsImV4dHJhY3RDb250ZW50cyIsImhhc0NoaWxkTm9kZXMiLCJsYXN0Q2hpbGQiLCJzZWxlY3ROb2RlIiwicHJvcCIsInRleHRCaXRzIiwiY29tcGFyZU5vZGUiLCJub2RlSW5kZXgiLCJzdGFydENvbXBhcmlzb24iLCJjb21wYXJlUG9pbnQiLCJlbmRDb21wYXJpc29uIiwidG9IdG1sIiwiY29udGFpbmVyIiwiaW50ZXJzZWN0c05vZGUiLCJ0b3VjaGluZ0lzSW50ZXJzZWN0aW5nIiwiaXNQb2ludEluUmFuZ2UiLCJpbnRlcnNlY3RzUmFuZ2UiLCJpbnRlcnNlY3Rpb24iLCJpbnRlcnNlY3Rpb25SYW5nZSIsInNldFN0YXJ0Iiwic2V0RW5kIiwidW5pb24iLCJ1bmlvblJhbmdlIiwiY29udGFpbnNOb2RlIiwiYWxsb3dQYXJ0aWFsIiwiY29udGFpbnNOb2RlQ29udGVudHMiLCJjb250YWluc1JhbmdlIiwiY29udGFpbnNOb2RlVGV4dCIsIm5vZGVSYW5nZSIsInRleHROb2RlcyIsImdldE5vZGVzIiwibGFzdFRleHROb2RlIiwicG9wIiwiY29udGFpbnMiLCJjcmVhdGVOb2RlSXRlcmF0b3IiLCJjb2xsYXBzZUJlZm9yZSIsInNldEVuZEJlZm9yZSIsImNvbGxhcHNlQWZ0ZXIiLCJzZXRTdGFydEFmdGVyIiwicmFuZ2VzRXF1YWwiLCJjb3B5Q29tcGFyaXNvbkNvbnN0YW50c1RvT2JqZWN0IiwiU1RBUlRfVE9fU1RBUlQiLCJTVEFSVF9UT19FTkQiLCJFTkRfVE9fRU5EIiwiRU5EX1RPX1NUQVJUIiwiTk9ERV9CRUZPUkUiLCJOT0RFX0FGVEVSIiwiTk9ERV9CRUZPUkVfQU5EX0FGVEVSIiwiTk9ERV9JTlNJREUiLCJjb3B5Q29tcGFyaXNvbkNvbnN0YW50cyIsImNyZWF0ZVJhbmdlQ29udGVudFJlbW92ZXIiLCJyZW1vdmVyIiwiYm91bmRhcnlVcGRhdGVyIiwiYm91bmRhcnkiLCJyZXR1cm5WYWx1ZSIsImNyZWF0ZVByb3RvdHlwZVJhbmdlIiwiZGV0YWNoZXIiLCJjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIiLCJpc0JlZm9yZSIsImlzU3RhcnQiLCJzZXRSYW5nZVN0YXJ0Iiwic2V0UmFuZ2VFbmQiLCJzZXRSYW5nZVN0YXJ0QW5kRW5kIiwic2V0RW5kQWZ0ZXIiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJkZWxldGVDb250ZW50cyIsInNwbGl0Qm91bmRhcmllcyIsInN0YXJ0RW5kU2FtZSIsIm5vcm1hbGl6ZUJvdW5kYXJpZXMiLCJtZXJnZUZvcndhcmQiLCJzaWJsaW5nIiwiYXBwZW5kRGF0YSIsIm1lcmdlQmFja3dhcmQiLCJub2RlTGVuZ3RoIiwiaW5zZXJ0RGF0YSIsIm5vcm1hbGl6ZVN0YXJ0IiwiZW5kTm9kZSIsInN0YXJ0Tm9kZSIsImNvbGxhcHNlVG9Qb2ludCIsInVwZGF0ZUNvbGxhcHNlZEFuZENvbW1vbkFuY2VzdG9yIiwic3RhcnRNb3ZlZCIsImVuZE1vdmVkIiwiYm91bmRhcnljaGFuZ2UiLCJyYW5nZVByb3RvdHlwZSIsInIxIiwicjIiLCJEb21SYW5nZSIsIldyYXBwZWRSYW5nZSIsImdldFRleHRSYW5nZUNvbnRhaW5lckVsZW1lbnQiLCJ0ZXh0UmFuZ2UiLCJwYXJlbnRFbCIsImR1cGxpY2F0ZSIsInN0YXJ0RWwiLCJlbmRFbCIsInN0YXJ0RW5kQ29udGFpbmVyIiwidGV4dFJhbmdlSXNDb2xsYXBzZWQiLCJjb21wYXJlRW5kUG9pbnRzIiwiZ2V0VGV4dFJhbmdlQm91bmRhcnlQb3NpdGlvbiIsIndob2xlUmFuZ2VDb250YWluZXJFbGVtZW50IiwiaXNDb2xsYXBzZWQiLCJ3b3JraW5nUmFuZ2UiLCJjb250YWluZXJFbGVtZW50IiwiY2FuSGF2ZUhUTUwiLCJ3b3JraW5nTm9kZSIsImNvbXBhcmlzb24iLCJ3b3JraW5nQ29tcGFyaXNvblR5cGUiLCJwcmV2aW91c05vZGUiLCJib3VuZGFyeVBvc2l0aW9uIiwiYm91bmRhcnlOb2RlIiwibW92ZVRvRWxlbWVudFRleHQiLCJzZXRFbmRQb2ludCIsInRlbXBSYW5nZSIsInJhbmdlTGVuZ3RoIiwidGV4dCIsInJlcGxhY2UiLCJtb3ZlU3RhcnQiLCJjcmVhdGVCb3VuZGFyeVRleHRSYW5nZSIsImJvdW5kYXJ5UGFyZW50IiwiYm91bmRhcnlPZmZzZXQiLCJub2RlSXNEYXRhTm9kZSIsInJhbmdlUHJvdG8iLCJjYW5TZXRSYW5nZVN0YXJ0QWZ0ZXJFbmQiLCJ1cGRhdGVSYW5nZVByb3BlcnRpZXMiLCJuYXRpdmVSYW5nZSIsInVwZGF0ZU5hdGl2ZVJhbmdlIiwiZGV0YWNoZWQiLCJyZWZyZXNoIiwidGVzdFRleHROb2RlIiwib3Bwb3NpdGVOYW1lIiwiZ2V0RW5kT2Zmc2V0IiwicmFuZ2UyIiwiY3JlYXRlTmF0aXZlUmFuZ2UiLCJyYW5nZUNvbnRhaW5lckVsZW1lbnQiLCJnbG9iYWxPYmoiLCJyYW5nZVRvVGV4dFJhbmdlIiwidHIiLCJzdGFydFJhbmdlIiwiZW5kUmFuZ2UiLCJjcmVhdGVSYW5neVJhbmdlIiwiY3JlYXRlSWZyYW1lUmFuZ2UiLCJjcmVhdGVJZnJhbWVSYW5neVJhbmdlIiwiY2hlY2tTZWxlY3Rpb25SYW5nZXMiLCJCT09MRUFOIiwid2luZG93UHJvcGVydHlOYW1lIiwiZ2V0U2VsZWN0aW9uIiwic2VsZWN0aW9uSXNDb2xsYXBzZWQiLCJDT05UUk9MIiwiZ2V0V2luU2VsZWN0aW9uIiwid2luUGFyYW0iLCJnZXREb2NTZWxlY3Rpb24iLCJpbXBsZW1lbnRzV2luR2V0U2VsZWN0aW9uIiwiaW1wbGVtZW50c0RvY1NlbGVjdGlvbiIsInVzZURvY3VtZW50U2VsZWN0aW9uIiwiaXNTZWxlY3Rpb25WYWxpZCIsIm5hdGl2ZVNlbCIsImdldE5hdGl2ZVNlbGVjdGlvbiIsInRlc3RTZWxlY3Rpb24iLCJzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cyIsInNlbGVjdGlvbkhhc0V4dGVuZCIsInNlbGVjdGlvbkhhc1JhbmdlQ291bnQiLCJyYW5nZUNvdW50Iiwic2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcyIsImNvbGxhcHNlZE5vbkVkaXRhYmxlU2VsZWN0aW9uc1N1cHBvcnRlZCIsImlmcmFtZSIsImlmcmFtZURvYyIsIm9wZW4iLCJ3cml0ZSIsImNsb3NlIiwic2VsIiwiZG9jRWwiLCJpZnJhbWVCb2R5IiwiYWRkUmFuZ2UiLCJyZW1vdmVBbGxSYW5nZXMiLCJpbXBsZW1lbnRzQ29udHJvbFJhbmdlIiwidGVzdENvbnRyb2xSYW5nZSIsImNyZWF0ZUNvbnRyb2xSYW5nZSIsImFuY2hvck5vZGUiLCJmb2N1c05vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c09mZnNldCIsImdldFJhbmdlQXQiLCJ1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZSIsImJhY2t3YXJkcyIsImFuY2hvclByZWZpeCIsImZvY3VzUHJlZml4IiwidXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tTmF0aXZlU2VsZWN0aW9uIiwibmF0aXZlU2VsZWN0aW9uIiwidXBkYXRlRW1wdHlTZWxlY3Rpb24iLCJfcmFuZ2VzIiwiZ2V0TmF0aXZlUmFuZ2UiLCJfc2VsZWN0aW9uTmF0aXZlUmFuZ2UiLCJyYW5nZUNvbnRhaW5zU2luZ2xlRWxlbWVudCIsInJhbmdlTm9kZXMiLCJnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlIiwidXBkYXRlRnJvbVRleHRSYW5nZSIsIndyYXBwZWRSYW5nZSIsInVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24iLCJkb2NTZWxlY3Rpb24iLCJjb250cm9sUmFuZ2UiLCJpdGVtIiwiYWRkUmFuZ2VUb0NvbnRyb2xTZWxlY3Rpb24iLCJyYW5nZUVsZW1lbnQiLCJuZXdDb250cm9sUmFuZ2UiLCJhZGQiLCJzZWxlY3QiLCJnZXRTZWxlY3Rpb25SYW5nZUF0IiwiV3JhcHBlZFNlbGVjdGlvbiIsImRvY1NlbCIsImdldElmcmFtZVNlbGVjdGlvbiIsInNlbFByb3RvIiwiY3JlYXRlQ29udHJvbFNlbGVjdGlvbiIsInJhbmdlcyIsImFkZFJhbmdlQmFja3dhcmRzIiwicHJldmlvdXNSYW5nZUNvdW50Iiwic2VsZWN0aW9uSXNCYWNrd2FyZHMiLCJzZXRSYW5nZXMiLCJlbXB0eSIsInJlZnJlc2hTZWxlY3Rpb24iLCJjaGVja0ZvckNoYW5nZXMiLCJvbGRSYW5nZXMiLCJyZW1vdmVSYW5nZU1hbnVhbGx5IiwiZ2V0QWxsUmFuZ2VzIiwicmVtb3ZlZCIsInJlbW92ZVJhbmdlIiwiaXNCYWNrd2FyZHMiLCJyYW5nZVRleHRzIiwiYXNzZXJ0Tm9kZUluU2FtZURvY3VtZW50IiwiY29sbGFwc2VUb1N0YXJ0IiwiY29sbGFwc2VUb0VuZCIsInNlbGVjdEFsbENoaWxkcmVuIiwiZGVsZXRlRnJvbURvY3VtZW50IiwiZWxlbWVudCIsInNldFNpbmdsZVJhbmdlIiwiaHRtbCIsInJhbmdlSW5zcGVjdHMiLCJhbmNob3IiLCJmb2N1cyIsIlNlbGVjdGlvbiIsInNlbGVjdGlvblByb3RvdHlwZSIsIkJhc2UiLCJfaW5zdGFuY2UiLCJfc3RhdGljIiwiX3Byb3RvdHlwaW5nIiwicHJvdG8iLCJiYXNlIiwia2xhc3MiLCJfY29uc3RydWN0aW5nIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiaW1wbGVtZW50IiwidmFsdWVPZiIsInNvdXJjZSIsInZhbHVlIiwibWV0aG9kIiwicHJldmlvdXMiLCJ0b1NvdXJjZSIsImhpZGRlbiIsImtleSIsIk9iamVjdCIsIm9iamVjdCIsImJsb2NrIiwiY29udGV4dCIsInVuZGVmaW5lZCIsIlN0cmluZyIsImJyb3dzZXIiLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJ0ZXN0RWxlbWVudCIsImlzSUUiLCJpbmRleE9mIiwiaXNHZWNrbyIsImlzV2ViS2l0IiwiaXNDaHJvbWUiLCJpc09wZXJhIiwiaW9zVmVyc2lvbiIsIm1hdGNoIiwiVVNFUl9BR0VOVCIsInRvTG93ZXJDYXNlIiwiaGFzQ29udGVudEVkaXRhYmxlU3VwcG9ydCIsImhhc0VkaXRpbmdBcGlTdXBwb3J0IiwiZXhlY0NvbW1hbmQiLCJxdWVyeUNvbW1hbmRTdXBwb3J0ZWQiLCJxdWVyeUNvbW1hbmRTdGF0ZSIsImhhc1F1ZXJ5U2VsZWN0b3JTdXBwb3J0IiwicXVlcnlTZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpc0luY29tcGF0aWJsZU1vYmlsZUJyb3dzZXIiLCJpc0lvcyIsImlzVG91Y2hEZXZpY2UiLCJzdXBwb3J0c0V2ZW50Iiwic3VwcG9ydHNTYW5kYm94ZWRJZnJhbWVzIiwidGhyb3dzTWl4ZWRDb250ZW50V2FybmluZ1doZW5JZnJhbWVTcmNJc0VtcHR5IiwiZGlzcGxheXNDYXJldEluRW1wdHlDb250ZW50RWRpdGFibGVDb3JyZWN0bHkiLCJoYXNDdXJyZW50U3R5bGVQcm9wZXJ0eSIsImluc2VydHNMaW5lQnJlYWtzT25SZXR1cm4iLCJzdXBwb3J0c1BsYWNlaG9sZGVyQXR0cmlidXRlT24iLCJldmVudE5hbWUiLCJzZXRBdHRyaWJ1dGUiLCJzdXBwb3J0c0V2ZW50c0luSWZyYW1lQ29ycmVjdGx5IiwiZmlyZXNPbkRyb3BPbmx5V2hlbk9uRHJhZ092ZXJJc0NhbmNlbGxlZCIsInN1cHBvcnRzRGF0YVRyYW5zZmVyIiwiQ2xpcGJvYXJkIiwiRGF0YVRyYW5zZmVyIiwiZ2V0RGF0YSIsInN1cHBvcnRzSFRNTDVUYWdzIiwiaHRtbDUiLCJzdXBwb3J0c0NvbW1hbmQiLCJidWdneUNvbW1hbmRzIiwiY29tbWFuZCIsImlzQnVnZ3kiLCJlMSIsInF1ZXJ5Q29tbWFuZEVuYWJsZWQiLCJlMiIsImRvZXNBdXRvTGlua2luZ0luQ29udGVudEVkaXRhYmxlIiwiY2FuRGlzYWJsZUF1dG9MaW5raW5nIiwiY2xlYXJzQ29udGVudEVkaXRhYmxlQ29ycmVjdGx5Iiwic3VwcG9ydHNHZXRBdHRyaWJ1dGVDb3JyZWN0bHkiLCJ0ZCIsImdldEF0dHJpYnV0ZSIsImNhblNlbGVjdEltYWdlc0luQ29udGVudEVkaXRhYmxlIiwiY2xlYXJzTGlzdHNJbkNvbnRlbnRFZGl0YWJsZUNvcnJlY3RseSIsImF1dG9TY3JvbGxzVG9DYXJldCIsImF1dG9DbG9zZXNVbmNsb3NlZFRhZ3MiLCJjbG9uZWRUZXN0RWxlbWVudCIsInN1cHBvcnRzTmF0aXZlR2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJzdXBwb3J0c1NlbGVjdGlvbk1vZGlmeSIsInN1cHBvcnRzQ2xhc3NMaXN0IiwibmVlZHNTcGFjZUFmdGVyTGluZUJyZWFrIiwic3VwcG9ydHNTcGVlY2hBcGlPbiIsImlucHV0IiwiY2hyb21lVmVyc2lvbiIsImNyYXNoZXNXaGVuRGVmaW5lUHJvcGVydHkiLCJwcm9wZXJ0eSIsImRvZXNBc3luY0ZvY3VzIiwiaGFzUHJvYmxlbXNTZXR0aW5nQ2FyZXRBZnRlckltZyIsImhhc1VuZG9JbkNvbnRleHRNZW51IiwiYXJyYXkiLCJuZWVkbGUiLCJ3aXRob3V0IiwiYXJyYXlUb1N1YnN0cmFjdCIsIm5ld0FyciIsImdldCIsIm5ld0FycmF5IiwiRGlzcGF0Y2hlciIsIm9ic2VydmUiLCJoYW5kbGVyIiwiZXZlbnRzIiwib24iLCJmaXJlIiwicGF5bG9hZCIsImhhbmRsZXJzIiwic3RvcE9ic2VydmluZyIsIm5ld0hhbmRsZXJzIiwibWVyZ2UiLCJvdGhlck9iaiIsIm5ld09iaiIsImlzQXJyYXkiLCJXSElURV9TUEFDRV9TVEFSVCIsIldISVRFX1NQQUNFX0VORCIsInN0cmluZyIsInN0ciIsInRyaW0iLCJpbnRlcnBvbGF0ZSIsInZhcnMiLCJieSIsInNlYXJjaCIsInNwbGl0IiwiSUdOT1JFX1VSTFNfSU4iLCJVUkxfUkVHX0VYUCIsIlRSQUlMSU5HX0NIQVJfUkVHX0VYUCIsIk1BWF9ESVNQTEFZX0xFTkdUSCIsIkJSQUNLRVRTIiwiYXV0b0xpbmsiLCJfaGFzUGFyZW50VGhhdFNob3VsZEJlSWdub3JlZCIsIl9wYXJzZU5vZGUiLCJfY29udmVydFVybHNUb0xpbmtzIiwidXJsIiwicHVuY3R1YXRpb24iLCJvcGVuaW5nIiwicmVhbFVybCIsImRpc3BsYXlVcmwiLCJzdWJzdHIiLCJfZ2V0VGVtcEVsZW1lbnQiLCJ0ZW1wRWxlbWVudCIsIl93eXNpaHRtbDVfdGVtcEVsZW1lbnQiLCJfd3JhcE1hdGNoZXNJbk5vZGUiLCJjaGlsZE5vZGVzTGVuZ3RoIiwiYWRkQ2xhc3MiLCJjbGFzc05hbWUiLCJjbGFzc0xpc3QiLCJoYXNDbGFzcyIsInJlbW92ZUNsYXNzIiwiZWxlbWVudENsYXNzTmFtZSIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiY29udmVydFRvTGlzdCIsIl9jcmVhdGVMaXN0SXRlbSIsImxpc3QiLCJsaXN0SXRlbSIsIl9jcmVhdGVMaXN0IiwibGlzdFR5cGUiLCJsaW5lQnJlYWtzIiwibGluZUJyZWFrc0xlbmd0aCIsImNoaWxkTm9kZSIsImxpbmVCcmVhayIsImlzQmxvY2tFbGVtZW50IiwiaXNMaW5lQnJlYWsiLCJjdXJyZW50TGlzdEl0ZW0iLCJnZXRTdHlsZSIsImZyb20iLCJpbnNlcnQiLCJhZnRlciIsInJlcGxhY2VDaGlsZCIsImNvcHlBdHRyaWJ1dGVzIiwiYXR0cmlidXRlc1RvQ29weSIsImVsZW1lbnRUb0NvcHlGcm9tIiwidG8iLCJlbGVtZW50VG9Db3B5VG8iLCJhdHRyaWJ1dGUiLCJhbmRUbyIsImNhbGxlZSIsIkJPWF9TSVpJTkdfUFJPUEVSVElFUyIsInNob3VsZElnbm9yZUJveFNpemluZ0JvcmRlckJveCIsImhhc0JveFNpemluZ0JvcmRlckJveCIsInBhcnNlSW50Iiwib2Zmc2V0V2lkdGgiLCJjb3B5U3R5bGVzIiwic3R5bGVzVG9Db3B5IiwiY3NzVGV4dCIsImhlaWdodF9yIiwiaGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0Iiwic2V0U3R5bGVzIiwiZGVsZWdhdGUiLCJzZWxlY3RvciIsImV2ZW50IiwiZ2V0QXNEb20iLCJfaW5uZXJIVE1MU2hpdiIsInN0eWxlIiwiZGlzcGxheSIsIl9lbnN1cmVIVE1MNUNvbXBhdGliaWxpdHkiLCJfd3lzaWh0bWw1X3N1cHBvcnRzSFRNTDVUYWdzIiwiSFRNTDVfRUxFTUVOVFMiLCJnZXRQYXJlbnRFbGVtZW50IiwiX2lzU2FtZU5vZGVOYW1lIiwiZGVzaXJlZE5vZGVOYW1lcyIsIl9pc0VsZW1lbnQiLCJfaGFzQ2xhc3NOYW1lIiwiY2xhc3NSZWdFeHAiLCJjbGFzc05hbWVzIiwiX2dldFBhcmVudEVsZW1lbnRXaXRoTm9kZU5hbWUiLCJsZXZlbHMiLCJfZ2V0UGFyZW50RWxlbWVudFdpdGhOb2RlTmFtZUFuZENsYXNzTmFtZSIsIm1hdGNoaW5nU2V0Iiwic3R5bGVQcm9wZXJ0eU1hcHBpbmciLCJSRUdfRVhQX0NBTUVMSVpFIiwiY2FtZWxpemUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsImNhbWVsaXplZFByb3BlcnR5IiwiY3VycmVudFN0eWxlIiwic3R5bGVWYWx1ZSIsIm5lZWRzT3ZlcmZsb3dSZXNldCIsIm9yaWdpbmFsT3ZlcmZsb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3ciLCJnZXRQcm9wZXJ0eVZhbHVlIiwiaGFzRWxlbWVudFdpdGhUYWdOYW1lIiwiTElWRV9DQUNIRSIsIkRPQ1VNRU5UX0lERU5USUZJRVIiLCJfZ2V0RG9jdW1lbnRJZGVudGlmaWVyIiwiX3d5c2lodG1sNV9pZGVudGlmaWVyIiwidGFnTmFtZSIsImNhY2hlRW50cnkiLCJoYXNFbGVtZW50V2l0aENsYXNzTmFtZSIsImVsZW1lbnRUb0luc2VydCIsImJlZm9yZSIsImludG8iLCJpbnNlcnRDU1MiLCJydWxlcyIsImhlYWQiLCJzdHlsZUVsZW1lbnQiLCJzdHlsZVNoZWV0IiwiZXZlbnROYW1lcyIsImhhbmRsZXJXcmFwcGVyIiwic3JjRWxlbWVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FuY2VsQnViYmxlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaEV2ZW50IiwicGFyc2UiLCJOT0RFX1RZUEVfTUFQUElORyIsIl9oYW5kbGVFbGVtZW50IiwiX2hhbmRsZVRleHQiLCJERUZBVUxUX05PREVfTkFNRSIsIldISVRFX1NQQUNFX1JFR19FWFAiLCJkZWZhdWx0UnVsZXMiLCJ0YWdzIiwiY2xhc3NlcyIsImN1cnJlbnRSdWxlcyIsImVsZW1lbnRPckh0bWwiLCJjbGVhblVwIiwiaXNTdHJpbmciLCJfY29udmVydCIsImdldENvcnJlY3RJbm5lckhUTUwiLCJvbGROb2RlIiwib2xkTm9kZVR5cGUiLCJvbGRDaGlsZHMiLCJvbGRDaGlsZHNMZW5ndGgiLCJuZXdDaGlsZCIsImF0dHJpYnV0ZXMiLCJydWxlIiwiZW5kVGFnIiwidGFnUnVsZXMiLCJzY29wZU5hbWUiLCJfd3lzaWh0bWw1Iiwib3V0ZXJIVE1MIiwicmVuYW1lX3RhZyIsIl9oYW5kbGVBdHRyaWJ1dGVzIiwic2V0Q2xhc3MiLCJzZXRfY2xhc3MiLCJhZGRfY2xhc3MiLCJzZXRBdHRyaWJ1dGVzIiwic2V0X2F0dHJpYnV0ZXMiLCJjaGVja0F0dHJpYnV0ZXMiLCJjaGVja19hdHRyaWJ1dGVzIiwiYWxsb3dlZENsYXNzZXMiLCJuZXdDbGFzc2VzIiwibmV3VW5pcXVlQ2xhc3NlcyIsIm9sZENsYXNzZXMiLCJjbGFzc2VzTGVuZ3RoIiwibmV3Q2xhc3Nlc0xlbmd0aCIsImN1cnJlbnRDbGFzcyIsIm5ld0NsYXNzIiwiYXR0cmlidXRlTmFtZSIsIm5ld0F0dHJpYnV0ZVZhbHVlIiwiYXR0cmlidXRlQ2hlY2tNZXRob2RzIiwiX2dldEF0dHJpYnV0ZSIsImFkZENsYXNzTWV0aG9kcyIsInVuc2hpZnQiLCJzcmMiLCJ3aWR0aCIsIkhBU19HRVRfQVRUUklCVVRFX0JVRyIsIl9pc0xvYWRlZEltYWdlIiwiaGFzQXR0cmlidXRlIiwiY29tcGxldGUiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJyZWFkeVN0YXRlIiwiUkVHX0VYUCIsImF0dHJpYnV0ZVZhbHVlIiwiYWx0IiwibnVtYmVycyIsImFsaWduX2ltZyIsIm1hcHBpbmciLCJsZWZ0IiwicmlnaHQiLCJhbGlnbl90ZXh0IiwiY2VudGVyIiwianVzdGlmeSIsImNsZWFyX2JyIiwiYm90aCIsImFsbCIsInNpemVfZm9udCIsInJlbW92ZUVtcHR5VGV4dE5vZGVzIiwicmVuYW1lRWxlbWVudCIsIm5ld05vZGVOYW1lIiwibmV3RWxlbWVudCIsInJlcGxhY2VXaXRoQ2hpbGROb2RlcyIsIl9pc0Jsb2NrRWxlbWVudCIsIl9pc0xpbmVCcmVhayIsIl9hcHBlbmRMaW5lQnJlYWsiLCJyZXNvbHZlTGlzdCIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJpc0xhc3RDaGlsZCIsInNob3VsZEFwcGVuZExpbmVCcmVhayIsIndpbmRvd1Byb3BlcnRpZXMiLCJ3aW5kb3dQcm9wZXJ0aWVzMiIsImRvY3VtZW50UHJvcGVydGllcyIsIlNhbmRib3giLCJyZWFkeUNhbGxiYWNrIiwiY2FsbGJhY2siLCJfY3JlYXRlSWZyYW1lIiwiaW5zZXJ0SW50byIsImdldEVsZW1lbnRCeUlkIiwiZ2V0SWZyYW1lIiwiX3JlYWR5RXJyb3IiLCJkZXN0cm95IiwidGhhdCIsIm9ubG9hZCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsIl9vbkxvYWRJZnJhbWUiLCJpZnJhbWVXaW5kb3ciLCJpZnJhbWVEb2N1bWVudCIsImNoYXJzZXQiLCJjaGFyYWN0ZXJTZXQiLCJzYW5kYm94SHRtbCIsIl9nZXRIdG1sIiwic3R5bGVzaGVldHMiLCJvbmVycm9yIiwiZXJyb3JNZXNzYWdlIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiX3Vuc2V0IiwibG9hZGVkIiwic2V0VGltZW91dCIsInRlbXBsYXRlVmFycyIsInNldHRlciIsIl9fZGVmaW5lR2V0dGVyX18iLCJfX2RlZmluZVNldHRlcl9fIiwic2V0IiwiZGVmaW5lUHJvcGVydHkiLCJzdHlsZXMiLCJjc3NGbG9hdCIsInN0eWxlRmxvYXQiLCJzaW11bGF0ZVBsYWNlaG9sZGVyIiwiZWRpdG9yIiwidmlldyIsInBsYWNlaG9sZGVyVGV4dCIsIkNMQVNTX05BTUUiLCJ1bnNldCIsImhhc1BsYWNlaG9sZGVyU2V0IiwiY2xlYXIiLCJpc0VtcHR5Iiwic2V0VmFsdWUiLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50IiwiZ2V0VGV4dENvbnRlbnQiLCJpbm5lclRleHQiLCJub2RlVmFsdWUiLCJjbGVhblBhc3RlZEhUTUwiLCJtYXRjaGVzIiwibWF0Y2hlc0xlbmd0aCIsImoiLCJlbHMiLCJkaXZzIiwiZGl2IiwibmV3X2RpdiIsInJlcGxhY2VXaXRoIiwicF9lbHMiLCIkIiwiYnJfZWxzIiwiYnIiLCJlbnN1cmVQcm9wZXJDbGVhcmluZyIsImNsZWFySWZOZWNlc3NhcnkiLCJjb21wb3NlciIsImVuc3VyZVByb3BlckNsZWFyaW5nT2ZMaXN0cyIsIkVMRU1FTlRTX1RIQVRfQ09OVEFJTl9MSSIsImNvbnRlbnRFZGl0YWJsZUVsZW1lbnQiLCJsaXN0SXNGaXJzdENoaWxkT2ZDb250ZW50RWRpdGFibGUiLCJoYXNPbmx5T25lTGlzdEl0ZW0iLCJvbmx5TGlzdEl0ZW1Jc0VtcHR5Iiwia2V5Q29kZSIsImdldFNlbGVjdGVkTm9kZSIsIlRJTERFX0VTQ0FQRUQiLCJlbGVtZW50c1dpdGhUaWxkZSIsInVybFRvU2VhcmNoIiwiaHJlZiIsIlVTRV9OQVRJVkVfTElORV9CUkVBS19XSEVOX0NBUkVUX0lOU0lERV9UQUdTIiwiTElTVF9UQUdTIiwiaW5zZXJ0TGluZUJyZWFrT25SZXR1cm4iLCJ1bndyYXAiLCJzZWxlY3RlZE5vZGUiLCJpbnZpc2libGVTcGFjZSIsImtleURvd24iLCJzaGlmdEtleSIsImJsb2NrRWxlbWVudCIsImV4ZWMiLCJyZWRyYXciLCJfZ2V0Q3VtdWxhdGl2ZU9mZnNldFRvcCIsInRvcCIsIm9mZnNldFRvcCIsIm9mZnNldFBhcmVudCIsImdldEJvb2ttYXJrIiwiZ2V0UmFuZ2UiLCJzZXRCb29rbWFyayIsImJvb2ttYXJrIiwic2V0U2VsZWN0aW9uIiwic2V0QmVmb3JlIiwic2V0QWZ0ZXIiLCJpc0VsZW1lbnQiLCJkaXNwbGF5U3R5bGUiLCJleGVjdXRlQW5kUmVzdG9yZSIsInJlc3RvcmVTY3JvbGxQb3NpdGlvbiIsIm9sZFNjcm9sbFRvcCIsInNjcm9sbFRvcCIsIm9sZFNjcm9sbExlZnQiLCJzY3JvbGxMZWZ0IiwicGxhY2Vob2xkZXJIVE1MIiwibmV3UmFuZ2UiLCJlMyIsImNhcmV0UGxhY2Vob2xkZXIiLCJlNCIsImV4ZWN1dGVBbmRSZXN0b3JlU2ltcGxlIiwiZmlyc3ROb2RlIiwibGFzdE5vZGUiLCJyYW5nZUJhY2t1cCIsImluc2VydEhUTUwiLCJzdXJyb3VuZCIsInNjcm9sbEludG9WaWV3IiwiaGFzU2Nyb2xsQmFycyIsInNjcm9sbEhlaWdodCIsIl93eXNpaHRtbDVTY3JvbGxJbnRvVmlld0VsZW1lbnQiLCJzZWxlY3RMaW5lIiwiX3NlbGVjdExpbmVfVzNDIiwiX3NlbGVjdExpbmVfTVNJRSIsIm1vZGlmeSIsInJhbmdlVG9wIiwiYm91bmRpbmdUb3AiLCJyYW5nZUhlaWdodCIsImJvdW5kaW5nSGVpZ2h0Iiwic2Nyb2xsV2lkdGgiLCJyYW5nZUJvdHRvbSIsInJhbmdlRW5kIiwibWVhc3VyZU5vZGUiLCJtb3ZlVG9Qb2ludCIsImdldFRleHQiLCJkZWZhdWx0VGFnTmFtZSIsIlJFR19FWFBfV0hJVEVfU1BBQ0UiLCJjc3NDbGFzcyIsInJlZ0V4cCIsIm1hdGNoaW5nQ2xhc3NOYW1lcyIsImhhc1NhbWVDbGFzc2VzIiwiZWwxIiwiZWwyIiwicmVwbGFjZVdpdGhPd25DaGlsZHJlbiIsImVsZW1lbnRzSGF2ZVNhbWVOb25DbGFzc0F0dHJpYnV0ZXMiLCJhdHRyMSIsImF0dHIyIiwiZ2V0TmFtZWRJdGVtIiwic3BlY2lmaWVkIiwiaXNTcGxpdFBvaW50Iiwic3BsaXROb2RlQXQiLCJkZXNjZW5kYW50Tm9kZSIsImRlc2NlbmRhbnRPZmZzZXQiLCJyZW1vdmVBdHRyaWJ1dGUiLCJNZXJnZSIsImlzRWxlbWVudE1lcmdlIiwiZmlyc3RUZXh0Tm9kZSIsImRvTWVyZ2UiLCJnZXRMZW5ndGgiLCJIVE1MQXBwbGllciIsInRhZ05hbWVzIiwic2ltaWxhckNsYXNzUmVnRXhwIiwibm9ybWFsaXplIiwiYXBwbHlUb0FueVRhZ05hbWUiLCJnZXRBbmNlc3RvcldpdGhDbGFzcyIsImNzc0NsYXNzTWF0Y2giLCJwb3N0QXBwbHkiLCJtZXJnZXMiLCJjdXJyZW50TWVyZ2UiLCJyYW5nZVN0YXJ0Tm9kZSIsInJhbmdlRW5kTm9kZSIsInJhbmdlU3RhcnRPZmZzZXQiLCJyYW5nZUVuZE9mZnNldCIsInByZWNlZGluZ1RleHROb2RlIiwiZ2V0QWRqYWNlbnRNZXJnZWFibGVUZXh0Tm9kZSIsIm5leHRUZXh0Tm9kZSIsImZvcndhcmQiLCJpc1RleHROb2RlIiwiYWRqYWNlbnROb2RlIiwicHJvcE5hbWUiLCJhcmVFbGVtZW50c01lcmdlYWJsZSIsImNyZWF0ZUNvbnRhaW5lciIsImFwcGx5VG9UZXh0Tm9kZSIsImlzUmVtb3ZhYmxlIiwidW5kb1RvVGV4dE5vZGUiLCJhbmNlc3RvcldpdGhDbGFzcyIsImFuY2VzdG9yUmFuZ2UiLCJhcHBseVRvUmFuZ2UiLCJ1bmRvVG9SYW5nZSIsImdldFRleHRTZWxlY3RlZEJ5UmFuZ2UiLCJpc0FwcGxpZWRUb1JhbmdlIiwic2VsZWN0ZWRUZXh0IiwidG9nZ2xlUmFuZ2UiLCJDb21tYW5kcyIsInN1cHBvcnQiLCJyZXN1bHQiLCJzdGF0ZSIsImNvbW1hbmRWYWx1ZSIsInF1ZXJ5Q29tbWFuZFZhbHVlIiwidW5kZWYiLCJib2xkIiwiZm9ybWF0SW5saW5lIiwiY29sb3IiLCJOT0RFX05BTUUiLCJfcmVtb3ZlRm9ybWF0IiwiYW5jaG9ycyIsImNvZGVFbGVtZW50IiwiX2Zvcm1hdCIsInRlbXBDbGFzcyIsIkRhdGUiLCJ0ZW1wQ2xhc3NSZWdFeHAiLCJoYXNFbGVtZW50Q2hpbGQiLCJlbGVtZW50VG9TZXRDYXJldEFmdGVyIiwid2hpdGVTcGFjZSIsImNyZWF0ZUxpbmsiLCJmb250U2l6ZSIsInNpemUiLCJmb3JlQ29sb3IiLCJCTE9DS19FTEVNRU5UU19HUk9VUCIsIl9hZGRDbGFzcyIsIl9yZW1vdmVDbGFzcyIsIl9pc0JsYW5rVGV4dE5vZGUiLCJfZ2V0UHJldmlvdXNTaWJsaW5nVGhhdElzTm90QmxhbmsiLCJfZ2V0TmV4dFNpYmxpbmdUaGF0SXNOb3RCbGFuayIsIl9hZGRMaW5lQnJlYWtCZWZvcmVBbmRBZnRlciIsIl9pc0xpbmVCcmVha09yQmxvY2tFbGVtZW50IiwiX3JlbW92ZUxpbmVCcmVha0JlZm9yZUFuZEFmdGVyIiwiX3JlbW92ZUxhc3RDaGlsZElmTGluZUJyZWFrIiwiX2V4ZWNDb21tYW5kIiwiZXZlbnRMaXN0ZW5lciIsIl9zZWxlY3RMaW5lQW5kV3JhcCIsIl9oYXNDbGFzc2VzIiwiZm9ybWF0QmxvY2siLCJoYXNDbGFzc2VzIiwiQUxJQVNfTUFQUElORyIsImh0bWxBcHBsaWVyIiwiX2dldFRhZ05hbWVzIiwiYWxpYXMiLCJfZm9ybWF0Q2xlYXIiLCJlYWNoIiwiY2hpbGRyZW4iLCJmb250X2VsIiwic3Bhbl9lbCIsInJlZHVjZWRfZGltZW5zaW9uIiwibm90X3NwYW5fbGlzdCIsIm5vdCIsInRvQXJyYXkiLCJub3Rfc3Bhbl9saXN0X2l0ZW0iLCJuZXdfZWwiLCJpcyIsImZpbmQiLCJzcGFuIiwiY2xhc3NfbmFtZSIsImNoaWxkX3NwYW4iLCJwYXJlbnRzIiwiaHRtbF90ZXh0IiwiX2dldEFwcGxpZXIiLCJpZGVudGlmaWVyIiwiYWxpYXNUYWdOYW1lIiwiaW5zZXJ0SW1hZ2UiLCJpbWFnZSIsImltYWdlc0luU2VsZWN0aW9uIiwiTElORV9CUkVBSyIsImluc2VydExpbmVCcmVhayIsImluc2VydE9yZGVyZWRMaXN0Iiwib3RoZXJMaXN0IiwidGVtcENsYXNzTmFtZSIsImdldFRpbWUiLCJpbnNlcnRVbm9yZGVyZWRMaXN0IiwiaXRhbGljIiwianVzdGlmeUNlbnRlciIsImp1c3RpZnlMZWZ0IiwianVzdGlmeVJpZ2h0IiwidW5kZXJsaW5lIiwiWl9LRVkiLCJZX0tFWSIsIk1BWF9ISVNUT1JZX0VOVFJJRVMiLCJVTkRPX0hUTUwiLCJSRURPX0hUTUwiLCJjbGVhblRlbXBFbGVtZW50cyIsIlVuZG9NYW5hZ2VyIiwiaGlzdG9yeSIsImdldFZhbHVlIiwicG9zaXRpb24iLCJfb2JzZXJ2ZSIsInNhbmRib3giLCJsYXN0S2V5IiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJpc1VuZG8iLCJpc1JlZG8iLCJ1bmRvIiwicmVkbyIsInRyYW5zYWN0IiwiaW50ZXJ2YWwiLCJvYnNlcnZlZCIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInByZXZpb3VzSHRtbCIsImN1cnJlbnRIdG1sIiwic2hpZnQiLCJWaWV3IiwidGV4dGFyZWFFbGVtZW50IiwiX29ic2VydmVWaWV3Q2hhbmdlIiwiY3VycmVudFZpZXciLCJzaG93IiwiaGlkZSIsImRpc2FibGUiLCJlbmFibGUiLCJDb21wb3NlciIsIkNBUkVUX0hBQ0siLCJ0ZXh0YXJlYSIsIl9pbml0U2FuZGJveCIsIl9kaXNwbGF5U3R5bGUiLCJzZXRUb0VuZCIsImVsZW1lbnRzV2l0aFZpc3VhbFZhbHVlIiwiX2NyZWF0ZSIsImhpZGRlbkZpZWxkIiwiY29tcG9zZXJDbGFzc05hbWUiLCJwbGFjZWhvbGRlciIsIl9pbml0QXV0b0xpbmtpbmciLCJfaW5pdE9iamVjdFJlc2l6aW5nIiwiX2luaXRVbmRvTWFuYWdlciIsImluaXRTeW5jIiwic3luYyIsInN1cHBvcnRzRGlzYWJsaW5nT2ZBdXRvTGlua2luZyIsInN1cHBvcnRzQXV0b0xpbmtpbmciLCJsaW5rcyIsInVybFJlZ0V4cCIsImxpbmsiLCJuZXdUZXh0Q29udGVudCIsInByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzTGVuZ3RoIiwiYWxsb3dPYmplY3RSZXNpemluZyIsIkhPU1RfVEVNUExBVEUiLCJURVhUX0ZPUk1BVFRJTkciLCJCT1hfRk9STUFUVElORyIsIlJFU0laRV9TVFlMRSIsIkFERElUSU9OQUxfQ1NTX1JVTEVTIiwiZm9jdXNXaXRob3V0U2Nyb2xsaW5nIiwic2V0QWN0aXZlIiwiZWxlbWVudFN0eWxlIiwib3JpZ2luYWxTY3JvbGxUb3AiLCJvcmlnaW5hbFNjcm9sbExlZnQiLCJvcmlnaW5hbFN0eWxlcyIsIldlYmtpdFVzZXJTZWxlY3QiLCJzY3JvbGxUbyIsIm9yaWdpbmFsQWN0aXZlRWxlbWVudCIsImhhc1BsYWNlaG9sZGVyIiwib3JpZ2luYWxQbGFjZWhvbGRlciIsImZvY3VzU3R5bGVzSG9zdCIsImJsdXJTdHlsZXNIb3N0IiwiYmx1ciIsImJveEZvcm1hdHRpbmdTdHlsZXMiLCJ3aW5PYnNlcnZlciIsIm9yaWdpbmFsVGV4dGFyZWFEaXNwbGF5U3R5bGUiLCJvcmlnaW5hbENvbXBvc2VyRGlzcGxheVN0eWxlIiwic2hvcnRjdXRzIiwiZm9jdXNCbHVyRWxlbWVudCIsInBhc3RlRXZlbnRzIiwiZG9tTm9kZVJlbW92ZWRJbnRlcnZhbCIsImRhdGFUcmFuc2ZlciIsInRpdGxlUHJlZml4ZXMiLCJJTUciLCJBIiwidGl0bGUiLCJoYXNUaXRsZSIsIklOVEVSVkFMIiwiU3luY2hyb25pemVyIiwiZnJvbUNvbXBvc2VyVG9UZXh0YXJlYSIsInNob3VsZFBhcnNlSHRtbCIsImZyb21UZXh0YXJlYVRvQ29tcG9zZXIiLCJ0ZXh0YXJlYVZhbHVlIiwiZm9ybSIsInN0YXJ0SW50ZXJ2YWwiLCJzdG9wSW50ZXJ2YWwiLCJUZXh0YXJlYSIsInN1cHBvcnRzUGxhY2Vob2xkZXIiLCJldmVudE1hcHBpbmciLCJmb2N1c2luIiwiZm9jdXNvdXQiLCJDTEFTU19OQU1FX09QRU5FRCIsIlNFTEVDVE9SX0ZPUk1fRUxFTUVOVFMiLCJTRUxFQ1RPUl9GSUVMRFMiLCJBVFRSSUJVVEVfRklFTERTIiwiRGlhbG9nIiwiX29ic2VydmVkIiwiY2FsbGJhY2tXcmFwcGVyIiwiX3NlcmlhbGl6ZSIsImVsZW1lbnRUb0NoYW5nZSIsImZvcm1FbGVtZW50cyIsIl9jbGVhckludGVydmFsIiwiZmllbGRzIiwiX2ludGVycG9sYXRlIiwiYXZvaWRIaWRkZW5GaWVsZHMiLCJmaWVsZCIsImZpZWxkTmFtZSIsIm5ld1ZhbHVlIiwiZm9jdXNlZEVsZW1lbnQiLCJkZWZhdWx0VmFsdWUiLCJmaXJzdEZpZWxkIiwibGlua1N0eWxlcyIsIndyYXBwZXJTdHlsZXMiLCJtYXJnaW4iLCJvcGFjaXR5IiwicGFkZGluZyIsInpJbmRleCIsImlucHV0U3R5bGVzIiwiY3Vyc29yIiwibWFyZ2luVG9wIiwib3V0bGluZSIsImlucHV0QXR0cmlidXRlcyIsIlNwZWVjaCIsIndyYXBwZXIiLCJDTEFTU19OQU1FX0NPTU1BTkRfRElTQUJMRUQiLCJDTEFTU19OQU1FX0NPTU1BTkRTX0RJU0FCTEVEIiwiQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSIsIkNMQVNTX05BTUVfQUNUSU9OX0FDVElWRSIsIlRvb2xiYXIiLCJfZ2V0TGlua3MiLCJzcGVlY2hJbnB1dExpbmtzIiwiZ3JvdXAiLCJkaWFsb2ciLCJfZ2V0RGlhbG9nIiwiZGlhbG9nRWxlbWVudCIsImNhcmV0Qm9va21hcmsiLCJkaWFsb2dDb250YWluZXIiLCJjb21tYW5kTGluayIsImNvbW1hbmRzRGlzYWJsZWQiLCJjb21tYW5kT2JqIiwiY29tbWFuZE1hcHBpbmciLCJfdXBkYXRlTGlua1N0YXRlcyIsImV4ZWNBY3Rpb24iLCJhY3Rpb24iLCJjb21tYW5kTGlua3MiLCJhY3Rpb25MaW5rcyIsInVuc2VsZWN0YWJsZSIsImFjdGlvbk1hcHBpbmciLCJkZWZhdWx0Q29uZmlnIiwicGFyc2VyUnVsZXMiLCJwYXJzZXIiLCJib2R5Q2xhc3NOYW1lIiwic3VwcG9ydFRvdWNoRGV2aWNlcyIsIkVkaXRvciIsIl9pc0NvbXBhdGlibGUiLCJfaW5pdFBhcnNlciIsInN5bmNocm9uaXplciIsImlzQ29tcGF0aWJsZSIsImh0bWxPckVsZW1lbnQiLCJrZWVwU2Nyb2xsUG9zaXRpb24iLCJXeXNpaHRtbDUiLCJvcHRpb25zIiwiZGVmYXVsdHMiLCJmbiIsImVkaXRhYmxldXRpbHMiLCJpbmhlcml0IiwiZWRpdGFibGV0eXBlcyIsImFic3RyYWN0aW5wdXQiLCJyZW5kZXIiLCJkZWZlcnJlZCIsIkRlZmVycmVkIiwibXNpZU9sZCIsIiRpbnB1dCIsImF0dHIiLCJzZXRBdHRyIiwibG9hZCIsInJlc29sdmUiLCJwcm9taXNlIiwidmFsdWUyaHRtbCIsImh0bWwydmFsdWUiLCJ2YWx1ZTJpbnB1dCIsImFjdGl2YXRlIiwiJGVsZW1lbnQiLCJ0cGwiLCJpbnB1dGNsYXNzIiwialF1ZXJ5Iiwid3lzaSIsImZvbnRTdHlsZXMiLCJsb2NhbGUiLCJmb250X3N0eWxlcyIsIm5vcm1hbCIsImgxIiwiaDIiLCJoMyIsImVtcGhhc2lzIiwibGlzdHMiLCJ1bm9yZGVyZWQiLCJvcmRlcmVkIiwiY2FuY2VsIiwiZWRpdCIsImNvbG91cnMiLCJmaXJzdCIsInNlY29uZCIsInRocmVlIiwidGVtcGxhdGVzIiwidG9vbGJhck9wdHMiLCJkZWZhdWx0T3B0aW9ucyIsImN1c3RvbVRlbXBsYXRlcyIsImNyZWF0ZVRvb2xiYXIiLCJjcmVhdGVFZGl0b3IiLCJvZmYiLCJmb2N1c1d5c2lodG1sNSIsInNlbGYiLCJjdWx0dXJlIiwiYXBwZW5kIiwiaW5pdEh0bWwiLCJpbml0SW5zZXJ0TGluayIsImluaXRJbnNlcnRJbWFnZSIsImNsaWNrIiwiY2hhbmdlVmlld1NlbGVjdG9yIiwidG9nZ2xlQ2xhc3MiLCJpbnNlcnRJbWFnZU1vZGFsIiwidXJsSW5wdXQiLCJpbnNlcnRCdXR0b24iLCJpbml0aWFsVmFsdWUiLCJrZXlwcmVzcyIsIndoaWNoIiwibW9kYWwiLCJhY3RpdmVCdXR0b24iLCJhcHBlbmRUbyIsImluc2VydExpbmtNb2RhbCIsImluc2VydExpbmsiLCJyZWwiLCJwcmVzc2VkRW50ZXIiLCJtZXRob2RzIiwicmVzZXREZWZhdWx0cyIsImRlZmF1bHRPcHRpb25zQ2FjaGUiLCJieXBhc3NEZWZhdWx0cyIsIiR0aGlzIiwic2hhbGxvd0V4dGVuZCIsInNldHRpbmdzIiwiZGVlcEV4dGVuZCIsIkFycmF5IiwiZXJyb3IiLCJDb25zdHJ1Y3RvciIsImVuIiwib3V0ZGVudCIsImluZGVudCIsImJsYWNrIiwic2lsdmVyIiwiZ3JheSIsIm1hcm9vbiIsInJlZCIsInB1cnBsZSIsImdyZWVuIiwib2xpdmUiLCJuYXZ5IiwiYmx1ZSIsIm9yYW5nZSJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJQSxVQUFVLE9BQU9DLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsU0FBT0EsT0FBT0MsUUFBZCxNQUEyQixRQUEzRCxHQUFzRSxVQUFVQyxHQUFWLEVBQWU7QUFBRSxnQkFBY0EsR0FBZCwwQ0FBY0EsR0FBZDtBQUFvQixDQUEzRyxHQUE4RyxVQUFVQSxHQUFWLEVBQWU7QUFBRSxTQUFPQSxPQUFPLE9BQU9G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V0FITztBQUlYQyxZQUFJO0FBSk8sT0FEWDtBQU9GQyxnQkFBVTtBQUNSN1IsY0FBTSxNQURFO0FBRVJxRSxnQkFBUSxRQUZBO0FBR1JJLG1CQUFXO0FBSEgsT0FQUjtBQVlGcU4sYUFBTztBQUNMQyxtQkFBVyxnQkFETjtBQUVMQyxpQkFBUyxjQUZKO0FBR0xpRCxpQkFBUyxTQUhKO0FBSUxDLGdCQUFRO0FBSkgsT0FaTDtBQWtCRmhOLFlBQU07QUFDSnRmLGdCQUFRLGFBREo7QUFFSnFwQixnQkFBUTtBQUZKLE9BbEJKO0FBc0JGck8sYUFBTztBQUNMaGIsZ0JBQVEsY0FESDtBQUVMcXBCLGdCQUFRO0FBRkgsT0F0Qkw7QUEwQkZ2MEIsWUFBTTtBQUNKdzBCLGNBQU07QUFERixPQTFCSjtBQTZCRkMsZUFBUztBQUNQbmMsZUFBTyxPQURBO0FBRVBvYyxlQUFPLElBRkE7QUFHUEMsZ0JBQVEsSUFIRDtBQUlQQyxlQUFPLElBSkE7QUFLUDZDLGVBQU8sT0FMQTtBQU1QQyxnQkFBUSxRQU5EO0FBT1BDLGNBQU0sTUFQQztBQVFQQyxnQkFBUSxRQVJEO0FBU1BDLGFBQUssS0FURTtBQVVQQyxnQkFBUSxRQVZEO0FBV1BDLGVBQU8sT0FYQTtBQVlQQyxlQUFPLE9BWkE7QUFhUEMsY0FBTSxNQWJDO0FBY1BDLGNBQU0sTUFkQztBQWVQQyxnQkFBUTtBQWZEO0FBN0JQO0FBRHNDLEdBQTVDO0FBaURELENBM1pBLENBMlpDejVDLE9BQU9nMUMsTUEzWlIsRUEyWmdCaDFDLE9BQU9sQixTQTNadkIsQ0FBRCIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgd3lzaWh0bWw1ID0ge1xuICB2ZXJzaW9uOiBcIjAuMy4wXCIsXG5cbiAgLy8gbmFtZXNwYWNlc1xuICBjb21tYW5kczoge30sXG4gIGRvbToge30sXG4gIHF1aXJrczoge30sXG4gIHRvb2xiYXI6IHt9LFxuICBsYW5nOiB7fSxcbiAgc2VsZWN0aW9uOiB7fSxcbiAgdmlld3M6IHt9LFxuXG4gIElOVklTSUJMRV9TUEFDRTogXCJcXHVGRUZGXCIsXG5cbiAgRU1QVFlfRlVOQ1RJT046IGZ1bmN0aW9uIEVNUFRZX0ZVTkNUSU9OKCkge30sXG5cbiAgRUxFTUVOVF9OT0RFOiAxLFxuICBURVhUX05PREU6IDMsXG5cbiAgQkFDS1NQQUNFX0tFWTogOCxcbiAgRU5URVJfS0VZOiAxMyxcbiAgRVNDQVBFX0tFWTogMjcsXG4gIFNQQUNFX0tFWTogMzIsXG4gIERFTEVURV9LRVk6IDQ2XG59OyAvKipcbiAgICogQGxpY2Vuc2UgUmFuZ3ksIGEgY3Jvc3MtYnJvd3NlciBKYXZhU2NyaXB0IHJhbmdlIGFuZCBzZWxlY3Rpb24gbGlicmFyeVxuICAgKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcmFuZ3kvXG4gICAqXG4gICAqIENvcHlyaWdodCAyMDExLCBUaW0gRG93blxuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gICAqIFZlcnNpb246IDEuMi4yXG4gICAqIEJ1aWxkIGRhdGU6IDEzIE5vdmVtYmVyIDIwMTFcbiAgICovXG53aW5kb3dbJ3Jhbmd5J10gPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIE9CSkVDVCA9IFwib2JqZWN0XCIsXG4gICAgICBGVU5DVElPTiA9IFwiZnVuY3Rpb25cIixcbiAgICAgIFVOREVGSU5FRCA9IFwidW5kZWZpbmVkXCI7XG5cbiAgdmFyIGRvbVJhbmdlUHJvcGVydGllcyA9IFtcInN0YXJ0Q29udGFpbmVyXCIsIFwic3RhcnRPZmZzZXRcIiwgXCJlbmRDb250YWluZXJcIiwgXCJlbmRPZmZzZXRcIiwgXCJjb2xsYXBzZWRcIiwgXCJjb21tb25BbmNlc3RvckNvbnRhaW5lclwiLCBcIlNUQVJUX1RPX1NUQVJUXCIsIFwiU1RBUlRfVE9fRU5EXCIsIFwiRU5EX1RPX1NUQVJUXCIsIFwiRU5EX1RPX0VORFwiXTtcblxuICB2YXIgZG9tUmFuZ2VNZXRob2RzID0gW1wic2V0U3RhcnRcIiwgXCJzZXRTdGFydEJlZm9yZVwiLCBcInNldFN0YXJ0QWZ0ZXJcIiwgXCJzZXRFbmRcIiwgXCJzZXRFbmRCZWZvcmVcIiwgXCJzZXRFbmRBZnRlclwiLCBcImNvbGxhcHNlXCIsIFwic2VsZWN0Tm9kZVwiLCBcInNlbGVjdE5vZGVDb250ZW50c1wiLCBcImNvbXBhcmVCb3VuZGFyeVBvaW50c1wiLCBcImRlbGV0ZUNvbnRlbnRzXCIsIFwiZXh0cmFjdENvbnRlbnRzXCIsIFwiY2xvbmVDb250ZW50c1wiLCBcImluc2VydE5vZGVcIiwgXCJzdXJyb3VuZENvbnRlbnRzXCIsIFwiY2xvbmVSYW5nZVwiLCBcInRvU3RyaW5nXCIsIFwiZGV0YWNoXCJdO1xuXG4gIHZhciB0ZXh0UmFuZ2VQcm9wZXJ0aWVzID0gW1wiYm91bmRpbmdIZWlnaHRcIiwgXCJib3VuZGluZ0xlZnRcIiwgXCJib3VuZGluZ1RvcFwiLCBcImJvdW5kaW5nV2lkdGhcIiwgXCJodG1sVGV4dFwiLCBcInRleHRcIl07XG5cbiAgLy8gU3Vic2V0IG9mIFRleHRSYW5nZSdzIGZ1bGwgc2V0IG9mIG1ldGhvZHMgdGhhdCB3ZSdyZSBpbnRlcmVzdGVkIGluXG4gIHZhciB0ZXh0UmFuZ2VNZXRob2RzID0gW1wiY29sbGFwc2VcIiwgXCJjb21wYXJlRW5kUG9pbnRzXCIsIFwiZHVwbGljYXRlXCIsIFwiZ2V0Qm9va21hcmtcIiwgXCJtb3ZlVG9Cb29rbWFya1wiLCBcIm1vdmVUb0VsZW1lbnRUZXh0XCIsIFwicGFyZW50RWxlbWVudFwiLCBcInBhc3RlSFRNTFwiLCBcInNlbGVjdFwiLCBcInNldEVuZFBvaW50XCIsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCJdO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gVHJpbyBvZiBmdW5jdGlvbnMgdGFrZW4gZnJvbSBQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZTpcbiAgLy8gaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvZmVhdHVyZS1kZXRlY3Rpb24tc3RhdGUtb2YtdGhlLWFydC1icm93c2VyLXNjcmlwdGluZ1xuICBmdW5jdGlvbiBpc0hvc3RNZXRob2QobywgcCkge1xuICAgIHZhciB0ID0gX3R5cGVvZihvW3BdKTtcbiAgICByZXR1cm4gdCA9PSBGVU5DVElPTiB8fCAhISh0ID09IE9CSkVDVCAmJiBvW3BdKSB8fCB0ID09IFwidW5rbm93blwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNIb3N0T2JqZWN0KG8sIHApIHtcbiAgICByZXR1cm4gISEoX3R5cGVvZihvW3BdKSA9PSBPQkpFQ1QgJiYgb1twXSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvc3RQcm9wZXJ0eShvLCBwKSB7XG4gICAgcmV0dXJuIF90eXBlb2Yob1twXSkgIT0gVU5ERUZJTkVEO1xuICB9XG5cbiAgLy8gQ3JlYXRlcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNhdmUgdmVyYm9zZSByZXBlYXRlZCBjYWxscyB0byB0ZXN0cyBmdW5jdGlvbnNcbiAgZnVuY3Rpb24gY3JlYXRlTXVsdGlwbGVQcm9wZXJ0eVRlc3QodGVzdEZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG8sIHByb3BzKSB7XG4gICAgICB2YXIgaSA9IHByb3BzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKCF0ZXN0RnVuYyhvLCBwcm9wc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cblxuICAvLyBOZXh0IHRyaW8gb2YgZnVuY3Rpb25zIGFyZSBhIGNvbnZlbmllbmNlIHRvIHNhdmUgdmVyYm9zZSByZXBlYXRlZCBjYWxscyB0byBwcmV2aW91cyB0d28gZnVuY3Rpb25zXG4gIHZhciBhcmVIb3N0TWV0aG9kcyA9IGNyZWF0ZU11bHRpcGxlUHJvcGVydHlUZXN0KGlzSG9zdE1ldGhvZCk7XG4gIHZhciBhcmVIb3N0T2JqZWN0cyA9IGNyZWF0ZU11bHRpcGxlUHJvcGVydHlUZXN0KGlzSG9zdE9iamVjdCk7XG4gIHZhciBhcmVIb3N0UHJvcGVydGllcyA9IGNyZWF0ZU11bHRpcGxlUHJvcGVydHlUZXN0KGlzSG9zdFByb3BlcnR5KTtcblxuICBmdW5jdGlvbiBpc1RleHRSYW5nZShyYW5nZSkge1xuICAgIHJldHVybiByYW5nZSAmJiBhcmVIb3N0TWV0aG9kcyhyYW5nZSwgdGV4dFJhbmdlTWV0aG9kcykgJiYgYXJlSG9zdFByb3BlcnRpZXMocmFuZ2UsIHRleHRSYW5nZVByb3BlcnRpZXMpO1xuICB9XG5cbiAgdmFyIGFwaSA9IHtcbiAgICB2ZXJzaW9uOiBcIjEuMi4yXCIsXG4gICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgIHN1cHBvcnRlZDogdHJ1ZSxcblxuICAgIHV0aWw6IHtcbiAgICAgIGlzSG9zdE1ldGhvZDogaXNIb3N0TWV0aG9kLFxuICAgICAgaXNIb3N0T2JqZWN0OiBpc0hvc3RPYmplY3QsXG4gICAgICBpc0hvc3RQcm9wZXJ0eTogaXNIb3N0UHJvcGVydHksXG4gICAgICBhcmVIb3N0TWV0aG9kczogYXJlSG9zdE1ldGhvZHMsXG4gICAgICBhcmVIb3N0T2JqZWN0czogYXJlSG9zdE9iamVjdHMsXG4gICAgICBhcmVIb3N0UHJvcGVydGllczogYXJlSG9zdFByb3BlcnRpZXMsXG4gICAgICBpc1RleHRSYW5nZTogaXNUZXh0UmFuZ2VcbiAgICB9LFxuXG4gICAgZmVhdHVyZXM6IHt9LFxuXG4gICAgbW9kdWxlczoge30sXG4gICAgY29uZmlnOiB7XG4gICAgICBhbGVydE9uV2FybjogZmFsc2UsXG4gICAgICBwcmVmZXJUZXh0UmFuZ2U6IGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGZhaWwocmVhc29uKSB7XG4gICAgd2luZG93LmFsZXJ0KFwiUmFuZ3kgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGJyb3dzZXIuIFJlYXNvbjogXCIgKyByZWFzb24pO1xuICAgIGFwaS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgYXBpLnN1cHBvcnRlZCA9IGZhbHNlO1xuICB9XG5cbiAgYXBpLmZhaWwgPSBmYWlsO1xuXG4gIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgdmFyIHdhcm5pbmdNZXNzYWdlID0gXCJSYW5neSB3YXJuaW5nOiBcIiArIG1zZztcbiAgICBpZiAoYXBpLmNvbmZpZy5hbGVydE9uV2Fybikge1xuICAgICAgd2luZG93LmFsZXJ0KHdhcm5pbmdNZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2Yod2luZG93LmNvbnNvbGUpICE9IFVOREVGSU5FRCAmJiBfdHlwZW9mKHdpbmRvdy5jb25zb2xlLmxvZykgIT0gVU5ERUZJTkVEKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2cod2FybmluZ01lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGFwaS53YXJuID0gd2FybjtcblxuICBpZiAoe30uaGFzT3duUHJvcGVydHkpIHtcbiAgICBhcGkudXRpbC5leHRlbmQgPSBmdW5jdGlvbiAobywgcHJvcHMpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgb1tpXSA9IHByb3BzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBmYWlsKFwiaGFzT3duUHJvcGVydHkgbm90IHN1cHBvcnRlZFwiKTtcbiAgfVxuXG4gIHZhciBpbml0TGlzdGVuZXJzID0gW107XG4gIHZhciBtb2R1bGVJbml0aWFsaXplcnMgPSBbXTtcblxuICAvLyBJbml0aWFsaXphdGlvblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIGlmIChhcGkuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRlc3RSYW5nZTtcbiAgICB2YXIgaW1wbGVtZW50c0RvbVJhbmdlID0gZmFsc2UsXG4gICAgICAgIGltcGxlbWVudHNUZXh0UmFuZ2UgPSBmYWxzZTtcblxuICAgIC8vIEZpcnN0LCBwZXJmb3JtIGJhc2ljIGZlYXR1cmUgdGVzdHNcblxuICAgIGlmIChpc0hvc3RNZXRob2QoZG9jdW1lbnQsIFwiY3JlYXRlUmFuZ2VcIikpIHtcbiAgICAgIHRlc3RSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICBpZiAoYXJlSG9zdE1ldGhvZHModGVzdFJhbmdlLCBkb21SYW5nZU1ldGhvZHMpICYmIGFyZUhvc3RQcm9wZXJ0aWVzKHRlc3RSYW5nZSwgZG9tUmFuZ2VQcm9wZXJ0aWVzKSkge1xuICAgICAgICBpbXBsZW1lbnRzRG9tUmFuZ2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGVzdFJhbmdlLmRldGFjaCgpO1xuICAgIH1cblxuICAgIHZhciBib2R5ID0gaXNIb3N0T2JqZWN0KGRvY3VtZW50LCBcImJvZHlcIikgPyBkb2N1bWVudC5ib2R5IDogZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO1xuXG4gICAgaWYgKGJvZHkgJiYgaXNIb3N0TWV0aG9kKGJvZHksIFwiY3JlYXRlVGV4dFJhbmdlXCIpKSB7XG4gICAgICB0ZXN0UmFuZ2UgPSBib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgaWYgKGlzVGV4dFJhbmdlKHRlc3RSYW5nZSkpIHtcbiAgICAgICAgaW1wbGVtZW50c1RleHRSYW5nZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpbXBsZW1lbnRzRG9tUmFuZ2UgJiYgIWltcGxlbWVudHNUZXh0UmFuZ2UpIHtcbiAgICAgIGZhaWwoXCJOZWl0aGVyIFJhbmdlIG5vciBUZXh0UmFuZ2UgYXJlIGltcGxlbWVudGVkXCIpO1xuICAgIH1cblxuICAgIGFwaS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgYXBpLmZlYXR1cmVzID0ge1xuICAgICAgaW1wbGVtZW50c0RvbVJhbmdlOiBpbXBsZW1lbnRzRG9tUmFuZ2UsXG4gICAgICBpbXBsZW1lbnRzVGV4dFJhbmdlOiBpbXBsZW1lbnRzVGV4dFJhbmdlXG4gICAgfTtcblxuICAgIC8vIEluaXRpYWxpemUgbW9kdWxlcyBhbmQgY2FsbCBpbml0IGxpc3RlbmVyc1xuICAgIHZhciBhbGxMaXN0ZW5lcnMgPSBtb2R1bGVJbml0aWFsaXplcnMuY29uY2F0KGluaXRMaXN0ZW5lcnMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhbGxMaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFsbExpc3RlbmVyc1tpXShhcGkpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgaWYgKGlzSG9zdE9iamVjdCh3aW5kb3csIFwiY29uc29sZVwiKSAmJiBpc0hvc3RNZXRob2Qod2luZG93LmNvbnNvbGUsIFwibG9nXCIpKSB7XG4gICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKFwiSW5pdCBsaXN0ZW5lciB0aHJldyBhbiBleGNlcHRpb24uIENvbnRpbnVpbmcuXCIsIGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFsbG93IGV4dGVybmFsIHNjcmlwdHMgdG8gaW5pdGlhbGl6ZSB0aGlzIGxpYnJhcnkgaW4gY2FzZSBpdCdzIGxvYWRlZCBhZnRlciB0aGUgZG9jdW1lbnQgaGFzIGxvYWRlZFxuICBhcGkuaW5pdCA9IGluaXQ7XG5cbiAgLy8gRXhlY3V0ZSBsaXN0ZW5lciBpbW1lZGlhdGVseSBpZiBhbHJlYWR5IGluaXRpYWxpemVkXG4gIGFwaS5hZGRJbml0TGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBpZiAoYXBpLmluaXRpYWxpemVkKSB7XG4gICAgICBsaXN0ZW5lcihhcGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY3JlYXRlTWlzc2luZ05hdGl2ZUFwaUxpc3RlbmVycyA9IFtdO1xuXG4gIGFwaS5hZGRDcmVhdGVNaXNzaW5nTmF0aXZlQXBpTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBjcmVhdGVNaXNzaW5nTmF0aXZlQXBpTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdOYXRpdmVBcGkod2luKSB7XG4gICAgd2luID0gd2luIHx8IHdpbmRvdztcbiAgICBpbml0KCk7XG5cbiAgICAvLyBOb3RpZnkgbGlzdGVuZXJzXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNyZWF0ZU1pc3NpbmdOYXRpdmVBcGlMaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNyZWF0ZU1pc3NpbmdOYXRpdmVBcGlMaXN0ZW5lcnNbaV0od2luKTtcbiAgICB9XG4gIH1cblxuICBhcGkuY3JlYXRlTWlzc2luZ05hdGl2ZUFwaSA9IGNyZWF0ZU1pc3NpbmdOYXRpdmVBcGk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gTW9kdWxlKG5hbWUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN1cHBvcnRlZCA9IGZhbHNlO1xuICB9XG5cbiAgTW9kdWxlLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuc3VwcG9ydGVkID0gZmFsc2U7XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2R1bGUgJ1wiICsgdGhpcy5uYW1lICsgXCInIGZhaWxlZCB0byBsb2FkOiBcIiArIHJlYXNvbik7XG4gIH07XG5cbiAgTW9kdWxlLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1zZykge1xuICAgIGFwaS53YXJuKFwiTW9kdWxlIFwiICsgdGhpcy5uYW1lICsgXCI6IFwiICsgbXNnKTtcbiAgfTtcblxuICBNb2R1bGUucHJvdG90eXBlLmNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKG1zZykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFcnJvciBpbiBSYW5neSBcIiArIHRoaXMubmFtZSArIFwiIG1vZHVsZTogXCIgKyBtc2cpO1xuICB9O1xuXG4gIGFwaS5jcmVhdGVNb2R1bGUgPSBmdW5jdGlvbiAobmFtZSwgaW5pdEZ1bmMpIHtcbiAgICB2YXIgbW9kdWxlID0gbmV3IE1vZHVsZShuYW1lKTtcbiAgICBhcGkubW9kdWxlc1tuYW1lXSA9IG1vZHVsZTtcblxuICAgIG1vZHVsZUluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uIChhcGkpIHtcbiAgICAgIGluaXRGdW5jKGFwaSwgbW9kdWxlKTtcbiAgICAgIG1vZHVsZS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBtb2R1bGUuc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgfTtcblxuICBhcGkucmVxdWlyZU1vZHVsZXMgPSBmdW5jdGlvbiAobW9kdWxlcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtb2R1bGVzLmxlbmd0aCwgbW9kdWxlLCBtb2R1bGVOYW1lOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIG1vZHVsZU5hbWUgPSBtb2R1bGVzW2ldO1xuICAgICAgbW9kdWxlID0gYXBpLm1vZHVsZXNbbW9kdWxlTmFtZV07XG4gICAgICBpZiAoIW1vZHVsZSB8fCAhKG1vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kdWxlICdcIiArIG1vZHVsZU5hbWUgKyBcIicgbm90IGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFtb2R1bGUuc3VwcG9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZHVsZSAnXCIgKyBtb2R1bGVOYW1lICsgXCInIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gV2FpdCBmb3IgZG9jdW1lbnQgdG8gbG9hZCBiZWZvcmUgcnVubmluZyB0ZXN0c1xuXG4gIHZhciBkb2NSZWFkeSA9IGZhbHNlO1xuXG4gIHZhciBsb2FkSGFuZGxlciA9IGZ1bmN0aW9uIGxvYWRIYW5kbGVyKGUpIHtcblxuICAgIGlmICghZG9jUmVhZHkpIHtcbiAgICAgIGRvY1JlYWR5ID0gdHJ1ZTtcbiAgICAgIGlmICghYXBpLmluaXRpYWxpemVkKSB7XG4gICAgICAgIGluaXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gVGVzdCB3aGV0aGVyIHdlIGhhdmUgd2luZG93IGFuZCBkb2N1bWVudCBvYmplY3RzIHRoYXQgd2Ugd2lsbCBuZWVkXG4gIGlmICgodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHdpbmRvdykpID09IFVOREVGSU5FRCkge1xuICAgIGZhaWwoXCJObyB3aW5kb3cgZm91bmRcIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICgodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZG9jdW1lbnQpKSA9PSBVTkRFRklORUQpIHtcbiAgICBmYWlsKFwiTm8gZG9jdW1lbnQgZm91bmRcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlzSG9zdE1ldGhvZChkb2N1bWVudCwgXCJhZGRFdmVudExpc3RlbmVyXCIpKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgbG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxuXG4gIC8vIEFkZCBhIGZhbGxiYWNrIGluIGNhc2UgdGhlIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQgaXNuJ3Qgc3VwcG9ydGVkXG4gIGlmIChpc0hvc3RNZXRob2Qod2luZG93LCBcImFkZEV2ZW50TGlzdGVuZXJcIikpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgbG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChpc0hvc3RNZXRob2Qod2luZG93LCBcImF0dGFjaEV2ZW50XCIpKSB7XG4gICAgd2luZG93LmF0dGFjaEV2ZW50KFwib25sb2FkXCIsIGxvYWRIYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBmYWlsKFwiV2luZG93IGRvZXMgbm90IGhhdmUgcmVxdWlyZWQgYWRkRXZlbnRMaXN0ZW5lciBvciBhdHRhY2hFdmVudCBtZXRob2RcIik7XG4gIH1cblxuICByZXR1cm4gYXBpO1xufSgpO1xucmFuZ3kuY3JlYXRlTW9kdWxlKFwiRG9tVXRpbFwiLCBmdW5jdGlvbiAoYXBpLCBtb2R1bGUpIHtcblxuICB2YXIgVU5ERUYgPSBcInVuZGVmaW5lZFwiO1xuICB2YXIgdXRpbCA9IGFwaS51dGlsO1xuXG4gIC8vIFBlcmZvcm0gZmVhdHVyZSB0ZXN0c1xuICBpZiAoIXV0aWwuYXJlSG9zdE1ldGhvZHMoZG9jdW1lbnQsIFtcImNyZWF0ZURvY3VtZW50RnJhZ21lbnRcIiwgXCJjcmVhdGVFbGVtZW50XCIsIFwiY3JlYXRlVGV4dE5vZGVcIl0pKSB7XG4gICAgbW9kdWxlLmZhaWwoXCJkb2N1bWVudCBtaXNzaW5nIGEgTm9kZSBjcmVhdGlvbiBtZXRob2RcIik7XG4gIH1cblxuICBpZiAoIXV0aWwuaXNIb3N0TWV0aG9kKGRvY3VtZW50LCBcImdldEVsZW1lbnRzQnlUYWdOYW1lXCIpKSB7XG4gICAgbW9kdWxlLmZhaWwoXCJkb2N1bWVudCBtaXNzaW5nIGdldEVsZW1lbnRzQnlUYWdOYW1lIG1ldGhvZFwiKTtcbiAgfVxuXG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGlmICghdXRpbC5hcmVIb3N0TWV0aG9kcyhlbCwgW1wiaW5zZXJ0QmVmb3JlXCIsIFwiYXBwZW5kQ2hpbGRcIiwgXCJjbG9uZU5vZGVcIl0gfHwgIXV0aWwuYXJlSG9zdE9iamVjdHMoZWwsIFtcInByZXZpb3VzU2libGluZ1wiLCBcIm5leHRTaWJsaW5nXCIsIFwiY2hpbGROb2Rlc1wiLCBcInBhcmVudE5vZGVcIl0pKSkge1xuICAgIG1vZHVsZS5mYWlsKFwiSW5jb21wbGV0ZSBFbGVtZW50IGltcGxlbWVudGF0aW9uXCIpO1xuICB9XG5cbiAgLy8gaW5uZXJIVE1MIGlzIHJlcXVpcmVkIGZvciBSYW5nZSdzIGNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCBtZXRob2RcbiAgaWYgKCF1dGlsLmlzSG9zdFByb3BlcnR5KGVsLCBcImlubmVySFRNTFwiKSkge1xuICAgIG1vZHVsZS5mYWlsKFwiRWxlbWVudCBpcyBtaXNzaW5nIGlubmVySFRNTCBwcm9wZXJ0eVwiKTtcbiAgfVxuXG4gIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwidGVzdFwiKTtcbiAgaWYgKCF1dGlsLmFyZUhvc3RNZXRob2RzKHRleHROb2RlLCBbXCJzcGxpdFRleHRcIiwgXCJkZWxldGVEYXRhXCIsIFwiaW5zZXJ0RGF0YVwiLCBcImFwcGVuZERhdGFcIiwgXCJjbG9uZU5vZGVcIl0gfHwgIXV0aWwuYXJlSG9zdE9iamVjdHMoZWwsIFtcInByZXZpb3VzU2libGluZ1wiLCBcIm5leHRTaWJsaW5nXCIsIFwiY2hpbGROb2Rlc1wiLCBcInBhcmVudE5vZGVcIl0pIHx8ICF1dGlsLmFyZUhvc3RQcm9wZXJ0aWVzKHRleHROb2RlLCBbXCJkYXRhXCJdKSkpIHtcbiAgICBtb2R1bGUuZmFpbChcIkluY29tcGxldGUgVGV4dCBOb2RlIGltcGxlbWVudGF0aW9uXCIpO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBSZW1vdmVkIHVzZSBvZiBpbmRleE9mIGJlY2F1c2Ugb2YgYSBiaXphcnJlIGJ1ZyBpbiBPcGVyYSB0aGF0IGlzIHRocm93biBpbiBvbmUgb2YgdGhlIEFjaWQzIHRlc3RzLiBJIGhhdmVuJ3QgYmVlblxuICAvLyBhYmxlIHRvIHJlcGxpY2F0ZSBpdCBvdXRzaWRlIG9mIHRoZSB0ZXN0LiBUaGUgYnVnIGlzIHRoYXQgaW5kZXhPZiByZXR1cm5zIC0xIHdoZW4gY2FsbGVkIG9uIGFuIEFycmF5IHRoYXRcbiAgLy8gY29udGFpbnMganVzdCB0aGUgZG9jdW1lbnQgYXMgYSBzaW5nbGUgZWxlbWVudCBhbmQgdGhlIHZhbHVlIHNlYXJjaGVkIGZvciBpcyB0aGUgZG9jdW1lbnQuXG4gIHZhciBhcnJheUNvbnRhaW5zID0gLypBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA/XG4gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oYXJyLCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyLmluZGV4T2YodmFsKSA+IC0xO1xuICAgICAgICAgICAgICAgICAgICAgIH06Ki9cblxuICBmdW5jdGlvbiBhcnJheUNvbnRhaW5zKGFyciwgdmFsKSB7XG4gICAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChhcnJbaV0gPT09IHZhbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIE9wZXJhIDExIHB1dHMgSFRNTCBlbGVtZW50cyBpbiB0aGUgbnVsbCBuYW1lc3BhY2UsIGl0IHNlZW1zLCBhbmQgSUUgNyBoYXMgdW5kZWZpbmVkIG5hbWVzcGFjZVVSSVxuICBmdW5jdGlvbiBpc0h0bWxOYW1lc3BhY2Uobm9kZSkge1xuICAgIHZhciBucztcbiAgICByZXR1cm4gX3R5cGVvZihub2RlLm5hbWVzcGFjZVVSSSkgPT0gVU5ERUYgfHwgKG5zID0gbm9kZS5uYW1lc3BhY2VVUkkpID09PSBudWxsIHx8IG5zID09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyZW50RWxlbWVudChub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gcGFyZW50Lm5vZGVUeXBlID09IDEgPyBwYXJlbnQgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Tm9kZUluZGV4KG5vZGUpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZykge1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vZGVMZW5ndGgobm9kZSkge1xuICAgIHZhciBjaGlsZE5vZGVzO1xuICAgIHJldHVybiBpc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpID8gbm9kZS5sZW5ndGggOiAoY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcykgPyBjaGlsZE5vZGVzLmxlbmd0aCA6IDA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb21tb25BbmNlc3Rvcihub2RlMSwgbm9kZTIpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gW10sXG4gICAgICAgIG47XG4gICAgZm9yIChuID0gbm9kZTE7IG47IG4gPSBuLnBhcmVudE5vZGUpIHtcbiAgICAgIGFuY2VzdG9ycy5wdXNoKG4pO1xuICAgIH1cblxuICAgIGZvciAobiA9IG5vZGUyOyBuOyBuID0gbi5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoYXJyYXlDb250YWlucyhhbmNlc3RvcnMsIG4pKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBbmNlc3Rvck9mKGFuY2VzdG9yLCBkZXNjZW5kYW50LCBzZWxmSXNBbmNlc3Rvcikge1xuICAgIHZhciBuID0gc2VsZklzQW5jZXN0b3IgPyBkZXNjZW5kYW50IDogZGVzY2VuZGFudC5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiA9PT0gYW5jZXN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbi5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbG9zZXN0QW5jZXN0b3JJbihub2RlLCBhbmNlc3Rvciwgc2VsZklzQW5jZXN0b3IpIHtcbiAgICB2YXIgcCxcbiAgICAgICAgbiA9IHNlbGZJc0FuY2VzdG9yID8gbm9kZSA6IG5vZGUucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAobikge1xuICAgICAgcCA9IG4ucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwID09PSBhbmNlc3Rvcikge1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICAgIG4gPSBwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ2hhcmFjdGVyRGF0YU5vZGUobm9kZSkge1xuICAgIHZhciB0ID0gbm9kZS5ub2RlVHlwZTtcbiAgICByZXR1cm4gdCA9PSAzIHx8IHQgPT0gNCB8fCB0ID09IDg7IC8vIFRleHQsIENEYXRhU2VjdGlvbiBvciBDb21tZW50XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRBZnRlcihub2RlLCBwcmVjZWRpbmdOb2RlKSB7XG4gICAgdmFyIG5leHROb2RlID0gcHJlY2VkaW5nTm9kZS5uZXh0U2libGluZyxcbiAgICAgICAgcGFyZW50ID0gcHJlY2VkaW5nTm9kZS5wYXJlbnROb2RlO1xuICAgIGlmIChuZXh0Tm9kZSkge1xuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBuZXh0Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvLyBOb3RlIHRoYXQgd2UgY2Fubm90IHVzZSBzcGxpdFRleHQoKSBiZWNhdXNlIGl0IGlzIGJ1Z3JpZGRlbiBpbiBJRSA5LlxuICBmdW5jdGlvbiBzcGxpdERhdGFOb2RlKG5vZGUsIGluZGV4KSB7XG4gICAgdmFyIG5ld05vZGUgPSBub2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgbmV3Tm9kZS5kZWxldGVEYXRhKDAsIGluZGV4KTtcbiAgICBub2RlLmRlbGV0ZURhdGEoaW5kZXgsIG5vZGUubGVuZ3RoIC0gaW5kZXgpO1xuICAgIGluc2VydEFmdGVyKG5ld05vZGUsIG5vZGUpO1xuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihub2RlLm93bmVyRG9jdW1lbnQpICE9IFVOREVGKSB7XG4gICAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihub2RlLmRvY3VtZW50KSAhPSBVTkRFRikge1xuICAgICAgcmV0dXJuIG5vZGUuZG9jdW1lbnQ7XG4gICAgfSBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBnZXREb2N1bWVudChub2RlLnBhcmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXREb2N1bWVudDogbm8gZG9jdW1lbnQgZm91bmQgZm9yIG5vZGVcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgICB2YXIgZG9jID0gZ2V0RG9jdW1lbnQobm9kZSk7XG4gICAgaWYgKF90eXBlb2YoZG9jLmRlZmF1bHRWaWV3KSAhPSBVTkRFRikge1xuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldztcbiAgICB9IGVsc2UgaWYgKF90eXBlb2YoZG9jLnBhcmVudFdpbmRvdykgIT0gVU5ERUYpIHtcbiAgICAgIHJldHVybiBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGEgd2luZG93IG9iamVjdCBmb3Igbm9kZVwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJZnJhbWVEb2N1bWVudChpZnJhbWVFbCkge1xuICAgIGlmIChfdHlwZW9mKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCkgIT0gVU5ERUYpIHtcbiAgICAgIHJldHVybiBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQ7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cpICE9IFVOREVGKSB7XG4gICAgICByZXR1cm4gaWZyYW1lRWwuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0SWZyYW1lV2luZG93OiBObyBEb2N1bWVudCBvYmplY3QgZm91bmQgZm9yIGlmcmFtZSBlbGVtZW50XCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElmcmFtZVdpbmRvdyhpZnJhbWVFbCkge1xuICAgIGlmIChfdHlwZW9mKGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cpICE9IFVOREVGKSB7XG4gICAgICByZXR1cm4gaWZyYW1lRWwuY29udGVudFdpbmRvdztcbiAgICB9IGVsc2UgaWYgKF90eXBlb2YoaWZyYW1lRWwuY29udGVudERvY3VtZW50KSAhPSBVTkRFRikge1xuICAgICAgcmV0dXJuIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0SWZyYW1lV2luZG93OiBObyBXaW5kb3cgb2JqZWN0IGZvdW5kIGZvciBpZnJhbWUgZWxlbWVudFwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCb2R5KGRvYykge1xuICAgIHJldHVybiB1dGlsLmlzSG9zdE9iamVjdChkb2MsIFwiYm9keVwiKSA/IGRvYy5ib2R5IDogZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJvb3RDb250YWluZXIobm9kZSkge1xuICAgIHZhciBwYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlUG9pbnRzKG5vZGVBLCBvZmZzZXRBLCBub2RlQiwgb2Zmc2V0Qikge1xuICAgIC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1UcmF2ZXJzYWwtUmFuZ2UvcmFuZ2VzLmh0bWwjTGV2ZWwtMi1SYW5nZS1Db21wYXJpbmdcbiAgICB2YXIgbm9kZUMsIHJvb3QsIGNoaWxkQSwgY2hpbGRCLCBuO1xuICAgIGlmIChub2RlQSA9PSBub2RlQikge1xuXG4gICAgICAvLyBDYXNlIDE6IG5vZGVzIGFyZSB0aGUgc2FtZVxuICAgICAgcmV0dXJuIG9mZnNldEEgPT09IG9mZnNldEIgPyAwIDogb2Zmc2V0QSA8IG9mZnNldEIgPyAtMSA6IDE7XG4gICAgfSBlbHNlIGlmIChub2RlQyA9IGdldENsb3Nlc3RBbmNlc3RvckluKG5vZGVCLCBub2RlQSwgdHJ1ZSkpIHtcblxuICAgICAgLy8gQ2FzZSAyOiBub2RlIEMgKGNvbnRhaW5lciBCIG9yIGFuIGFuY2VzdG9yKSBpcyBhIGNoaWxkIG5vZGUgb2YgQVxuICAgICAgcmV0dXJuIG9mZnNldEEgPD0gZ2V0Tm9kZUluZGV4KG5vZGVDKSA/IC0xIDogMTtcbiAgICB9IGVsc2UgaWYgKG5vZGVDID0gZ2V0Q2xvc2VzdEFuY2VzdG9ySW4obm9kZUEsIG5vZGVCLCB0cnVlKSkge1xuXG4gICAgICAvLyBDYXNlIDM6IG5vZGUgQyAoY29udGFpbmVyIEEgb3IgYW4gYW5jZXN0b3IpIGlzIGEgY2hpbGQgbm9kZSBvZiBCXG4gICAgICByZXR1cm4gZ2V0Tm9kZUluZGV4KG5vZGVDKSA8IG9mZnNldEIgPyAtMSA6IDE7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gQ2FzZSA0OiBjb250YWluZXJzIGFyZSBzaWJsaW5ncyBvciBkZXNjZW5kYW50cyBvZiBzaWJsaW5nc1xuICAgICAgcm9vdCA9IGdldENvbW1vbkFuY2VzdG9yKG5vZGVBLCBub2RlQik7XG4gICAgICBjaGlsZEEgPSBub2RlQSA9PT0gcm9vdCA/IHJvb3QgOiBnZXRDbG9zZXN0QW5jZXN0b3JJbihub2RlQSwgcm9vdCwgdHJ1ZSk7XG4gICAgICBjaGlsZEIgPSBub2RlQiA9PT0gcm9vdCA/IHJvb3QgOiBnZXRDbG9zZXN0QW5jZXN0b3JJbihub2RlQiwgcm9vdCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChjaGlsZEEgPT09IGNoaWxkQikge1xuICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBiZSBwb3NzaWJsZVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbXBhcmVQb2ludHMgZ290IHRvIGNhc2UgNCBhbmQgY2hpbGRBIGFuZCBjaGlsZEIgYXJlIHRoZSBzYW1lIVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSByb290LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgaWYgKG4gPT09IGNoaWxkQSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gY2hpbGRCKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbiA9IG4ubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5vdCBiZSBoZXJlIVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmcmFnbWVudEZyb21Ob2RlQ2hpbGRyZW4obm9kZSkge1xuICAgIHZhciBmcmFnbWVudCA9IGdldERvY3VtZW50KG5vZGUpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgY2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkID0gbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3ROb2RlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiBcIltObyBub2RlXVwiO1xuICAgIH1cbiAgICBpZiAoaXNDaGFyYWN0ZXJEYXRhTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuICdcIicgKyBub2RlLmRhdGEgKyAnXCInO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICB2YXIgaWRBdHRyID0gbm9kZS5pZCA/ICcgaWQ9XCInICsgbm9kZS5pZCArICdcIicgOiBcIlwiO1xuICAgICAgcmV0dXJuIFwiPFwiICsgbm9kZS5ub2RlTmFtZSArIGlkQXR0ciArIFwiPltcIiArIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggKyBcIl1cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZU5hbWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gTm9kZUl0ZXJhdG9yKHJvb3QpIHtcbiAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIHRoaXMuX25leHQgPSByb290O1xuICB9XG5cbiAgTm9kZUl0ZXJhdG9yLnByb3RvdHlwZSA9IHtcbiAgICBfY3VycmVudDogbnVsbCxcblxuICAgIGhhc05leHQ6IGZ1bmN0aW9uIGhhc05leHQoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl9uZXh0O1xuICAgIH0sXG5cbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIG4gPSB0aGlzLl9jdXJyZW50ID0gdGhpcy5fbmV4dDtcbiAgICAgIHZhciBjaGlsZCwgbmV4dDtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICAgIGNoaWxkID0gbi5maXJzdENoaWxkO1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICB0aGlzLl9uZXh0ID0gY2hpbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICAgICAgd2hpbGUgKG4gIT09IHRoaXMucm9vdCAmJiAhKG5leHQgPSBuLm5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fbmV4dCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICAgIH0sXG5cbiAgICBkZXRhY2g6IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9uZXh0ID0gdGhpcy5yb290ID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3Iocm9vdCkge1xuICAgIHJldHVybiBuZXcgTm9kZUl0ZXJhdG9yKHJvb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gRG9tUG9zaXRpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfVxuXG4gIERvbVBvc2l0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhwb3MpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUgPT09IHBvcy5ub2RlICYgdGhpcy5vZmZzZXQgPT0gcG9zLm9mZnNldDtcbiAgICB9LFxuXG4gICAgaW5zcGVjdDogZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgIHJldHVybiBcIltEb21Qb3NpdGlvbihcIiArIGluc3BlY3ROb2RlKHRoaXMubm9kZSkgKyBcIjpcIiArIHRoaXMub2Zmc2V0ICsgXCIpXVwiO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBET01FeGNlcHRpb24oY29kZU5hbWUpIHtcbiAgICB0aGlzLmNvZGUgPSB0aGlzW2NvZGVOYW1lXTtcbiAgICB0aGlzLmNvZGVOYW1lID0gY29kZU5hbWU7XG4gICAgdGhpcy5tZXNzYWdlID0gXCJET01FeGNlcHRpb246IFwiICsgdGhpcy5jb2RlTmFtZTtcbiAgfVxuXG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgSU5ERVhfU0laRV9FUlI6IDEsXG4gICAgSElFUkFSQ0hZX1JFUVVFU1RfRVJSOiAzLFxuICAgIFdST05HX0RPQ1VNRU5UX0VSUjogNCxcbiAgICBOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlI6IDcsXG4gICAgTk9UX0ZPVU5EX0VSUjogOCxcbiAgICBOT1RfU1VQUE9SVEVEX0VSUjogOSxcbiAgICBJTlZBTElEX1NUQVRFX0VSUjogMTFcbiAgfTtcblxuICBET01FeGNlcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gIH07XG5cbiAgYXBpLmRvbSA9IHtcbiAgICBhcnJheUNvbnRhaW5zOiBhcnJheUNvbnRhaW5zLFxuICAgIGlzSHRtbE5hbWVzcGFjZTogaXNIdG1sTmFtZXNwYWNlLFxuICAgIHBhcmVudEVsZW1lbnQ6IHBhcmVudEVsZW1lbnQsXG4gICAgZ2V0Tm9kZUluZGV4OiBnZXROb2RlSW5kZXgsXG4gICAgZ2V0Tm9kZUxlbmd0aDogZ2V0Tm9kZUxlbmd0aCxcbiAgICBnZXRDb21tb25BbmNlc3RvcjogZ2V0Q29tbW9uQW5jZXN0b3IsXG4gICAgaXNBbmNlc3Rvck9mOiBpc0FuY2VzdG9yT2YsXG4gICAgZ2V0Q2xvc2VzdEFuY2VzdG9ySW46IGdldENsb3Nlc3RBbmNlc3RvckluLFxuICAgIGlzQ2hhcmFjdGVyRGF0YU5vZGU6IGlzQ2hhcmFjdGVyRGF0YU5vZGUsXG4gICAgaW5zZXJ0QWZ0ZXI6IGluc2VydEFmdGVyLFxuICAgIHNwbGl0RGF0YU5vZGU6IHNwbGl0RGF0YU5vZGUsXG4gICAgZ2V0RG9jdW1lbnQ6IGdldERvY3VtZW50LFxuICAgIGdldFdpbmRvdzogZ2V0V2luZG93LFxuICAgIGdldElmcmFtZVdpbmRvdzogZ2V0SWZyYW1lV2luZG93LFxuICAgIGdldElmcmFtZURvY3VtZW50OiBnZXRJZnJhbWVEb2N1bWVudCxcbiAgICBnZXRCb2R5OiBnZXRCb2R5LFxuICAgIGdldFJvb3RDb250YWluZXI6IGdldFJvb3RDb250YWluZXIsXG4gICAgY29tcGFyZVBvaW50czogY29tcGFyZVBvaW50cyxcbiAgICBpbnNwZWN0Tm9kZTogaW5zcGVjdE5vZGUsXG4gICAgZnJhZ21lbnRGcm9tTm9kZUNoaWxkcmVuOiBmcmFnbWVudEZyb21Ob2RlQ2hpbGRyZW4sXG4gICAgY3JlYXRlSXRlcmF0b3I6IGNyZWF0ZUl0ZXJhdG9yLFxuICAgIERvbVBvc2l0aW9uOiBEb21Qb3NpdGlvblxuICB9O1xuXG4gIGFwaS5ET01FeGNlcHRpb24gPSBET01FeGNlcHRpb247XG59KTtyYW5neS5jcmVhdGVNb2R1bGUoXCJEb21SYW5nZVwiLCBmdW5jdGlvbiAoYXBpLCBtb2R1bGUpIHtcbiAgYXBpLnJlcXVpcmVNb2R1bGVzKFtcIkRvbVV0aWxcIl0pO1xuXG4gIHZhciBkb20gPSBhcGkuZG9tO1xuICB2YXIgRG9tUG9zaXRpb24gPSBkb20uRG9tUG9zaXRpb247XG4gIHZhciBET01FeGNlcHRpb24gPSBhcGkuRE9NRXhjZXB0aW9uO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbnNcblxuICBmdW5jdGlvbiBpc05vblRleHRQYXJ0aWFsbHlTZWxlY3RlZChub2RlLCByYW5nZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlICE9IDMgJiYgKGRvbS5pc0FuY2VzdG9yT2Yobm9kZSwgcmFuZ2Uuc3RhcnRDb250YWluZXIsIHRydWUpIHx8IGRvbS5pc0FuY2VzdG9yT2Yobm9kZSwgcmFuZ2UuZW5kQ29udGFpbmVyLCB0cnVlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSYW5nZURvY3VtZW50KHJhbmdlKSB7XG4gICAgcmV0dXJuIGRvbS5nZXREb2N1bWVudChyYW5nZS5zdGFydENvbnRhaW5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHJhbmdlLCB0eXBlLCBhcmdzKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IHJhbmdlLl9saXN0ZW5lcnNbdHlwZV07XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbChyYW5nZSwgeyB0YXJnZXQ6IHJhbmdlLCBhcmdzOiBhcmdzIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJvdW5kYXJ5QmVmb3JlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBEb21Qb3NpdGlvbihub2RlLnBhcmVudE5vZGUsIGRvbS5nZXROb2RlSW5kZXgobm9kZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Qm91bmRhcnlBZnRlck5vZGUobm9kZSkge1xuICAgIHJldHVybiBuZXcgRG9tUG9zaXRpb24obm9kZS5wYXJlbnROb2RlLCBkb20uZ2V0Tm9kZUluZGV4KG5vZGUpICsgMSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnROb2RlQXRQb3NpdGlvbihub2RlLCBuLCBvKSB7XG4gICAgdmFyIGZpcnN0Tm9kZUluc2VydGVkID0gbm9kZS5ub2RlVHlwZSA9PSAxMSA/IG5vZGUuZmlyc3RDaGlsZCA6IG5vZGU7XG4gICAgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKG4pKSB7XG4gICAgICBpZiAobyA9PSBuLmxlbmd0aCkge1xuICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIobm9kZSwgbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG8gPT0gMCA/IG4gOiBkb20uc3BsaXREYXRhTm9kZShuLCBvKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvID49IG4uY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIG4uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4uaW5zZXJ0QmVmb3JlKG5vZGUsIG4uY2hpbGROb2Rlc1tvXSk7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdE5vZGVJbnNlcnRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lU3VidHJlZShpdGVyYXRvcikge1xuICAgIHZhciBwYXJ0aWFsbHlTZWxlY3RlZDtcbiAgICBmb3IgKHZhciBub2RlLCBmcmFnID0gZ2V0UmFuZ2VEb2N1bWVudChpdGVyYXRvci5yYW5nZSkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdWJJdGVyYXRvcjsgbm9kZSA9IGl0ZXJhdG9yLm5leHQoKTspIHtcbiAgICAgIHBhcnRpYWxseVNlbGVjdGVkID0gaXRlcmF0b3IuaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUoKTtcblxuICAgICAgbm9kZSA9IG5vZGUuY2xvbmVOb2RlKCFwYXJ0aWFsbHlTZWxlY3RlZCk7XG4gICAgICBpZiAocGFydGlhbGx5U2VsZWN0ZWQpIHtcbiAgICAgICAgc3ViSXRlcmF0b3IgPSBpdGVyYXRvci5nZXRTdWJ0cmVlSXRlcmF0b3IoKTtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjbG9uZVN1YnRyZWUoc3ViSXRlcmF0b3IpKTtcbiAgICAgICAgc3ViSXRlcmF0b3IuZGV0YWNoKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxMCkge1xuICAgICAgICAvLyBEb2N1bWVudFR5cGVcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIkhJRVJBUkNIWV9SRVFVRVNUX0VSUlwiKTtcbiAgICAgIH1cbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZVN1YnRyZWUocmFuZ2VJdGVyYXRvciwgZnVuYywgaXRlcmF0b3JTdGF0ZSkge1xuICAgIHZhciBpdCwgbjtcbiAgICBpdGVyYXRvclN0YXRlID0gaXRlcmF0b3JTdGF0ZSB8fCB7IHN0b3A6IGZhbHNlIH07XG4gICAgZm9yICh2YXIgbm9kZSwgc3ViUmFuZ2VJdGVyYXRvcjsgbm9kZSA9IHJhbmdlSXRlcmF0b3IubmV4dCgpOykge1xuICAgICAgLy9sb2cuZGVidWcoXCJpdGVyYXRlU3VidHJlZSwgcGFydGlhbGx5IHNlbGVjdGVkOiBcIiArIHJhbmdlSXRlcmF0b3IuaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUoKSwgbm9kZVRvU3RyaW5nKG5vZGUpKTtcbiAgICAgIGlmIChyYW5nZUl0ZXJhdG9yLmlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlKCkpIHtcbiAgICAgICAgLy8gVGhlIG5vZGUgaXMgcGFydGlhbGx5IHNlbGVjdGVkIGJ5IHRoZSBSYW5nZSwgc28gd2UgY2FuIHVzZSBhIG5ldyBSYW5nZUl0ZXJhdG9yIG9uIHRoZSBwb3J0aW9uIG9mIHRoZVxuICAgICAgICAvLyBub2RlIHNlbGVjdGVkIGJ5IHRoZSBSYW5nZS5cbiAgICAgICAgaWYgKGZ1bmMobm9kZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaXRlcmF0b3JTdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ViUmFuZ2VJdGVyYXRvciA9IHJhbmdlSXRlcmF0b3IuZ2V0U3VidHJlZUl0ZXJhdG9yKCk7XG4gICAgICAgICAgaXRlcmF0ZVN1YnRyZWUoc3ViUmFuZ2VJdGVyYXRvciwgZnVuYywgaXRlcmF0b3JTdGF0ZSk7XG4gICAgICAgICAgc3ViUmFuZ2VJdGVyYXRvci5kZXRhY2godHJ1ZSk7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yU3RhdGUuc3RvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHdob2xlIG5vZGUgaXMgc2VsZWN0ZWQsIHNvIHdlIGNhbiB1c2UgZWZmaWNpZW50IERPTSBpdGVyYXRpb24gdG8gaXRlcmF0ZSBvdmVyIHRoZSBub2RlIGFuZCBpdHNcbiAgICAgICAgLy8gZGVzY2VuZGFudFxuICAgICAgICBpdCA9IGRvbS5jcmVhdGVJdGVyYXRvcihub2RlKTtcbiAgICAgICAgd2hpbGUgKG4gPSBpdC5uZXh0KCkpIHtcbiAgICAgICAgICBpZiAoZnVuYyhuKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yU3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlU3VidHJlZShpdGVyYXRvcikge1xuICAgIHZhciBzdWJJdGVyYXRvcjtcbiAgICB3aGlsZSAoaXRlcmF0b3IubmV4dCgpKSB7XG4gICAgICBpZiAoaXRlcmF0b3IuaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUoKSkge1xuICAgICAgICBzdWJJdGVyYXRvciA9IGl0ZXJhdG9yLmdldFN1YnRyZWVJdGVyYXRvcigpO1xuICAgICAgICBkZWxldGVTdWJ0cmVlKHN1Ykl0ZXJhdG9yKTtcbiAgICAgICAgc3ViSXRlcmF0b3IuZGV0YWNoKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3IucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdFN1YnRyZWUoaXRlcmF0b3IpIHtcblxuICAgIGZvciAodmFyIG5vZGUsIGZyYWcgPSBnZXRSYW5nZURvY3VtZW50KGl0ZXJhdG9yLnJhbmdlKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN1Ykl0ZXJhdG9yOyBub2RlID0gaXRlcmF0b3IubmV4dCgpOykge1xuXG4gICAgICBpZiAoaXRlcmF0b3IuaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUoKSkge1xuICAgICAgICBub2RlID0gbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICBzdWJJdGVyYXRvciA9IGl0ZXJhdG9yLmdldFN1YnRyZWVJdGVyYXRvcigpO1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGV4dHJhY3RTdWJ0cmVlKHN1Ykl0ZXJhdG9yKSk7XG4gICAgICAgIHN1Ykl0ZXJhdG9yLmRldGFjaCh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdG9yLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMTApIHtcbiAgICAgICAgLy8gRG9jdW1lbnRUeXBlXG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJISUVSQVJDSFlfUkVRVUVTVF9FUlJcIik7XG4gICAgICB9XG4gICAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vZGVzSW5SYW5nZShyYW5nZSwgbm9kZVR5cGVzLCBmaWx0ZXIpIHtcbiAgICAvL2xvZy5pbmZvKFwiZ2V0Tm9kZXNJblJhbmdlLCBcIiArIG5vZGVUeXBlcy5qb2luKFwiLFwiKSk7XG4gICAgdmFyIGZpbHRlck5vZGVUeXBlcyA9ICEhKG5vZGVUeXBlcyAmJiBub2RlVHlwZXMubGVuZ3RoKSxcbiAgICAgICAgcmVnZXg7XG4gICAgdmFyIGZpbHRlckV4aXN0cyA9ICEhZmlsdGVyO1xuICAgIGlmIChmaWx0ZXJOb2RlVHlwZXMpIHtcbiAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBub2RlVHlwZXMuam9pbihcInxcIikgKyBcIikkXCIpO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIGl0ZXJhdGVTdWJ0cmVlKG5ldyBSYW5nZUl0ZXJhdG9yKHJhbmdlLCBmYWxzZSksIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoKCFmaWx0ZXJOb2RlVHlwZXMgfHwgcmVnZXgudGVzdChub2RlLm5vZGVUeXBlKSkgJiYgKCFmaWx0ZXJFeGlzdHMgfHwgZmlsdGVyKG5vZGUpKSkge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbnNwZWN0KHJhbmdlKSB7XG4gICAgdmFyIG5hbWUgPSB0eXBlb2YgcmFuZ2UuZ2V0TmFtZSA9PSBcInVuZGVmaW5lZFwiID8gXCJSYW5nZVwiIDogcmFuZ2UuZ2V0TmFtZSgpO1xuICAgIHJldHVybiBcIltcIiArIG5hbWUgKyBcIihcIiArIGRvbS5pbnNwZWN0Tm9kZShyYW5nZS5zdGFydENvbnRhaW5lcikgKyBcIjpcIiArIHJhbmdlLnN0YXJ0T2Zmc2V0ICsgXCIsIFwiICsgZG9tLmluc3BlY3ROb2RlKHJhbmdlLmVuZENvbnRhaW5lcikgKyBcIjpcIiArIHJhbmdlLmVuZE9mZnNldCArIFwiKV1cIjtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gUmFuZ2VJdGVyYXRvciBjb2RlIHBhcnRpYWxseSBib3Jyb3dzIGZyb20gSUVSYW5nZSBieSBUaW0gUnlhbiAoaHR0cDovL2dpdGh1Yi5jb20vdGltY2FtZXJvbnJ5YW4vSUVSYW5nZSlcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBSYW5nZUl0ZXJhdG9yKHJhbmdlLCBjbG9uZVBhcnRpYWxseVNlbGVjdGVkVGV4dE5vZGVzKSB7XG4gICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgIHRoaXMuY2xvbmVQYXJ0aWFsbHlTZWxlY3RlZFRleHROb2RlcyA9IGNsb25lUGFydGlhbGx5U2VsZWN0ZWRUZXh0Tm9kZXM7XG5cbiAgICBpZiAoIXJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgdGhpcy5zYyA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgdGhpcy5zbyA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgdGhpcy5lYyA9IHJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgIHRoaXMuZW8gPSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgICB2YXIgcm9vdCA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gICAgICBpZiAodGhpcy5zYyA9PT0gdGhpcy5lYyAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZSh0aGlzLnNjKSkge1xuICAgICAgICB0aGlzLmlzU2luZ2xlQ2hhcmFjdGVyRGF0YU5vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9maXJzdCA9IHRoaXMuX2xhc3QgPSB0aGlzLl9uZXh0ID0gdGhpcy5zYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gdGhpcy5fbmV4dCA9IHRoaXMuc2MgPT09IHJvb3QgJiYgIWRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKHRoaXMuc2MpID8gdGhpcy5zYy5jaGlsZE5vZGVzW3RoaXMuc29dIDogZG9tLmdldENsb3Nlc3RBbmNlc3RvckluKHRoaXMuc2MsIHJvb3QsIHRydWUpO1xuICAgICAgICB0aGlzLl9sYXN0ID0gdGhpcy5lYyA9PT0gcm9vdCAmJiAhZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUodGhpcy5lYykgPyB0aGlzLmVjLmNoaWxkTm9kZXNbdGhpcy5lbyAtIDFdIDogZG9tLmdldENsb3Nlc3RBbmNlc3RvckluKHRoaXMuZWMsIHJvb3QsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFJhbmdlSXRlcmF0b3IucHJvdG90eXBlID0ge1xuICAgIF9jdXJyZW50OiBudWxsLFxuICAgIF9uZXh0OiBudWxsLFxuICAgIF9maXJzdDogbnVsbCxcbiAgICBfbGFzdDogbnVsbCxcbiAgICBpc1NpbmdsZUNoYXJhY3RlckRhdGFOb2RlOiBmYWxzZSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5fbmV4dCA9IHRoaXMuX2ZpcnN0O1xuICAgIH0sXG5cbiAgICBoYXNOZXh0OiBmdW5jdGlvbiBoYXNOZXh0KCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fbmV4dDtcbiAgICB9LFxuXG4gICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIC8vIE1vdmUgdG8gbmV4dCBub2RlXG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9uZXh0O1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5fbmV4dCA9IGN1cnJlbnQgIT09IHRoaXMuX2xhc3QgPyBjdXJyZW50Lm5leHRTaWJsaW5nIDogbnVsbDtcblxuICAgICAgICAvLyBDaGVjayBmb3IgcGFydGlhbGx5IHNlbGVjdGVkIHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKGN1cnJlbnQpICYmIHRoaXMuY2xvbmVQYXJ0aWFsbHlTZWxlY3RlZFRleHROb2Rlcykge1xuICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmVjKSB7XG5cbiAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5jbG9uZU5vZGUodHJ1ZSkpLmRlbGV0ZURhdGEodGhpcy5lbywgY3VycmVudC5sZW5ndGggLSB0aGlzLmVvKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnQgPT09IHRoaXMuc2MpIHtcblxuICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LmNsb25lTm9kZSh0cnVlKSkuZGVsZXRlRGF0YSgwLCB0aGlzLnNvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50LFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZDtcblxuICAgICAgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKGN1cnJlbnQpICYmIChjdXJyZW50ID09PSB0aGlzLnNjIHx8IGN1cnJlbnQgPT09IHRoaXMuZWMpKSB7XG4gICAgICAgIHN0YXJ0ID0gY3VycmVudCA9PT0gdGhpcy5zYyA/IHRoaXMuc28gOiAwO1xuICAgICAgICBlbmQgPSBjdXJyZW50ID09PSB0aGlzLmVjID8gdGhpcy5lbyA6IGN1cnJlbnQubGVuZ3RoO1xuICAgICAgICBpZiAoc3RhcnQgIT0gZW5kKSB7XG4gICAgICAgICAgY3VycmVudC5kZWxldGVEYXRhKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXJyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjdXJyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY3VycmVudCk7XG4gICAgICAgIH0gZWxzZSB7fVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDaGVja3MgaWYgdGhlIGN1cnJlbnQgbm9kZSBpcyBwYXJ0aWFsbHkgc2VsZWN0ZWRcbiAgICBpc1BhcnRpYWxseVNlbGVjdGVkU3VidHJlZTogZnVuY3Rpb24gaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICByZXR1cm4gaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQoY3VycmVudCwgdGhpcy5yYW5nZSk7XG4gICAgfSxcblxuICAgIGdldFN1YnRyZWVJdGVyYXRvcjogZnVuY3Rpb24gZ2V0U3VidHJlZUl0ZXJhdG9yKCkge1xuICAgICAgdmFyIHN1YlJhbmdlO1xuICAgICAgaWYgKHRoaXMuaXNTaW5nbGVDaGFyYWN0ZXJEYXRhTm9kZSkge1xuICAgICAgICBzdWJSYW5nZSA9IHRoaXMucmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgICBzdWJSYW5nZS5jb2xsYXBzZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ViUmFuZ2UgPSBuZXcgUmFuZ2UoZ2V0UmFuZ2VEb2N1bWVudCh0aGlzLnJhbmdlKSk7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgdmFyIHN0YXJ0Q29udGFpbmVyID0gY3VycmVudCxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IGN1cnJlbnQsXG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBkb20uZ2V0Tm9kZUxlbmd0aChjdXJyZW50KTtcblxuICAgICAgICBpZiAoZG9tLmlzQW5jZXN0b3JPZihjdXJyZW50LCB0aGlzLnNjLCB0cnVlKSkge1xuICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gdGhpcy5zYztcbiAgICAgICAgICBzdGFydE9mZnNldCA9IHRoaXMuc287XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbS5pc0FuY2VzdG9yT2YoY3VycmVudCwgdGhpcy5lYywgdHJ1ZSkpIHtcbiAgICAgICAgICBlbmRDb250YWluZXIgPSB0aGlzLmVjO1xuICAgICAgICAgIGVuZE9mZnNldCA9IHRoaXMuZW87XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVCb3VuZGFyaWVzKHN1YlJhbmdlLCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2VJdGVyYXRvcihzdWJSYW5nZSwgdGhpcy5jbG9uZVBhcnRpYWxseVNlbGVjdGVkVGV4dE5vZGVzKTtcbiAgICB9LFxuXG4gICAgZGV0YWNoOiBmdW5jdGlvbiBkZXRhY2goZGV0YWNoUmFuZ2UpIHtcbiAgICAgIGlmIChkZXRhY2hSYW5nZSkge1xuICAgICAgICB0aGlzLnJhbmdlLmRldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5yYW5nZSA9IHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9uZXh0ID0gdGhpcy5fZmlyc3QgPSB0aGlzLl9sYXN0ID0gdGhpcy5zYyA9IHRoaXMuc28gPSB0aGlzLmVjID0gdGhpcy5lbyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRXhjZXB0aW9uc1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFJhbmdlRXhjZXB0aW9uKGNvZGVOYW1lKSB7XG4gICAgdGhpcy5jb2RlID0gdGhpc1tjb2RlTmFtZV07XG4gICAgdGhpcy5jb2RlTmFtZSA9IGNvZGVOYW1lO1xuICAgIHRoaXMubWVzc2FnZSA9IFwiUmFuZ2VFeGNlcHRpb246IFwiICsgdGhpcy5jb2RlTmFtZTtcbiAgfVxuXG4gIFJhbmdlRXhjZXB0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBCQURfQk9VTkRBUllQT0lOVFNfRVJSOiAxLFxuICAgIElOVkFMSURfTk9ERV9UWVBFX0VSUjogMlxuICB9O1xuXG4gIFJhbmdlRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICB9O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEN1cnJlbnRseSBpdGVyYXRlcyB0aHJvdWdoIGFsbCBub2RlcyBpbiB0aGUgcmFuZ2Ugb24gY3JlYXRpb24gdW50aWwgSSB0aGluayBvZiBhIGRlY2VudCB3YXkgdG8gZG8gaXRcbiAgICogVE9ETzogTG9vayBpbnRvIG1ha2luZyB0aGlzIGEgcHJvcGVyIGl0ZXJhdG9yLCBub3QgcmVxdWlyaW5nIHByZWxvYWRpbmcgZXZlcnl0aGluZyBmaXJzdFxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFJhbmdlTm9kZUl0ZXJhdG9yKHJhbmdlLCBub2RlVHlwZXMsIGZpbHRlcikge1xuICAgIHRoaXMubm9kZXMgPSBnZXROb2Rlc0luUmFuZ2UocmFuZ2UsIG5vZGVUeXBlcywgZmlsdGVyKTtcbiAgICB0aGlzLl9uZXh0ID0gdGhpcy5ub2Rlc1swXTtcbiAgICB0aGlzLl9wb3NpdGlvbiA9IDA7XG4gIH1cblxuICBSYW5nZU5vZGVJdGVyYXRvci5wcm90b3R5cGUgPSB7XG4gICAgX2N1cnJlbnQ6IG51bGwsXG5cbiAgICBoYXNOZXh0OiBmdW5jdGlvbiBoYXNOZXh0KCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fbmV4dDtcbiAgICB9LFxuXG4gICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9uZXh0O1xuICAgICAgdGhpcy5fbmV4dCA9IHRoaXMubm9kZXNbKyt0aGlzLl9wb3NpdGlvbl07XG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgICB9LFxuXG4gICAgZGV0YWNoOiBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fbmV4dCA9IHRoaXMubm9kZXMgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYmVmb3JlQWZ0ZXJOb2RlVHlwZXMgPSBbMSwgMywgNCwgNSwgNywgOCwgMTBdO1xuICB2YXIgcm9vdENvbnRhaW5lck5vZGVUeXBlcyA9IFsyLCA5LCAxMV07XG4gIHZhciByZWFkb25seU5vZGVUeXBlcyA9IFs1LCA2LCAxMCwgMTJdO1xuICB2YXIgaW5zZXJ0YWJsZU5vZGVUeXBlcyA9IFsxLCAzLCA0LCA1LCA3LCA4LCAxMCwgMTFdO1xuICB2YXIgc3Vycm91bmROb2RlVHlwZXMgPSBbMSwgMywgNCwgNSwgNywgOF07XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW5jZXN0b3JGaW5kZXIobm9kZVR5cGVzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBzZWxmSXNBbmNlc3Rvcikge1xuICAgICAgdmFyIHQsXG4gICAgICAgICAgbiA9IHNlbGZJc0FuY2VzdG9yID8gbm9kZSA6IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgIHQgPSBuLm5vZGVUeXBlO1xuICAgICAgICBpZiAoZG9tLmFycmF5Q29udGFpbnMobm9kZVR5cGVzLCB0KSkge1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGdldFJvb3RDb250YWluZXIgPSBkb20uZ2V0Um9vdENvbnRhaW5lcjtcbiAgdmFyIGdldERvY3VtZW50T3JGcmFnbWVudENvbnRhaW5lciA9IGNyZWF0ZUFuY2VzdG9yRmluZGVyKFs5LCAxMV0pO1xuICB2YXIgZ2V0UmVhZG9ubHlBbmNlc3RvciA9IGNyZWF0ZUFuY2VzdG9yRmluZGVyKHJlYWRvbmx5Tm9kZVR5cGVzKTtcbiAgdmFyIGdldERvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yID0gY3JlYXRlQW5jZXN0b3JGaW5kZXIoWzYsIDEwLCAxMl0pO1xuXG4gIGZ1bmN0aW9uIGFzc2VydE5vRG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3Iobm9kZSwgYWxsb3dTZWxmKSB7XG4gICAgaWYgKGdldERvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIGFsbG93U2VsZikpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUV4Y2VwdGlvbihcIklOVkFMSURfTk9ERV9UWVBFX0VSUlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb3REZXRhY2hlZChyYW5nZSkge1xuICAgIGlmICghcmFuZ2Uuc3RhcnRDb250YWluZXIpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTlZBTElEX1NUQVRFX0VSUlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRWYWxpZE5vZGVUeXBlKG5vZGUsIGludmFsaWRUeXBlcykge1xuICAgIGlmICghZG9tLmFycmF5Q29udGFpbnMoaW52YWxpZFR5cGVzLCBub2RlLm5vZGVUeXBlKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXhjZXB0aW9uKFwiSU5WQUxJRF9OT0RFX1RZUEVfRVJSXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydFZhbGlkT2Zmc2V0KG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IChkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShub2RlKSA/IG5vZGUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTkRFWF9TSVpFX0VSUlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRTYW1lRG9jdW1lbnRPckZyYWdtZW50KG5vZGUxLCBub2RlMikge1xuICAgIGlmIChnZXREb2N1bWVudE9yRnJhZ21lbnRDb250YWluZXIobm9kZTEsIHRydWUpICE9PSBnZXREb2N1bWVudE9yRnJhZ21lbnRDb250YWluZXIobm9kZTIsIHRydWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiV1JPTkdfRE9DVU1FTlRfRVJSXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVOb3RSZWFkT25seShub2RlKSB7XG4gICAgaWYgKGdldFJlYWRvbmx5QW5jZXN0b3Iobm9kZSwgdHJ1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlJcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZShub2RlLCBjb2RlTmFtZSkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihjb2RlTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNPcnBoYW4obm9kZSkge1xuICAgIHJldHVybiAhZG9tLmFycmF5Q29udGFpbnMocm9vdENvbnRhaW5lck5vZGVUeXBlcywgbm9kZS5ub2RlVHlwZSkgJiYgIWdldERvY3VtZW50T3JGcmFnbWVudENvbnRhaW5lcihub2RlLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWRPZmZzZXQobm9kZSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCA8PSAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUobm9kZSkgPyBub2RlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0UmFuZ2VWYWxpZChyYW5nZSkge1xuICAgIGFzc2VydE5vdERldGFjaGVkKHJhbmdlKTtcbiAgICBpZiAoaXNPcnBoYW4ocmFuZ2Uuc3RhcnRDb250YWluZXIpIHx8IGlzT3JwaGFuKHJhbmdlLmVuZENvbnRhaW5lcikgfHwgIWlzVmFsaWRPZmZzZXQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSB8fCAhaXNWYWxpZE9mZnNldChyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbmdlIGVycm9yOiBSYW5nZSBpcyBubyBsb25nZXIgdmFsaWQgYWZ0ZXIgRE9NIG11dGF0aW9uIChcIiArIHJhbmdlLmluc3BlY3QoKSArIFwiKVwiKTtcbiAgICB9XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIFRlc3QgdGhlIGJyb3dzZXIncyBpbm5lckhUTUwgc3VwcG9ydCB0byBkZWNpZGUgaG93IHRvIGltcGxlbWVudCBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnRcbiAgdmFyIHN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIHZhciBodG1sUGFyc2luZ0NvbmZvcm1zID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgc3R5bGVFbC5pbm5lckhUTUwgPSBcIjxiPng8L2I+XCI7XG4gICAgaHRtbFBhcnNpbmdDb25mb3JtcyA9IHN0eWxlRWwuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAzOyAvLyBPcGVyYSBpbmNvcnJlY3RseSBjcmVhdGVzIGFuIGVsZW1lbnQgbm9kZVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSUUgNiBhbmQgNyB0aHJvd1xuICB9XG5cbiAgYXBpLmZlYXR1cmVzLmh0bWxQYXJzaW5nQ29uZm9ybXMgPSBodG1sUGFyc2luZ0NvbmZvcm1zO1xuXG4gIHZhciBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgPSBodG1sUGFyc2luZ0NvbmZvcm1zID9cblxuICAvLyBJbXBsZW1lbnRhdGlvbiBhcyBwZXIgSFRNTCBwYXJzaW5nIHNwZWMsIHRydXN0aW5nIGluIHRoZSBicm93c2VyJ3MgaW1wbGVtZW50YXRpb24gb2YgaW5uZXJIVE1MLiBTZWVcbiAgLy8gZGlzY3Vzc2lvbiBhbmQgYmFzZSBjb2RlIGZvciB0aGlzIGltcGxlbWVudGF0aW9uIGF0IGlzc3VlIDY3LlxuICAvLyBTcGVjOiBodHRwOi8vaHRtbDUub3JnL3NwZWNzL2RvbS1wYXJzaW5nLmh0bWwjZXh0ZW5zaW9ucy10by10aGUtcmFuZ2UtaW50ZXJmYWNlXG4gIC8vIFRoYW5rcyB0byBBbGVrcyBXaWxsaWFtcy5cbiAgZnVuY3Rpb24gKGZyYWdtZW50U3RyKSB7XG4gICAgLy8gXCJMZXQgbm9kZSB0aGUgY29udGV4dCBvYmplY3QncyBzdGFydCdzIG5vZGUuXCJcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnRDb250YWluZXI7XG4gICAgdmFyIGRvYyA9IGRvbS5nZXREb2N1bWVudChub2RlKTtcblxuICAgIC8vIFwiSWYgdGhlIGNvbnRleHQgb2JqZWN0J3Mgc3RhcnQncyBub2RlIGlzIG51bGwsIHJhaXNlIGFuIElOVkFMSURfU1RBVEVfRVJSXG4gICAgLy8gZXhjZXB0aW9uIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cIlxuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOVkFMSURfU1RBVEVfRVJSXCIpO1xuICAgIH1cblxuICAgIC8vIFwiTGV0IGVsZW1lbnQgYmUgYXMgZm9sbG93cywgZGVwZW5kaW5nIG9uIG5vZGUncyBpbnRlcmZhY2U6XCJcbiAgICAvLyBEb2N1bWVudCwgRG9jdW1lbnQgRnJhZ21lbnQ6IG51bGxcbiAgICB2YXIgZWwgPSBudWxsO1xuXG4gICAgLy8gXCJFbGVtZW50OiBub2RlXCJcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICBlbCA9IG5vZGU7XG5cbiAgICAgIC8vIFwiVGV4dCwgQ29tbWVudDogbm9kZSdzIHBhcmVudEVsZW1lbnRcIlxuICAgIH0gZWxzZSBpZiAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUobm9kZSkpIHtcbiAgICAgIGVsID0gZG9tLnBhcmVudEVsZW1lbnQobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gXCJJZiBlaXRoZXIgZWxlbWVudCBpcyBudWxsIG9yIGVsZW1lbnQncyBvd25lckRvY3VtZW50IGlzIGFuIEhUTUwgZG9jdW1lbnRcbiAgICAvLyBhbmQgZWxlbWVudCdzIGxvY2FsIG5hbWUgaXMgXCJodG1sXCIgYW5kIGVsZW1lbnQncyBuYW1lc3BhY2UgaXMgdGhlIEhUTUxcbiAgICAvLyBuYW1lc3BhY2VcIlxuICAgIGlmIChlbCA9PT0gbnVsbCB8fCBlbC5ub2RlTmFtZSA9PSBcIkhUTUxcIiAmJiBkb20uaXNIdG1sTmFtZXNwYWNlKGRvbS5nZXREb2N1bWVudChlbCkuZG9jdW1lbnRFbGVtZW50KSAmJiBkb20uaXNIdG1sTmFtZXNwYWNlKGVsKSkge1xuXG4gICAgICAvLyBcImxldCBlbGVtZW50IGJlIGEgbmV3IEVsZW1lbnQgd2l0aCBcImJvZHlcIiBhcyBpdHMgbG9jYWwgbmFtZSBhbmQgdGhlIEhUTUxcbiAgICAgIC8vIG5hbWVzcGFjZSBhcyBpdHMgbmFtZXNwYWNlLlwiXCJcbiAgICAgIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbCA9IGVsLmNsb25lTm9kZShmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gXCJJZiB0aGUgbm9kZSdzIGRvY3VtZW50IGlzIGFuIEhUTUwgZG9jdW1lbnQ6IEludm9rZSB0aGUgSFRNTCBmcmFnbWVudCBwYXJzaW5nIGFsZ29yaXRobS5cIlxuICAgIC8vIFwiSWYgdGhlIG5vZGUncyBkb2N1bWVudCBpcyBhbiBYTUwgZG9jdW1lbnQ6IEludm9rZSB0aGUgWE1MIGZyYWdtZW50IHBhcnNpbmcgYWxnb3JpdGhtLlwiXG4gICAgLy8gXCJJbiBlaXRoZXIgY2FzZSwgdGhlIGFsZ29yaXRobSBtdXN0IGJlIGludm9rZWQgd2l0aCBmcmFnbWVudCBhcyB0aGUgaW5wdXRcbiAgICAvLyBhbmQgZWxlbWVudCBhcyB0aGUgY29udGV4dCBlbGVtZW50LlwiXG4gICAgZWwuaW5uZXJIVE1MID0gZnJhZ21lbnRTdHI7XG5cbiAgICAvLyBcIklmIHRoaXMgcmFpc2VzIGFuIGV4Y2VwdGlvbiwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy4gT3RoZXJ3aXNlLCBsZXQgbmV3XG4gICAgLy8gY2hpbGRyZW4gYmUgdGhlIG5vZGVzIHJldHVybmVkLlwiXG5cbiAgICAvLyBcIkxldCBmcmFnbWVudCBiZSBhIG5ldyBEb2N1bWVudEZyYWdtZW50LlwiXG4gICAgLy8gXCJBcHBlbmQgYWxsIG5ldyBjaGlsZHJlbiB0byBmcmFnbWVudC5cIlxuICAgIC8vIFwiUmV0dXJuIGZyYWdtZW50LlwiXG4gICAgcmV0dXJuIGRvbS5mcmFnbWVudEZyb21Ob2RlQ2hpbGRyZW4oZWwpO1xuICB9IDpcblxuICAvLyBJbiB0aGlzIGNhc2UsIGlubmVySFRNTCBjYW5ub3QgYmUgdHJ1c3RlZCwgc28gZmFsbCBiYWNrIHRvIGEgc2ltcGxlciwgbm9uLWNvbmZvcm1hbnQgaW1wbGVtZW50YXRpb24gdGhhdFxuICAvLyBwcmV2aW91cyB2ZXJzaW9ucyBvZiBSYW5neSB1c2VkICh3aXRoIHRoZSBleGNlcHRpb24gb2YgdXNpbmcgYSBib2R5IGVsZW1lbnQgcmF0aGVyIHRoYW4gYSBkaXYpXG4gIGZ1bmN0aW9uIChmcmFnbWVudFN0cikge1xuICAgIGFzc2VydE5vdERldGFjaGVkKHRoaXMpO1xuICAgIHZhciBkb2MgPSBnZXRSYW5nZURvY3VtZW50KHRoaXMpO1xuICAgIHZhciBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYm9keVwiKTtcbiAgICBlbC5pbm5lckhUTUwgPSBmcmFnbWVudFN0cjtcblxuICAgIHJldHVybiBkb20uZnJhZ21lbnRGcm9tTm9kZUNoaWxkcmVuKGVsKTtcbiAgfTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIHZhciByYW5nZVByb3BlcnRpZXMgPSBbXCJzdGFydENvbnRhaW5lclwiLCBcInN0YXJ0T2Zmc2V0XCIsIFwiZW5kQ29udGFpbmVyXCIsIFwiZW5kT2Zmc2V0XCIsIFwiY29sbGFwc2VkXCIsIFwiY29tbW9uQW5jZXN0b3JDb250YWluZXJcIl07XG5cbiAgdmFyIHMycyA9IDAsXG4gICAgICBzMmUgPSAxLFxuICAgICAgZTJlID0gMixcbiAgICAgIGUycyA9IDM7XG4gIHZhciBuX2IgPSAwLFxuICAgICAgbl9hID0gMSxcbiAgICAgIG5fYl9hID0gMixcbiAgICAgIG5faSA9IDM7XG5cbiAgZnVuY3Rpb24gUmFuZ2VQcm90b3R5cGUoKSB7fVxuXG4gIFJhbmdlUHJvdG90eXBlLnByb3RvdHlwZSA9IHtcbiAgICBhdHRhY2hMaXN0ZW5lcjogZnVuY3Rpb24gYXR0YWNoTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9LFxuXG4gICAgY29tcGFyZUJvdW5kYXJ5UG9pbnRzOiBmdW5jdGlvbiBjb21wYXJlQm91bmRhcnlQb2ludHMoaG93LCByYW5nZSkge1xuICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgIGFzc2VydFNhbWVEb2N1bWVudE9yRnJhZ21lbnQodGhpcy5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRDb250YWluZXIpO1xuXG4gICAgICB2YXIgbm9kZUEsIG9mZnNldEEsIG5vZGVCLCBvZmZzZXRCO1xuICAgICAgdmFyIHByZWZpeEEgPSBob3cgPT0gZTJzIHx8IGhvdyA9PSBzMnMgPyBcInN0YXJ0XCIgOiBcImVuZFwiO1xuICAgICAgdmFyIHByZWZpeEIgPSBob3cgPT0gczJlIHx8IGhvdyA9PSBzMnMgPyBcInN0YXJ0XCIgOiBcImVuZFwiO1xuICAgICAgbm9kZUEgPSB0aGlzW3ByZWZpeEEgKyBcIkNvbnRhaW5lclwiXTtcbiAgICAgIG9mZnNldEEgPSB0aGlzW3ByZWZpeEEgKyBcIk9mZnNldFwiXTtcbiAgICAgIG5vZGVCID0gcmFuZ2VbcHJlZml4QiArIFwiQ29udGFpbmVyXCJdO1xuICAgICAgb2Zmc2V0QiA9IHJhbmdlW3ByZWZpeEIgKyBcIk9mZnNldFwiXTtcbiAgICAgIHJldHVybiBkb20uY29tcGFyZVBvaW50cyhub2RlQSwgb2Zmc2V0QSwgbm9kZUIsIG9mZnNldEIpO1xuICAgIH0sXG5cbiAgICBpbnNlcnROb2RlOiBmdW5jdGlvbiBpbnNlcnROb2RlKG5vZGUpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICBhc3NlcnRWYWxpZE5vZGVUeXBlKG5vZGUsIGluc2VydGFibGVOb2RlVHlwZXMpO1xuICAgICAgYXNzZXJ0Tm9kZU5vdFJlYWRPbmx5KHRoaXMuc3RhcnRDb250YWluZXIpO1xuXG4gICAgICBpZiAoZG9tLmlzQW5jZXN0b3JPZihub2RlLCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0cnVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBObyBjaGVjayBmb3Igd2hldGhlciB0aGUgY29udGFpbmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgUmFuZ2UgaXMgb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWxsb3dcbiAgICAgIC8vIGNoaWxkcmVuIG9mIHRoZSB0eXBlIG9mIG5vZGU6IHRoZSBicm93c2VyJ3MgRE9NIGltcGxlbWVudGF0aW9uIHNob3VsZCBkbyB0aGlzIGZvciB1cyB3aGVuIHdlIGF0dGVtcHRcbiAgICAgIC8vIHRvIGFkZCB0aGUgbm9kZVxuXG4gICAgICB2YXIgZmlyc3ROb2RlSW5zZXJ0ZWQgPSBpbnNlcnROb2RlQXRQb3NpdGlvbihub2RlLCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0KTtcbiAgICAgIHRoaXMuc2V0U3RhcnRCZWZvcmUoZmlyc3ROb2RlSW5zZXJ0ZWQpO1xuICAgIH0sXG5cbiAgICBjbG9uZUNvbnRlbnRzOiBmdW5jdGlvbiBjbG9uZUNvbnRlbnRzKCkge1xuICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcblxuICAgICAgdmFyIGNsb25lLCBmcmFnO1xuICAgICAgaWYgKHRoaXMuY29sbGFwc2VkKSB7XG4gICAgICAgIHJldHVybiBnZXRSYW5nZURvY3VtZW50KHRoaXMpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0Q29udGFpbmVyID09PSB0aGlzLmVuZENvbnRhaW5lciAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZSh0aGlzLnN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICAgIGNsb25lID0gdGhpcy5zdGFydENvbnRhaW5lci5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgY2xvbmUuZGF0YSA9IGNsb25lLmRhdGEuc2xpY2UodGhpcy5zdGFydE9mZnNldCwgdGhpcy5lbmRPZmZzZXQpO1xuICAgICAgICAgIGZyYWcgPSBnZXRSYW5nZURvY3VtZW50KHRoaXMpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgUmFuZ2VJdGVyYXRvcih0aGlzLCB0cnVlKTtcbiAgICAgICAgICBjbG9uZSA9IGNsb25lU3VidHJlZShpdGVyYXRvcik7XG4gICAgICAgICAgaXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjYW5TdXJyb3VuZENvbnRlbnRzOiBmdW5jdGlvbiBjYW5TdXJyb3VuZENvbnRlbnRzKCkge1xuICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgIGFzc2VydE5vZGVOb3RSZWFkT25seSh0aGlzLnN0YXJ0Q29udGFpbmVyKTtcbiAgICAgIGFzc2VydE5vZGVOb3RSZWFkT25seSh0aGlzLmVuZENvbnRhaW5lcik7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZW50cyBjYW4gYmUgc3Vycm91bmRlZC4gU3BlY2lmaWNhbGx5LCB0aGlzIG1lYW5zIHdoZXRoZXIgdGhlIHJhbmdlIHBhcnRpYWxseSBzZWxlY3RzXG4gICAgICAvLyBubyBub24tdGV4dCBub2Rlcy5cbiAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuICAgICAgdmFyIGJvdW5kYXJpZXNJbnZhbGlkID0gaXRlcmF0b3IuX2ZpcnN0ICYmIGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKGl0ZXJhdG9yLl9maXJzdCwgdGhpcykgfHwgaXRlcmF0b3IuX2xhc3QgJiYgaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQoaXRlcmF0b3IuX2xhc3QsIHRoaXMpO1xuICAgICAgaXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICByZXR1cm4gIWJvdW5kYXJpZXNJbnZhbGlkO1xuICAgIH0sXG5cbiAgICBzdXJyb3VuZENvbnRlbnRzOiBmdW5jdGlvbiBzdXJyb3VuZENvbnRlbnRzKG5vZGUpIHtcbiAgICAgIGFzc2VydFZhbGlkTm9kZVR5cGUobm9kZSwgc3Vycm91bmROb2RlVHlwZXMpO1xuXG4gICAgICBpZiAoIXRoaXMuY2FuU3Vycm91bmRDb250ZW50cygpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUV4Y2VwdGlvbihcIkJBRF9CT1VOREFSWVBPSU5UU19FUlJcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbnRlbnRzXG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuZXh0cmFjdENvbnRlbnRzKCk7XG5cbiAgICAgIC8vIENsZWFyIHRoZSBjaGlsZHJlbiBvZiB0aGUgbm9kZVxuICAgICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEluc2VydCB0aGUgbmV3IG5vZGUgYW5kIGFkZCB0aGUgZXh0cmFjdGVkIGNvbnRlbnRzXG4gICAgICBpbnNlcnROb2RlQXRQb3NpdGlvbihub2RlLCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0KTtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICAgIHRoaXMuc2VsZWN0Tm9kZShub2RlKTtcbiAgICB9LFxuXG4gICAgY2xvbmVSYW5nZTogZnVuY3Rpb24gY2xvbmVSYW5nZSgpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2UoZ2V0UmFuZ2VEb2N1bWVudCh0aGlzKSk7XG4gICAgICB2YXIgaSA9IHJhbmdlUHJvcGVydGllcy5sZW5ndGgsXG4gICAgICAgICAgcHJvcDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgcHJvcCA9IHJhbmdlUHJvcGVydGllc1tpXTtcbiAgICAgICAgcmFuZ2VbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgdmFyIHNjID0gdGhpcy5zdGFydENvbnRhaW5lcjtcbiAgICAgIGlmIChzYyA9PT0gdGhpcy5lbmRDb250YWluZXIgJiYgZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoc2MpKSB7XG4gICAgICAgIHJldHVybiBzYy5ub2RlVHlwZSA9PSAzIHx8IHNjLm5vZGVUeXBlID09IDQgPyBzYy5kYXRhLnNsaWNlKHRoaXMuc3RhcnRPZmZzZXQsIHRoaXMuZW5kT2Zmc2V0KSA6IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGV4dEJpdHMgPSBbXSxcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3IFJhbmdlSXRlcmF0b3IodGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgaXRlcmF0ZVN1YnRyZWUoaXRlcmF0b3IsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgLy8gQWNjZXB0IG9ubHkgdGV4dCBvciBDREFUQSBub2Rlcywgbm90IGNvbW1lbnRzXG5cbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzIHx8IG5vZGUubm9kZVR5cGUgPT0gNCkge1xuICAgICAgICAgICAgdGV4dEJpdHMucHVzaChub2RlLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGl0ZXJhdG9yLmRldGFjaCgpO1xuICAgICAgICByZXR1cm4gdGV4dEJpdHMuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gVGhlIG1ldGhvZHMgYmVsb3cgYXJlIGFsbCBub24tc3RhbmRhcmQuIFRoZSBmb2xsb3dpbmcgYmF0Y2ggd2VyZSBpbnRyb2R1Y2VkIGJ5IE1vemlsbGEgYnV0IGhhdmUgc2luY2VcbiAgICAvLyBiZWVuIHJlbW92ZWQgZnJvbSBNb3ppbGxhLlxuXG4gICAgY29tcGFyZU5vZGU6IGZ1bmN0aW9uIGNvbXBhcmVOb2RlKG5vZGUpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG5cbiAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB2YXIgbm9kZUluZGV4ID0gZG9tLmdldE5vZGVJbmRleChub2RlKTtcblxuICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIk5PVF9GT1VORF9FUlJcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydENvbXBhcmlzb24gPSB0aGlzLmNvbXBhcmVQb2ludChwYXJlbnQsIG5vZGVJbmRleCksXG4gICAgICAgICAgZW5kQ29tcGFyaXNvbiA9IHRoaXMuY29tcGFyZVBvaW50KHBhcmVudCwgbm9kZUluZGV4ICsgMSk7XG5cbiAgICAgIGlmIChzdGFydENvbXBhcmlzb24gPCAwKSB7XG4gICAgICAgIC8vIE5vZGUgc3RhcnRzIGJlZm9yZVxuICAgICAgICByZXR1cm4gZW5kQ29tcGFyaXNvbiA+IDAgPyBuX2JfYSA6IG5fYjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbmRDb21wYXJpc29uID4gMCA/IG5fYSA6IG5faTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29tcGFyZVBvaW50OiBmdW5jdGlvbiBjb21wYXJlUG9pbnQobm9kZSwgb2Zmc2V0KSB7XG4gICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgYXNzZXJ0Tm9kZShub2RlLCBcIkhJRVJBUkNIWV9SRVFVRVNUX0VSUlwiKTtcbiAgICAgIGFzc2VydFNhbWVEb2N1bWVudE9yRnJhZ21lbnQobm9kZSwgdGhpcy5zdGFydENvbnRhaW5lcik7XG5cbiAgICAgIGlmIChkb20uY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpIDwgMCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKGRvbS5jb21wYXJlUG9pbnRzKG5vZGUsIG9mZnNldCwgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0KSA+IDApIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50OiBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQsXG5cbiAgICB0b0h0bWw6IGZ1bmN0aW9uIHRvSHRtbCgpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICB2YXIgY29udGFpbmVyID0gZ2V0UmFuZ2VEb2N1bWVudCh0aGlzKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2xvbmVDb250ZW50cygpKTtcbiAgICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgIH0sXG5cbiAgICAvLyB0b3VjaGluZ0lzSW50ZXJzZWN0aW5nIGRldGVybWluZXMgd2hldGhlciB0aGlzIG1ldGhvZCBjb25zaWRlcnMgYSBub2RlIHRoYXQgYm9yZGVycyBhIHJhbmdlIGludGVyc2VjdHNcbiAgICAvLyB3aXRoIGl0IChhcyBpbiBXZWJLaXQpIG9yIG5vdCAoYXMgaW4gR2Vja28gcHJlLTEuOSwgYW5kIHRoZSBkZWZhdWx0KVxuICAgIGludGVyc2VjdHNOb2RlOiBmdW5jdGlvbiBpbnRlcnNlY3RzTm9kZShub2RlLCB0b3VjaGluZ0lzSW50ZXJzZWN0aW5nKSB7XG4gICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgYXNzZXJ0Tm9kZShub2RlLCBcIk5PVF9GT1VORF9FUlJcIik7XG4gICAgICBpZiAoZG9tLmdldERvY3VtZW50KG5vZGUpICE9PSBnZXRSYW5nZURvY3VtZW50KHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICBvZmZzZXQgPSBkb20uZ2V0Tm9kZUluZGV4KG5vZGUpO1xuICAgICAgYXNzZXJ0Tm9kZShwYXJlbnQsIFwiTk9UX0ZPVU5EX0VSUlwiKTtcblxuICAgICAgdmFyIHN0YXJ0Q29tcGFyaXNvbiA9IGRvbS5jb21wYXJlUG9pbnRzKHBhcmVudCwgb2Zmc2V0LCB0aGlzLmVuZENvbnRhaW5lciwgdGhpcy5lbmRPZmZzZXQpLFxuICAgICAgICAgIGVuZENvbXBhcmlzb24gPSBkb20uY29tcGFyZVBvaW50cyhwYXJlbnQsIG9mZnNldCArIDEsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpO1xuXG4gICAgICByZXR1cm4gdG91Y2hpbmdJc0ludGVyc2VjdGluZyA/IHN0YXJ0Q29tcGFyaXNvbiA8PSAwICYmIGVuZENvbXBhcmlzb24gPj0gMCA6IHN0YXJ0Q29tcGFyaXNvbiA8IDAgJiYgZW5kQ29tcGFyaXNvbiA+IDA7XG4gICAgfSxcblxuICAgIGlzUG9pbnRJblJhbmdlOiBmdW5jdGlvbiBpc1BvaW50SW5SYW5nZShub2RlLCBvZmZzZXQpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICBhc3NlcnROb2RlKG5vZGUsIFwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSXCIpO1xuICAgICAgYXNzZXJ0U2FtZURvY3VtZW50T3JGcmFnbWVudChub2RlLCB0aGlzLnN0YXJ0Q29udGFpbmVyKTtcblxuICAgICAgcmV0dXJuIGRvbS5jb21wYXJlUG9pbnRzKG5vZGUsIG9mZnNldCwgdGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCkgPj0gMCAmJiBkb20uY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCkgPD0gMDtcbiAgICB9LFxuXG4gICAgLy8gVGhlIG1ldGhvZHMgYmVsb3cgYXJlIG5vbi1zdGFuZGFyZCBhbmQgaW52ZW50ZWQgYnkgbWUuXG5cbiAgICAvLyBTaGFyaW5nIGEgYm91bmRhcnkgc3RhcnQtdG8tZW5kIG9yIGVuZC10by1zdGFydCBkb2VzIG5vdCBjb3VudCBhcyBpbnRlcnNlY3Rpb24uXG4gICAgaW50ZXJzZWN0c1JhbmdlOiBmdW5jdGlvbiBpbnRlcnNlY3RzUmFuZ2UocmFuZ2UsIHRvdWNoaW5nSXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG5cbiAgICAgIGlmIChnZXRSYW5nZURvY3VtZW50KHJhbmdlKSAhPSBnZXRSYW5nZURvY3VtZW50KHRoaXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJXUk9OR19ET0NVTUVOVF9FUlJcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydENvbXBhcmlzb24gPSBkb20uY29tcGFyZVBvaW50cyh0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0LCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCksXG4gICAgICAgICAgZW5kQ29tcGFyaXNvbiA9IGRvbS5jb21wYXJlUG9pbnRzKHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCwgcmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICAgICAgcmV0dXJuIHRvdWNoaW5nSXNJbnRlcnNlY3RpbmcgPyBzdGFydENvbXBhcmlzb24gPD0gMCAmJiBlbmRDb21wYXJpc29uID49IDAgOiBzdGFydENvbXBhcmlzb24gPCAwICYmIGVuZENvbXBhcmlzb24gPiAwO1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3Rpb246IGZ1bmN0aW9uIGludGVyc2VjdGlvbihyYW5nZSkge1xuICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c1JhbmdlKHJhbmdlKSkge1xuICAgICAgICB2YXIgc3RhcnRDb21wYXJpc29uID0gZG9tLmNvbXBhcmVQb2ludHModGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCwgcmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSxcbiAgICAgICAgICAgIGVuZENvbXBhcmlzb24gPSBkb20uY29tcGFyZVBvaW50cyh0aGlzLmVuZENvbnRhaW5lciwgdGhpcy5lbmRPZmZzZXQsIHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcblxuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUmFuZ2UgPSB0aGlzLmNsb25lUmFuZ2UoKTtcblxuICAgICAgICBpZiAoc3RhcnRDb21wYXJpc29uID09IC0xKSB7XG4gICAgICAgICAgaW50ZXJzZWN0aW9uUmFuZ2Uuc2V0U3RhcnQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kQ29tcGFyaXNvbiA9PSAxKSB7XG4gICAgICAgICAgaW50ZXJzZWN0aW9uUmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uUmFuZ2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgdW5pb246IGZ1bmN0aW9uIHVuaW9uKHJhbmdlKSB7XG4gICAgICBpZiAodGhpcy5pbnRlcnNlY3RzUmFuZ2UocmFuZ2UsIHRydWUpKSB7XG4gICAgICAgIHZhciB1bmlvblJhbmdlID0gdGhpcy5jbG9uZVJhbmdlKCk7XG4gICAgICAgIGlmIChkb20uY29tcGFyZVBvaW50cyhyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpID09IC0xKSB7XG4gICAgICAgICAgdW5pb25SYW5nZS5zZXRTdGFydChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb20uY29tcGFyZVBvaW50cyhyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCwgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0KSA9PSAxKSB7XG4gICAgICAgICAgdW5pb25SYW5nZS5zZXRFbmQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmlvblJhbmdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXhjZXB0aW9uKFwiUmFuZ2VzIGRvIG5vdCBpbnRlcnNlY3RcIik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbnRhaW5zTm9kZTogZnVuY3Rpb24gY29udGFpbnNOb2RlKG5vZGUsIGFsbG93UGFydGlhbCkge1xuICAgICAgaWYgKGFsbG93UGFydGlhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RzTm9kZShub2RlLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlTm9kZShub2RlKSA9PSBuX2k7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbnRhaW5zTm9kZUNvbnRlbnRzOiBmdW5jdGlvbiBjb250YWluc05vZGVDb250ZW50cyhub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wYXJlUG9pbnQobm9kZSwgMCkgPj0gMCAmJiB0aGlzLmNvbXBhcmVQb2ludChub2RlLCBkb20uZ2V0Tm9kZUxlbmd0aChub2RlKSkgPD0gMDtcbiAgICB9LFxuXG4gICAgY29udGFpbnNSYW5nZTogZnVuY3Rpb24gY29udGFpbnNSYW5nZShyYW5nZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0aW9uKHJhbmdlKS5lcXVhbHMocmFuZ2UpO1xuICAgIH0sXG5cbiAgICBjb250YWluc05vZGVUZXh0OiBmdW5jdGlvbiBjb250YWluc05vZGVUZXh0KG5vZGUpIHtcbiAgICAgIHZhciBub2RlUmFuZ2UgPSB0aGlzLmNsb25lUmFuZ2UoKTtcbiAgICAgIG5vZGVSYW5nZS5zZWxlY3ROb2RlKG5vZGUpO1xuICAgICAgdmFyIHRleHROb2RlcyA9IG5vZGVSYW5nZS5nZXROb2RlcyhbM10pO1xuICAgICAgaWYgKHRleHROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5vZGVSYW5nZS5zZXRTdGFydCh0ZXh0Tm9kZXNbMF0sIDApO1xuICAgICAgICB2YXIgbGFzdFRleHROb2RlID0gdGV4dE5vZGVzLnBvcCgpO1xuICAgICAgICBub2RlUmFuZ2Uuc2V0RW5kKGxhc3RUZXh0Tm9kZSwgbGFzdFRleHROb2RlLmxlbmd0aCk7XG4gICAgICAgIHZhciBjb250YWlucyA9IHRoaXMuY29udGFpbnNSYW5nZShub2RlUmFuZ2UpO1xuICAgICAgICBub2RlUmFuZ2UuZGV0YWNoKCk7XG4gICAgICAgIHJldHVybiBjb250YWlucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5zTm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjcmVhdGVOb2RlSXRlcmF0b3I6IGZ1bmN0aW9uIGNyZWF0ZU5vZGVJdGVyYXRvcihub2RlVHlwZXMsIGZpbHRlcikge1xuICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2VOb2RlSXRlcmF0b3IodGhpcywgbm9kZVR5cGVzLCBmaWx0ZXIpO1xuICAgIH0sXG5cbiAgICBnZXROb2RlczogZnVuY3Rpb24gZ2V0Tm9kZXMobm9kZVR5cGVzLCBmaWx0ZXIpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICByZXR1cm4gZ2V0Tm9kZXNJblJhbmdlKHRoaXMsIG5vZGVUeXBlcywgZmlsdGVyKTtcbiAgICB9LFxuXG4gICAgZ2V0RG9jdW1lbnQ6IGZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgICAgcmV0dXJuIGdldFJhbmdlRG9jdW1lbnQodGhpcyk7XG4gICAgfSxcblxuICAgIGNvbGxhcHNlQmVmb3JlOiBmdW5jdGlvbiBjb2xsYXBzZUJlZm9yZShub2RlKSB7XG4gICAgICBhc3NlcnROb3REZXRhY2hlZCh0aGlzKTtcblxuICAgICAgdGhpcy5zZXRFbmRCZWZvcmUobm9kZSk7XG4gICAgICB0aGlzLmNvbGxhcHNlKGZhbHNlKTtcbiAgICB9LFxuXG4gICAgY29sbGFwc2VBZnRlcjogZnVuY3Rpb24gY29sbGFwc2VBZnRlcihub2RlKSB7XG4gICAgICBhc3NlcnROb3REZXRhY2hlZCh0aGlzKTtcblxuICAgICAgdGhpcy5zZXRTdGFydEFmdGVyKG5vZGUpO1xuICAgICAgdGhpcy5jb2xsYXBzZSh0cnVlKTtcbiAgICB9LFxuXG4gICAgZ2V0TmFtZTogZnVuY3Rpb24gZ2V0TmFtZSgpIHtcbiAgICAgIHJldHVybiBcIkRvbVJhbmdlXCI7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKHJhbmdlKSB7XG4gICAgICByZXR1cm4gUmFuZ2UucmFuZ2VzRXF1YWwodGhpcywgcmFuZ2UpO1xuICAgIH0sXG5cbiAgICBpbnNwZWN0OiBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgcmV0dXJuIF9pbnNwZWN0KHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjb3B5Q29tcGFyaXNvbkNvbnN0YW50c1RvT2JqZWN0KG9iaikge1xuICAgIG9iai5TVEFSVF9UT19TVEFSVCA9IHMycztcbiAgICBvYmouU1RBUlRfVE9fRU5EID0gczJlO1xuICAgIG9iai5FTkRfVE9fRU5EID0gZTJlO1xuICAgIG9iai5FTkRfVE9fU1RBUlQgPSBlMnM7XG5cbiAgICBvYmouTk9ERV9CRUZPUkUgPSBuX2I7XG4gICAgb2JqLk5PREVfQUZURVIgPSBuX2E7XG4gICAgb2JqLk5PREVfQkVGT1JFX0FORF9BRlRFUiA9IG5fYl9hO1xuICAgIG9iai5OT0RFX0lOU0lERSA9IG5faTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlDb21wYXJpc29uQ29uc3RhbnRzKGNvbnN0cnVjdG9yKSB7XG4gICAgY29weUNvbXBhcmlzb25Db25zdGFudHNUb09iamVjdChjb25zdHJ1Y3Rvcik7XG4gICAgY29weUNvbXBhcmlzb25Db25zdGFudHNUb09iamVjdChjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmFuZ2VDb250ZW50UmVtb3ZlcihyZW1vdmVyLCBib3VuZGFyeVVwZGF0ZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcblxuICAgICAgdmFyIHNjID0gdGhpcy5zdGFydENvbnRhaW5lcixcbiAgICAgICAgICBzbyA9IHRoaXMuc3RhcnRPZmZzZXQsXG4gICAgICAgICAgcm9vdCA9IHRoaXMuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuXG4gICAgICAvLyBXb3JrIG91dCB3aGVyZSB0byBwb3NpdGlvbiB0aGUgcmFuZ2UgYWZ0ZXIgY29udGVudCByZW1vdmFsXG4gICAgICB2YXIgbm9kZSwgYm91bmRhcnk7XG4gICAgICBpZiAoc2MgIT09IHJvb3QpIHtcbiAgICAgICAgbm9kZSA9IGRvbS5nZXRDbG9zZXN0QW5jZXN0b3JJbihzYywgcm9vdCwgdHJ1ZSk7XG4gICAgICAgIGJvdW5kYXJ5ID0gZ2V0Qm91bmRhcnlBZnRlck5vZGUobm9kZSk7XG4gICAgICAgIHNjID0gYm91bmRhcnkubm9kZTtcbiAgICAgICAgc28gPSBib3VuZGFyeS5vZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIG5vbmUgb2YgdGhlIHJhbmdlIGlzIHJlYWQtb25seVxuICAgICAgaXRlcmF0ZVN1YnRyZWUoaXRlcmF0b3IsIGFzc2VydE5vZGVOb3RSZWFkT25seSk7XG5cbiAgICAgIGl0ZXJhdG9yLnJlc2V0KCk7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgY29udGVudFxuICAgICAgdmFyIHJldHVyblZhbHVlID0gcmVtb3ZlcihpdGVyYXRvcik7XG4gICAgICBpdGVyYXRvci5kZXRhY2goKTtcblxuICAgICAgLy8gTW92ZSB0byB0aGUgbmV3IHBvc2l0aW9uXG4gICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgc2MsIHNvLCBzYywgc28pO1xuXG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByb3RvdHlwZVJhbmdlKGNvbnN0cnVjdG9yLCBib3VuZGFyeVVwZGF0ZXIsIGRldGFjaGVyKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKGlzQmVmb3JlLCBpc1N0YXJ0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgYXNzZXJ0Tm90RGV0YWNoZWQodGhpcyk7XG4gICAgICAgIGFzc2VydFZhbGlkTm9kZVR5cGUobm9kZSwgYmVmb3JlQWZ0ZXJOb2RlVHlwZXMpO1xuICAgICAgICBhc3NlcnRWYWxpZE5vZGVUeXBlKGdldFJvb3RDb250YWluZXIobm9kZSksIHJvb3RDb250YWluZXJOb2RlVHlwZXMpO1xuXG4gICAgICAgIHZhciBib3VuZGFyeSA9IChpc0JlZm9yZSA/IGdldEJvdW5kYXJ5QmVmb3JlTm9kZSA6IGdldEJvdW5kYXJ5QWZ0ZXJOb2RlKShub2RlKTtcbiAgICAgICAgKGlzU3RhcnQgPyBzZXRSYW5nZVN0YXJ0IDogc2V0UmFuZ2VFbmQpKHRoaXMsIGJvdW5kYXJ5Lm5vZGUsIGJvdW5kYXJ5Lm9mZnNldCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFJhbmdlU3RhcnQocmFuZ2UsIG5vZGUsIG9mZnNldCkge1xuICAgICAgdmFyIGVjID0gcmFuZ2UuZW5kQ29udGFpbmVyLFxuICAgICAgICAgIGVvID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgaWYgKG5vZGUgIT09IHJhbmdlLnN0YXJ0Q29udGFpbmVyIHx8IG9mZnNldCAhPT0gcmFuZ2Uuc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHJvb3QgY29udGFpbmVycyBvZiB0aGUgcmFuZ2UgYW5kIHRoZSBuZXcgYm91bmRhcnksIGFuZCBhbHNvIGNoZWNrIHdoZXRoZXIgdGhlIG5ldyBib3VuZGFyeVxuICAgICAgICAvLyBpcyBhZnRlciB0aGUgY3VycmVudCBlbmQuIEluIGVpdGhlciBjYXNlLCBjb2xsYXBzZSB0aGUgcmFuZ2UgdG8gdGhlIG5ldyBwb3NpdGlvblxuICAgICAgICBpZiAoZ2V0Um9vdENvbnRhaW5lcihub2RlKSAhPSBnZXRSb290Q29udGFpbmVyKGVjKSB8fCBkb20uY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIGVjLCBlbykgPT0gMSkge1xuICAgICAgICAgIGVjID0gbm9kZTtcbiAgICAgICAgICBlbyA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBib3VuZGFyeVVwZGF0ZXIocmFuZ2UsIG5vZGUsIG9mZnNldCwgZWMsIGVvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRSYW5nZUVuZChyYW5nZSwgbm9kZSwgb2Zmc2V0KSB7XG4gICAgICB2YXIgc2MgPSByYW5nZS5zdGFydENvbnRhaW5lcixcbiAgICAgICAgICBzbyA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgaWYgKG5vZGUgIT09IHJhbmdlLmVuZENvbnRhaW5lciB8fCBvZmZzZXQgIT09IHJhbmdlLmVuZE9mZnNldCkge1xuICAgICAgICAvLyBDaGVjayB0aGUgcm9vdCBjb250YWluZXJzIG9mIHRoZSByYW5nZSBhbmQgdGhlIG5ldyBib3VuZGFyeSwgYW5kIGFsc28gY2hlY2sgd2hldGhlciB0aGUgbmV3IGJvdW5kYXJ5XG4gICAgICAgIC8vIGlzIGFmdGVyIHRoZSBjdXJyZW50IGVuZC4gSW4gZWl0aGVyIGNhc2UsIGNvbGxhcHNlIHRoZSByYW5nZSB0byB0aGUgbmV3IHBvc2l0aW9uXG4gICAgICAgIGlmIChnZXRSb290Q29udGFpbmVyKG5vZGUpICE9IGdldFJvb3RDb250YWluZXIoc2MpIHx8IGRvbS5jb21wYXJlUG9pbnRzKG5vZGUsIG9mZnNldCwgc2MsIHNvKSA9PSAtMSkge1xuICAgICAgICAgIHNjID0gbm9kZTtcbiAgICAgICAgICBzbyA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBib3VuZGFyeVVwZGF0ZXIocmFuZ2UsIHNjLCBzbywgbm9kZSwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRSYW5nZVN0YXJ0QW5kRW5kKHJhbmdlLCBub2RlLCBvZmZzZXQpIHtcbiAgICAgIGlmIChub2RlICE9PSByYW5nZS5zdGFydENvbnRhaW5lciB8fCBvZmZzZXQgIT09IHJhbmdlLnN0YXJ0T2Zmc2V0IHx8IG5vZGUgIT09IHJhbmdlLmVuZENvbnRhaW5lciB8fCBvZmZzZXQgIT09IHJhbmdlLmVuZE9mZnNldCkge1xuICAgICAgICBib3VuZGFyeVVwZGF0ZXIocmFuZ2UsIG5vZGUsIG9mZnNldCwgbm9kZSwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmFuZ2VQcm90b3R5cGUoKTtcblxuICAgIGFwaS51dGlsLmV4dGVuZChjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIHNldFN0YXJ0OiBmdW5jdGlvbiBzZXRTdGFydChub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgYXNzZXJ0Tm90RGV0YWNoZWQodGhpcyk7XG4gICAgICAgIGFzc2VydE5vRG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3Iobm9kZSwgdHJ1ZSk7XG4gICAgICAgIGFzc2VydFZhbGlkT2Zmc2V0KG5vZGUsIG9mZnNldCk7XG5cbiAgICAgICAgc2V0UmFuZ2VTdGFydCh0aGlzLCBub2RlLCBvZmZzZXQpO1xuICAgICAgfSxcblxuICAgICAgc2V0RW5kOiBmdW5jdGlvbiBzZXRFbmQobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGFzc2VydE5vdERldGFjaGVkKHRoaXMpO1xuICAgICAgICBhc3NlcnROb0RvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIHRydWUpO1xuICAgICAgICBhc3NlcnRWYWxpZE9mZnNldChub2RlLCBvZmZzZXQpO1xuXG4gICAgICAgIHNldFJhbmdlRW5kKHRoaXMsIG5vZGUsIG9mZnNldCk7XG4gICAgICB9LFxuXG4gICAgICBzZXRTdGFydEJlZm9yZTogY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKHRydWUsIHRydWUpLFxuICAgICAgc2V0U3RhcnRBZnRlcjogY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKGZhbHNlLCB0cnVlKSxcbiAgICAgIHNldEVuZEJlZm9yZTogY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKHRydWUsIGZhbHNlKSxcbiAgICAgIHNldEVuZEFmdGVyOiBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoZmFsc2UsIGZhbHNlKSxcblxuICAgICAgY29sbGFwc2U6IGZ1bmN0aW9uIGNvbGxhcHNlKGlzU3RhcnQpIHtcbiAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgdGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCwgdGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm91bmRhcnlVcGRhdGVyKHRoaXMsIHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCwgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgc2VsZWN0Tm9kZUNvbnRlbnRzOiBmdW5jdGlvbiBzZWxlY3ROb2RlQ29udGVudHMobm9kZSkge1xuICAgICAgICAvLyBUaGlzIGRvZXNuJ3Qgc2VlbSB3ZWxsIHNwZWNpZmllZDogdGhlIHNwZWMgdGFsa3Mgb25seSBhYm91dCBzZWxlY3RpbmcgdGhlIG5vZGUncyBjb250ZW50cywgd2hpY2hcbiAgICAgICAgLy8gY291bGQgYmUgdGFrZW4gdG8gbWVhbiBvbmx5IGl0cyBjaGlsZHJlbi4gSG93ZXZlciwgYnJvd3NlcnMgaW1wbGVtZW50IHRoaXMgdGhlIHNhbWUgYXMgc2VsZWN0Tm9kZSBmb3JcbiAgICAgICAgLy8gdGV4dCBub2Rlcywgc28gSSBzaGFsbCBkbyBsaWtld2lzZVxuICAgICAgICBhc3NlcnROb3REZXRhY2hlZCh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Tm9Eb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3Rvcihub2RlLCB0cnVlKTtcblxuICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgbm9kZSwgMCwgbm9kZSwgZG9tLmdldE5vZGVMZW5ndGgobm9kZSkpO1xuICAgICAgfSxcblxuICAgICAgc2VsZWN0Tm9kZTogZnVuY3Rpb24gc2VsZWN0Tm9kZShub2RlKSB7XG4gICAgICAgIGFzc2VydE5vdERldGFjaGVkKHRoaXMpO1xuICAgICAgICBhc3NlcnROb0RvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgYXNzZXJ0VmFsaWROb2RlVHlwZShub2RlLCBiZWZvcmVBZnRlck5vZGVUeXBlcyk7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gZ2V0Qm91bmRhcnlCZWZvcmVOb2RlKG5vZGUpLFxuICAgICAgICAgICAgZW5kID0gZ2V0Qm91bmRhcnlBZnRlck5vZGUobm9kZSk7XG4gICAgICAgIGJvdW5kYXJ5VXBkYXRlcih0aGlzLCBzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQsIGVuZC5ub2RlLCBlbmQub2Zmc2V0KTtcbiAgICAgIH0sXG5cbiAgICAgIGV4dHJhY3RDb250ZW50czogY3JlYXRlUmFuZ2VDb250ZW50UmVtb3ZlcihleHRyYWN0U3VidHJlZSwgYm91bmRhcnlVcGRhdGVyKSxcblxuICAgICAgZGVsZXRlQ29udGVudHM6IGNyZWF0ZVJhbmdlQ29udGVudFJlbW92ZXIoZGVsZXRlU3VidHJlZSwgYm91bmRhcnlVcGRhdGVyKSxcblxuICAgICAgY2FuU3Vycm91bmRDb250ZW50czogZnVuY3Rpb24gY2FuU3Vycm91bmRDb250ZW50cygpIHtcbiAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Tm9kZU5vdFJlYWRPbmx5KHRoaXMuc3RhcnRDb250YWluZXIpO1xuICAgICAgICBhc3NlcnROb2RlTm90UmVhZE9ubHkodGhpcy5lbmRDb250YWluZXIpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZW50cyBjYW4gYmUgc3Vycm91bmRlZC4gU3BlY2lmaWNhbGx5LCB0aGlzIG1lYW5zIHdoZXRoZXIgdGhlIHJhbmdlIHBhcnRpYWxseSBzZWxlY3RzXG4gICAgICAgIC8vIG5vIG5vbi10ZXh0IG5vZGVzLlxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgUmFuZ2VJdGVyYXRvcih0aGlzLCB0cnVlKTtcbiAgICAgICAgdmFyIGJvdW5kYXJpZXNJbnZhbGlkID0gaXRlcmF0b3IuX2ZpcnN0ICYmIGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKGl0ZXJhdG9yLl9maXJzdCwgdGhpcykgfHwgaXRlcmF0b3IuX2xhc3QgJiYgaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQoaXRlcmF0b3IuX2xhc3QsIHRoaXMpO1xuICAgICAgICBpdGVyYXRvci5kZXRhY2goKTtcbiAgICAgICAgcmV0dXJuICFib3VuZGFyaWVzSW52YWxpZDtcbiAgICAgIH0sXG5cbiAgICAgIGRldGFjaDogZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgICBkZXRhY2hlcih0aGlzKTtcbiAgICAgIH0sXG5cbiAgICAgIHNwbGl0Qm91bmRhcmllczogZnVuY3Rpb24gc3BsaXRCb3VuZGFyaWVzKCkge1xuICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuXG4gICAgICAgIHZhciBzYyA9IHRoaXMuc3RhcnRDb250YWluZXIsXG4gICAgICAgICAgICBzbyA9IHRoaXMuc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICBlYyA9IHRoaXMuZW5kQ29udGFpbmVyLFxuICAgICAgICAgICAgZW8gPSB0aGlzLmVuZE9mZnNldDtcbiAgICAgICAgdmFyIHN0YXJ0RW5kU2FtZSA9IHNjID09PSBlYztcblxuICAgICAgICBpZiAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoZWMpICYmIGVvID4gMCAmJiBlbyA8IGVjLmxlbmd0aCkge1xuICAgICAgICAgIGRvbS5zcGxpdERhdGFOb2RlKGVjLCBlbyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoc2MpICYmIHNvID4gMCAmJiBzbyA8IHNjLmxlbmd0aCkge1xuXG4gICAgICAgICAgc2MgPSBkb20uc3BsaXREYXRhTm9kZShzYywgc28pO1xuICAgICAgICAgIGlmIChzdGFydEVuZFNhbWUpIHtcbiAgICAgICAgICAgIGVvIC09IHNvO1xuICAgICAgICAgICAgZWMgPSBzYztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVjID09IHNjLnBhcmVudE5vZGUgJiYgZW8gPj0gZG9tLmdldE5vZGVJbmRleChzYykpIHtcbiAgICAgICAgICAgIGVvKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvID0gMDtcbiAgICAgICAgfVxuICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgc2MsIHNvLCBlYywgZW8pO1xuICAgICAgfSxcblxuICAgICAgbm9ybWFsaXplQm91bmRhcmllczogZnVuY3Rpb24gbm9ybWFsaXplQm91bmRhcmllcygpIHtcbiAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcblxuICAgICAgICB2YXIgc2MgPSB0aGlzLnN0YXJ0Q29udGFpbmVyLFxuICAgICAgICAgICAgc28gPSB0aGlzLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgZWMgPSB0aGlzLmVuZENvbnRhaW5lcixcbiAgICAgICAgICAgIGVvID0gdGhpcy5lbmRPZmZzZXQ7XG5cbiAgICAgICAgdmFyIG1lcmdlRm9yd2FyZCA9IGZ1bmN0aW9uIG1lcmdlRm9yd2FyZChub2RlKSB7XG4gICAgICAgICAgdmFyIHNpYmxpbmcgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcubm9kZVR5cGUgPT0gbm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgZWMgPSBub2RlO1xuICAgICAgICAgICAgZW8gPSBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kRGF0YShzaWJsaW5nLmRhdGEpO1xuICAgICAgICAgICAgc2libGluZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbWVyZ2VCYWNrd2FyZCA9IGZ1bmN0aW9uIG1lcmdlQmFja3dhcmQobm9kZSkge1xuICAgICAgICAgIHZhciBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgaWYgKHNpYmxpbmcgJiYgc2libGluZy5ub2RlVHlwZSA9PSBub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBzYyA9IG5vZGU7XG4gICAgICAgICAgICB2YXIgbm9kZUxlbmd0aCA9IG5vZGUubGVuZ3RoO1xuICAgICAgICAgICAgc28gPSBzaWJsaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIG5vZGUuaW5zZXJ0RGF0YSgwLCBzaWJsaW5nLmRhdGEpO1xuICAgICAgICAgICAgc2libGluZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNpYmxpbmcpO1xuICAgICAgICAgICAgaWYgKHNjID09IGVjKSB7XG4gICAgICAgICAgICAgIGVvICs9IHNvO1xuICAgICAgICAgICAgICBlYyA9IHNjO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlYyA9PSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IGRvbS5nZXROb2RlSW5kZXgobm9kZSk7XG4gICAgICAgICAgICAgIGlmIChlbyA9PSBub2RlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBlYyA9IG5vZGU7XG4gICAgICAgICAgICAgICAgZW8gPSBub2RlTGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVvID4gbm9kZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgZW8tLTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbm9ybWFsaXplU3RhcnQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShlYykpIHtcbiAgICAgICAgICBpZiAoZWMubGVuZ3RoID09IGVvKSB7XG4gICAgICAgICAgICBtZXJnZUZvcndhcmQoZWMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZW8gPiAwKSB7XG4gICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGVjLmNoaWxkTm9kZXNbZW8gLSAxXTtcbiAgICAgICAgICAgIGlmIChlbmROb2RlICYmIGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKGVuZE5vZGUpKSB7XG4gICAgICAgICAgICAgIG1lcmdlRm9yd2FyZChlbmROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9ybWFsaXplU3RhcnQgPSAhdGhpcy5jb2xsYXBzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9ybWFsaXplU3RhcnQpIHtcbiAgICAgICAgICBpZiAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoc2MpKSB7XG4gICAgICAgICAgICBpZiAoc28gPT0gMCkge1xuICAgICAgICAgICAgICBtZXJnZUJhY2t3YXJkKHNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNvIDwgc2MuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IHNjLmNoaWxkTm9kZXNbc29dO1xuICAgICAgICAgICAgICBpZiAoc3RhcnROb2RlICYmIGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZUJhY2t3YXJkKHN0YXJ0Tm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2MgPSBlYztcbiAgICAgICAgICBzbyA9IGVvO1xuICAgICAgICB9XG5cbiAgICAgICAgYm91bmRhcnlVcGRhdGVyKHRoaXMsIHNjLCBzbywgZWMsIGVvKTtcbiAgICAgIH0sXG5cbiAgICAgIGNvbGxhcHNlVG9Qb2ludDogZnVuY3Rpb24gY29sbGFwc2VUb1BvaW50KG5vZGUsIG9mZnNldCkge1xuICAgICAgICBhc3NlcnROb3REZXRhY2hlZCh0aGlzKTtcblxuICAgICAgICBhc3NlcnROb0RvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIHRydWUpO1xuICAgICAgICBhc3NlcnRWYWxpZE9mZnNldChub2RlLCBvZmZzZXQpO1xuXG4gICAgICAgIHNldFJhbmdlU3RhcnRBbmRFbmQodGhpcywgbm9kZSwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvcHlDb21wYXJpc29uQ29uc3RhbnRzKGNvbnN0cnVjdG9yKTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gVXBkYXRlcyBjb21tb25BbmNlc3RvckNvbnRhaW5lciBhbmQgY29sbGFwc2VkIGFmdGVyIGJvdW5kYXJ5IGNoYW5nZVxuICBmdW5jdGlvbiB1cGRhdGVDb2xsYXBzZWRBbmRDb21tb25BbmNlc3RvcihyYW5nZSkge1xuICAgIHJhbmdlLmNvbGxhcHNlZCA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyID09PSByYW5nZS5lbmRDb250YWluZXIgJiYgcmFuZ2Uuc3RhcnRPZmZzZXQgPT09IHJhbmdlLmVuZE9mZnNldDtcbiAgICByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbGxhcHNlZCA/IHJhbmdlLnN0YXJ0Q29udGFpbmVyIDogZG9tLmdldENvbW1vbkFuY2VzdG9yKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5lbmRDb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQm91bmRhcmllcyhyYW5nZSwgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCkge1xuICAgIHZhciBzdGFydE1vdmVkID0gcmFuZ2Uuc3RhcnRDb250YWluZXIgIT09IHN0YXJ0Q29udGFpbmVyIHx8IHJhbmdlLnN0YXJ0T2Zmc2V0ICE9PSBzdGFydE9mZnNldDtcbiAgICB2YXIgZW5kTW92ZWQgPSByYW5nZS5lbmRDb250YWluZXIgIT09IGVuZENvbnRhaW5lciB8fCByYW5nZS5lbmRPZmZzZXQgIT09IGVuZE9mZnNldDtcblxuICAgIHJhbmdlLnN0YXJ0Q29udGFpbmVyID0gc3RhcnRDb250YWluZXI7XG4gICAgcmFuZ2Uuc3RhcnRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICByYW5nZS5lbmRDb250YWluZXIgPSBlbmRDb250YWluZXI7XG4gICAgcmFuZ2UuZW5kT2Zmc2V0ID0gZW5kT2Zmc2V0O1xuXG4gICAgdXBkYXRlQ29sbGFwc2VkQW5kQ29tbW9uQW5jZXN0b3IocmFuZ2UpO1xuICAgIGRpc3BhdGNoRXZlbnQocmFuZ2UsIFwiYm91bmRhcnljaGFuZ2VcIiwgeyBzdGFydE1vdmVkOiBzdGFydE1vdmVkLCBlbmRNb3ZlZDogZW5kTW92ZWQgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2gocmFuZ2UpIHtcbiAgICBhc3NlcnROb3REZXRhY2hlZChyYW5nZSk7XG4gICAgcmFuZ2Uuc3RhcnRDb250YWluZXIgPSByYW5nZS5zdGFydE9mZnNldCA9IHJhbmdlLmVuZENvbnRhaW5lciA9IHJhbmdlLmVuZE9mZnNldCA9IG51bGw7XG4gICAgcmFuZ2UuY29sbGFwc2VkID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSBudWxsO1xuICAgIGRpc3BhdGNoRXZlbnQocmFuZ2UsIFwiZGV0YWNoXCIsIG51bGwpO1xuICAgIHJhbmdlLl9saXN0ZW5lcnMgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gUmFuZ2UoZG9jKSB7XG4gICAgdGhpcy5zdGFydENvbnRhaW5lciA9IGRvYztcbiAgICB0aGlzLnN0YXJ0T2Zmc2V0ID0gMDtcbiAgICB0aGlzLmVuZENvbnRhaW5lciA9IGRvYztcbiAgICB0aGlzLmVuZE9mZnNldCA9IDA7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge1xuICAgICAgYm91bmRhcnljaGFuZ2U6IFtdLFxuICAgICAgZGV0YWNoOiBbXVxuICAgIH07XG4gICAgdXBkYXRlQ29sbGFwc2VkQW5kQ29tbW9uQW5jZXN0b3IodGhpcyk7XG4gIH1cblxuICBjcmVhdGVQcm90b3R5cGVSYW5nZShSYW5nZSwgdXBkYXRlQm91bmRhcmllcywgZGV0YWNoKTtcblxuICBhcGkucmFuZ2VQcm90b3R5cGUgPSBSYW5nZVByb3RvdHlwZS5wcm90b3R5cGU7XG5cbiAgUmFuZ2UucmFuZ2VQcm9wZXJ0aWVzID0gcmFuZ2VQcm9wZXJ0aWVzO1xuICBSYW5nZS5SYW5nZUl0ZXJhdG9yID0gUmFuZ2VJdGVyYXRvcjtcbiAgUmFuZ2UuY29weUNvbXBhcmlzb25Db25zdGFudHMgPSBjb3B5Q29tcGFyaXNvbkNvbnN0YW50cztcbiAgUmFuZ2UuY3JlYXRlUHJvdG90eXBlUmFuZ2UgPSBjcmVhdGVQcm90b3R5cGVSYW5nZTtcbiAgUmFuZ2UuaW5zcGVjdCA9IF9pbnNwZWN0O1xuICBSYW5nZS5nZXRSYW5nZURvY3VtZW50ID0gZ2V0UmFuZ2VEb2N1bWVudDtcbiAgUmFuZ2UucmFuZ2VzRXF1YWwgPSBmdW5jdGlvbiAocjEsIHIyKSB7XG4gICAgcmV0dXJuIHIxLnN0YXJ0Q29udGFpbmVyID09PSByMi5zdGFydENvbnRhaW5lciAmJiByMS5zdGFydE9mZnNldCA9PT0gcjIuc3RhcnRPZmZzZXQgJiYgcjEuZW5kQ29udGFpbmVyID09PSByMi5lbmRDb250YWluZXIgJiYgcjEuZW5kT2Zmc2V0ID09PSByMi5lbmRPZmZzZXQ7XG4gIH07XG5cbiAgYXBpLkRvbVJhbmdlID0gUmFuZ2U7XG4gIGFwaS5SYW5nZUV4Y2VwdGlvbiA9IFJhbmdlRXhjZXB0aW9uO1xufSk7cmFuZ3kuY3JlYXRlTW9kdWxlKFwiV3JhcHBlZFJhbmdlXCIsIGZ1bmN0aW9uIChhcGksIG1vZHVsZSkge1xuICBhcGkucmVxdWlyZU1vZHVsZXMoW1wiRG9tVXRpbFwiLCBcIkRvbVJhbmdlXCJdKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB2YXIgV3JhcHBlZFJhbmdlO1xuICB2YXIgZG9tID0gYXBpLmRvbTtcbiAgdmFyIERvbVBvc2l0aW9uID0gZG9tLkRvbVBvc2l0aW9uO1xuICB2YXIgRG9tUmFuZ2UgPSBhcGkuRG9tUmFuZ2U7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKlxuICBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgYSBidWcgd2hlcmUgSUUgcmV0dXJucyB0aGUgd3JvbmcgY29udGFpbmVyIGVsZW1lbnQgZnJvbSB0aGUgVGV4dFJhbmdlJ3MgcGFyZW50RWxlbWVudCgpXG4gIG1ldGhvZC4gRm9yIGV4YW1wbGUsIGluIHRoZSBmb2xsb3dpbmcgKHdoZXJlIHBpcGVzIGRlbm90ZSB0aGUgc2VsZWN0aW9uIGJvdW5kYXJpZXMpOlxuICAgPHVsIGlkPVwidWxcIj48bGkgaWQ9XCJhXCI+fCBhIDwvbGk+PGxpIGlkPVwiYlwiPiBiIHw8L2xpPjwvdWw+XG4gICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgYWxlcnQocmFuZ2UucGFyZW50RWxlbWVudCgpLmlkKTsgLy8gU2hvdWxkIGFsZXJ0IFwidWxcIiBidXQgYWxlcnRzIFwiYlwiXG4gICBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjb21tb24gYW5jZXN0b3Igbm9kZSBvZiB0aGUgZm9sbG93aW5nOlxuICAtIHRoZSBwYXJlbnRFbGVtZW50KCkgb2YgdGhlIHRleHRSYW5nZVxuICAtIHRoZSBwYXJlbnRFbGVtZW50KCkgb2YgdGhlIHRleHRSYW5nZSBhZnRlciBjYWxsaW5nIGNvbGxhcHNlKHRydWUpXG4gIC0gdGhlIHBhcmVudEVsZW1lbnQoKSBvZiB0aGUgdGV4dFJhbmdlIGFmdGVyIGNhbGxpbmcgY29sbGFwc2UoZmFsc2UpXG4gICAqL1xuICBmdW5jdGlvbiBnZXRUZXh0UmFuZ2VDb250YWluZXJFbGVtZW50KHRleHRSYW5nZSkge1xuICAgIHZhciBwYXJlbnRFbCA9IHRleHRSYW5nZS5wYXJlbnRFbGVtZW50KCk7XG5cbiAgICB2YXIgcmFuZ2UgPSB0ZXh0UmFuZ2UuZHVwbGljYXRlKCk7XG4gICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgdmFyIHN0YXJ0RWwgPSByYW5nZS5wYXJlbnRFbGVtZW50KCk7XG4gICAgcmFuZ2UgPSB0ZXh0UmFuZ2UuZHVwbGljYXRlKCk7XG4gICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgIHZhciBlbmRFbCA9IHJhbmdlLnBhcmVudEVsZW1lbnQoKTtcbiAgICB2YXIgc3RhcnRFbmRDb250YWluZXIgPSBzdGFydEVsID09IGVuZEVsID8gc3RhcnRFbCA6IGRvbS5nZXRDb21tb25BbmNlc3RvcihzdGFydEVsLCBlbmRFbCk7XG5cbiAgICByZXR1cm4gc3RhcnRFbmRDb250YWluZXIgPT0gcGFyZW50RWwgPyBzdGFydEVuZENvbnRhaW5lciA6IGRvbS5nZXRDb21tb25BbmNlc3RvcihwYXJlbnRFbCwgc3RhcnRFbmRDb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dFJhbmdlSXNDb2xsYXBzZWQodGV4dFJhbmdlKSB7XG4gICAgcmV0dXJuIHRleHRSYW5nZS5jb21wYXJlRW5kUG9pbnRzKFwiU3RhcnRUb0VuZFwiLCB0ZXh0UmFuZ2UpID09IDA7XG4gIH1cblxuICAvLyBHZXRzIHRoZSBib3VuZGFyeSBvZiBhIFRleHRSYW5nZSBleHByZXNzZWQgYXMgYSBub2RlIGFuZCBhbiBvZmZzZXQgd2l0aGluIHRoYXQgbm9kZS4gVGhpcyBmdW5jdGlvbiBzdGFydGVkIG91dCBhc1xuICAvLyBhbiBpbXByb3ZlZCB2ZXJzaW9uIG9mIGNvZGUgZm91bmQgaW4gVGltIENhbWVyb24gUnlhbidzIElFUmFuZ2UgKGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9pZXJhbmdlLykgYnV0IGhhc1xuICAvLyBncm93biwgZml4aW5nIHByb2JsZW1zIHdpdGggbGluZSBicmVha3MgaW4gcHJlZm9ybWF0dGVkIHRleHQsIGFkZGluZyB3b3JrYXJvdW5kIGZvciBJRSBUZXh0UmFuZ2UgYnVncywgaGFuZGxpbmdcbiAgLy8gZm9yIGlucHV0cyBhbmQgaW1hZ2VzLCBwbHVzIG9wdGltaXphdGlvbnMuXG4gIGZ1bmN0aW9uIGdldFRleHRSYW5nZUJvdW5kYXJ5UG9zaXRpb24odGV4dFJhbmdlLCB3aG9sZVJhbmdlQ29udGFpbmVyRWxlbWVudCwgaXNTdGFydCwgaXNDb2xsYXBzZWQpIHtcbiAgICB2YXIgd29ya2luZ1JhbmdlID0gdGV4dFJhbmdlLmR1cGxpY2F0ZSgpO1xuXG4gICAgd29ya2luZ1JhbmdlLmNvbGxhcHNlKGlzU3RhcnQpO1xuICAgIHZhciBjb250YWluZXJFbGVtZW50ID0gd29ya2luZ1JhbmdlLnBhcmVudEVsZW1lbnQoKTtcblxuICAgIC8vIFNvbWV0aW1lcyBjb2xsYXBzaW5nIGEgVGV4dFJhbmdlIHRoYXQncyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0IG5vZGUgY2FuIG1vdmUgaXQgaW50byB0aGUgcHJldmlvdXMgbm9kZSwgc29cbiAgICAvLyBjaGVjayBmb3IgdGhhdFxuICAgIC8vIFRPRE86IEZpbmQgb3V0IHdoZW4uIFdvcmthcm91bmQgZm9yIHdob2xlUmFuZ2VDb250YWluZXJFbGVtZW50IG1heSBicmVhayB0aGlzXG4gICAgaWYgKCFkb20uaXNBbmNlc3Rvck9mKHdob2xlUmFuZ2VDb250YWluZXJFbGVtZW50LCBjb250YWluZXJFbGVtZW50LCB0cnVlKSkge1xuICAgICAgY29udGFpbmVyRWxlbWVudCA9IHdob2xlUmFuZ2VDb250YWluZXJFbGVtZW50O1xuICAgIH1cblxuICAgIC8vIERlYWwgd2l0aCBub2RlcyB0aGF0IGNhbm5vdCBcImNvbnRhaW4gcmljaCBIVE1MIG1hcmt1cFwiLiBJbiBwcmFjdGljZSwgdGhpcyBtZWFucyBmb3JtIGlucHV0cywgaW1hZ2VzIGFuZFxuICAgIC8vIHNpbWlsYXIuIFNlZSBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvYWE3MDM5NTAlMjhWUy44NSUyOS5hc3B4XG4gICAgaWYgKCFjb250YWluZXJFbGVtZW50LmNhbkhhdmVIVE1MKSB7XG4gICAgICByZXR1cm4gbmV3IERvbVBvc2l0aW9uKGNvbnRhaW5lckVsZW1lbnQucGFyZW50Tm9kZSwgZG9tLmdldE5vZGVJbmRleChjb250YWluZXJFbGVtZW50KSk7XG4gICAgfVxuXG4gICAgdmFyIHdvcmtpbmdOb2RlID0gZG9tLmdldERvY3VtZW50KGNvbnRhaW5lckVsZW1lbnQpLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHZhciBjb21wYXJpc29uLFxuICAgICAgICB3b3JraW5nQ29tcGFyaXNvblR5cGUgPSBpc1N0YXJ0ID8gXCJTdGFydFRvU3RhcnRcIiA6IFwiU3RhcnRUb0VuZFwiO1xuICAgIHZhciBwcmV2aW91c05vZGUsIG5leHROb2RlLCBib3VuZGFyeVBvc2l0aW9uLCBib3VuZGFyeU5vZGU7XG5cbiAgICAvLyBNb3ZlIHRoZSB3b3JraW5nIHJhbmdlIHRocm91Z2ggdGhlIGNvbnRhaW5lcidzIGNoaWxkcmVuLCBzdGFydGluZyBhdCB0aGUgZW5kIGFuZCB3b3JraW5nIGJhY2t3YXJkcywgdW50aWwgdGhlXG4gICAgLy8gd29ya2luZyByYW5nZSByZWFjaGVzIG9yIGdvZXMgcGFzdCB0aGUgYm91bmRhcnkgd2UncmUgaW50ZXJlc3RlZCBpblxuICAgIGRvIHtcbiAgICAgIGNvbnRhaW5lckVsZW1lbnQuaW5zZXJ0QmVmb3JlKHdvcmtpbmdOb2RlLCB3b3JraW5nTm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgd29ya2luZ1JhbmdlLm1vdmVUb0VsZW1lbnRUZXh0KHdvcmtpbmdOb2RlKTtcbiAgICB9IHdoaWxlICgoY29tcGFyaXNvbiA9IHdvcmtpbmdSYW5nZS5jb21wYXJlRW5kUG9pbnRzKHdvcmtpbmdDb21wYXJpc29uVHlwZSwgdGV4dFJhbmdlKSkgPiAwICYmIHdvcmtpbmdOb2RlLnByZXZpb3VzU2libGluZyk7XG5cbiAgICAvLyBXZSd2ZSBub3cgcmVhY2hlZCBvciBnb25lIHBhc3QgdGhlIGJvdW5kYXJ5IG9mIHRoZSB0ZXh0IHJhbmdlIHdlJ3JlIGludGVyZXN0ZWQgaW5cbiAgICAvLyBzbyBoYXZlIGlkZW50aWZpZWQgdGhlIG5vZGUgd2Ugd2FudFxuICAgIGJvdW5kYXJ5Tm9kZSA9IHdvcmtpbmdOb2RlLm5leHRTaWJsaW5nO1xuXG4gICAgaWYgKGNvbXBhcmlzb24gPT0gLTEgJiYgYm91bmRhcnlOb2RlICYmIGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKGJvdW5kYXJ5Tm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBjaGFyYWN0ZXIgZGF0YSBub2RlICh0ZXh0LCBjb21tZW50LCBjZGF0YSkuIFRoZSB3b3JraW5nIHJhbmdlIGlzIGNvbGxhcHNlZCBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICAvLyBub2RlIGNvbnRhaW5pbmcgdGhlIHRleHQgcmFuZ2UncyBib3VuZGFyeSwgc28gd2UgbW92ZSB0aGUgZW5kIG9mIHRoZSB3b3JraW5nIHJhbmdlIHRvIHRoZSBib3VuZGFyeSBwb2ludFxuICAgICAgLy8gYW5kIG1lYXN1cmUgdGhlIGxlbmd0aCBvZiBpdHMgdGV4dCB0byBnZXQgdGhlIGJvdW5kYXJ5J3Mgb2Zmc2V0IHdpdGhpbiB0aGUgbm9kZS5cbiAgICAgIHdvcmtpbmdSYW5nZS5zZXRFbmRQb2ludChpc1N0YXJ0ID8gXCJFbmRUb1N0YXJ0XCIgOiBcIkVuZFRvRW5kXCIsIHRleHRSYW5nZSk7XG5cbiAgICAgIHZhciBvZmZzZXQ7XG5cbiAgICAgIGlmICgvW1xcclxcbl0vLnRlc3QoYm91bmRhcnlOb2RlLmRhdGEpKSB7XG4gICAgICAgIC8qXG4gICAgICAgIEZvciB0aGUgcGFydGljdWxhciBjYXNlIG9mIGEgYm91bmRhcnkgd2l0aGluIGEgdGV4dCBub2RlIGNvbnRhaW5pbmcgbGluZSBicmVha3MgKHdpdGhpbiBhIDxwcmU+IGVsZW1lbnQsXG4gICAgICAgIGZvciBleGFtcGxlKSwgd2UgbmVlZCBhIHNsaWdodGx5IGNvbXBsaWNhdGVkIGFwcHJvYWNoIHRvIGdldCB0aGUgYm91bmRhcnkncyBvZmZzZXQgaW4gSUUuIFRoZSBmYWN0czpcbiAgICAgICAgIC0gRWFjaCBsaW5lIGJyZWFrIGlzIHJlcHJlc2VudGVkIGFzIFxcciBpbiB0aGUgdGV4dCBub2RlJ3MgZGF0YS9ub2RlVmFsdWUgcHJvcGVydGllc1xuICAgICAgICAtIEVhY2ggbGluZSBicmVhayBpcyByZXByZXNlbnRlZCBhcyBcXHJcXG4gaW4gdGhlIFRleHRSYW5nZSdzICd0ZXh0JyBwcm9wZXJ0eVxuICAgICAgICAtIFRoZSAndGV4dCcgcHJvcGVydHkgb2YgdGhlIFRleHRSYW5nZSBkb2VzIG5vdCBjb250YWluIHRyYWlsaW5nIGxpbmUgYnJlYWtzXG4gICAgICAgICBUbyBnZXQgcm91bmQgdGhlIHByb2JsZW0gcHJlc2VudGVkIGJ5IHRoZSBmaW5hbCBmYWN0IGFib3ZlLCB3ZSBjYW4gdXNlIHRoZSBmYWN0IHRoYXQgVGV4dFJhbmdlJ3NcbiAgICAgICAgbW92ZVN0YXJ0KCkgYW5kIG1vdmVFbmQoKSBtZXRob2RzIHJldHVybiB0aGUgYWN0dWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIG1vdmVkLCB3aGljaCBpcyBub3QgbmVjZXNzYXJpbHlcbiAgICAgICAgdGhlIHNhbWUgYXMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGl0IHdhcyBpbnN0cnVjdGVkIHRvIG1vdmUuIFRoZSBzaW1wbGVzdCBhcHByb2FjaCBpcyB0byB1c2UgdGhpcyB0b1xuICAgICAgICBzdG9yZSB0aGUgY2hhcmFjdGVycyBtb3ZlZCB3aGVuIG1vdmluZyBib3RoIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSByYW5nZSB0byB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIGJvZHkgYW5kIHN1YnRyYWN0aW5nIHRoZSBzdGFydCBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mZnNldCAodGhlIFwibW92ZS1uZWdhdGl2ZS1nYXppbGxpb25cIiBtZXRob2QpLlxuICAgICAgICBIb3dldmVyLCB0aGlzIGlzIGV4dHJlbWVseSBzbG93IHdoZW4gdGhlIGRvY3VtZW50IGlzIGxhcmdlIGFuZCB0aGUgcmFuZ2UgaXMgbmVhciB0aGUgZW5kIG9mIGl0LiBDbGVhcmx5XG4gICAgICAgIGRvaW5nIHRoZSBtaXJyb3IgaW1hZ2UgKGkuZS4gbW92aW5nIHRoZSByYW5nZSBib3VuZGFyaWVzIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50KSBoYXMgdGhlIHNhbWVcbiAgICAgICAgcHJvYmxlbS5cbiAgICAgICAgIEFub3RoZXIgYXBwcm9hY2ggdGhhdCB3b3JrcyBpcyB0byB1c2UgbW92ZVN0YXJ0KCkgdG8gbW92ZSB0aGUgc3RhcnQgYm91bmRhcnkgb2YgdGhlIHJhbmdlIHVwIHRvIHRoZSBlbmRcbiAgICAgICAgYm91bmRhcnkgb25lIGNoYXJhY3RlciBhdCBhIHRpbWUgYW5kIGluY3JlbWVudGluZyBhIGNvdW50ZXIgd2l0aCB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIG1vdmVTdGFydCgpXG4gICAgICAgIGNhbGwuIEhvd2V2ZXIsIHRoZSBjaGVjayBmb3Igd2hldGhlciB0aGUgc3RhcnQgYm91bmRhcnkgaGFzIHJlYWNoZWQgdGhlIGVuZCBib3VuZGFyeSBpcyBleHBlbnNpdmUsIHNvXG4gICAgICAgIHRoaXMgbWV0aG9kIGlzIHNsb3cgKGFsdGhvdWdoIHVubGlrZSBcIm1vdmUtbmVnYXRpdmUtZ2F6aWxsaW9uXCIgaXMgbGFyZ2VseSB1bmFmZmVjdGVkIGJ5IHRoZSBsb2NhdGlvbiBvZlxuICAgICAgICB0aGUgcmFuZ2Ugd2l0aGluIHRoZSBkb2N1bWVudCkuXG4gICAgICAgICBUaGUgbWV0aG9kIGJlbG93IGlzIGEgaHlicmlkIG9mIHRoZSB0d28gbWV0aG9kcyBhYm92ZS4gSXQgdXNlcyB0aGUgZmFjdCB0aGF0IGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlXG4gICAgICAgIFRleHRSYW5nZSdzICd0ZXh0JyBwcm9wZXJ0eSB3aXRoIGVhY2ggXFxyXFxuIGNvbnZlcnRlZCB0byBhIHNpbmdsZSBcXHIgY2hhcmFjdGVyIGNhbm5vdCBiZSBsb25nZXIgdGhhbiB0aGVcbiAgICAgICAgdGV4dCBvZiB0aGUgVGV4dFJhbmdlLCBzbyB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlIGlzIG1vdmVkIHRoYXQgbGVuZ3RoIGluaXRpYWxseSBhbmQgdGhlbiBhIGNoYXJhY3RlciBhdFxuICAgICAgICBhIHRpbWUgdG8gbWFrZSB1cCBmb3IgYW55IHRyYWlsaW5nIGxpbmUgYnJlYWtzIG5vdCBjb250YWluZWQgaW4gdGhlICd0ZXh0JyBwcm9wZXJ0eS4gVGhpcyBoYXMgZ29vZFxuICAgICAgICBwZXJmb3JtYW5jZSBpbiBtb3N0IHNpdHVhdGlvbnMgY29tcGFyZWQgdG8gdGhlIHByZXZpb3VzIHR3byBtZXRob2RzLlxuICAgICAgICAqL1xuICAgICAgICB2YXIgdGVtcFJhbmdlID0gd29ya2luZ1JhbmdlLmR1cGxpY2F0ZSgpO1xuICAgICAgICB2YXIgcmFuZ2VMZW5ndGggPSB0ZW1wUmFuZ2UudGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgXCJcXHJcIikubGVuZ3RoO1xuXG4gICAgICAgIG9mZnNldCA9IHRlbXBSYW5nZS5tb3ZlU3RhcnQoXCJjaGFyYWN0ZXJcIiwgcmFuZ2VMZW5ndGgpO1xuICAgICAgICB3aGlsZSAoKGNvbXBhcmlzb24gPSB0ZW1wUmFuZ2UuY29tcGFyZUVuZFBvaW50cyhcIlN0YXJ0VG9FbmRcIiwgdGVtcFJhbmdlKSkgPT0gLTEpIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICB0ZW1wUmFuZ2UubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSB3b3JraW5nUmFuZ2UudGV4dC5sZW5ndGg7XG4gICAgICB9XG4gICAgICBib3VuZGFyeVBvc2l0aW9uID0gbmV3IERvbVBvc2l0aW9uKGJvdW5kYXJ5Tm9kZSwgb2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBJZiB0aGUgYm91bmRhcnkgaW1tZWRpYXRlbHkgZm9sbG93cyBhIGNoYXJhY3RlciBkYXRhIG5vZGUgYW5kIHRoaXMgaXMgdGhlIGVuZCBib3VuZGFyeSwgd2Ugc2hvdWxkIGZhdm91clxuICAgICAgLy8gYSBwb3NpdGlvbiB3aXRoaW4gdGhhdCwgYW5kIGxpa2V3aXNlIGZvciBhIHN0YXJ0IGJvdW5kYXJ5IHByZWNlZGluZyBhIGNoYXJhY3RlciBkYXRhIG5vZGVcbiAgICAgIHByZXZpb3VzTm9kZSA9IChpc0NvbGxhcHNlZCB8fCAhaXNTdGFydCkgJiYgd29ya2luZ05vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgbmV4dE5vZGUgPSAoaXNDb2xsYXBzZWQgfHwgaXNTdGFydCkgJiYgd29ya2luZ05vZGUubmV4dFNpYmxpbmc7XG5cbiAgICAgIGlmIChuZXh0Tm9kZSAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShuZXh0Tm9kZSkpIHtcbiAgICAgICAgYm91bmRhcnlQb3NpdGlvbiA9IG5ldyBEb21Qb3NpdGlvbihuZXh0Tm9kZSwgMCk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzTm9kZSAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShwcmV2aW91c05vZGUpKSB7XG4gICAgICAgIGJvdW5kYXJ5UG9zaXRpb24gPSBuZXcgRG9tUG9zaXRpb24ocHJldmlvdXNOb2RlLCBwcmV2aW91c05vZGUubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kYXJ5UG9zaXRpb24gPSBuZXcgRG9tUG9zaXRpb24oY29udGFpbmVyRWxlbWVudCwgZG9tLmdldE5vZGVJbmRleCh3b3JraW5nTm9kZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFuIHVwXG4gICAgd29ya2luZ05vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3b3JraW5nTm9kZSk7XG5cbiAgICByZXR1cm4gYm91bmRhcnlQb3NpdGlvbjtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBUZXh0UmFuZ2UgcmVwcmVzZW50aW5nIHRoZSBib3VuZGFyeSBvZiBhIFRleHRSYW5nZSBleHByZXNzZWQgYXMgYSBub2RlIGFuZCBhbiBvZmZzZXQgd2l0aGluIHRoYXQgbm9kZS5cbiAgLy8gVGhpcyBmdW5jdGlvbiBzdGFydGVkIG91dCBhcyBhbiBvcHRpbWl6ZWQgdmVyc2lvbiBvZiBjb2RlIGZvdW5kIGluIFRpbSBDYW1lcm9uIFJ5YW4ncyBJRVJhbmdlXG4gIC8vIChodHRwOi8vY29kZS5nb29nbGUuY29tL3AvaWVyYW5nZS8pXG4gIGZ1bmN0aW9uIGNyZWF0ZUJvdW5kYXJ5VGV4dFJhbmdlKGJvdW5kYXJ5UG9zaXRpb24sIGlzU3RhcnQpIHtcbiAgICB2YXIgYm91bmRhcnlOb2RlLFxuICAgICAgICBib3VuZGFyeVBhcmVudCxcbiAgICAgICAgYm91bmRhcnlPZmZzZXQgPSBib3VuZGFyeVBvc2l0aW9uLm9mZnNldDtcbiAgICB2YXIgZG9jID0gZG9tLmdldERvY3VtZW50KGJvdW5kYXJ5UG9zaXRpb24ubm9kZSk7XG4gICAgdmFyIHdvcmtpbmdOb2RlLFxuICAgICAgICBjaGlsZE5vZGVzLFxuICAgICAgICB3b3JraW5nUmFuZ2UgPSBkb2MuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICB2YXIgbm9kZUlzRGF0YU5vZGUgPSBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShib3VuZGFyeVBvc2l0aW9uLm5vZGUpO1xuXG4gICAgaWYgKG5vZGVJc0RhdGFOb2RlKSB7XG4gICAgICBib3VuZGFyeU5vZGUgPSBib3VuZGFyeVBvc2l0aW9uLm5vZGU7XG4gICAgICBib3VuZGFyeVBhcmVudCA9IGJvdW5kYXJ5Tm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZE5vZGVzID0gYm91bmRhcnlQb3NpdGlvbi5ub2RlLmNoaWxkTm9kZXM7XG4gICAgICBib3VuZGFyeU5vZGUgPSBib3VuZGFyeU9mZnNldCA8IGNoaWxkTm9kZXMubGVuZ3RoID8gY2hpbGROb2Rlc1tib3VuZGFyeU9mZnNldF0gOiBudWxsO1xuICAgICAgYm91bmRhcnlQYXJlbnQgPSBib3VuZGFyeVBvc2l0aW9uLm5vZGU7XG4gICAgfVxuXG4gICAgLy8gUG9zaXRpb24gdGhlIHJhbmdlIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBib3VuZGFyeVxuICAgIHdvcmtpbmdOb2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgLy8gTWFraW5nIHRoZSB3b3JraW5nIGVsZW1lbnQgbm9uLWVtcHR5IGVsZW1lbnQgcGVyc3VhZGVzIElFIHRvIGNvbnNpZGVyIHRoZSBUZXh0UmFuZ2UgYm91bmRhcnkgdG8gYmUgd2l0aGluIHRoZVxuICAgIC8vIGVsZW1lbnQgcmF0aGVyIHRoYW4gaW1tZWRpYXRlbHkgYmVmb3JlIG9yIGFmdGVyIGl0LCB3aGljaCBpcyB3aGF0IHdlIHdhbnRcbiAgICB3b3JraW5nTm9kZS5pbm5lckhUTUwgPSBcIiYjZmVmZjtcIjtcblxuICAgIC8vIGluc2VydEJlZm9yZSBpcyBzdXBwb3NlZCB0byB3b3JrIGxpa2UgYXBwZW5kQ2hpbGQgaWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgbnVsbC4gSG93ZXZlciwgYSBidWcgcmVwb3J0XG4gICAgLy8gZm9yIElFUmFuZ2Ugc3VnZ2VzdHMgdGhhdCBpdCBjYW4gY3Jhc2ggdGhlIGJyb3dzZXI6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9pZXJhbmdlL2lzc3Vlcy9kZXRhaWw/aWQ9MTJcbiAgICBpZiAoYm91bmRhcnlOb2RlKSB7XG4gICAgICBib3VuZGFyeVBhcmVudC5pbnNlcnRCZWZvcmUod29ya2luZ05vZGUsIGJvdW5kYXJ5Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kYXJ5UGFyZW50LmFwcGVuZENoaWxkKHdvcmtpbmdOb2RlKTtcbiAgICB9XG5cbiAgICB3b3JraW5nUmFuZ2UubW92ZVRvRWxlbWVudFRleHQod29ya2luZ05vZGUpO1xuICAgIHdvcmtpbmdSYW5nZS5jb2xsYXBzZSghaXNTdGFydCk7XG5cbiAgICAvLyBDbGVhbiB1cFxuICAgIGJvdW5kYXJ5UGFyZW50LnJlbW92ZUNoaWxkKHdvcmtpbmdOb2RlKTtcblxuICAgIC8vIE1vdmUgdGhlIHdvcmtpbmcgcmFuZ2UgdG8gdGhlIHRleHQgb2Zmc2V0LCBpZiByZXF1aXJlZFxuICAgIGlmIChub2RlSXNEYXRhTm9kZSkge1xuICAgICAgd29ya2luZ1JhbmdlW2lzU3RhcnQgPyBcIm1vdmVTdGFydFwiIDogXCJtb3ZlRW5kXCJdKFwiY2hhcmFjdGVyXCIsIGJvdW5kYXJ5T2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya2luZ1JhbmdlO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICBpZiAoYXBpLmZlYXR1cmVzLmltcGxlbWVudHNEb21SYW5nZSAmJiAoIWFwaS5mZWF0dXJlcy5pbXBsZW1lbnRzVGV4dFJhbmdlIHx8ICFhcGkuY29uZmlnLnByZWZlclRleHRSYW5nZSkpIHtcbiAgICAvLyBUaGlzIGlzIGEgd3JhcHBlciBhcm91bmQgdGhlIGJyb3dzZXIncyBuYXRpdmUgRE9NIFJhbmdlLiBJdCBoYXMgdHdvIGFpbXM6XG4gICAgLy8gLSBQcm92aWRlIHdvcmthcm91bmRzIGZvciBzcGVjaWZpYyBicm93c2VyIGJ1Z3NcbiAgICAvLyAtIHByb3ZpZGUgY29udmVuaWVudCBleHRlbnNpb25zLCB3aGljaCBhcmUgaW5oZXJpdGVkIGZyb20gUmFuZ3kncyBEb21SYW5nZVxuXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByYW5nZVByb3RvO1xuICAgICAgdmFyIHJhbmdlUHJvcGVydGllcyA9IERvbVJhbmdlLnJhbmdlUHJvcGVydGllcztcbiAgICAgIHZhciBjYW5TZXRSYW5nZVN0YXJ0QWZ0ZXJFbmQ7XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVJhbmdlUHJvcGVydGllcyhyYW5nZSkge1xuICAgICAgICB2YXIgaSA9IHJhbmdlUHJvcGVydGllcy5sZW5ndGgsXG4gICAgICAgICAgICBwcm9wO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgcHJvcCA9IHJhbmdlUHJvcGVydGllc1tpXTtcbiAgICAgICAgICByYW5nZVtwcm9wXSA9IHJhbmdlLm5hdGl2ZVJhbmdlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZU5hdGl2ZVJhbmdlKHJhbmdlLCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0KSB7XG4gICAgICAgIHZhciBzdGFydE1vdmVkID0gcmFuZ2Uuc3RhcnRDb250YWluZXIgIT09IHN0YXJ0Q29udGFpbmVyIHx8IHJhbmdlLnN0YXJ0T2Zmc2V0ICE9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICB2YXIgZW5kTW92ZWQgPSByYW5nZS5lbmRDb250YWluZXIgIT09IGVuZENvbnRhaW5lciB8fCByYW5nZS5lbmRPZmZzZXQgIT0gZW5kT2Zmc2V0O1xuXG4gICAgICAgIC8vIEFsd2F5cyBzZXQgYm90aCBib3VuZGFyaWVzIGZvciB0aGUgYmVuZWZpdCBvZiBJRTkgKHNlZSBpc3N1ZSAzNSlcbiAgICAgICAgaWYgKHN0YXJ0TW92ZWQgfHwgZW5kTW92ZWQpIHtcbiAgICAgICAgICByYW5nZS5zZXRFbmQoZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQpO1xuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0YWNoKHJhbmdlKSB7XG4gICAgICAgIHJhbmdlLm5hdGl2ZVJhbmdlLmRldGFjaCgpO1xuICAgICAgICByYW5nZS5kZXRhY2hlZCA9IHRydWU7XG4gICAgICAgIHZhciBpID0gcmFuZ2VQcm9wZXJ0aWVzLmxlbmd0aCxcbiAgICAgICAgICAgIHByb3A7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBwcm9wID0gcmFuZ2VQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgIHJhbmdlW3Byb3BdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyO1xuXG4gICAgICBXcmFwcGVkUmFuZ2UgPSBmdW5jdGlvbiBXcmFwcGVkUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbmdlIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmF0aXZlUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgRG9tUmFuZ2UuY3JlYXRlUHJvdG90eXBlUmFuZ2UoV3JhcHBlZFJhbmdlLCB1cGRhdGVOYXRpdmVSYW5nZSwgZGV0YWNoKTtcblxuICAgICAgcmFuZ2VQcm90byA9IFdyYXBwZWRSYW5nZS5wcm90b3R5cGU7XG5cbiAgICAgIHJhbmdlUHJvdG8uc2VsZWN0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgcmFuZ2VQcm90by5kZWxldGVDb250ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICB9O1xuXG4gICAgICByYW5nZVByb3RvLmV4dHJhY3RDb250ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZyYWcgPSB0aGlzLm5hdGl2ZVJhbmdlLmV4dHJhY3RDb250ZW50cygpO1xuICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgIHJldHVybiBmcmFnO1xuICAgICAgfTtcblxuICAgICAgcmFuZ2VQcm90by5jbG9uZUNvbnRlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVSYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBUT0RPOiBVbnRpbCBJIGNhbiBmaW5kIGEgd2F5IHRvIHByb2dyYW1tYXRpY2FsbHkgdHJpZ2dlciB0aGUgRmlyZWZveCBidWcgKGFwcGFyZW50bHkgbG9uZy1zdGFuZGluZywgc3RpbGxcbiAgICAgIC8vIHByZXNlbnQgaW4gMy42LjgpIHRoYXQgdGhyb3dzIFwiSW5kZXggb3Igc2l6ZSBpcyBuZWdhdGl2ZSBvciBncmVhdGVyIHRoYW4gdGhlIGFsbG93ZWQgYW1vdW50XCIgZm9yXG4gICAgICAvLyBpbnNlcnROb2RlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcywgYWxsIGJyb3dzZXJzIHdpbGwgaGF2ZSB0byB1c2UgdGhlIFJhbmd5J3Mgb3duIGltcGxlbWVudGF0aW9uIG9mXG4gICAgICAvLyBpbnNlcnROb2RlLCB3aGljaCB3b3JrcyBidXQgaXMgYWxtb3N0IGNlcnRhaW5seSBzbG93ZXIgdGhhbiB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLlxuICAgICAgLypcbiAgICAgICAgICAgICAgICAgIHJhbmdlUHJvdG8uaW5zZXJ0Tm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLmluc2VydE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICovXG5cbiAgICAgIHJhbmdlUHJvdG8uc3Vycm91bmRDb250ZW50cyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc3Vycm91bmRDb250ZW50cyhub2RlKTtcbiAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgcmFuZ2VQcm90by5jb2xsYXBzZSA9IGZ1bmN0aW9uIChpc1N0YXJ0KSB7XG4gICAgICAgIHRoaXMubmF0aXZlUmFuZ2UuY29sbGFwc2UoaXNTdGFydCk7XG4gICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgIH07XG5cbiAgICAgIHJhbmdlUHJvdG8uY2xvbmVSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcmFwcGVkUmFuZ2UodGhpcy5uYXRpdmVSYW5nZS5jbG9uZVJhbmdlKCkpO1xuICAgICAgfTtcblxuICAgICAgcmFuZ2VQcm90by5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICB9O1xuXG4gICAgICByYW5nZVByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVSYW5nZS50b1N0cmluZygpO1xuICAgICAgfTtcblxuICAgICAgLy8gQ3JlYXRlIHRlc3QgcmFuZ2UgYW5kIG5vZGUgZm9yIGZlYXR1cmUgZGV0ZWN0aW9uXG5cbiAgICAgIHZhciB0ZXN0VGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcInRlc3RcIik7XG4gICAgICBkb20uZ2V0Qm9keShkb2N1bWVudCkuYXBwZW5kQ2hpbGQodGVzdFRleHROb2RlKTtcbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG5cbiAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAvLyBUZXN0IGZvciBGaXJlZm94IDIgYnVnIHRoYXQgcHJldmVudHMgbW92aW5nIHRoZSBzdGFydCBvZiBhIFJhbmdlIHRvIGEgcG9pbnQgYWZ0ZXIgaXRzIGN1cnJlbnQgZW5kIGFuZFxuICAgICAgLy8gY29ycmVjdCBmb3IgaXRcblxuICAgICAgcmFuZ2Uuc2V0U3RhcnQodGVzdFRleHROb2RlLCAwKTtcbiAgICAgIHJhbmdlLnNldEVuZCh0ZXN0VGV4dE5vZGUsIDApO1xuXG4gICAgICB0cnkge1xuICAgICAgICByYW5nZS5zZXRTdGFydCh0ZXN0VGV4dE5vZGUsIDEpO1xuICAgICAgICBjYW5TZXRSYW5nZVN0YXJ0QWZ0ZXJFbmQgPSB0cnVlO1xuXG4gICAgICAgIHJhbmdlUHJvdG8uc2V0U3RhcnQgPSBmdW5jdGlvbiAobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgfTtcblxuICAgICAgICByYW5nZVByb3RvLnNldEVuZCA9IGZ1bmN0aW9uIChub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIgPSBmdW5jdGlvbiBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIobmFtZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZVtuYW1lXShub2RlKTtcbiAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZXgpIHtcblxuICAgICAgICBjYW5TZXRSYW5nZVN0YXJ0QWZ0ZXJFbmQgPSBmYWxzZTtcblxuICAgICAgICByYW5nZVByb3RvLnNldFN0YXJ0ID0gZnVuY3Rpb24gKG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgfTtcblxuICAgICAgICByYW5nZVByb3RvLnNldEVuZCA9IGZ1bmN0aW9uIChub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlciA9IGZ1bmN0aW9uIGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcihuYW1lLCBvcHBvc2l0ZU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2VbbmFtZV0obm9kZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlW29wcG9zaXRlTmFtZV0obm9kZSk7XG4gICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2VbbmFtZV0obm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmFuZ2VQcm90by5zZXRTdGFydEJlZm9yZSA9IGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcihcInNldFN0YXJ0QmVmb3JlXCIsIFwic2V0RW5kQmVmb3JlXCIpO1xuICAgICAgcmFuZ2VQcm90by5zZXRTdGFydEFmdGVyID0gY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKFwic2V0U3RhcnRBZnRlclwiLCBcInNldEVuZEFmdGVyXCIpO1xuICAgICAgcmFuZ2VQcm90by5zZXRFbmRCZWZvcmUgPSBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoXCJzZXRFbmRCZWZvcmVcIiwgXCJzZXRTdGFydEJlZm9yZVwiKTtcbiAgICAgIHJhbmdlUHJvdG8uc2V0RW5kQWZ0ZXIgPSBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoXCJzZXRFbmRBZnRlclwiLCBcInNldFN0YXJ0QWZ0ZXJcIik7XG5cbiAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAvLyBUZXN0IGZvciBhbmQgY29ycmVjdCBGaXJlZm94IDIgYmVoYXZpb3VyIHdpdGggc2VsZWN0Tm9kZUNvbnRlbnRzIG9uIHRleHQgbm9kZXM6IGl0IGNvbGxhcHNlcyB0aGUgcmFuZ2UgdG9cbiAgICAgIC8vIHRoZSAwdGggY2hhcmFjdGVyIG9mIHRoZSB0ZXh0IG5vZGVcbiAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyh0ZXN0VGV4dE5vZGUpO1xuICAgICAgaWYgKHJhbmdlLnN0YXJ0Q29udGFpbmVyID09IHRlc3RUZXh0Tm9kZSAmJiByYW5nZS5lbmRDb250YWluZXIgPT0gdGVzdFRleHROb2RlICYmIHJhbmdlLnN0YXJ0T2Zmc2V0ID09IDAgJiYgcmFuZ2UuZW5kT2Zmc2V0ID09IHRlc3RUZXh0Tm9kZS5sZW5ndGgpIHtcbiAgICAgICAgcmFuZ2VQcm90by5zZWxlY3ROb2RlQ29udGVudHMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlUHJvdG8uc2VsZWN0Tm9kZUNvbnRlbnRzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB0aGlzLnNldFN0YXJ0KG5vZGUsIDApO1xuICAgICAgICAgIHRoaXMuc2V0RW5kKG5vZGUsIERvbVJhbmdlLmdldEVuZE9mZnNldChub2RlKSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAvLyBUZXN0IGZvciBXZWJLaXQgYnVnIHRoYXQgaGFzIHRoZSBiZWFodmlvdXIgb2YgY29tcGFyZUJvdW5kYXJ5UG9pbnRzIHJvdW5kIHRoZSB3cm9uZyB3YXkgZm9yIGNvbnN0YW50c1xuICAgICAgLy8gU1RBUlRfVE9fRU5EIGFuZCBFTkRfVE9fU1RBUlQ6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDczOFxuXG4gICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHModGVzdFRleHROb2RlKTtcbiAgICAgIHJhbmdlLnNldEVuZCh0ZXN0VGV4dE5vZGUsIDMpO1xuXG4gICAgICB2YXIgcmFuZ2UyID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJhbmdlMi5zZWxlY3ROb2RlQ29udGVudHModGVzdFRleHROb2RlKTtcbiAgICAgIHJhbmdlMi5zZXRFbmQodGVzdFRleHROb2RlLCA0KTtcbiAgICAgIHJhbmdlMi5zZXRTdGFydCh0ZXN0VGV4dE5vZGUsIDIpO1xuXG4gICAgICBpZiAocmFuZ2UuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKHJhbmdlLlNUQVJUX1RPX0VORCwgcmFuZ2UyKSA9PSAtMSAmIHJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyhyYW5nZS5FTkRfVE9fU1RBUlQsIHJhbmdlMikgPT0gMSkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSB3cm9uZyB3YXkgcm91bmQsIHNvIGNvcnJlY3QgZm9yIGl0XG5cblxuICAgICAgICByYW5nZVByb3RvLmNvbXBhcmVCb3VuZGFyeVBvaW50cyA9IGZ1bmN0aW9uICh0eXBlLCByYW5nZSkge1xuICAgICAgICAgIHJhbmdlID0gcmFuZ2UubmF0aXZlUmFuZ2UgfHwgcmFuZ2U7XG4gICAgICAgICAgaWYgKHR5cGUgPT0gcmFuZ2UuU1RBUlRfVE9fRU5EKSB7XG4gICAgICAgICAgICB0eXBlID0gcmFuZ2UuRU5EX1RPX1NUQVJUO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSByYW5nZS5FTkRfVE9fU1RBUlQpIHtcbiAgICAgICAgICAgIHR5cGUgPSByYW5nZS5TVEFSVF9UT19FTkQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZVJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyh0eXBlLCByYW5nZSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZVByb3RvLmNvbXBhcmVCb3VuZGFyeVBvaW50cyA9IGZ1bmN0aW9uICh0eXBlLCByYW5nZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZVJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyh0eXBlLCByYW5nZS5uYXRpdmVSYW5nZSB8fCByYW5nZSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAvLyBUZXN0IGZvciBleGlzdGVuY2Ugb2YgY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IGFuZCBkZWxlZ2F0ZSB0byBpdCBpZiBpdCBleGlzdHNcbiAgICAgIGlmIChhcGkudXRpbC5pc0hvc3RNZXRob2QocmFuZ2UsIFwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50XCIpKSB7XG4gICAgICAgIHJhbmdlUHJvdG8uY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50ID0gZnVuY3Rpb24gKGZyYWdtZW50U3RyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlUmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KGZyYWdtZW50U3RyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgIC8vIENsZWFuIHVwXG4gICAgICBkb20uZ2V0Qm9keShkb2N1bWVudCkucmVtb3ZlQ2hpbGQodGVzdFRleHROb2RlKTtcbiAgICAgIHJhbmdlLmRldGFjaCgpO1xuICAgICAgcmFuZ2UyLmRldGFjaCgpO1xuICAgIH0pKCk7XG5cbiAgICBhcGkuY3JlYXRlTmF0aXZlUmFuZ2UgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgICByZXR1cm4gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChhcGkuZmVhdHVyZXMuaW1wbGVtZW50c1RleHRSYW5nZSkge1xuICAgIC8vIFRoaXMgaXMgYSB3cmFwcGVyIGFyb3VuZCBhIFRleHRSYW5nZSwgcHJvdmlkaW5nIGZ1bGwgRE9NIFJhbmdlIGZ1bmN0aW9uYWxpdHkgdXNpbmcgcmFuZ3kncyBEb21SYW5nZSBhcyBhXG4gICAgLy8gcHJvdG90eXBlXG5cbiAgICBXcmFwcGVkUmFuZ2UgPSBmdW5jdGlvbiBXcmFwcGVkUmFuZ2UodGV4dFJhbmdlKSB7XG4gICAgICB0aGlzLnRleHRSYW5nZSA9IHRleHRSYW5nZTtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH07XG5cbiAgICBXcmFwcGVkUmFuZ2UucHJvdG90eXBlID0gbmV3IERvbVJhbmdlKGRvY3VtZW50KTtcblxuICAgIFdyYXBwZWRSYW5nZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGFydCwgZW5kO1xuXG4gICAgICAvLyBUZXh0UmFuZ2UncyBwYXJlbnRFbGVtZW50KCkgbWV0aG9kIGNhbm5vdCBiZSB0cnVzdGVkLiBnZXRUZXh0UmFuZ2VDb250YWluZXJFbGVtZW50KCkgd29ya3MgYXJvdW5kIHRoYXQuXG4gICAgICB2YXIgcmFuZ2VDb250YWluZXJFbGVtZW50ID0gZ2V0VGV4dFJhbmdlQ29udGFpbmVyRWxlbWVudCh0aGlzLnRleHRSYW5nZSk7XG5cbiAgICAgIGlmICh0ZXh0UmFuZ2VJc0NvbGxhcHNlZCh0aGlzLnRleHRSYW5nZSkpIHtcbiAgICAgICAgZW5kID0gc3RhcnQgPSBnZXRUZXh0UmFuZ2VCb3VuZGFyeVBvc2l0aW9uKHRoaXMudGV4dFJhbmdlLCByYW5nZUNvbnRhaW5lckVsZW1lbnQsIHRydWUsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBzdGFydCA9IGdldFRleHRSYW5nZUJvdW5kYXJ5UG9zaXRpb24odGhpcy50ZXh0UmFuZ2UsIHJhbmdlQ29udGFpbmVyRWxlbWVudCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBlbmQgPSBnZXRUZXh0UmFuZ2VCb3VuZGFyeVBvc2l0aW9uKHRoaXMudGV4dFJhbmdlLCByYW5nZUNvbnRhaW5lckVsZW1lbnQsIGZhbHNlLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhcnQoc3RhcnQubm9kZSwgc3RhcnQub2Zmc2V0KTtcbiAgICAgIHRoaXMuc2V0RW5kKGVuZC5ub2RlLCBlbmQub2Zmc2V0KTtcbiAgICB9O1xuXG4gICAgRG9tUmFuZ2UuY29weUNvbXBhcmlzb25Db25zdGFudHMoV3JhcHBlZFJhbmdlKTtcblxuICAgIC8vIEFkZCBXcmFwcGVkUmFuZ2UgYXMgdGhlIFJhbmdlIHByb3BlcnR5IG9mIHRoZSBnbG9iYWwgb2JqZWN0IHRvIGFsbG93IGV4cHJlc3Npb24gbGlrZSBSYW5nZS5FTkRfVE9fRU5EIHRvIHdvcmtcbiAgICB2YXIgZ2xvYmFsT2JqID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSgpO1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsT2JqLlJhbmdlID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGdsb2JhbE9iai5SYW5nZSA9IFdyYXBwZWRSYW5nZTtcbiAgICB9XG5cbiAgICBhcGkuY3JlYXRlTmF0aXZlUmFuZ2UgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgICByZXR1cm4gZG9jLmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChhcGkuZmVhdHVyZXMuaW1wbGVtZW50c1RleHRSYW5nZSkge1xuICAgIFdyYXBwZWRSYW5nZS5yYW5nZVRvVGV4dFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICBpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIHZhciB0ciA9IGNyZWF0ZUJvdW5kYXJ5VGV4dFJhbmdlKG5ldyBEb21Qb3NpdGlvbihyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gdHI7XG5cbiAgICAgICAgLy9yZXR1cm4gY3JlYXRlQm91bmRhcnlUZXh0UmFuZ2UobmV3IERvbVBvc2l0aW9uKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCksIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHN0YXJ0UmFuZ2UgPSBjcmVhdGVCb3VuZGFyeVRleHRSYW5nZShuZXcgRG9tUG9zaXRpb24ocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSwgdHJ1ZSk7XG4gICAgICAgIHZhciBlbmRSYW5nZSA9IGNyZWF0ZUJvdW5kYXJ5VGV4dFJhbmdlKG5ldyBEb21Qb3NpdGlvbihyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCksIGZhbHNlKTtcbiAgICAgICAgdmFyIHRleHRSYW5nZSA9IGRvbS5nZXREb2N1bWVudChyYW5nZS5zdGFydENvbnRhaW5lcikuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgdGV4dFJhbmdlLnNldEVuZFBvaW50KFwiU3RhcnRUb1N0YXJ0XCIsIHN0YXJ0UmFuZ2UpO1xuICAgICAgICB0ZXh0UmFuZ2Uuc2V0RW5kUG9pbnQoXCJFbmRUb0VuZFwiLCBlbmRSYW5nZSk7XG4gICAgICAgIHJldHVybiB0ZXh0UmFuZ2U7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIFdyYXBwZWRSYW5nZS5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJXcmFwcGVkUmFuZ2VcIjtcbiAgfTtcblxuICBhcGkuV3JhcHBlZFJhbmdlID0gV3JhcHBlZFJhbmdlO1xuXG4gIGFwaS5jcmVhdGVSYW5nZSA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgcmV0dXJuIG5ldyBXcmFwcGVkUmFuZ2UoYXBpLmNyZWF0ZU5hdGl2ZVJhbmdlKGRvYykpO1xuICB9O1xuXG4gIGFwaS5jcmVhdGVSYW5neVJhbmdlID0gZnVuY3Rpb24gKGRvYykge1xuICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcbiAgICByZXR1cm4gbmV3IERvbVJhbmdlKGRvYyk7XG4gIH07XG5cbiAgYXBpLmNyZWF0ZUlmcmFtZVJhbmdlID0gZnVuY3Rpb24gKGlmcmFtZUVsKSB7XG4gICAgcmV0dXJuIGFwaS5jcmVhdGVSYW5nZShkb20uZ2V0SWZyYW1lRG9jdW1lbnQoaWZyYW1lRWwpKTtcbiAgfTtcblxuICBhcGkuY3JlYXRlSWZyYW1lUmFuZ3lSYW5nZSA9IGZ1bmN0aW9uIChpZnJhbWVFbCkge1xuICAgIHJldHVybiBhcGkuY3JlYXRlUmFuZ3lSYW5nZShkb20uZ2V0SWZyYW1lRG9jdW1lbnQoaWZyYW1lRWwpKTtcbiAgfTtcblxuICBhcGkuYWRkQ3JlYXRlTWlzc2luZ05hdGl2ZUFwaUxpc3RlbmVyKGZ1bmN0aW9uICh3aW4pIHtcbiAgICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuICAgIGlmICh0eXBlb2YgZG9jLmNyZWF0ZVJhbmdlID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRvYy5jcmVhdGVSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFwaS5jcmVhdGVSYW5nZSh0aGlzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGRvYyA9IHdpbiA9IG51bGw7XG4gIH0pO1xufSk7cmFuZ3kuY3JlYXRlTW9kdWxlKFwiV3JhcHBlZFNlbGVjdGlvblwiLCBmdW5jdGlvbiAoYXBpLCBtb2R1bGUpIHtcbiAgLy8gVGhpcyB3aWxsIGNyZWF0ZSBhIHNlbGVjdGlvbiBvYmplY3Qgd3JhcHBlciB0aGF0IGZvbGxvd3MgdGhlIFNlbGVjdGlvbiBvYmplY3QgZm91bmQgaW4gdGhlIFdIQVRXRyBkcmFmdCBET00gUmFuZ2VcbiAgLy8gc3BlYyAoaHR0cDovL2h0bWw1Lm9yZy9zcGVjcy9kb20tcmFuZ2UuaHRtbClcblxuICBhcGkucmVxdWlyZU1vZHVsZXMoW1wiRG9tVXRpbFwiLCBcIkRvbVJhbmdlXCIsIFwiV3JhcHBlZFJhbmdlXCJdKTtcblxuICBhcGkuY29uZmlnLmNoZWNrU2VsZWN0aW9uUmFuZ2VzID0gdHJ1ZTtcblxuICB2YXIgQk9PTEVBTiA9IFwiYm9vbGVhblwiLFxuICAgICAgd2luZG93UHJvcGVydHlOYW1lID0gXCJfcmFuZ3lTZWxlY3Rpb25cIixcbiAgICAgIGRvbSA9IGFwaS5kb20sXG4gICAgICB1dGlsID0gYXBpLnV0aWwsXG4gICAgICBEb21SYW5nZSA9IGFwaS5Eb21SYW5nZSxcbiAgICAgIFdyYXBwZWRSYW5nZSA9IGFwaS5XcmFwcGVkUmFuZ2UsXG4gICAgICBET01FeGNlcHRpb24gPSBhcGkuRE9NRXhjZXB0aW9uLFxuICAgICAgRG9tUG9zaXRpb24gPSBkb20uRG9tUG9zaXRpb24sXG4gICAgICBnZXRTZWxlY3Rpb24sXG4gICAgICBzZWxlY3Rpb25Jc0NvbGxhcHNlZCxcbiAgICAgIENPTlRST0wgPSBcIkNvbnRyb2xcIjtcblxuICBmdW5jdGlvbiBnZXRXaW5TZWxlY3Rpb24od2luUGFyYW0pIHtcbiAgICByZXR1cm4gKHdpblBhcmFtIHx8IHdpbmRvdykuZ2V0U2VsZWN0aW9uKCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREb2NTZWxlY3Rpb24od2luUGFyYW0pIHtcbiAgICByZXR1cm4gKHdpblBhcmFtIHx8IHdpbmRvdykuZG9jdW1lbnQuc2VsZWN0aW9uO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgdGhlIFJhbmdlL1RleHRSYW5nZSBhbmQgU2VsZWN0aW9uIGZlYXR1cmVzIHJlcXVpcmVkXG4gIC8vIFRlc3QgZm9yIGFiaWxpdHkgdG8gcmV0cmlldmUgc2VsZWN0aW9uXG4gIHZhciBpbXBsZW1lbnRzV2luR2V0U2VsZWN0aW9uID0gYXBpLnV0aWwuaXNIb3N0TWV0aG9kKHdpbmRvdywgXCJnZXRTZWxlY3Rpb25cIiksXG4gICAgICBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uID0gYXBpLnV0aWwuaXNIb3N0T2JqZWN0KGRvY3VtZW50LCBcInNlbGVjdGlvblwiKTtcblxuICB2YXIgdXNlRG9jdW1lbnRTZWxlY3Rpb24gPSBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uICYmICghaW1wbGVtZW50c1dpbkdldFNlbGVjdGlvbiB8fCBhcGkuY29uZmlnLnByZWZlclRleHRSYW5nZSk7XG5cbiAgaWYgKHVzZURvY3VtZW50U2VsZWN0aW9uKSB7XG4gICAgZ2V0U2VsZWN0aW9uID0gZ2V0RG9jU2VsZWN0aW9uO1xuICAgIGFwaS5pc1NlbGVjdGlvblZhbGlkID0gZnVuY3Rpb24gKHdpblBhcmFtKSB7XG4gICAgICB2YXIgZG9jID0gKHdpblBhcmFtIHx8IHdpbmRvdykuZG9jdW1lbnQsXG4gICAgICAgICAgbmF0aXZlU2VsID0gZG9jLnNlbGVjdGlvbjtcblxuICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgc2VsZWN0aW9uIFRleHRSYW5nZSBpcyBhY3R1YWxseSBjb250YWluZWQgd2l0aGluIHRoZSBjb3JyZWN0IGRvY3VtZW50XG4gICAgICByZXR1cm4gbmF0aXZlU2VsLnR5cGUgIT0gXCJOb25lXCIgfHwgZG9tLmdldERvY3VtZW50KG5hdGl2ZVNlbC5jcmVhdGVSYW5nZSgpLnBhcmVudEVsZW1lbnQoKSkgPT0gZG9jO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoaW1wbGVtZW50c1dpbkdldFNlbGVjdGlvbikge1xuICAgIGdldFNlbGVjdGlvbiA9IGdldFdpblNlbGVjdGlvbjtcbiAgICBhcGkuaXNTZWxlY3Rpb25WYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmZhaWwoXCJOZWl0aGVyIGRvY3VtZW50LnNlbGVjdGlvbiBvciB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkgZGV0ZWN0ZWQuXCIpO1xuICB9XG5cbiAgYXBpLmdldE5hdGl2ZVNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbjtcblxuICB2YXIgdGVzdFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbigpO1xuICB2YXIgdGVzdFJhbmdlID0gYXBpLmNyZWF0ZU5hdGl2ZVJhbmdlKGRvY3VtZW50KTtcbiAgdmFyIGJvZHkgPSBkb20uZ2V0Qm9keShkb2N1bWVudCk7XG5cbiAgLy8gT2J0YWluaW5nIGEgcmFuZ2UgZnJvbSBhIHNlbGVjdGlvblxuICB2YXIgc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMgPSB1dGlsLmFyZUhvc3RPYmplY3RzKHRlc3RTZWxlY3Rpb24sIFtcImFuY2hvck5vZGVcIiwgXCJmb2N1c05vZGVcIl0gJiYgdXRpbC5hcmVIb3N0UHJvcGVydGllcyh0ZXN0U2VsZWN0aW9uLCBbXCJhbmNob3JPZmZzZXRcIiwgXCJmb2N1c09mZnNldFwiXSkpO1xuICBhcGkuZmVhdHVyZXMuc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cztcblxuICAvLyBUZXN0IGZvciBleGlzdGVuY2Ugb2YgbmF0aXZlIHNlbGVjdGlvbiBleHRlbmQoKSBtZXRob2RcbiAgdmFyIHNlbGVjdGlvbkhhc0V4dGVuZCA9IHV0aWwuaXNIb3N0TWV0aG9kKHRlc3RTZWxlY3Rpb24sIFwiZXh0ZW5kXCIpO1xuICBhcGkuZmVhdHVyZXMuc2VsZWN0aW9uSGFzRXh0ZW5kID0gc2VsZWN0aW9uSGFzRXh0ZW5kO1xuXG4gIC8vIFRlc3QgaWYgcmFuZ2VDb3VudCBleGlzdHNcbiAgdmFyIHNlbGVjdGlvbkhhc1JhbmdlQ291bnQgPSB0eXBlb2YgdGVzdFNlbGVjdGlvbi5yYW5nZUNvdW50ID09IFwibnVtYmVyXCI7XG4gIGFwaS5mZWF0dXJlcy5zZWxlY3Rpb25IYXNSYW5nZUNvdW50ID0gc2VsZWN0aW9uSGFzUmFuZ2VDb3VudDtcblxuICB2YXIgc2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcyA9IGZhbHNlO1xuICB2YXIgY29sbGFwc2VkTm9uRWRpdGFibGVTZWxlY3Rpb25zU3VwcG9ydGVkID0gdHJ1ZTtcblxuICBpZiAodXRpbC5hcmVIb3N0TWV0aG9kcyh0ZXN0U2VsZWN0aW9uLCBbXCJhZGRSYW5nZVwiLCBcImdldFJhbmdlQXRcIiwgXCJyZW1vdmVBbGxSYW5nZXNcIl0pICYmIHR5cGVvZiB0ZXN0U2VsZWN0aW9uLnJhbmdlQ291bnQgPT0gXCJudW1iZXJcIiAmJiBhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlKSB7XG5cbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICBib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgICAgIHZhciBpZnJhbWVEb2MgPSBkb20uZ2V0SWZyYW1lRG9jdW1lbnQoaWZyYW1lKTtcbiAgICAgIGlmcmFtZURvYy5vcGVuKCk7XG4gICAgICBpZnJhbWVEb2Mud3JpdGUoXCI8aHRtbD48aGVhZD48L2hlYWQ+PGJvZHk+MTI8L2JvZHk+PC9odG1sPlwiKTtcbiAgICAgIGlmcmFtZURvYy5jbG9zZSgpO1xuXG4gICAgICB2YXIgc2VsID0gZG9tLmdldElmcmFtZVdpbmRvdyhpZnJhbWUpLmdldFNlbGVjdGlvbigpO1xuICAgICAgdmFyIGRvY0VsID0gaWZyYW1lRG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgIHZhciBpZnJhbWVCb2R5ID0gZG9jRWwubGFzdENoaWxkLFxuICAgICAgICAgIHRleHROb2RlID0gaWZyYW1lQm9keS5maXJzdENoaWxkO1xuXG4gICAgICAvLyBUZXN0IHdoZXRoZXIgdGhlIG5hdGl2ZSBzZWxlY3Rpb24gd2lsbCBhbGxvdyBhIGNvbGxhcHNlZCBzZWxlY3Rpb24gd2l0aGluIGEgbm9uLWVkaXRhYmxlIGVsZW1lbnRcbiAgICAgIHZhciByMSA9IGlmcmFtZURvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgcjEuc2V0U3RhcnQodGV4dE5vZGUsIDEpO1xuICAgICAgcjEuY29sbGFwc2UodHJ1ZSk7XG4gICAgICBzZWwuYWRkUmFuZ2UocjEpO1xuICAgICAgY29sbGFwc2VkTm9uRWRpdGFibGVTZWxlY3Rpb25zU3VwcG9ydGVkID0gc2VsLnJhbmdlQ291bnQgPT0gMTtcbiAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgICAgLy8gVGVzdCB3aGV0aGVyIHRoZSBuYXRpdmUgc2VsZWN0aW9uIGlzIGNhcGFibGUgb2Ygc3VwcG9ydGluZyBtdWx0aXBsZSByYW5nZXNcbiAgICAgIHZhciByMiA9IHIxLmNsb25lUmFuZ2UoKTtcbiAgICAgIHIxLnNldFN0YXJ0KHRleHROb2RlLCAwKTtcbiAgICAgIHIyLnNldEVuZCh0ZXh0Tm9kZSwgMik7XG4gICAgICBzZWwuYWRkUmFuZ2UocjEpO1xuICAgICAgc2VsLmFkZFJhbmdlKHIyKTtcblxuICAgICAgc2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcyA9IHNlbC5yYW5nZUNvdW50ID09IDI7XG5cbiAgICAgIC8vIENsZWFuIHVwXG4gICAgICByMS5kZXRhY2goKTtcbiAgICAgIHIyLmRldGFjaCgpO1xuXG4gICAgICBib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIGFwaS5mZWF0dXJlcy5zZWxlY3Rpb25TdXBwb3J0c011bHRpcGxlUmFuZ2VzID0gc2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcztcbiAgYXBpLmZlYXR1cmVzLmNvbGxhcHNlZE5vbkVkaXRhYmxlU2VsZWN0aW9uc1N1cHBvcnRlZCA9IGNvbGxhcHNlZE5vbkVkaXRhYmxlU2VsZWN0aW9uc1N1cHBvcnRlZDtcblxuICAvLyBDb250cm9sUmFuZ2VzXG4gIHZhciBpbXBsZW1lbnRzQ29udHJvbFJhbmdlID0gZmFsc2UsXG4gICAgICB0ZXN0Q29udHJvbFJhbmdlO1xuXG4gIGlmIChib2R5ICYmIHV0aWwuaXNIb3N0TWV0aG9kKGJvZHksIFwiY3JlYXRlQ29udHJvbFJhbmdlXCIpKSB7XG4gICAgdGVzdENvbnRyb2xSYW5nZSA9IGJvZHkuY3JlYXRlQ29udHJvbFJhbmdlKCk7XG4gICAgaWYgKHV0aWwuYXJlSG9zdFByb3BlcnRpZXModGVzdENvbnRyb2xSYW5nZSwgW1wiaXRlbVwiLCBcImFkZFwiXSkpIHtcbiAgICAgIGltcGxlbWVudHNDb250cm9sUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0NvbnRyb2xSYW5nZSA9IGltcGxlbWVudHNDb250cm9sUmFuZ2U7XG5cbiAgLy8gU2VsZWN0aW9uIGNvbGxhcHNlZG5lc3NcbiAgaWYgKHNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzKSB7XG4gICAgc2VsZWN0aW9uSXNDb2xsYXBzZWQgPSBmdW5jdGlvbiBzZWxlY3Rpb25Jc0NvbGxhcHNlZChzZWwpIHtcbiAgICAgIHJldHVybiBzZWwuYW5jaG9yTm9kZSA9PT0gc2VsLmZvY3VzTm9kZSAmJiBzZWwuYW5jaG9yT2Zmc2V0ID09PSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzZWxlY3Rpb25Jc0NvbGxhcHNlZCA9IGZ1bmN0aW9uIHNlbGVjdGlvbklzQ29sbGFwc2VkKHNlbCkge1xuICAgICAgcmV0dXJuIHNlbC5yYW5nZUNvdW50ID8gc2VsLmdldFJhbmdlQXQoc2VsLnJhbmdlQ291bnQgLSAxKS5jb2xsYXBzZWQgOiBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tUmFuZ2Uoc2VsLCByYW5nZSwgYmFja3dhcmRzKSB7XG4gICAgdmFyIGFuY2hvclByZWZpeCA9IGJhY2t3YXJkcyA/IFwiZW5kXCIgOiBcInN0YXJ0XCIsXG4gICAgICAgIGZvY3VzUHJlZml4ID0gYmFja3dhcmRzID8gXCJzdGFydFwiIDogXCJlbmRcIjtcbiAgICBzZWwuYW5jaG9yTm9kZSA9IHJhbmdlW2FuY2hvclByZWZpeCArIFwiQ29udGFpbmVyXCJdO1xuICAgIHNlbC5hbmNob3JPZmZzZXQgPSByYW5nZVthbmNob3JQcmVmaXggKyBcIk9mZnNldFwiXTtcbiAgICBzZWwuZm9jdXNOb2RlID0gcmFuZ2VbZm9jdXNQcmVmaXggKyBcIkNvbnRhaW5lclwiXTtcbiAgICBzZWwuZm9jdXNPZmZzZXQgPSByYW5nZVtmb2N1c1ByZWZpeCArIFwiT2Zmc2V0XCJdO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tTmF0aXZlU2VsZWN0aW9uKHNlbCkge1xuICAgIHZhciBuYXRpdmVTZWwgPSBzZWwubmF0aXZlU2VsZWN0aW9uO1xuICAgIHNlbC5hbmNob3JOb2RlID0gbmF0aXZlU2VsLmFuY2hvck5vZGU7XG4gICAgc2VsLmFuY2hvck9mZnNldCA9IG5hdGl2ZVNlbC5hbmNob3JPZmZzZXQ7XG4gICAgc2VsLmZvY3VzTm9kZSA9IG5hdGl2ZVNlbC5mb2N1c05vZGU7XG4gICAgc2VsLmZvY3VzT2Zmc2V0ID0gbmF0aXZlU2VsLmZvY3VzT2Zmc2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKSB7XG4gICAgc2VsLmFuY2hvck5vZGUgPSBzZWwuZm9jdXNOb2RlID0gbnVsbDtcbiAgICBzZWwuYW5jaG9yT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0ID0gMDtcbiAgICBzZWwucmFuZ2VDb3VudCA9IDA7XG4gICAgc2VsLmlzQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICBzZWwuX3Jhbmdlcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmF0aXZlUmFuZ2UocmFuZ2UpIHtcbiAgICB2YXIgbmF0aXZlUmFuZ2U7XG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRG9tUmFuZ2UpIHtcbiAgICAgIG5hdGl2ZVJhbmdlID0gcmFuZ2UuX3NlbGVjdGlvbk5hdGl2ZVJhbmdlO1xuICAgICAgaWYgKCFuYXRpdmVSYW5nZSkge1xuICAgICAgICBuYXRpdmVSYW5nZSA9IGFwaS5jcmVhdGVOYXRpdmVSYW5nZShkb20uZ2V0RG9jdW1lbnQocmFuZ2Uuc3RhcnRDb250YWluZXIpKTtcbiAgICAgICAgbmF0aXZlUmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgbmF0aXZlUmFuZ2Uuc2V0U3RhcnQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgcmFuZ2UuX3NlbGVjdGlvbk5hdGl2ZVJhbmdlID0gbmF0aXZlUmFuZ2U7XG4gICAgICAgIHJhbmdlLmF0dGFjaExpc3RlbmVyKFwiZGV0YWNoXCIsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbk5hdGl2ZVJhbmdlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyYW5nZSBpbnN0YW5jZW9mIFdyYXBwZWRSYW5nZSkge1xuICAgICAgbmF0aXZlUmFuZ2UgPSByYW5nZS5uYXRpdmVSYW5nZTtcbiAgICB9IGVsc2UgaWYgKGFwaS5mZWF0dXJlcy5pbXBsZW1lbnRzRG9tUmFuZ2UgJiYgcmFuZ2UgaW5zdGFuY2VvZiBkb20uZ2V0V2luZG93KHJhbmdlLnN0YXJ0Q29udGFpbmVyKS5SYW5nZSkge1xuICAgICAgbmF0aXZlUmFuZ2UgPSByYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZVJhbmdlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmFuZ2VDb250YWluc1NpbmdsZUVsZW1lbnQocmFuZ2VOb2Rlcykge1xuICAgIGlmICghcmFuZ2VOb2Rlcy5sZW5ndGggfHwgcmFuZ2VOb2Rlc1swXS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSByYW5nZU5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAoIWRvbS5pc0FuY2VzdG9yT2YocmFuZ2VOb2Rlc1swXSwgcmFuZ2VOb2Rlc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNpbmdsZUVsZW1lbnRGcm9tUmFuZ2UocmFuZ2UpIHtcbiAgICB2YXIgbm9kZXMgPSByYW5nZS5nZXROb2RlcygpO1xuICAgIGlmICghcmFuZ2VDb250YWluc1NpbmdsZUVsZW1lbnQobm9kZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlOiByYW5nZSBcIiArIHJhbmdlLmluc3BlY3QoKSArIFwiIGRpZCBub3QgY29uc2lzdCBvZiBhIHNpbmdsZSBlbGVtZW50XCIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNbMF07XG4gIH1cblxuICBmdW5jdGlvbiBpc1RleHRSYW5nZShyYW5nZSkge1xuICAgIHJldHVybiAhIXJhbmdlICYmIHR5cGVvZiByYW5nZS50ZXh0ICE9IFwidW5kZWZpbmVkXCI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcm9tVGV4dFJhbmdlKHNlbCwgcmFuZ2UpIHtcbiAgICAvLyBDcmVhdGUgYSBSYW5nZSBmcm9tIHRoZSBzZWxlY3RlZCBUZXh0UmFuZ2VcbiAgICB2YXIgd3JhcHBlZFJhbmdlID0gbmV3IFdyYXBwZWRSYW5nZShyYW5nZSk7XG4gICAgc2VsLl9yYW5nZXMgPSBbd3JhcHBlZFJhbmdlXTtcblxuICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHNlbCwgd3JhcHBlZFJhbmdlLCBmYWxzZSk7XG4gICAgc2VsLnJhbmdlQ291bnQgPSAxO1xuICAgIHNlbC5pc0NvbGxhcHNlZCA9IHdyYXBwZWRSYW5nZS5jb2xsYXBzZWQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDb250cm9sU2VsZWN0aW9uKHNlbCkge1xuICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlZCBzZWxlY3Rpb24gYmFzZWQgb24gd2hhdCdzIG5vdyBpbiB0aGUgbmF0aXZlIHNlbGVjdGlvblxuICAgIHNlbC5fcmFuZ2VzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHNlbC5kb2NTZWxlY3Rpb24udHlwZSA9PSBcIk5vbmVcIikge1xuICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRyb2xSYW5nZSA9IHNlbC5kb2NTZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIGlmIChpc1RleHRSYW5nZShjb250cm9sUmFuZ2UpKSB7XG4gICAgICAgIC8vIFRoaXMgY2FzZSAod2hlcmUgdGhlIHNlbGVjdGlvbiB0eXBlIGlzIFwiQ29udHJvbFwiIGFuZCBjYWxsaW5nIGNyZWF0ZVJhbmdlKCkgb24gdGhlIHNlbGVjdGlvbiByZXR1cm5zXG4gICAgICAgIC8vIGEgVGV4dFJhbmdlKSBjYW4gaGFwcGVuIGluIElFIDkuIEl0IGhhcHBlbnMsIGZvciBleGFtcGxlLCB3aGVuIGFsbCBlbGVtZW50cyBpbiB0aGUgc2VsZWN0ZWRcbiAgICAgICAgLy8gQ29udHJvbFJhbmdlIGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIENvbnRyb2xSYW5nZSBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgICAgdXBkYXRlRnJvbVRleHRSYW5nZShzZWwsIGNvbnRyb2xSYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWwucmFuZ2VDb3VudCA9IGNvbnRyb2xSYW5nZS5sZW5ndGg7XG4gICAgICAgIHZhciByYW5nZSxcbiAgICAgICAgICAgIGRvYyA9IGRvbS5nZXREb2N1bWVudChjb250cm9sUmFuZ2UuaXRlbSgwKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLnJhbmdlQ291bnQ7ICsraSkge1xuICAgICAgICAgIHJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKGRvYyk7XG4gICAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShjb250cm9sUmFuZ2UuaXRlbShpKSk7XG4gICAgICAgICAgc2VsLl9yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsLmlzQ29sbGFwc2VkID0gc2VsLnJhbmdlQ291bnQgPT0gMSAmJiBzZWwuX3Jhbmdlc1swXS5jb2xsYXBzZWQ7XG4gICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHNlbCwgc2VsLl9yYW5nZXNbc2VsLnJhbmdlQ291bnQgLSAxXSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFJhbmdlVG9Db250cm9sU2VsZWN0aW9uKHNlbCwgcmFuZ2UpIHtcbiAgICB2YXIgY29udHJvbFJhbmdlID0gc2VsLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgIHZhciByYW5nZUVsZW1lbnQgPSBnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlKHJhbmdlKTtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBDb250cm9sUmFuZ2UgY29udGFpbmluZyBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZWxlY3RlZCBDb250cm9sUmFuZ2UgcGx1cyB0aGUgZWxlbWVudFxuICAgIC8vIGNvbnRhaW5lZCBieSB0aGUgc3VwcGxpZWQgcmFuZ2VcbiAgICB2YXIgZG9jID0gZG9tLmdldERvY3VtZW50KGNvbnRyb2xSYW5nZS5pdGVtKDApKTtcbiAgICB2YXIgbmV3Q29udHJvbFJhbmdlID0gZG9tLmdldEJvZHkoZG9jKS5jcmVhdGVDb250cm9sUmFuZ2UoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29udHJvbFJhbmdlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBuZXdDb250cm9sUmFuZ2UuYWRkKGNvbnRyb2xSYW5nZS5pdGVtKGkpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NvbnRyb2xSYW5nZS5hZGQocmFuZ2VFbGVtZW50KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkUmFuZ2UoKTogRWxlbWVudCB3aXRoaW4gdGhlIHNwZWNpZmllZCBSYW5nZSBjb3VsZCBub3QgYmUgYWRkZWQgdG8gY29udHJvbCBzZWxlY3Rpb24gKGRvZXMgaXQgaGF2ZSBsYXlvdXQ/KVwiKTtcbiAgICB9XG4gICAgbmV3Q29udHJvbFJhbmdlLnNlbGVjdCgpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBiYXNlZCBvbiB3aGF0J3Mgbm93IGluIHRoZSBuYXRpdmUgc2VsZWN0aW9uXG4gICAgdXBkYXRlQ29udHJvbFNlbGVjdGlvbihzZWwpO1xuICB9XG5cbiAgdmFyIGdldFNlbGVjdGlvblJhbmdlQXQ7XG5cbiAgaWYgKHV0aWwuaXNIb3N0TWV0aG9kKHRlc3RTZWxlY3Rpb24sIFwiZ2V0UmFuZ2VBdFwiKSkge1xuICAgIGdldFNlbGVjdGlvblJhbmdlQXQgPSBmdW5jdGlvbiBnZXRTZWxlY3Rpb25SYW5nZUF0KHNlbCwgaW5kZXgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZWwuZ2V0UmFuZ2VBdChpbmRleCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzKSB7XG4gICAgZ2V0U2VsZWN0aW9uUmFuZ2VBdCA9IGZ1bmN0aW9uIGdldFNlbGVjdGlvblJhbmdlQXQoc2VsKSB7XG4gICAgICB2YXIgZG9jID0gZG9tLmdldERvY3VtZW50KHNlbC5hbmNob3JOb2RlKTtcbiAgICAgIHZhciByYW5nZSA9IGFwaS5jcmVhdGVSYW5nZShkb2MpO1xuICAgICAgcmFuZ2Uuc2V0U3RhcnQoc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgcmFuZ2Uuc2V0RW5kKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG5cbiAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVuIHRoZSBzZWxlY3Rpb24gd2FzIHNlbGVjdGVkIGJhY2t3YXJkcyAoZnJvbSB0aGUgZW5kIHRvIHRoZSBzdGFydCBpbiB0aGVcbiAgICAgIC8vIGRvY3VtZW50KVxuICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCAhPT0gdGhpcy5pc0NvbGxhcHNlZCkge1xuICAgICAgICByYW5nZS5zZXRTdGFydChzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgICAgICByYW5nZS5zZXRFbmQoc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFdyYXBwZWRTZWxlY3Rpb24oc2VsZWN0aW9uLCBkb2NTZWxlY3Rpb24sIHdpbikge1xuICAgIHRoaXMubmF0aXZlU2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgIHRoaXMuZG9jU2VsZWN0aW9uID0gZG9jU2VsZWN0aW9uO1xuICAgIHRoaXMuX3JhbmdlcyA9IFtdO1xuICAgIHRoaXMud2luID0gd2luO1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICB9XG5cbiAgYXBpLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICh3aW4pIHtcbiAgICB3aW4gPSB3aW4gfHwgd2luZG93O1xuICAgIHZhciBzZWwgPSB3aW5bd2luZG93UHJvcGVydHlOYW1lXTtcbiAgICB2YXIgbmF0aXZlU2VsID0gZ2V0U2VsZWN0aW9uKHdpbiksXG4gICAgICAgIGRvY1NlbCA9IGltcGxlbWVudHNEb2NTZWxlY3Rpb24gPyBnZXREb2NTZWxlY3Rpb24od2luKSA6IG51bGw7XG4gICAgaWYgKHNlbCkge1xuICAgICAgc2VsLm5hdGl2ZVNlbGVjdGlvbiA9IG5hdGl2ZVNlbDtcbiAgICAgIHNlbC5kb2NTZWxlY3Rpb24gPSBkb2NTZWw7XG4gICAgICBzZWwucmVmcmVzaCh3aW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWwgPSBuZXcgV3JhcHBlZFNlbGVjdGlvbihuYXRpdmVTZWwsIGRvY1NlbCwgd2luKTtcbiAgICAgIHdpblt3aW5kb3dQcm9wZXJ0eU5hbWVdID0gc2VsO1xuICAgIH1cbiAgICByZXR1cm4gc2VsO1xuICB9O1xuXG4gIGFwaS5nZXRJZnJhbWVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoaWZyYW1lRWwpIHtcbiAgICByZXR1cm4gYXBpLmdldFNlbGVjdGlvbihkb20uZ2V0SWZyYW1lV2luZG93KGlmcmFtZUVsKSk7XG4gIH07XG5cbiAgdmFyIHNlbFByb3RvID0gV3JhcHBlZFNlbGVjdGlvbi5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29udHJvbFNlbGVjdGlvbihzZWwsIHJhbmdlcykge1xuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBzZWxlY3Rpb24gYmVjb21lcyBvZiB0eXBlIFwiQ29udHJvbFwiXG4gICAgdmFyIGRvYyA9IGRvbS5nZXREb2N1bWVudChyYW5nZXNbMF0uc3RhcnRDb250YWluZXIpO1xuICAgIHZhciBjb250cm9sUmFuZ2UgPSBkb20uZ2V0Qm9keShkb2MpLmNyZWF0ZUNvbnRyb2xSYW5nZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBlbDsgaSA8IHJhbmdlQ291bnQ7ICsraSkge1xuICAgICAgZWwgPSBnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlKHJhbmdlc1tpXSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb250cm9sUmFuZ2UuYWRkKGVsKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldFJhbmdlcygpOiBFbGVtZW50IHdpdGhpbiB0aGUgb25lIG9mIHRoZSBzcGVjaWZpZWQgUmFuZ2VzIGNvdWxkIG5vdCBiZSBhZGRlZCB0byBjb250cm9sIHNlbGVjdGlvbiAoZG9lcyBpdCBoYXZlIGxheW91dD8pXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250cm9sUmFuZ2Uuc2VsZWN0KCk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZWQgc2VsZWN0aW9uIGJhc2VkIG9uIHdoYXQncyBub3cgaW4gdGhlIG5hdGl2ZSBzZWxlY3Rpb25cbiAgICB1cGRhdGVDb250cm9sU2VsZWN0aW9uKHNlbCk7XG4gIH1cblxuICAvLyBTZWxlY3RpbmcgYSByYW5nZVxuICBpZiAoIXVzZURvY3VtZW50U2VsZWN0aW9uICYmIHNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzICYmIHV0aWwuYXJlSG9zdE1ldGhvZHModGVzdFNlbGVjdGlvbiwgW1wicmVtb3ZlQWxsUmFuZ2VzXCIsIFwiYWRkUmFuZ2VcIl0pKSB7XG4gICAgc2VsUHJvdG8ucmVtb3ZlQWxsUmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5uYXRpdmVTZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB1cGRhdGVFbXB0eVNlbGVjdGlvbih0aGlzKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZFJhbmdlQmFja3dhcmRzID0gZnVuY3Rpb24gYWRkUmFuZ2VCYWNrd2FyZHMoc2VsLCByYW5nZSkge1xuICAgICAgdmFyIGRvYyA9IERvbVJhbmdlLmdldFJhbmdlRG9jdW1lbnQocmFuZ2UpO1xuICAgICAgdmFyIGVuZFJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKGRvYyk7XG4gICAgICBlbmRSYW5nZS5jb2xsYXBzZVRvUG9pbnQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgc2VsLm5hdGl2ZVNlbGVjdGlvbi5hZGRSYW5nZShnZXROYXRpdmVSYW5nZShlbmRSYW5nZSkpO1xuICAgICAgc2VsLm5hdGl2ZVNlbGVjdGlvbi5leHRlbmQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgIHNlbC5yZWZyZXNoKCk7XG4gICAgfTtcblxuICAgIGlmIChzZWxlY3Rpb25IYXNSYW5nZUNvdW50KSB7XG4gICAgICBzZWxQcm90by5hZGRSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSwgYmFja3dhcmRzKSB7XG4gICAgICAgIGlmIChpbXBsZW1lbnRzQ29udHJvbFJhbmdlICYmIGltcGxlbWVudHNEb2NTZWxlY3Rpb24gJiYgdGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgICAgYWRkUmFuZ2VUb0NvbnRyb2xTZWxlY3Rpb24odGhpcywgcmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChiYWNrd2FyZHMgJiYgc2VsZWN0aW9uSGFzRXh0ZW5kKSB7XG4gICAgICAgICAgICBhZGRSYW5nZUJhY2t3YXJkcyh0aGlzLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1JhbmdlQ291bnQ7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcykge1xuICAgICAgICAgICAgICBwcmV2aW91c1JhbmdlQ291bnQgPSB0aGlzLnJhbmdlQ291bnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICBwcmV2aW91c1JhbmdlQ291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uYXRpdmVTZWxlY3Rpb24uYWRkUmFuZ2UoZ2V0TmF0aXZlUmFuZ2UocmFuZ2UpKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBhZGRpbmcgdGhlIHJhbmdlIHdhcyBzdWNjZXNzZnVsXG4gICAgICAgICAgICB0aGlzLnJhbmdlQ291bnQgPSB0aGlzLm5hdGl2ZVNlbGVjdGlvbi5yYW5nZUNvdW50O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ID09IHByZXZpb3VzUmFuZ2VDb3VudCArIDEpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIHJhbmdlIHdhcyBhZGRlZCBzdWNjZXNzZnVsbHlcblxuICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSByYW5nZSB0aGF0IHdlIGFkZGVkIHRvIHRoZSBzZWxlY3Rpb24gaXMgcmVmbGVjdGVkIGluIHRoZSBsYXN0IHJhbmdlIGV4dHJhY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgaWYgKGFwaS5jb25maWcuY2hlY2tTZWxlY3Rpb25SYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmF0aXZlUmFuZ2UgPSBnZXRTZWxlY3Rpb25SYW5nZUF0KHRoaXMubmF0aXZlU2VsZWN0aW9uLCB0aGlzLnJhbmdlQ291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAobmF0aXZlUmFuZ2UgJiYgIURvbVJhbmdlLnJhbmdlc0VxdWFsKG5hdGl2ZVJhbmdlLCByYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEhhcHBlbnMgaW4gV2ViS2l0IHdpdGgsIGZvciBleGFtcGxlLCBhIHNlbGVjdGlvbiBwbGFjZWQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBXcmFwcGVkUmFuZ2UobmF0aXZlUmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9yYW5nZXNbdGhpcy5yYW5nZUNvdW50IC0gMV0gPSByYW5nZTtcbiAgICAgICAgICAgICAgdXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tUmFuZ2UodGhpcywgcmFuZ2UsIHNlbGVjdGlvbklzQmFja3dhcmRzKHRoaXMubmF0aXZlU2VsZWN0aW9uKSk7XG4gICAgICAgICAgICAgIHRoaXMuaXNDb2xsYXBzZWQgPSBzZWxlY3Rpb25Jc0NvbGxhcHNlZCh0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFRoZSByYW5nZSB3YXMgbm90IGFkZGVkIHN1Y2Nlc3NmdWxseS4gVGhlIHNpbXBsZXN0IHRoaW5nIGlzIHRvIHJlZnJlc2hcbiAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxQcm90by5hZGRSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSwgYmFja3dhcmRzKSB7XG4gICAgICAgIGlmIChiYWNrd2FyZHMgJiYgc2VsZWN0aW9uSGFzRXh0ZW5kKSB7XG4gICAgICAgICAgYWRkUmFuZ2VCYWNrd2FyZHModGhpcywgcmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubmF0aXZlU2VsZWN0aW9uLmFkZFJhbmdlKGdldE5hdGl2ZVJhbmdlKHJhbmdlKSk7XG4gICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgc2VsUHJvdG8uc2V0UmFuZ2VzID0gZnVuY3Rpb24gKHJhbmdlcykge1xuICAgICAgaWYgKGltcGxlbWVudHNDb250cm9sUmFuZ2UgJiYgcmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY3JlYXRlQ29udHJvbFNlbGVjdGlvbih0aGlzLCByYW5nZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIHRoaXMuYWRkUmFuZ2UocmFuZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAodXRpbC5pc0hvc3RNZXRob2QodGVzdFNlbGVjdGlvbiwgXCJlbXB0eVwiKSAmJiB1dGlsLmlzSG9zdE1ldGhvZCh0ZXN0UmFuZ2UsIFwic2VsZWN0XCIpICYmIGltcGxlbWVudHNDb250cm9sUmFuZ2UgJiYgdXNlRG9jdW1lbnRTZWxlY3Rpb24pIHtcblxuICAgIHNlbFByb3RvLnJlbW92ZUFsbFJhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEFkZGVkIHRyeS9jYXRjaCBhcyBmaXggZm9yIGlzc3VlICMyMVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5kb2NTZWxlY3Rpb24uZW1wdHkoKTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgZW1wdHkoKSBub3Qgd29ya2luZyAoaXNzdWUgIzI0KVxuICAgICAgICBpZiAodGhpcy5kb2NTZWxlY3Rpb24udHlwZSAhPSBcIk5vbmVcIikge1xuICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGZhaWx1cmUgdG8gZW1wdHkgYSBjb250cm9sIHNlbGVjdGlvbiBieSBpbnN0ZWFkIHNlbGVjdGluZyBhIFRleHRSYW5nZSBhbmQgdGhlblxuICAgICAgICAgIC8vIGNhbGxpbmcgZW1wdHkoKVxuICAgICAgICAgIHZhciBkb2M7XG4gICAgICAgICAgaWYgKHRoaXMuYW5jaG9yTm9kZSkge1xuICAgICAgICAgICAgZG9jID0gZG9tLmdldERvY3VtZW50KHRoaXMuYW5jaG9yTm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRvY1NlbGVjdGlvbi50eXBlID09IENPTlRST0wpIHtcbiAgICAgICAgICAgIHZhciBjb250cm9sUmFuZ2UgPSB0aGlzLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xSYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZG9jID0gZG9tLmdldERvY3VtZW50KGNvbnRyb2xSYW5nZS5pdGVtKDApKS5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgICB2YXIgdGV4dFJhbmdlID0gZG9jLmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICB0ZXh0UmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmRvY1NlbGVjdGlvbi5lbXB0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXgpIHt9XG4gICAgICB1cGRhdGVFbXB0eVNlbGVjdGlvbih0aGlzKTtcbiAgICB9O1xuXG4gICAgc2VsUHJvdG8uYWRkUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIGlmICh0aGlzLmRvY1NlbGVjdGlvbi50eXBlID09IENPTlRST0wpIHtcbiAgICAgICAgYWRkUmFuZ2VUb0NvbnRyb2xTZWxlY3Rpb24odGhpcywgcmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgV3JhcHBlZFJhbmdlLnJhbmdlVG9UZXh0UmFuZ2UocmFuZ2UpLnNlbGVjdCgpO1xuICAgICAgICB0aGlzLl9yYW5nZXNbMF0gPSByYW5nZTtcbiAgICAgICAgdGhpcy5yYW5nZUNvdW50ID0gMTtcbiAgICAgICAgdGhpcy5pc0NvbGxhcHNlZCA9IHRoaXMuX3Jhbmdlc1swXS5jb2xsYXBzZWQ7XG4gICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHRoaXMsIHJhbmdlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbFByb3RvLnNldFJhbmdlcyA9IGZ1bmN0aW9uIChyYW5nZXMpIHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB2YXIgcmFuZ2VDb3VudCA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICBpZiAocmFuZ2VDb3VudCA+IDEpIHtcbiAgICAgICAgY3JlYXRlQ29udHJvbFNlbGVjdGlvbih0aGlzLCByYW5nZXMpO1xuICAgICAgfSBlbHNlIGlmIChyYW5nZUNvdW50KSB7XG4gICAgICAgIHRoaXMuYWRkUmFuZ2UocmFuZ2VzWzBdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5mYWlsKFwiTm8gbWVhbnMgb2Ygc2VsZWN0aW5nIGEgUmFuZ2Ugb3IgVGV4dFJhbmdlIHdhcyBmb3VuZFwiKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzZWxQcm90by5nZXRSYW5nZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLnJhbmdlQ291bnQpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTkRFWF9TSVpFX0VSUlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jhbmdlc1tpbmRleF07XG4gICAgfVxuICB9O1xuXG4gIHZhciByZWZyZXNoU2VsZWN0aW9uO1xuXG4gIGlmICh1c2VEb2N1bWVudFNlbGVjdGlvbikge1xuICAgIHJlZnJlc2hTZWxlY3Rpb24gPSBmdW5jdGlvbiByZWZyZXNoU2VsZWN0aW9uKHNlbCkge1xuICAgICAgdmFyIHJhbmdlO1xuICAgICAgaWYgKGFwaS5pc1NlbGVjdGlvblZhbGlkKHNlbC53aW4pKSB7XG4gICAgICAgIHJhbmdlID0gc2VsLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBkb20uZ2V0Qm9keShzZWwud2luLmRvY3VtZW50KS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWwuZG9jU2VsZWN0aW9uLnR5cGUgPT0gQ09OVFJPTCkge1xuICAgICAgICB1cGRhdGVDb250cm9sU2VsZWN0aW9uKHNlbCk7XG4gICAgICB9IGVsc2UgaWYgKGlzVGV4dFJhbmdlKHJhbmdlKSkge1xuICAgICAgICB1cGRhdGVGcm9tVGV4dFJhbmdlKHNlbCwgcmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHV0aWwuaXNIb3N0TWV0aG9kKHRlc3RTZWxlY3Rpb24sIFwiZ2V0UmFuZ2VBdFwiKSAmJiB0eXBlb2YgdGVzdFNlbGVjdGlvbi5yYW5nZUNvdW50ID09IFwibnVtYmVyXCIpIHtcbiAgICByZWZyZXNoU2VsZWN0aW9uID0gZnVuY3Rpb24gcmVmcmVzaFNlbGVjdGlvbihzZWwpIHtcbiAgICAgIGlmIChpbXBsZW1lbnRzQ29udHJvbFJhbmdlICYmIGltcGxlbWVudHNEb2NTZWxlY3Rpb24gJiYgc2VsLmRvY1NlbGVjdGlvbi50eXBlID09IENPTlRST0wpIHtcbiAgICAgICAgdXBkYXRlQ29udHJvbFNlbGVjdGlvbihzZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsLl9yYW5nZXMubGVuZ3RoID0gc2VsLnJhbmdlQ291bnQgPSBzZWwubmF0aXZlU2VsZWN0aW9uLnJhbmdlQ291bnQ7XG4gICAgICAgIGlmIChzZWwucmFuZ2VDb3VudCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWwucmFuZ2VDb3VudDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBzZWwuX3Jhbmdlc1tpXSA9IG5ldyBhcGkuV3JhcHBlZFJhbmdlKHNlbC5uYXRpdmVTZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHNlbCwgc2VsLl9yYW5nZXNbc2VsLnJhbmdlQ291bnQgLSAxXSwgc2VsZWN0aW9uSXNCYWNrd2FyZHMoc2VsLm5hdGl2ZVNlbGVjdGlvbikpO1xuICAgICAgICAgIHNlbC5pc0NvbGxhcHNlZCA9IHNlbGVjdGlvbklzQ29sbGFwc2VkKHNlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAoc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMgJiYgX3R5cGVvZih0ZXN0U2VsZWN0aW9uLmlzQ29sbGFwc2VkKSA9PSBCT09MRUFOICYmIF90eXBlb2YodGVzdFJhbmdlLmNvbGxhcHNlZCkgPT0gQk9PTEVBTiAmJiBhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlKSB7XG4gICAgcmVmcmVzaFNlbGVjdGlvbiA9IGZ1bmN0aW9uIHJlZnJlc2hTZWxlY3Rpb24oc2VsKSB7XG4gICAgICB2YXIgcmFuZ2UsXG4gICAgICAgICAgbmF0aXZlU2VsID0gc2VsLm5hdGl2ZVNlbGVjdGlvbjtcbiAgICAgIGlmIChuYXRpdmVTZWwuYW5jaG9yTm9kZSkge1xuICAgICAgICByYW5nZSA9IGdldFNlbGVjdGlvblJhbmdlQXQobmF0aXZlU2VsLCAwKTtcbiAgICAgICAgc2VsLl9yYW5nZXMgPSBbcmFuZ2VdO1xuICAgICAgICBzZWwucmFuZ2VDb3VudCA9IDE7XG4gICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbU5hdGl2ZVNlbGVjdGlvbihzZWwpO1xuICAgICAgICBzZWwuaXNDb2xsYXBzZWQgPSBzZWxlY3Rpb25Jc0NvbGxhcHNlZChzZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5mYWlsKFwiTm8gbWVhbnMgb2Ygb2J0YWluaW5nIGEgUmFuZ2Ugb3IgVGV4dFJhbmdlIGZyb20gdGhlIHVzZXIncyBzZWxlY3Rpb24gd2FzIGZvdW5kXCIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHNlbFByb3RvLnJlZnJlc2ggPSBmdW5jdGlvbiAoY2hlY2tGb3JDaGFuZ2VzKSB7XG4gICAgdmFyIG9sZFJhbmdlcyA9IGNoZWNrRm9yQ2hhbmdlcyA/IHRoaXMuX3Jhbmdlcy5zbGljZSgwKSA6IG51bGw7XG4gICAgcmVmcmVzaFNlbGVjdGlvbih0aGlzKTtcbiAgICBpZiAoY2hlY2tGb3JDaGFuZ2VzKSB7XG4gICAgICB2YXIgaSA9IG9sZFJhbmdlcy5sZW5ndGg7XG4gICAgICBpZiAoaSAhPSB0aGlzLl9yYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKCFEb21SYW5nZS5yYW5nZXNFcXVhbChvbGRSYW5nZXNbaV0sIHRoaXMuX3Jhbmdlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZW1vdmFsIG9mIGEgc2luZ2xlIHJhbmdlXG4gIHZhciByZW1vdmVSYW5nZU1hbnVhbGx5ID0gZnVuY3Rpb24gcmVtb3ZlUmFuZ2VNYW51YWxseShzZWwsIHJhbmdlKSB7XG4gICAgdmFyIHJhbmdlcyA9IHNlbC5nZXRBbGxSYW5nZXMoKSxcbiAgICAgICAgcmVtb3ZlZCA9IGZhbHNlO1xuICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAocmVtb3ZlZCB8fCByYW5nZSAhPT0gcmFuZ2VzW2ldKSB7XG4gICAgICAgIHNlbC5hZGRSYW5nZShyYW5nZXNbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBkcmFmdCBXSEFUV0cgUmFuZ2Ugc3BlYywgdGhlIHNhbWUgcmFuZ2UgbWF5IGJlIGFkZGVkIHRvIHRoZSBzZWxlY3Rpb24gbXVsdGlwbGVcbiAgICAgICAgLy8gdGltZXMuIHJlbW92ZVJhbmdlIHNob3VsZCBvbmx5IHJlbW92ZSB0aGUgZmlyc3QgaW5zdGFuY2UsIHNvIHRoZSBmb2xsb3dpbmcgZW5zdXJlcyBvbmx5IHRoZSBmaXJzdFxuICAgICAgICAvLyBpbnN0YW5jZSBpcyByZW1vdmVkXG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNlbC5yYW5nZUNvdW50KSB7XG4gICAgICB1cGRhdGVFbXB0eVNlbGVjdGlvbihzZWwpO1xuICAgIH1cbiAgfTtcblxuICBpZiAoaW1wbGVtZW50c0NvbnRyb2xSYW5nZSkge1xuICAgIHNlbFByb3RvLnJlbW92ZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICBpZiAodGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgIHZhciBjb250cm9sUmFuZ2UgPSB0aGlzLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICB2YXIgcmFuZ2VFbGVtZW50ID0gZ2V0U2luZ2xlRWxlbWVudEZyb21SYW5nZShyYW5nZSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IENvbnRyb2xSYW5nZSBjb250YWluaW5nIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNlbGVjdGVkIENvbnRyb2xSYW5nZSBtaW51cyB0aGVcbiAgICAgICAgLy8gZWxlbWVudCBjb250YWluZWQgYnkgdGhlIHN1cHBsaWVkIHJhbmdlXG4gICAgICAgIHZhciBkb2MgPSBkb20uZ2V0RG9jdW1lbnQoY29udHJvbFJhbmdlLml0ZW0oMCkpO1xuICAgICAgICB2YXIgbmV3Q29udHJvbFJhbmdlID0gZG9tLmdldEJvZHkoZG9jKS5jcmVhdGVDb250cm9sUmFuZ2UoKTtcbiAgICAgICAgdmFyIGVsLFxuICAgICAgICAgICAgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29udHJvbFJhbmdlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgZWwgPSBjb250cm9sUmFuZ2UuaXRlbShpKTtcbiAgICAgICAgICBpZiAoZWwgIT09IHJhbmdlRWxlbWVudCB8fCByZW1vdmVkKSB7XG4gICAgICAgICAgICBuZXdDb250cm9sUmFuZ2UuYWRkKGNvbnRyb2xSYW5nZS5pdGVtKGkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld0NvbnRyb2xSYW5nZS5zZWxlY3QoKTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZWQgc2VsZWN0aW9uIGJhc2VkIG9uIHdoYXQncyBub3cgaW4gdGhlIG5hdGl2ZSBzZWxlY3Rpb25cbiAgICAgICAgdXBkYXRlQ29udHJvbFNlbGVjdGlvbih0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZVJhbmdlTWFudWFsbHkodGhpcywgcmFuZ2UpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc2VsUHJvdG8ucmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHJlbW92ZVJhbmdlTWFudWFsbHkodGhpcywgcmFuZ2UpO1xuICAgIH07XG4gIH1cblxuICAvLyBEZXRlY3RpbmcgaWYgYSBzZWxlY3Rpb24gaXMgYmFja3dhcmRzXG4gIHZhciBzZWxlY3Rpb25Jc0JhY2t3YXJkcztcbiAgaWYgKCF1c2VEb2N1bWVudFNlbGVjdGlvbiAmJiBzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cyAmJiBhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlKSB7XG4gICAgc2VsZWN0aW9uSXNCYWNrd2FyZHMgPSBmdW5jdGlvbiBzZWxlY3Rpb25Jc0JhY2t3YXJkcyhzZWwpIHtcbiAgICAgIHZhciBiYWNrd2FyZHMgPSBmYWxzZTtcbiAgICAgIGlmIChzZWwuYW5jaG9yTm9kZSkge1xuICAgICAgICBiYWNrd2FyZHMgPSBkb20uY29tcGFyZVBvaW50cyhzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCwgc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KSA9PSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhY2t3YXJkcztcbiAgICB9O1xuXG4gICAgc2VsUHJvdG8uaXNCYWNrd2FyZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uSXNCYWNrd2FyZHModGhpcyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzZWxlY3Rpb25Jc0JhY2t3YXJkcyA9IHNlbFByb3RvLmlzQmFja3dhcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBTZWxlY3Rpb24gdGV4dFxuICAvLyBUaGlzIGlzIGNvbmZvcm1hbnQgdG8gdGhlIG5ldyBXSEFUV0cgRE9NIFJhbmdlIGRyYWZ0IHNwZWMgYnV0IGRpZmZlcnMgZnJvbSBXZWJLaXQgYW5kIE1vemlsbGEncyBpbXBsZW1lbnRhdGlvblxuICBzZWxQcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciByYW5nZVRleHRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucmFuZ2VDb3VudDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICByYW5nZVRleHRzW2ldID0gXCJcIiArIHRoaXMuX3Jhbmdlc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlVGV4dHMuam9pbihcIlwiKTtcbiAgfTtcblxuICBmdW5jdGlvbiBhc3NlcnROb2RlSW5TYW1lRG9jdW1lbnQoc2VsLCBub2RlKSB7XG4gICAgaWYgKHNlbC5hbmNob3JOb2RlICYmIGRvbS5nZXREb2N1bWVudChzZWwuYW5jaG9yTm9kZSkgIT09IGRvbS5nZXREb2N1bWVudChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIldST05HX0RPQ1VNRU5UX0VSUlwiKTtcbiAgICB9XG4gIH1cblxuICAvLyBObyBjdXJyZW50IGJyb3dzZXJzIGNvbmZvcm0gZnVsbHkgdG8gdGhlIEhUTUwgNSBkcmFmdCBzcGVjIGZvciB0aGlzIG1ldGhvZCwgc28gUmFuZ3kncyBvd24gbWV0aG9kIGlzIGFsd2F5cyB1c2VkXG4gIHNlbFByb3RvLmNvbGxhcHNlID0gZnVuY3Rpb24gKG5vZGUsIG9mZnNldCkge1xuICAgIGFzc2VydE5vZGVJblNhbWVEb2N1bWVudCh0aGlzLCBub2RlKTtcbiAgICB2YXIgcmFuZ2UgPSBhcGkuY3JlYXRlUmFuZ2UoZG9tLmdldERvY3VtZW50KG5vZGUpKTtcbiAgICByYW5nZS5jb2xsYXBzZVRvUG9pbnQobm9kZSwgb2Zmc2V0KTtcbiAgICB0aGlzLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHRoaXMuYWRkUmFuZ2UocmFuZ2UpO1xuICAgIHRoaXMuaXNDb2xsYXBzZWQgPSB0cnVlO1xuICB9O1xuXG4gIHNlbFByb3RvLmNvbGxhcHNlVG9TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yYW5nZUNvdW50KSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZXNbMF07XG4gICAgICB0aGlzLmNvbGxhcHNlKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTlZBTElEX1NUQVRFX0VSUlwiKTtcbiAgICB9XG4gIH07XG5cbiAgc2VsUHJvdG8uY29sbGFwc2VUb0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yYW5nZUNvdW50KSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZXNbdGhpcy5yYW5nZUNvdW50IC0gMV07XG4gICAgICB0aGlzLmNvbGxhcHNlKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOVkFMSURfU1RBVEVfRVJSXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGUgSFRNTCA1IHNwZWMgaXMgdmVyeSBzcGVjaWZpYyBvbiBob3cgc2VsZWN0QWxsQ2hpbGRyZW4gc2hvdWxkIGJlIGltcGxlbWVudGVkIHNvIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXNcbiAgLy8gbmV2ZXIgdXNlZCBieSBSYW5neS5cbiAgc2VsUHJvdG8uc2VsZWN0QWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGFzc2VydE5vZGVJblNhbWVEb2N1bWVudCh0aGlzLCBub2RlKTtcbiAgICB2YXIgcmFuZ2UgPSBhcGkuY3JlYXRlUmFuZ2UoZG9tLmdldERvY3VtZW50KG5vZGUpKTtcbiAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG4gICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB0aGlzLmFkZFJhbmdlKHJhbmdlKTtcbiAgfTtcblxuICBzZWxQcm90by5kZWxldGVGcm9tRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2VwY2lhbCBiZWhhdmlvdXIgcmVxdWlyZWQgZm9yIENvbnRyb2wgc2VsZWN0aW9uc1xuICAgIGlmIChpbXBsZW1lbnRzQ29udHJvbFJhbmdlICYmIGltcGxlbWVudHNEb2NTZWxlY3Rpb24gJiYgdGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICB2YXIgY29udHJvbFJhbmdlID0gdGhpcy5kb2NTZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHZhciBlbGVtZW50O1xuICAgICAgd2hpbGUgKGNvbnRyb2xSYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgZWxlbWVudCA9IGNvbnRyb2xSYW5nZS5pdGVtKDApO1xuICAgICAgICBjb250cm9sUmFuZ2UucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmFuZ2VDb3VudCkge1xuICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuZ2V0QWxsUmFuZ2VzKCk7XG4gICAgICB0aGlzLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICByYW5nZXNbaV0uZGVsZXRlQ29udGVudHMoKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBIVE1MNSBzcGVjIHNheXMgbm90aGluZyBhYm91dCB3aGF0IHRoZSBzZWxlY3Rpb24gc2hvdWxkIGNvbnRhaW4gYWZ0ZXIgY2FsbGluZyBkZWxldGVDb250ZW50cyBvbiBlYWNoXG4gICAgICAvLyByYW5nZS4gRmlyZWZveCBtb3ZlcyB0aGUgc2VsZWN0aW9uIHRvIHdoZXJlIHRoZSBmaW5hbCBzZWxlY3RlZCByYW5nZSB3YXMsIHNvIHdlIGVtdWxhdGUgdGhhdFxuICAgICAgdGhpcy5hZGRSYW5nZShyYW5nZXNbbGVuIC0gMV0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGUgZm9sbG93aW5nIGFyZSBub24tc3RhbmRhcmQgZXh0ZW5zaW9uc1xuICBzZWxQcm90by5nZXRBbGxSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jhbmdlcy5zbGljZSgwKTtcbiAgfTtcblxuICBzZWxQcm90by5zZXRTaW5nbGVSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIHRoaXMuc2V0UmFuZ2VzKFtyYW5nZV0pO1xuICB9O1xuXG4gIHNlbFByb3RvLmNvbnRhaW5zTm9kZSA9IGZ1bmN0aW9uIChub2RlLCBhbGxvd1BhcnRpYWwpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAodGhpcy5fcmFuZ2VzW2ldLmNvbnRhaW5zTm9kZShub2RlLCBhbGxvd1BhcnRpYWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgc2VsUHJvdG8udG9IdG1sID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBodG1sID0gXCJcIjtcbiAgICBpZiAodGhpcy5yYW5nZUNvdW50KSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gRG9tUmFuZ2UuZ2V0UmFuZ2VEb2N1bWVudCh0aGlzLl9yYW5nZXNbMF0pLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yYW5nZXNbaV0uY2xvbmVDb250ZW50cygpKTtcbiAgICAgIH1cbiAgICAgIGh0bWwgPSBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcblxuICBmdW5jdGlvbiBpbnNwZWN0KHNlbCkge1xuICAgIHZhciByYW5nZUluc3BlY3RzID0gW107XG4gICAgdmFyIGFuY2hvciA9IG5ldyBEb21Qb3NpdGlvbihzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XG4gICAgdmFyIGZvY3VzID0gbmV3IERvbVBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgdmFyIG5hbWUgPSB0eXBlb2Ygc2VsLmdldE5hbWUgPT0gXCJmdW5jdGlvblwiID8gc2VsLmdldE5hbWUoKSA6IFwiU2VsZWN0aW9uXCI7XG5cbiAgICBpZiAodHlwZW9mIHNlbC5yYW5nZUNvdW50ICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWwucmFuZ2VDb3VudDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHJhbmdlSW5zcGVjdHNbaV0gPSBEb21SYW5nZS5pbnNwZWN0KHNlbC5nZXRSYW5nZUF0KGkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiW1wiICsgbmFtZSArIFwiKFJhbmdlczogXCIgKyByYW5nZUluc3BlY3RzLmpvaW4oXCIsIFwiKSArIFwiKShhbmNob3I6IFwiICsgYW5jaG9yLmluc3BlY3QoKSArIFwiLCBmb2N1czogXCIgKyBmb2N1cy5pbnNwZWN0KCkgKyBcIl1cIjtcbiAgfVxuXG4gIHNlbFByb3RvLmdldE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiV3JhcHBlZFNlbGVjdGlvblwiO1xuICB9O1xuXG4gIHNlbFByb3RvLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGluc3BlY3QodGhpcyk7XG4gIH07XG5cbiAgc2VsUHJvdG8uZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMud2luW3dpbmRvd1Byb3BlcnR5TmFtZV0gPSBudWxsO1xuICAgIHRoaXMud2luID0gdGhpcy5hbmNob3JOb2RlID0gdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICB9O1xuXG4gIFdyYXBwZWRTZWxlY3Rpb24uaW5zcGVjdCA9IGluc3BlY3Q7XG5cbiAgYXBpLlNlbGVjdGlvbiA9IFdyYXBwZWRTZWxlY3Rpb247XG5cbiAgYXBpLnNlbGVjdGlvblByb3RvdHlwZSA9IHNlbFByb3RvO1xuXG4gIGFwaS5hZGRDcmVhdGVNaXNzaW5nTmF0aXZlQXBpTGlzdGVuZXIoZnVuY3Rpb24gKHdpbikge1xuICAgIGlmICh0eXBlb2Ygd2luLmdldFNlbGVjdGlvbiA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW4uZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXBpLmdldFNlbGVjdGlvbih0aGlzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHdpbiA9IG51bGw7XG4gIH0pO1xufSk7XG4vKlxuXHRCYXNlLmpzLCB2ZXJzaW9uIDEuMWFcblx0Q29weXJpZ2h0IDIwMDYtMjAxMCwgRGVhbiBFZHdhcmRzXG5cdExpY2Vuc2U6IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4qL1xuXG52YXIgQmFzZSA9IGZ1bmN0aW9uIEJhc2UoKSB7XG4gIC8vIGR1bW15XG59O1xuXG5CYXNlLmV4dGVuZCA9IGZ1bmN0aW9uIChfaW5zdGFuY2UsIF9zdGF0aWMpIHtcbiAgLy8gc3ViY2xhc3NcbiAgdmFyIGV4dGVuZCA9IEJhc2UucHJvdG90eXBlLmV4dGVuZDtcblxuICAvLyBidWlsZCB0aGUgcHJvdG90eXBlXG4gIEJhc2UuX3Byb3RvdHlwaW5nID0gdHJ1ZTtcbiAgdmFyIHByb3RvID0gbmV3IHRoaXMoKTtcbiAgZXh0ZW5kLmNhbGwocHJvdG8sIF9pbnN0YW5jZSk7XG4gIHByb3RvLmJhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY2FsbCB0aGlzIG1ldGhvZCBmcm9tIGFueSBvdGhlciBtZXRob2QgdG8gaW52b2tlIHRoYXQgbWV0aG9kJ3MgYW5jZXN0b3JcbiAgfTtcbiAgZGVsZXRlIEJhc2UuX3Byb3RvdHlwaW5nO1xuXG4gIC8vIGNyZWF0ZSB0aGUgd3JhcHBlciBmb3IgdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gIC8vdmFyIGNvbnN0cnVjdG9yID0gcHJvdG8uY29uc3RydWN0b3IudmFsdWVPZigpOyAvLy1kZWFuXG4gIHZhciBjb25zdHJ1Y3RvciA9IHByb3RvLmNvbnN0cnVjdG9yO1xuICB2YXIga2xhc3MgPSBwcm90by5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJhc2UuX3Byb3RvdHlwaW5nKSB7XG4gICAgICBpZiAodGhpcy5fY29uc3RydWN0aW5nIHx8IHRoaXMuY29uc3RydWN0b3IgPT0ga2xhc3MpIHtcbiAgICAgICAgLy8gaW5zdGFudGlhdGlvblxuICAgICAgICB0aGlzLl9jb25zdHJ1Y3RpbmcgPSB0cnVlO1xuICAgICAgICBjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBkZWxldGUgdGhpcy5fY29uc3RydWN0aW5nO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gIT0gbnVsbCkge1xuICAgICAgICAvLyBjYXN0aW5nXG4gICAgICAgIHJldHVybiAoYXJndW1lbnRzWzBdLmV4dGVuZCB8fCBleHRlbmQpLmNhbGwoYXJndW1lbnRzWzBdLCBwcm90byk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGJ1aWxkIHRoZSBjbGFzcyBpbnRlcmZhY2VcbiAga2xhc3MuYW5jZXN0b3IgPSB0aGlzO1xuICBrbGFzcy5leHRlbmQgPSB0aGlzLmV4dGVuZDtcbiAga2xhc3MuZm9yRWFjaCA9IHRoaXMuZm9yRWFjaDtcbiAga2xhc3MuaW1wbGVtZW50ID0gdGhpcy5pbXBsZW1lbnQ7XG4gIGtsYXNzLnByb3RvdHlwZSA9IHByb3RvO1xuICBrbGFzcy50b1N0cmluZyA9IHRoaXMudG9TdHJpbmc7XG4gIGtsYXNzLnZhbHVlT2YgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIC8vcmV0dXJuICh0eXBlID09IFwib2JqZWN0XCIpID8ga2xhc3MgOiBjb25zdHJ1Y3RvcjsgLy8tZGVhblxuICAgIHJldHVybiB0eXBlID09IFwib2JqZWN0XCIgPyBrbGFzcyA6IGNvbnN0cnVjdG9yLnZhbHVlT2YoKTtcbiAgfTtcbiAgZXh0ZW5kLmNhbGwoa2xhc3MsIF9zdGF0aWMpO1xuICAvLyBjbGFzcyBpbml0aWFsaXNhdGlvblxuICBpZiAodHlwZW9mIGtsYXNzLmluaXQgPT0gXCJmdW5jdGlvblwiKSBrbGFzcy5pbml0KCk7XG4gIHJldHVybiBrbGFzcztcbn07XG5cbkJhc2UucHJvdG90eXBlID0ge1xuICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChzb3VyY2UsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBleHRlbmRpbmcgd2l0aCBhIG5hbWUvdmFsdWUgcGFpclxuICAgICAgdmFyIGFuY2VzdG9yID0gdGhpc1tzb3VyY2VdO1xuICAgICAgaWYgKGFuY2VzdG9yICYmIHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIgJiYgKCAvLyBvdmVycmlkaW5nIGEgbWV0aG9kP1xuICAgICAgLy8gdGhlIHZhbHVlT2YoKSBjb21wYXJpc29uIGlzIHRvIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgICFhbmNlc3Rvci52YWx1ZU9mIHx8IGFuY2VzdG9yLnZhbHVlT2YoKSAhPSB2YWx1ZS52YWx1ZU9mKCkpICYmIC9cXGJiYXNlXFxiLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAvLyBnZXQgdGhlIHVuZGVybHlpbmcgbWV0aG9kXG4gICAgICAgIHZhciBtZXRob2QgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIHZhbHVlID0gZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5iYXNlIHx8IEJhc2UucHJvdG90eXBlLmJhc2U7XG4gICAgICAgICAgdGhpcy5iYXNlID0gYW5jZXN0b3I7XG4gICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdGhpcy5iYXNlID0gcHJldmlvdXM7XG4gICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBwb2ludCB0byB0aGUgdW5kZXJseWluZyBtZXRob2RcbiAgICAgICAgdmFsdWUudmFsdWVPZiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGUgPT0gXCJvYmplY3RcIiA/IHZhbHVlIDogbWV0aG9kO1xuICAgICAgICB9O1xuICAgICAgICB2YWx1ZS50b1N0cmluZyA9IEJhc2UudG9TdHJpbmc7XG4gICAgICB9XG4gICAgICB0aGlzW3NvdXJjZV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZSkge1xuICAgICAgLy8gZXh0ZW5kaW5nIHdpdGggYW4gb2JqZWN0IGxpdGVyYWxcbiAgICAgIHZhciBleHRlbmQgPSBCYXNlLnByb3RvdHlwZS5leHRlbmQ7XG4gICAgICAvLyBpZiB0aGlzIG9iamVjdCBoYXMgYSBjdXN0b21pc2VkIGV4dGVuZCBtZXRob2QgdGhlbiB1c2UgaXRcbiAgICAgIGlmICghQmFzZS5fcHJvdG90eXBpbmcgJiYgdHlwZW9mIHRoaXMgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGV4dGVuZCA9IHRoaXMuZXh0ZW5kIHx8IGV4dGVuZDtcbiAgICAgIH1cbiAgICAgIHZhciBwcm90byA9IHsgdG9Tb3VyY2U6IG51bGwgfTtcbiAgICAgIC8vIGRvIHRoZSBcInRvU3RyaW5nXCIgYW5kIG90aGVyIG1ldGhvZHMgbWFudWFsbHlcbiAgICAgIHZhciBoaWRkZW4gPSBbXCJjb25zdHJ1Y3RvclwiLCBcInRvU3RyaW5nXCIsIFwidmFsdWVPZlwiXTtcbiAgICAgIC8vIGlmIHdlIGFyZSBwcm90b3R5cGluZyB0aGVuIGluY2x1ZGUgdGhlIGNvbnN0cnVjdG9yXG4gICAgICB2YXIgaSA9IEJhc2UuX3Byb3RvdHlwaW5nID8gMCA6IDE7XG4gICAgICB3aGlsZSAoa2V5ID0gaGlkZGVuW2krK10pIHtcbiAgICAgICAgaWYgKHNvdXJjZVtrZXldICE9IHByb3RvW2tleV0pIHtcbiAgICAgICAgICBleHRlbmQuY2FsbCh0aGlzLCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29weSBlYWNoIG9mIHRoZSBzb3VyY2Ugb2JqZWN0J3MgcHJvcGVydGllcyB0byB0aGlzIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoIXByb3RvW2tleV0pIGV4dGVuZC5jYWxsKHRoaXMsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuLy8gaW5pdGlhbGlzZVxuQmFzZSA9IEJhc2UuZXh0ZW5kKHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZXh0ZW5kKGFyZ3VtZW50c1swXSk7XG4gIH1cbn0sIHtcbiAgYW5jZXN0b3I6IE9iamVjdCxcbiAgdmVyc2lvbjogXCIxLjFcIixcblxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKG9iamVjdCwgYmxvY2ssIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAodGhpcy5wcm90b3R5cGVba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJsb2NrLmNhbGwoY29udGV4dCwgb2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaW1wbGVtZW50OiBmdW5jdGlvbiBpbXBsZW1lbnQoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBpZiBpdCdzIGEgZnVuY3Rpb24sIGNhbGwgaXRcbiAgICAgICAgYXJndW1lbnRzW2ldKHRoaXMucHJvdG90eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFkZCB0aGUgaW50ZXJmYWNlIHVzaW5nIHRoZSBleHRlbmQgbWV0aG9kXG4gICAgICAgIHRoaXMucHJvdG90eXBlLmV4dGVuZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlT2YoKSk7XG4gIH1cbn0pOyAvKipcbiAgICAqIERldGVjdCBicm93c2VyIHN1cHBvcnQgZm9yIHNwZWNpZmljIGZlYXR1cmVzXG4gICAgKi9cbnd5c2lodG1sNS5icm93c2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblxuICAvLyBCcm93c2VyIHNuaWZmaW5nIGlzIHVuZm9ydHVuYXRlbHkgbmVlZGVkIHNpbmNlIHNvbWUgYmVoYXZpb3JzIGFyZSBpbXBvc3NpYmxlIHRvIGZlYXR1cmUgZGV0ZWN0XG4gIGlzSUUgPSB1c2VyQWdlbnQuaW5kZXhPZihcIk1TSUVcIikgIT09IC0xICYmIHVzZXJBZ2VudC5pbmRleE9mKFwiT3BlcmFcIikgPT09IC0xLFxuICAgICAgaXNHZWNrbyA9IHVzZXJBZ2VudC5pbmRleE9mKFwiR2Vja29cIikgIT09IC0xICYmIHVzZXJBZ2VudC5pbmRleE9mKFwiS0hUTUxcIikgPT09IC0xLFxuICAgICAgaXNXZWJLaXQgPSB1c2VyQWdlbnQuaW5kZXhPZihcIkFwcGxlV2ViS2l0L1wiKSAhPT0gLTEsXG4gICAgICBpc0Nocm9tZSA9IHVzZXJBZ2VudC5pbmRleE9mKFwiQ2hyb21lL1wiKSAhPT0gLTEsXG4gICAgICBpc09wZXJhID0gdXNlckFnZW50LmluZGV4T2YoXCJPcGVyYS9cIikgIT09IC0xO1xuXG4gIGZ1bmN0aW9uIGlvc1ZlcnNpb24odXNlckFnZW50KSB7XG4gICAgcmV0dXJuICgvaXBhZHxpcGhvbmV8aXBvZC8udGVzdCh1c2VyQWdlbnQpICYmIHVzZXJBZ2VudC5tYXRjaCgvIG9zIChcXGQrKS4rPyBsaWtlIG1hYyBvcyB4LykgfHwgWywgMF0pWzFdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBTdGF0aWMgdmFyaWFibGUgbmVlZGVkLCBwdWJsaWNseSBhY2Nlc3NpYmxlLCB0byBiZSBhYmxlIG92ZXJyaWRlIGl0IGluIHVuaXQgdGVzdHNcbiAgICBVU0VSX0FHRU5UOiB1c2VyQWdlbnQsXG5cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlIGJyb3dzZXJzIHRoYXQgYXJlIG5vdCBjYXBhYmxlIG9mIGRpc3BsYXlpbmcgYW5kIGhhbmRsaW5nXG4gICAgICogY29udGVudEVkaXRhYmxlIGFzIGRlc2lyZWQ6XG4gICAgICogICAgLSBpUGhvbmUsIGlQYWQgKHRlc3RlZCBpT1MgNC4yLjIpIGFuZCBBbmRyb2lkICh0ZXN0ZWQgMi4yKSByZWZ1c2UgdG8gbWFrZSBjb250ZW50RWRpdGFibGVzIGZvY3VzYWJsZVxuICAgICAqICAgIC0gSUUgPCA4IGNyZWF0ZSBpbnZhbGlkIG1hcmt1cCBhbmQgY3Jhc2ggcmFuZG9tbHkgZnJvbSB0aW1lIHRvIHRpbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3VwcG9ydGVkOiBmdW5jdGlvbiBzdXBwb3J0ZWQoKSB7XG4gICAgICB2YXIgdXNlckFnZW50ID0gdGhpcy5VU0VSX0FHRU5ULnRvTG93ZXJDYXNlKCksXG5cbiAgICAgIC8vIEVzc2VudGlhbCBmb3IgbWFraW5nIGh0bWwgZWxlbWVudHMgZWRpdGFibGVcbiAgICAgIGhhc0NvbnRlbnRFZGl0YWJsZVN1cHBvcnQgPSBcImNvbnRlbnRFZGl0YWJsZVwiIGluIHRlc3RFbGVtZW50LFxuXG4gICAgICAvLyBGb2xsb3dpbmcgbWV0aG9kcyBhcmUgbmVlZGVkIGluIG9yZGVyIHRvIGludGVyYWN0IHdpdGggdGhlIGNvbnRlbnRFZGl0YWJsZSBhcmVhXG4gICAgICBoYXNFZGl0aW5nQXBpU3VwcG9ydCA9IGRvY3VtZW50LmV4ZWNDb21tYW5kICYmIGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCAmJiBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZSxcblxuICAgICAgLy8gZG9jdW1lbnQgc2VsZWN0b3IgYXBpcyBhcmUgb25seSBzdXBwb3J0ZWQgYnkgSUUgOCssIFNhZmFyaSA0KywgQ2hyb21lIGFuZCBGaXJlZm94IDMuNStcbiAgICAgIGhhc1F1ZXJ5U2VsZWN0b3JTdXBwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsLFxuXG4gICAgICAvLyBjb250ZW50RWRpdGFibGUgaXMgdW51c2FibGUgaW4gbW9iaWxlIGJyb3dzZXJzICh0ZXN0ZWQgaU9TIDQuMi4yLCBBbmRyb2lkIDIuMiwgT3BlcmEgTW9iaWxlLCBXZWJPUyAzLjA1KVxuICAgICAgaXNJbmNvbXBhdGlibGVNb2JpbGVCcm93c2VyID0gdGhpcy5pc0lvcygpICYmIGlvc1ZlcnNpb24odXNlckFnZW50KSA8IDUgfHwgdXNlckFnZW50LmluZGV4T2YoXCJvcGVyYSBtb2JpXCIpICE9PSAtMSB8fCB1c2VyQWdlbnQuaW5kZXhPZihcImhwd29zL1wiKSAhPT0gLTE7XG5cbiAgICAgIHJldHVybiBoYXNDb250ZW50RWRpdGFibGVTdXBwb3J0ICYmIGhhc0VkaXRpbmdBcGlTdXBwb3J0ICYmIGhhc1F1ZXJ5U2VsZWN0b3JTdXBwb3J0ICYmICFpc0luY29tcGF0aWJsZU1vYmlsZUJyb3dzZXI7XG4gICAgfSxcblxuICAgIGlzVG91Y2hEZXZpY2U6IGZ1bmN0aW9uIGlzVG91Y2hEZXZpY2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdXBwb3J0c0V2ZW50KFwidG91Y2htb3ZlXCIpO1xuICAgIH0sXG5cbiAgICBpc0lvczogZnVuY3Rpb24gaXNJb3MoKSB7XG4gICAgICB2YXIgdXNlckFnZW50ID0gdGhpcy5VU0VSX0FHRU5ULnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gdXNlckFnZW50LmluZGV4T2YoXCJ3ZWJraXRcIikgIT09IC0xICYmIHVzZXJBZ2VudC5pbmRleE9mKFwibW9iaWxlXCIpICE9PSAtMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyBzYW5kYm94ZWQgaWZyYW1lc1xuICAgICAqIEN1cnJlbnRseSBvbmx5IElFIDYrIG9mZmVycyBzdWNoIGZlYXR1cmUgPGlmcmFtZSBzZWN1cml0eT1cInJlc3RyaWN0ZWRcIj5cbiAgICAgKlxuICAgICAqIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNDYyMih2PXZzLjg1KS5hc3B4XG4gICAgICogaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWUvYXJjaGl2ZS8yMDA4LzAxLzE4L3VzaW5nLWZyYW1lcy1tb3JlLXNlY3VyZWx5LmFzcHhcbiAgICAgKlxuICAgICAqIEhUTUw1IHNhbmRib3hlZCBpZnJhbWVzIGFyZSBzdGlsbCBidWdneSBhbmQgdGhlaXIgRE9NIGlzIG5vdCByZWFjaGFibGUgZnJvbSB0aGUgb3V0c2lkZSAoZXhjZXB0IHdoZW4gdXNpbmcgcG9zdE1lc3NhZ2UpXG4gICAgICovXG4gICAgc3VwcG9ydHNTYW5kYm94ZWRJZnJhbWVzOiBmdW5jdGlvbiBzdXBwb3J0c1NhbmRib3hlZElmcmFtZXMoKSB7XG4gICAgICByZXR1cm4gaXNJRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSUU2KzcgdGhyb3cgYSBtaXhlZCBjb250ZW50IHdhcm5pbmcgd2hlbiB0aGUgc3JjIG9mIGFuIGlmcmFtZVxuICAgICAqIGlzIGVtcHR5L3Vuc2V0IG9yIGFib3V0OmJsYW5rXG4gICAgICogd2luZG93LnF1ZXJ5U2VsZWN0b3IgaXMgaW1wbGVtZW50ZWQgYXMgb2YgSUU4XG4gICAgICovXG4gICAgdGhyb3dzTWl4ZWRDb250ZW50V2FybmluZ1doZW5JZnJhbWVTcmNJc0VtcHR5OiBmdW5jdGlvbiB0aHJvd3NNaXhlZENvbnRlbnRXYXJuaW5nV2hlbklmcmFtZVNyY0lzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gIShcInF1ZXJ5U2VsZWN0b3JcIiBpbiBkb2N1bWVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGNhcmV0IGlzIGNvcnJlY3RseSBkaXNwbGF5ZWQgaW4gY29udGVudEVkaXRhYmxlIGVsZW1lbnRzXG4gICAgICogRmlyZWZveCBzb21ldGltZXMgc2hvd3MgYSBodWdlIGNhcmV0IGluIHRoZSBiZWdpbm5pbmcgYWZ0ZXIgZm9jdXNpbmdcbiAgICAgKi9cbiAgICBkaXNwbGF5c0NhcmV0SW5FbXB0eUNvbnRlbnRFZGl0YWJsZUNvcnJlY3RseTogZnVuY3Rpb24gZGlzcGxheXNDYXJldEluRW1wdHlDb250ZW50RWRpdGFibGVDb3JyZWN0bHkoKSB7XG4gICAgICByZXR1cm4gIWlzR2Vja287XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9wZXJhIGFuZCBJRSBhcmUgdGhlIG9ubHkgYnJvd3NlcnMgd2hvIG9mZmVyIHRoZSBjc3MgdmFsdWVcbiAgICAgKiBpbiB0aGUgb3JpZ2luYWwgdW5pdCwgdGh4IHRvIHRoZSBjdXJyZW50U3R5bGUgb2JqZWN0XG4gICAgICogQWxsIG90aGVyIGJyb3dzZXJzIHByb3ZpZGUgdGhlIGNvbXB1dGVkIHN0eWxlIGluIHB4IHZpYSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZVxuICAgICAqL1xuICAgIGhhc0N1cnJlbnRTdHlsZVByb3BlcnR5OiBmdW5jdGlvbiBoYXNDdXJyZW50U3R5bGVQcm9wZXJ0eSgpIHtcbiAgICAgIHJldHVybiBcImN1cnJlbnRTdHlsZVwiIGluIHRlc3RFbGVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBicm93c2VyIGluc2VydHMgYSA8YnI+IHdoZW4gcHJlc3NpbmcgZW50ZXIgaW4gYSBjb250ZW50RWRpdGFibGUgZWxlbWVudFxuICAgICAqL1xuICAgIGluc2VydHNMaW5lQnJlYWtzT25SZXR1cm46IGZ1bmN0aW9uIGluc2VydHNMaW5lQnJlYWtzT25SZXR1cm4oKSB7XG4gICAgICByZXR1cm4gaXNHZWNrbztcbiAgICB9LFxuXG4gICAgc3VwcG9ydHNQbGFjZWhvbGRlckF0dHJpYnV0ZU9uOiBmdW5jdGlvbiBzdXBwb3J0c1BsYWNlaG9sZGVyQXR0cmlidXRlT24oZWxlbWVudCkge1xuICAgICAgcmV0dXJuIFwicGxhY2Vob2xkZXJcIiBpbiBlbGVtZW50O1xuICAgIH0sXG5cbiAgICBzdXBwb3J0c0V2ZW50OiBmdW5jdGlvbiBzdXBwb3J0c0V2ZW50KGV2ZW50TmFtZSkge1xuICAgICAgcmV0dXJuIFwib25cIiArIGV2ZW50TmFtZSBpbiB0ZXN0RWxlbWVudCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRlc3RFbGVtZW50LnNldEF0dHJpYnV0ZShcIm9uXCIgKyBldmVudE5hbWUsIFwicmV0dXJuO1wiKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0ZXN0RWxlbWVudFtcIm9uXCIgKyBldmVudE5hbWVdID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB9KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9wZXJhIGRvZXNuJ3QgY29ycmVjdGx5IGZpcmUgZm9jdXMvYmx1ciBldmVudHMgd2hlbiBjbGlja2luZyBpbi0gYW5kIG91dHNpZGUgb2YgaWZyYW1lXG4gICAgICovXG4gICAgc3VwcG9ydHNFdmVudHNJbklmcmFtZUNvcnJlY3RseTogZnVuY3Rpb24gc3VwcG9ydHNFdmVudHNJbklmcmFtZUNvcnJlY3RseSgpIHtcbiAgICAgIHJldHVybiAhaXNPcGVyYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hyb21lICYgU2FmYXJpIG9ubHkgZmlyZSB0aGUgb25kcm9wL29uZHJhZ2VuZC8uLi4gZXZlbnRzIHdoZW4gdGhlIG9uZHJhZ292ZXIgZXZlbnQgaXMgY2FuY2VsbGVkXG4gICAgICogd2l0aCBldmVudC5wcmV2ZW50RGVmYXVsdFxuICAgICAqIEZpcmVmb3ggMy42IGZpcmVzIHRob3NlIGV2ZW50cyBhbnl3YXksIGJ1dCB0aGUgbW96aWxsYSBkb2Mgc2F5cyB0aGF0IHRoZSBkcmFnb3Zlci9kcmFnZW50ZXIgZXZlbnQgbmVlZHNcbiAgICAgKiB0byBiZSBjYW5jZWxsZWRcbiAgICAgKi9cbiAgICBmaXJlc09uRHJvcE9ubHlXaGVuT25EcmFnT3ZlcklzQ2FuY2VsbGVkOiBmdW5jdGlvbiBmaXJlc09uRHJvcE9ubHlXaGVuT25EcmFnT3ZlcklzQ2FuY2VsbGVkKCkge1xuICAgICAgcmV0dXJuIGlzV2ViS2l0IHx8IGlzR2Vja287XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGV2ZW50LmRhdGFUcmFuc2ZlciBwcm9wZXJ0eSBpbiBhIHByb3BlciB3YXlcbiAgICAgKi9cbiAgICBzdXBwb3J0c0RhdGFUcmFuc2ZlcjogZnVuY3Rpb24gc3VwcG9ydHNEYXRhVHJhbnNmZXIoKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBkYXRhVHJhbnNmZXIgaW4gYSBzYWZlIHdheSwgaXQgZG9lc24ndCBzdHJpcCBzY3JpcHQgY29kZSBpbiB0aGUgaHRtbCBwYXlsb2FkIChsaWtlIENocm9tZSBkb2VzKVxuICAgICAgICByZXR1cm4gaXNXZWJLaXQgJiYgKHdpbmRvdy5DbGlwYm9hcmQgfHwgd2luZG93LkRhdGFUcmFuc2ZlcikucHJvdG90eXBlLmdldERhdGE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXZlcnl0aGluZyBiZWxvdyBJRTkgZG9lc24ndCBrbm93IGhvdyB0byB0cmVhdCBIVE1MNSB0YWdzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgZG9jdW1lbnQgb2JqZWN0IG9uIHdoaWNoIHRvIGNoZWNrIEhUTUw1IHN1cHBvcnRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNIVE1MNVRhZ3MoZG9jdW1lbnQpO1xuICAgICAqL1xuICAgIHN1cHBvcnRzSFRNTDVUYWdzOiBmdW5jdGlvbiBzdXBwb3J0c0hUTUw1VGFncyhjb250ZXh0KSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICBodG1sNSA9IFwiPGFydGljbGU+Zm9vPC9hcnRpY2xlPlwiO1xuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBodG1sNTtcbiAgICAgIHJldHVybiBlbGVtZW50LmlubmVySFRNTC50b0xvd2VyQ2FzZSgpID09PSBodG1sNTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSBkb2N1bWVudCBzdXBwb3J0cyBhIGNlcnRhaW4gcXVlcnlDb21tYW5kXG4gICAgICogSW4gcGFydGljdWxhciwgT3BlcmEgbmVlZHMgYSByZWZlcmVuY2UgdG8gYSBkb2N1bWVudCB0aGF0IGhhcyBhIGNvbnRlbnRFZGl0YWJsZSBpbiBpdCdzIGRvbSB0cmVlXG4gICAgICogaW4gb2RlciB0byByZXBvcnQgY29ycmVjdCByZXN1bHRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZG9jIERvY3VtZW50IG9iamVjdCBvbiB3aGljaCB0byBjaGVjayBmb3IgYSBxdWVyeSBjb21tYW5kXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbW1hbmQgVGhlIHF1ZXJ5IGNvbW1hbmQgdG8gY2hlY2sgZm9yXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNDb21tYW5kKGRvY3VtZW50LCBcImJvbGRcIik7XG4gICAgICovXG4gICAgc3VwcG9ydHNDb21tYW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBGb2xsb3dpbmcgY29tbWFuZHMgYXJlIHN1cHBvcnRlZCBidXQgY29udGFpbiBidWdzIGluIHNvbWUgYnJvd3NlcnNcbiAgICAgIHZhciBidWdneUNvbW1hbmRzID0ge1xuICAgICAgICAvLyBmb3JtYXRCbG9jayBmYWlscyB3aXRoIHNvbWUgdGFncyAoZWcuIDxibG9ja3F1b3RlPilcbiAgICAgICAgXCJmb3JtYXRCbG9ja1wiOiBpc0lFLFxuICAgICAgICAvLyBXaGVuIGluc2VydGluZyB1bm9yZGVyZWQgb3Igb3JkZXJlZCBsaXN0cyBpbiBGaXJlZm94LCBDaHJvbWUgb3IgU2FmYXJpLCB0aGUgY3VycmVudCBzZWxlY3Rpb24gb3IgbGluZSBnZXRzXG4gICAgICAgIC8vIGNvbnZlcnRlZCBpbnRvIGEgbGlzdCAoPHVsPjxsaT4uLi48L2xpPjwvdWw+LCA8b2w+PGxpPi4uLjwvbGk+PC9vbD4pXG4gICAgICAgIC8vIElFIGFuZCBPcGVyYSBhY3QgYSBiaXQgZGlmZmVyZW50IGhlcmUgYXMgdGhleSBjb252ZXJ0IHRoZSBlbnRpcmUgY29udGVudCBvZiB0aGUgY3VycmVudCBibG9jayBlbGVtZW50IGludG8gYSBsaXN0XG4gICAgICAgIFwiaW5zZXJ0VW5vcmRlcmVkTGlzdFwiOiBpc0lFIHx8IGlzT3BlcmEgfHwgaXNXZWJLaXQsXG4gICAgICAgIFwiaW5zZXJ0T3JkZXJlZExpc3RcIjogaXNJRSB8fCBpc09wZXJhIHx8IGlzV2ViS2l0XG4gICAgICB9O1xuXG4gICAgICAvLyBGaXJlZm94IHRocm93cyBlcnJvcnMgZm9yIHF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCwgc28gd2UgaGF2ZSB0byBidWlsZCB1cCBvdXIgb3duIG9iamVjdCBvZiBzdXBwb3J0ZWQgY29tbWFuZHNcbiAgICAgIHZhciBzdXBwb3J0ZWQgPSB7XG4gICAgICAgIFwiaW5zZXJ0SFRNTFwiOiBpc0dlY2tvXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRvYywgY29tbWFuZCkge1xuICAgICAgICB2YXIgaXNCdWdneSA9IGJ1Z2d5Q29tbWFuZHNbY29tbWFuZF07XG4gICAgICAgIGlmICghaXNCdWdneSkge1xuICAgICAgICAgIC8vIEZpcmVmb3ggdGhyb3dzIGVycm9ycyB3aGVuIGludm9raW5nIHF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCBvciBxdWVyeUNvbW1hbmRFbmFibGVkXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBkb2MucXVlcnlDb21tYW5kU3VwcG9ydGVkKGNvbW1hbmQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUxKSB7fVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBkb2MucXVlcnlDb21tYW5kRW5hYmxlZChjb21tYW5kKTtcbiAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgcmV0dXJuICEhc3VwcG9ydGVkW2NvbW1hbmRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH0oKSxcblxuICAgIC8qKlxuICAgICAqIElFOiBVUkxzIHN0YXJ0aW5nIHdpdGg6XG4gICAgICogICAgd3d3LiwgaHR0cDovLywgaHR0cHM6Ly8sIGZ0cDovLywgZ29waGVyOi8vLCBtYWlsdG86LCBuZXc6LCBzbmV3czosIHRlbG5ldDosIHdhc2lzOiwgZmlsZTovLyxcbiAgICAgKiAgICBubnRwOi8vLCBuZXdzcmM6LCBsZGFwOi8vLCBsZGFwczovLywgb3V0bG9vazosIG1pYzovLyBhbmQgdXJsOlxuICAgICAqIHdpbGwgYXV0b21hdGljYWxseSBiZSBhdXRvLWxpbmtlZCB3aGVuIGVpdGhlciB0aGUgdXNlciBpbnNlcnRzIHRoZW0gdmlhIGNvcHkmcGFzdGUgb3IgcHJlc3NlcyB0aGVcbiAgICAgKiBzcGFjZSBiYXIgd2hlbiB0aGUgY2FyZXQgaXMgZGlyZWN0bHkgYWZ0ZXIgc3VjaCBhbiB1cmwuXG4gICAgICogVGhpcyBiZWhhdmlvciBjYW5ub3QgZWFzaWx5IGJlIGF2b2lkZWQgaW4gSUUgPCA5IHNpbmNlIHRoZSBsb2dpYyBpcyBoYXJkY29kZWQgaW4gdGhlIG1zaHRtbC5kbGxcbiAgICAgKiAocmVsYXRlZCBibG9nIHBvc3Qgb24gbXNkblxuICAgICAqIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAwOS8wOS8xNy9wcmV2ZW50LWF1dG9tYXRpYy1oeXBlcmxpbmtpbmctaW4tY29udGVudGVkaXRhYmxlLWh0bWwuYXNweCkuXG4gICAgICovXG4gICAgZG9lc0F1dG9MaW5raW5nSW5Db250ZW50RWRpdGFibGU6IGZ1bmN0aW9uIGRvZXNBdXRvTGlua2luZ0luQ29udGVudEVkaXRhYmxlKCkge1xuICAgICAgcmV0dXJuIGlzSUU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFzIHN0YXRlZCBhYm92ZSwgSUUgYXV0byBsaW5rcyB1cmxzIHR5cGVkIGludG8gY29udGVudEVkaXRhYmxlIGVsZW1lbnRzXG4gICAgICogU2luY2UgSUU5IGl0J3MgcG9zc2libGUgdG8gcHJldmVudCB0aGlzIGJlaGF2aW9yXG4gICAgICovXG4gICAgY2FuRGlzYWJsZUF1dG9MaW5raW5nOiBmdW5jdGlvbiBjYW5EaXNhYmxlQXV0b0xpbmtpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdXBwb3J0c0NvbW1hbmQoZG9jdW1lbnQsIFwiQXV0b1VybERldGVjdFwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSUUgbGVhdmVzIGFuIGVtcHR5IHBhcmFncmFwaCBpbiB0aGUgY29udGVudEVkaXRhYmxlIGVsZW1lbnQgYWZ0ZXIgY2xlYXJpbmcgaXRcbiAgICAgKiBDaHJvbWUvU2FmYXJpIHNvbWV0aW1lcyBhbiBlbXB0eSA8ZGl2PlxuICAgICAqL1xuICAgIGNsZWFyc0NvbnRlbnRFZGl0YWJsZUNvcnJlY3RseTogZnVuY3Rpb24gY2xlYXJzQ29udGVudEVkaXRhYmxlQ29ycmVjdGx5KCkge1xuICAgICAgcmV0dXJuIGlzR2Vja28gfHwgaXNPcGVyYSB8fCBpc1dlYktpdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSUUgZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgZ2V0QXR0cmlidXRlXG4gICAgICovXG4gICAgc3VwcG9ydHNHZXRBdHRyaWJ1dGVDb3JyZWN0bHk6IGZ1bmN0aW9uIHN1cHBvcnRzR2V0QXR0cmlidXRlQ29ycmVjdGx5KCkge1xuICAgICAgdmFyIHRkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuICAgICAgcmV0dXJuIHRkLmdldEF0dHJpYnV0ZShcInJvd3NwYW5cIikgIT0gXCIxXCI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2xpY2tpbmcgb24gaW1hZ2VzIGluIElFLCBPcGVyYSBhbmQgRmlyZWZveCwgdGhleSBhcmUgc2VsZWN0ZWQsIHdoaWNoIG1ha2VzIGl0IGVhc3kgdG8gaW50ZXJhY3Qgd2l0aCB0aGVtLlxuICAgICAqIENocm9tZSBhbmQgU2FmYXJpIGJvdGggZG9uJ3Qgc3VwcG9ydCB0aGlzXG4gICAgICovXG4gICAgY2FuU2VsZWN0SW1hZ2VzSW5Db250ZW50RWRpdGFibGU6IGZ1bmN0aW9uIGNhblNlbGVjdEltYWdlc0luQ29udGVudEVkaXRhYmxlKCkge1xuICAgICAgcmV0dXJuIGlzR2Vja28gfHwgaXNJRSB8fCBpc09wZXJhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBjYXJldCBpcyBpbiBhbiBlbXB0eSBsaXN0ICg8dWw+PGxpPnw8L2xpPjwvdWw+KSB3aGljaCBpcyB0aGUgZmlyc3QgY2hpbGQgaW4gYW4gY29udGVudEVkaXRhYmxlIGNvbnRhaW5lclxuICAgICAqIHByZXNzaW5nIGJhY2tzcGFjZSBkb2Vzbid0IHJlbW92ZSB0aGUgZW50aXJlIGxpc3QgYXMgZG9uZSBpbiBvdGhlciBicm93c2Vyc1xuICAgICAqL1xuICAgIGNsZWFyc0xpc3RzSW5Db250ZW50RWRpdGFibGVDb3JyZWN0bHk6IGZ1bmN0aW9uIGNsZWFyc0xpc3RzSW5Db250ZW50RWRpdGFibGVDb3JyZWN0bHkoKSB7XG4gICAgICByZXR1cm4gaXNHZWNrbyB8fCBpc0lFIHx8IGlzV2ViS2l0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbGwgYnJvd3NlcnMgZXhjZXB0IFNhZmFyaSBhbmQgQ2hyb21lIGF1dG9tYXRpY2FsbHkgc2Nyb2xsIHRoZSByYW5nZS9jYXJldCBwb3NpdGlvbiBpbnRvIHZpZXdcbiAgICAgKi9cbiAgICBhdXRvU2Nyb2xsc1RvQ2FyZXQ6IGZ1bmN0aW9uIGF1dG9TY3JvbGxzVG9DYXJldCgpIHtcbiAgICAgIHJldHVybiAhaXNXZWJLaXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGJyb3dzZXIgYXV0b21hdGljYWxseSBjbG9zZXMgdGFncyB0aGF0IGRvbid0IG5lZWQgdG8gYmUgb3BlbmVkXG4gICAgICovXG4gICAgYXV0b0Nsb3Nlc1VuY2xvc2VkVGFnczogZnVuY3Rpb24gYXV0b0Nsb3Nlc1VuY2xvc2VkVGFncygpIHtcbiAgICAgIHZhciBjbG9uZWRUZXN0RWxlbWVudCA9IHRlc3RFbGVtZW50LmNsb25lTm9kZShmYWxzZSksXG4gICAgICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICAgICAgaW5uZXJIVE1MO1xuXG4gICAgICBjbG9uZWRUZXN0RWxlbWVudC5pbm5lckhUTUwgPSBcIjxwPjxkaXY+PC9kaXY+XCI7XG4gICAgICBpbm5lckhUTUwgPSBjbG9uZWRUZXN0RWxlbWVudC5pbm5lckhUTUwudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVyblZhbHVlID0gaW5uZXJIVE1MID09PSBcIjxwPjwvcD48ZGl2PjwvZGl2PlwiIHx8IGlubmVySFRNTCA9PT0gXCI8cD48ZGl2PjwvZGl2PjwvcD5cIjtcblxuICAgICAgLy8gQ2FjaGUgcmVzdWx0IGJ5IG92ZXJ3cml0aW5nIGN1cnJlbnQgZnVuY3Rpb25cbiAgICAgIHRoaXMuYXV0b0Nsb3Nlc1VuY2xvc2VkVGFncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBuYXRpdmUgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSB3aGljaCByZXR1cm5zIGxpdmUgTm9kZUxpc3RzXG4gICAgICovXG4gICAgc3VwcG9ydHNOYXRpdmVHZXRFbGVtZW50c0J5Q2xhc3NOYW1lOiBmdW5jdGlvbiBzdXBwb3J0c05hdGl2ZUdldEVsZW1lbnRzQnlDbGFzc05hbWUoKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXMgb2Ygbm93ICgxOS4wNC4yMDExKSBvbmx5IHN1cHBvcnRlZCBieSBGaXJlZm94IDQgYW5kIENocm9tZVxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vU2VsZWN0aW9uL21vZGlmeVxuICAgICAqL1xuICAgIHN1cHBvcnRzU2VsZWN0aW9uTW9kaWZ5OiBmdW5jdGlvbiBzdXBwb3J0c1NlbGVjdGlvbk1vZGlmeSgpIHtcbiAgICAgIHJldHVybiBcImdldFNlbGVjdGlvblwiIGluIHdpbmRvdyAmJiBcIm1vZGlmeVwiIGluIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgY2xhc3NMaXN0IG9iamVjdCBmb3IgZmFzdCBjbGFzc05hbWUgbWFuaXB1bGF0aW9uXG4gICAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9lbGVtZW50LmNsYXNzTGlzdFxuICAgICAqL1xuICAgIHN1cHBvcnRzQ2xhc3NMaXN0OiBmdW5jdGlvbiBzdXBwb3J0c0NsYXNzTGlzdCgpIHtcbiAgICAgIHJldHVybiBcImNsYXNzTGlzdFwiIGluIHRlc3RFbGVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPcGVyYSBuZWVkcyBhIHdoaXRlIHNwYWNlIGFmdGVyIGEgPGJyPiBpbiBvcmRlciB0byBwb3NpdGlvbiB0aGUgY2FyZXQgY29ycmVjdGx5XG4gICAgICovXG4gICAgbmVlZHNTcGFjZUFmdGVyTGluZUJyZWFrOiBmdW5jdGlvbiBuZWVkc1NwYWNlQWZ0ZXJMaW5lQnJlYWsoKSB7XG4gICAgICByZXR1cm4gaXNPcGVyYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgc3BlZWNoIGFwaSBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgICAqIFNlZSBodHRwOi8vbWlrZXB1bHR6LmNvbS8yMDExLzAzL2FjY2Vzc2luZy1nb29nbGUtc3BlZWNoLWFwaS1jaHJvbWUtMTEvXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgKiAgICBpZiAod3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNTcGVlY2hBcGlPbihpbnB1dCkpIHtcbiAgICAgKiAgICAgIC8vIC4uLlxuICAgICAqICAgIH1cbiAgICAgKi9cbiAgICBzdXBwb3J0c1NwZWVjaEFwaU9uOiBmdW5jdGlvbiBzdXBwb3J0c1NwZWVjaEFwaU9uKGlucHV0KSB7XG4gICAgICB2YXIgY2hyb21lVmVyc2lvbiA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLykgfHwgWywgMF07XG4gICAgICByZXR1cm4gY2hyb21lVmVyc2lvblsxXSA+PSAxMSAmJiAoXCJvbndlYmtpdHNwZWVjaGNoYW5nZVwiIGluIGlucHV0IHx8IFwic3BlZWNoXCIgaW4gaW5wdXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJRTkgY3Jhc2hlcyB3aGVuIHNldHRpbmcgYSBnZXR0ZXIgdmlhIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBvbiBYTUxIdHRwUmVxdWVzdCBvciBYRG9tYWluUmVxdWVzdFxuICAgICAqIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9pZS9mZWVkYmFjay9kZXRhaWxzLzY1MDExMlxuICAgICAqIG9yIHRyeSB0aGUgUE9DIGh0dHA6Ly90aWZmdGlmZi5kZS9pZTlfY3Jhc2gvXG4gICAgICovXG4gICAgY3Jhc2hlc1doZW5EZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gY3Jhc2hlc1doZW5EZWZpbmVQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIGlzSUUgJiYgKHByb3BlcnR5ID09PSBcIlhNTEh0dHBSZXF1ZXN0XCIgfHwgcHJvcGVydHkgPT09IFwiWERvbWFpblJlcXVlc3RcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElFIGlzIHRoZSBvbmx5IGJyb3dzZXIgd2hvIGZpcmVzIHRoZSBcImZvY3VzXCIgZXZlbnQgbm90IGltbWVkaWF0ZWx5IHdoZW4gLmZvY3VzKCkgaXMgY2FsbGVkIG9uIGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBkb2VzQXN5bmNGb2N1czogZnVuY3Rpb24gZG9lc0FzeW5jRm9jdXMoKSB7XG4gICAgICByZXR1cm4gaXNJRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW4gSUUgaXQncyBpbXBzc2libGUgZm9yIHRoZSB1c2VyIGFuZCBmb3IgdGhlIHNlbGVjdGlvbiBsaWJyYXJ5IHRvIHNldCB0aGUgY2FyZXQgYWZ0ZXIgYW4gPGltZz4gd2hlbiBpdCdzIHRoZSBsYXN0Q2hpbGQgaW4gdGhlIGRvY3VtZW50XG4gICAgICovXG4gICAgaGFzUHJvYmxlbXNTZXR0aW5nQ2FyZXRBZnRlckltZzogZnVuY3Rpb24gaGFzUHJvYmxlbXNTZXR0aW5nQ2FyZXRBZnRlckltZygpIHtcbiAgICAgIHJldHVybiBpc0lFO1xuICAgIH0sXG5cbiAgICBoYXNVbmRvSW5Db250ZXh0TWVudTogZnVuY3Rpb24gaGFzVW5kb0luQ29udGV4dE1lbnUoKSB7XG4gICAgICByZXR1cm4gaXNHZWNrbyB8fCBpc0Nocm9tZSB8fCBpc09wZXJhO1xuICAgIH1cbiAgfTtcbn0oKTt3eXNpaHRtbDUubGFuZy5hcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIGEgZ2l2ZW4gb2JqZWN0IGV4aXN0cyBpbiBhbiBhcnJheVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB3eXNpaHRtbDUubGFuZy5hcnJheShbMSwgMl0pLmNvbnRhaW5zKDEpO1xuICAgICAqICAgIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBjb250YWluczogZnVuY3Rpb24gY29udGFpbnMobmVlZGxlKSB7XG4gICAgICBpZiAoYXJyLmluZGV4T2YpIHtcbiAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhcnJbaV0gPT09IG5lZWRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3Vic3RyYWN0IG9uZSBhcnJheSBmcm9tIGFub3RoZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1LmxhbmcuYXJyYXkoWzEsIDIsIDMsIDRdKS53aXRob3V0KFszLCA0XSk7XG4gICAgICogICAgLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgd2l0aG91dDogZnVuY3Rpb24gd2l0aG91dChhcnJheVRvU3Vic3RyYWN0KSB7XG4gICAgICBhcnJheVRvU3Vic3RyYWN0ID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoYXJyYXlUb1N1YnN0cmFjdCk7XG4gICAgICB2YXIgbmV3QXJyID0gW10sXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFhcnJheVRvU3Vic3RyYWN0LmNvbnRhaW5zKGFycltpXSkpIHtcbiAgICAgICAgICBuZXdBcnIucHVzaChhcnJbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3QXJyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBjbGVhbiBuYXRpdmUgYXJyYXlcbiAgICAgKiBcbiAgICAgKiBGb2xsb3dpbmcgd2lsbCBjb252ZXJ0IGEgTGl2ZSBOb2RlTGlzdCB0byBhIHByb3BlciBBcnJheVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgdmFyIGNoaWxkTm9kZXMgPSB3eXNpaHRtbDUubGFuZy5hcnJheShkb2N1bWVudC5ib2R5LmNoaWxkTm9kZXMpLmdldCgpO1xuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgbmV3QXJyYXkgPSBbXTtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3QXJyYXkucHVzaChhcnJbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgIH1cbiAgfTtcbn07d3lzaWh0bWw1LmxhbmcuRGlzcGF0Y2hlciA9IEJhc2UuZXh0ZW5kKFxuLyoqIEBzY29wZSB3eXNpaHRtbDUubGFuZy5EaWFsb2cucHJvdG90eXBlICove1xuICBvYnNlcnZlOiBmdW5jdGlvbiBvYnNlcnZlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMgfHwge307XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gfHwgW107XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9uOiBmdW5jdGlvbiBvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vYnNlcnZlLmFwcGx5KHRoaXMsIHd5c2lodG1sNS5sYW5nLmFycmF5KGFyZ3VtZW50cykuZ2V0KCkpO1xuICB9LFxuXG4gIGZpcmU6IGZ1bmN0aW9uIGZpcmUoZXZlbnROYW1lLCBwYXlsb2FkKSB7XG4gICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cyB8fCB7fTtcbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdIHx8IFtdLFxuICAgICAgICBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYW5kbGVyc1tpXS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzdG9wT2JzZXJ2aW5nOiBmdW5jdGlvbiBzdG9wT2JzZXJ2aW5nKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMgfHwge307XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBoYW5kbGVycyxcbiAgICAgICAgbmV3SGFuZGxlcnM7XG4gICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgaGFuZGxlcnMgPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdIHx8IFtdLCBuZXdIYW5kbGVycyA9IFtdO1xuICAgICAgZm9yICg7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGFuZGxlcnNbaV0gIT09IGhhbmRsZXIgJiYgaGFuZGxlcikge1xuICAgICAgICAgIG5ld0hhbmRsZXJzLnB1c2goaGFuZGxlcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gbmV3SGFuZGxlcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFuIHVwIGFsbCBldmVudHNcbiAgICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTt3eXNpaHRtbDUubGFuZy5vYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB3eXNpaHRtbDUubGFuZy5vYmplY3QoeyBmb286IDEsIGJhcjogMSB9KS5tZXJnZSh7IGJhcjogMiwgYmF6OiAzIH0pLmdldCgpO1xuICAgICAqICAgIC8vID0+IHsgZm9vOiAxLCBiYXI6IDIsIGJhejogMyB9XG4gICAgICovXG4gICAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKG90aGVyT2JqKSB7XG4gICAgICBmb3IgKHZhciBpIGluIG90aGVyT2JqKSB7XG4gICAgICAgIG9ialtpXSA9IG90aGVyT2JqW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB3eXNpaHRtbDUubGFuZy5vYmplY3QoeyBmb286IDEgfSkuY2xvbmUoKTtcbiAgICAgKiAgICAvLyA9PiB7IGZvbzogMSB9XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgdmFyIG5ld09iaiA9IHt9LFxuICAgICAgICAgIGk7XG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgIG5ld09ialtpXSA9IG9ialtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1Lmxhbmcub2JqZWN0KFtdKS5pc0FycmF5KCk7XG4gICAgICogICAgLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGlzQXJyYXk6IGZ1bmN0aW9uIGlzQXJyYXkoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICB9XG4gIH07XG59OyhmdW5jdGlvbiAoKSB7XG4gIHZhciBXSElURV9TUEFDRV9TVEFSVCA9IC9eXFxzKy8sXG4gICAgICBXSElURV9TUEFDRV9FTkQgPSAvXFxzKyQvO1xuICB3eXNpaHRtbDUubGFuZy5zdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqICAgIHd5c2lodG1sNS5sYW5nLnN0cmluZyhcIiAgIGZvbyAgIFwiKS50cmltKCk7XG4gICAgICAgKiAgICAvLyA9PiBcImZvb1wiXG4gICAgICAgKi9cbiAgICAgIHRyaW06IGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShXSElURV9TUEFDRV9TVEFSVCwgXCJcIikucmVwbGFjZShXSElURV9TUEFDRV9FTkQsIFwiXCIpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogICAgd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKFwiSGVsbG8gI3tuYW1lfVwiKS5pbnRlcnBvbGF0ZSh7IG5hbWU6IFwiQ2hyaXN0b3BoZXJcIiB9KTtcbiAgICAgICAqICAgIC8vID0+IFwiSGVsbG8gQ2hyaXN0b3BoZXJcIlxuICAgICAgICovXG4gICAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGUodmFycykge1xuICAgICAgICBmb3IgKHZhciBpIGluIHZhcnMpIHtcbiAgICAgICAgICBzdHIgPSB0aGlzLnJlcGxhY2UoXCIje1wiICsgaSArIFwifVwiKS5ieSh2YXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogICAgd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKFwiSGVsbG8gVG9tXCIpLnJlcGxhY2UoXCJUb21cIikud2l0aChcIkhhbnNcIik7XG4gICAgICAgKiAgICAvLyA9PiBcIkhlbGxvIEhhbnNcIlxuICAgICAgICovXG4gICAgICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJ5OiBmdW5jdGlvbiBieShyZXBsYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnNwbGl0KHNlYXJjaCkuam9pbihyZXBsYWNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn0pKCk7IC8qKlxuICAgICAgKiBGaW5kIHVybHMgaW4gZGVzY2VuZGFudCB0ZXh0IG5vZGVzIG9mIGFuIGVsZW1lbnQgYW5kIGF1dG8tbGlua3MgdGhlbVxuICAgICAgKiBJbnNwaXJlZCBieSBodHRwOi8vamFtZXMucGFkb2xzZXkuY29tL2phdmFzY3JpcHQvZmluZC1hbmQtcmVwbGFjZS10ZXh0LXdpdGgtamF2YXNjcmlwdC9cbiAgICAgICpcbiAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IENvbnRhaW5lciBlbGVtZW50IGluIHdoaWNoIHRvIHNlYXJjaCBmb3IgdXJsc1xuICAgICAgKlxuICAgICAgKiBAZXhhbXBsZVxuICAgICAgKiAgICA8ZGl2IGlkPVwidGV4dC1jb250YWluZXJcIj5QbGVhc2UgY2xpY2sgaGVyZTogd3d3Lmdvb2dsZS5jb208L2Rpdj5cbiAgICAgICogICAgPHNjcmlwdD53eXNpaHRtbDUuZG9tLmF1dG9MaW5rKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGV4dC1jb250YWluZXJcIikpOzwvc2NyaXB0PlxuICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciAvKipcbiAgICAgICAqIERvbid0IGF1dG8tbGluayB1cmxzIHRoYXQgYXJlIGNvbnRhaW5lZCBpbiB0aGUgZm9sbG93aW5nIGVsZW1lbnRzOlxuICAgICAgICovXG4gIElHTk9SRV9VUkxTX0lOID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoW1wiQ09ERVwiLCBcIlBSRVwiLCBcIkFcIiwgXCJTQ1JJUFRcIiwgXCJIRUFEXCIsIFwiVElUTEVcIiwgXCJTVFlMRVwiXSksXG5cbiAgLyoqXG4gICAqIHJldmlzaW9uIDE6XG4gICAqICAgIC8oXFxTK1xcLnsxfVteXFxzXFwsXFwuXFwhXSspL2dcbiAgICpcbiAgICogcmV2aXNpb24gMjpcbiAgICogICAgLyhcXGIoKChodHRwcz98ZnRwKTpcXC9cXC8pfCh3d3dcXC4pKVstQS1aMC05KyZAI1xcLyU/PX5ffCE6LC47XFxbXFxdXSpbLUEtWjAtOSsmQCNcXC8lPX5ffF0pL2dpbVxuICAgKlxuICAgKiBwdXQgdGhpcyBpbiB0aGUgYmVnaW5uaW5nIGlmIHlvdSBkb24ndCB3YW4ndCB0byBtYXRjaCB3aXRoaW4gYSB3b3JkXG4gICAqICAgIChefFtcXD5cXChcXHtcXFtcXHNcXD5dKVxuICAgKi9cbiAgVVJMX1JFR19FWFAgPSAvKChodHRwcz86XFwvXFwvfHd3d1xcLilbXlxcczxdezMsfSkvZ2ksXG4gICAgICBUUkFJTElOR19DSEFSX1JFR19FWFAgPSAvKFteXFx3XFwvXFwtXSgsPykpJC9pLFxuICAgICAgTUFYX0RJU1BMQVlfTEVOR1RIID0gMTAwLFxuICAgICAgQlJBQ0tFVFMgPSB7IFwiKVwiOiBcIihcIiwgXCJdXCI6IFwiW1wiLCBcIn1cIjogXCJ7XCIgfTtcblxuICBmdW5jdGlvbiBhdXRvTGluayhlbGVtZW50KSB7XG4gICAgaWYgKF9oYXNQYXJlbnRUaGF0U2hvdWxkQmVJZ25vcmVkKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudCA9PT0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIH1cblxuICAgIHJldHVybiBfcGFyc2VOb2RlKGVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYmFzaWNhbGx5IGEgcmVidWlsZCBvZlxuICAgKiB0aGUgcmFpbHMgYXV0b19saW5rX3VybHMgdGV4dCBoZWxwZXJcbiAgICovXG4gIGZ1bmN0aW9uIF9jb252ZXJ0VXJsc1RvTGlua3Moc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKFVSTF9SRUdfRVhQLCBmdW5jdGlvbiAobWF0Y2gsIHVybCkge1xuICAgICAgdmFyIHB1bmN0dWF0aW9uID0gKHVybC5tYXRjaChUUkFJTElOR19DSEFSX1JFR19FWFApIHx8IFtdKVsxXSB8fCBcIlwiLFxuICAgICAgICAgIG9wZW5pbmcgPSBCUkFDS0VUU1twdW5jdHVhdGlvbl07XG4gICAgICB1cmwgPSB1cmwucmVwbGFjZShUUkFJTElOR19DSEFSX1JFR19FWFAsIFwiXCIpO1xuXG4gICAgICBpZiAodXJsLnNwbGl0KG9wZW5pbmcpLmxlbmd0aCA+IHVybC5zcGxpdChwdW5jdHVhdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIHVybCA9IHVybCArIHB1bmN0dWF0aW9uO1xuICAgICAgICBwdW5jdHVhdGlvbiA9IFwiXCI7XG4gICAgICB9XG4gICAgICB2YXIgcmVhbFVybCA9IHVybCxcbiAgICAgICAgICBkaXNwbGF5VXJsID0gdXJsO1xuICAgICAgaWYgKHVybC5sZW5ndGggPiBNQVhfRElTUExBWV9MRU5HVEgpIHtcbiAgICAgICAgZGlzcGxheVVybCA9IGRpc3BsYXlVcmwuc3Vic3RyKDAsIE1BWF9ESVNQTEFZX0xFTkdUSCkgKyBcIi4uLlwiO1xuICAgICAgfVxuICAgICAgLy8gQWRkIGh0dHAgcHJlZml4IGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHJlYWxVcmwuc3Vic3RyKDAsIDQpID09PSBcInd3dy5cIikge1xuICAgICAgICByZWFsVXJsID0gXCJodHRwOi8vXCIgKyByZWFsVXJsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzxhIGhyZWY9XCInICsgcmVhbFVybCArICdcIj4nICsgcmVhbFVybCArICc8L2E+JyArIHB1bmN0dWF0aW9uO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgb3IgKGlmIGFscmVhZHkgY2FjaGVkKSByZXR1cm5zIGEgdGVtcCBlbGVtZW50XG4gICAqIGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQgb2JqZWN0XG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0VGVtcEVsZW1lbnQoY29udGV4dCkge1xuICAgIHZhciB0ZW1wRWxlbWVudCA9IGNvbnRleHQuX3d5c2lodG1sNV90ZW1wRWxlbWVudDtcbiAgICBpZiAoIXRlbXBFbGVtZW50KSB7XG4gICAgICB0ZW1wRWxlbWVudCA9IGNvbnRleHQuX3d5c2lodG1sNV90ZW1wRWxlbWVudCA9IGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBvcmlnaW5hbCB0ZXh0IG5vZGVzIHdpdGggdGhlIG5ld2x5IGF1dG8tbGlua2VkIGRvbSB0cmVlXG4gICAqL1xuICBmdW5jdGlvbiBfd3JhcE1hdGNoZXNJbk5vZGUodGV4dE5vZGUpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHRleHROb2RlLnBhcmVudE5vZGUsXG4gICAgICAgIHRlbXBFbGVtZW50ID0gX2dldFRlbXBFbGVtZW50KHBhcmVudE5vZGUub3duZXJEb2N1bWVudCk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGluc2VydCBhbiBlbXB0eS90ZW1wb3JhcnkgPHNwYW4gLz4gdG8gZml4IElFIHF1aXJrc1xuICAgIC8vIEVsc2V3aXNlIElFIHdvdWxkIHN0cmlwIHdoaXRlIHNwYWNlIGluIHRoZSBiZWdpbm5pbmdcbiAgICB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPSBcIjxzcGFuPjwvc3Bhbj5cIiArIF9jb252ZXJ0VXJsc1RvTGlua3ModGV4dE5vZGUuZGF0YSk7XG4gICAgdGVtcEVsZW1lbnQucmVtb3ZlQ2hpbGQodGVtcEVsZW1lbnQuZmlyc3RDaGlsZCk7XG5cbiAgICB3aGlsZSAodGVtcEVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgLy8gaW5zZXJ0cyB0ZW1wRWxlbWVudC5maXJzdENoaWxkIGJlZm9yZSB0ZXh0Tm9kZVxuICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGVtcEVsZW1lbnQuZmlyc3RDaGlsZCwgdGV4dE5vZGUpO1xuICAgIH1cbiAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9oYXNQYXJlbnRUaGF0U2hvdWxkQmVJZ25vcmVkKG5vZGUpIHtcbiAgICB2YXIgbm9kZU5hbWU7XG4gICAgd2hpbGUgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZTtcbiAgICAgIGlmIChJR05PUkVfVVJMU19JTi5jb250YWlucyhub2RlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcImJvZHlcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9wYXJzZU5vZGUoZWxlbWVudCkge1xuICAgIGlmIChJR05PUkVfVVJMU19JTi5jb250YWlucyhlbGVtZW50Lm5vZGVOYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSB3eXNpaHRtbDUuVEVYVF9OT0RFICYmIGVsZW1lbnQuZGF0YS5tYXRjaChVUkxfUkVHX0VYUCkpIHtcbiAgICAgIF93cmFwTWF0Y2hlc0luTm9kZShlbGVtZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGROb2RlcyA9IHd5c2lodG1sNS5sYW5nLmFycmF5KGVsZW1lbnQuY2hpbGROb2RlcykuZ2V0KCksXG4gICAgICAgIGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgICAgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGNoaWxkTm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgX3BhcnNlTm9kZShjaGlsZE5vZGVzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHd5c2lodG1sNS5kb20uYXV0b0xpbmsgPSBhdXRvTGluaztcblxuICAvLyBSZXZlYWwgdXJsIHJlZyBleHAgdG8gdGhlIG91dHNpZGVcbiAgd3lzaWh0bWw1LmRvbS5hdXRvTGluay5VUkxfUkVHX0VYUCA9IFVSTF9SRUdfRVhQO1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgc3VwcG9ydHNDbGFzc0xpc3QgPSB3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c0NsYXNzTGlzdCgpLFxuICAgICAgYXBpID0gd3lzaWh0bWw1LmRvbTtcblxuICBhcGkuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKHN1cHBvcnRzQ2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGlmIChhcGkuaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgfTtcblxuICBhcGkucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKHN1cHBvcnRzQ2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoXnxcXFxccyspXCIgKyBjbGFzc05hbWUgKyBcIihcXFxccyt8JClcIiksIFwiIFwiKTtcbiAgfTtcblxuICBhcGkuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKHN1cHBvcnRzQ2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudENsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lO1xuICAgIHJldHVybiBlbGVtZW50Q2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgKGVsZW1lbnRDbGFzc05hbWUgPT0gY2xhc3NOYW1lIHx8IG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGNsYXNzTmFtZSArIFwiKFxcXFxzfCQpXCIpLnRlc3QoZWxlbWVudENsYXNzTmFtZSkpO1xuICB9O1xufSkod3lzaWh0bWw1KTtcbnd5c2lodG1sNS5kb20uY29udGFpbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmIChkb2N1bWVudEVsZW1lbnQuY29udGFpbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRhaW5lciwgZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IHd5c2lodG1sNS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXIgIT09IGVsZW1lbnQgJiYgY29udGFpbmVyLmNvbnRhaW5zKGVsZW1lbnQpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9Ob2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4gICAgICByZXR1cm4gISEoY29udGFpbmVyLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQpICYgMTYpO1xuICAgIH07XG4gIH1cbn0oKTsgLyoqXG4gICAgICogQ29udmVydHMgYW4gSFRNTCBmcmFnbWVudC9lbGVtZW50IGludG8gYSB1bm9yZGVyZWQvb3JkZXJlZCBsaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlIHR1cm5lZCBpbnRvIGEgbGlzdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaXN0VHlwZSBUaGUgbGlzdCB0eXBlIGluIHdoaWNoIHRvIGNvbnZlcnQgdGhlIHRyZWUgKGVpdGhlciBcInVsXCIgb3IgXCJvbFwiKVxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSBjcmVhdGVkIGxpc3RcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgPCEtLSBBc3N1bWUgdGhlIGZvbGxvd2luZyBkb206IC0tPlxuICAgICAqICAgIDxzcGFuIGlkPVwicHNldWRvLWxpc3RcIj5cbiAgICAgKiAgICAgIGVtaW5lbTxicj5cbiAgICAgKiAgICAgIGRyLiBkcmVcbiAgICAgKiAgICAgIDxkaXY+NTAgQ2VudDwvZGl2PlxuICAgICAqICAgIDwvc3Bhbj5cbiAgICAgKlxuICAgICAqICAgIDxzY3JpcHQ+XG4gICAgICogICAgICB3eXNpaHRtbDUuZG9tLmNvbnZlcnRUb0xpc3QoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwc2V1ZG8tbGlzdFwiKSwgXCJ1bFwiKTtcbiAgICAgKiAgICA8L3NjcmlwdD5cbiAgICAgKlxuICAgICAqICAgIDwhLS0gV2lsbCByZXN1bHQgaW46IC0tPlxuICAgICAqICAgIDx1bD5cbiAgICAgKiAgICAgIDxsaT5lbWluZW08L2xpPlxuICAgICAqICAgICAgPGxpPmRyLiBkcmU8L2xpPlxuICAgICAqICAgICAgPGxpPjUwIENlbnQ8L2xpPlxuICAgICAqICAgIDwvdWw+XG4gICAgICovXG53eXNpaHRtbDUuZG9tLmNvbnZlcnRUb0xpc3QgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9jcmVhdGVMaXN0SXRlbShkb2MsIGxpc3QpIHtcbiAgICB2YXIgbGlzdEl0ZW0gPSBkb2MuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgIGxpc3QuYXBwZW5kQ2hpbGQobGlzdEl0ZW0pO1xuICAgIHJldHVybiBsaXN0SXRlbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVMaXN0KGRvYywgdHlwZSkge1xuICAgIHJldHVybiBkb2MuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRUb0xpc3QoZWxlbWVudCwgbGlzdFR5cGUpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gXCJVTFwiIHx8IGVsZW1lbnQubm9kZU5hbWUgPT09IFwiT0xcIiB8fCBlbGVtZW50Lm5vZGVOYW1lID09PSBcIk1FTlVcIikge1xuICAgICAgLy8gQWxyZWFkeSBhIGxpc3RcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgIGxpc3QgPSBfY3JlYXRlTGlzdChkb2MsIGxpc3RUeXBlKSxcbiAgICAgICAgbGluZUJyZWFrcyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcImJyXCIpLFxuICAgICAgICBsaW5lQnJlYWtzTGVuZ3RoID0gbGluZUJyZWFrcy5sZW5ndGgsXG4gICAgICAgIGNoaWxkTm9kZXMsXG4gICAgICAgIGNoaWxkTm9kZXNMZW5ndGgsXG4gICAgICAgIGNoaWxkTm9kZSxcbiAgICAgICAgbGluZUJyZWFrLFxuICAgICAgICBwYXJlbnROb2RlLFxuICAgICAgICBpc0Jsb2NrRWxlbWVudCxcbiAgICAgICAgaXNMaW5lQnJlYWssXG4gICAgICAgIGN1cnJlbnRMaXN0SXRlbSxcbiAgICAgICAgaTtcblxuICAgIC8vIEZpcnN0IGZpbmQgPGJyPiBhdCB0aGUgZW5kIG9mIGlubGluZSBlbGVtZW50cyBhbmQgbW92ZSB0aGVtIGJlaGluZCB0aGVtXG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmVCcmVha3NMZW5ndGg7IGkrKykge1xuICAgICAgbGluZUJyZWFrID0gbGluZUJyZWFrc1tpXTtcbiAgICAgIHdoaWxlICgocGFyZW50Tm9kZSA9IGxpbmVCcmVhay5wYXJlbnROb2RlKSAmJiBwYXJlbnROb2RlICE9PSBlbGVtZW50ICYmIHBhcmVudE5vZGUubGFzdENoaWxkID09PSBsaW5lQnJlYWspIHtcbiAgICAgICAgaWYgKHd5c2lodG1sNS5kb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20ocGFyZW50Tm9kZSkgPT09IFwiYmxvY2tcIikge1xuICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluZUJyZWFrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB3eXNpaHRtbDUuZG9tLmluc2VydChsaW5lQnJlYWspLmFmdGVyKGxpbmVCcmVhay5wYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZE5vZGVzID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoZWxlbWVudC5jaGlsZE5vZGVzKS5nZXQoKTtcbiAgICBjaGlsZE5vZGVzTGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGROb2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgICBjdXJyZW50TGlzdEl0ZW0gPSBjdXJyZW50TGlzdEl0ZW0gfHwgX2NyZWF0ZUxpc3RJdGVtKGRvYywgbGlzdCk7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgaXNCbG9ja0VsZW1lbnQgPSB3eXNpaHRtbDUuZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKGNoaWxkTm9kZSkgPT09IFwiYmxvY2tcIjtcbiAgICAgIGlzTGluZUJyZWFrID0gY2hpbGROb2RlLm5vZGVOYW1lID09PSBcIkJSXCI7XG5cbiAgICAgIGlmIChpc0Jsb2NrRWxlbWVudCkge1xuICAgICAgICAvLyBBcHBlbmQgYmxvY2tFbGVtZW50IHRvIGN1cnJlbnQgPGxpPiBpZiBlbXB0eSwgb3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgY3VycmVudExpc3RJdGVtID0gY3VycmVudExpc3RJdGVtLmZpcnN0Q2hpbGQgPyBfY3JlYXRlTGlzdEl0ZW0oZG9jLCBsaXN0KSA6IGN1cnJlbnRMaXN0SXRlbTtcbiAgICAgICAgY3VycmVudExpc3RJdGVtLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgICAgIGN1cnJlbnRMaXN0SXRlbSA9IG51bGw7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNMaW5lQnJlYWspIHtcbiAgICAgICAgLy8gT25seSBjcmVhdGUgYSBuZXcgbGlzdCBpdGVtIGluIHRoZSBuZXh0IGl0ZXJhdGlvbiB3aGVuIHRoZSBjdXJyZW50IG9uZSBoYXMgYWxyZWFkeSBjb250ZW50XG4gICAgICAgIGN1cnJlbnRMaXN0SXRlbSA9IGN1cnJlbnRMaXN0SXRlbS5maXJzdENoaWxkID8gbnVsbCA6IGN1cnJlbnRMaXN0SXRlbTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRMaXN0SXRlbS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgIH1cblxuICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobGlzdCwgZWxlbWVudCk7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICByZXR1cm4gY29udmVydFRvTGlzdDtcbn0oKTsgLyoqXG4gICAgICogQ29weSBhIHNldCBvZiBhdHRyaWJ1dGVzIGZyb20gb25lIGVsZW1lbnQgdG8gYW5vdGhlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXR0cmlidXRlc1RvQ29weSBMaXN0IG9mIGF0dHJpYnV0ZXMgd2hpY2ggc2hvdWxkIGJlIGNvcGllZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2hpY2ggb2ZmZXJzIHRoZSBcImZyb21cIiBtZXRob2Qgd2hpY2ggY2FuIGJlIGludm9rZWQgd2l0aCB0aGUgZWxlbWVudCB3aGVyZSB0b1xuICAgICAqICAgIGNvcHkgdGhlIGF0dHJpYnV0ZXMgZnJvbS4sIHRoaXMgYWdhaW4gcmV0dXJucyBhbiBvYmplY3Qgd2hpY2ggcHJvdmlkZXMgYSBtZXRob2QgbmFtZWQgXCJ0b1wiIHdoaWNoIGNhbiBiZSBpbnZva2VkIFxuICAgICAqICAgIHdpdGggdGhlIGVsZW1lbnQgd2hlcmUgdG8gY29weSB0aGUgYXR0cmlidXRlcyB0byAoc2VlIGV4YW1wbGUpXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHZhciB0ZXh0YXJlYSAgICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0YXJlYVwiKSxcbiAgICAgKiAgICAgICAgZGl2ICAgICAgICAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiZGl2W2NvbnRlbnRlZGl0YWJsZT10cnVlXVwiKSxcbiAgICAgKiAgICAgICAgYW5vdGhlckRpdiAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiZGl2LnByZXZpZXdcIik7XG4gICAgICogICAgd3lzaWh0bWw1LmRvbS5jb3B5QXR0cmlidXRlcyhbXCJzcGVsbGNoZWNrXCIsIFwidmFsdWVcIiwgXCJwbGFjZWhvbGRlclwiXSkuZnJvbSh0ZXh0YXJlYSkudG8oZGl2KS5hbmRUbyhhbm90aGVyRGl2KTtcbiAgICAgKlxuICAgICAqL1xud3lzaWh0bWw1LmRvbS5jb3B5QXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVzVG9Db3B5KSB7XG4gIHJldHVybiB7XG4gICAgZnJvbTogZnVuY3Rpb24gZnJvbShlbGVtZW50VG9Db3B5RnJvbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG86IGZ1bmN0aW9uIHRvKGVsZW1lbnRUb0NvcHlUbykge1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGUsXG4gICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICBsZW5ndGggPSBhdHRyaWJ1dGVzVG9Db3B5Lmxlbmd0aDtcbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzVG9Db3B5W2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50VG9Db3B5RnJvbVthdHRyaWJ1dGVdICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW1lbnRUb0NvcHlGcm9tW2F0dHJpYnV0ZV0gIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgZWxlbWVudFRvQ29weVRvW2F0dHJpYnV0ZV0gPSBlbGVtZW50VG9Db3B5RnJvbVthdHRyaWJ1dGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBhbmRUbzogYXJndW1lbnRzLmNhbGxlZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IC8qKlxuICAgKiBDb3B5IGEgc2V0IG9mIHN0eWxlcyBmcm9tIG9uZSBlbGVtZW50IHRvIGFub3RoZXJcbiAgICogUGxlYXNlIG5vdGUgdGhhdCB0aGlzIG9ubHkgd29ya3MgcHJvcGVybHkgYWNyb3NzIGJyb3dzZXJzIHdoZW4gdGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBjb3B5IHRoZSBzdHlsZXNcbiAgICogaXMgaW4gdGhlIGRvbVxuICAgKlxuICAgKiBJbnRlcmVzdGluZyBhcnRpY2xlIG9uIGhvdyB0byBjb3B5IHN0eWxlc1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHlsZXNUb0NvcHkgTGlzdCBvZiBzdHlsZXMgd2hpY2ggc2hvdWxkIGJlIGNvcGllZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIG9mZmVycyB0aGUgXCJmcm9tXCIgbWV0aG9kIHdoaWNoIGNhbiBiZSBpbnZva2VkIHdpdGggdGhlIGVsZW1lbnQgd2hlcmUgdG9cbiAgICogICAgY29weSB0aGUgc3R5bGVzIGZyb20uLCB0aGlzIGFnYWluIHJldHVybnMgYW4gb2JqZWN0IHdoaWNoIHByb3ZpZGVzIGEgbWV0aG9kIG5hbWVkIFwidG9cIiB3aGljaCBjYW4gYmUgaW52b2tlZCBcbiAgICogICAgd2l0aCB0aGUgZWxlbWVudCB3aGVyZSB0byBjb3B5IHRoZSBzdHlsZXMgdG8gKHNlZSBleGFtcGxlKVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgICB2YXIgdGV4dGFyZWEgICAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwidGV4dGFyZWFcIiksXG4gICAqICAgICAgICBkaXYgICAgICAgICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJkaXZbY29udGVudGVkaXRhYmxlPXRydWVdXCIpLFxuICAgKiAgICAgICAgYW5vdGhlckRpdiAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiZGl2LnByZXZpZXdcIik7XG4gICAqICAgIHd5c2lodG1sNS5kb20uY29weVN0eWxlcyhbXCJvdmVyZmxvdy15XCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl0pLmZyb20odGV4dGFyZWEpLnRvKGRpdikuYW5kVG8oYW5vdGhlckRpdik7XG4gICAqXG4gICAqL1xuKGZ1bmN0aW9uIChkb20pIHtcblxuICAvKipcbiAgICogTW96aWxsYSwgV2ViS2l0IGFuZCBPcGVyYSByZWNhbGN1bGF0ZSB0aGUgY29tcHV0ZWQgd2lkdGggd2hlbiBib3gtc2l6aW5nOiBib2Rlci1ib3g7IGlzIHNldFxuICAgKiBTbyBpZiBhbiBlbGVtZW50IGhhcyBcIndpZHRoOiAyMDBweDsgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94OyBib3JkZXI6IDFweDtcIiB0aGVuIFxuICAgKiBpdHMgY29tcHV0ZWQgY3NzIHdpZHRoIHdpbGwgYmUgMTk4cHhcbiAgICovXG4gIHZhciBCT1hfU0laSU5HX1BST1BFUlRJRVMgPSBbXCItd2Via2l0LWJveC1zaXppbmdcIiwgXCItbW96LWJveC1zaXppbmdcIiwgXCItbXMtYm94LXNpemluZ1wiLCBcImJveC1zaXppbmdcIl07XG5cbiAgdmFyIHNob3VsZElnbm9yZUJveFNpemluZ0JvcmRlckJveCA9IGZ1bmN0aW9uIHNob3VsZElnbm9yZUJveFNpemluZ0JvcmRlckJveChlbGVtZW50KSB7XG4gICAgaWYgKGhhc0JveFNpemluZ0JvcmRlckJveChlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGRvbS5nZXRTdHlsZShcIndpZHRoXCIpLmZyb20oZWxlbWVudCksIDEwKSA8IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB2YXIgaGFzQm94U2l6aW5nQm9yZGVyQm94ID0gZnVuY3Rpb24gaGFzQm94U2l6aW5nQm9yZGVyQm94KGVsZW1lbnQpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbmd0aCA9IEJPWF9TSVpJTkdfUFJPUEVSVElFUy5sZW5ndGg7XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGRvbS5nZXRTdHlsZShCT1hfU0laSU5HX1BST1BFUlRJRVNbaV0pLmZyb20oZWxlbWVudCkgPT09IFwiYm9yZGVyLWJveFwiKSB7XG4gICAgICAgIHJldHVybiBCT1hfU0laSU5HX1BST1BFUlRJRVNbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGRvbS5jb3B5U3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlc1RvQ29weSkge1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiBmdW5jdGlvbiBmcm9tKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUJveFNpemluZ0JvcmRlckJveChlbGVtZW50KSkge1xuICAgICAgICAgIHN0eWxlc1RvQ29weSA9IHd5c2lodG1sNS5sYW5nLmFycmF5KHN0eWxlc1RvQ29weSkud2l0aG91dChCT1hfU0laSU5HX1BST1BFUlRJRVMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNzc1RleHQgPSBcIlwiLFxuICAgICAgICAgICAgbGVuZ3RoID0gc3R5bGVzVG9Db3B5Lmxlbmd0aCxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgcHJvcGVydHk7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IHN0eWxlc1RvQ29weVtpXTtcbiAgICAgICAgICBjc3NUZXh0ICs9IHByb3BlcnR5ICsgXCI6XCIgKyBkb20uZ2V0U3R5bGUocHJvcGVydHkpLmZyb20oZWxlbWVudCkgKyBcIjtcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG86IGZ1bmN0aW9uIHRvKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHRfciA9IC9cXDtoZWlnaHRcXDovO1xuICAgICAgICAgICAgaWYgKGNzc1RleHQubWF0Y2goaGVpZ2h0X3IpICYmIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgbGlzdCA9IGNzc1RleHQuc3BsaXQoaGVpZ2h0X3IpO1xuICAgICAgICAgICAgICBoZWlnaHQgPSBwYXJzZUludChsaXN0WzFdLCAxMCk7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldEhlaWdodCA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGNzc1RleHQgPSBsaXN0WzBdICsgJ2hlaWdodDonICsgZWxlbWVudC5vZmZzZXRIZWlnaHQgKyAncHg7JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tLnNldFN0eWxlcyhjc3NUZXh0KS5vbihlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB7IGFuZFRvOiBhcmd1bWVudHMuY2FsbGVlIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG59KSh3eXNpaHRtbDUuZG9tKTsgLyoqXG4gICAgICAgICAgICAgICAgICAgKiBFdmVudCBEZWxlZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAqICAgIHd5c2lodG1sNS5kb20uZGVsZWdhdGUoZG9jdW1lbnQuYm9keSwgXCJhXCIsIFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIGZvb1xuICAgICAgICAgICAgICAgICAgICogICAgfSk7XG4gICAgICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG5cbiAgd3lzaWh0bWw1LmRvbS5kZWxlZ2F0ZSA9IGZ1bmN0aW9uIChjb250YWluZXIsIHNlbGVjdG9yLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gd3lzaWh0bWw1LmRvbS5vYnNlcnZlKGNvbnRhaW5lciwgZXZlbnROYW1lLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQsXG4gICAgICAgICAgbWF0Y2ggPSB3eXNpaHRtbDUubGFuZy5hcnJheShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuXG4gICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChtYXRjaC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSkod3lzaWh0bWw1KTsgLyoqXG4gICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGdpdmVuIGh0bWwgd3JhcHBlZCBpbiBhIGRpdiBlbGVtZW50XG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIEZpeGluZyBJRSdzIGluYWJpbGl0eSB0byB0cmVhdCB1bmtub3duIGVsZW1lbnRzIChIVE1MNSBzZWN0aW9uLCBhcnRpY2xlLCAuLi4pIGNvcnJlY3RseVxuICAgICAgICAgICAgICAgKiB3aGVuIGluc2VydGVkIHZpYSBpbm5lckhUTUxcbiAgICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIFRoZSBodG1sIHdoaWNoIHNob3VsZCBiZSB3cmFwcGVkIGluIGEgZG9tIGVsZW1lbnRcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmVqY3R9IFtjb250ZXh0XSBEb2N1bWVudCBvYmplY3Qgb2YgdGhlIGNvbnRleHQgdGhlIGh0bWwgYmVsb25ncyB0b1xuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgKiAgICB3eXNpaHRtbDUuZG9tLmdldEFzRG9tKFwiPGFydGljbGU+Zm9vPC9hcnRpY2xlPlwiKTtcbiAgICAgICAgICAgICAgICovXG53eXNpaHRtbDUuZG9tLmdldEFzRG9tID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBfaW5uZXJIVE1MU2hpdiA9IGZ1bmN0aW9uIF9pbm5lckhUTUxTaGl2KGh0bWwsIGNvbnRleHQpIHtcbiAgICB2YXIgdGVtcEVsZW1lbnQgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGVtcEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIGNvbnRleHQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wRWxlbWVudCk7XG4gICAgLy8gSUUgdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIHRyeWluZyB0byBpbnNlcnQgPGZyYW1lc2V0PjwvZnJhbWVzZXQ+IHZpYSBpbm5lckhUTUxcbiAgICB0cnkge1xuICAgICAgdGVtcEVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGNvbnRleHQuYm9keS5yZW1vdmVDaGlsZCh0ZW1wRWxlbWVudCk7XG4gICAgcmV0dXJuIHRlbXBFbGVtZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIHN1cmUgSUUgc3VwcG9ydHMgSFRNTDUgdGFncywgd2hpY2ggaXMgYWNjb21wbGlzaGVkIGJ5IHNpbXBseSBjcmVhdGluZyBvbmUgaW5zdGFuY2Ugb2YgZWFjaCBlbGVtZW50XG4gICAqL1xuICB2YXIgX2Vuc3VyZUhUTUw1Q29tcGF0aWJpbGl0eSA9IGZ1bmN0aW9uIF9lbnN1cmVIVE1MNUNvbXBhdGliaWxpdHkoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0Ll93eXNpaHRtbDVfc3VwcG9ydHNIVE1MNVRhZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IEhUTUw1X0VMRU1FTlRTLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoSFRNTDVfRUxFTUVOVFNbaV0pO1xuICAgIH1cbiAgICBjb250ZXh0Ll93eXNpaHRtbDVfc3VwcG9ydHNIVE1MNVRhZ3MgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGh0bWw1IHRhZ3NcbiAgICogdGFrZW4gZnJvbSBodHRwOi8vc2ltb24uaHRtbDUub3JnL2h0bWw1LWVsZW1lbnRzXG4gICAqL1xuICB2YXIgSFRNTDVfRUxFTUVOVFMgPSBbXCJhYmJyXCIsIFwiYXJ0aWNsZVwiLCBcImFzaWRlXCIsIFwiYXVkaW9cIiwgXCJiZGlcIiwgXCJjYW52YXNcIiwgXCJjb21tYW5kXCIsIFwiZGF0YWxpc3RcIiwgXCJkZXRhaWxzXCIsIFwiZmlnY2FwdGlvblwiLCBcImZpZ3VyZVwiLCBcImZvb3RlclwiLCBcImhlYWRlclwiLCBcImhncm91cFwiLCBcImtleWdlblwiLCBcIm1hcmtcIiwgXCJtZXRlclwiLCBcIm5hdlwiLCBcIm91dHB1dFwiLCBcInByb2dyZXNzXCIsIFwicnBcIiwgXCJydFwiLCBcInJ1YnlcIiwgXCJzdmdcIiwgXCJzZWN0aW9uXCIsIFwic291cmNlXCIsIFwic3VtbWFyeVwiLCBcInRpbWVcIiwgXCJ0cmFja1wiLCBcInZpZGVvXCIsIFwid2JyXCJdO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoaHRtbCwgY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuICAgIHZhciB0ZW1wRWxlbWVudDtcbiAgICBpZiAoKHR5cGVvZiBodG1sID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoaHRtbCkpID09PSBcIm9iamVjdFwiICYmIGh0bWwubm9kZVR5cGUpIHtcbiAgICAgIHRlbXBFbGVtZW50ID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGVtcEVsZW1lbnQuYXBwZW5kQ2hpbGQoaHRtbCk7XG4gICAgfSBlbHNlIGlmICh3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c0hUTUw1VGFncyhjb250ZXh0KSkge1xuICAgICAgdGVtcEVsZW1lbnQgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0gZWxzZSB7XG4gICAgICBfZW5zdXJlSFRNTDVDb21wYXRpYmlsaXR5KGNvbnRleHQpO1xuICAgICAgdGVtcEVsZW1lbnQgPSBfaW5uZXJIVE1MU2hpdihodG1sLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBFbGVtZW50O1xuICB9O1xufSgpOyAvKipcbiAgICAgKiBXYWxrcyB0aGUgZG9tIHRyZWUgZnJvbSB0aGUgZ2l2ZW4gbm9kZSB1cCB1bnRpbCBpdCBmaW5kcyBhIG1hdGNoXG4gICAgICogRGVzaWduZWQgZm9yIG9wdGltYWwgcGVyZm9ybWFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgVGhlIGZyb20gd2hpY2ggdG8gY2hlY2sgdGhlIHBhcmVudCBub2Rlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaGluZ1NldCBPYmplY3QgdG8gbWF0Y2ggYWdhaW5zdCAocG9zc2libGUgcHJvcGVydGllczogbm9kZU5hbWUsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtsZXZlbHNdIEhvdyBtYW55IHBhcmVudHMgc2hvdWxkIHRoZSBmdW5jdGlvbiBjaGVjayB1cCBmcm9tIHRoZSBjdXJyZW50IG5vZGUgKGRlZmF1bHRzIHRvIDUwKVxuICAgICAqIEByZXR1cm4ge251bGx8RWxlbWVudH0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZWQgdGhlIGRlc2lyZWROb2RlTmFtZShzKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgdmFyIGxpc3RFbGVtZW50ID0gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJsaVwiKSwgeyBub2RlTmFtZTogW1wiTUVOVVwiLCBcIlVMXCIsIFwiT0xcIl0gfSk7XG4gICAgICogICAgLy8gLi4uIG9yIC4uLlxuICAgICAqICAgIHZhciB1bm9yZGVyZWRMaXN0RWxlbWVudCA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibGlcIiksIHsgbm9kZU5hbWU6IFwiVUxcIiB9KTtcbiAgICAgKiAgICAvLyAuLi4gb3IgLi4uXG4gICAgICogICAgdmFyIGNvbG9yZWRFbGVtZW50ID0gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KG15VGV4dE5vZGUsIHsgbm9kZU5hbWU6IFwiU1BBTlwiLCBjbGFzc05hbWU6IFwid3lzaXd5Zy1jb2xvci1yZWRcIiwgY2xhc3NSZWdFeHA6IC93eXNpd3lnLWNvbG9yLVthLXpdL2cgfSk7XG4gICAgICovXG53eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgZnVuY3Rpb24gX2lzU2FtZU5vZGVOYW1lKG5vZGVOYW1lLCBkZXNpcmVkTm9kZU5hbWVzKSB7XG4gICAgaWYgKCFkZXNpcmVkTm9kZU5hbWVzIHx8ICFkZXNpcmVkTm9kZU5hbWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXNpcmVkTm9kZU5hbWVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbm9kZU5hbWUgPT09IGRlc2lyZWROb2RlTmFtZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUubGFuZy5hcnJheShkZXNpcmVkTm9kZU5hbWVzKS5jb250YWlucyhub2RlTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2lzRWxlbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5FTEVNRU5UX05PREU7XG4gIH1cblxuICBmdW5jdGlvbiBfaGFzQ2xhc3NOYW1lKGVsZW1lbnQsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IChlbGVtZW50LmNsYXNzTmFtZSB8fCBcIlwiKS5tYXRjaChjbGFzc1JlZ0V4cCkgfHwgW107XG4gICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiAhIWNsYXNzTmFtZXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lc1tjbGFzc05hbWVzLmxlbmd0aCAtIDFdID09PSBjbGFzc05hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0UGFyZW50RWxlbWVudFdpdGhOb2RlTmFtZShub2RlLCBub2RlTmFtZSwgbGV2ZWxzKSB7XG4gICAgd2hpbGUgKGxldmVscy0tICYmIG5vZGUgJiYgbm9kZS5ub2RlTmFtZSAhPT0gXCJCT0RZXCIpIHtcbiAgICAgIGlmIChfaXNTYW1lTm9kZU5hbWUobm9kZS5ub2RlTmFtZSwgbm9kZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0UGFyZW50RWxlbWVudFdpdGhOb2RlTmFtZUFuZENsYXNzTmFtZShub2RlLCBub2RlTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCwgbGV2ZWxzKSB7XG4gICAgd2hpbGUgKGxldmVscy0tICYmIG5vZGUgJiYgbm9kZS5ub2RlTmFtZSAhPT0gXCJCT0RZXCIpIHtcbiAgICAgIGlmIChfaXNFbGVtZW50KG5vZGUpICYmIF9pc1NhbWVOb2RlTmFtZShub2RlLm5vZGVOYW1lLCBub2RlTmFtZSkgJiYgX2hhc0NsYXNzTmFtZShub2RlLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBtYXRjaGluZ1NldCwgbGV2ZWxzKSB7XG4gICAgbGV2ZWxzID0gbGV2ZWxzIHx8IDUwOyAvLyBHbyBtYXggNTAgbm9kZXMgdXB3YXJkcyBmcm9tIGN1cnJlbnQgbm9kZVxuICAgIGlmIChtYXRjaGluZ1NldC5jbGFzc05hbWUgfHwgbWF0Y2hpbmdTZXQuY2xhc3NSZWdFeHApIHtcbiAgICAgIHJldHVybiBfZ2V0UGFyZW50RWxlbWVudFdpdGhOb2RlTmFtZUFuZENsYXNzTmFtZShub2RlLCBtYXRjaGluZ1NldC5ub2RlTmFtZSwgbWF0Y2hpbmdTZXQuY2xhc3NOYW1lLCBtYXRjaGluZ1NldC5jbGFzc1JlZ0V4cCwgbGV2ZWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9nZXRQYXJlbnRFbGVtZW50V2l0aE5vZGVOYW1lKG5vZGUsIG1hdGNoaW5nU2V0Lm5vZGVOYW1lLCBsZXZlbHMpO1xuICAgIH1cbiAgfTtcbn0oKTtcbi8qKlxuICogR2V0IGVsZW1lbnQncyBzdHlsZSBmb3IgYSBzcGVjaWZpYyBjc3MgcHJvcGVydHlcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb24gd2hpY2ggdG8gcmV0cmlldmUgdGhlIHN0eWxlXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgVGhlIENTUyBwcm9wZXJ0eSB0byByZXRyaWV2ZSAoXCJmbG9hdFwiLCBcImRpc3BsYXlcIiwgXCJ0ZXh0LWFsaWduXCIsIC4uLilcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgd3lzaWh0bWw1LmRvbS5nZXRTdHlsZShcImRpc3BsYXlcIikuZnJvbShkb2N1bWVudC5ib2R5KTtcbiAqICAgIC8vID0+IFwiYmxvY2tcIlxuICovXG53eXNpaHRtbDUuZG9tLmdldFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3R5bGVQcm9wZXJ0eU1hcHBpbmcgPSB7XG4gICAgXCJmbG9hdFwiOiBcInN0eWxlRmxvYXRcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlID8gXCJzdHlsZUZsb2F0XCIgOiBcImNzc0Zsb2F0XCJcbiAgfSxcbiAgICAgIFJFR19FWFBfQ0FNRUxJWkUgPSAvXFwtW2Etel0vZztcblxuICBmdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoUkVHX0VYUF9DQU1FTElaRSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2guY2hhckF0KDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb206IGZ1bmN0aW9uIGZyb20oZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gd3lzaWh0bWw1LkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICBjYW1lbGl6ZWRQcm9wZXJ0eSA9IHN0eWxlUHJvcGVydHlNYXBwaW5nW3Byb3BlcnR5XSB8fCBjYW1lbGl6ZShwcm9wZXJ0eSksXG4gICAgICAgICAgICBzdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG4gICAgICAgICAgICBjdXJyZW50U3R5bGUgPSBlbGVtZW50LmN1cnJlbnRTdHlsZSxcbiAgICAgICAgICAgIHN0eWxlVmFsdWUgPSBzdHlsZVtjYW1lbGl6ZWRQcm9wZXJ0eV07XG4gICAgICAgIGlmIChzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjdXJyZW50U3R5bGUgaXMgbm8gc3RhbmRhcmQgYW5kIG9ubHkgc3VwcG9ydGVkIGJ5IE9wZXJhIGFuZCBJRSBidXQgaXQgaGFzIG9uZSBpbXBvcnRhbnQgYWR2YW50YWdlIG92ZXIgdGhlIHN0YW5kYXJkLWNvbXBsaWFudFxuICAgICAgICAvLyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSwgc2luY2UgaXQgcmV0dXJucyBjc3MgcHJvcGVydHkgdmFsdWVzIGluIHRoZWlyIG9yaWdpbmFsIHVuaXQ6XG4gICAgICAgIC8vIElmIHlvdSBzZXQgYW4gZWxlbWVudHMgd2lkdGggdG8gXCI1MCVcIiwgd2luZG93LmdldENvbXB1dGVkU3R5bGUgd2lsbCBnaXZlIHlvdSBpdCdzIGN1cnJlbnQgd2lkdGggaW4gcHggd2hpbGUgY3VycmVudFN0eWxlXG4gICAgICAgIC8vIGdpdmVzIHlvdSB0aGUgb3JpZ2luYWwgXCI1MCVcIi5cbiAgICAgICAgLy8gT3BlcmEgc3VwcG9ydHMgYm90aCwgY3VycmVudFN0eWxlIGFuZCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSwgdGhhdCdzIHdoeSBjaGVja2luZyBmb3IgY3VycmVudFN0eWxlIHNob3VsZCBoYXZlIGhpZ2hlciBwcmlvXG4gICAgICAgIGlmIChjdXJyZW50U3R5bGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTdHlsZVtjYW1lbGl6ZWRQcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy9pZSB3aWxsIG9jY2FzaW9uYWxseSBmYWlsIGZvciB1bmtub3duIHJlYXNvbnMuIHN3YWxsb3dpbmcgZXhjZXB0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93LFxuICAgICAgICAgICAgbmVlZHNPdmVyZmxvd1Jlc2V0ID0gKHByb3BlcnR5ID09PSBcImhlaWdodFwiIHx8IHByb3BlcnR5ID09PSBcIndpZHRoXCIpICYmIGVsZW1lbnQubm9kZU5hbWUgPT09IFwiVEVYVEFSRUFcIixcbiAgICAgICAgICAgIG9yaWdpbmFsT3ZlcmZsb3csXG4gICAgICAgICAgICByZXR1cm5WYWx1ZTtcblxuICAgICAgICBpZiAod2luLmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSBib3RoIGNhbGN1bGF0ZSBhIHdyb25nIHdpZHRoIGFuZCBoZWlnaHQgZm9yIHRleHRhcmVhcyB3aGVuIHRoZXkgaGF2ZSBzY3JvbGwgYmFyc1xuICAgICAgICAgIC8vIHRoZXJmb3JlIHdlIHJlbW92ZSBhbmQgcmVzdG9yZSB0aGUgc2Nyb2xsYmFyIGFuZCBjYWxjdWxhdGUgdGhlIHZhbHVlIGluIGJldHdlZW5cbiAgICAgICAgICBpZiAobmVlZHNPdmVyZmxvd1Jlc2V0KSB7XG4gICAgICAgICAgICBvcmlnaW5hbE92ZXJmbG93ID0gc3R5bGUub3ZlcmZsb3c7XG4gICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVyblZhbHVlID0gd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gICAgICAgICAgaWYgKG5lZWRzT3ZlcmZsb3dSZXNldCkge1xuICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBvcmlnaW5hbE92ZXJmbG93IHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH07XG59KCk7IC8qKlxuICAgICAqIEhpZ2ggcGVyZm9ybWFudCB3YXkgdG8gY2hlY2sgd2hldGhlciBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpYyB0YWcgbmFtZSBpcyBpbiB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAgICAgKiBPcHRpbWl6ZWQgZm9yIGJlaW5nIGhlYXZpbHkgZXhlY3V0ZWRcbiAgICAgKiBVbmxlYXNoZXMgdGhlIHBvd2VyIG9mIGxpdmUgbm9kZSBsaXN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRvYyBUaGUgZG9jdW1lbnQgb2JqZWN0IG9mIHRoZSBjb250ZXh0IHdoZXJlIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWUgVXBwZXIgY2FzZWQgdGFnIG5hbWVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHd5c2lodG1sNS5kb20uaGFzRWxlbWVudFdpdGhUYWdOYW1lKGRvY3VtZW50LCBcIklNR1wiKTtcbiAgICAgKi9cbnd5c2lodG1sNS5kb20uaGFzRWxlbWVudFdpdGhUYWdOYW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgTElWRV9DQUNIRSA9IHt9LFxuICAgICAgRE9DVU1FTlRfSURFTlRJRklFUiA9IDE7XG5cbiAgZnVuY3Rpb24gX2dldERvY3VtZW50SWRlbnRpZmllcihkb2MpIHtcbiAgICByZXR1cm4gZG9jLl93eXNpaHRtbDVfaWRlbnRpZmllciB8fCAoZG9jLl93eXNpaHRtbDVfaWRlbnRpZmllciA9IERPQ1VNRU5UX0lERU5USUZJRVIrKyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGRvYywgdGFnTmFtZSkge1xuICAgIHZhciBrZXkgPSBfZ2V0RG9jdW1lbnRJZGVudGlmaWVyKGRvYykgKyBcIjpcIiArIHRhZ05hbWUsXG4gICAgICAgIGNhY2hlRW50cnkgPSBMSVZFX0NBQ0hFW2tleV07XG4gICAgaWYgKCFjYWNoZUVudHJ5KSB7XG4gICAgICBjYWNoZUVudHJ5ID0gTElWRV9DQUNIRVtrZXldID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZUVudHJ5Lmxlbmd0aCA+IDA7XG4gIH07XG59KCk7IC8qKlxuICAgICAqIEhpZ2ggcGVyZm9ybWFudCB3YXkgdG8gY2hlY2sgd2hldGhlciBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpYyBjbGFzcyBuYW1lIGlzIGluIHRoZSBnaXZlbiBkb2N1bWVudFxuICAgICAqIE9wdGltaXplZCBmb3IgYmVpbmcgaGVhdmlseSBleGVjdXRlZFxuICAgICAqIFVubGVhc2hlcyB0aGUgcG93ZXIgb2YgbGl2ZSBub2RlIGxpc3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZG9jIFRoZSBkb2N1bWVudCBvYmplY3Qgb2YgdGhlIGNvbnRleHQgd2hlcmUgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZSBVcHBlciBjYXNlZCB0YWcgbmFtZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1LmRvbS5oYXNFbGVtZW50V2l0aENsYXNzTmFtZShkb2N1bWVudCwgXCJmb29iYXJcIik7XG4gICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgTElWRV9DQUNIRSA9IHt9LFxuICAgICAgRE9DVU1FTlRfSURFTlRJRklFUiA9IDE7XG5cbiAgZnVuY3Rpb24gX2dldERvY3VtZW50SWRlbnRpZmllcihkb2MpIHtcbiAgICByZXR1cm4gZG9jLl93eXNpaHRtbDVfaWRlbnRpZmllciB8fCAoZG9jLl93eXNpaHRtbDVfaWRlbnRpZmllciA9IERPQ1VNRU5UX0lERU5USUZJRVIrKyk7XG4gIH1cblxuICB3eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoQ2xhc3NOYW1lID0gZnVuY3Rpb24gKGRvYywgY2xhc3NOYW1lKSB7XG4gICAgLy8gZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFPDlcbiAgICAvLyBidXQgaXMgc29tZXRpbWVzIG1vY2tlZCB2aWEgbGlicmFyeSBjb2RlICh3aGljaCB0aGVuIGRvZXNuJ3QgcmV0dXJuIGxpdmUgbm9kZSBsaXN0cylcbiAgICBpZiAoIXd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzTmF0aXZlR2V0RWxlbWVudHNCeUNsYXNzTmFtZSgpKSB7XG4gICAgICByZXR1cm4gISFkb2MucXVlcnlTZWxlY3RvcihcIi5cIiArIGNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IF9nZXREb2N1bWVudElkZW50aWZpZXIoZG9jKSArIFwiOlwiICsgY2xhc3NOYW1lLFxuICAgICAgICBjYWNoZUVudHJ5ID0gTElWRV9DQUNIRVtrZXldO1xuICAgIGlmICghY2FjaGVFbnRyeSkge1xuICAgICAgY2FjaGVFbnRyeSA9IExJVkVfQ0FDSEVba2V5XSA9IGRvYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlRW50cnkubGVuZ3RoID4gMDtcbiAgfTtcbn0pKHd5c2lodG1sNSk7XG53eXNpaHRtbDUuZG9tLmluc2VydCA9IGZ1bmN0aW9uIChlbGVtZW50VG9JbnNlcnQpIHtcbiAgcmV0dXJuIHtcbiAgICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIoZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50VG9JbnNlcnQsIGVsZW1lbnQubmV4dFNpYmxpbmcpO1xuICAgIH0sXG5cbiAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZShlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnRUb0luc2VydCwgZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGludG86IGZ1bmN0aW9uIGludG8oZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50VG9JbnNlcnQpO1xuICAgIH1cbiAgfTtcbn07d3lzaWh0bWw1LmRvbS5pbnNlcnRDU1MgPSBmdW5jdGlvbiAocnVsZXMpIHtcbiAgcnVsZXMgPSBydWxlcy5qb2luKFwiXFxuXCIpO1xuXG4gIHJldHVybiB7XG4gICAgaW50bzogZnVuY3Rpb24gaW50byhkb2MpIHtcbiAgICAgIHZhciBoZWFkID0gZG9jLmhlYWQgfHwgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXSxcbiAgICAgICAgICBzdHlsZUVsZW1lbnQgPSBkb2MuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG4gICAgICBzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuICAgICAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBydWxlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUocnVsZXMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07IC8qKlxuICAgKiBNZXRob2QgdG8gc2V0IGRvbSBldmVudHNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgd3lzaWh0bWw1LmRvbS5vYnNlcnZlKGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmJvZHksIFtcImZvY3VzXCIsIFwiYmx1clwiXSwgZnVuY3Rpb24oKSB7IC4uLiB9KTtcbiAgICovXG53eXNpaHRtbDUuZG9tLm9ic2VydmUgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lcywgaGFuZGxlcikge1xuICBldmVudE5hbWVzID0gdHlwZW9mIGV2ZW50TmFtZXMgPT09IFwic3RyaW5nXCIgPyBbZXZlbnROYW1lc10gOiBldmVudE5hbWVzO1xuXG4gIHZhciBoYW5kbGVyV3JhcHBlcixcbiAgICAgIGV2ZW50TmFtZSxcbiAgICAgIGkgPSAwLFxuICAgICAgbGVuZ3RoID0gZXZlbnROYW1lcy5sZW5ndGg7XG5cbiAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZXNbaV07XG4gICAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVyV3JhcHBlciA9IGZ1bmN0aW9uIGhhbmRsZXJXcmFwcGVyKGV2ZW50KSB7XG4gICAgICAgIGlmICghKFwidGFyZ2V0XCIgaW4gZXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQuc3JjRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IGV2ZW50LnByZXZlbnREZWZhdWx0IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGV2ZW50LnN0b3BQcm9wYWdhdGlvbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBoYW5kbGVyLmNhbGwoZWxlbWVudCwgZXZlbnQpO1xuICAgICAgfTtcbiAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoXCJvblwiICsgZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdmFyIGV2ZW50TmFtZSxcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBldmVudE5hbWVzLmxlbmd0aDtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lc1tpXTtcbiAgICAgICAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LmRldGFjaEV2ZW50KFwib25cIiArIGV2ZW50TmFtZSwgaGFuZGxlcldyYXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbi8qKlxuICogSFRNTCBTYW5pdGl6ZXJcbiAqIFJld3JpdGVzIHRoZSBIVE1MIGJhc2VkIG9uIGdpdmVuIHJ1bGVzXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudE9ySHRtbCBIVE1MIFN0cmluZyB0byBiZSBzYW5pdGl6ZWQgT1IgZWxlbWVudCB3aG9zZSBjb250ZW50IHNob3VsZCBiZSBzYW5pdGl6ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcnVsZXNdIExpc3Qgb2YgcnVsZXMgZm9yIHJld3JpdGluZyB0aGUgSFRNTCwgaWYgdGhlcmUncyBubyBydWxlIGZvciBhbiBlbGVtZW50IGl0IHdpbGxcbiAqICAgIGJlIGNvbnZlcnRlZCB0byBhIFwic3BhblwiLiBFYWNoIHJ1bGUgaXMgYSBrZXkvdmFsdWUgcGFpciB3aGVyZSBrZXkgaXMgdGhlIHRhZyB0byBjb252ZXJ0LCBhbmQgdmFsdWUgdGhlXG4gKiAgICBkZXNpcmVkIHN1YnN0aXR1dGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IERvY3VtZW50IG9iamVjdCBpbiB3aGljaCB0byBwYXJzZSB0aGUgaHRtbCwgbmVlZGVkIHRvIHNhbmRib3ggdGhlIHBhcnNpbmdcbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fFN0cmluZ30gRGVwZW5kcyBvbiB0aGUgZWxlbWVudE9ySHRtbCBwYXJhbWV0ZXIuIFdoZW4gaHRtbCB0aGVuIHRoZSBzYW5pdGl6ZWQgaHRtbCBhcyBzdHJpbmcgZWxzZXdpc2UgdGhlIGVsZW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIHZhciB1c2VySFRNTCA9ICc8ZGl2IGlkPVwiZm9vXCIgb25jbGljaz1cImFsZXJ0KDEpO1wiPjxwPjxmb250IGNvbG9yPVwicmVkXCI+Zm9vPC9mb250PjxzY3JpcHQ+YWxlcnQoMSk7PC9zY3JpcHQ+PC9wPjwvZGl2Pic7XG4gKiAgICB3eXNpaHRtbDUuZG9tLnBhcnNlKHVzZXJIVE1MLCB7XG4gKiAgICAgIHRhZ3Mge1xuICogICAgICAgIHA6ICAgICAgXCJkaXZcIiwgICAgICAvLyBSZW5hbWUgcCB0YWdzIHRvIGRpdiB0YWdzXG4gKiAgICAgICAgZm9udDogICBcInNwYW5cIiAgICAgIC8vIFJlbmFtZSBmb250IHRhZ3MgdG8gc3BhbiB0YWdzXG4gKiAgICAgICAgZGl2OiAgICB0cnVlLCAgICAgICAvLyBLZWVwIHRoZW0sIGFsc28gcG9zc2libGUgKHNhbWUgcmVzdWx0IHdoZW4gcGFzc2luZzogXCJkaXZcIiBvciB0cnVlKVxuICogICAgICAgIHNjcmlwdDogdW5kZWZpbmVkICAgLy8gUmVtb3ZlIHNjcmlwdCBlbGVtZW50c1xuICogICAgICB9XG4gKiAgICB9KTtcbiAqICAgIC8vID0+IDxkaXY+PGRpdj48c3Bhbj5mb28gYmFyPC9zcGFuPjwvZGl2PjwvZGl2PlxuICpcbiAqICAgIHZhciB1c2VySFRNTCA9ICc8dGFibGU+PHRib2R5Pjx0cj48dGQ+SSdtIGEgdGFibGUhPC90ZD48L3RyPjwvdGJvZHk+PC90YWJsZT4nO1xuICogICAgd3lzaWh0bWw1LmRvbS5wYXJzZSh1c2VySFRNTCk7XG4gKiAgICAvLyA9PiAnPHNwYW4+PHNwYW4+PHNwYW4+PHNwYW4+SSdtIGEgdGFibGUhPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPidcbiAqXG4gKiAgICB2YXIgdXNlckhUTUwgPSAnPGRpdj5mb29iYXI8YnI+Zm9vYmFyPC9kaXY+JztcbiAqICAgIHd5c2lodG1sNS5kb20ucGFyc2UodXNlckhUTUwsIHtcbiAqICAgICAgdGFnczoge1xuICogICAgICAgIGRpdjogdW5kZWZpbmVkLFxuICogICAgICAgIGJyOiAgdHJ1ZVxuICogICAgICB9XG4gKiAgICB9KTtcbiAqICAgIC8vID0+ICcnXG4gKlxuICogICAgdmFyIHVzZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJyZWRcIj5mb288L2Rpdj48ZGl2IGNsYXNzPVwicGlua1wiPmJhcjwvZGl2Pic7XG4gKiAgICB3eXNpaHRtbDUuZG9tLnBhcnNlKHVzZXJIVE1MLCB7XG4gKiAgICAgIGNsYXNzZXM6IHtcbiAqICAgICAgICByZWQ6ICAgIDEsXG4gKiAgICAgICAgZ3JlZW46ICAxXG4gKiAgICAgIH0sXG4gKiAgICAgIHRhZ3M6IHtcbiAqICAgICAgICBkaXY6IHtcbiAqICAgICAgICAgIHJlbmFtZV90YWc6ICAgICBcInBcIlxuICogICAgICAgIH1cbiAqICAgICAgfVxuICogICAgfSk7XG4gKiAgICAvLyA9PiAnPHAgY2xhc3M9XCJyZWRcIj5mb288L3A+PHA+YmFyPC9wPidcbiAqL1xud3lzaWh0bWw1LmRvbS5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGEgWE1MUGFyc2VyL0RPTVBhcnNlciBhcyBIVE1MNSBpcyBub3QgYWx3YXlzIHdlbGwtZm9ybWVkIFhNTFxuICAgKiBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKCc8aW1nIHNyYz1cImZvby5naWZcIj4nKSB3aWxsIGNhdXNlIGEgcGFyc2VFcnJvciBzaW5jZSB0aGVcbiAgICogbm9kZSBpc24ndCBjbG9zZWRcbiAgICpcbiAgICogVGhlcmVmb3JlIHdlJ3ZlIHRvIHVzZSB0aGUgYnJvd3NlcidzIG9yZGluYXJ5IEhUTUwgcGFyc2VyIGludm9rZWQgYnkgc2V0dGluZyBpbm5lckhUTUwuXG4gICAqL1xuICB2YXIgTk9ERV9UWVBFX01BUFBJTkcgPSB7XG4gICAgXCIxXCI6IF9oYW5kbGVFbGVtZW50LFxuICAgIFwiM1wiOiBfaGFuZGxlVGV4dFxuICB9LFxuXG4gIC8vIFJlbmFtZSB1bmtub3duIHRhZ3MgdG8gdGhpc1xuICBERUZBVUxUX05PREVfTkFNRSA9IFwic3BhblwiLFxuICAgICAgV0hJVEVfU1BBQ0VfUkVHX0VYUCA9IC9cXHMrLyxcbiAgICAgIGRlZmF1bHRSdWxlcyA9IHsgdGFnczoge30sIGNsYXNzZXM6IHt9IH0sXG4gICAgICBjdXJyZW50UnVsZXMgPSB7fTtcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBhbGwgY2hpbGRzIG9mIHRoZSBlbGVtZW50LCByZWNyZWF0ZXMgdGhlbSwgYXBwZW5kcyB0aGVtIGludG8gYSBkb2N1bWVudCBmcmFnbWVudFxuICAgKiB3aGljaCBsYXRlciByZXBsYWNlcyB0aGUgZW50aXJlIGJvZHkgY29udGVudFxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2UoZWxlbWVudE9ySHRtbCwgcnVsZXMsIGNvbnRleHQsIGNsZWFuVXApIHtcbiAgICB3eXNpaHRtbDUubGFuZy5vYmplY3QoY3VycmVudFJ1bGVzKS5tZXJnZShkZWZhdWx0UnVsZXMpLm1lcmdlKHJ1bGVzKS5nZXQoKTtcblxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGVsZW1lbnRPckh0bWwub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICB2YXIgZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgaXNTdHJpbmcgPSB0eXBlb2YgZWxlbWVudE9ySHRtbCA9PT0gXCJzdHJpbmdcIixcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgbmV3Tm9kZSxcbiAgICAgICAgZmlyc3RDaGlsZDtcblxuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgZWxlbWVudCA9IHd5c2lodG1sNS5kb20uZ2V0QXNEb20oZWxlbWVudE9ySHRtbCwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50T3JIdG1sO1xuICAgIH1cblxuICAgIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGZpcnN0Q2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgICAgbmV3Tm9kZSA9IF9jb252ZXJ0KGZpcnN0Q2hpbGQsIGNsZWFuVXApO1xuICAgICAgaWYgKG5ld05vZGUpIHtcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgZWxlbWVudCBjb250ZW50c1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcblxuICAgIC8vIEluc2VydCBuZXcgRE9NIHRyZWVcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblxuICAgIHJldHVybiBpc1N0cmluZyA/IHd5c2lodG1sNS5xdWlya3MuZ2V0Q29ycmVjdElubmVySFRNTChlbGVtZW50KSA6IGVsZW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBfY29udmVydChvbGROb2RlLCBjbGVhblVwKSB7XG4gICAgdmFyIG9sZE5vZGVUeXBlID0gb2xkTm9kZS5ub2RlVHlwZSxcbiAgICAgICAgb2xkQ2hpbGRzID0gb2xkTm9kZS5jaGlsZE5vZGVzLFxuICAgICAgICBvbGRDaGlsZHNMZW5ndGggPSBvbGRDaGlsZHMubGVuZ3RoLFxuICAgICAgICBuZXdOb2RlLFxuICAgICAgICBtZXRob2QgPSBOT0RFX1RZUEVfTUFQUElOR1tvbGROb2RlVHlwZV0sXG4gICAgICAgIGkgPSAwO1xuXG4gICAgbmV3Tm9kZSA9IG1ldGhvZCAmJiBtZXRob2Qob2xkTm9kZSk7XG5cbiAgICBpZiAoIW5ld05vZGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBvbGRDaGlsZHNMZW5ndGg7IGkrKykge1xuICAgICAgbmV3Q2hpbGQgPSBfY29udmVydChvbGRDaGlsZHNbaV0sIGNsZWFuVXApO1xuICAgICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICAgIG5ld05vZGUuYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFudXAgc2Vuc2VsZXNzIDxzcGFuPiBlbGVtZW50c1xuICAgIGlmIChjbGVhblVwICYmIG5ld05vZGUuY2hpbGROb2Rlcy5sZW5ndGggPD0gMSAmJiBuZXdOb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IERFRkFVTFRfTk9ERV9OQU1FICYmICFuZXdOb2RlLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3Tm9kZS5maXJzdENoaWxkO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2hhbmRsZUVsZW1lbnQob2xkTm9kZSkge1xuICAgIHZhciBydWxlLFxuICAgICAgICBuZXdOb2RlLFxuICAgICAgICBlbmRUYWcsXG4gICAgICAgIHRhZ1J1bGVzID0gY3VycmVudFJ1bGVzLnRhZ3MsXG4gICAgICAgIG5vZGVOYW1lID0gb2xkTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBzY29wZU5hbWUgPSBvbGROb2RlLnNjb3BlTmFtZTtcblxuICAgIC8qKlxuICAgICAqIFdlIGFscmVhZHkgcGFyc2VkIHRoYXQgZWxlbWVudFxuICAgICAqIGlnbm9yZSBpdCEgKHllcywgdGhpcyBzb21ldGltZXMgaGFwcGVucyBpbiBJRTggd2hlbiB0aGUgaHRtbCBpcyBpbnZhbGlkKVxuICAgICAqL1xuICAgIGlmIChvbGROb2RlLl93eXNpaHRtbDUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBvbGROb2RlLl93eXNpaHRtbDUgPSAxO1xuXG4gICAgaWYgKG9sZE5vZGUuY2xhc3NOYW1lID09PSBcInd5c2lodG1sNS10ZW1wXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElFIGlzIHRoZSBvbmx5IGJyb3dzZXIgd2hvIGRvZXNuJ3QgaW5jbHVkZSB0aGUgbmFtZXNwYWNlIGluIHRoZVxuICAgICAqIG5vZGVOYW1lLCB0aGF0J3Mgd2h5IHdlIGhhdmUgdG8gcHJlcGVuZCBpdCBieSBvdXJzZWx2ZXNcbiAgICAgKiBzY29wZU5hbWUgaXMgYSBwcm9wcmlldGFyeSBJRSBmZWF0dXJlXG4gICAgICogcmVhZCBtb3JlIGhlcmUgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM0Mzg4KHY9dnMuODUpLmFzcHhcbiAgICAgKi9cbiAgICBpZiAoc2NvcGVOYW1lICYmIHNjb3BlTmFtZSAhPSBcIkhUTUxcIikge1xuICAgICAgbm9kZU5hbWUgPSBzY29wZU5hbWUgKyBcIjpcIiArIG5vZGVOYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGFpciBub2RlXG4gICAgICogSUUgaXMgYSBiaXQgYml0Y2h5IHdoZW4gaXQgY29tZXMgdG8gaW52YWxpZCBuZXN0ZWQgbWFya3VwIHdoaWNoIGluY2x1ZGVzIHVuY2xvc2VkIHRhZ3NcbiAgICAgKiBBIDxwPiBkb2Vzbid0IG5lZWQgdG8gYmUgY2xvc2VkIGFjY29yZGluZyBIVE1MNC01IHNwZWMsIHdlIHNpbXBseSByZXBsYWNlIGl0IHdpdGggYSA8ZGl2PiB0byBwcmVzZXJ2ZSBpdHMgY29udGVudCBhbmQgbGF5b3V0XG4gICAgICovXG4gICAgaWYgKFwib3V0ZXJIVE1MXCIgaW4gb2xkTm9kZSkge1xuICAgICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5hdXRvQ2xvc2VzVW5jbG9zZWRUYWdzKCkgJiYgb2xkTm9kZS5ub2RlTmFtZSA9PT0gXCJQXCIgJiYgb2xkTm9kZS5vdXRlckhUTUwuc2xpY2UoLTQpLnRvTG93ZXJDYXNlKCkgIT09IFwiPC9wPlwiKSB7XG4gICAgICAgIG5vZGVOYW1lID0gXCJkaXZcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZU5hbWUgaW4gdGFnUnVsZXMpIHtcbiAgICAgIHJ1bGUgPSB0YWdSdWxlc1tub2RlTmFtZV07XG4gICAgICBpZiAoIXJ1bGUgfHwgcnVsZS5yZW1vdmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJ1bGUgPSB0eXBlb2YgcnVsZSA9PT0gXCJzdHJpbmdcIiA/IHsgcmVuYW1lX3RhZzogcnVsZSB9IDogcnVsZTtcbiAgICB9IGVsc2UgaWYgKG9sZE5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgcnVsZSA9IHsgcmVuYW1lX3RhZzogREVGQVVMVF9OT0RFX05BTUUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIGVtcHR5IHVua25vd24gZWxlbWVudHNcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG5ld05vZGUgPSBvbGROb2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChydWxlLnJlbmFtZV90YWcgfHwgbm9kZU5hbWUpO1xuICAgIF9oYW5kbGVBdHRyaWJ1dGVzKG9sZE5vZGUsIG5ld05vZGUsIHJ1bGUpO1xuXG4gICAgb2xkTm9kZSA9IG51bGw7XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBfaGFuZGxlQXR0cmlidXRlcyhvbGROb2RlLCBuZXdOb2RlLCBydWxlKSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fSxcbiAgICAgICAgLy8gZnJlc2ggbmV3IHNldCBvZiBhdHRyaWJ1dGVzIHRvIHNldCBvbiBuZXdOb2RlXG4gICAgc2V0Q2xhc3MgPSBydWxlLnNldF9jbGFzcyxcbiAgICAgICAgLy8gY2xhc3NlcyB0byBzZXRcbiAgICBhZGRDbGFzcyA9IHJ1bGUuYWRkX2NsYXNzLFxuICAgICAgICAvLyBhZGQgY2xhc3NlcyBiYXNlZCBvbiBleGlzdGluZyBhdHRyaWJ1dGVzXG4gICAgc2V0QXR0cmlidXRlcyA9IHJ1bGUuc2V0X2F0dHJpYnV0ZXMsXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMgdG8gc2V0IG9uIHRoZSBjdXJyZW50IG5vZGVcbiAgICBjaGVja0F0dHJpYnV0ZXMgPSBydWxlLmNoZWNrX2F0dHJpYnV0ZXMsXG4gICAgICAgIC8vIGNoZWNrL2NvbnZlcnQgdmFsdWVzIG9mIGF0dHJpYnV0ZXNcbiAgICBhbGxvd2VkQ2xhc3NlcyA9IGN1cnJlbnRSdWxlcy5jbGFzc2VzLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgY2xhc3NlcyA9IFtdLFxuICAgICAgICBuZXdDbGFzc2VzID0gW10sXG4gICAgICAgIG5ld1VuaXF1ZUNsYXNzZXMgPSBbXSxcbiAgICAgICAgb2xkQ2xhc3NlcyA9IFtdLFxuICAgICAgICBjbGFzc2VzTGVuZ3RoLFxuICAgICAgICBuZXdDbGFzc2VzTGVuZ3RoLFxuICAgICAgICBjdXJyZW50Q2xhc3MsXG4gICAgICAgIG5ld0NsYXNzLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICBuZXdBdHRyaWJ1dGVWYWx1ZSxcbiAgICAgICAgbWV0aG9kO1xuXG4gICAgaWYgKHNldEF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSB3eXNpaHRtbDUubGFuZy5vYmplY3Qoc2V0QXR0cmlidXRlcykuY2xvbmUoKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBdHRyaWJ1dGVzKSB7XG4gICAgICBmb3IgKGF0dHJpYnV0ZU5hbWUgaW4gY2hlY2tBdHRyaWJ1dGVzKSB7XG4gICAgICAgIG1ldGhvZCA9IGF0dHJpYnV0ZUNoZWNrTWV0aG9kc1tjaGVja0F0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV1dO1xuICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5ld0F0dHJpYnV0ZVZhbHVlID0gbWV0aG9kKF9nZXRBdHRyaWJ1dGUob2xkTm9kZSwgYXR0cmlidXRlTmFtZSkpO1xuICAgICAgICBpZiAodHlwZW9mIG5ld0F0dHJpYnV0ZVZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IG5ld0F0dHJpYnV0ZVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNldENsYXNzKSB7XG4gICAgICBjbGFzc2VzLnB1c2goc2V0Q2xhc3MpO1xuICAgIH1cblxuICAgIGlmIChhZGRDbGFzcykge1xuICAgICAgZm9yIChhdHRyaWJ1dGVOYW1lIGluIGFkZENsYXNzKSB7XG4gICAgICAgIG1ldGhvZCA9IGFkZENsYXNzTWV0aG9kc1thZGRDbGFzc1thdHRyaWJ1dGVOYW1lXV07XG4gICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Q2xhc3MgPSBtZXRob2QoX2dldEF0dHJpYnV0ZShvbGROb2RlLCBhdHRyaWJ1dGVOYW1lKSk7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3Q2xhc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjbGFzc2VzLnB1c2gobmV3Q2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgd3lzaWh0bWw1IHRlbXAgY2xhc3MgZG9lc24ndCBnZXQgc3RyaXBwZWQgb3V0XG4gICAgYWxsb3dlZENsYXNzZXNbXCJfd3lzaWh0bWw1LXRlbXAtcGxhY2Vob2xkZXJcIl0gPSAxO1xuXG4gICAgLy8gYWRkIG9sZCBjbGFzc2VzIGxhc3RcbiAgICBvbGRDbGFzc2VzID0gb2xkTm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICBpZiAob2xkQ2xhc3Nlcykge1xuICAgICAgY2xhc3NlcyA9IGNsYXNzZXMuY29uY2F0KG9sZENsYXNzZXMuc3BsaXQoV0hJVEVfU1BBQ0VfUkVHX0VYUCkpO1xuICAgIH1cbiAgICBjbGFzc2VzTGVuZ3RoID0gY2xhc3Nlcy5sZW5ndGg7XG4gICAgZm9yICg7IGkgPCBjbGFzc2VzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1cnJlbnRDbGFzcyA9IGNsYXNzZXNbaV07XG4gICAgICBpZiAoYWxsb3dlZENsYXNzZXNbY3VycmVudENsYXNzXSkge1xuICAgICAgICBuZXdDbGFzc2VzLnB1c2goY3VycmVudENsYXNzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgZHVwbGljYXRlIGVudHJpZXMgYW5kIHByZXNlcnZlIGNsYXNzIHNwZWNpZmljaXR5XG4gICAgbmV3Q2xhc3Nlc0xlbmd0aCA9IG5ld0NsYXNzZXMubGVuZ3RoO1xuICAgIHdoaWxlIChuZXdDbGFzc2VzTGVuZ3RoLS0pIHtcbiAgICAgIGN1cnJlbnRDbGFzcyA9IG5ld0NsYXNzZXNbbmV3Q2xhc3Nlc0xlbmd0aF07XG4gICAgICBpZiAoIXd5c2lodG1sNS5sYW5nLmFycmF5KG5ld1VuaXF1ZUNsYXNzZXMpLmNvbnRhaW5zKGN1cnJlbnRDbGFzcykpIHtcbiAgICAgICAgbmV3VW5pcXVlQ2xhc3Nlcy51bnNoaWZ0KGN1cnJlbnRDbGFzcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld1VuaXF1ZUNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICBhdHRyaWJ1dGVzW1wiY2xhc3NcIl0gPSBuZXdVbmlxdWVDbGFzc2VzLmpvaW4oXCIgXCIpO1xuICAgIH1cblxuICAgIC8vIHNldCBhdHRyaWJ1dGVzIG9uIG5ld05vZGVcbiAgICBmb3IgKGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgLy8gU2V0dGluZyBhdHRyaWJ1dGVzIGNhbiBjYXVzZSBhIGpzIGVycm9yIGluIElFIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlc1xuICAgICAgLy8gZWcuIG9uIGEgPGltZz4gdW5kZXIgaHR0cHMgd2hlbiBpdCdzIG5ldyBhdHRyaWJ1dGUgdmFsdWUgaXMgbm9uLWh0dHBzXG4gICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSB0aGlzIGZ1cnRoZXIgYW5kIGNoZWNrIGZvciBzbWFydGVyIGhhbmRsaW5nXG4gICAgICB0cnkge1xuICAgICAgICBuZXdOb2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLy8gSUU4IHNvbWV0aW1lcyBsb3NlcyB0aGUgd2lkdGgvaGVpZ2h0IGF0dHJpYnV0ZXMgd2hlbiB0aG9zZSBhcmUgc2V0IGJlZm9yZSB0aGUgXCJzcmNcIlxuICAgIC8vIHNvIHdlIG1ha2Ugc3VyZSB0byBzZXQgdGhlbSBhZ2FpblxuICAgIGlmIChhdHRyaWJ1dGVzLnNyYykge1xuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLndpZHRoICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG5ld05vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgYXR0cmlidXRlcy53aWR0aCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMuaGVpZ2h0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG5ld05vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGF0dHJpYnV0ZXMuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSUUgZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgaGFzQXR0cmlidXRlL2dldEF0dHJpYnV0ZSwgZm9yIGV4YW1wbGU6XG4gICAqICAgIHZhciB0ZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiKTtcbiAgICogICAgdGQuZ2V0QXR0cmlidXRlKFwicm93c3BhblwiKTsgLy8gPT4gXCIxXCIgaW4gSUVcbiAgICpcbiAgICogVGhlcmVmb3JlIHdlIGhhdmUgdG8gY2hlY2sgdGhlIGVsZW1lbnQncyBvdXRlckhUTUwgZm9yIHRoZSBhdHRyaWJ1dGVcbiAgICovXG4gIHZhciBIQVNfR0VUX0FUVFJJQlVURV9CVUcgPSAhd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNHZXRBdHRyaWJ1dGVDb3JyZWN0bHkoKTtcbiAgZnVuY3Rpb24gX2dldEF0dHJpYnV0ZShub2RlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lO1xuICAgIGlmIChub2RlTmFtZSA9PSBcIklNR1wiICYmIGF0dHJpYnV0ZU5hbWUgPT0gXCJzcmNcIiAmJiBfaXNMb2FkZWRJbWFnZShub2RlKSA9PT0gdHJ1ZSkge1xuICAgICAgLy8gR2V0ICdzcmMnIGF0dHJpYnV0ZSB2YWx1ZSB2aWEgb2JqZWN0IHByb3BlcnR5IHNpbmNlIHRoaXMgd2lsbCBhbHdheXMgY29udGFpbiB0aGVcbiAgICAgIC8vIGZ1bGwgYWJzb2x1dGUgdXJsIChodHRwOi8vLi4uKVxuICAgICAgLy8gdGhpcyBmaXhlcyBhIHZlcnkgYW5ub3lpbmcgYnVnIGluIGZpcmVmb3ggKHZlciAzLjYgJiA0KSBhbmQgSUUgOCB3aGVyZSBpbWFnZXMgY29waWVkIGZyb20gdGhlIHNhbWUgaG9zdFxuICAgICAgLy8gd2lsbCBoYXZlIHJlbGF0aXZlIHBhdGhzLCB3aGljaCB0aGUgc2FuaXRpemVyIHN0cmlwcyBvdXQgKHNlZSBhdHRyaWJ1dGVDaGVja01ldGhvZHMudXJsKVxuICAgICAgcmV0dXJuIG5vZGUuc3JjO1xuICAgIH0gZWxzZSBpZiAoSEFTX0dFVF9BVFRSSUJVVEVfQlVHICYmIFwib3V0ZXJIVE1MXCIgaW4gbm9kZSkge1xuICAgICAgLy8gRG9uJ3QgdHJ1c3QgZ2V0QXR0cmlidXRlL2hhc0F0dHJpYnV0ZSBpbiBJRSA2LTgsIGluc3RlYWQgY2hlY2sgdGhlIGVsZW1lbnQncyBvdXRlckhUTUxcbiAgICAgIHZhciBvdXRlckhUTUwgPSBub2RlLm91dGVySFRNTC50b0xvd2VyQ2FzZSgpLFxuXG4gICAgICAvLyBUT0RPOiBUaGlzIG1pZ2h0IG5vdCB3b3JrIGZvciBhdHRyaWJ1dGVzIHdpdGhvdXQgdmFsdWU6IDxpbnB1dCBkaXNhYmxlZD5cbiAgICAgIGhhc0F0dHJpYnV0ZSA9IG91dGVySFRNTC5pbmRleE9mKFwiIFwiICsgYXR0cmlidXRlTmFtZSArIFwiPVwiKSAhPSAtMTtcblxuICAgICAgcmV0dXJuIGhhc0F0dHJpYnV0ZSA/IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIGlzIGEgcHJvcGVyIGxvYWRlZCBpbWFnZVxuICAgKiBGSVhNRTogUmV0dXJucyB1bmRlZmluZWQgd2hlbiB1bmtub3duIChDaHJvbWUsIFNhZmFyaSlcbiAgICovXG4gIGZ1bmN0aW9uIF9pc0xvYWRlZEltYWdlKG5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5vZGUuY29tcGxldGUgJiYgIW5vZGUubW96TWF0Y2hlc1NlbGVjdG9yKFwiOi1tb3otYnJva2VuXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChub2RlLmNvbXBsZXRlICYmIG5vZGUucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9oYW5kbGVUZXh0KG9sZE5vZGUpIHtcbiAgICByZXR1cm4gb2xkTm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG9sZE5vZGUuZGF0YSk7XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0gYXR0cmlidXRlIGNoZWNrcyAtLS0tLS0tLS0tLS0gXFxcXFxuICB2YXIgYXR0cmlidXRlQ2hlY2tNZXRob2RzID0ge1xuICAgIHVybDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIFJFR19FWFAgPSAvXmh0dHBzPzpcXC9cXC8vaTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCAhYXR0cmlidXRlVmFsdWUubWF0Y2goUkVHX0VYUCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWUucmVwbGFjZShSRUdfRVhQLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0oKSxcblxuICAgIGFsdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIFJFR19FWFAgPSAvW14gYS16MC05X1xcLV0vZ2k7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIGlmICghYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWUucmVwbGFjZShSRUdfRVhQLCBcIlwiKTtcbiAgICAgIH07XG4gICAgfSgpLFxuXG4gICAgbnVtYmVyczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIFJFR19FWFAgPSAvXFxEL2c7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gKGF0dHJpYnV0ZVZhbHVlIHx8IFwiXCIpLnJlcGxhY2UoUkVHX0VYUCwgXCJcIik7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZSB8fCBudWxsO1xuICAgICAgfTtcbiAgICB9KClcbiAgfTtcblxuICAvLyAtLS0tLS0tLS0tLS0gY2xhc3MgY29udmVydGVyIChjb252ZXJ0cyBhbiBodG1sIGF0dHJpYnV0ZSB0byBhIGNsYXNzIG5hbWUpIC0tLS0tLS0tLS0tLSBcXFxcXG4gIHZhciBhZGRDbGFzc01ldGhvZHMgPSB7XG4gICAgYWxpZ25faW1nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgbGVmdDogXCJ3eXNpd3lnLWZsb2F0LWxlZnRcIixcbiAgICAgICAgcmlnaHQ6IFwid3lzaXd5Zy1mbG9hdC1yaWdodFwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWFwcGluZ1tTdHJpbmcoYXR0cmlidXRlVmFsdWUpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgfTtcbiAgICB9KCksXG5cbiAgICBhbGlnbl90ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgbGVmdDogXCJ3eXNpd3lnLXRleHQtYWxpZ24tbGVmdFwiLFxuICAgICAgICByaWdodDogXCJ3eXNpd3lnLXRleHQtYWxpZ24tcmlnaHRcIixcbiAgICAgICAgY2VudGVyOiBcInd5c2l3eWctdGV4dC1hbGlnbi1jZW50ZXJcIixcbiAgICAgICAganVzdGlmeTogXCJ3eXNpd3lnLXRleHQtYWxpZ24tanVzdGlmeVwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWFwcGluZ1tTdHJpbmcoYXR0cmlidXRlVmFsdWUpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgfTtcbiAgICB9KCksXG5cbiAgICBjbGVhcl9icjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgIGxlZnQ6IFwid3lzaXd5Zy1jbGVhci1sZWZ0XCIsXG4gICAgICAgIHJpZ2h0OiBcInd5c2l3eWctY2xlYXItcmlnaHRcIixcbiAgICAgICAgYm90aDogXCJ3eXNpd3lnLWNsZWFyLWJvdGhcIixcbiAgICAgICAgYWxsOiBcInd5c2l3eWctY2xlYXItYm90aFwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWFwcGluZ1tTdHJpbmcoYXR0cmlidXRlVmFsdWUpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgfTtcbiAgICB9KCksXG5cbiAgICBzaXplX2ZvbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICBcIjFcIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS14eC1zbWFsbFwiLFxuICAgICAgICBcIjJcIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS1zbWFsbFwiLFxuICAgICAgICBcIjNcIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS1tZWRpdW1cIixcbiAgICAgICAgXCI0XCI6IFwid3lzaXd5Zy1mb250LXNpemUtbGFyZ2VcIixcbiAgICAgICAgXCI1XCI6IFwid3lzaXd5Zy1mb250LXNpemUteC1sYXJnZVwiLFxuICAgICAgICBcIjZcIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS14eC1sYXJnZVwiLFxuICAgICAgICBcIjdcIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS14eC1sYXJnZVwiLFxuICAgICAgICBcIi1cIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS1zbWFsbGVyXCIsXG4gICAgICAgIFwiK1wiOiBcInd5c2l3eWctZm9udC1zaXplLWxhcmdlclwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWFwcGluZ1tTdHJpbmcoYXR0cmlidXRlVmFsdWUpLmNoYXJBdCgwKV07XG4gICAgICB9O1xuICAgIH0oKVxuICB9O1xuXG4gIHJldHVybiBwYXJzZTtcbn0oKTsgLyoqXG4gICAgICogQ2hlY2tzIGZvciBlbXB0eSB0ZXh0IG5vZGUgY2hpbGRzIGFuZCByZW1vdmVzIHRoZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBUaGUgZWxlbWVudCBpbiB3aGljaCB0byBjbGVhbnVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB3eXNpaHRtbDUuZG9tLnJlbW92ZUVtcHR5VGV4dE5vZGVzKGVsZW1lbnQpO1xuICAgICAqL1xud3lzaWh0bWw1LmRvbS5yZW1vdmVFbXB0eVRleHROb2RlcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBjaGlsZE5vZGUsXG4gICAgICBjaGlsZE5vZGVzID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkobm9kZS5jaGlsZE5vZGVzKS5nZXQoKSxcbiAgICAgIGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgIGkgPSAwO1xuICBmb3IgKDsgaSA8IGNoaWxkTm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gd3lzaWh0bWw1LlRFWFRfTk9ERSAmJiBjaGlsZE5vZGUuZGF0YSA9PT0gXCJcIikge1xuICAgICAgY2hpbGROb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGROb2RlKTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIFJlbmFtZXMgYW4gZWxlbWVudCAoZWcuIGEgPGRpdj4gdG8gYSA8cD4pIGFuZCBrZWVwcyBpdHMgY2hpbGRzXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBsaXN0IGVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmFtZWRcbiAqIEBwYXJhbSB7RWxlbWVudH0gbmV3Tm9kZU5hbWUgVGhlIGRlc2lyZWQgdGFnIG5hbWVcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgPCEtLSBBc3N1bWUgdGhlIGZvbGxvd2luZyBkb206IC0tPlxuICogICAgPHVsIGlkPVwibGlzdFwiPlxuICogICAgICA8bGk+ZW1pbmVtPC9saT5cbiAqICAgICAgPGxpPmRyLiBkcmU8L2xpPlxuICogICAgICA8bGk+NTAgQ2VudDwvbGk+XG4gKiAgICA8L3VsPlxuICpcbiAqICAgIDxzY3JpcHQ+XG4gKiAgICAgIHd5c2lodG1sNS5kb20ucmVuYW1lRWxlbWVudChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxpc3RcIiksIFwib2xcIik7XG4gKiAgICA8L3NjcmlwdD5cbiAqXG4gKiAgICA8IS0tIFdpbGwgcmVzdWx0IGluOiAtLT5cbiAqICAgIDxvbD5cbiAqICAgICAgPGxpPmVtaW5lbTwvbGk+XG4gKiAgICAgIDxsaT5kci4gZHJlPC9saT5cbiAqICAgICAgPGxpPjUwIENlbnQ8L2xpPlxuICogICAgPC9vbD5cbiAqL1xud3lzaWh0bWw1LmRvbS5yZW5hbWVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5ld05vZGVOYW1lKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmV3Tm9kZU5hbWUpLFxuICAgICAgZmlyc3RDaGlsZDtcbiAgd2hpbGUgKGZpcnN0Q2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICBuZXdFbGVtZW50LmFwcGVuZENoaWxkKGZpcnN0Q2hpbGQpO1xuICB9XG4gIHd5c2lodG1sNS5kb20uY29weUF0dHJpYnV0ZXMoW1wiYWxpZ25cIiwgXCJjbGFzc05hbWVcIl0pLmZyb20oZWxlbWVudCkudG8obmV3RWxlbWVudCk7XG4gIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3RWxlbWVudCwgZWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufTsgLyoqXG4gICAqIFRha2VzIGFuIGVsZW1lbnQsIHJlbW92ZXMgaXQgYW5kIHJlcGxhY2VzIGl0IHdpdGggaXQncyBjaGlsZHNcbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIFRoZSBub2RlIHdoaWNoIHRvIHJlcGxhY2Ugd2l0aCBpdCdzIGNoaWxkIG5vZGVzXG4gICAqIEBleGFtcGxlXG4gICAqICAgIDxkaXYgaWQ9XCJmb29cIj5cbiAgICogICAgICA8c3Bhbj5oZWxsbzwvc3Bhbj5cbiAgICogICAgPC9kaXY+XG4gICAqICAgIDxzY3JpcHQ+XG4gICAqICAgICAgLy8gUmVtb3ZlICNmb28gYW5kIHJlcGxhY2Ugd2l0aCBpdCdzIGNoaWxkcmVuXG4gICAqICAgICAgd3lzaWh0bWw1LmRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXMoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmb29cIikpO1xuICAgKiAgICA8L3NjcmlwdD5cbiAgICovXG53eXNpaHRtbDUuZG9tLnJlcGxhY2VXaXRoQ2hpbGROb2RlcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICghbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZyYWdtZW50ID0gbm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gIH1cbiAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChmcmFnbWVudCwgbm9kZSk7XG4gIG5vZGUgPSBmcmFnbWVudCA9IG51bGw7XG59O1xuLyoqXG4gKiBVbndyYXBzIGFuIHVub3JkZXJlZC9vcmRlcmVkIGxpc3RcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGxpc3QgZWxlbWVudCB3aGljaCBzaG91bGQgYmUgdW53cmFwcGVkXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIDwhLS0gQXNzdW1lIHRoZSBmb2xsb3dpbmcgZG9tOiAtLT5cbiAqICAgIDx1bCBpZD1cImxpc3RcIj5cbiAqICAgICAgPGxpPmVtaW5lbTwvbGk+XG4gKiAgICAgIDxsaT5kci4gZHJlPC9saT5cbiAqICAgICAgPGxpPjUwIENlbnQ8L2xpPlxuICogICAgPC91bD5cbiAqXG4gKiAgICA8c2NyaXB0PlxuICogICAgICB3eXNpaHRtbDUuZG9tLnJlc29sdmVMaXN0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGlzdFwiKSk7XG4gKiAgICA8L3NjcmlwdD5cbiAqXG4gKiAgICA8IS0tIFdpbGwgcmVzdWx0IGluOiAtLT5cbiAqICAgIGVtaW5lbTxicj5cbiAqICAgIGRyLiBkcmU8YnI+XG4gKiAgICA1MCBDZW50PGJyPlxuICovXG4oZnVuY3Rpb24gKGRvbSkge1xuICBmdW5jdGlvbiBfaXNCbG9ja0VsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBkb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20obm9kZSkgPT09IFwiYmxvY2tcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pc0xpbmVCcmVhayhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09IFwiQlJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcHBlbmRMaW5lQnJlYWsoZWxlbWVudCkge1xuICAgIHZhciBsaW5lQnJlYWsgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQobGluZUJyZWFrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVMaXN0KGxpc3QpIHtcbiAgICBpZiAobGlzdC5ub2RlTmFtZSAhPT0gXCJNRU5VXCIgJiYgbGlzdC5ub2RlTmFtZSAhPT0gXCJVTFwiICYmIGxpc3Qubm9kZU5hbWUgIT09IFwiT0xcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkb2MgPSBsaXN0Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgIGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgcHJldmlvdXNTaWJsaW5nID0gbGlzdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIHx8IGxpc3QucHJldmlvdXNTaWJsaW5nLFxuICAgICAgICBmaXJzdENoaWxkLFxuICAgICAgICBsYXN0Q2hpbGQsXG4gICAgICAgIGlzTGFzdENoaWxkLFxuICAgICAgICBzaG91bGRBcHBlbmRMaW5lQnJlYWssXG4gICAgICAgIGxpc3RJdGVtO1xuXG4gICAgaWYgKHByZXZpb3VzU2libGluZyAmJiAhX2lzQmxvY2tFbGVtZW50KHByZXZpb3VzU2libGluZykpIHtcbiAgICAgIF9hcHBlbmRMaW5lQnJlYWsoZnJhZ21lbnQpO1xuICAgIH1cblxuICAgIHdoaWxlIChsaXN0SXRlbSA9IGxpc3QuZmlyc3RDaGlsZCkge1xuICAgICAgbGFzdENoaWxkID0gbGlzdEl0ZW0ubGFzdENoaWxkO1xuICAgICAgd2hpbGUgKGZpcnN0Q2hpbGQgPSBsaXN0SXRlbS5maXJzdENoaWxkKSB7XG4gICAgICAgIGlzTGFzdENoaWxkID0gZmlyc3RDaGlsZCA9PT0gbGFzdENoaWxkO1xuICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgYmVmb3JlIGFwcGVuZGluZyBpdCB0byB0aGUgZnJhZ21lbnQsIGFzIGl0IG90aGVyd2lzZSB3aWxsIGxvb3NlIHN0eWxlIGluZm9ybWF0aW9uXG4gICAgICAgIHNob3VsZEFwcGVuZExpbmVCcmVhayA9IGlzTGFzdENoaWxkICYmICFfaXNCbG9ja0VsZW1lbnQoZmlyc3RDaGlsZCkgJiYgIV9pc0xpbmVCcmVhayhmaXJzdENoaWxkKTtcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgICAgIGlmIChzaG91bGRBcHBlbmRMaW5lQnJlYWspIHtcbiAgICAgICAgICBfYXBwZW5kTGluZUJyZWFrKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0SXRlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpc3RJdGVtKTtcbiAgICB9XG4gICAgbGlzdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChmcmFnbWVudCwgbGlzdCk7XG4gIH1cblxuICBkb20ucmVzb2x2ZUxpc3QgPSByZXNvbHZlTGlzdDtcbn0pKHd5c2lodG1sNS5kb20pOyAvKipcbiAgICAgICAgICAgICAgICAgICAqIFNhbmRib3ggZm9yIGV4ZWN1dGluZyBqYXZhc2NyaXB0LCBwYXJzaW5nIGNzcyBzdHlsZXMgYW5kIGRvaW5nIGRvbSBvcGVyYXRpb25zIGluIGEgc2VjdXJlIHdheVxuICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAqIEJyb3dzZXIgQ29tcGF0aWJpbGl0eTpcbiAgICAgICAgICAgICAgICAgICAqICAtIFNlY3VyZSBpbiBNU0lFIDYrLCBidXQgb25seSB3aGVuIHRoZSB1c2VyIGhhc24ndCBtYWRlIGNoYW5nZXMgdG8gaGlzIHNlY3VyaXR5IGxldmVsIFwicmVzdHJpY3RlZFwiXG4gICAgICAgICAgICAgICAgICAgKiAgLSBQYXJ0aWFsbHkgc2VjdXJlIGluIG90aGVyIGJyb3dzZXJzIChGaXJlZm94LCBPcGVyYSwgU2FmYXJpLCBDaHJvbWUsIC4uLilcbiAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgY2xhc3MgY2FuJ3QgYmVuZWZpdCBmcm9tIHRoZSBIVE1MNSBzYW5kYm94IGF0dHJpYnV0ZSBmb3IgdGhlIGZvbGxvd2luZyByZWFzb25zOlxuICAgICAgICAgICAgICAgICAgICogICAgLSBzYW5kYm94aW5nIGRvZXNuJ3Qgd29yayBjb3JyZWN0bHkgd2l0aCBpbmxpbmVkIGNvbnRlbnQgKHNyYz1cImphdmFzY3JpcHQ6JzxodG1sPi4uLjwvaHRtbD4nXCIpXG4gICAgICAgICAgICAgICAgICAgKiAgICAtIHNhbmRib3hpbmcgb2YgcGh5c2ljYWwgZG9jdW1lbnRzIGNhdXNlcyB0aGF0IHRoZSBkb20gaXNuJ3QgYWNjZXNzaWJsZSBhbnltb3JlIGZyb20gdGhlIG91dHNpZGUgKGlmcmFtZS5jb250ZW50V2luZG93LCAuLi4pXG4gICAgICAgICAgICAgICAgICAgKiAgICAtIHNldHRpbmcgdGhlIFwiYWxsb3ctc2FtZS1vcmlnaW5cIiBmbGFnIHdvdWxkIGZpeCB0aGF0LCBidXQgdGhlbiBzdGlsbCBqYXZhc2NyaXB0IGFuZCBkb20gZXZlbnRzIHJlZnVzZSB0byBmaXJlXG4gICAgICAgICAgICAgICAgICAgKiAgICAtIHRoZXJlZm9yZSB0aGUgXCJhbGxvdy1zY3JpcHRzXCIgZmxhZyBpcyBuZWVkZWQsIHdoaWNoIHRoZW4gd291bGQgZGVhY3RpdmF0ZSBhbnkgc2VjdXJpdHksIGFzIHRoZSBqcyBleGVjdXRlZCBpbnNpZGUgdGhlIGlmcmFtZVxuICAgICAgICAgICAgICAgICAgICogICAgICBjYW4gZG8gYW55dGhpbmcgYXMgaWYgdGhlIHNhbmRib3ggYXR0cmlidXRlIHdhc24ndCBzZXRcbiAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVhZHlDYWxsYmFja10gTWV0aG9kIHRoYXQgZ2V0cyBpbnZva2VkIHdoZW4gdGhlIHNhbmRib3ggaXMgcmVhZHlcbiAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAqICAgIG5ldyB3eXNpaHRtbDUuZG9tLlNhbmRib3goZnVuY3Rpb24oc2FuZGJveCkge1xuICAgICAgICAgICAgICAgICAgICogICAgICBzYW5kYm94LmdldFdpbmRvdygpLmRvY3VtZW50LmJvZHkuaW5uZXJIVE1MID0gJzxpbWcgc3JjPWZvby5naWYgb25lcnJvcj1cImFsZXJ0KGRvY3VtZW50LmNvb2tpZSlcIj4nO1xuICAgICAgICAgICAgICAgICAgICogICAgfSk7XG4gICAgICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciAvKipcbiAgICAgICAqIERlZmF1bHQgY29uZmlndXJhdGlvblxuICAgICAgICovXG4gIGRvYyA9IGRvY3VtZW50LFxuXG4gIC8qKlxuICAgKiBQcm9wZXJ0aWVzIHRvIHVuc2V0L3Byb3RlY3Qgb24gdGhlIHdpbmRvdyBvYmplY3RcbiAgICovXG4gIHdpbmRvd1Byb3BlcnRpZXMgPSBbXCJwYXJlbnRcIiwgXCJ0b3BcIiwgXCJvcGVuZXJcIiwgXCJmcmFtZUVsZW1lbnRcIiwgXCJmcmFtZXNcIiwgXCJsb2NhbFN0b3JhZ2VcIiwgXCJnbG9iYWxTdG9yYWdlXCIsIFwic2Vzc2lvblN0b3JhZ2VcIiwgXCJpbmRleGVkREJcIl0sXG5cbiAgLyoqXG4gICAqIFByb3BlcnRpZXMgb24gdGhlIHdpbmRvdyBvYmplY3Qgd2hpY2ggYXJlIHNldCB0byBhbiBlbXB0eSBmdW5jdGlvblxuICAgKi9cbiAgd2luZG93UHJvcGVydGllczIgPSBbXCJvcGVuXCIsIFwiY2xvc2VcIiwgXCJvcGVuRGlhbG9nXCIsIFwic2hvd01vZGFsRGlhbG9nXCIsIFwiYWxlcnRcIiwgXCJjb25maXJtXCIsIFwicHJvbXB0XCIsIFwib3BlbkRhdGFiYXNlXCIsIFwicG9zdE1lc3NhZ2VcIiwgXCJYTUxIdHRwUmVxdWVzdFwiLCBcIlhEb21haW5SZXF1ZXN0XCJdLFxuXG4gIC8qKlxuICAgKiBQcm9wZXJ0aWVzIHRvIHVuc2V0L3Byb3RlY3Qgb24gdGhlIGRvY3VtZW50IG9iamVjdFxuICAgKi9cbiAgZG9jdW1lbnRQcm9wZXJ0aWVzID0gW1wicmVmZXJyZXJcIiwgXCJ3cml0ZVwiLCBcIm9wZW5cIiwgXCJjbG9zZVwiXTtcblxuICB3eXNpaHRtbDUuZG9tLlNhbmRib3ggPSBCYXNlLmV4dGVuZChcbiAgLyoqIEBzY29wZSB3eXNpaHRtbDUuZG9tLlNhbmRib3gucHJvdG90eXBlICove1xuXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKHJlYWR5Q2FsbGJhY2ssIGNvbmZpZykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IHJlYWR5Q2FsbGJhY2sgfHwgd3lzaWh0bWw1LkVNUFRZX0ZVTkNUSU9OO1xuICAgICAgdGhpcy5jb25maWcgPSB3eXNpaHRtbDUubGFuZy5vYmplY3Qoe30pLm1lcmdlKGNvbmZpZykuZ2V0KCk7XG4gICAgICB0aGlzLmlmcmFtZSA9IHRoaXMuX2NyZWF0ZUlmcmFtZSgpO1xuICAgIH0sXG5cbiAgICBpbnNlcnRJbnRvOiBmdW5jdGlvbiBpbnNlcnRJbnRvKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBlbGVtZW50ID0gZG9jLmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaWZyYW1lKTtcbiAgICB9LFxuXG4gICAgZ2V0SWZyYW1lOiBmdW5jdGlvbiBnZXRJZnJhbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pZnJhbWU7XG4gICAgfSxcblxuICAgIGdldFdpbmRvdzogZnVuY3Rpb24gZ2V0V2luZG93KCkge1xuICAgICAgdGhpcy5fcmVhZHlFcnJvcigpO1xuICAgIH0sXG5cbiAgICBnZXREb2N1bWVudDogZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XG4gICAgICB0aGlzLl9yZWFkeUVycm9yKCk7XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgaWZyYW1lID0gdGhpcy5nZXRJZnJhbWUoKTtcbiAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSxcblxuICAgIF9yZWFkeUVycm9yOiBmdW5jdGlvbiBfcmVhZHlFcnJvcigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInd5c2lodG1sNS5TYW5kYm94OiBTYW5kYm94IGlmcmFtZSBpc24ndCBsb2FkZWQgeWV0XCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBzYW5kYm94IGlmcmFtZVxuICAgICAqXG4gICAgICogU29tZSBpbXBvcnRhbnQgbm90ZXM6XG4gICAgICogIC0gV2UgY2FuJ3QgdXNlIEhUTUw1IHNhbmRib3ggZm9yIG5vdzpcbiAgICAgKiAgICBzZXR0aW5nIGl0IGNhdXNlcyB0aGF0IHRoZSBpZnJhbWUncyBkb20gY2FuJ3QgYmUgYWNjZXNzZWQgZnJvbSB0aGUgb3V0c2lkZVxuICAgICAqICAgIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHNldCB0aGUgXCJhbGxvdy1zYW1lLW9yaWdpblwiIGZsYWcgd2hpY2ggZW5hYmxlcyBhY2Nlc3NpbmcgdGhlIGlmcmFtZSdzIGRvbVxuICAgICAqICAgIEJ1dCB0aGVuIHRoZXJlJ3MgYW5vdGhlciBwcm9ibGVtLCBET00gZXZlbnRzIChmb2N1cywgYmx1ciwgY2hhbmdlLCBrZXlwcmVzcywgLi4uKSBhcmVuJ3QgZmlyZWQuXG4gICAgICogICAgSW4gb3JkZXIgdG8gbWFrZSB0aGlzIGhhcHBlbiB3ZSBuZWVkIHRvIHNldCB0aGUgXCJhbGxvdy1zY3JpcHRzXCIgZmxhZy5cbiAgICAgKiAgICBBIGNvbWJpbmF0aW9uIG9mIGFsbG93LXNjcmlwdHMgYW5kIGFsbG93LXNhbWUtb3JpZ2luIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyBzZXR0aW5nIG5vIHNhbmRib3ggYXR0cmlidXRlIGF0IGFsbC5cbiAgICAgKiAgLSBDaHJvbWUgJiBTYWZhcmksIGRvZXNuJ3Qgc2VlbSB0byBzdXBwb3J0IHNhbmRib3hpbmcgY29ycmVjdGx5IHdoZW4gdGhlIGlmcmFtZSdzIGh0bWwgaXMgaW5saW5lZCAobm8gcGh5c2ljYWwgZG9jdW1lbnQpXG4gICAgICogIC0gSUUgbmVlZHMgdG8gaGF2ZSB0aGUgc2VjdXJpdHk9XCJyZXN0cmljdGVkXCIgYXR0cmlidXRlIHNldCBiZWZvcmUgdGhlIGlmcmFtZSBpcyBcbiAgICAgKiAgICBpbnNlcnRlZCBpbnRvIHRoZSBkb20gdHJlZVxuICAgICAqICAtIEJlbGlldmUgaXQgb3Igbm90IGJ1dCBpbiBJRSBcInNlY3VyaXR5XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKSBpcyBmYWxzZSwgZXZlblxuICAgICAqICAgIHRob3VnaCBpdCBzdXBwb3J0cyBpdFxuICAgICAqICAtIFdoZW4gYW4gaWZyYW1lIGhhcyBzZWN1cml0eT1cInJlc3RyaWN0ZWRcIiwgaW4gSUUgZXZhbCgpICYgZXhlY1NjcmlwdCgpIGRvbid0IHdvcmsgYW55bW9yZVxuICAgICAqICAtIElFIGRvZXNuJ3QgZmlyZSB0aGUgb25sb2FkIGV2ZW50IHdoZW4gdGhlIGNvbnRlbnQgaXMgaW5saW5lZCBpbiB0aGUgc3JjIGF0dHJpYnV0ZSwgdGhlcmVmb3JlIHdlIHJlbHlcbiAgICAgKiAgICBvbiB0aGUgb25yZWFkeXN0YXRlY2hhbmdlIGV2ZW50XG4gICAgICovXG4gICAgX2NyZWF0ZUlmcmFtZTogZnVuY3Rpb24gX2NyZWF0ZUlmcmFtZSgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBpZnJhbWUgPSBkb2MuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgIGlmcmFtZS5jbGFzc05hbWUgPSBcInd5c2lodG1sNS1zYW5kYm94XCI7XG4gICAgICB3eXNpaHRtbDUuZG9tLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICBcInNlY3VyaXR5XCI6IFwicmVzdHJpY3RlZFwiLFxuICAgICAgICBcImFsbG93dHJhbnNwYXJlbmN5XCI6IFwidHJ1ZVwiLFxuICAgICAgICBcImZyYW1lYm9yZGVyXCI6IDAsXG4gICAgICAgIFwid2lkdGhcIjogMCxcbiAgICAgICAgXCJoZWlnaHRcIjogMCxcbiAgICAgICAgXCJtYXJnaW53aWR0aFwiOiAwLFxuICAgICAgICBcIm1hcmdpbmhlaWdodFwiOiAwXG4gICAgICB9KS5vbihpZnJhbWUpO1xuXG4gICAgICAvLyBTZXR0aW5nIHRoZSBzcmMgbGlrZSB0aGlzIHByZXZlbnRzIHNzbCB3YXJuaW5ncyBpbiBJRTZcbiAgICAgIGlmICh3eXNpaHRtbDUuYnJvd3Nlci50aHJvd3NNaXhlZENvbnRlbnRXYXJuaW5nV2hlbklmcmFtZVNyY0lzRW1wdHkoKSkge1xuICAgICAgICBpZnJhbWUuc3JjID0gXCJqYXZhc2NyaXB0Oic8aHRtbD48L2h0bWw+J1wiO1xuICAgICAgfVxuXG4gICAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIHRoYXQuX29uTG9hZElmcmFtZShpZnJhbWUpO1xuICAgICAgfTtcblxuICAgICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKC9sb2FkZWR8Y29tcGxldGUvLnRlc3QoaWZyYW1lLnJlYWR5U3RhdGUpKSB7XG4gICAgICAgICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgIHRoYXQuX29uTG9hZElmcmFtZShpZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gaWZyYW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBmb3Igd2hlbiB0aGUgaWZyYW1lIGhhcyBmaW5pc2hlZCBsb2FkaW5nXG4gICAgICovXG4gICAgX29uTG9hZElmcmFtZTogZnVuY3Rpb24gX29uTG9hZElmcmFtZShpZnJhbWUpIHtcbiAgICAgIC8vIGRvbid0IHJlc3VtZSB3aGVuIHRoZSBpZnJhbWUgZ290IHVubG9hZGVkIChlZy4gYnkgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgZG9tKVxuICAgICAgaWYgKCF3eXNpaHRtbDUuZG9tLmNvbnRhaW5zKGRvYy5kb2N1bWVudEVsZW1lbnQsIGlmcmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgaWZyYW1lV2luZG93ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3csXG4gICAgICAgICAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudCxcbiAgICAgICAgICBjaGFyc2V0ID0gZG9jLmNoYXJhY3RlclNldCB8fCBkb2MuY2hhcnNldCB8fCBcInV0Zi04XCIsXG4gICAgICAgICAgc2FuZGJveEh0bWwgPSB0aGlzLl9nZXRIdG1sKHtcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgc3R5bGVzaGVldHM6IHRoaXMuY29uZmlnLnN0eWxlc2hlZXRzXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBiYXNpYyBkb20gdHJlZSBpbmNsdWRpbmcgcHJvcGVyIERPQ1RZUEUgYW5kIGNoYXJzZXRcbiAgICAgIGlmcmFtZURvY3VtZW50Lm9wZW4oXCJ0ZXh0L2h0bWxcIiwgXCJyZXBsYWNlXCIpO1xuICAgICAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2FuZGJveEh0bWwpO1xuICAgICAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcblxuICAgICAgdGhpcy5nZXRXaW5kb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpZnJhbWUuY29udGVudFdpbmRvdztcbiAgICAgIH07XG4gICAgICB0aGlzLmdldERvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgICB9O1xuXG4gICAgICAvLyBDYXRjaCBqcyBlcnJvcnMgYW5kIHBhc3MgdGhlbSB0byB0aGUgcGFyZW50J3Mgb25lcnJvciBldmVudFxuICAgICAgLy8gYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIpIGRvZXNuJ3Qgd29yayBwcm9wZXJseSBpbiBzb21lIGJyb3dzZXJzXG4gICAgICAvLyBUT0RPOiBhcHBhcmVudGx5IHRoaXMgZG9lc24ndCB3b3JrIGluIElFOSFcbiAgICAgIGlmcmFtZVdpbmRvdy5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yTWVzc2FnZSwgZmlsZU5hbWUsIGxpbmVOdW1iZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid3lzaWh0bWw1LlNhbmRib3g6IFwiICsgZXJyb3JNZXNzYWdlLCBmaWxlTmFtZSwgbGluZU51bWJlcik7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIXd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzU2FuZGJveGVkSWZyYW1lcygpKSB7XG4gICAgICAgIC8vIFVuc2V0IGEgYnVuY2ggb2Ygc2Vuc2l0aXZlIHZhcmlhYmxlc1xuICAgICAgICAvLyBQbGVhc2Ugbm90ZTogVGhpcyBpc24ndCBoYWNrIHNhZmUhICBcbiAgICAgICAgLy8gSXQgbW9yZSBvciBsZXNzIGp1c3QgdGFrZXMgY2FyZSBvZiBiYXNpYyBhdHRhY2tzIGFuZCBwcmV2ZW50cyBhY2NpZGVudGFsIHRoZWZ0IG9mIHNlbnNpdGl2ZSBpbmZvcm1hdGlvblxuICAgICAgICAvLyBJRSBpcyBzZWN1cmUgdGhvdWdoLCB3aGljaCBpcyB0aGUgbW9zdCBpbXBvcnRhbnQgdGhpbmcsIHNpbmNlIElFIGlzIHRoZSBvbmx5IGJyb3dzZXIsIHdob1xuICAgICAgICAvLyB0YWtlcyBvdmVyIHNjcmlwdHMgJiBzdHlsZXMgaW50byBjb250ZW50RWRpdGFibGUgZWxlbWVudHMgd2hlbiBjb3BpZWQgZnJvbSBleHRlcm5hbCB3ZWJzaXRlc1xuICAgICAgICAvLyBvciBhcHBsaWNhdGlvbnMgKE1pY3Jvc29mdCBXb3JkLCAuLi4pXG4gICAgICAgIHZhciBpLCBsZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHdpbmRvd1Byb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl91bnNldChpZnJhbWVXaW5kb3csIHdpbmRvd1Byb3BlcnRpZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHdpbmRvd1Byb3BlcnRpZXMyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5fdW5zZXQoaWZyYW1lV2luZG93LCB3aW5kb3dQcm9wZXJ0aWVzMltpXSwgd3lzaWh0bWw1LkVNUFRZX0ZVTkNUSU9OKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBkb2N1bWVudFByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl91bnNldChpZnJhbWVEb2N1bWVudCwgZG9jdW1lbnRQcm9wZXJ0aWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGRvZXNuJ3Qgd29yayBpbiBTYWZhcmkgNSBcbiAgICAgICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTkyNDYxL2lzLWl0LXBvc3NpYmxlLXRvLW92ZXJyaWRlLWRvY3VtZW50LWNvb2tpZS1pbi13ZWJraXRcbiAgICAgICAgdGhpcy5fdW5zZXQoaWZyYW1lRG9jdW1lbnQsIFwiY29va2llXCIsIFwiXCIsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG5cbiAgICAgIC8vIFRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5jYWxsYmFjayh0aGF0KTtcbiAgICAgIH0sIDApO1xuICAgIH0sXG5cbiAgICBfZ2V0SHRtbDogZnVuY3Rpb24gX2dldEh0bWwodGVtcGxhdGVWYXJzKSB7XG4gICAgICB2YXIgc3R5bGVzaGVldHMgPSB0ZW1wbGF0ZVZhcnMuc3R5bGVzaGVldHMsXG4gICAgICAgICAgaHRtbCA9IFwiXCIsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbGVuZ3RoO1xuICAgICAgc3R5bGVzaGVldHMgPSB0eXBlb2Ygc3R5bGVzaGVldHMgPT09IFwic3RyaW5nXCIgPyBbc3R5bGVzaGVldHNdIDogc3R5bGVzaGVldHM7XG4gICAgICBpZiAoc3R5bGVzaGVldHMpIHtcbiAgICAgICAgbGVuZ3RoID0gc3R5bGVzaGVldHMubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaHRtbCArPSAnPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIGhyZWY9XCInICsgc3R5bGVzaGVldHNbaV0gKyAnXCI+JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGVtcGxhdGVWYXJzLnN0eWxlc2hlZXRzID0gaHRtbDtcblxuICAgICAgcmV0dXJuIHd5c2lodG1sNS5sYW5nLnN0cmluZygnPCFET0NUWVBFIGh0bWw+PGh0bWw+PGhlYWQ+JyArICc8bWV0YSBjaGFyc2V0PVwiI3tjaGFyc2V0fVwiPiN7c3R5bGVzaGVldHN9PC9oZWFkPicgKyAnPGJvZHk+PC9ib2R5PjwvaHRtbD4nKS5pbnRlcnBvbGF0ZSh0ZW1wbGF0ZVZhcnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gdW5zZXQvb3ZlcnJpZGUgZXhpc3RpbmcgdmFyaWFibGVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAvLyBNYWtlIGNvb2tpZSB1bnJlYWRhYmxlIGFuZCB1bndyaXRhYmxlXG4gICAgICogICAgdGhpcy5fdW5zZXQoZG9jdW1lbnQsIFwiY29va2llXCIsIFwiXCIsIHRydWUpO1xuICAgICAqL1xuICAgIF91bnNldDogZnVuY3Rpb24gX3Vuc2V0KG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBzZXR0ZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG9iamVjdC5fX2RlZmluZUdldHRlcl9fKHByb3BlcnR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb2JqZWN0Ll9fZGVmaW5lU2V0dGVyX18ocHJvcGVydHksIGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cblxuICAgICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5jcmFzaGVzV2hlbkRlZmluZVByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICAgICAgY29uZmlnLnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgY29uZmlnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSkod3lzaWh0bWw1KTtcbihmdW5jdGlvbiAoKSB7XG4gIHZhciBtYXBwaW5nID0ge1xuICAgIFwiY2xhc3NOYW1lXCI6IFwiY2xhc3NcIlxuICB9O1xuICB3eXNpaHRtbDUuZG9tLnNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0cmlidXRlcykge1xuICAgIHJldHVybiB7XG4gICAgICBvbjogZnVuY3Rpb24gb24oZWxlbWVudCkge1xuICAgICAgICBmb3IgKHZhciBpIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShtYXBwaW5nW2ldIHx8IGksIGF0dHJpYnV0ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn0pKCk7d3lzaWh0bWw1LmRvbS5zZXRTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gIHJldHVybiB7XG4gICAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgICBpZiAodHlwZW9mIHN0eWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdHlsZS5jc3NUZXh0ICs9IFwiO1wiICsgc3R5bGVzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpIGluIHN0eWxlcykge1xuICAgICAgICBpZiAoaSA9PT0gXCJmbG9hdFwiKSB7XG4gICAgICAgICAgc3R5bGUuY3NzRmxvYXQgPSBzdHlsZXNbaV07XG4gICAgICAgICAgc3R5bGUuc3R5bGVGbG9hdCA9IHN0eWxlc1tpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZVtpXSA9IHN0eWxlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07IC8qKlxuICAgKiBTaW11bGF0ZSBIVE1MNSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgICpcbiAgICogTmVlZGVkIHNpbmNlXG4gICAqICAgIC0gZGl2W2NvbnRlbnRFZGl0YWJsZV0gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpdFxuICAgKiAgICAtIG9sZGVyIGJyb3dzZXJzIChzdWNoIGFzIElFOCBhbmQgRmlyZWZveCAzLjYpIGRvbid0IHN1cHBvcnQgaXQgYXQgYWxsXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgSW5zdGFuY2Ugb2YgbWFpbiB3eXNpaHRtbDUuRWRpdG9yIGNsYXNzXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdmlldyBJbnN0YW5jZSBvZiB3eXNpaHRtbDUudmlld3MuKiBjbGFzc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcGxhY2Vob2xkZXJUZXh0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgIHd5c2lodG1sLmRvbS5zaW11bGF0ZVBsYWNlaG9sZGVyKHRoaXMsIGNvbXBvc2VyLCBcIkZvb2JhclwiKTtcbiAgICovXG4oZnVuY3Rpb24gKGRvbSkge1xuICBkb20uc2ltdWxhdGVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChlZGl0b3IsIHZpZXcsIHBsYWNlaG9sZGVyVGV4dCkge1xuICAgIHZhciBDTEFTU19OQU1FID0gXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICB1bnNldCA9IGZ1bmN0aW9uIHVuc2V0KCkge1xuICAgICAgaWYgKHZpZXcuaGFzUGxhY2Vob2xkZXJTZXQoKSkge1xuICAgICAgICB2aWV3LmNsZWFyKCk7XG4gICAgICB9XG4gICAgICBkb20ucmVtb3ZlQ2xhc3Modmlldy5lbGVtZW50LCBDTEFTU19OQU1FKTtcbiAgICB9LFxuICAgICAgICBzZXQgPSBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICBpZiAodmlldy5pc0VtcHR5KCkpIHtcbiAgICAgICAgdmlldy5zZXRWYWx1ZShwbGFjZWhvbGRlclRleHQpO1xuICAgICAgICBkb20uYWRkQ2xhc3Modmlldy5lbGVtZW50LCBDTEFTU19OQU1FKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZWRpdG9yLm9ic2VydmUoXCJzZXRfcGxhY2Vob2xkZXJcIiwgc2V0KS5vYnNlcnZlKFwidW5zZXRfcGxhY2Vob2xkZXJcIiwgdW5zZXQpLm9ic2VydmUoXCJmb2N1czpjb21wb3NlclwiLCB1bnNldCkub2JzZXJ2ZShcInBhc3RlOmNvbXBvc2VyXCIsIHVuc2V0KS5vYnNlcnZlKFwiYmx1cjpjb21wb3NlclwiLCBzZXQpO1xuXG4gICAgc2V0KCk7XG4gIH07XG59KSh3eXNpaHRtbDUuZG9tKTtcbihmdW5jdGlvbiAoZG9tKSB7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmIChcInRleHRDb250ZW50XCIgaW4gZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgZG9tLnNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRleHQpIHtcbiAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIH07XG5cbiAgICBkb20uZ2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChcImlubmVyVGV4dFwiIGluIGRvY3VtZW50RWxlbWVudCkge1xuICAgIGRvbS5zZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZXh0KSB7XG4gICAgICBlbGVtZW50LmlubmVyVGV4dCA9IHRleHQ7XG4gICAgfTtcblxuICAgIGRvbS5nZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5pbm5lclRleHQ7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBkb20uc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgdGV4dCkge1xuICAgICAgZWxlbWVudC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgIH07XG5cbiAgICBkb20uZ2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubm9kZVZhbHVlO1xuICAgIH07XG4gIH1cbn0pKHd5c2lodG1sNS5kb20pO1xuXG4vKipcbiAqIEZpeCBtb3N0IGNvbW1vbiBodG1sIGZvcm1hdHRpbmcgbWlzYmVoYXZpb3JzIG9mIGJyb3dzZXJzIGltcGxlbWVudGF0aW9uIHdoZW4gaW5zZXJ0aW5nXG4gKiBjb250ZW50IHZpYSBjb3B5ICYgcGFzdGUgY29udGVudEVkaXRhYmxlXG4gKlxuICogQGF1dGhvciBDaHJpc3RvcGhlciBCbHVtXG4gKi9cbnd5c2lodG1sNS5xdWlya3MuY2xlYW5QYXN0ZWRIVE1MID0gZnVuY3Rpb24gKCkge1xuICAvLyBUT0RPOiBXZSBwcm9iYWJseSBuZWVkIG1vcmUgcnVsZXMgaGVyZVxuICB2YXIgZGVmYXVsdFJ1bGVzID0ge1xuICAgIC8vIFdoZW4gcGFzdGluZyB1bmRlcmxpbmVkIGxpbmtzIDxhPiBpbnRvIGEgY29udGVudEVkaXRhYmxlLCBJRSB0aGlua3MsIGl0IGhhcyB0byBpbnNlcnQgPHU+IHRvIGtlZXAgdGhlIHN0eWxpbmdcbiAgICBcImEgdVwiOiB3eXNpaHRtbDUuZG9tLnJlcGxhY2VXaXRoQ2hpbGROb2Rlc1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNsZWFuUGFzdGVkSFRNTChlbGVtZW50T3JIdG1sLCBydWxlcywgY29udGV4dCkge1xuICAgIHJ1bGVzID0gcnVsZXMgfHwgZGVmYXVsdFJ1bGVzO1xuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGVsZW1lbnRPckh0bWwub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblxuICAgIHZhciBlbGVtZW50LFxuICAgICAgICBpc1N0cmluZyA9IHR5cGVvZiBlbGVtZW50T3JIdG1sID09PSBcInN0cmluZ1wiLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXNMZW5ndGgsXG4gICAgICAgIGksXG4gICAgICAgIGogPSAwO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgZWxlbWVudCA9IHd5c2lodG1sNS5kb20uZ2V0QXNEb20oZWxlbWVudE9ySHRtbCwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50T3JIdG1sO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9IGVsZW1lbnQuaW5uZXJIVE1MLnJlcGxhY2UoL1xcbi9nLCAnPC9icj4nKVxuICAgICAgdmFyIGVscyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsID0gZWxzW2ldO1xuICAgICAgICBlbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH1cbiAgICAgIHZhciBkaXZzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdkaXYnKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGl2cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGl2ID0gZGl2c1tpXTtcbiAgICAgICAgdmFyIG5ld19kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgICAgIG5ld19kaXYuaW5uZXJUZXh0ID0gZGl2LmlubmVyVGV4dDtcbiAgICAgICAgZGl2LnJlcGxhY2VXaXRoKG5ld19kaXYpO1xuICAgICAgfVxuICAgICAgdmFyIHBfZWxzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdwJyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBfZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbCA9IHBfZWxzW2ldO1xuICAgICAgICBpZiAoISQudHJpbShlbC5pbm5lclRleHQpLmxlbmd0aCkge1xuICAgICAgICAgIGVsLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYnJfZWxzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdicicpO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUoaSA8IGJyX2Vscy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHZhciBiciA9IGJyX2Vsc1tpXTtcbiAgICAgICAgd2hpbGUgKGJyLm5leHRTaWJsaW5nID09IGJyX2Vsc1tpICsgMV0pIHtcbiAgICAgICAgICB2YXIgZWwgPSBicl9lbHNbaSArIDFdO1xuICAgICAgICAgIGVsLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyX2Vscy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgYnJfZWxzW2ldXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpIGluIHJ1bGVzKSB7XG4gICAgICBtYXRjaGVzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGkpO1xuICAgICAgbWV0aG9kID0gcnVsZXNbaV07XG4gICAgICBtYXRjaGVzTGVuZ3RoID0gbWF0Y2hlcy5sZW5ndGg7XG4gICAgICBmb3IgKDsgaiA8IG1hdGNoZXNMZW5ndGg7IGorKykge1xuICAgICAgICBtZXRob2QobWF0Y2hlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWF0Y2hlcyA9IGVsZW1lbnRPckh0bWwgPSBydWxlcyA9IG51bGw7XG5cbiAgICByZXR1cm4gaXNTdHJpbmcgPyBlbGVtZW50LmlubmVySFRNTCA6IGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gY2xlYW5QYXN0ZWRIVE1MO1xufSgpOyAvKipcbiAgICAgKiBJRSBhbmQgT3BlcmEgbGVhdmUgYW4gZW1wdHkgcGFyYWdyYXBoIGluIHRoZSBjb250ZW50RWRpdGFibGUgZWxlbWVudCBhZnRlciBjbGVhcmluZyBpdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRlbnRFZGl0YWJsZUVsZW1lbnQgVGhlIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50IHRvIG9ic2VydmUgZm9yIGNsZWFyaW5nIGV2ZW50c1xuICAgICAqIEBleGFwbGVcbiAgICAgKiAgICB3eXNpaHRtbDUucXVpcmtzLmVuc3VyZVByb3BlckNsZWFyaW5nKG15Q29udGVudEVkaXRhYmxlRWxlbWVudCk7XG4gICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgZG9tID0gd3lzaWh0bWw1LmRvbTtcblxuICB3eXNpaHRtbDUucXVpcmtzLmVuc3VyZVByb3BlckNsZWFyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGVhcklmTmVjZXNzYXJ5ID0gZnVuY3Rpb24gY2xlYXJJZk5lY2Vzc2FyeShldmVudCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lckhUTUwgPSBlbGVtZW50LmlubmVySFRNTC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoaW5uZXJIVE1MID09IFwiPHA+Jm5ic3A7PC9wPlwiIHx8IGlubmVySFRNTCA9PSBcIjxwPiZuYnNwOzwvcD48cD4mbmJzcDs8L3A+XCIpIHtcbiAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbXBvc2VyKSB7XG4gICAgICBkb20ub2JzZXJ2ZShjb21wb3Nlci5lbGVtZW50LCBbXCJjdXRcIiwgXCJrZXlkb3duXCJdLCBjbGVhcklmTmVjZXNzYXJ5KTtcbiAgICB9O1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEluIE9wZXJhIHdoZW4gdGhlIGNhcmV0IGlzIGluIHRoZSBmaXJzdCBhbmQgb25seSBpdGVtIG9mIGEgbGlzdCAoPHVsPjxsaT58PC9saT48L3VsPikgYW5kIHRoZSBsaXN0IGlzIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgY29udGVudEVkaXRhYmxlIGVsZW1lbnQsIGl0J3MgaW1wb3NzaWJsZSB0byBkZWxldGUgdGhlIGxpc3QgYnkgaGl0dGluZyBiYWNrc3BhY2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRlbnRFZGl0YWJsZUVsZW1lbnQgVGhlIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50IHRvIG9ic2VydmUgZm9yIGNsZWFyaW5nIGV2ZW50c1xuICAgKiBAZXhhcGxlXG4gICAqICAgIHd5c2lodG1sNS5xdWlya3MuZW5zdXJlUHJvcGVyQ2xlYXJpbmcobXlDb250ZW50RWRpdGFibGVFbGVtZW50KTtcbiAgICovXG4gIHd5c2lodG1sNS5xdWlya3MuZW5zdXJlUHJvcGVyQ2xlYXJpbmdPZkxpc3RzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBFTEVNRU5UU19USEFUX0NPTlRBSU5fTEkgPSBbXCJPTFwiLCBcIlVMXCIsIFwiTUVOVVwiXTtcblxuICAgIHZhciBjbGVhcklmTmVjZXNzYXJ5ID0gZnVuY3Rpb24gY2xlYXJJZk5lY2Vzc2FyeShlbGVtZW50LCBjb250ZW50RWRpdGFibGVFbGVtZW50KSB7XG4gICAgICBpZiAoIWNvbnRlbnRFZGl0YWJsZUVsZW1lbnQuZmlyc3RDaGlsZCB8fCAhd3lzaWh0bWw1LmxhbmcuYXJyYXkoRUxFTUVOVFNfVEhBVF9DT05UQUlOX0xJKS5jb250YWlucyhjb250ZW50RWRpdGFibGVFbGVtZW50LmZpcnN0Q2hpbGQubm9kZU5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpc3QgPSBkb20uZ2V0UGFyZW50RWxlbWVudChlbGVtZW50LCB7IG5vZGVOYW1lOiBFTEVNRU5UU19USEFUX0NPTlRBSU5fTEkgfSk7XG4gICAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGlzdElzRmlyc3RDaGlsZE9mQ29udGVudEVkaXRhYmxlID0gbGlzdCA9PSBjb250ZW50RWRpdGFibGVFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICBpZiAoIWxpc3RJc0ZpcnN0Q2hpbGRPZkNvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNPbmx5T25lTGlzdEl0ZW0gPSBsaXN0LmNoaWxkTm9kZXMubGVuZ3RoIDw9IDE7XG4gICAgICBpZiAoIWhhc09ubHlPbmVMaXN0SXRlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvbmx5TGlzdEl0ZW1Jc0VtcHR5ID0gbGlzdC5maXJzdENoaWxkID8gbGlzdC5maXJzdENoaWxkLmlubmVySFRNTCA9PT0gXCJcIiA6IHRydWU7XG4gICAgICBpZiAoIW9ubHlMaXN0SXRlbUlzRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsaXN0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGlzdCk7XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoY29tcG9zZXIpIHtcbiAgICAgIGRvbS5vYnNlcnZlKGNvbXBvc2VyLmVsZW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgIT09IHd5c2lodG1sNS5CQUNLU1BBQ0VfS0VZKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICAgIGNsZWFySWZOZWNlc3NhcnkoZWxlbWVudCwgY29tcG9zZXIuZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9KCk7XG59KSh3eXNpaHRtbDUpO1xuLy8gU2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY2NDM5OFxuLy9cbi8vIEluIEZpcmVmb3ggdGhpczpcbi8vICAgICAgdmFyIGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuLy8gICAgICBkLmlubmVySFRNTCA9JzxhIGhyZWY9XCJ+XCI+PC9hPic7XG4vLyAgICAgIGQuaW5uZXJIVE1MO1xuLy8gd2lsbCByZXN1bHQgaW46XG4vLyAgICAgIDxhIGhyZWY9XCIlN0VcIj48L2E+XG4vLyB3aGljaCBpcyB3cm9uZ1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIFRJTERFX0VTQ0FQRUQgPSBcIiU3RVwiO1xuICB3eXNpaHRtbDUucXVpcmtzLmdldENvcnJlY3RJbm5lckhUTUwgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBpbm5lckhUTUwgPSBlbGVtZW50LmlubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MLmluZGV4T2YoVElMREVfRVNDQVBFRCkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gaW5uZXJIVE1MO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50c1dpdGhUaWxkZSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltocmVmKj0nfiddLCBbc3JjKj0nfiddXCIpLFxuICAgICAgICB1cmwsXG4gICAgICAgIHVybFRvU2VhcmNoLFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGk7XG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gZWxlbWVudHNXaXRoVGlsZGUubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHVybCA9IGVsZW1lbnRzV2l0aFRpbGRlW2ldLmhyZWYgfHwgZWxlbWVudHNXaXRoVGlsZGVbaV0uc3JjO1xuICAgICAgdXJsVG9TZWFyY2ggPSB3eXNpaHRtbDUubGFuZy5zdHJpbmcodXJsKS5yZXBsYWNlKFwiflwiKS5ieShUSUxERV9FU0NBUEVEKTtcbiAgICAgIGlubmVySFRNTCA9IHd5c2lodG1sNS5sYW5nLnN0cmluZyhpbm5lckhUTUwpLnJlcGxhY2UodXJsVG9TZWFyY2gpLmJ5KHVybCk7XG4gICAgfVxuICAgIHJldHVybiBpbm5lckhUTUw7XG4gIH07XG59KSh3eXNpaHRtbDUpOyAvKipcbiAgICAgICAgICAgICAgICogU29tZSBicm93c2VycyBkb24ndCBpbnNlcnQgbGluZSBicmVha3Mgd2hlbiBoaXR0aW5nIHJldHVybiBpbiBhIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50XG4gICAgICAgICAgICAgICAqICAgIC0gT3BlcmEgJiBJRSBpbnNlcnQgbmV3IDxwPiBvbiByZXR1cm5cbiAgICAgICAgICAgICAgICogICAgLSBDaHJvbWUgJiBTYWZhcmkgaW5zZXJ0IG5ldyA8ZGl2PiBvbiByZXR1cm5cbiAgICAgICAgICAgICAgICogICAgLSBGaXJlZm94IGluc2VydHMgPGJyPiBvbiByZXR1cm4gKHlpcHBpZSEpXG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgKiAgICB3eXNpaHRtbDUucXVpcmtzLmluc2VydExpbmVCcmVha09uUmV0dXJuKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciBkb20gPSB3eXNpaHRtbDUuZG9tLFxuICAgICAgVVNFX05BVElWRV9MSU5FX0JSRUFLX1dIRU5fQ0FSRVRfSU5TSURFX1RBR1MgPSBbXCJMSVwiLCBcIlBcIiwgXCJIMVwiLCBcIkgyXCIsIFwiSDNcIiwgXCJINFwiLCBcIkg1XCIsIFwiSDZcIl0sXG4gICAgICBMSVNUX1RBR1MgPSBbXCJVTFwiLCBcIk9MXCIsIFwiTUVOVVwiXTtcblxuICB3eXNpaHRtbDUucXVpcmtzLmluc2VydExpbmVCcmVha09uUmV0dXJuID0gZnVuY3Rpb24gKGNvbXBvc2VyKSB7XG4gICAgZnVuY3Rpb24gdW53cmFwKHNlbGVjdGVkTm9kZSkge1xuICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSBkb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHsgbm9kZU5hbWU6IFtcIlBcIiwgXCJESVZcIl0gfSwgMik7XG4gICAgICBpZiAoIXBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW52aXNpYmxlU3BhY2UgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFKTtcbiAgICAgIGRvbS5pbnNlcnQoaW52aXNpYmxlU3BhY2UpLmJlZm9yZShwYXJlbnRFbGVtZW50KTtcbiAgICAgIGRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXMocGFyZW50RWxlbWVudCk7XG4gICAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2VsZWN0Tm9kZShpbnZpc2libGVTcGFjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga2V5RG93bihldmVudCkge1xuICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5IHx8IGtleUNvZGUgIT09IHd5c2lodG1sNS5FTlRFUl9LRVkgJiYga2V5Q29kZSAhPT0gd3lzaWh0bWw1LkJBQ0tTUEFDRV9LRVkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICBzZWxlY3RlZE5vZGUgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCksXG4gICAgICAgICAgYmxvY2tFbGVtZW50ID0gZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBVU0VfTkFUSVZFX0xJTkVfQlJFQUtfV0hFTl9DQVJFVF9JTlNJREVfVEFHUyB9LCA0KTtcbiAgICAgIGlmIChibG9ja0VsZW1lbnQpIHtcbiAgICAgICAgLy8gU29tZSBicm93c2VycyBjcmVhdGUgPHA+IGVsZW1lbnRzIGFmdGVyIGxlYXZpbmcgYSBsaXN0XG4gICAgICAgIC8vIGNoZWNrIGFmdGVyIGtleWRvd24gb2YgYmFja3NwYWNlIGFuZCByZXR1cm4gd2hldGhlciBhIDxwPiBnb3QgaW5zZXJ0ZWQgYW5kIHVud3JhcCBpdFxuICAgICAgICBpZiAoYmxvY2tFbGVtZW50Lm5vZGVOYW1lID09PSBcIkxJXCIgJiYgKGtleUNvZGUgPT09IHd5c2lodG1sNS5FTlRFUl9LRVkgfHwga2V5Q29kZSA9PT0gd3lzaWh0bWw1LkJBQ0tTUEFDRV9LRVkpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSgpLFxuICAgICAgICAgICAgICAgIGxpc3QsXG4gICAgICAgICAgICAgICAgZGl2O1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZE5vZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaXN0ID0gZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7XG4gICAgICAgICAgICAgIG5vZGVOYW1lOiBMSVNUX1RBR1NcbiAgICAgICAgICAgIH0sIDIpO1xuXG4gICAgICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVud3JhcChzZWxlY3RlZE5vZGUpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGJsb2NrRWxlbWVudC5ub2RlTmFtZS5tYXRjaCgvSFsxLTZdLykgJiYga2V5Q29kZSA9PT0gd3lzaWh0bWw1LkVOVEVSX0tFWSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdW53cmFwKGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKSk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5Q29kZSA9PT0gd3lzaWh0bWw1LkVOVEVSX0tFWSAmJiAhd3lzaWh0bWw1LmJyb3dzZXIuaW5zZXJ0c0xpbmVCcmVha3NPblJldHVybigpKSB7XG4gICAgICAgIGNvbXBvc2VyLmNvbW1hbmRzLmV4ZWMoXCJpbnNlcnRMaW5lQnJlYWtcIik7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8ga2V5cHJlc3MgZG9lc24ndCBmaXJlIHdoZW4geW91IGhpdCBiYWNrc3BhY2VcbiAgICBkb20ub2JzZXJ2ZShjb21wb3Nlci5lbGVtZW50Lm93bmVyRG9jdW1lbnQsIFwia2V5ZG93blwiLCBrZXlEb3duKTtcbiAgfTtcbn0pKHd5c2lodG1sNSk7IC8qKlxuICAgICAgICAgICAgICAgKiBGb3JjZSByZXJlbmRlcmluZyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAgICAgICAgICAgICAgICogTmVlZGVkIHRvIGZpeCBkaXNwbGF5IG1pc2JlaGF2aW9ycyBvZiBJRVxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb2JqZWN0IHdoaWNoIG5lZWRzIHRvIGJlIHJlcmVuZGVyZWRcbiAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICogICAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIENMQVNTX05BTUUgPSBcInd5c2lodG1sNS1xdWlya3MtcmVkcmF3XCI7XG5cbiAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHd5c2lodG1sNS5kb20uYWRkQ2xhc3MoZWxlbWVudCwgQ0xBU1NfTkFNRSk7XG4gICAgd3lzaWh0bWw1LmRvbS5yZW1vdmVDbGFzcyhlbGVtZW50LCBDTEFTU19OQU1FKTtcblxuICAgIC8vIEZvbGxvd2luZyBoYWNrIGlzIG5lZWRlZCBmb3IgZmlyZWZveCB0byBtYWtlIHN1cmUgdGhhdCBpbWFnZSByZXNpemUgaGFuZGxlcyBhcmUgcHJvcGVybHkgcmVtb3ZlZFxuICAgIHRyeSB7XG4gICAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgICAgZG9jLmV4ZWNDb21tYW5kKFwiaXRhbGljXCIsIGZhbHNlLCBudWxsKTtcbiAgICAgIGRvYy5leGVjQ29tbWFuZChcIml0YWxpY1wiLCBmYWxzZSwgbnVsbCk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfTtcbn0pKHd5c2lodG1sNSk7IC8qKlxuICAgICAgICAgICAgICAgKiBTZWxlY3Rpb24gQVBJXG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAqICAgIHZhciBzZWxlY3Rpb24gPSBuZXcgd3lzaWh0bWw1LlNlbGVjdGlvbihlZGl0b3IpO1xuICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciBkb20gPSB3eXNpaHRtbDUuZG9tO1xuXG4gIGZ1bmN0aW9uIF9nZXRDdW11bGF0aXZlT2Zmc2V0VG9wKGVsZW1lbnQpIHtcbiAgICB2YXIgdG9wID0gMDtcbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHRvcCArPSBlbGVtZW50Lm9mZnNldFRvcCB8fCAwO1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICB9IHdoaWxlIChlbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcDtcbiAgfVxuXG4gIHd5c2lodG1sNS5TZWxlY3Rpb24gPSBCYXNlLmV4dGVuZChcbiAgLyoqIEBzY29wZSB3eXNpaHRtbDUuU2VsZWN0aW9uLnByb3RvdHlwZSAqL3tcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCBvdXIgZXh0ZXJuYWwgcmFuZ2UgbGlicmFyeSBpcyBpbml0aWFsaXplZFxuICAgICAgd2luZG93LnJhbmd5LmluaXQoKTtcblxuICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICB0aGlzLmNvbXBvc2VyID0gZWRpdG9yLmNvbXBvc2VyO1xuICAgICAgdGhpcy5kb2MgPSB0aGlzLmNvbXBvc2VyLmRvYztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHNlbGVjdGlvbiBhcyBhIGJvb2ttYXJrIHRvIGJlIGFibGUgdG8gbGF0ZXIgcmVzdG9yZSBpdFxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAqL1xuICAgIGdldEJvb2ttYXJrOiBmdW5jdGlvbiBnZXRCb29rbWFyaygpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICAgIHJldHVybiByYW5nZSAmJiByYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgYSBzZWxlY3Rpb24gcmV0cmlldmVkIHZpYSB3eXNpaHRtbDUuU2VsZWN0aW9uLnByb3RvdHlwZS5nZXRCb29rbWFya1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJvb2ttYXJrIEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICovXG4gICAgc2V0Qm9va21hcms6IGZ1bmN0aW9uIHNldEJvb2ttYXJrKGJvb2ttYXJrKSB7XG4gICAgICBpZiAoIWJvb2ttYXJrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oYm9va21hcmspO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNhcmV0IGluIGZyb250IG9mIHRoZSBnaXZlbiBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBUaGUgZWxlbWVudCBvciB0ZXh0IG5vZGUgd2hlcmUgdG8gcG9zaXRpb24gdGhlIGNhcmV0IGluIGZyb250IG9mXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICBzZWxlY3Rpb24uc2V0QmVmb3JlKG15RWxlbWVudCk7XG4gICAgICovXG4gICAgc2V0QmVmb3JlOiBmdW5jdGlvbiBzZXRCZWZvcmUobm9kZSkge1xuICAgICAgdmFyIHJhbmdlID0gcmFuZ3kuY3JlYXRlUmFuZ2UodGhpcy5kb2MpO1xuICAgICAgcmFuZ2Uuc2V0U3RhcnRCZWZvcmUobm9kZSk7XG4gICAgICByYW5nZS5zZXRFbmRCZWZvcmUobm9kZSk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRTZWxlY3Rpb24ocmFuZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNhcmV0IGFmdGVyIHRoZSBnaXZlbiBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBUaGUgZWxlbWVudCBvciB0ZXh0IG5vZGUgd2hlcmUgdG8gcG9zaXRpb24gdGhlIGNhcmV0IGluIGZyb250IG9mXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICBzZWxlY3Rpb24uc2V0QmVmb3JlKG15RWxlbWVudCk7XG4gICAgICovXG4gICAgc2V0QWZ0ZXI6IGZ1bmN0aW9uIHNldEFmdGVyKG5vZGUpIHtcbiAgICAgIHZhciByYW5nZSA9IHJhbmd5LmNyZWF0ZVJhbmdlKHRoaXMuZG9jKTtcbiAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIobm9kZSk7XG4gICAgICByYW5nZS5zZXRFbmRBZnRlcihub2RlKTtcbiAgICAgIHJldHVybiB0aGlzLnNldFNlbGVjdGlvbihyYW5nZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFiaWxpdHkgdG8gc2VsZWN0L21hcmsgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBUaGUgbm9kZS9lbGVtZW50IHRvIHNlbGVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgc2VsZWN0aW9uLnNlbGVjdE5vZGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJteS1pbWFnZVwiKSk7XG4gICAgICovXG4gICAgc2VsZWN0Tm9kZTogZnVuY3Rpb24gc2VsZWN0Tm9kZShub2RlKSB7XG4gICAgICB2YXIgcmFuZ2UgPSByYW5neS5jcmVhdGVSYW5nZSh0aGlzLmRvYyksXG4gICAgICAgICAgaXNFbGVtZW50ID0gbm9kZS5ub2RlVHlwZSA9PT0gd3lzaWh0bWw1LkVMRU1FTlRfTk9ERSxcbiAgICAgICAgICBjYW5IYXZlSFRNTCA9IFwiY2FuSGF2ZUhUTUxcIiBpbiBub2RlID8gbm9kZS5jYW5IYXZlSFRNTCA6IG5vZGUubm9kZU5hbWUgIT09IFwiSU1HXCIsXG4gICAgICAgICAgY29udGVudCA9IGlzRWxlbWVudCA/IG5vZGUuaW5uZXJIVE1MIDogbm9kZS5kYXRhLFxuICAgICAgICAgIGlzRW1wdHkgPSBjb250ZW50ID09PSBcIlwiIHx8IGNvbnRlbnQgPT09IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UsXG4gICAgICAgICAgZGlzcGxheVN0eWxlID0gZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKG5vZGUpLFxuICAgICAgICAgIGlzQmxvY2tFbGVtZW50ID0gZGlzcGxheVN0eWxlID09PSBcImJsb2NrXCIgfHwgZGlzcGxheVN0eWxlID09PSBcImxpc3QtaXRlbVwiO1xuXG4gICAgICBpZiAoaXNFbXB0eSAmJiBpc0VsZW1lbnQgJiYgY2FuSGF2ZUhUTUwpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgY2FyZXQgaXMgdmlzaWJsZSBpbiBub2RlIGJ5IGluc2VydGluZyBhIHplcm8gd2lkdGggbm8gYnJlYWtpbmcgc3BhY2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBub2RlLmlubmVySFRNTCA9IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0U7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5IYXZlSFRNTCkge1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuSGF2ZUhUTUwgJiYgaXNFbXB0eSAmJiBpc0VsZW1lbnQpIHtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2UoaXNCbG9ja0VsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChjYW5IYXZlSFRNTCAmJiBpc0VtcHR5KSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIobm9kZSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFNlbGVjdGlvbihyYW5nZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbm9kZSB3aGljaCBjb250YWlucyB0aGUgc2VsZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb250cm9sUmFuZ2VdIChvbmx5IElFKSBXaGV0aGVyIGl0IHNob3VsZCByZXR1cm4gdGhlIHNlbGVjdGVkIENvbnRyb2xSYW5nZSBlbGVtZW50IHdoZW4gdGhlIHNlbGVjdGlvbiB0eXBlIGlzIGEgXCJDb250cm9sUmFuZ2VcIlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5vZGUgdGhhdCBjb250YWlucyB0aGUgY2FyZXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHZhciBub2RlVGhhdENvbnRhaW5zQ2FyZXQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWROb2RlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZE5vZGUoY29udHJvbFJhbmdlKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uLCByYW5nZTtcblxuICAgICAgaWYgKGNvbnRyb2xSYW5nZSAmJiB0aGlzLmRvYy5zZWxlY3Rpb24gJiYgdGhpcy5kb2Muc2VsZWN0aW9uLnR5cGUgPT09IFwiQ29udHJvbFwiKSB7XG4gICAgICAgIHJhbmdlID0gdGhpcy5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIGlmIChyYW5nZSAmJiByYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcmFuZ2UuaXRlbSgwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbih0aGlzLmRvYyk7XG4gICAgICBpZiAoc2VsZWN0aW9uLmZvY3VzTm9kZSA9PT0gc2VsZWN0aW9uLmFuY2hvck5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UodGhpcy5kb2MpO1xuICAgICAgICByZXR1cm4gcmFuZ2UgPyByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lciA6IHRoaXMuZG9jLmJvZHk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGV4ZWN1dGVBbmRSZXN0b3JlOiBmdW5jdGlvbiBleGVjdXRlQW5kUmVzdG9yZShtZXRob2QsIHJlc3RvcmVTY3JvbGxQb3NpdGlvbikge1xuICAgICAgdmFyIGJvZHkgPSB0aGlzLmRvYy5ib2R5LFxuICAgICAgICAgIG9sZFNjcm9sbFRvcCA9IHJlc3RvcmVTY3JvbGxQb3NpdGlvbiAmJiBib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICBvbGRTY3JvbGxMZWZ0ID0gcmVzdG9yZVNjcm9sbFBvc2l0aW9uICYmIGJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgICBjbGFzc05hbWUgPSBcIl93eXNpaHRtbDUtdGVtcC1wbGFjZWhvbGRlclwiLFxuICAgICAgICAgIHBsYWNlaG9sZGVySFRNTCA9ICc8c3BhbiBjbGFzcz1cIicgKyBjbGFzc05hbWUgKyAnXCI+JyArIHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UgKyAnPC9zcGFuPicsXG4gICAgICAgICAgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKHRoaXMuZG9jKSxcbiAgICAgICAgICBuZXdSYW5nZTtcblxuICAgICAgLy8gTm90aGluZyBzZWxlY3RlZCwgZXhlY3V0ZSBhbmQgc2F5IGdvb2RieWVcbiAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgbWV0aG9kKGJvZHksIGJvZHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHBsYWNlaG9sZGVySFRNTCk7XG4gICAgICByYW5nZS5pbnNlcnROb2RlKG5vZGUpO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCBhIHBvdGVudGlhbCBlcnJvciBkb2Vzbid0IGNhdXNlIG91ciBwbGFjZWhvbGRlciBlbGVtZW50IHRvIGJlIGxlZnQgYXMgYSBwbGFjZWhvbGRlclxuICAgICAgdHJ5IHtcbiAgICAgICAgbWV0aG9kKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5lbmRDb250YWluZXIpO1xuICAgICAgfSBjYXRjaCAoZTMpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZTM7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuXG4gICAgICBjYXJldFBsYWNlaG9sZGVyID0gdGhpcy5kb2MucXVlcnlTZWxlY3RvcihcIi5cIiArIGNsYXNzTmFtZSk7XG4gICAgICBpZiAoY2FyZXRQbGFjZWhvbGRlcikge1xuICAgICAgICBuZXdSYW5nZSA9IHJhbmd5LmNyZWF0ZVJhbmdlKHRoaXMuZG9jKTtcbiAgICAgICAgbmV3UmFuZ2Uuc2VsZWN0Tm9kZShjYXJldFBsYWNlaG9sZGVyKTtcbiAgICAgICAgbmV3UmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24obmV3UmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgZm9yIHdoZW4gYWxsIGhlbGwgYnJlYWtzIGxvb3NlXG4gICAgICAgIGJvZHkuZm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3RvcmVTY3JvbGxQb3NpdGlvbikge1xuICAgICAgICBib2R5LnNjcm9sbFRvcCA9IG9sZFNjcm9sbFRvcDtcbiAgICAgICAgYm9keS5zY3JvbGxMZWZ0ID0gb2xkU2Nyb2xsTGVmdDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGl0IGFnYWluLCBqdXN0IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBwbGFjZWhvbGRlciBpcyBkZWZpbml0ZWx5IG91dCBvZiB0aGUgZG9tIHRyZWVcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhcmV0UGxhY2Vob2xkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjYXJldFBsYWNlaG9sZGVyKTtcbiAgICAgIH0gY2F0Y2ggKGU0KSB7fVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaWZmZXJlbnQgYXBwcm9hY2ggb2YgcHJlc2VydmluZyB0aGUgc2VsZWN0aW9uIChkb2Vzbid0IG1vZGlmeSB0aGUgZG9tKVxuICAgICAqIFRha2VzIGFsbCB0ZXh0IG5vZGVzIGluIHRoZSBzZWxlY3Rpb24gYW5kIHNhdmVzIHRoZSBzZWxlY3Rpb24gcG9zaXRpb24gaW4gdGhlIGZpcnN0IGFuZCBsYXN0IG9uZVxuICAgICAqL1xuICAgIGV4ZWN1dGVBbmRSZXN0b3JlU2ltcGxlOiBmdW5jdGlvbiBleGVjdXRlQW5kUmVzdG9yZVNpbXBsZShtZXRob2QpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKSxcbiAgICAgICAgICBib2R5ID0gdGhpcy5kb2MuYm9keSxcbiAgICAgICAgICBuZXdSYW5nZSxcbiAgICAgICAgICBmaXJzdE5vZGUsXG4gICAgICAgICAgbGFzdE5vZGUsXG4gICAgICAgICAgdGV4dE5vZGVzLFxuICAgICAgICAgIHJhbmdlQmFja3VwO1xuXG4gICAgICAvLyBOb3RoaW5nIHNlbGVjdGVkLCBleGVjdXRlIGFuZCBzYXkgZ29vZGJ5ZVxuICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICBtZXRob2QoYm9keSwgYm9keSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGV4dE5vZGVzID0gcmFuZ2UuZ2V0Tm9kZXMoWzNdKTtcbiAgICAgIGZpcnN0Tm9kZSA9IHRleHROb2Rlc1swXSB8fCByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgIGxhc3ROb2RlID0gdGV4dE5vZGVzW3RleHROb2Rlcy5sZW5ndGggLSAxXSB8fCByYW5nZS5lbmRDb250YWluZXI7XG5cbiAgICAgIHJhbmdlQmFja3VwID0ge1xuICAgICAgICBjb2xsYXBzZWQ6IHJhbmdlLmNvbGxhcHNlZCxcbiAgICAgICAgc3RhcnRDb250YWluZXI6IGZpcnN0Tm9kZSxcbiAgICAgICAgc3RhcnRPZmZzZXQ6IGZpcnN0Tm9kZSA9PT0gcmFuZ2Uuc3RhcnRDb250YWluZXIgPyByYW5nZS5zdGFydE9mZnNldCA6IDAsXG4gICAgICAgIGVuZENvbnRhaW5lcjogbGFzdE5vZGUsXG4gICAgICAgIGVuZE9mZnNldDogbGFzdE5vZGUgPT09IHJhbmdlLmVuZENvbnRhaW5lciA/IHJhbmdlLmVuZE9mZnNldCA6IGxhc3ROb2RlLmxlbmd0aFxuICAgICAgfTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbWV0aG9kKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5lbmRDb250YWluZXIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cblxuICAgICAgbmV3UmFuZ2UgPSByYW5neS5jcmVhdGVSYW5nZSh0aGlzLmRvYyk7XG4gICAgICB0cnkge1xuICAgICAgICBuZXdSYW5nZS5zZXRTdGFydChyYW5nZUJhY2t1cC5zdGFydENvbnRhaW5lciwgcmFuZ2VCYWNrdXAuc3RhcnRPZmZzZXQpO1xuICAgICAgfSBjYXRjaCAoZTEpIHt9XG4gICAgICB0cnkge1xuICAgICAgICBuZXdSYW5nZS5zZXRFbmQocmFuZ2VCYWNrdXAuZW5kQ29udGFpbmVyLCByYW5nZUJhY2t1cC5lbmRPZmZzZXQpO1xuICAgICAgfSBjYXRjaCAoZTIpIHt9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihuZXdSYW5nZSk7XG4gICAgICB9IGNhdGNoIChlMykge31cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGh0bWwgYXQgdGhlIGNhcmV0IHBvc2l0aW9uIGFuZCBtb3ZlIHRoZSBjdXJzb3IgYWZ0ZXIgdGhlIGluc2VydGVkIGh0bWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIEhUTUwgc3RyaW5nIHRvIGluc2VydFxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgc2VsZWN0aW9uLmluc2VydEhUTUwoXCI8cD5mb29iYXI8L3A+XCIpO1xuICAgICAqL1xuICAgIGluc2VydEhUTUw6IGZ1bmN0aW9uIGluc2VydEhUTUwoaHRtbCkge1xuICAgICAgdmFyIHJhbmdlID0gcmFuZ3kuY3JlYXRlUmFuZ2UodGhpcy5kb2MpLFxuICAgICAgICAgIG5vZGUgPSByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoaHRtbCksXG4gICAgICAgICAgbGFzdENoaWxkID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgICB0aGlzLmluc2VydE5vZGUobm9kZSk7XG4gICAgICBpZiAobGFzdENoaWxkKSB7XG4gICAgICAgIHRoaXMuc2V0QWZ0ZXIobGFzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgbm9kZSBhdCB0aGUgY2FyZXQgcG9zaXRpb24gYW5kIG1vdmUgdGhlIGN1cnNvciBiZWhpbmQgaXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIEhUTUwgc3RyaW5nIHRvIGluc2VydFxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgc2VsZWN0aW9uLmluc2VydE5vZGUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJmb29iYXJcIikpO1xuICAgICAqL1xuICAgIGluc2VydE5vZGU6IGZ1bmN0aW9uIGluc2VydE5vZGUobm9kZSkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJhbmdlLmluc2VydE5vZGUobm9kZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGN1cnJlbnQgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIFRoZSBub2RlIHRvIHN1cnJvdW5kIHRoZSBzZWxlY3RlZCBlbGVtZW50cyB3aXRoXG4gICAgICovXG4gICAgc3Vycm91bmQ6IGZ1bmN0aW9uIHN1cnJvdW5kKG5vZGUpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIG9ubHkgd29ya3Mgd2hlbiB0aGUgcmFuZ2UgYm91bmRhcmllcyBhcmUgbm90IG92ZXJsYXBwaW5nIG90aGVyIGVsZW1lbnRzXG4gICAgICAgIHJhbmdlLnN1cnJvdW5kQ29udGVudHMobm9kZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZmFsbGJhY2tcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChyYW5nZS5leHRyYWN0Q29udGVudHMoKSk7XG4gICAgICAgIHJhbmdlLmluc2VydE5vZGUobm9kZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbiBpbnRvIHRoZSB2aWV3XG4gICAgICogRklYTUU6IFRoaXMgaXMgYSBiaXQgaGFja3ksIHRoZXJlIG1pZ2h0IGJlIGEgc21hcnRlciB3YXkgb2YgZG9pbmcgdGhpc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICBzZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldzogZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoKSB7XG4gICAgICB2YXIgZG9jID0gdGhpcy5kb2MsXG4gICAgICAgICAgaGFzU2Nyb2xsQmFycyA9IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jLmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgdGVtcEVsZW1lbnQgPSBkb2MuX3d5c2lodG1sNVNjcm9sbEludG9WaWV3RWxlbWVudCA9IGRvYy5fd3lzaWh0bWw1U2Nyb2xsSW50b1ZpZXdFbGVtZW50IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIC8vIFRoZSBlbGVtZW50IG5lZWRzIGNvbnRlbnQgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgaXQncyBwb3NpdGlvbiBwcm9wZXJseVxuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0U7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfSgpLFxuICAgICAgICAgIG9mZnNldFRvcDtcblxuICAgICAgaWYgKGhhc1Njcm9sbEJhcnMpIHtcbiAgICAgICAgdGhpcy5pbnNlcnROb2RlKHRlbXBFbGVtZW50KTtcbiAgICAgICAgb2Zmc2V0VG9wID0gX2dldEN1bXVsYXRpdmVPZmZzZXRUb3AodGVtcEVsZW1lbnQpO1xuICAgICAgICB0ZW1wRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXBFbGVtZW50KTtcbiAgICAgICAgaWYgKG9mZnNldFRvcCA+IGRvYy5ib2R5LnNjcm9sbFRvcCkge1xuICAgICAgICAgIGRvYy5ib2R5LnNjcm9sbFRvcCA9IG9mZnNldFRvcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgbGluZSB3aGVyZSB0aGUgY2FyZXQgaXMgaW5cbiAgICAgKi9cbiAgICBzZWxlY3RMaW5lOiBmdW5jdGlvbiBzZWxlY3RMaW5lKCkge1xuICAgICAgaWYgKHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzU2VsZWN0aW9uTW9kaWZ5KCkpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0TGluZV9XM0MoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kb2Muc2VsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdExpbmVfTVNJRSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL1NlbGVjdGlvbi9tb2RpZnlcbiAgICAgKi9cbiAgICBfc2VsZWN0TGluZV9XM0M6IGZ1bmN0aW9uIF9zZWxlY3RMaW5lX1czQygpIHtcbiAgICAgIHZhciB3aW4gPSB0aGlzLmRvYy5kZWZhdWx0VmlldyxcbiAgICAgICAgICBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBzZWxlY3Rpb24ubW9kaWZ5KFwiZXh0ZW5kXCIsIFwibGVmdFwiLCBcImxpbmVib3VuZGFyeVwiKTtcbiAgICAgIHNlbGVjdGlvbi5tb2RpZnkoXCJleHRlbmRcIiwgXCJyaWdodFwiLCBcImxpbmVib3VuZGFyeVwiKTtcbiAgICB9LFxuXG4gICAgX3NlbGVjdExpbmVfTVNJRTogZnVuY3Rpb24gX3NlbGVjdExpbmVfTVNJRSgpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLFxuICAgICAgICAgIHJhbmdlVG9wID0gcmFuZ2UuYm91bmRpbmdUb3AsXG4gICAgICAgICAgcmFuZ2VIZWlnaHQgPSByYW5nZS5ib3VuZGluZ0hlaWdodCxcbiAgICAgICAgICBzY3JvbGxXaWR0aCA9IHRoaXMuZG9jLmJvZHkuc2Nyb2xsV2lkdGgsXG4gICAgICAgICAgcmFuZ2VCb3R0b20sXG4gICAgICAgICAgcmFuZ2VFbmQsXG4gICAgICAgICAgbWVhc3VyZU5vZGUsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBqO1xuXG4gICAgICBpZiAoIXJhbmdlLm1vdmVUb1BvaW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhbmdlVG9wID09PSAwKSB7XG4gICAgICAgIC8vIERvbid0IGtub3cgd2h5LCBidXQgd2hlbiB0aGUgc2VsZWN0aW9uIGVuZHMgYXQgdGhlIGVuZCBvZiBhIGxpbmVcbiAgICAgICAgLy8gcmFuZ2UuYm91bmRpbmdUb3AgaXMgMFxuICAgICAgICBtZWFzdXJlTm9kZSA9IHRoaXMuZG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB0aGlzLmluc2VydE5vZGUobWVhc3VyZU5vZGUpO1xuICAgICAgICByYW5nZVRvcCA9IG1lYXN1cmVOb2RlLm9mZnNldFRvcDtcbiAgICAgICAgbWVhc3VyZU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtZWFzdXJlTm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJhbmdlVG9wICs9IDE7XG5cbiAgICAgIGZvciAoaSA9IC0xMDsgaSA8IHNjcm9sbFdpZHRoOyBpICs9IDIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByYW5nZS5tb3ZlVG9Qb2ludChpLCByYW5nZVRvcCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gY2F0Y2ggKGUxKSB7fVxuICAgICAgfVxuXG4gICAgICAvLyBJbnZlc3RpZ2F0ZSB0aGUgZm9sbG93aW5nIGluIG9yZGVyIHRvIGhhbmRsZSBtdWx0aSBsaW5lIHNlbGVjdGlvbnNcbiAgICAgIC8vIHJhbmdlQm90dG9tID0gcmFuZ2VUb3AgKyAocmFuZ2VIZWlnaHQgPyAocmFuZ2VIZWlnaHQgLSAxKSA6IDApO1xuICAgICAgcmFuZ2VCb3R0b20gPSByYW5nZVRvcDtcbiAgICAgIHJhbmdlRW5kID0gdGhpcy5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICBmb3IgKGogPSBzY3JvbGxXaWR0aDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByYW5nZUVuZC5tb3ZlVG9Qb2ludChqLCByYW5nZUJvdHRvbSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gY2F0Y2ggKGUyKSB7fVxuICAgICAgfVxuXG4gICAgICByYW5nZS5zZXRFbmRQb2ludChcIkVuZFRvRW5kXCIsIHJhbmdlRW5kKTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH0sXG5cbiAgICBnZXRUZXh0OiBmdW5jdGlvbiBnZXRUZXh0KCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uID8gc2VsZWN0aW9uLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgIH0sXG5cbiAgICBnZXROb2RlczogZnVuY3Rpb24gZ2V0Tm9kZXMobm9kZVR5cGUsIGZpbHRlcikge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZS5nZXROb2Rlcyhbbm9kZVR5cGVdLCBmaWx0ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRSYW5nZTogZnVuY3Rpb24gZ2V0UmFuZ2UoKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHJldHVybiBzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLnJhbmdlQ291bnQgJiYgc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbjogZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmd5LmdldFNlbGVjdGlvbih0aGlzLmRvYy5kZWZhdWx0VmlldyB8fCB0aGlzLmRvYy5wYXJlbnRXaW5kb3cpO1xuICAgIH0sXG5cbiAgICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihyYW5nZSkge1xuICAgICAgdmFyIHdpbiA9IHRoaXMuZG9jLmRlZmF1bHRWaWV3IHx8IHRoaXMuZG9jLnBhcmVudFdpbmRvdyxcbiAgICAgICAgICBzZWxlY3Rpb24gPSByYW5neS5nZXRTZWxlY3Rpb24od2luKTtcbiAgICAgIHJldHVybiBzZWxlY3Rpb24uc2V0U2luZ2xlUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfSk7XG59KSh3eXNpaHRtbDUpO1xuLyoqXG4gKiBJbnNwaXJlZCBieSB0aGUgcmFuZ3kgQ1NTIEFwcGxpZXIgbW9kdWxlIHdyaXR0ZW4gYnkgVGltIERvd24gYW5kIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9yYW5neS9cbiAqXG4gKiBjaGFuZ2VkIGluIG9yZGVyIHRvIGJlIGFibGUgLi4uXG4gKiAgICAtIHRvIHVzZSBjdXN0b20gdGFnc1xuICogICAgLSB0byBkZXRlY3QgYW5kIHJlcGxhY2Ugc2ltaWxhciBjc3MgY2xhc3NlcyB2aWEgcmVnIGV4cFxuICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSwgcmFuZ3kpIHtcbiAgdmFyIGRlZmF1bHRUYWdOYW1lID0gXCJzcGFuXCI7XG5cbiAgdmFyIFJFR19FWFBfV0hJVEVfU1BBQ0UgPSAvXFxzKy9nO1xuXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBjc3NDbGFzcywgcmVnRXhwKSB7XG4gICAgaWYgKCFlbC5jbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hpbmdDbGFzc05hbWVzID0gZWwuY2xhc3NOYW1lLm1hdGNoKHJlZ0V4cCkgfHwgW107XG4gICAgcmV0dXJuIG1hdGNoaW5nQ2xhc3NOYW1lc1ttYXRjaGluZ0NsYXNzTmFtZXMubGVuZ3RoIC0gMV0gPT09IGNzc0NsYXNzO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNzc0NsYXNzLCByZWdFeHApIHtcbiAgICBpZiAoZWwuY2xhc3NOYW1lKSB7XG4gICAgICByZW1vdmVDbGFzcyhlbCwgcmVnRXhwKTtcbiAgICAgIGVsLmNsYXNzTmFtZSArPSBcIiBcIiArIGNzc0NsYXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSBjc3NDbGFzcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgcmVnRXhwKSB7XG4gICAgaWYgKGVsLmNsYXNzTmFtZSkge1xuICAgICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UocmVnRXhwLCBcIlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNTYW1lQ2xhc3NlcyhlbDEsIGVsMikge1xuICAgIHJldHVybiBlbDEuY2xhc3NOYW1lLnJlcGxhY2UoUkVHX0VYUF9XSElURV9TUEFDRSwgXCIgXCIpID09IGVsMi5jbGFzc05hbWUucmVwbGFjZShSRUdfRVhQX1dISVRFX1NQQUNFLCBcIiBcIik7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlV2l0aE93bkNoaWxkcmVuKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWwuZmlyc3RDaGlsZCwgZWwpO1xuICAgIH1cbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZWxlbWVudHNIYXZlU2FtZU5vbkNsYXNzQXR0cmlidXRlcyhlbDEsIGVsMikge1xuICAgIGlmIChlbDEuYXR0cmlidXRlcy5sZW5ndGggIT0gZWwyLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbDEuYXR0cmlidXRlcy5sZW5ndGgsIGF0dHIxLCBhdHRyMiwgbmFtZTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhdHRyMSA9IGVsMS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgbmFtZSA9IGF0dHIxLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBcImNsYXNzXCIpIHtcbiAgICAgICAgYXR0cjIgPSBlbDIuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0obmFtZSk7XG4gICAgICAgIGlmIChhdHRyMS5zcGVjaWZpZWQgIT0gYXR0cjIuc3BlY2lmaWVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyMS5zcGVjaWZpZWQgJiYgYXR0cjEubm9kZVZhbHVlICE9PSBhdHRyMi5ub2RlVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NwbGl0UG9pbnQobm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKHJhbmd5LmRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpKSB7XG4gICAgICBpZiAob2Zmc2V0ID09IDApIHtcbiAgICAgICAgcmV0dXJuICEhbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCA9PSBub2RlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gISFub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCA+IDAgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGl0Tm9kZUF0KG5vZGUsIGRlc2NlbmRhbnROb2RlLCBkZXNjZW5kYW50T2Zmc2V0KSB7XG4gICAgdmFyIG5ld05vZGU7XG4gICAgaWYgKHJhbmd5LmRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKGRlc2NlbmRhbnROb2RlKSkge1xuICAgICAgaWYgKGRlc2NlbmRhbnRPZmZzZXQgPT0gMCkge1xuICAgICAgICBkZXNjZW5kYW50T2Zmc2V0ID0gcmFuZ3kuZG9tLmdldE5vZGVJbmRleChkZXNjZW5kYW50Tm9kZSk7XG4gICAgICAgIGRlc2NlbmRhbnROb2RlID0gZGVzY2VuZGFudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVzY2VuZGFudE9mZnNldCA9PSBkZXNjZW5kYW50Tm9kZS5sZW5ndGgpIHtcbiAgICAgICAgZGVzY2VuZGFudE9mZnNldCA9IHJhbmd5LmRvbS5nZXROb2RlSW5kZXgoZGVzY2VuZGFudE5vZGUpICsgMTtcbiAgICAgICAgZGVzY2VuZGFudE5vZGUgPSBkZXNjZW5kYW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3Tm9kZSA9IHJhbmd5LmRvbS5zcGxpdERhdGFOb2RlKGRlc2NlbmRhbnROb2RlLCBkZXNjZW5kYW50T2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFuZXdOb2RlKSB7XG4gICAgICBuZXdOb2RlID0gZGVzY2VuZGFudE5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgIGlmIChuZXdOb2RlLmlkKSB7XG4gICAgICAgIG5ld05vZGUucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQgPSBkZXNjZW5kYW50Tm9kZS5jaGlsZE5vZGVzW2Rlc2NlbmRhbnRPZmZzZXRdKSB7XG4gICAgICAgIG5ld05vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgICAgcmFuZ3kuZG9tLmluc2VydEFmdGVyKG5ld05vZGUsIGRlc2NlbmRhbnROb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NlbmRhbnROb2RlID09IG5vZGUgPyBuZXdOb2RlIDogc3BsaXROb2RlQXQobm9kZSwgbmV3Tm9kZS5wYXJlbnROb2RlLCByYW5neS5kb20uZ2V0Tm9kZUluZGV4KG5ld05vZGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIE1lcmdlKGZpcnN0Tm9kZSkge1xuICAgIHRoaXMuaXNFbGVtZW50TWVyZ2UgPSBmaXJzdE5vZGUubm9kZVR5cGUgPT0gd3lzaWh0bWw1LkVMRU1FTlRfTk9ERTtcbiAgICB0aGlzLmZpcnN0VGV4dE5vZGUgPSB0aGlzLmlzRWxlbWVudE1lcmdlID8gZmlyc3ROb2RlLmxhc3RDaGlsZCA6IGZpcnN0Tm9kZTtcbiAgICB0aGlzLnRleHROb2RlcyA9IFt0aGlzLmZpcnN0VGV4dE5vZGVdO1xuICB9XG5cbiAgTWVyZ2UucHJvdG90eXBlID0ge1xuICAgIGRvTWVyZ2U6IGZ1bmN0aW9uIGRvTWVyZ2UoKSB7XG4gICAgICB2YXIgdGV4dEJpdHMgPSBbXSxcbiAgICAgICAgICB0ZXh0Tm9kZSxcbiAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgdGV4dDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnRleHROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB0ZXh0Tm9kZSA9IHRoaXMudGV4dE5vZGVzW2ldO1xuICAgICAgICBwYXJlbnQgPSB0ZXh0Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB0ZXh0Qml0c1tpXSA9IHRleHROb2RlLmRhdGE7XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgICBpZiAoIXBhcmVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmZpcnN0VGV4dE5vZGUuZGF0YSA9IHRleHQgPSB0ZXh0Qml0cy5qb2luKFwiXCIpO1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSxcblxuICAgIGdldExlbmd0aDogZnVuY3Rpb24gZ2V0TGVuZ3RoKCkge1xuICAgICAgdmFyIGkgPSB0aGlzLnRleHROb2Rlcy5sZW5ndGgsXG4gICAgICAgICAgbGVuID0gMDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgbGVuICs9IHRoaXMudGV4dE5vZGVzW2ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW47XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciB0ZXh0Qml0cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMudGV4dE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHRleHRCaXRzW2ldID0gXCInXCIgKyB0aGlzLnRleHROb2Rlc1tpXS5kYXRhICsgXCInXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJbTWVyZ2UoXCIgKyB0ZXh0Qml0cy5qb2luKFwiLFwiKSArIFwiKV1cIjtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSFRNTEFwcGxpZXIodGFnTmFtZXMsIGNzc0NsYXNzLCBzaW1pbGFyQ2xhc3NSZWdFeHAsIG5vcm1hbGl6ZSkge1xuICAgIHRoaXMudGFnTmFtZXMgPSB0YWdOYW1lcyB8fCBbZGVmYXVsdFRhZ05hbWVdO1xuICAgIHRoaXMuY3NzQ2xhc3MgPSBjc3NDbGFzcyB8fCBcIlwiO1xuICAgIHRoaXMuc2ltaWxhckNsYXNzUmVnRXhwID0gc2ltaWxhckNsYXNzUmVnRXhwO1xuICAgIHRoaXMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuICAgIHRoaXMuYXBwbHlUb0FueVRhZ05hbWUgPSBmYWxzZTtcbiAgfVxuXG4gIEhUTUxBcHBsaWVyLnByb3RvdHlwZSA9IHtcbiAgICBnZXRBbmNlc3RvcldpdGhDbGFzczogZnVuY3Rpb24gZ2V0QW5jZXN0b3JXaXRoQ2xhc3Mobm9kZSkge1xuICAgICAgdmFyIGNzc0NsYXNzTWF0Y2g7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBjc3NDbGFzc01hdGNoID0gdGhpcy5jc3NDbGFzcyA/IGhhc0NsYXNzKG5vZGUsIHRoaXMuY3NzQ2xhc3MsIHRoaXMuc2ltaWxhckNsYXNzUmVnRXhwKSA6IHRydWU7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IHd5c2lodG1sNS5FTEVNRU5UX05PREUgJiYgcmFuZ3kuZG9tLmFycmF5Q29udGFpbnModGhpcy50YWdOYW1lcywgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmIGNzc0NsYXNzTWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBOb3JtYWxpemVzIG5vZGVzIGFmdGVyIGFwcGx5aW5nIGEgQ1NTIGNsYXNzIHRvIGEgUmFuZ2UuXG4gICAgcG9zdEFwcGx5OiBmdW5jdGlvbiBwb3N0QXBwbHkodGV4dE5vZGVzLCByYW5nZSkge1xuICAgICAgdmFyIGZpcnN0Tm9kZSA9IHRleHROb2Rlc1swXSxcbiAgICAgICAgICBsYXN0Tm9kZSA9IHRleHROb2Rlc1t0ZXh0Tm9kZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgIHZhciBtZXJnZXMgPSBbXSxcbiAgICAgICAgICBjdXJyZW50TWVyZ2U7XG5cbiAgICAgIHZhciByYW5nZVN0YXJ0Tm9kZSA9IGZpcnN0Tm9kZSxcbiAgICAgICAgICByYW5nZUVuZE5vZGUgPSBsYXN0Tm9kZTtcbiAgICAgIHZhciByYW5nZVN0YXJ0T2Zmc2V0ID0gMCxcbiAgICAgICAgICByYW5nZUVuZE9mZnNldCA9IGxhc3ROb2RlLmxlbmd0aDtcblxuICAgICAgdmFyIHRleHROb2RlLCBwcmVjZWRpbmdUZXh0Tm9kZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB0ZXh0Tm9kZSA9IHRleHROb2Rlc1tpXTtcbiAgICAgICAgcHJlY2VkaW5nVGV4dE5vZGUgPSB0aGlzLmdldEFkamFjZW50TWVyZ2VhYmxlVGV4dE5vZGUodGV4dE5vZGUucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICBpZiAocHJlY2VkaW5nVGV4dE5vZGUpIHtcbiAgICAgICAgICBpZiAoIWN1cnJlbnRNZXJnZSkge1xuICAgICAgICAgICAgY3VycmVudE1lcmdlID0gbmV3IE1lcmdlKHByZWNlZGluZ1RleHROb2RlKTtcbiAgICAgICAgICAgIG1lcmdlcy5wdXNoKGN1cnJlbnRNZXJnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRNZXJnZS50ZXh0Tm9kZXMucHVzaCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgaWYgKHRleHROb2RlID09PSBmaXJzdE5vZGUpIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnROb2RlID0gY3VycmVudE1lcmdlLmZpcnN0VGV4dE5vZGU7XG4gICAgICAgICAgICByYW5nZVN0YXJ0T2Zmc2V0ID0gcmFuZ2VTdGFydE5vZGUubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGV4dE5vZGUgPT09IGxhc3ROb2RlKSB7XG4gICAgICAgICAgICByYW5nZUVuZE5vZGUgPSBjdXJyZW50TWVyZ2UuZmlyc3RUZXh0Tm9kZTtcbiAgICAgICAgICAgIHJhbmdlRW5kT2Zmc2V0ID0gY3VycmVudE1lcmdlLmdldExlbmd0aCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50TWVyZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRlc3Qgd2hldGhlciB0aGUgZmlyc3Qgbm9kZSBhZnRlciB0aGUgcmFuZ2UgbmVlZHMgbWVyZ2luZ1xuICAgICAgdmFyIG5leHRUZXh0Tm9kZSA9IHRoaXMuZ2V0QWRqYWNlbnRNZXJnZWFibGVUZXh0Tm9kZShsYXN0Tm9kZS5wYXJlbnROb2RlLCB0cnVlKTtcbiAgICAgIGlmIChuZXh0VGV4dE5vZGUpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50TWVyZ2UpIHtcbiAgICAgICAgICBjdXJyZW50TWVyZ2UgPSBuZXcgTWVyZ2UobGFzdE5vZGUpO1xuICAgICAgICAgIG1lcmdlcy5wdXNoKGN1cnJlbnRNZXJnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudE1lcmdlLnRleHROb2Rlcy5wdXNoKG5leHRUZXh0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERvIHRoZSBtZXJnZXNcbiAgICAgIGlmIChtZXJnZXMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG1lcmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIG1lcmdlc1tpXS5kb01lcmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSByYW5nZSBib3VuZGFyaWVzXG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KHJhbmdlU3RhcnROb2RlLCByYW5nZVN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKHJhbmdlRW5kTm9kZSwgcmFuZ2VFbmRPZmZzZXQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRBZGphY2VudE1lcmdlYWJsZVRleHROb2RlOiBmdW5jdGlvbiBnZXRBZGphY2VudE1lcmdlYWJsZVRleHROb2RlKG5vZGUsIGZvcndhcmQpIHtcbiAgICAgIHZhciBpc1RleHROb2RlID0gbm9kZS5ub2RlVHlwZSA9PSB3eXNpaHRtbDUuVEVYVF9OT0RFO1xuICAgICAgdmFyIGVsID0gaXNUZXh0Tm9kZSA/IG5vZGUucGFyZW50Tm9kZSA6IG5vZGU7XG4gICAgICB2YXIgYWRqYWNlbnROb2RlO1xuICAgICAgdmFyIHByb3BOYW1lID0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCI7XG4gICAgICBpZiAoaXNUZXh0Tm9kZSkge1xuICAgICAgICAvLyBDYW4gbWVyZ2UgaWYgdGhlIG5vZGUncyBwcmV2aW91cy9uZXh0IHNpYmxpbmcgaXMgYSB0ZXh0IG5vZGVcbiAgICAgICAgYWRqYWNlbnROb2RlID0gbm9kZVtwcm9wTmFtZV07XG4gICAgICAgIGlmIChhZGphY2VudE5vZGUgJiYgYWRqYWNlbnROb2RlLm5vZGVUeXBlID09IHd5c2lodG1sNS5URVhUX05PREUpIHtcbiAgICAgICAgICByZXR1cm4gYWRqYWNlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb21wYXJlIGVsZW1lbnQgd2l0aCBpdHMgc2libGluZ1xuICAgICAgICBhZGphY2VudE5vZGUgPSBlbFtwcm9wTmFtZV07XG4gICAgICAgIGlmIChhZGphY2VudE5vZGUgJiYgdGhpcy5hcmVFbGVtZW50c01lcmdlYWJsZShub2RlLCBhZGphY2VudE5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGFkamFjZW50Tm9kZVtmb3J3YXJkID8gXCJmaXJzdENoaWxkXCIgOiBcImxhc3RDaGlsZFwiXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGFyZUVsZW1lbnRzTWVyZ2VhYmxlOiBmdW5jdGlvbiBhcmVFbGVtZW50c01lcmdlYWJsZShlbDEsIGVsMikge1xuICAgICAgcmV0dXJuIHJhbmd5LmRvbS5hcnJheUNvbnRhaW5zKHRoaXMudGFnTmFtZXMsIChlbDEudGFnTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpKSAmJiByYW5neS5kb20uYXJyYXlDb250YWlucyh0aGlzLnRhZ05hbWVzLCAoZWwyLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSkgJiYgaGFzU2FtZUNsYXNzZXMoZWwxLCBlbDIpICYmIGVsZW1lbnRzSGF2ZVNhbWVOb25DbGFzc0F0dHJpYnV0ZXMoZWwxLCBlbDIpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVDb250YWluZXI6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihkb2MpIHtcbiAgICAgIHZhciBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KHRoaXMudGFnTmFtZXNbMF0pO1xuICAgICAgaWYgKHRoaXMuY3NzQ2xhc3MpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gdGhpcy5jc3NDbGFzcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgYXBwbHlUb1RleHROb2RlOiBmdW5jdGlvbiBhcHBseVRvVGV4dE5vZGUodGV4dE5vZGUpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0ZXh0Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIHJhbmd5LmRvbS5hcnJheUNvbnRhaW5zKHRoaXMudGFnTmFtZXMsIHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGlmICh0aGlzLmNzc0NsYXNzKSB7XG4gICAgICAgICAgYWRkQ2xhc3MocGFyZW50LCB0aGlzLmNzc0NsYXNzLCB0aGlzLnNpbWlsYXJDbGFzc1JlZ0V4cCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuY3JlYXRlQ29udGFpbmVyKHJhbmd5LmRvbS5nZXREb2N1bWVudCh0ZXh0Tm9kZSkpO1xuICAgICAgICB0ZXh0Tm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgdGV4dE5vZGUpO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzUmVtb3ZhYmxlOiBmdW5jdGlvbiBpc1JlbW92YWJsZShlbCkge1xuICAgICAgcmV0dXJuIHJhbmd5LmRvbS5hcnJheUNvbnRhaW5zKHRoaXMudGFnTmFtZXMsIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgJiYgd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKGVsLmNsYXNzTmFtZSkudHJpbSgpID09IHRoaXMuY3NzQ2xhc3M7XG4gICAgfSxcblxuICAgIHVuZG9Ub1RleHROb2RlOiBmdW5jdGlvbiB1bmRvVG9UZXh0Tm9kZSh0ZXh0Tm9kZSwgcmFuZ2UsIGFuY2VzdG9yV2l0aENsYXNzKSB7XG4gICAgICBpZiAoIXJhbmdlLmNvbnRhaW5zTm9kZShhbmNlc3RvcldpdGhDbGFzcykpIHtcbiAgICAgICAgLy8gU3BsaXQgb3V0IHRoZSBwb3J0aW9uIG9mIHRoZSBhbmNlc3RvciBmcm9tIHdoaWNoIHdlIGNhbiByZW1vdmUgdGhlIENTUyBjbGFzc1xuICAgICAgICB2YXIgYW5jZXN0b3JSYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgYW5jZXN0b3JSYW5nZS5zZWxlY3ROb2RlKGFuY2VzdG9yV2l0aENsYXNzKTtcblxuICAgICAgICBpZiAoYW5jZXN0b3JSYW5nZS5pc1BvaW50SW5SYW5nZShyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCkgJiYgaXNTcGxpdFBvaW50KHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KSkge1xuICAgICAgICAgIHNwbGl0Tm9kZUF0KGFuY2VzdG9yV2l0aENsYXNzLCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIoYW5jZXN0b3JXaXRoQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmNlc3RvclJhbmdlLmlzUG9pbnRJblJhbmdlKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCkgJiYgaXNTcGxpdFBvaW50KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCkpIHtcbiAgICAgICAgICBhbmNlc3RvcldpdGhDbGFzcyA9IHNwbGl0Tm9kZUF0KGFuY2VzdG9yV2l0aENsYXNzLCByYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNpbWlsYXJDbGFzc1JlZ0V4cCkge1xuICAgICAgICByZW1vdmVDbGFzcyhhbmNlc3RvcldpdGhDbGFzcywgdGhpcy5zaW1pbGFyQ2xhc3NSZWdFeHApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNSZW1vdmFibGUoYW5jZXN0b3JXaXRoQ2xhc3MpKSB7XG4gICAgICAgIHJlcGxhY2VXaXRoT3duQ2hpbGRyZW4oYW5jZXN0b3JXaXRoQ2xhc3MpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhcHBseVRvUmFuZ2U6IGZ1bmN0aW9uIGFwcGx5VG9SYW5nZShyYW5nZSkge1xuICAgICAgdmFyIHRleHROb2RlcyA9IHJhbmdlLmdldE5vZGVzKFt3eXNpaHRtbDUuVEVYVF9OT0RFXSk7XG4gICAgICBpZiAoIXRleHROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlQ29udGFpbmVyKHJhbmdlLmVuZENvbnRhaW5lci5vd25lckRvY3VtZW50KTtcbiAgICAgICAgICByYW5nZS5zdXJyb3VuZENvbnRlbnRzKG5vZGUpO1xuICAgICAgICAgIHRoaXMuc2VsZWN0Tm9kZShyYW5nZSwgbm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuXG4gICAgICByYW5nZS5zcGxpdEJvdW5kYXJpZXMoKTtcbiAgICAgIHRleHROb2RlcyA9IHJhbmdlLmdldE5vZGVzKFt3eXNpaHRtbDUuVEVYVF9OT0RFXSk7XG5cbiAgICAgIGlmICh0ZXh0Tm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0ZXh0Tm9kZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGV4dE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgdGV4dE5vZGUgPSB0ZXh0Tm9kZXNbaV07XG4gICAgICAgICAgaWYgKCF0aGlzLmdldEFuY2VzdG9yV2l0aENsYXNzKHRleHROb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5hcHBseVRvVGV4dE5vZGUodGV4dE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KHRleHROb2Rlc1swXSwgMCk7XG4gICAgICAgIHRleHROb2RlID0gdGV4dE5vZGVzW3RleHROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKHRleHROb2RlLCB0ZXh0Tm9kZS5sZW5ndGgpO1xuXG4gICAgICAgIGlmICh0aGlzLm5vcm1hbGl6ZSkge1xuICAgICAgICAgIHRoaXMucG9zdEFwcGx5KHRleHROb2RlcywgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVuZG9Ub1JhbmdlOiBmdW5jdGlvbiB1bmRvVG9SYW5nZShyYW5nZSkge1xuICAgICAgdmFyIHRleHROb2RlcyA9IHJhbmdlLmdldE5vZGVzKFt3eXNpaHRtbDUuVEVYVF9OT0RFXSksXG4gICAgICAgICAgdGV4dE5vZGUsXG4gICAgICAgICAgYW5jZXN0b3JXaXRoQ2xhc3M7XG4gICAgICBpZiAodGV4dE5vZGVzLmxlbmd0aCkge1xuICAgICAgICByYW5nZS5zcGxpdEJvdW5kYXJpZXMoKTtcbiAgICAgICAgdGV4dE5vZGVzID0gcmFuZ2UuZ2V0Tm9kZXMoW3d5c2lodG1sNS5URVhUX05PREVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkb2MgPSByYW5nZS5lbmRDb250YWluZXIub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgIG5vZGUgPSBkb2MuY3JlYXRlVGV4dE5vZGUod3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRSk7XG4gICAgICAgIHJhbmdlLmluc2VydE5vZGUobm9kZSk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGUobm9kZSk7XG4gICAgICAgIHRleHROb2RlcyA9IFtub2RlXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB0ZXh0Tm9kZSA9IHRleHROb2Rlc1tpXTtcbiAgICAgICAgYW5jZXN0b3JXaXRoQ2xhc3MgPSB0aGlzLmdldEFuY2VzdG9yV2l0aENsYXNzKHRleHROb2RlKTtcbiAgICAgICAgaWYgKGFuY2VzdG9yV2l0aENsYXNzKSB7XG4gICAgICAgICAgdGhpcy51bmRvVG9UZXh0Tm9kZSh0ZXh0Tm9kZSwgcmFuZ2UsIGFuY2VzdG9yV2l0aENsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVuID09IDEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3ROb2RlKHJhbmdlLCB0ZXh0Tm9kZXNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGV4dE5vZGVzWzBdLCAwKTtcbiAgICAgICAgdGV4dE5vZGUgPSB0ZXh0Tm9kZXNbdGV4dE5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICByYW5nZS5zZXRFbmQodGV4dE5vZGUsIHRleHROb2RlLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMubm9ybWFsaXplKSB7XG4gICAgICAgICAgdGhpcy5wb3N0QXBwbHkodGV4dE5vZGVzLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0Tm9kZTogZnVuY3Rpb24gc2VsZWN0Tm9kZShyYW5nZSwgbm9kZSkge1xuICAgICAgdmFyIGlzRWxlbWVudCA9IG5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5FTEVNRU5UX05PREUsXG4gICAgICAgICAgY2FuSGF2ZUhUTUwgPSBcImNhbkhhdmVIVE1MXCIgaW4gbm9kZSA/IG5vZGUuY2FuSGF2ZUhUTUwgOiB0cnVlLFxuICAgICAgICAgIGNvbnRlbnQgPSBpc0VsZW1lbnQgPyBub2RlLmlubmVySFRNTCA6IG5vZGUuZGF0YSxcbiAgICAgICAgICBpc0VtcHR5ID0gY29udGVudCA9PT0gXCJcIiB8fCBjb250ZW50ID09PSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFO1xuXG4gICAgICBpZiAoaXNFbXB0eSAmJiBpc0VsZW1lbnQgJiYgY2FuSGF2ZUhUTUwpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgY2FyZXQgaXMgdmlzaWJsZSBpbiBub2RlIGJ5IGluc2VydGluZyBhIHplcm8gd2lkdGggbm8gYnJlYWtpbmcgc3BhY2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBub2RlLmlubmVySFRNTCA9IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0U7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG4gICAgICBpZiAoaXNFbXB0eSAmJiBpc0VsZW1lbnQpIHtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChpc0VtcHR5KSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIobm9kZSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRUZXh0U2VsZWN0ZWRCeVJhbmdlOiBmdW5jdGlvbiBnZXRUZXh0U2VsZWN0ZWRCeVJhbmdlKHRleHROb2RlLCByYW5nZSkge1xuICAgICAgdmFyIHRleHRSYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgIHRleHRSYW5nZS5zZWxlY3ROb2RlQ29udGVudHModGV4dE5vZGUpO1xuXG4gICAgICB2YXIgaW50ZXJzZWN0aW9uUmFuZ2UgPSB0ZXh0UmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlKTtcbiAgICAgIHZhciB0ZXh0ID0gaW50ZXJzZWN0aW9uUmFuZ2UgPyBpbnRlcnNlY3Rpb25SYW5nZS50b1N0cmluZygpIDogXCJcIjtcbiAgICAgIHRleHRSYW5nZS5kZXRhY2goKTtcblxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSxcblxuICAgIGlzQXBwbGllZFRvUmFuZ2U6IGZ1bmN0aW9uIGlzQXBwbGllZFRvUmFuZ2UocmFuZ2UpIHtcbiAgICAgIHZhciBhbmNlc3RvcnMgPSBbXSxcbiAgICAgICAgICBhbmNlc3RvcixcbiAgICAgICAgICB0ZXh0Tm9kZXMgPSByYW5nZS5nZXROb2Rlcyhbd3lzaWh0bWw1LlRFWFRfTk9ERV0pO1xuICAgICAgaWYgKCF0ZXh0Tm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGFuY2VzdG9yID0gdGhpcy5nZXRBbmNlc3RvcldpdGhDbGFzcyhyYW5nZS5zdGFydENvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBhbmNlc3RvciA/IFthbmNlc3Rvcl0gOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHROb2Rlcy5sZW5ndGgsIHNlbGVjdGVkVGV4dDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHNlbGVjdGVkVGV4dCA9IHRoaXMuZ2V0VGV4dFNlbGVjdGVkQnlSYW5nZSh0ZXh0Tm9kZXNbaV0sIHJhbmdlKTtcbiAgICAgICAgYW5jZXN0b3IgPSB0aGlzLmdldEFuY2VzdG9yV2l0aENsYXNzKHRleHROb2Rlc1tpXSk7XG4gICAgICAgIGlmIChzZWxlY3RlZFRleHQgIT0gXCJcIiAmJiAhYW5jZXN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYW5jZXN0b3JzO1xuICAgIH0sXG5cbiAgICB0b2dnbGVSYW5nZTogZnVuY3Rpb24gdG9nZ2xlUmFuZ2UocmFuZ2UpIHtcbiAgICAgIGlmICh0aGlzLmlzQXBwbGllZFRvUmFuZ2UocmFuZ2UpKSB7XG4gICAgICAgIHRoaXMudW5kb1RvUmFuZ2UocmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHBseVRvUmFuZ2UocmFuZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3eXNpaHRtbDUuc2VsZWN0aW9uLkhUTUxBcHBsaWVyID0gSFRNTEFwcGxpZXI7XG59KSh3eXNpaHRtbDUsIHJhbmd5KTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgKiBSaWNoIFRleHQgUXVlcnkvRm9ybWF0dGluZyBDb21tYW5kc1xuICAgICAgICAgICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICogICAgdmFyIGNvbW1hbmRzID0gbmV3IHd5c2lodG1sNS5Db21tYW5kcyhlZGl0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICovXG53eXNpaHRtbDUuQ29tbWFuZHMgPSBCYXNlLmV4dGVuZChcbi8qKiBAc2NvcGUgd3lzaWh0bWw1LkNvbW1hbmRzLnByb3RvdHlwZSAqL3tcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuY29tcG9zZXIgPSBlZGl0b3IuY29tcG9zZXI7XG4gICAgdGhpcy5kb2MgPSB0aGlzLmNvbXBvc2VyLmRvYztcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgZ2l2ZW4gY29tbWFuZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29tbWFuZCBUaGUgY29tbWFuZCBzdHJpbmcgd2hpY2ggdG8gY2hlY2sgKGVnLiBcImJvbGRcIiwgXCJpdGFsaWNcIiwgXCJpbnNlcnRVbm9yZGVyZWRMaXN0XCIpXG4gICAqIEBleGFtcGxlXG4gICAqICAgIGNvbW1hbmRzLnN1cHBvcnRzKFwiY3JlYXRlTGlua1wiKTtcbiAgICovXG4gIHN1cHBvcnQ6IGZ1bmN0aW9uIHN1cHBvcnQoY29tbWFuZCkge1xuICAgIHJldHVybiB3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c0NvbW1hbmQodGhpcy5kb2MsIGNvbW1hbmQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBnaXZlbiBjb21tYW5kXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb21tYW5kIFRoZSBjb21tYW5kIHN0cmluZyB3aGljaCB0byBleGVjdXRlIChlZy4gXCJib2xkXCIsIFwiaXRhbGljXCIsIFwiaW5zZXJ0VW5vcmRlcmVkTGlzdFwiKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3ZhbHVlXSBUaGUgY29tbWFuZCB2YWx1ZSBwYXJhbWV0ZXIsIG5lZWRlZCBmb3Igc29tZSBjb21tYW5kcyAoXCJjcmVhdGVMaW5rXCIsIFwiaW5zZXJ0SW1hZ2VcIiwgLi4uKSwgb3B0aW9uYWwgZm9yIGNvbW1hbmRzIHRoYXQgZG9uJ3QgcmVxdWlyZSBvbmUgKFwiYm9sZFwiLCBcInVuZGVybGluZVwiLCAuLi4pXG4gICAqIEBleGFtcGxlXG4gICAqICAgIGNvbW1hbmRzLmV4ZWMoXCJpbnNlcnRJbWFnZVwiLCBcImh0dHA6Ly9hMS50d2ltZy5jb20vcHJvZmlsZV9pbWFnZXMvMTEzODY4NjU1L3NjaHJlaV90d2l0dGVyX3JlYXNvbmFibHlfc21hbGwuanBnXCIpO1xuICAgKi9cbiAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21tYW5kLCB2YWx1ZSkge1xuICAgIHZhciBvYmogPSB3eXNpaHRtbDUuY29tbWFuZHNbY29tbWFuZF0sXG4gICAgICAgIGFyZ3MgPSB3eXNpaHRtbDUubGFuZy5hcnJheShhcmd1bWVudHMpLmdldCgpLFxuICAgICAgICBtZXRob2QgPSBvYmogJiYgb2JqLmV4ZWMsXG4gICAgICAgIHJlc3VsdCA9IG51bGw7XG5cbiAgICB0aGlzLmVkaXRvci5maXJlKFwiYmVmb3JlY29tbWFuZDpjb21wb3NlclwiKTtcblxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLmNvbXBvc2VyKTtcbiAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseShvYmosIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyB0cnkvY2F0Y2ggZm9yIGJ1Z2d5IGZpcmVmb3hcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5kb2MuZXhlY0NvbW1hbmQoY29tbWFuZCwgZmFsc2UsIHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdGhpcy5lZGl0b3IuZmlyZShcImFmdGVyY29tbWFuZDpjb21wb3NlclwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBjdXJyZW50IGNvbW1hbmQgaXMgYWN0aXZlXG4gICAqIElmIHRoZSBjYXJldCBpcyB3aXRoaW4gYSBib2xkIHRleHQsIHRoZW4gY2FsbGluZyB0aGlzIHdpdGggY29tbWFuZCBcImJvbGRcIiBzaG91bGQgcmV0dXJuIHRydWVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbW1hbmQgVGhlIGNvbW1hbmQgc3RyaW5nIHdoaWNoIHRvIGNoZWNrIChlZy4gXCJib2xkXCIsIFwiaXRhbGljXCIsIFwiaW5zZXJ0VW5vcmRlcmVkTGlzdFwiKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbW1hbmRWYWx1ZV0gVGhlIGNvbW1hbmQgdmFsdWUgcGFyYW1ldGVyIChlZy4gZm9yIFwiaW5zZXJ0SW1hZ2VcIiB0aGUgaW1hZ2Ugc3JjKVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBjb21tYW5kIGlzIGFjdGl2ZVxuICAgKiBAZXhhbXBsZVxuICAgKiAgICB2YXIgaXNDdXJyZW50U2VsZWN0aW9uQm9sZCA9IGNvbW1hbmRzLnN0YXRlKFwiYm9sZFwiKTtcbiAgICovXG4gIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21tYW5kLCBjb21tYW5kVmFsdWUpIHtcbiAgICB2YXIgb2JqID0gd3lzaWh0bWw1LmNvbW1hbmRzW2NvbW1hbmRdLFxuICAgICAgICBhcmdzID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoYXJndW1lbnRzKS5nZXQoKSxcbiAgICAgICAgbWV0aG9kID0gb2JqICYmIG9iai5zdGF0ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5jb21wb3Nlcik7XG4gICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHRyeS9jYXRjaCBmb3IgYnVnZ3kgZmlyZWZveFxuICAgICAgICByZXR1cm4gdGhpcy5kb2MucXVlcnlDb21tYW5kU3RhdGUoY29tbWFuZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBjb21tYW5kJ3MgdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbW1hbmQgVGhlIGNvbW1hbmQgc3RyaW5nIHdoaWNoIHRvIGNoZWNrIChlZy4gXCJmb3JtYXRCbG9ja1wiKVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjb21tYW5kIHZhbHVlXG4gICAqIEBleGFtcGxlXG4gICAqICAgIHZhciBjdXJyZW50QmxvY2tFbGVtZW50ID0gY29tbWFuZHMudmFsdWUoXCJmb3JtYXRCbG9ja1wiKTtcbiAgICovXG4gIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShjb21tYW5kKSB7XG4gICAgdmFyIG9iaiA9IHd5c2lodG1sNS5jb21tYW5kc1tjb21tYW5kXSxcbiAgICAgICAgbWV0aG9kID0gb2JqICYmIG9iai52YWx1ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNhbGwob2JqLCB0aGlzLmNvbXBvc2VyLCBjb21tYW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdHJ5L2NhdGNoIGZvciBidWdneSBmaXJlZm94XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5xdWVyeUNvbW1hbmRWYWx1ZShjb21tYW5kKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZjtcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuYm9sZCA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5leGVjKGNvbXBvc2VyLCBjb21tYW5kLCBcImJcIik7XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21wb3NlciwgY29tbWFuZCwgY29sb3IpIHtcbiAgICAgIC8vIGVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZShcImJvbGRcIikgcmVzdWx0czpcbiAgICAgIC8vIGZpcmVmb3g6IG9ubHkgPGI+XG4gICAgICAvLyBjaHJvbWU6ICA8Yj4sIDxzdHJvbmc+LCA8aDE+LCA8aDI+LCAuLi5cbiAgICAgIC8vIGllOiAgICAgIDxiPiwgPHN0cm9uZz5cbiAgICAgIC8vIG9wZXJhOiAgIDxiPiwgPHN0cm9uZz5cbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBcImJcIik7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWYsXG4gICAgICBOT0RFX05BTUUgPSBcIkFcIixcbiAgICAgIGRvbSA9IHd5c2lodG1sNS5kb207XG5cbiAgZnVuY3Rpb24gX3JlbW92ZUZvcm1hdChjb21wb3NlciwgYW5jaG9ycykge1xuICAgIHZhciBsZW5ndGggPSBhbmNob3JzLmxlbmd0aCxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgY29kZUVsZW1lbnQsXG4gICAgICAgIHRleHRDb250ZW50O1xuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGFuY2hvciA9IGFuY2hvcnNbaV07XG4gICAgICBjb2RlRWxlbWVudCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGFuY2hvciwgeyBub2RlTmFtZTogXCJjb2RlXCIgfSk7XG4gICAgICB0ZXh0Q29udGVudCA9IGRvbS5nZXRUZXh0Q29udGVudChhbmNob3IpO1xuXG4gICAgICAvLyBpZiA8YT4gY29udGFpbnMgdXJsLWxpa2UgdGV4dCBjb250ZW50LCByZW5hbWUgaXQgdG8gPGNvZGU+IHRvIHByZXZlbnQgcmUtYXV0b2xpbmtpbmdcbiAgICAgIC8vIGVsc2UgcmVwbGFjZSA8YT4gd2l0aCBpdHMgY2hpbGROb2Rlc1xuICAgICAgaWYgKHRleHRDb250ZW50Lm1hdGNoKGRvbS5hdXRvTGluay5VUkxfUkVHX0VYUCkgJiYgIWNvZGVFbGVtZW50KSB7XG4gICAgICAgIC8vIDxjb2RlPiBlbGVtZW50IGlzIHVzZWQgdG8gcHJldmVudCBsYXRlciBhdXRvLWxpbmtpbmcgb2YgdGhlIGNvbnRlbnRcbiAgICAgICAgY29kZUVsZW1lbnQgPSBkb20ucmVuYW1lRWxlbWVudChhbmNob3IsIFwiY29kZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXMoYW5jaG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZm9ybWF0KGNvbXBvc2VyLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGRvYyA9IGNvbXBvc2VyLmRvYyxcbiAgICAgICAgdGVtcENsYXNzID0gXCJfd3lzaWh0bWw1LXRlbXAtXCIgKyArbmV3IERhdGUoKSxcbiAgICAgICAgdGVtcENsYXNzUmVnRXhwID0gL25vbi1tYXRjaGluZy1jbGFzcy9nLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBhbmNob3JzLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGhhc0VsZW1lbnRDaGlsZCxcbiAgICAgICAgaXNFbXB0eSxcbiAgICAgICAgZWxlbWVudFRvU2V0Q2FyZXRBZnRlcixcbiAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgIHdoaXRlU3BhY2UsXG4gICAgICAgIGo7XG4gICAgd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5leGVjKGNvbXBvc2VyLCB1bmRlZiwgTk9ERV9OQU1FLCB0ZW1wQ2xhc3MsIHRlbXBDbGFzc1JlZ0V4cCk7XG4gICAgYW5jaG9ycyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKE5PREVfTkFNRSArIFwiLlwiICsgdGVtcENsYXNzKTtcbiAgICBsZW5ndGggPSBhbmNob3JzLmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBhbmNob3IgPSBhbmNob3JzW2ldO1xuICAgICAgYW5jaG9yLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgICAgZm9yIChqIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZShqLCBhdHRyaWJ1dGVzW2pdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtZW50VG9TZXRDYXJldEFmdGVyID0gYW5jaG9yO1xuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIHRleHRDb250ZW50ID0gZG9tLmdldFRleHRDb250ZW50KGFuY2hvcik7XG4gICAgICBoYXNFbGVtZW50Q2hpbGQgPSAhIWFuY2hvci5xdWVyeVNlbGVjdG9yKFwiKlwiKTtcbiAgICAgIGlzRW1wdHkgPSB0ZXh0Q29udGVudCA9PT0gXCJcIiB8fCB0ZXh0Q29udGVudCA9PT0gd3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRTtcbiAgICAgIGlmICghaGFzRWxlbWVudENoaWxkICYmIGlzRW1wdHkpIHtcbiAgICAgICAgZG9tLnNldFRleHRDb250ZW50KGFuY2hvciwgYXR0cmlidXRlcy50ZXh0IHx8IGFuY2hvci5ocmVmKTtcbiAgICAgICAgd2hpdGVTcGFjZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZShcIiBcIik7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZXRBZnRlcihhbmNob3IpO1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uaW5zZXJ0Tm9kZSh3aGl0ZVNwYWNlKTtcbiAgICAgICAgZWxlbWVudFRvU2V0Q2FyZXRBZnRlciA9IHdoaXRlU3BhY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZXRBZnRlcihlbGVtZW50VG9TZXRDYXJldEFmdGVyKTtcbiAgfVxuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5jcmVhdGVMaW5rID0ge1xuICAgIC8qKlxuICAgICAqIFRPRE86IFVzZSBIVE1MQXBwbGllciBvciBmb3JtYXRJbmxpbmUgaGVyZVxuICAgICAqXG4gICAgICogVHVybnMgc2VsZWN0aW9uIGludG8gYSBsaW5rXG4gICAgICogSWYgc2VsZWN0aW9uIGlzIGFscmVhZHkgYSBsaW5rLCBpdCByZW1vdmVzIHRoZSBsaW5rIGFuZCB3cmFwcyBpdCB3aXRoIGEgPGNvZGU+IGVsZW1lbnRcbiAgICAgKiBUaGUgPGNvZGU+IGVsZW1lbnQgaXMgbmVlZGVkIHRvIGF2b2lkIGF1dG8gbGlua2luZ1xuICAgICAqIFxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgLy8gZWl0aGVyIC4uLlxuICAgICAqICAgIHd5c2lodG1sNS5jb21tYW5kcy5jcmVhdGVMaW5rLmV4ZWMoY29tcG9zZXIsIFwiY3JlYXRlTGlua1wiLCBcImh0dHA6Ly93d3cuZ29vZ2xlLmRlXCIpO1xuICAgICAqICAgIC8vIC4uLiBvciAuLi5cbiAgICAgKiAgICB3eXNpaHRtbDUuY29tbWFuZHMuY3JlYXRlTGluay5leGVjKGNvbXBvc2VyLCBcImNyZWF0ZUxpbmtcIiwgeyBocmVmOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmRlXCIsIHRhcmdldDogXCJfYmxhbmtcIiB9KTtcbiAgICAgKi9cbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kLCB2YWx1ZSkge1xuICAgICAgdmFyIGFuY2hvcnMgPSB0aGlzLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kKTtcbiAgICAgIGlmIChhbmNob3JzKSB7XG4gICAgICAgIC8vIFNlbGVjdGlvbiBjb250YWlucyBsaW5rc1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF9yZW1vdmVGb3JtYXQoY29tcG9zZXIsIGFuY2hvcnMpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBsaW5rc1xuICAgICAgICB2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih2YWx1ZSkpID09PSBcIm9iamVjdFwiID8gdmFsdWUgOiB7IGhyZWY6IHZhbHVlIH07XG4gICAgICAgIF9mb3JtYXQoY29tcG9zZXIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJBXCIpO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsgLyoqXG4gICAgICAgICAgICAgICAqIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiZm9udFNpemVcIikgd2lsbCBjcmVhdGUgZWl0aGVyIGlubGluZSBzdHlsZXMgKGZpcmVmb3gsIGNocm9tZSkgb3IgdXNlIGZvbnQgdGFnc1xuICAgICAgICAgICAgICAgKiB3aGljaCB3ZSBkb24ndCB3YW50XG4gICAgICAgICAgICAgICAqIEluc3RlYWQgd2Ugc2V0IGEgY3NzIGNsYXNzXG4gICAgICAgICAgICAgICAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmLFxuICAgICAgUkVHX0VYUCA9IC93eXNpd3lnLWZvbnQtc2l6ZS1bYS16XFwtXSsvZztcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuZm9udFNpemUgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCwgc2l6ZSkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuZXhlYyhjb21wb3NlciwgY29tbWFuZCwgXCJzcGFuXCIsIFwid3lzaXd5Zy1mb250LXNpemUtXCIgKyBzaXplLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBzaXplKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJzcGFuXCIsIFwid3lzaXd5Zy1mb250LXNpemUtXCIgKyBzaXplLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7XG4vKipcbiAqIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiZm9yZUNvbG9yXCIpIHdpbGwgY3JlYXRlIGVpdGhlciBpbmxpbmUgc3R5bGVzIChmaXJlZm94LCBjaHJvbWUpIG9yIHVzZSBmb250IHRhZ3NcbiAqIHdoaWNoIHdlIGRvbid0IHdhbnRcbiAqIEluc3RlYWQgd2Ugc2V0IGEgY3NzIGNsYXNzXG4gKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZixcbiAgICAgIFJFR19FWFAgPSAvd3lzaXd5Zy1jb2xvci1bYS16XSsvZztcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuZm9yZUNvbG9yID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIGNvbG9yKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5leGVjKGNvbXBvc2VyLCBjb21tYW5kLCBcInNwYW5cIiwgXCJ3eXNpd3lnLWNvbG9yLVwiICsgY29sb3IsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIGNvbG9yKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJzcGFuXCIsIFwid3lzaXd5Zy1jb2xvci1cIiArIGNvbG9yLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmLFxuICAgICAgZG9tID0gd3lzaWh0bWw1LmRvbSxcbiAgICAgIERFRkFVTFRfTk9ERV9OQU1FID0gXCJESVZcIixcblxuICAvLyBGb2xsb3dpbmcgZWxlbWVudHMgYXJlIGdyb3VwZWRcbiAgLy8gd2hlbiB0aGUgY2FyZXQgaXMgd2l0aGluIGEgSDEgYW5kIHRoZSBINCBpcyBpbnZva2VkLCB0aGUgSDEgc2hvdWxkIHR1cm4gaW50byBINFxuICAvLyBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgSDQgd2l0aGluIGEgSDEgd2hpY2ggd291bGQgcmVzdWx0IGluIHNlbWFudGljYWxseSBpbnZhbGlkIGh0bWxcbiAgQkxPQ0tfRUxFTUVOVFNfR1JPVVAgPSBbXCJIMVwiLCBcIkgyXCIsIFwiSDNcIiwgXCJINFwiLCBcIkg1XCIsIFwiSDZcIiwgXCJQXCIsIFwiQkxPQ0tRVU9URVwiLCBERUZBVUxUX05PREVfTkFNRV07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzaW1pbGlhciBjbGFzc2VzIChiYXNlZCBvbiBjbGFzc1JlZ0V4cClcbiAgICogYW5kIGFkZCB0aGUgZGVzaXJlZCBjbGFzcyBuYW1lXG4gICAqL1xuICBmdW5jdGlvbiBfYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkge1xuICAgIGlmIChlbGVtZW50LmNsYXNzTmFtZSkge1xuICAgICAgX3JlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzUmVnRXhwKTtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NSZWdFeHApIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoY2xhc3NSZWdFeHAsIFwiXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgZ2l2ZW4gbm9kZSBpcyBhIHRleHQgbm9kZSBhbmQgd2hldGhlciBpdCdzIGVtcHR5XG4gICAqL1xuICBmdW5jdGlvbiBfaXNCbGFua1RleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gd3lzaWh0bWw1LlRFWFRfTk9ERSAmJiAhd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKG5vZGUuZGF0YSkudHJpbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcHJldmlvdXMgc2libGluZyBub2RlIHRoYXQgaXMgbm90IGEgYmxhbmsgdGV4dCBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0UHJldmlvdXNTaWJsaW5nVGhhdElzTm90Qmxhbmsobm9kZSkge1xuICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICB3aGlsZSAocHJldmlvdXNTaWJsaW5nICYmIF9pc0JsYW5rVGV4dE5vZGUocHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgcHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXNTaWJsaW5nLnByZXZpb3VzU2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIHByZXZpb3VzU2libGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5leHQgc2libGluZyBub2RlIHRoYXQgaXMgbm90IGEgYmxhbmsgdGV4dCBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0TmV4dFNpYmxpbmdUaGF0SXNOb3RCbGFuayhub2RlKSB7XG4gICAgdmFyIG5leHRTaWJsaW5nID0gbm9kZS5uZXh0U2libGluZztcbiAgICB3aGlsZSAobmV4dFNpYmxpbmcgJiYgX2lzQmxhbmtUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBuZXh0U2libGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGxpbmUgYnJlYWtzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGdpdmVuIG5vZGUgaWYgdGhlIHByZXZpb3VzIGFuZCBuZXh0IHNpYmxpbmdzXG4gICAqIGFyZW4ndCBhbHJlYWR5IGNhdXNpbmcgYSB2aXN1YWwgbGluZSBicmVhayAoYmxvY2sgZWxlbWVudCBvciA8YnI+KVxuICAgKi9cbiAgZnVuY3Rpb24gX2FkZExpbmVCcmVha0JlZm9yZUFuZEFmdGVyKG5vZGUpIHtcbiAgICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50LFxuICAgICAgICBuZXh0U2libGluZyA9IF9nZXROZXh0U2libGluZ1RoYXRJc05vdEJsYW5rKG5vZGUpLFxuICAgICAgICBwcmV2aW91c1NpYmxpbmcgPSBfZ2V0UHJldmlvdXNTaWJsaW5nVGhhdElzTm90Qmxhbmsobm9kZSk7XG5cbiAgICBpZiAobmV4dFNpYmxpbmcgJiYgIV9pc0xpbmVCcmVha09yQmxvY2tFbGVtZW50KG5leHRTaWJsaW5nKSkge1xuICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkb2MuY3JlYXRlRWxlbWVudChcImJyXCIpLCBuZXh0U2libGluZyk7XG4gICAgfVxuICAgIGlmIChwcmV2aW91c1NpYmxpbmcgJiYgIV9pc0xpbmVCcmVha09yQmxvY2tFbGVtZW50KHByZXZpb3VzU2libGluZykpIHtcbiAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9jLmNyZWF0ZUVsZW1lbnQoXCJiclwiKSwgbm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgbGluZSBicmVha3MgYmVmb3JlIGFuZCBhZnRlciB0aGUgZ2l2ZW4gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gX3JlbW92ZUxpbmVCcmVha0JlZm9yZUFuZEFmdGVyKG5vZGUpIHtcbiAgICB2YXIgbmV4dFNpYmxpbmcgPSBfZ2V0TmV4dFNpYmxpbmdUaGF0SXNOb3RCbGFuayhub2RlKSxcbiAgICAgICAgcHJldmlvdXNTaWJsaW5nID0gX2dldFByZXZpb3VzU2libGluZ1RoYXRJc05vdEJsYW5rKG5vZGUpO1xuXG4gICAgaWYgKG5leHRTaWJsaW5nICYmIF9pc0xpbmVCcmVhayhuZXh0U2libGluZykpIHtcbiAgICAgIG5leHRTaWJsaW5nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobmV4dFNpYmxpbmcpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXNTaWJsaW5nICYmIF9pc0xpbmVCcmVhayhwcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICBwcmV2aW91c1NpYmxpbmcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aW91c1NpYmxpbmcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9yZW1vdmVMYXN0Q2hpbGRJZkxpbmVCcmVhayhub2RlKSB7XG4gICAgdmFyIGxhc3RDaGlsZCA9IG5vZGUubGFzdENoaWxkO1xuICAgIGlmIChsYXN0Q2hpbGQgJiYgX2lzTGluZUJyZWFrKGxhc3RDaGlsZCkpIHtcbiAgICAgIGxhc3RDaGlsZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxhc3RDaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2lzTGluZUJyZWFrKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlTmFtZSA9PT0gXCJCUlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBlbG1lbnQgY2F1c2VzIGEgdmlzdWFsIGxpbmUgYnJlYWtcbiAgICogKDxicj4gb3IgYmxvY2sgZWxlbWVudHMpXG4gICAqL1xuICBmdW5jdGlvbiBfaXNMaW5lQnJlYWtPckJsb2NrRWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKF9pc0xpbmVCcmVhayhlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGRvbS5nZXRTdHlsZShcImRpc3BsYXlcIikuZnJvbShlbGVtZW50KSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBuYXRpdmUgcXVlcnkgY29tbWFuZFxuICAgKiBhbmQgaWYgbmVjZXNzYXJ5IG1vZGlmeSB0aGUgaW5zZXJ0ZWQgbm9kZSdzIGNsYXNzTmFtZVxuICAgKi9cbiAgZnVuY3Rpb24gX2V4ZWNDb21tYW5kKGRvYywgY29tbWFuZCwgbm9kZU5hbWUsIGNsYXNzTmFtZSkge1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIHZhciBldmVudExpc3RlbmVyID0gZG9tLm9ic2VydmUoZG9jLCBcIkRPTU5vZGVJbnNlcnRlZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgIGRpc3BsYXlTdHlsZTtcbiAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSAhPT0gd3lzaWh0bWw1LkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkaXNwbGF5U3R5bGUgPSBkb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20odGFyZ2V0KTtcbiAgICAgICAgaWYgKGRpc3BsYXlTdHlsZS5zdWJzdHIoMCwgNikgIT09IFwiaW5saW5lXCIpIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBvbmx5IGJsb2NrIGVsZW1lbnRzIHJlY2VpdmUgdGhlIGdpdmVuIGNsYXNzXG4gICAgICAgICAgdGFyZ2V0LmNsYXNzTmFtZSArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGRvYy5leGVjQ29tbWFuZChjb21tYW5kLCBmYWxzZSwgbm9kZU5hbWUpO1xuICAgIGlmIChldmVudExpc3RlbmVyKSB7XG4gICAgICBldmVudExpc3RlbmVyLnN0b3AoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfc2VsZWN0TGluZUFuZFdyYXAoY29tcG9zZXIsIGVsZW1lbnQpIHtcbiAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2VsZWN0TGluZSgpO1xuICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zdXJyb3VuZChlbGVtZW50KTtcbiAgICBfcmVtb3ZlTGluZUJyZWFrQmVmb3JlQW5kQWZ0ZXIoZWxlbWVudCk7XG4gICAgX3JlbW92ZUxhc3RDaGlsZElmTGluZUJyZWFrKGVsZW1lbnQpO1xuICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZWxlY3ROb2RlKGVsZW1lbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2hhc0NsYXNzZXMoZWxlbWVudCkge1xuICAgIHJldHVybiAhIXd5c2lodG1sNS5sYW5nLnN0cmluZyhlbGVtZW50LmNsYXNzTmFtZSkudHJpbSgpO1xuICB9XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIG5vZGVOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSB7XG4gICAgICB2YXIgZG9jID0gY29tcG9zZXIuZG9jLFxuICAgICAgICAgIGJsb2NrRWxlbWVudCA9IHRoaXMuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIG5vZGVOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSxcbiAgICAgICAgICBzZWxlY3RlZE5vZGU7XG5cbiAgICAgIG5vZGVOYW1lID0gdHlwZW9mIG5vZGVOYW1lID09PSBcInN0cmluZ1wiID8gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA6IG5vZGVOYW1lO1xuXG4gICAgICBpZiAoYmxvY2tFbGVtZW50KSB7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGNsYXNzUmVnRXhwKSB7XG4gICAgICAgICAgICBfcmVtb3ZlQ2xhc3MoYmxvY2tFbGVtZW50LCBjbGFzc1JlZ0V4cCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBoYXNDbGFzc2VzID0gX2hhc0NsYXNzZXMoYmxvY2tFbGVtZW50KTtcbiAgICAgICAgICBpZiAoIWhhc0NsYXNzZXMgJiYgYmxvY2tFbGVtZW50Lm5vZGVOYW1lID09PSAobm9kZU5hbWUgfHwgREVGQVVMVF9OT0RFX05BTUUpKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgYSBsaW5lIGJyZWFrIGFmdGVyd2FyZHMgYW5kIGJlZm9yZXdhcmRzIHdoZW4gdGhlcmUgYXJlIHNpYmxpbmdzXG4gICAgICAgICAgICAvLyB0aGF0IGFyZSBub3Qgb2YgdHlwZSBsaW5lIGJyZWFrIG9yIGJsb2NrIGVsZW1lbnRcbiAgICAgICAgICAgIF9hZGRMaW5lQnJlYWtCZWZvcmVBbmRBZnRlcihibG9ja0VsZW1lbnQpO1xuICAgICAgICAgICAgZG9tLnJlcGxhY2VXaXRoQ2hpbGROb2RlcyhibG9ja0VsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2xhc3Nlcykge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgc3R5bGluZyBpcyBrZXB0IGJ5IHJlbmFtaW5nIHRoZSBlbGVtZW50IHRvIDxkaXY+IGFuZCBjb3B5aW5nIG92ZXIgdGhlIGNsYXNzIG5hbWVcbiAgICAgICAgICAgIGRvbS5yZW5hbWVFbGVtZW50KGJsb2NrRWxlbWVudCwgREVGQVVMVF9OT0RFX05BTUUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBzaW1pbGlhciBibG9jayBlbGVtZW50IGFuZCByZW5hbWUgaXQgKDxoMiBjbGFzcz1cImZvb1wiPjwvaDI+ICA9PiAgPGgxIGNsYXNzPVwiZm9vXCI+PC9oMT4pXG4gICAgICBpZiAobm9kZU5hbWUgPT09IG51bGwgfHwgd3lzaWh0bWw1LmxhbmcuYXJyYXkoQkxPQ0tfRUxFTUVOVFNfR1JPVVApLmNvbnRhaW5zKG5vZGVOYW1lKSkge1xuICAgICAgICBzZWxlY3RlZE5vZGUgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICAgIGJsb2NrRWxlbWVudCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwge1xuICAgICAgICAgIG5vZGVOYW1lOiBCTE9DS19FTEVNRU5UU19HUk9VUFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYmxvY2tFbGVtZW50KSB7XG4gICAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlU2ltcGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFJlbmFtZSBjdXJyZW50IGJsb2NrIGVsZW1lbnQgdG8gbmV3IGJsb2NrIGVsZW1lbnQgYW5kIGFkZCBjbGFzc1xuICAgICAgICAgICAgaWYgKG5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgIGJsb2NrRWxlbWVudCA9IGRvbS5yZW5hbWVFbGVtZW50KGJsb2NrRWxlbWVudCwgbm9kZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICBfYWRkQ2xhc3MoYmxvY2tFbGVtZW50LCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvc2VyLmNvbW1hbmRzLnN1cHBvcnQoY29tbWFuZCkpIHtcbiAgICAgICAgX2V4ZWNDb21tYW5kKGRvYywgY29tbWFuZCwgbm9kZU5hbWUgfHwgREVGQVVMVF9OT0RFX05BTUUsIGNsYXNzTmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYmxvY2tFbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUgfHwgREVGQVVMVF9OT0RFX05BTUUpO1xuICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBibG9ja0VsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgfVxuICAgICAgX3NlbGVjdExpbmVBbmRXcmFwKGNvbXBvc2VyLCBibG9ja0VsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIG5vZGVOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSB7XG4gICAgICBub2RlTmFtZSA9IHR5cGVvZiBub2RlTmFtZSA9PT0gXCJzdHJpbmdcIiA/IG5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgOiBub2RlTmFtZTtcbiAgICAgIHZhciBzZWxlY3RlZE5vZGUgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICByZXR1cm4gZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7XG4gICAgICAgIG5vZGVOYW1lOiBub2RlTmFtZSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIGNsYXNzUmVnRXhwOiBjbGFzc1JlZ0V4cFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyAvKipcbiAgICAgICAgICAgICAgICogZm9ybWF0SW5saW5lIHNjZW5hcmlvcyBmb3IgdGFnIFwiQlwiICh8ID0gY2FyZXQsIHxmb298ID0gc2VsZWN0ZWQgdGV4dClcbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogICAjMSBjYXJldCBpbiB1bmZvcm1hdHRlZCB0ZXh0OlxuICAgICAgICAgICAgICAgKiAgICAgIGFiY2RlZmd8XG4gICAgICAgICAgICAgICAqICAgb3V0cHV0OlxuICAgICAgICAgICAgICAgKiAgICAgIGFiY2RlZmc8Yj58PC9iPlxuICAgICAgICAgICAgICAgKiAgIFxuICAgICAgICAgICAgICAgKiAgICMyIHVuZm9ybWF0dGVkIHRleHQgc2VsZWN0ZWQ6XG4gICAgICAgICAgICAgICAqICAgICAgYWJjfGRlZ3xoXG4gICAgICAgICAgICAgICAqICAgb3V0cHV0OlxuICAgICAgICAgICAgICAgKiAgICAgIGFiYzxiPnxkZWd8PC9iPmhcbiAgICAgICAgICAgICAgICogICBcbiAgICAgICAgICAgICAgICogICAjMyB1bmZvcm1hdHRlZCB0ZXh0IHNlbGVjdGVkIGFjcm9zcyBib3VuZGFyaWVzOlxuICAgICAgICAgICAgICAgKiAgICAgIGFifGMgPHNwYW4+ZGVmZ3xoPC9zcGFuPlxuICAgICAgICAgICAgICAgKiAgIG91dHB1dDpcbiAgICAgICAgICAgICAgICogICAgICBhYjxiPnxjIDwvYj48c3Bhbj48Yj5kZWZnPC9iPnxoPC9zcGFuPlxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiAgICM0IGZvcm1hdHRlZCB0ZXh0IGVudGlyZWx5IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAqICAgICAgPGI+fGFiY3w8L2I+XG4gICAgICAgICAgICAgICAqICAgb3V0cHV0OlxuICAgICAgICAgICAgICAgKiAgICAgIHxhYmN8XG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqICAgIzUgZm9ybWF0dGVkIHRleHQgcGFydGlhbGx5IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAqICAgICAgPGI+YWJ8Y3w8L2I+XG4gICAgICAgICAgICAgICAqICAgb3V0cHV0OlxuICAgICAgICAgICAgICAgKiAgICAgIDxiPmFiPC9iPnxjfFxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiAgICM2IGZvcm1hdHRlZCB0ZXh0IHNlbGVjdGVkIGFjcm9zcyBib3VuZGFyaWVzXG4gICAgICAgICAgICAgICAqICAgICAgPHNwYW4+YWJ8Yzwvc3Bhbj4gPGI+ZGV8ZmdoPC9iPlxuICAgICAgICAgICAgICAgKiAgIG91dHB1dDpcbiAgICAgICAgICAgICAgICogICAgICA8c3Bhbj5hYnxjPC9zcGFuPiBkZXw8Yj5mZ2g8L2I+XG4gICAgICAgICAgICAgICAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmLFxuXG4gIC8vIFRyZWF0IDxiPiBhcyA8c3Ryb25nPiBhbmQgdmljZSB2ZXJzYVxuICBBTElBU19NQVBQSU5HID0ge1xuICAgIFwic3Ryb25nXCI6IFwiYlwiLFxuICAgIFwiZW1cIjogXCJpXCIsXG4gICAgXCJiXCI6IFwic3Ryb25nXCIsXG4gICAgXCJpXCI6IFwiZW1cIlxuICB9LFxuICAgICAgaHRtbEFwcGxpZXIgPSB7fTtcblxuICBmdW5jdGlvbiBfZ2V0VGFnTmFtZXModGFnTmFtZSkge1xuICAgIHZhciBhbGlhcyA9IEFMSUFTX01BUFBJTkdbdGFnTmFtZV07XG4gICAgcmV0dXJuIGFsaWFzID8gW3RhZ05hbWUudG9Mb3dlckNhc2UoKSwgYWxpYXMudG9Mb3dlckNhc2UoKV0gOiBbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9mb3JtYXRDbGVhcihyYW5nZSkge1xuICAgIGJvZHkgPSAkKHJhbmdlLmVuZENvbnRhaW5lci5vd25lckRvY3VtZW50LmJvZHkpO1xuICAgICQuZWFjaChib2R5LmNoaWxkcmVuKCdmb250JyksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvbnRfZWwgPSAkKHRoaXMpO1xuICAgICAgZm9udF9lbC5yZXBsYWNlV2l0aCgnPHNwYW4+JyArIGZvbnRfZWwuaHRtbCgpICsgJzwvc3Bhbj4nKTtcbiAgICB9KTtcblxuICAgICQuZWFjaChib2R5LmNoaWxkcmVuKCdzcGFuJyksIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNwYW5fZWwgPSAkKHRoaXMpO1xuICAgICAgcmVkdWNlZF9kaW1lbnNpb24oc3Bhbl9lbCk7XG4gICAgfSk7XG4gICAgbm90X3NwYW5fbGlzdCA9ICQoJ3Rib2R5OmZpcnN0ID4gdHInKS5ub3QoJ3RkJykudG9BcnJheSgpO1xuICAgIHdoaWxlIChub3Rfc3Bhbl9saXN0Lmxlbmd0aCkge1xuICAgICAgbm90X3NwYW5fbGlzdF9pdGVtID0gbm90X3NwYW5fbGlzdC5wb3AoKTtcbiAgICAgICQuZWFjaChub3Rfc3Bhbl9saXN0X2l0ZW0uY2hpbGRyZW4oKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXdfZWwgPSAkKHRoaXMpO1xuICAgICAgICBpZiAobmV3X2VsLmlzKCdzcGFuJykpIHtcbiAgICAgICAgICByZWR1Y2VkX2RpbWVuc2lvbihuZXdfZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vdF9zcGFuX2xpc3QucHVzaChuZXdfZWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgJC5lYWNoKGJvZHkuZmluZCgnc3BhbicpLCBmdW5jdGlvbiAoKSB7XG4gICAgICBlbCA9ICQodGhpcyk7XG4gICAgICBpZiAoISQudHJpbShlbC50ZXh0KCkpLmxlbmd0aCkge1xuICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByYW5nZS5lbmRDb250YWluZXIub3duZXJEb2N1bWVudC5nZXRTZWxlY3Rpb24oKS5lbXB0eSgpO1xuICB9XG5cbiAgLy8gbWFrZSA8c3BhbiBjbGFzcz0nYSc+MTIzPHNwYW4gY2xhc3M9J2InPjQ8L3NwYW4+NTwvc3Bhbj4gYmVjb21lXG4gIC8vIDxzcGFuIGNsYXNzPSdhJz4xMjM8L3NwYW4+IDxzcGFuIGNsYXNzPSdiJz40PC9zcGFuPiA8c3BhbiBjbGFzcz0nYSc+NTwvc3Bhbj5cbiAgZnVuY3Rpb24gcmVkdWNlZF9kaW1lbnNpb24oc3Bhbikge1xuICAgIGlmIChzcGFuLmNoaWxkcmVuKCdzcGFuJykubGVuZ3RoKSB7XG4gICAgICBjbGFzc19uYW1lID0gJC50cmltKHNwYW4uZ2V0KDApLmNsYXNzTmFtZSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW4uY2hpbGRyZW4oJ3NwYW4nKS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZF9zcGFuID0gJChzcGFuLmNoaWxkcmVuKCdzcGFuJylbaV0pO1xuICAgICAgICByZWR1Y2VkX2RpbWVuc2lvbihjaGlsZF9zcGFuKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coc3Bhbi5wYXJlbnRzKCdzcGFuJykubGVuZ3RoKTtcbiAgICAgIGh0bWxfdGV4dCA9IHNwYW4uaHRtbCgpO1xuICAgICAgaWYgKCFjbGFzc19uYW1lLmxlbmd0aCkge1xuICAgICAgICBjbGFzc19uYW1lID0gJ3d5c2l3eWctY29sb3ItY2xlYXInO1xuICAgICAgfVxuICAgICAgaHRtbF90ZXh0ID0gaHRtbF90ZXh0LnJlcGxhY2UoLzxzcGFuXFwgLywgJzwvc3Bhbj48c3BhbiAnKTtcbiAgICAgIGh0bWxfdGV4dCA9IGh0bWxfdGV4dC5yZXBsYWNlKC88XFwvc3Bhbj4oPyFbXFxzXFxTXSo8XFwvc3Bhbj5bXFxzXFxTXSokKS9pLCBcIjwvc3Bhbj48c3BhbiBjbGFzcz0nXCIgKyBjbGFzc19uYW1lICsgXCInPlwiKTtcbiAgICAgIGh0bWxfdGV4dCA9IFwiPHNwYW4gY2xhc3M9J1wiICsgY2xhc3NfbmFtZSArIFwiJz5cIiArIGh0bWxfdGV4dCArIFwiPC9zcGFuPlwiO1xuICAgICAgc3Bhbi5yZXBsYWNlV2l0aChodG1sX3RleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2dldEFwcGxpZXIodGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkge1xuICAgIHZhciBpZGVudGlmaWVyID0gdGFnTmFtZSArIFwiOlwiICsgY2xhc3NOYW1lO1xuICAgIGlmICghaHRtbEFwcGxpZXJbaWRlbnRpZmllcl0pIHtcbiAgICAgIGh0bWxBcHBsaWVyW2lkZW50aWZpZXJdID0gbmV3IHd5c2lodG1sNS5zZWxlY3Rpb24uSFRNTEFwcGxpZXIoX2dldFRhZ05hbWVzKHRhZ05hbWUpLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWxBcHBsaWVyW2lkZW50aWZpZXJdO1xuICB9XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZSA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kLCB0YWdOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgX2dldEFwcGxpZXIodGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkudG9nZ2xlUmFuZ2UocmFuZ2UpO1xuICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNldFNlbGVjdGlvbihyYW5nZSk7XG4gICAgICBfZm9ybWF0Q2xlYXIocmFuZ2UpO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIHRhZ05hbWUsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApIHtcbiAgICAgIHZhciBkb2MgPSBjb21wb3Nlci5kb2MsXG4gICAgICAgICAgYWxpYXNUYWdOYW1lID0gQUxJQVNfTUFQUElOR1t0YWdOYW1lXSB8fCB0YWdOYW1lLFxuICAgICAgICAgIHJhbmdlO1xuXG4gICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkb2N1bWVudCBjb250YWlucyBhIG5vZGUgd2l0aCB0aGUgZGVzaXJlZCB0YWdOYW1lXG4gICAgICBpZiAoIXd5c2lodG1sNS5kb20uaGFzRWxlbWVudFdpdGhUYWdOYW1lKGRvYywgdGFnTmFtZSkgJiYgIXd5c2lodG1sNS5kb20uaGFzRWxlbWVudFdpdGhUYWdOYW1lKGRvYywgYWxpYXNUYWdOYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRvY3VtZW50IGNvbnRhaW5zIGEgbm9kZSB3aXRoIHRoZSBkZXNpcmVkIGNsYXNzTmFtZVxuICAgICAgaWYgKGNsYXNzTmFtZSAmJiAhd3lzaWh0bWw1LmRvbS5oYXNFbGVtZW50V2l0aENsYXNzTmFtZShkb2MsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByYW5nZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZ2V0QXBwbGllcih0YWdOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKS5pc0FwcGxpZWRUb1JhbmdlKHJhbmdlKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmO1xuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRIVE1MID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIGh0bWwpIHtcbiAgICAgIGlmIChjb21wb3Nlci5jb21tYW5kcy5zdXBwb3J0KGNvbW1hbmQpKSB7XG4gICAgICAgIGNvbXBvc2VyLmRvYy5leGVjQ29tbWFuZChjb21tYW5kLCBmYWxzZSwgaHRtbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uaW5zZXJ0SFRNTChodG1sKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgTk9ERV9OQU1FID0gXCJJTUdcIjtcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuaW5zZXJ0SW1hZ2UgPSB7XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiA8aW1nPlxuICAgICAqIElmIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGFuIGltYWdlIGxpbmssIGl0IHJlbW92ZXMgaXRcbiAgICAgKiBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIC8vIGVpdGhlciAuLi5cbiAgICAgKiAgICB3eXNpaHRtbDUuY29tbWFuZHMuaW5zZXJ0SW1hZ2UuZXhlYyhjb21wb3NlciwgXCJpbnNlcnRJbWFnZVwiLCBcImh0dHA6Ly93d3cuZ29vZ2xlLmRlL2xvZ28uanBnXCIpO1xuICAgICAqICAgIC8vIC4uLiBvciAuLi5cbiAgICAgKiAgICB3eXNpaHRtbDUuY29tbWFuZHMuaW5zZXJ0SW1hZ2UuZXhlYyhjb21wb3NlciwgXCJpbnNlcnRJbWFnZVwiLCB7IHNyYzogXCJodHRwOi8vd3d3Lmdvb2dsZS5kZS9sb2dvLmpwZ1wiLCB0aXRsZTogXCJmb29cIiB9KTtcbiAgICAgKi9cbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kLCB2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YodmFsdWUpKSA9PT0gXCJvYmplY3RcIiA/IHZhbHVlIDogeyBzcmM6IHZhbHVlIH07XG5cbiAgICAgIHZhciBkb2MgPSBjb21wb3Nlci5kb2MsXG4gICAgICAgICAgaW1hZ2UgPSB0aGlzLnN0YXRlKGNvbXBvc2VyKSxcbiAgICAgICAgICB0ZXh0Tm9kZSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHBhcmVudDtcblxuICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgIC8vIEltYWdlIGFscmVhZHkgc2VsZWN0ZWQsIHNldCB0aGUgY2FyZXQgYmVmb3JlIGl0IGFuZCBkZWxldGUgaXRcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNldEJlZm9yZShpbWFnZSk7XG4gICAgICAgIHBhcmVudCA9IGltYWdlLnBhcmVudE5vZGU7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChpbWFnZSk7XG5cbiAgICAgICAgLy8gYW5kIGl0J3MgcGFyZW50IDxhPiB0b28gaWYgaXQgaGFzbid0IGdvdCBhbnkgb3RoZXIgcmVsZXZhbnQgY2hpbGQgbm9kZXNcbiAgICAgICAgd3lzaWh0bWw1LmRvbS5yZW1vdmVFbXB0eVRleHROb2RlcyhwYXJlbnQpO1xuICAgICAgICBpZiAocGFyZW50Lm5vZGVOYW1lID09PSBcIkFcIiAmJiAhcGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2V0QWZ0ZXIocGFyZW50KTtcbiAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwYXJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyZWZveCBhbmQgaWUgc29tZXRpbWVzIGRvbid0IHJlbW92ZSB0aGUgaW1hZ2UgaGFuZGxlcywgZXZlbiB0aG91Z2ggdGhlIGltYWdlIGdvdCByZW1vdmVkXG4gICAgICAgIHd5c2lodG1sNS5xdWlya3MucmVkcmF3KGNvbXBvc2VyLmVsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGltYWdlID0gZG9jLmNyZWF0ZUVsZW1lbnQoTk9ERV9OQU1FKTtcblxuICAgICAgZm9yIChpIGluIHZhbHVlKSB7XG4gICAgICAgIGltYWdlW2ldID0gdmFsdWVbaV07XG4gICAgICB9XG5cbiAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5pbnNlcnROb2RlKGltYWdlKTtcbiAgICAgIGlmICh3eXNpaHRtbDUuYnJvd3Nlci5oYXNQcm9ibGVtc1NldHRpbmdDYXJldEFmdGVySW1nKCkpIHtcbiAgICAgICAgdGV4dE5vZGUgPSBkb2MuY3JlYXRlVGV4dE5vZGUod3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRSk7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5pbnNlcnROb2RlKHRleHROb2RlKTtcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNldEFmdGVyKHRleHROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZXRBZnRlcihpbWFnZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21wb3Nlcikge1xuICAgICAgdmFyIGRvYyA9IGNvbXBvc2VyLmRvYyxcbiAgICAgICAgICBzZWxlY3RlZE5vZGUsXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICBpbWFnZXNJblNlbGVjdGlvbjtcblxuICAgICAgaWYgKCF3eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoVGFnTmFtZShkb2MsIE5PREVfTkFNRSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3RlZE5vZGUgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICBpZiAoIXNlbGVjdGVkTm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZE5vZGUubm9kZU5hbWUgPT09IE5PREVfTkFNRSkge1xuICAgICAgICAvLyBUaGlzIHdvcmtzIHBlcmZlY3RseSBpbiBJRVxuICAgICAgICByZXR1cm4gc2VsZWN0ZWROb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ZWROb2RlLm5vZGVUeXBlICE9PSB3eXNpaHRtbDUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGV4dCA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRUZXh0KCk7XG4gICAgICB0ZXh0ID0gd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKHRleHQpLnRyaW0oKTtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaW1hZ2VzSW5TZWxlY3Rpb24gPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0Tm9kZXMod3lzaWh0bWw1LkVMRU1FTlRfTk9ERSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09IFwiSU1HXCI7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGltYWdlc0luU2VsZWN0aW9uLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbWFnZXNJblNlbGVjdGlvblswXTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGNvbXBvc2VyKSB7XG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLnN0YXRlKGNvbXBvc2VyKTtcbiAgICAgIHJldHVybiBpbWFnZSAmJiBpbWFnZS5zcmM7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWYsXG4gICAgICBMSU5FX0JSRUFLID0gXCI8YnI+XCIgKyAod3lzaWh0bWw1LmJyb3dzZXIubmVlZHNTcGFjZUFmdGVyTGluZUJyZWFrKCkgPyBcIiBcIiA6IFwiXCIpO1xuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRMaW5lQnJlYWsgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgaWYgKGNvbXBvc2VyLmNvbW1hbmRzLnN1cHBvcnQoY29tbWFuZCkpIHtcbiAgICAgICAgY29tcG9zZXIuZG9jLmV4ZWNDb21tYW5kKGNvbW1hbmQsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5hdXRvU2Nyb2xsc1RvQ2FyZXQoKSkge1xuICAgICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb3Nlci5jb21tYW5kcy5leGVjKFwiaW5zZXJ0SFRNTFwiLCBMSU5FX0JSRUFLKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWY7XG4gIC8vXG4gIC8vIGZ1bmN0aW9uIF9yZW1vdmVGb3JtYXQoY29tcG9zZXIsIGFuY2hvcnMpIHtcbiAgLy8gICB2YXIgbGVuZ3RoICA9IGFuY2hvcnMubGVuZ3RoLFxuICAvLyAgICAgICBpICAgICAgID0gMCxcbiAgLy8gICAgICAgYW5jaG9yLFxuICAvLyAgICAgICBjb2RlRWxlbWVudCxcbiAgLy8gICAgICAgdGV4dENvbnRlbnQ7XG4gIC8vICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgLy8gICAgIGFuY2hvciAgICAgID0gYW5jaG9yc1tpXTtcbiAgLy8gICAgIGNvZGVFbGVtZW50ID0gZG9tLmdldFBhcmVudEVsZW1lbnQoYW5jaG9yLCB7IG5vZGVOYW1lOiBcImNvZGVcIiB9KTtcbiAgLy8gICAgIHRleHRDb250ZW50ID0gZG9tLmdldFRleHRDb250ZW50KGFuY2hvcik7XG4gIC8vXG4gIC8vICAgICAvLyBpZiA8YT4gY29udGFpbnMgdXJsLWxpa2UgdGV4dCBjb250ZW50LCByZW5hbWUgaXQgdG8gPGNvZGU+IHRvIHByZXZlbnQgcmUtYXV0b2xpbmtpbmdcbiAgLy8gICAgIC8vIGVsc2UgcmVwbGFjZSA8YT4gd2l0aCBpdHMgY2hpbGROb2Rlc1xuICAvLyAgICAgaWYgKHRleHRDb250ZW50Lm1hdGNoKGRvbS5hdXRvTGluay5VUkxfUkVHX0VYUCkgJiYgIWNvZGVFbGVtZW50KSB7XG4gIC8vICAgICAgIC8vIDxjb2RlPiBlbGVtZW50IGlzIHVzZWQgdG8gcHJldmVudCBsYXRlciBhdXRvLWxpbmtpbmcgb2YgdGhlIGNvbnRlbnRcbiAgLy8gICAgICAgY29kZUVsZW1lbnQgPSBkb20ucmVuYW1lRWxlbWVudChhbmNob3IsIFwiY29kZVwiKTtcbiAgLy8gICAgIH0gZWxzZSB7XG4gIC8vICAgICAgIGRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXMoYW5jaG9yKTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vIH1cbiAgLy9cbiAgLy9cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmNsZWFyID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIGNvbXBvc2VyLmRvYy5leGVjQ29tbWFuZCgncmVtb3ZlRm9ybWF0Jyk7XG4gICAgICBSRUdfRVhQID0gL3d5c2l3eWctY29sb3ItW2Etel0rL2c7XG4gICAgICB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIFwic3BhblwiLCBcIlwiLCBSRUdfRVhQKTtcbiAgICB9XG4gIH07XG4gIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRPcmRlcmVkTGlzdCA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICB2YXIgZG9jID0gY29tcG9zZXIuZG9jLFxuICAgICAgICAgIHNlbGVjdGVkTm9kZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKSxcbiAgICAgICAgICBsaXN0ID0gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwgeyBub2RlTmFtZTogXCJPTFwiIH0pLFxuICAgICAgICAgIG90aGVyTGlzdCA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHsgbm9kZU5hbWU6IFwiVUxcIiB9KSxcbiAgICAgICAgICB0ZW1wQ2xhc3NOYW1lID0gXCJfd3lzaWh0bWw1LXRlbXAtXCIgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICBpc0VtcHR5LFxuICAgICAgICAgIHRlbXBFbGVtZW50O1xuXG4gICAgICBpZiAoY29tcG9zZXIuY29tbWFuZHMuc3VwcG9ydChjb21tYW5kKSkge1xuICAgICAgICBkb2MuZXhlY0NvbW1hbmQoY29tbWFuZCwgZmFsc2UsIG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgIC8vIFVud3JhcCBsaXN0XG4gICAgICAgIC8vIDxvbD48bGk+Zm9vPC9saT48bGk+YmFyPC9saT48L29sPlxuICAgICAgICAvLyBiZWNvbWVzOlxuICAgICAgICAvLyBmb288YnI+YmFyPGJyPlxuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHd5c2lodG1sNS5kb20ucmVzb2x2ZUxpc3QobGlzdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvdGhlckxpc3QpIHtcbiAgICAgICAgLy8gVHVybiBhbiB1bm9yZGVyZWQgbGlzdCBpbnRvIGFuIG9yZGVyZWQgbGlzdFxuICAgICAgICAvLyA8dWw+PGxpPmZvbzwvbGk+PGxpPmJhcjwvbGk+PC91bD5cbiAgICAgICAgLy8gYmVjb21lczpcbiAgICAgICAgLy8gPG9sPjxsaT5mb288L2xpPjxsaT5iYXI8L2xpPjwvb2w+XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd3lzaWh0bWw1LmRvbS5yZW5hbWVFbGVtZW50KG90aGVyTGlzdCwgXCJvbFwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgbGlzdFxuICAgICAgICBjb21wb3Nlci5jb21tYW5kcy5leGVjKFwiZm9ybWF0QmxvY2tcIiwgXCJkaXZcIiwgdGVtcENsYXNzTmFtZSk7XG4gICAgICAgIHRlbXBFbGVtZW50ID0gZG9jLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyB0ZW1wQ2xhc3NOYW1lKTtcbiAgICAgICAgaXNFbXB0eSA9IHRlbXBFbGVtZW50LmlubmVySFRNTCA9PT0gXCJcIiB8fCB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPT09IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0U7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbGlzdCA9IHd5c2lodG1sNS5kb20uY29udmVydFRvTGlzdCh0ZW1wRWxlbWVudCwgXCJvbFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNlbGVjdE5vZGUobGlzdC5xdWVyeVNlbGVjdG9yKFwibGlcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21wb3Nlcikge1xuICAgICAgdmFyIHNlbGVjdGVkTm9kZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKTtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBcIk9MXCIgfSk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZjtcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuaW5zZXJ0VW5vcmRlcmVkTGlzdCA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICB2YXIgZG9jID0gY29tcG9zZXIuZG9jLFxuICAgICAgICAgIHNlbGVjdGVkTm9kZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKSxcbiAgICAgICAgICBsaXN0ID0gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwgeyBub2RlTmFtZTogXCJVTFwiIH0pLFxuICAgICAgICAgIG90aGVyTGlzdCA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHsgbm9kZU5hbWU6IFwiT0xcIiB9KSxcbiAgICAgICAgICB0ZW1wQ2xhc3NOYW1lID0gXCJfd3lzaWh0bWw1LXRlbXAtXCIgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICBpc0VtcHR5LFxuICAgICAgICAgIHRlbXBFbGVtZW50O1xuXG4gICAgICBpZiAoY29tcG9zZXIuY29tbWFuZHMuc3VwcG9ydChjb21tYW5kKSkge1xuICAgICAgICBkb2MuZXhlY0NvbW1hbmQoY29tbWFuZCwgZmFsc2UsIG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgIC8vIFVud3JhcCBsaXN0XG4gICAgICAgIC8vIDx1bD48bGk+Zm9vPC9saT48bGk+YmFyPC9saT48L3VsPlxuICAgICAgICAvLyBiZWNvbWVzOlxuICAgICAgICAvLyBmb288YnI+YmFyPGJyPlxuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHd5c2lodG1sNS5kb20ucmVzb2x2ZUxpc3QobGlzdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvdGhlckxpc3QpIHtcbiAgICAgICAgLy8gVHVybiBhbiBvcmRlcmVkIGxpc3QgaW50byBhbiB1bm9yZGVyZWQgbGlzdFxuICAgICAgICAvLyA8b2w+PGxpPmZvbzwvbGk+PGxpPmJhcjwvbGk+PC9vbD5cbiAgICAgICAgLy8gYmVjb21lczpcbiAgICAgICAgLy8gPHVsPjxsaT5mb288L2xpPjxsaT5iYXI8L2xpPjwvdWw+XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd3lzaWh0bWw1LmRvbS5yZW5hbWVFbGVtZW50KG90aGVyTGlzdCwgXCJ1bFwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgbGlzdFxuICAgICAgICBjb21wb3Nlci5jb21tYW5kcy5leGVjKFwiZm9ybWF0QmxvY2tcIiwgXCJkaXZcIiwgdGVtcENsYXNzTmFtZSk7XG4gICAgICAgIHRlbXBFbGVtZW50ID0gZG9jLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyB0ZW1wQ2xhc3NOYW1lKTtcbiAgICAgICAgaXNFbXB0eSA9IHRlbXBFbGVtZW50LmlubmVySFRNTCA9PT0gXCJcIiB8fCB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPT09IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0U7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbGlzdCA9IHd5c2lodG1sNS5kb20uY29udmVydFRvTGlzdCh0ZW1wRWxlbWVudCwgXCJ1bFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNlbGVjdE5vZGUobGlzdC5xdWVyeVNlbGVjdG9yKFwibGlcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21wb3Nlcikge1xuICAgICAgdmFyIHNlbGVjdGVkTm9kZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKTtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBcIlVMXCIgfSk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZjtcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuaXRhbGljID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIFwiaVwiKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBjb2xvcikge1xuICAgICAgLy8gZWxlbWVudC5vd25lckRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN0YXRlKFwiaXRhbGljXCIpIHJlc3VsdHM6XG4gICAgICAvLyBmaXJlZm94OiBvbmx5IDxpPlxuICAgICAgLy8gY2hyb21lOiAgPGk+LCA8ZW0+LCA8YmxvY2txdW90ZT4sIC4uLlxuICAgICAgLy8gaWU6ICAgICAgPGk+LCA8ZW0+XG4gICAgICAvLyBvcGVyYTogICBvbmx5IDxpPlxuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIFwiaVwiKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmLFxuICAgICAgQ0xBU1NfTkFNRSA9IFwid3lzaXd5Zy10ZXh0LWFsaWduLWNlbnRlclwiLFxuICAgICAgUkVHX0VYUCA9IC93eXNpd3lnLXRleHQtYWxpZ24tW2Etel0rL2c7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmp1c3RpZnlDZW50ZXIgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRCbG9jay5leGVjKGNvbXBvc2VyLCBcImZvcm1hdEJsb2NrXCIsIG51bGwsIENMQVNTX05BTUUsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0QmxvY2suc3RhdGUoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgQ0xBU1NfTkFNRSwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZixcbiAgICAgIENMQVNTX05BTUUgPSBcInd5c2l3eWctdGV4dC1hbGlnbi1sZWZ0XCIsXG4gICAgICBSRUdfRVhQID0gL3d5c2l3eWctdGV4dC1hbGlnbi1bYS16XSsvZztcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuanVzdGlmeUxlZnQgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRCbG9jay5leGVjKGNvbXBvc2VyLCBcImZvcm1hdEJsb2NrXCIsIG51bGwsIENMQVNTX05BTUUsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0QmxvY2suc3RhdGUoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgQ0xBU1NfTkFNRSwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZixcbiAgICAgIENMQVNTX05BTUUgPSBcInd5c2l3eWctdGV4dC1hbGlnbi1yaWdodFwiLFxuICAgICAgUkVHX0VYUCA9IC93eXNpd3lnLXRleHQtYWxpZ24tW2Etel0rL2c7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmp1c3RpZnlSaWdodCA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrLmV4ZWMoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgQ0xBU1NfTkFNRSwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRCbG9jay5zdGF0ZShjb21wb3NlciwgXCJmb3JtYXRCbG9ja1wiLCBudWxsLCBDTEFTU19OQU1FLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmO1xuICB3eXNpaHRtbDUuY29tbWFuZHMudW5kZXJsaW5lID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIFwidVwiKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJ1XCIpO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsgLyoqXG4gICAgICAgICAgICAgICAqIFVuZG8gTWFuYWdlciBmb3Igd3lzaWh0bWw1XG4gICAgICAgICAgICAgICAqIHNsaWdodGx5IGluc3BpcmVkIGJ5IGh0dHA6Ly9ybml3YS5jb20vZWRpdGluZy91bmRvbWFuYWdlci5odG1sI3RoZS11bmRvbWFuYWdlci1pbnRlcmZhY2VcbiAgICAgICAgICAgICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgWl9LRVkgPSA5MCxcbiAgICAgIFlfS0VZID0gODksXG4gICAgICBCQUNLU1BBQ0VfS0VZID0gOCxcbiAgICAgIERFTEVURV9LRVkgPSA0NixcbiAgICAgIE1BWF9ISVNUT1JZX0VOVFJJRVMgPSA0MCxcbiAgICAgIFVORE9fSFRNTCA9ICc8c3BhbiBpZD1cIl93eXNpaHRtbDUtdW5kb1wiIGNsYXNzPVwiX3d5c2lodG1sNS10ZW1wXCI+JyArIHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UgKyAnPC9zcGFuPicsXG4gICAgICBSRURPX0hUTUwgPSAnPHNwYW4gaWQ9XCJfd3lzaWh0bWw1LXJlZG9cIiBjbGFzcz1cIl93eXNpaHRtbDUtdGVtcFwiPicgKyB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFICsgJzwvc3Bhbj4nLFxuICAgICAgZG9tID0gd3lzaWh0bWw1LmRvbTtcblxuICBmdW5jdGlvbiBjbGVhblRlbXBFbGVtZW50cyhkb2MpIHtcbiAgICB2YXIgdGVtcEVsZW1lbnQ7XG4gICAgd2hpbGUgKHRlbXBFbGVtZW50ID0gZG9jLnF1ZXJ5U2VsZWN0b3IoXCIuX3d5c2lodG1sNS10ZW1wXCIpKSB7XG4gICAgICB0ZW1wRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXBFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICB3eXNpaHRtbDUuVW5kb01hbmFnZXIgPSB3eXNpaHRtbDUubGFuZy5EaXNwYXRjaGVyLmV4dGVuZChcbiAgLyoqIEBzY29wZSB3eXNpaHRtbDUuVW5kb01hbmFnZXIucHJvdG90eXBlICove1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgdGhpcy5jb21wb3NlciA9IGVkaXRvci5jb21wb3NlcjtcbiAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuY29tcG9zZXIuZWxlbWVudDtcbiAgICAgIHRoaXMuaGlzdG9yeSA9IFt0aGlzLmNvbXBvc2VyLmdldFZhbHVlKCldO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IDE7XG5cbiAgICAgIC8vIFVuZG8gbWFuYWdlciBjdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcnMgd2hvIGhhdmUgdGhlIGluc2VydEhUTUwgY29tbWFuZCAobm90IElFKVxuICAgICAgaWYgKHRoaXMuY29tcG9zZXIuY29tbWFuZHMuc3VwcG9ydChcImluc2VydEhUTUxcIikpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfb2JzZXJ2ZTogZnVuY3Rpb24gX29ic2VydmUoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgZG9jID0gdGhpcy5jb21wb3Nlci5zYW5kYm94LmdldERvY3VtZW50KCksXG4gICAgICAgICAgbGFzdEtleTtcblxuICAgICAgLy8gQ2F0Y2ggQ1RSTCtaIGFuZCBDVFJMK1lcbiAgICAgIGRvbS5vYnNlcnZlKHRoaXMuZWxlbWVudCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuYWx0S2V5IHx8ICFldmVudC5jdHJsS2V5ICYmICFldmVudC5tZXRhS2V5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlLFxuICAgICAgICAgICAgaXNVbmRvID0ga2V5Q29kZSA9PT0gWl9LRVkgJiYgIWV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgaXNSZWRvID0ga2V5Q29kZSA9PT0gWl9LRVkgJiYgZXZlbnQuc2hpZnRLZXkgfHwga2V5Q29kZSA9PT0gWV9LRVk7XG5cbiAgICAgICAgaWYgKGlzVW5kbykge1xuICAgICAgICAgIHRoYXQudW5kbygpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWRvKSB7XG4gICAgICAgICAgdGhhdC5yZWRvKCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENhdGNoIGRlbGV0ZSBhbmQgYmFja3NwYWNlXG4gICAgICBkb20ub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gbGFzdEtleSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RLZXkgPSBrZXlDb2RlO1xuXG4gICAgICAgIGlmIChrZXlDb2RlID09PSBCQUNLU1BBQ0VfS0VZIHx8IGtleUNvZGUgPT09IERFTEVURV9LRVkpIHtcbiAgICAgICAgICB0aGF0LnRyYW5zYWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBOb3cgdGhpcyBpcyB2ZXJ5IGhhY2t5OlxuICAgICAgLy8gVGhlc2UgZGF5cyBicm93c2VycyBkb24ndCBvZmZlciBhIHVuZG8vcmVkbyBldmVudCB3aGljaCB3ZSBjb3VsZCBob29rIGludG9cbiAgICAgIC8vIHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHVzZXIgaGl0cyB1bmRvL3JlZG8gaW4gdGhlIGNvbnRleHRtZW51LlxuICAgICAgLy8gVGhlcmVmb3JlIHdlIHNpbXBseSBpbnNlcnQgdHdvIGVsZW1lbnRzIGFzIHNvb24gYXMgdGhlIGNvbnRleHRtZW51IGdldHMgb3BlbmVkLlxuICAgICAgLy8gVGhlIGxhc3QgZWxlbWVudCBiZWluZyBpbnNlcnRlZCB3aWxsIGJlIGltbWVkaWF0ZWx5IGJlIHJlbW92ZWQgYWdhaW4gYnkgYSBleGV4Q29tbWFuZChcInVuZG9cIilcbiAgICAgIC8vICA9PiBXaGVuIHRoZSBzZWNvbmQgZWxlbWVudCBhcHBlYXJzIGluIHRoZSBkb20gdHJlZSB0aGVuIHdlIGtub3cgdGhlIHVzZXIgY2xpY2tlZCBcInJlZG9cIiBpbiB0aGUgY29udGV4dCBtZW51XG4gICAgICAvLyAgPT4gV2hlbiB0aGUgZmlyc3QgZWxlbWVudCBkaXNhcHBlYXJzIGZyb20gdGhlIGRvbSB0cmVlIHRoZW4gd2Uga25vdyB0aGUgdXNlciBjbGlja2VkIFwidW5kb1wiIGluIHRoZSBjb250ZXh0IG1lbnVcbiAgICAgIGlmICh3eXNpaHRtbDUuYnJvd3Nlci5oYXNVbmRvSW5Db250ZXh0TWVudSgpKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCxcbiAgICAgICAgICAgIG9ic2VydmVkLFxuICAgICAgICAgICAgY2xlYW5VcCA9IGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgICAgY2xlYW5UZW1wRWxlbWVudHMoZG9jKTtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICBkb20ub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNsZWFuVXAoKTtcbiAgICAgICAgICB0aGF0LmNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhhdC5lbGVtZW50Lmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICB0aGF0LmNvbXBvc2VyLnNlbGVjdGlvbi5zZXRBZnRlcih0aGF0LmVsZW1lbnQubGFzdENoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZW5hYmxlIHVuZG8gYnV0dG9uIGluIGNvbnRleHQgbWVudVxuICAgICAgICAgICAgZG9jLmV4ZWNDb21tYW5kKFwiaW5zZXJ0SFRNTFwiLCBmYWxzZSwgVU5ET19IVE1MKTtcbiAgICAgICAgICAgIC8vIGVuYWJsZSByZWRvIGJ1dHRvbiBpbiBjb250ZXh0IG1lbnVcbiAgICAgICAgICAgIGRvYy5leGVjQ29tbWFuZChcImluc2VydEhUTUxcIiwgZmFsc2UsIFJFRE9fSFRNTCk7XG4gICAgICAgICAgICBkb2MuZXhlY0NvbW1hbmQoXCJ1bmRvXCIsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRvYy5nZXRFbGVtZW50QnlJZChcIl93eXNpaHRtbDUtcmVkb1wiKSkge1xuICAgICAgICAgICAgICBjbGVhblVwKCk7XG4gICAgICAgICAgICAgIHRoYXQucmVkbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDQwMCk7XG5cbiAgICAgICAgICBpZiAoIW9ic2VydmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlZCA9IHRydWU7XG4gICAgICAgICAgICBkb20ub2JzZXJ2ZShkb2N1bWVudCwgXCJtb3VzZWRvd25cIiwgY2xlYW5VcCk7XG4gICAgICAgICAgICBkb20ub2JzZXJ2ZShkb2MsIFtcIm1vdXNlZG93blwiLCBcInBhc3RlXCIsIFwiY3V0XCIsIFwiY29weVwiXSwgY2xlYW5VcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lZGl0b3Iub2JzZXJ2ZShcIm5ld3dvcmQ6Y29tcG9zZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0LnRyYW5zYWN0KCk7XG4gICAgICB9KS5vYnNlcnZlKFwiYmVmb3JlY29tbWFuZDpjb21wb3NlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQudHJhbnNhY3QoKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB0cmFuc2FjdDogZnVuY3Rpb24gdHJhbnNhY3QoKSB7XG4gICAgICB2YXIgcHJldmlvdXNIdG1sID0gdGhpcy5oaXN0b3J5W3RoaXMucG9zaXRpb24gLSAxXSxcbiAgICAgICAgICBjdXJyZW50SHRtbCA9IHRoaXMuY29tcG9zZXIuZ2V0VmFsdWUoKTtcblxuICAgICAgaWYgKGN1cnJlbnRIdG1sID09IHByZXZpb3VzSHRtbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLmhpc3RvcnkubGVuZ3RoID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIGlmIChsZW5ndGggPiBNQVhfSElTVE9SWV9FTlRSSUVTKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeS5zaGlmdCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uLS07XG4gICAgICB9XG5cbiAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKGN1cnJlbnRIdG1sKTtcbiAgICB9LFxuXG4gICAgdW5kbzogZnVuY3Rpb24gdW5kbygpIHtcbiAgICAgIHRoaXMudHJhbnNhY3QoKTtcblxuICAgICAgaWYgKHRoaXMucG9zaXRpb24gPD0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0KHRoaXMuaGlzdG9yeVstLXRoaXMucG9zaXRpb24gLSAxXSk7XG4gICAgICB0aGlzLmVkaXRvci5maXJlKFwidW5kbzpjb21wb3NlclwiKTtcbiAgICB9LFxuXG4gICAgcmVkbzogZnVuY3Rpb24gcmVkbygpIHtcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uID49IHRoaXMuaGlzdG9yeS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldCh0aGlzLmhpc3RvcnlbKyt0aGlzLnBvc2l0aW9uIC0gMV0pO1xuICAgICAgdGhpcy5lZGl0b3IuZmlyZShcInJlZG86Y29tcG9zZXJcIik7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24gc2V0KGh0bWwpIHtcbiAgICAgIHRoaXMuY29tcG9zZXIuc2V0VmFsdWUoaHRtbCk7XG4gICAgICB0aGlzLmVkaXRvci5mb2N1cyh0cnVlKTtcbiAgICB9XG4gIH0pO1xufSkod3lzaWh0bWw1KTtcbi8qKlxuICogVE9ETzogdGhlIGZvbGxvd2luZyBtZXRob2RzIHN0aWxsIG5lZWQgdW5pdCB0ZXN0IGNvdmVyYWdlXG4gKi9cbnd5c2lodG1sNS52aWV3cy5WaWV3ID0gQmFzZS5leHRlbmQoXG4vKiogQHNjb3BlIHd5c2lodG1sNS52aWV3cy5WaWV3LnByb3RvdHlwZSAqL3tcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKHBhcmVudCwgdGV4dGFyZWFFbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmVsZW1lbnQgPSB0ZXh0YXJlYUVsZW1lbnQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG5cbiAgICB0aGlzLl9vYnNlcnZlVmlld0NoYW5nZSgpO1xuICB9LFxuXG4gIF9vYnNlcnZlVmlld0NoYW5nZTogZnVuY3Rpb24gX29ic2VydmVWaWV3Q2hhbmdlKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGlzLnBhcmVudC5vYnNlcnZlKFwiYmVmb3JlbG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LnBhcmVudC5vYnNlcnZlKFwiY2hhbmdlX3ZpZXdcIiwgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgaWYgKHZpZXcgPT09IHRoYXQubmFtZSkge1xuICAgICAgICAgIHRoYXQucGFyZW50LmN1cnJlbnRWaWV3ID0gdGhhdDtcbiAgICAgICAgICB0aGF0LnNob3coKTtcbiAgICAgICAgICAvLyBVc2luZyB0aW55IGRlbGF5IGhlcmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHBsYWNlaG9sZGVyIGlzIHNldCBiZWZvcmUgZm9jdXNpbmdcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGF0LmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiOmZvY3VzXCIpID09PSB0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5lbGVtZW50LmZvY3VzKCk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSxcblxuICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIH0sXG5cbiAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gIH0sXG5cbiAgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgfSxcblxuICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XG4gIH1cbn0pOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciBkb20gPSB3eXNpaHRtbDUuZG9tLFxuICAgICAgYnJvd3NlciA9IHd5c2lodG1sNS5icm93c2VyO1xuXG4gIHd5c2lodG1sNS52aWV3cy5Db21wb3NlciA9IHd5c2lodG1sNS52aWV3cy5WaWV3LmV4dGVuZChcbiAgLyoqIEBzY29wZSB3eXNpaHRtbDUudmlld3MuQ29tcG9zZXIucHJvdG90eXBlICove1xuICAgIG5hbWU6IFwiY29tcG9zZXJcIixcblxuICAgIC8vIE5lZWRlZCBmb3IgZmlyZWZveCBpbiBvcmRlciB0byBkaXNwbGF5IGEgcHJvcGVyIGNhcmV0IGluIGFuIGVtcHR5IGNvbnRlbnRFZGl0YWJsZVxuICAgIENBUkVUX0hBQ0s6IFwiPGJyPlwiLFxuXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKHBhcmVudCwgdGV4dGFyZWFFbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHRoaXMuYmFzZShwYXJlbnQsIHRleHRhcmVhRWxlbWVudCwgY29uZmlnKTtcbiAgICAgIHRoaXMudGV4dGFyZWEgPSB0aGlzLnBhcmVudC50ZXh0YXJlYTtcbiAgICAgIHRoaXMuX2luaXRTYW5kYm94KCk7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSBicm93c2VyLmRpc3BsYXlzQ2FyZXRJbkVtcHR5Q29udGVudEVkaXRhYmxlQ29ycmVjdGx5KCkgPyBcIlwiIDogdGhpcy5DQVJFVF9IQUNLO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUocGFyc2UpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuaXNFbXB0eSgpID8gXCJcIiA6IHd5c2lodG1sNS5xdWlya3MuZ2V0Q29ycmVjdElubmVySFRNTCh0aGlzLmVsZW1lbnQpO1xuXG4gICAgICBpZiAocGFyc2UpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnBhcmVudC5wYXJzZSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlcGxhY2UgYWxsIFwiemVybyB3aWR0aCBubyBicmVha2luZyBzcGFjZVwiIGNoYXJzXG4gICAgICAvLyB3aGljaCBhcmUgdXNlZCBhcyBoYWNrcyB0byBlbmFibGUgc29tZSBmdW5jdGlvbmFsaXRpZXNcbiAgICAgIC8vIEFsc28gcmVtb3ZlIGFsbCBDQVJFVCBoYWNrcyB0aGF0IHNvbWVob3cgZ290IGxlZnRcbiAgICAgIHZhbHVlID0gd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKHZhbHVlKS5yZXBsYWNlKHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UpLmJ5KFwiXCIpO1xuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZShodG1sLCBwYXJzZSkge1xuICAgICAgaWYgKHBhcnNlKSB7XG4gICAgICAgIGh0bWwgPSB0aGlzLnBhcmVudC5wYXJzZShodG1sKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdGhpcy5pZnJhbWUuc3R5bGUuZGlzcGxheSA9IHRoaXMuX2Rpc3BsYXlTdHlsZSB8fCBcIlwiO1xuXG4gICAgICAvLyBGaXJlZm94IG5lZWRzIHRoaXMsIG90aGVyd2lzZSBjb250ZW50RWRpdGFibGUgYmVjb21lcyB1bmVkaXRhYmxlXG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB0aGlzLl9kaXNwbGF5U3R5bGUgPSBkb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20odGhpcy5pZnJhbWUpO1xuICAgICAgaWYgKHRoaXMuX2Rpc3BsYXlTdHlsZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgdGhpcy5fZGlzcGxheVN0eWxlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9LFxuXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIik7XG4gICAgICB0aGlzLmJhc2UoKTtcbiAgICB9LFxuXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIsIFwidHJ1ZVwiKTtcbiAgICAgIHRoaXMuYmFzZSgpO1xuICAgIH0sXG5cbiAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoc2V0VG9FbmQpIHtcbiAgICAgIC8vIElFIDggZmlyZXMgdGhlIGZvY3VzIGV2ZW50IGFmdGVyIC5mb2N1cygpXG4gICAgICAvLyBUaGlzIGlzIG5lZWRlZCBieSBvdXIgc2ltdWxhdGVfcGxhY2Vob2xkZXIuanMgdG8gd29ya1xuICAgICAgLy8gdGhlcmVmb3JlIHdlIGNsZWFyIGl0IG91cnNlbHZlcyB0aGlzIHRpbWVcbiAgICAgIGlmICh3eXNpaHRtbDUuYnJvd3Nlci5kb2VzQXN5bmNGb2N1cygpICYmIHRoaXMuaGFzUGxhY2Vob2xkZXJTZXQoKSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYmFzZSgpO1xuXG4gICAgICB2YXIgbGFzdENoaWxkID0gdGhpcy5lbGVtZW50Lmxhc3RDaGlsZDtcbiAgICAgIGlmIChzZXRUb0VuZCAmJiBsYXN0Q2hpbGQpIHtcbiAgICAgICAgaWYgKGxhc3RDaGlsZC5ub2RlTmFtZSA9PT0gXCJCUlwiKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0QmVmb3JlKHRoaXMuZWxlbWVudC5sYXN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldEFmdGVyKHRoaXMuZWxlbWVudC5sYXN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldFRleHRDb250ZW50OiBmdW5jdGlvbiBnZXRUZXh0Q29udGVudCgpIHtcbiAgICAgIHJldHVybiBkb20uZ2V0VGV4dENvbnRlbnQodGhpcy5lbGVtZW50KTtcbiAgICB9LFxuXG4gICAgaGFzUGxhY2Vob2xkZXJTZXQ6IGZ1bmN0aW9uIGhhc1BsYWNlaG9sZGVyU2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dENvbnRlbnQoKSA9PSB0aGlzLnRleHRhcmVhLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIik7XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICB2YXIgaW5uZXJIVE1MID0gdGhpcy5lbGVtZW50LmlubmVySFRNTCxcbiAgICAgICAgICBlbGVtZW50c1dpdGhWaXN1YWxWYWx1ZSA9IFwiYmxvY2txdW90ZSwgdWwsIG9sLCBpbWcsIGVtYmVkLCBvYmplY3QsIHRhYmxlLCBpZnJhbWUsIHN2ZywgdmlkZW8sIGF1ZGlvLCBidXR0b24sIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhXCI7XG4gICAgICByZXR1cm4gaW5uZXJIVE1MID09PSBcIlwiIHx8IGlubmVySFRNTCA9PT0gdGhpcy5DQVJFVF9IQUNLIHx8IHRoaXMuaGFzUGxhY2Vob2xkZXJTZXQoKSB8fCB0aGlzLmdldFRleHRDb250ZW50KCkgPT09IFwiXCIgJiYgIXRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnRzV2l0aFZpc3VhbFZhbHVlKTtcbiAgICB9LFxuXG4gICAgX2luaXRTYW5kYm94OiBmdW5jdGlvbiBfaW5pdFNhbmRib3goKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc2FuZGJveCA9IG5ldyBkb20uU2FuZGJveChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQuX2NyZWF0ZSgpO1xuICAgICAgfSwge1xuICAgICAgICBzdHlsZXNoZWV0czogdGhpcy5jb25maWcuc3R5bGVzaGVldHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5pZnJhbWUgPSB0aGlzLnNhbmRib3guZ2V0SWZyYW1lKCk7XG5cbiAgICAgIC8vIENyZWF0ZSBoaWRkZW4gZmllbGQgd2hpY2ggdGVsbHMgdGhlIHNlcnZlciBhZnRlciBzdWJtaXQsIHRoYXQgdGhlIHVzZXIgdXNlZCBhbiB3eXNpd3lnIGVkaXRvclxuICAgICAgdmFyIGhpZGRlbkZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgaGlkZGVuRmllbGQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgICBoaWRkZW5GaWVsZC5uYW1lID0gXCJfd3lzaWh0bWw1X21vZGVcIjtcbiAgICAgIGhpZGRlbkZpZWxkLnZhbHVlID0gMTtcblxuICAgICAgLy8gU3RvcmUgcmVmZXJlbmNlIHRvIGN1cnJlbnQgd3lzaWh0bWw1IGluc3RhbmNlIG9uIHRoZSB0ZXh0YXJlYSBlbGVtZW50XG4gICAgICB2YXIgdGV4dGFyZWFFbGVtZW50ID0gdGhpcy50ZXh0YXJlYS5lbGVtZW50O1xuICAgICAgZG9tLmluc2VydCh0aGlzLmlmcmFtZSkuYWZ0ZXIodGV4dGFyZWFFbGVtZW50KTtcbiAgICAgIGRvbS5pbnNlcnQoaGlkZGVuRmllbGQpLmFmdGVyKHRleHRhcmVhRWxlbWVudCk7XG4gICAgfSxcblxuICAgIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZG9jID0gdGhpcy5zYW5kYm94LmdldERvY3VtZW50KCk7XG4gICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmRvYy5ib2R5O1xuICAgICAgdGhpcy50ZXh0YXJlYSA9IHRoaXMucGFyZW50LnRleHRhcmVhO1xuICAgICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IHRoaXMudGV4dGFyZWEuZ2V0VmFsdWUodHJ1ZSk7XG4gICAgICB0aGlzLmVuYWJsZSgpO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgb3VyIHNlbGVjdGlvbiBoYW5kbGVyIGlzIHJlYWR5XG4gICAgICB0aGlzLnNlbGVjdGlvbiA9IG5ldyB3eXNpaHRtbDUuU2VsZWN0aW9uKHRoaXMucGFyZW50KTtcblxuICAgICAgLy8gTWFrZSBzdXJlIGNvbW1hbmRzIGRpc3BhdGNoZXIgaXMgcmVhZHlcbiAgICAgIHRoaXMuY29tbWFuZHMgPSBuZXcgd3lzaWh0bWw1LkNvbW1hbmRzKHRoaXMucGFyZW50KTtcblxuICAgICAgZG9tLmNvcHlBdHRyaWJ1dGVzKFtcImNsYXNzTmFtZVwiLCBcInNwZWxsY2hlY2tcIiwgXCJ0aXRsZVwiLCBcImxhbmdcIiwgXCJkaXJcIiwgXCJhY2Nlc3NLZXlcIl0pLmZyb20odGhpcy50ZXh0YXJlYS5lbGVtZW50KS50byh0aGlzLmVsZW1lbnQpO1xuXG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5lbGVtZW50LCB0aGlzLmNvbmZpZy5jb21wb3NlckNsYXNzTmFtZSk7XG5cbiAgICAgIC8vIE1ha2UgdGhlIGVkaXRvciBsb29rIGxpa2UgdGhlIG9yaWdpbmFsIHRleHRhcmVhLCBieSBzeW5jaW5nIHN0eWxlc1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnN0eWxlKSB7XG4gICAgICAgIHRoaXMuc3R5bGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vYnNlcnZlKCk7XG5cbiAgICAgIHZhciBuYW1lID0gdGhpcy5jb25maWcubmFtZTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmVsZW1lbnQsIG5hbWUpO1xuICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5pZnJhbWUsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW11bGF0ZSBodG1sNSBwbGFjZWhvbGRlciBhdHRyaWJ1dGUgb24gY29udGVudEVkaXRhYmxlIGVsZW1lbnRcbiAgICAgIHZhciBwbGFjZWhvbGRlclRleHQgPSB0eXBlb2YgdGhpcy5jb25maWcucGxhY2Vob2xkZXIgPT09IFwic3RyaW5nXCIgPyB0aGlzLmNvbmZpZy5wbGFjZWhvbGRlciA6IHRoaXMudGV4dGFyZWEuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKTtcbiAgICAgIGlmIChwbGFjZWhvbGRlclRleHQpIHtcbiAgICAgICAgZG9tLnNpbXVsYXRlUGxhY2Vob2xkZXIodGhpcy5wYXJlbnQsIHRoaXMsIHBsYWNlaG9sZGVyVGV4dCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBicm93c2VyIGF2b2lkcyB1c2luZyBpbmxpbmUgc3R5bGVzIHdoZW5ldmVyIHBvc3NpYmxlXG4gICAgICB0aGlzLmNvbW1hbmRzLmV4ZWMoXCJzdHlsZVdpdGhDU1NcIiwgZmFsc2UpO1xuXG4gICAgICB0aGlzLl9pbml0QXV0b0xpbmtpbmcoKTtcbiAgICAgIHRoaXMuX2luaXRPYmplY3RSZXNpemluZygpO1xuICAgICAgdGhpcy5faW5pdFVuZG9NYW5hZ2VyKCk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIGh0bWw1IGF1dG9mb2N1cyBvbiBjb250ZW50RWRpdGFibGUgZWxlbWVudFxuICAgICAgaWYgKHRoaXMudGV4dGFyZWEuZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJhdXRvZm9jdXNcIikgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIjpmb2N1c1wiKSA9PSB0aGlzLnRleHRhcmVhLmVsZW1lbnQpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhhdC5mb2N1cygpO1xuICAgICAgICB9LCAxMDApO1xuICAgICAgfVxuXG4gICAgICB3eXNpaHRtbDUucXVpcmtzLmluc2VydExpbmVCcmVha09uUmV0dXJuKHRoaXMpO1xuXG4gICAgICAvLyBJRSBzb21ldGltZXMgbGVhdmVzIGEgc2luZ2xlIHBhcmFncmFwaCwgd2hpY2ggY2FuJ3QgYmUgcmVtb3ZlZCBieSB0aGUgdXNlclxuICAgICAgaWYgKCFicm93c2VyLmNsZWFyc0NvbnRlbnRFZGl0YWJsZUNvcnJlY3RseSgpKSB7XG4gICAgICAgIHd5c2lodG1sNS5xdWlya3MuZW5zdXJlUHJvcGVyQ2xlYXJpbmcodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYnJvd3Nlci5jbGVhcnNMaXN0c0luQ29udGVudEVkaXRhYmxlQ29ycmVjdGx5KCkpIHtcbiAgICAgICAgd3lzaWh0bWw1LnF1aXJrcy5lbnN1cmVQcm9wZXJDbGVhcmluZ09mTGlzdHModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBhIHN5bmMgdGhhdCBtYWtlcyBzdXJlIHRoYXQgdGV4dGFyZWEgYW5kIGVkaXRvciBoYXZlIHRoZSBzYW1lIGNvbnRlbnRcbiAgICAgIGlmICh0aGlzLmluaXRTeW5jICYmIHRoaXMuY29uZmlnLnN5bmMpIHtcbiAgICAgICAgdGhpcy5pbml0U3luYygpO1xuICAgICAgfVxuXG4gICAgICAvLyBPa2F5IGhpZGUgdGhlIHRleHRhcmVhLCB3ZSBhcmUgcmVhZHkgdG8gZ29cbiAgICAgIHRoaXMudGV4dGFyZWEuaGlkZSgpO1xuXG4gICAgICAvLyBGaXJlIGdsb2JhbCAoYmVmb3JlLSlsb2FkIGV2ZW50XG4gICAgICB0aGlzLnBhcmVudC5maXJlKFwiYmVmb3JlbG9hZFwiKS5maXJlKFwibG9hZFwiKTtcbiAgICB9LFxuXG4gICAgX2luaXRBdXRvTGlua2luZzogZnVuY3Rpb24gX2luaXRBdXRvTGlua2luZygpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBzdXBwb3J0c0Rpc2FibGluZ09mQXV0b0xpbmtpbmcgPSBicm93c2VyLmNhbkRpc2FibGVBdXRvTGlua2luZygpLFxuICAgICAgICAgIHN1cHBvcnRzQXV0b0xpbmtpbmcgPSBicm93c2VyLmRvZXNBdXRvTGlua2luZ0luQ29udGVudEVkaXRhYmxlKCk7XG4gICAgICBpZiAoc3VwcG9ydHNEaXNhYmxpbmdPZkF1dG9MaW5raW5nKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMuZXhlYyhcImF1dG9VcmxEZXRlY3RcIiwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuY29uZmlnLmF1dG9MaW5rKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gT25seSBkbyB0aGUgYXV0byBsaW5raW5nIGJ5IG91cnNlbHZlcyB3aGVuIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBhdXRvIGxpbmtpbmdcbiAgICAgIC8vIE9SIHdoZW4gaGUgc3VwcG9ydHMgYXV0byBsaW5raW5nIGJ1dCB3ZSB3ZXJlIGFibGUgdG8gdHVybiBpdCBvZmYgKElFOSspXG4gICAgICBpZiAoIXN1cHBvcnRzQXV0b0xpbmtpbmcgfHwgc3VwcG9ydHNBdXRvTGlua2luZyAmJiBzdXBwb3J0c0Rpc2FibGluZ09mQXV0b0xpbmtpbmcpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQub2JzZXJ2ZShcIm5ld3dvcmQ6Y29tcG9zZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlKGZ1bmN0aW9uIChzdGFydENvbnRhaW5lciwgZW5kQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBkb20uYXV0b0xpbmsoZW5kQ29udGFpbmVyLnBhcmVudE5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQXNzdW1pbmcgd2UgaGF2ZSB0aGUgZm9sbG93aW5nOlxuICAgICAgLy8gIDxhIGhyZWY9XCJodHRwOi8vd3d3Lmdvb2dsZS5kZVwiPmh0dHA6Ly93d3cuZ29vZ2xlLmRlPC9hPlxuICAgICAgLy8gSWYgYSB1c2VyIG5vdyBjaGFuZ2VzIHRoZSB1cmwgaW4gdGhlIGlubmVySFRNTCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgICAvLyBpdCdzIHN5bmNocm9uaXplZCB3aXRoIHRoZSBocmVmIGF0dHJpYnV0ZSAoYXMgbG9uZyBhcyB0aGUgaW5uZXJIVE1MIGlzIHN0aWxsIGEgdXJsKVxuICAgICAgdmFyIC8vIFVzZSBhIGxpdmUgTm9kZUxpc3QgdG8gY2hlY2sgd2hldGhlciB0aGVyZSBhcmUgYW55IGxpbmtzIGluIHRoZSBkb2N1bWVudFxuICAgICAgbGlua3MgPSB0aGlzLnNhbmRib3guZ2V0RG9jdW1lbnQoKS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFcIiksXG5cbiAgICAgIC8vIFRoZSBhdXRvTGluayBoZWxwZXIgbWV0aG9kIHJldmVhbHMgYSByZWcgZXhwIHRvIGRldGVjdCBjb3JyZWN0IHVybHNcbiAgICAgIHVybFJlZ0V4cCA9IGRvbS5hdXRvTGluay5VUkxfUkVHX0VYUCxcbiAgICAgICAgICBnZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIGdldFRleHRDb250ZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHRleHRDb250ZW50ID0gd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKGRvbS5nZXRUZXh0Q29udGVudChlbGVtZW50KSkudHJpbSgpO1xuICAgICAgICBpZiAodGV4dENvbnRlbnQuc3Vic3RyKDAsIDQpID09PSBcInd3dy5cIikge1xuICAgICAgICAgIHRleHRDb250ZW50ID0gXCJodHRwOi8vXCIgKyB0ZXh0Q29udGVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gICAgICB9O1xuXG4gICAgICBkb20ub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZWN0ZWROb2RlID0gdGhhdC5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50KSxcbiAgICAgICAgICAgIGxpbmsgPSBkb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHsgbm9kZU5hbWU6IFwiQVwiIH0sIDQpLFxuICAgICAgICAgICAgdGV4dENvbnRlbnQ7XG5cbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dENvbnRlbnQgPSBnZXRUZXh0Q29udGVudChsaW5rKTtcbiAgICAgICAgLy8ga2V5ZG93biBpcyBmaXJlZCBiZWZvcmUgdGhlIGFjdHVhbCBjb250ZW50IGlzIGNoYW5nZWRcbiAgICAgICAgLy8gdGhlcmVmb3JlIHdlIHNldCBhIHRpbWVvdXQgdG8gY2hhbmdlIHRoZSBocmVmXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBuZXdUZXh0Q29udGVudCA9IGdldFRleHRDb250ZW50KGxpbmspO1xuICAgICAgICAgIGlmIChuZXdUZXh0Q29udGVudCA9PT0gdGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPbmx5IHNldCBocmVmIHdoZW4gbmV3IGhyZWYgbG9va3MgbGlrZSBhIHZhbGlkIHVybFxuICAgICAgICAgIGlmIChuZXdUZXh0Q29udGVudC5tYXRjaCh1cmxSZWdFeHApKSB7XG4gICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgbmV3VGV4dENvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2luaXRPYmplY3RSZXNpemluZzogZnVuY3Rpb24gX2luaXRPYmplY3RSZXNpemluZygpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gW1wid2lkdGhcIiwgXCJoZWlnaHRcIl0sXG4gICAgICAgICAgcHJvcGVydGllc0xlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoLFxuICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cbiAgICAgIHRoaXMuY29tbWFuZHMuZXhlYyhcImVuYWJsZU9iamVjdFJlc2l6aW5nXCIsIHRoaXMuY29uZmlnLmFsbG93T2JqZWN0UmVzaXppbmcpO1xuXG4gICAgICBpZiAodGhpcy5jb25maWcuYWxsb3dPYmplY3RSZXNpemluZykge1xuICAgICAgICAvLyBJRSBzZXRzIGlubGluZSBzdHlsZXMgYWZ0ZXIgcmVzaXppbmcgb2JqZWN0c1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGxpbmVzIG1ha2Ugc3VyZSB0aGF0IHRoZSB3aWR0aC9oZWlnaHQgY3NzIHByb3BlcnRpZXNcbiAgICAgICAgLy8gYXJlIGNvcGllZCBvdmVyIHRvIHRoZSB3aWR0aC9oZWlnaHQgYXR0cmlidXRlc1xuICAgICAgICBpZiAoYnJvd3Nlci5zdXBwb3J0c0V2ZW50KFwicmVzaXplZW5kXCIpKSB7XG4gICAgICAgICAgZG9tLm9ic2VydmUoZWxlbWVudCwgXCJyZXNpemVlbmRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHByb3BlcnRpZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgIGlmIChzdHlsZVtwcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKHByb3BlcnR5LCBwYXJzZUludChzdHlsZVtwcm9wZXJ0eV0sIDEwKSk7XG4gICAgICAgICAgICAgICAgc3R5bGVbcHJvcGVydHldID0gXCJcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWZ0ZXIgcmVzaXppbmcgSUUgc29tZXRpbWVzIGZvcmdldHMgdG8gcmVtb3ZlIHRoZSBvbGQgcmVzaXplIGhhbmRsZXNcbiAgICAgICAgICAgIHd5c2lodG1sNS5xdWlya3MucmVkcmF3KGVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYnJvd3Nlci5zdXBwb3J0c0V2ZW50KFwicmVzaXplc3RhcnRcIikpIHtcbiAgICAgICAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBcInJlc2l6ZXN0YXJ0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfaW5pdFVuZG9NYW5hZ2VyOiBmdW5jdGlvbiBfaW5pdFVuZG9NYW5hZ2VyKCkge1xuICAgICAgbmV3IHd5c2lodG1sNS5VbmRvTWFuYWdlcih0aGlzLnBhcmVudCk7XG4gICAgfVxuICB9KTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIGRvbSA9IHd5c2lodG1sNS5kb20sXG4gICAgICBkb2MgPSBkb2N1bWVudCxcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIEhPU1RfVEVNUExBVEUgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblxuICAvKipcbiAgICogU3R5bGVzIHRvIGNvcHkgZnJvbSB0ZXh0YXJlYSB0byB0aGUgY29tcG9zZXIgZWxlbWVudFxuICAgKi9cbiAgVEVYVF9GT1JNQVRUSU5HID0gW1wiYmFja2dyb3VuZC1jb2xvclwiLCBcImNvbG9yXCIsIFwiY3Vyc29yXCIsIFwiZm9udC1mYW1pbHlcIiwgXCJmb250LXNpemVcIiwgXCJmb250LXN0eWxlXCIsIFwiZm9udC12YXJpYW50XCIsIFwiZm9udC13ZWlnaHRcIiwgXCJsaW5lLWhlaWdodFwiLCBcImxldHRlci1zcGFjaW5nXCIsIFwidGV4dC1hbGlnblwiLCBcInRleHQtZGVjb3JhdGlvblwiLCBcInRleHQtaW5kZW50XCIsIFwidGV4dC1yZW5kZXJpbmdcIiwgXCJ3b3JkLWJyZWFrXCIsIFwid29yZC13cmFwXCIsIFwid29yZC1zcGFjaW5nXCJdLFxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdG8gY29weSBmcm9tIHRleHRhcmVhIHRvIHRoZSBpZnJhbWVcbiAgICovXG4gIEJPWF9GT1JNQVRUSU5HID0gW1wiYmFja2dyb3VuZC1jb2xvclwiLCBcImJvcmRlci1jb2xsYXBzZVwiLCBcImJvcmRlci1ib3R0b20tY29sb3JcIiwgXCJib3JkZXItYm90dG9tLXN0eWxlXCIsIFwiYm9yZGVyLWJvdHRvbS13aWR0aFwiLCBcImJvcmRlci1sZWZ0LWNvbG9yXCIsIFwiYm9yZGVyLWxlZnQtc3R5bGVcIiwgXCJib3JkZXItbGVmdC13aWR0aFwiLCBcImJvcmRlci1yaWdodC1jb2xvclwiLCBcImJvcmRlci1yaWdodC1zdHlsZVwiLCBcImJvcmRlci1yaWdodC13aWR0aFwiLCBcImJvcmRlci10b3AtY29sb3JcIiwgXCJib3JkZXItdG9wLXN0eWxlXCIsIFwiYm9yZGVyLXRvcC13aWR0aFwiLCBcImNsZWFyXCIsIFwiZGlzcGxheVwiLCBcImZsb2F0XCIsIFwibWFyZ2luLWJvdHRvbVwiLCBcIm1hcmdpbi1sZWZ0XCIsIFwibWFyZ2luLXJpZ2h0XCIsIFwibWFyZ2luLXRvcFwiLCBcIm91dGxpbmUtY29sb3JcIiwgXCJvdXRsaW5lLW9mZnNldFwiLCBcIm91dGxpbmUtd2lkdGhcIiwgXCJvdXRsaW5lLXN0eWxlXCIsIFwicGFkZGluZy1sZWZ0XCIsIFwicGFkZGluZy1yaWdodFwiLCBcInBhZGRpbmctdG9wXCIsIFwicGFkZGluZy1ib3R0b21cIiwgXCJwb3NpdGlvblwiLCBcInRvcFwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcInotaW5kZXhcIiwgXCJ2ZXJ0aWNhbC1hbGlnblwiLCBcInRleHQtYWxpZ25cIiwgXCItd2Via2l0LWJveC1zaXppbmdcIiwgXCItbW96LWJveC1zaXppbmdcIiwgXCItbXMtYm94LXNpemluZ1wiLCBcImJveC1zaXppbmdcIiwgXCItd2Via2l0LWJveC1zaGFkb3dcIiwgXCItbW96LWJveC1zaGFkb3dcIiwgXCItbXMtYm94LXNoYWRvd1wiLCBcImJveC1zaGFkb3dcIiwgXCItd2Via2l0LWJvcmRlci10b3AtcmlnaHQtcmFkaXVzXCIsIFwiLW1vei1ib3JkZXItcmFkaXVzLXRvcHJpZ2h0XCIsIFwiYm9yZGVyLXRvcC1yaWdodC1yYWRpdXNcIiwgXCItd2Via2l0LWJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzXCIsIFwiLW1vei1ib3JkZXItcmFkaXVzLWJvdHRvbXJpZ2h0XCIsIFwiYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXNcIiwgXCItd2Via2l0LWJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIiwgXCItbW96LWJvcmRlci1yYWRpdXMtYm90dG9tbGVmdFwiLCBcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIiwgXCItd2Via2l0LWJvcmRlci10b3AtbGVmdC1yYWRpdXNcIiwgXCItbW96LWJvcmRlci1yYWRpdXMtdG9wbGVmdFwiLCBcImJvcmRlci10b3AtbGVmdC1yYWRpdXNcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXSxcblxuICAvKipcbiAgICogU3R5bGVzIHRvIHN5bmMgd2hpbGUgdGhlIHdpbmRvdyBnZXRzIHJlc2l6ZWRcbiAgICovXG4gIFJFU0laRV9TVFlMRSA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwidG9wXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCJdLFxuICAgICAgQURESVRJT05BTF9DU1NfUlVMRVMgPSBbXCJodG1sICAgICAgICAgICAgIHsgaGVpZ2h0OiAxMDAlOyB9XCIsIFwiYm9keSAgICAgICAgICAgICB7IG1pbi1oZWlnaHQ6IDEwMCU7IHBhZGRpbmc6IDA7IG1hcmdpbjogMDsgbWFyZ2luLXRvcDogLTFweDsgcGFkZGluZy10b3A6IDFweDsgd2hpdGUtc3BhY2U6IHByZS13cmFwOyB9XCIsIFwiLl93eXNpaHRtbDUtdGVtcCB7IGRpc3BsYXk6IG5vbmU7IH1cIiwgd3lzaWh0bWw1LmJyb3dzZXIuaXNHZWNrbyA/IFwiYm9keS5wbGFjZWhvbGRlciB7IGNvbG9yOiBncmF5dGV4dCAhaW1wb3J0YW50OyB9XCIgOiBcImJvZHkucGxhY2Vob2xkZXIgeyBjb2xvcjogI2E5YTlhOSAhaW1wb3J0YW50OyB9XCIsIFwiYm9keVtkaXNhYmxlZF0gICB7IGJhY2tncm91bmQtY29sb3I6ICNlZWUgIWltcG9ydGFudDsgY29sb3I6ICM5OTkgIWltcG9ydGFudDsgY3Vyc29yOiBkZWZhdWx0ICFpbXBvcnRhbnQ7IH1cIixcbiAgLy8gRW5zdXJlIHRoYXQgdXNlciBzZWUncyBicm9rZW4gaW1hZ2VzIGFuZCBjYW4gZGVsZXRlIHRoZW1cbiAgXCJpbWc6LW1vei1icm9rZW4gIHsgLW1vei1mb3JjZS1icm9rZW4taW1hZ2UtaWNvbjogMTsgaGVpZ2h0OiAyNHB4OyB3aWR0aDogMjRweDsgfVwiXTtcblxuICAvKipcbiAgICogV2l0aCBcInNldEFjdGl2ZVwiIElFIG9mZmVycyBhIHNtYXJ0IHdheSBvZiBmb2N1c2luZyBlbGVtZW50cyB3aXRob3V0IHNjcm9sbGluZyB0aGVtIGludG8gdmlldzpcbiAgICogaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NzM4KHY9dnMuODUpLmFzcHhcbiAgICpcbiAgICogT3RoZXIgYnJvd3NlcnMgbmVlZCBhIG1vcmUgaGFja3kgd2F5OiAocHNzc3QgZG9uJ3QgdGVsbCBteSBtYW1hKVxuICAgKiBJbiBvcmRlciB0byBwcmV2ZW50IHRoZSBlbGVtZW50IGJlaW5nIHNjcm9sbGVkIGludG8gdmlldyB3aGVuIGZvY3VzaW5nIGl0LCB3ZSBzaW1wbHlcbiAgICogbW92ZSBpdCBvdXQgb2YgdGhlIHNjcm9sbGFibGUgYXJlYSwgZm9jdXMgaXQsIGFuZCByZXNldCBpdCdzIHBvc2l0aW9uXG4gICAqL1xuICB2YXIgZm9jdXNXaXRob3V0U2Nyb2xsaW5nID0gZnVuY3Rpb24gZm9jdXNXaXRob3V0U2Nyb2xsaW5nKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5zZXRBY3RpdmUpIHtcbiAgICAgIC8vIEZvbGxvd2luZyBsaW5lIGNvdWxkIGNhdXNlIGEganMgZXJyb3Igd2hlbiB0aGUgdGV4dGFyZWEgaXMgaW52aXNpYmxlXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3hpbmcvd3lzaWh0bWw1L2lzc3Vlcy85XG4gICAgICB0cnkge1xuICAgICAgICBlbGVtZW50LnNldEFjdGl2ZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVsZW1lbnRTdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG4gICAgICAgICAgb3JpZ2luYWxTY3JvbGxUb3AgPSBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2MuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgICAgb3JpZ2luYWxTY3JvbGxMZWZ0ID0gZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvYy5ib2R5LnNjcm9sbExlZnQsXG4gICAgICAgICAgb3JpZ2luYWxTdHlsZXMgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBlbGVtZW50U3R5bGUucG9zaXRpb24sXG4gICAgICAgIHRvcDogZWxlbWVudFN0eWxlLnRvcCxcbiAgICAgICAgbGVmdDogZWxlbWVudFN0eWxlLmxlZnQsXG4gICAgICAgIFdlYmtpdFVzZXJTZWxlY3Q6IGVsZW1lbnRTdHlsZS5XZWJraXRVc2VyU2VsZWN0XG4gICAgICB9O1xuXG4gICAgICBkb20uc2V0U3R5bGVzKHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgdG9wOiBcIi05OTk5OXB4XCIsXG4gICAgICAgIGxlZnQ6IFwiLTk5OTk5cHhcIixcbiAgICAgICAgLy8gRG9uJ3QgYXNrIHdoeSBidXQgdGVtcG9yYXJpbHkgc2V0dGluZyAtd2Via2l0LXVzZXItc2VsZWN0IHRvIG5vbmUgbWFrZXMgdGhlIHdob2xlIHRoaW5nIHBlcmZvcm1pbmcgc21vb3RoZXJcbiAgICAgICAgV2Via2l0VXNlclNlbGVjdDogXCJub25lXCJcbiAgICAgIH0pLm9uKGVsZW1lbnQpO1xuXG4gICAgICBlbGVtZW50LmZvY3VzKCk7XG5cbiAgICAgIGRvbS5zZXRTdHlsZXMob3JpZ2luYWxTdHlsZXMpLm9uKGVsZW1lbnQpO1xuXG4gICAgICBpZiAod2luLnNjcm9sbFRvKSB7XG4gICAgICAgIC8vIFNvbWUgYnJvd3NlciBleHRlbnNpb25zIHVuc2V0IHRoaXMgbWV0aG9kIHRvIHByZXZlbnQgYW5ub3lhbmNlc1xuICAgICAgICAvLyBcIkJldHRlciBQb3BVcCBCbG9ja2VyXCIgZm9yIENocm9tZSBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYmV0dGVycG9wdXBibG9ja2VyL3NvdXJjZS9icm93c2UvdHJ1bmsvYmxvY2tTdGFydC5qcyMxMDBcbiAgICAgICAgLy8gSXNzdWU6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9iZXR0ZXJwb3B1cGJsb2NrZXIvaXNzdWVzL2RldGFpbD9pZD0xXG4gICAgICAgIHdpbi5zY3JvbGxUbyhvcmlnaW5hbFNjcm9sbExlZnQsIG9yaWdpbmFsU2Nyb2xsVG9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd3lzaWh0bWw1LnZpZXdzLkNvbXBvc2VyLnByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIG9yaWdpbmFsQWN0aXZlRWxlbWVudCA9IGRvYy5xdWVyeVNlbGVjdG9yKFwiOmZvY3VzXCIpLFxuICAgICAgICB0ZXh0YXJlYUVsZW1lbnQgPSB0aGlzLnRleHRhcmVhLmVsZW1lbnQsXG4gICAgICAgIGhhc1BsYWNlaG9sZGVyID0gdGV4dGFyZWFFbGVtZW50Lmhhc0F0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpLFxuICAgICAgICBvcmlnaW5hbFBsYWNlaG9sZGVyID0gaGFzUGxhY2Vob2xkZXIgJiYgdGV4dGFyZWFFbGVtZW50LmdldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpO1xuICAgIHRoaXMuZm9jdXNTdHlsZXNIb3N0ID0gdGhpcy5mb2N1c1N0eWxlc0hvc3QgfHwgSE9TVF9URU1QTEFURS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgIHRoaXMuYmx1clN0eWxlc0hvc3QgPSB0aGlzLmJsdXJTdHlsZXNIb3N0IHx8IEhPU1RfVEVNUExBVEUuY2xvbmVOb2RlKGZhbHNlKTtcblxuICAgIC8vIFJlbW92ZSBwbGFjZWhvbGRlciBiZWZvcmUgY29weWluZyAoYXMgdGhlIHBsYWNlaG9sZGVyIGhhcyBhbiBhZmZlY3Qgb24gdGhlIGNvbXB1dGVkIHN0eWxlKVxuICAgIGlmIChoYXNQbGFjZWhvbGRlcikge1xuICAgICAgdGV4dGFyZWFFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpO1xuICAgIH1cblxuICAgIGlmICh0ZXh0YXJlYUVsZW1lbnQgPT09IG9yaWdpbmFsQWN0aXZlRWxlbWVudCkge1xuICAgICAgdGV4dGFyZWFFbGVtZW50LmJsdXIoKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0gaWZyYW1lIHN0eWxlcyAoaGFzIHRvIGJlIHNldCBiZWZvcmUgZWRpdG9yIHN0eWxlcywgb3RoZXJ3aXNlIElFOSBzZXRzIHdyb25nIGZvbnRGYW1pbHkgb24gYmx1clN0eWxlc0hvc3QpIC0tLS0tLS0tLVxuICAgIGRvbS5jb3B5U3R5bGVzKEJPWF9GT1JNQVRUSU5HKS5mcm9tKHRleHRhcmVhRWxlbWVudCkudG8odGhpcy5pZnJhbWUpLmFuZFRvKHRoaXMuYmx1clN0eWxlc0hvc3QpO1xuXG4gICAgLy8gLS0tLS0tLS0tIGVkaXRvciBzdHlsZXMgLS0tLS0tLS0tXG4gICAgZG9tLmNvcHlTdHlsZXMoVEVYVF9GT1JNQVRUSU5HKS5mcm9tKHRleHRhcmVhRWxlbWVudCkudG8odGhpcy5lbGVtZW50KS5hbmRUbyh0aGlzLmJsdXJTdHlsZXNIb3N0KTtcblxuICAgIC8vIC0tLS0tLS0tLSBhcHBseSBzdGFuZGFyZCBydWxlcyAtLS0tLS0tLS1cbiAgICBkb20uaW5zZXJ0Q1NTKEFERElUSU9OQUxfQ1NTX1JVTEVTKS5pbnRvKHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50KTtcblxuICAgIC8vIC0tLS0tLS0tLSA6Zm9jdXMgc3R5bGVzIC0tLS0tLS0tLVxuICAgIGZvY3VzV2l0aG91dFNjcm9sbGluZyh0ZXh0YXJlYUVsZW1lbnQpO1xuICAgIGRvbS5jb3B5U3R5bGVzKEJPWF9GT1JNQVRUSU5HKS5mcm9tKHRleHRhcmVhRWxlbWVudCkudG8odGhpcy5mb2N1c1N0eWxlc0hvc3QpO1xuICAgIGRvbS5jb3B5U3R5bGVzKFRFWFRfRk9STUFUVElORykuZnJvbSh0ZXh0YXJlYUVsZW1lbnQpLnRvKHRoaXMuZm9jdXNTdHlsZXNIb3N0KTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IGNoYW5nZSB0aGUgZGlzcGxheSBzdHlsZSBvZiB0aGUgaWZyYW1lIHdoZW4gY29weWluZyBzdHlsZXMgb2JsdXIvb25mb2N1c1xuICAgIC8vIHRoaXMgaXMgbmVlZGVkIGZvciB3aGVuIHRoZSBjaGFuZ2VfdmlldyBldmVudCBpcyBmaXJlZCB3aGVyZSB0aGUgaWZyYW1lIGlzIGhpZGRlbiBhbmQgdGhlblxuICAgIC8vIHRoZSBibHVyIGV2ZW50IGZpcmVzIGFuZCByZS1kaXNwbGF5cyBpdFxuICAgIHZhciBib3hGb3JtYXR0aW5nU3R5bGVzID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoQk9YX0ZPUk1BVFRJTkcpLndpdGhvdXQoW1wiZGlzcGxheVwiXSk7XG5cbiAgICAvLyAtLS0tLS0tLS0gcmVzdG9yZSBmb2N1cyAtLS0tLS0tLS1cbiAgICBpZiAob3JpZ2luYWxBY3RpdmVFbGVtZW50KSB7XG4gICAgICBvcmlnaW5hbEFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dGFyZWFFbGVtZW50LmJsdXIoKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0gcmVzdG9yZSBwbGFjZWhvbGRlciAtLS0tLS0tLS1cbiAgICBpZiAoaGFzUGxhY2Vob2xkZXIpIHtcbiAgICAgIHRleHRhcmVhRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiLCBvcmlnaW5hbFBsYWNlaG9sZGVyKTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGNvcHlpbmcgc3R5bGVzLCB3ZSBvbmx5IGdldCB0aGUgY29tcHV0ZWQgc3R5bGUgd2hpY2ggaXMgbmV2ZXIgcmV0dXJuZWQgaW4gcGVyY2VudCB1bml0XG4gICAgLy8gVGhlcmVmb3JlIHdlJ3ZlIHRvIHJlY2FsY3VsYXRlIHN0eWxlIG9ucmVzaXplXG4gICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5oYXNDdXJyZW50U3R5bGVQcm9wZXJ0eSgpKSB7XG4gICAgICB2YXIgd2luT2JzZXJ2ZXIgPSBkb20ub2JzZXJ2ZSh3aW4sIFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGlmIGNvbXBvc2VyIGRvZXNuJ3QgZXhpc3QgYW55bW9yZVxuICAgICAgICBpZiAoIWRvbS5jb250YWlucyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoYXQuaWZyYW1lKSkge1xuICAgICAgICAgIHdpbk9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yaWdpbmFsVGV4dGFyZWFEaXNwbGF5U3R5bGUgPSBkb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20odGV4dGFyZWFFbGVtZW50KSxcbiAgICAgICAgICAgIG9yaWdpbmFsQ29tcG9zZXJEaXNwbGF5U3R5bGUgPSBkb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20odGhhdC5pZnJhbWUpO1xuICAgICAgICB0ZXh0YXJlYUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgIHRoYXQuaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgZG9tLmNvcHlTdHlsZXMoUkVTSVpFX1NUWUxFKS5mcm9tKHRleHRhcmVhRWxlbWVudCkudG8odGhhdC5pZnJhbWUpLmFuZFRvKHRoYXQuZm9jdXNTdHlsZXNIb3N0KS5hbmRUbyh0aGF0LmJsdXJTdHlsZXNIb3N0KTtcbiAgICAgICAgdGhhdC5pZnJhbWUuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsQ29tcG9zZXJEaXNwbGF5U3R5bGU7XG4gICAgICAgIHRleHRhcmVhRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxUZXh0YXJlYURpc3BsYXlTdHlsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLSBTeW5jIGZvY3VzL2JsdXIgc3R5bGVzIC0tLS0tLS0tLVxuICAgIHRoaXMucGFyZW50Lm9ic2VydmUoXCJmb2N1czpjb21wb3NlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uY29weVN0eWxlcyhib3hGb3JtYXR0aW5nU3R5bGVzKS5mcm9tKHRoYXQuZm9jdXNTdHlsZXNIb3N0KS50byh0aGF0LmlmcmFtZSk7XG4gICAgICBkb20uY29weVN0eWxlcyhURVhUX0ZPUk1BVFRJTkcpLmZyb20odGhhdC5mb2N1c1N0eWxlc0hvc3QpLnRvKHRoYXQuZWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnBhcmVudC5vYnNlcnZlKFwiYmx1cjpjb21wb3NlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uY29weVN0eWxlcyhib3hGb3JtYXR0aW5nU3R5bGVzKS5mcm9tKHRoYXQuYmx1clN0eWxlc0hvc3QpLnRvKHRoYXQuaWZyYW1lKTtcbiAgICAgIGRvbS5jb3B5U3R5bGVzKFRFWFRfRk9STUFUVElORykuZnJvbSh0aGF0LmJsdXJTdHlsZXNIb3N0KS50byh0aGF0LmVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KSh3eXNpaHRtbDUpOyAvKipcbiAgICAgICAgICAgICAgICogVGFraW5nIGNhcmUgb2YgZXZlbnRzXG4gICAgICAgICAgICAgICAqICAtIFNpbXVsYXRpbmcgJ2NoYW5nZScgZXZlbnQgb24gY29udGVudEVkaXRhYmxlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICogIC0gSGFuZGxpbmcgZHJhZyAmIGRyb3AgbG9naWNcbiAgICAgICAgICAgICAgICogIC0gQ2F0Y2ggcGFzdGUgZXZlbnRzXG4gICAgICAgICAgICAgICAqICAtIERpc3BhdGNoIHByb3ByaWV0YXJ5IG5ld3dvcmQ6Y29tcG9zZXIgZXZlbnRcbiAgICAgICAgICAgICAgICogIC0gS2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICAgICAgICAgICAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIGRvbSA9IHd5c2lodG1sNS5kb20sXG4gICAgICBicm93c2VyID0gd3lzaWh0bWw1LmJyb3dzZXIsXG5cbiAgLyoqXG4gICAqIE1hcCBrZXlDb2RlcyB0byBxdWVyeSBjb21tYW5kc1xuICAgKi9cbiAgc2hvcnRjdXRzID0ge1xuICAgIFwiNjZcIjogXCJib2xkXCIsIC8vIEJcbiAgICBcIjczXCI6IFwiaXRhbGljXCIsIC8vIElcbiAgICBcIjg1XCI6IFwidW5kZXJsaW5lXCIgLy8gVVxuICB9O1xuXG4gIHd5c2lodG1sNS52aWV3cy5Db21wb3Nlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIHN0YXRlID0gdGhpcy5nZXRWYWx1ZSgpLFxuICAgICAgICBpZnJhbWUgPSB0aGlzLnNhbmRib3guZ2V0SWZyYW1lKCksXG4gICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgIGZvY3VzQmx1ckVsZW1lbnQgPSBicm93c2VyLnN1cHBvcnRzRXZlbnRzSW5JZnJhbWVDb3JyZWN0bHkoKSA/IGVsZW1lbnQgOiB0aGlzLnNhbmRib3guZ2V0V2luZG93KCksXG5cbiAgICAvLyBGaXJlZm94IDwgMy41IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZHJvcCBldmVudCwgaW5zdGVhZCBpdCBzdXBwb3J0cyBhIHNvIGNhbGxlZCBcImRyYWdkcm9wXCIgZXZlbnQgd2hpY2ggYmVoYXZlcyBhbG1vc3QgdGhlIHNhbWVcbiAgICBwYXN0ZUV2ZW50cyA9IGJyb3dzZXIuc3VwcG9ydHNFdmVudChcImRyb3BcIikgPyBbXCJkcm9wXCIsIFwicGFzdGVcIl0gOiBbXCJkcmFnZHJvcFwiLCBcInBhc3RlXCJdO1xuXG4gICAgLy8gLS0tLS0tLS0tIGRlc3Ryb3k6Y29tcG9zZXIgZXZlbnQgLS0tLS0tLS0tXG4gICAgZG9tLm9ic2VydmUoaWZyYW1lLCBcIkRPTU5vZGVSZW1vdmVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoZG9tTm9kZVJlbW92ZWRJbnRlcnZhbCk7XG4gICAgICB0aGF0LnBhcmVudC5maXJlKFwiZGVzdHJveTpjb21wb3NlclwiKTtcbiAgICB9KTtcblxuICAgIC8vIERPTU5vZGVSZW1vdmVkIGV2ZW50IGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUUgOFxuICAgIHZhciBkb21Ob2RlUmVtb3ZlZEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFkb20uY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBpZnJhbWUpKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoZG9tTm9kZVJlbW92ZWRJbnRlcnZhbCk7XG4gICAgICAgIHRoYXQucGFyZW50LmZpcmUoXCJkZXN0cm95OmNvbXBvc2VyXCIpO1xuICAgICAgfVxuICAgIH0sIDI1MCk7XG5cbiAgICAvLyAtLS0tLS0tLS0gRm9jdXMgJiBibHVyIGxvZ2ljIC0tLS0tLS0tLVxuICAgIGRvbS5vYnNlcnZlKGZvY3VzQmx1ckVsZW1lbnQsIFwiZm9jdXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC5wYXJlbnQuZmlyZShcImZvY3VzXCIpLmZpcmUoXCJmb2N1czpjb21wb3NlclwiKTtcblxuICAgICAgLy8gRGVsYXkgc3RvcmluZyBvZiBzdGF0ZSB1bnRpbCBhbGwgZm9jdXMgaGFuZGxlciBhcmUgZmlyZWRcbiAgICAgIC8vIGVzcGVjaWFsbHkgdGhlIG9uZSB3aGljaCByZXNldHMgdGhlIHBsYWNlaG9sZGVyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RhdGUgPSB0aGF0LmdldFZhbHVlKCk7XG4gICAgICB9LCAwKTtcbiAgICB9KTtcblxuICAgIGRvbS5vYnNlcnZlKGZvY3VzQmx1ckVsZW1lbnQsIFwiYmx1clwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc3RhdGUgIT09IHRoYXQuZ2V0VmFsdWUoKSkge1xuICAgICAgICB0aGF0LnBhcmVudC5maXJlKFwiY2hhbmdlXCIpLmZpcmUoXCJjaGFuZ2U6Y29tcG9zZXJcIik7XG4gICAgICB9XG4gICAgICB0aGF0LnBhcmVudC5maXJlKFwiYmx1clwiKS5maXJlKFwiYmx1cjpjb21wb3NlclwiKTtcbiAgICB9KTtcblxuICAgIGlmICh3eXNpaHRtbDUuYnJvd3Nlci5pc0lvcygpKSB7XG4gICAgICAvLyBXaGVuIG9uIGlQYWQvaVBob25lL0lQb2QgYWZ0ZXIgY2xpY2tpbmcgb3V0c2lkZSBvZiBlZGl0b3IsIHRoZSBlZGl0b3IgbG9zZXMgZm9jdXNcbiAgICAgIC8vIGJ1dCB0aGUgVUkgc3RpbGwgYWN0cyBhcyBpZiB0aGUgZWRpdG9yIGhhcyBmb2N1cyAoYmxpbmtpbmcgY2FyZXQgYW5kIG9uc2NyZWVuIGtleWJvYXJkIHZpc2libGUpXG4gICAgICAvLyBXZSBwcmV2ZW50IHRoYXQgYnkgZm9jdXNpbmcgYSB0ZW1wb3JhcnkgaW5wdXQgZWxlbWVudCB3aGljaCBpbW1lZGlhdGVseSBsb3NlcyBmb2N1c1xuICAgICAgZG9tLm9ic2VydmUoZWxlbWVudCwgXCJibHVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxcbiAgICAgICAgICAgIG9yaWdpbmFsU2Nyb2xsVG9wID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICAgIG9yaWdpbmFsU2Nyb2xsTGVmdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGF0LnNlbGVjdGlvbi5pbnNlcnROb2RlKGlucHV0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgIGlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW5wdXQpO1xuXG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyhvcmlnaW5hbFNjcm9sbExlZnQsIG9yaWdpbmFsU2Nyb2xsVG9wKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLSBEcmFnICYgRHJvcCBsb2dpYyAtLS0tLS0tLS1cbiAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBcImRyYWdlbnRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LnBhcmVudC5maXJlKFwidW5zZXRfcGxhY2Vob2xkZXJcIik7XG4gICAgfSk7XG5cbiAgICBpZiAoYnJvd3Nlci5maXJlc09uRHJvcE9ubHlXaGVuT25EcmFnT3ZlcklzQ2FuY2VsbGVkKCkpIHtcbiAgICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFtcImRyYWdvdmVyXCIsIFwiZHJhZ2VudGVyXCJdLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIHBhc3RlRXZlbnRzLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBldmVudC5kYXRhVHJhbnNmZXIsXG4gICAgICAgICAgZGF0YTtcblxuICAgICAgaWYgKGRhdGFUcmFuc2ZlciAmJiBicm93c2VyLnN1cHBvcnRzRGF0YVRyYW5zZmVyKCkpIHtcbiAgICAgICAgZGF0YSA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dC9odG1sXCIpIHx8IGRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dC9wbGFpblwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgdGhhdC5jb21tYW5kcy5leGVjKFwiaW5zZXJ0SFRNTFwiLCBkYXRhKTtcbiAgICAgICAgdGhhdC5wYXJlbnQuZmlyZShcInBhc3RlXCIpLmZpcmUoXCJwYXN0ZTpjb21wb3NlclwiKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LnBhcmVudC5maXJlKFwicGFzdGVcIikuZmlyZShcInBhc3RlOmNvbXBvc2VyXCIpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIC0tLS0tLS0tLSBuZXdvcmQgZXZlbnQgLS0tLS0tKy0tLVxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwia2V5dXBcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICBpZiAoa2V5Q29kZSA9PT0gd3lzaWh0bWw1LkVOVEVSX0tFWSkge1xuICAgICAgICB0aGF0LnBhcmVudC5maXJlKFwibmV3d29yZDpjb21wb3NlclwiKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucGFyZW50Lm9ic2VydmUoXCJwYXN0ZTpjb21wb3NlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5wYXJlbnQuZmlyZShcIm5ld3dvcmQ6Y29tcG9zZXJcIik7XG4gICAgICB9LCAwKTtcbiAgICB9KTtcblxuICAgIC8vIC0tLS0tLS0tLSBNYWtlIHN1cmUgdGhhdCBpbWFnZXMgYXJlIHNlbGVjdGVkIHdoZW4gY2xpY2tpbmcgb24gdGhlbSAtLS0tLS0tLS1cbiAgICBpZiAoIWJyb3dzZXIuY2FuU2VsZWN0SW1hZ2VzSW5Db250ZW50RWRpdGFibGUoKSkge1xuICAgICAgZG9tLm9ic2VydmUoZWxlbWVudCwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09IFwiSU1HXCIpIHtcbiAgICAgICAgICB0aGF0LnNlbGVjdGlvbi5zZWxlY3ROb2RlKHRhcmdldCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tIFNob3J0Y3V0IGxvZ2ljIC0tLS0tLS0tLVxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZSxcbiAgICAgICAgICBjb21tYW5kID0gc2hvcnRjdXRzW2tleUNvZGVdO1xuICAgICAgaWYgKChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpICYmICFldmVudC5hbHRLZXkgJiYgY29tbWFuZCkge1xuICAgICAgICB0aGF0LmNvbW1hbmRzLmV4ZWMoY29tbWFuZCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyAtLS0tLS0tLS0gTWFrZSBzdXJlIHRoYXQgd2hlbiBwcmVzc2luZyBiYWNrc3BhY2UvZGVsZXRlIG9uIHNlbGVjdGVkIGltYWdlcyBkZWxldGVzIHRoZSBpbWFnZSBhbmQgaXQncyBhbmNob3IgLS0tLS0tLS0tXG4gICAgZG9tLm9ic2VydmUoZWxlbWVudCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoYXQuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSh0cnVlKSxcbiAgICAgICAgICBrZXlDb2RlID0gZXZlbnQua2V5Q29kZSxcbiAgICAgICAgICBwYXJlbnQ7XG4gICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5ub2RlTmFtZSA9PT0gXCJJTUdcIiAmJiAoa2V5Q29kZSA9PT0gd3lzaWh0bWw1LkJBQ0tTUEFDRV9LRVkgfHwga2V5Q29kZSA9PT0gd3lzaWh0bWw1LkRFTEVURV9LRVkpKSB7XG4gICAgICAgIC8vIDggPT4gYmFja3NwYWNlLCA0NiA9PiBkZWxldGVcbiAgICAgICAgcGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgIC8vIGRlbGV0ZSB0aGUgPGltZz5cbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgICAgIC8vIGFuZCBpdCdzIHBhcmVudCA8YT4gdG9vIGlmIGl0IGhhc24ndCBnb3QgYW55IG90aGVyIGNoaWxkIG5vZGVzXG4gICAgICAgIGlmIChwYXJlbnQubm9kZU5hbWUgPT09IFwiQVwiICYmICFwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBhcmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3eXNpaHRtbDUucXVpcmtzLnJlZHJhdyhlbGVtZW50KTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyAtLS0tLS0tLS0gU2hvdyB1cmwgaW4gdG9vbHRpcCB3aGVuIGhvdmVyaW5nIGxpbmtzIG9yIGltYWdlcyAtLS0tLS0tLS1cbiAgICB2YXIgdGl0bGVQcmVmaXhlcyA9IHtcbiAgICAgIElNRzogXCJJbWFnZTogXCIsXG4gICAgICBBOiBcIkxpbms6IFwiXG4gICAgfTtcblxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICBub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZSxcbiAgICAgICAgICB0aXRsZTtcbiAgICAgIGlmIChub2RlTmFtZSAhPT0gXCJBXCIgJiYgbm9kZU5hbWUgIT09IFwiSU1HXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhhc1RpdGxlID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZShcInRpdGxlXCIpO1xuICAgICAgaWYgKCFoYXNUaXRsZSkge1xuICAgICAgICB0aXRsZSA9IHRpdGxlUHJlZml4ZXNbbm9kZU5hbWVdICsgKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJzcmNcIikpO1xuICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgdGl0bGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSkod3lzaWh0bWw1KTsgLyoqXG4gICAgICAgICAgICAgICAqIENsYXNzIHRoYXQgdGFrZXMgY2FyZSB0aGF0IHRoZSB2YWx1ZSBvZiB0aGUgY29tcG9zZXIgYW5kIHRoZSB0ZXh0YXJlYSBpcyBhbHdheXMgaW4gc3luY1xuICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciBJTlRFUlZBTCA9IDQwMDtcblxuICB3eXNpaHRtbDUudmlld3MuU3luY2hyb25pemVyID0gQmFzZS5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LnZpZXdzLlN5bmNocm9uaXplci5wcm90b3R5cGUgKi97XG5cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gY29uc3RydWN0b3IoZWRpdG9yLCB0ZXh0YXJlYSwgY29tcG9zZXIpIHtcbiAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgdGhpcy50ZXh0YXJlYSA9IHRleHRhcmVhO1xuICAgICAgdGhpcy5jb21wb3NlciA9IGNvbXBvc2VyO1xuXG4gICAgICB0aGlzLl9vYnNlcnZlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN5bmMgaHRtbCBmcm9tIGNvbXBvc2VyIHRvIHRleHRhcmVhXG4gICAgICogVGFrZXMgY2FyZSBvZiBwbGFjZWhvbGRlcnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZFBhcnNlSHRtbCBXaGV0aGVyIHRoZSBodG1sIHNob3VsZCBiZSBzYW5pdGl6ZWQgYmVmb3JlIGluc2VydGluZyBpdCBpbnRvIHRoZSB0ZXh0YXJlYVxuICAgICAqL1xuICAgIGZyb21Db21wb3NlclRvVGV4dGFyZWE6IGZ1bmN0aW9uIGZyb21Db21wb3NlclRvVGV4dGFyZWEoc2hvdWxkUGFyc2VIdG1sKSB7XG4gICAgICB0aGlzLnRleHRhcmVhLnNldFZhbHVlKHd5c2lodG1sNS5sYW5nLnN0cmluZyh0aGlzLmNvbXBvc2VyLmdldFZhbHVlKCkpLnRyaW0oKSwgc2hvdWxkUGFyc2VIdG1sKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3luYyB2YWx1ZSBvZiB0ZXh0YXJlYSB0byBjb21wb3NlclxuICAgICAqIFRha2VzIGNhcmUgb2YgcGxhY2Vob2xkZXJzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaG91bGRQYXJzZUh0bWwgV2hldGhlciB0aGUgaHRtbCBzaG91bGQgYmUgc2FuaXRpemVkIGJlZm9yZSBpbnNlcnRpbmcgaXQgaW50byB0aGUgY29tcG9zZXJcbiAgICAgKi9cbiAgICBmcm9tVGV4dGFyZWFUb0NvbXBvc2VyOiBmdW5jdGlvbiBmcm9tVGV4dGFyZWFUb0NvbXBvc2VyKHNob3VsZFBhcnNlSHRtbCkge1xuICAgICAgdmFyIHRleHRhcmVhVmFsdWUgPSB0aGlzLnRleHRhcmVhLmdldFZhbHVlKCk7XG4gICAgICBpZiAodGV4dGFyZWFWYWx1ZSkge1xuICAgICAgICB0aGlzLmNvbXBvc2VyLnNldFZhbHVlKHRleHRhcmVhVmFsdWUsIHNob3VsZFBhcnNlSHRtbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBvc2VyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLmZpcmUoXCJzZXRfcGxhY2Vob2xkZXJcIik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZSBzeW5jaW5nIGJhc2VkIG9uIHZpZXcgc3RhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZFBhcnNlSHRtbCBXaGV0aGVyIHRoZSBodG1sIHNob3VsZCBiZSBzYW5pdGl6ZWQgYmVmb3JlIGluc2VydGluZyBpdCBpbnRvIHRoZSBjb21wb3Nlci90ZXh0YXJlYVxuICAgICAqL1xuICAgIHN5bmM6IGZ1bmN0aW9uIHN5bmMoc2hvdWxkUGFyc2VIdG1sKSB7XG4gICAgICBpZiAodGhpcy5lZGl0b3IuY3VycmVudFZpZXcubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiKSB7XG4gICAgICAgIHRoaXMuZnJvbVRleHRhcmVhVG9Db21wb3NlcihzaG91bGRQYXJzZUh0bWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mcm9tQ29tcG9zZXJUb1RleHRhcmVhKHNob3VsZFBhcnNlSHRtbCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGludGVydmFsLWJhc2VkIHN5bmNpbmdcbiAgICAgKiBhbHNvIG1ha2VzIHN1cmUgdGhhdCBvbi1zdWJtaXQgdGhlIGNvbXBvc2VyJ3MgY29udGVudCBpcyBzeW5jZWQgd2l0aCB0aGUgdGV4dGFyZWFcbiAgICAgKiBpbW1lZGlhdGVseSB3aGVuIHRoZSBmb3JtIGdldHMgc3VibWl0dGVkXG4gICAgICovXG4gICAgX29ic2VydmU6IGZ1bmN0aW9uIF9vYnNlcnZlKCkge1xuICAgICAgdmFyIGludGVydmFsLFxuICAgICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIGZvcm0gPSB0aGlzLnRleHRhcmVhLmVsZW1lbnQuZm9ybSxcbiAgICAgICAgICBzdGFydEludGVydmFsID0gZnVuY3Rpb24gc3RhcnRJbnRlcnZhbCgpIHtcbiAgICAgICAgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhhdC5mcm9tQ29tcG9zZXJUb1RleHRhcmVhKCk7XG4gICAgICAgIH0sIElOVEVSVkFMKTtcbiAgICAgIH0sXG4gICAgICAgICAgc3RvcEludGVydmFsID0gZnVuY3Rpb24gc3RvcEludGVydmFsKCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgaW50ZXJ2YWwgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgc3RhcnRJbnRlcnZhbCgpO1xuXG4gICAgICBpZiAoZm9ybSkge1xuICAgICAgICAvLyBJZiB0aGUgdGV4dGFyZWEgaXMgaW4gYSBmb3JtIG1ha2Ugc3VyZSB0aGF0IGFmdGVyIG9ucmVzZXQgYW5kIG9uc3VibWl0IHRoZSBjb21wb3NlclxuICAgICAgICAvLyBoYXMgdGhlIGNvcnJlY3Qgc3RhdGVcbiAgICAgICAgd3lzaWh0bWw1LmRvbS5vYnNlcnZlKGZvcm0sIFwic3VibWl0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LnN5bmModHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB3eXNpaHRtbDUuZG9tLm9ic2VydmUoZm9ybSwgXCJyZXNldFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LmZyb21UZXh0YXJlYVRvQ29tcG9zZXIoKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRpdG9yLm9ic2VydmUoXCJjaGFuZ2Vfdmlld1wiLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgICBpZiAodmlldyA9PT0gXCJjb21wb3NlclwiICYmICFpbnRlcnZhbCkge1xuICAgICAgICAgIHRoYXQuZnJvbVRleHRhcmVhVG9Db21wb3Nlcih0cnVlKTtcbiAgICAgICAgICBzdGFydEludGVydmFsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmlldyA9PT0gXCJ0ZXh0YXJlYVwiKSB7XG4gICAgICAgICAgdGhhdC5mcm9tQ29tcG9zZXJUb1RleHRhcmVhKHRydWUpO1xuICAgICAgICAgIHN0b3BJbnRlcnZhbCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5lZGl0b3Iub2JzZXJ2ZShcImRlc3Ryb3k6Y29tcG9zZXJcIiwgc3RvcEludGVydmFsKTtcbiAgICB9XG4gIH0pO1xufSkod3lzaWh0bWw1KTtcbnd5c2lodG1sNS52aWV3cy5UZXh0YXJlYSA9IHd5c2lodG1sNS52aWV3cy5WaWV3LmV4dGVuZChcbi8qKiBAc2NvcGUgd3lzaWh0bWw1LnZpZXdzLlRleHRhcmVhLnByb3RvdHlwZSAqL3tcbiAgbmFtZTogXCJ0ZXh0YXJlYVwiLFxuXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBjb25zdHJ1Y3RvcihwYXJlbnQsIHRleHRhcmVhRWxlbWVudCwgY29uZmlnKSB7XG4gICAgdGhpcy5iYXNlKHBhcmVudCwgdGV4dGFyZWFFbGVtZW50LCBjb25maWcpO1xuXG4gICAgdGhpcy5fb2JzZXJ2ZSgpO1xuICB9LFxuXG4gIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSBcIlwiO1xuICB9LFxuXG4gIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShwYXJzZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuaXNFbXB0eSgpID8gXCJcIiA6IHRoaXMuZWxlbWVudC52YWx1ZTtcbiAgICBpZiAocGFyc2UpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5wYXJlbnQucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG5cbiAgc2V0VmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKGh0bWwsIHBhcnNlKSB7XG4gICAgaWYgKHBhcnNlKSB7XG4gICAgICBodG1sID0gdGhpcy5wYXJlbnQucGFyc2UoaHRtbCk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudC52YWx1ZSA9IGh0bWw7XG4gIH0sXG5cbiAgaGFzUGxhY2Vob2xkZXJTZXQ6IGZ1bmN0aW9uIGhhc1BsYWNlaG9sZGVyU2V0KCkge1xuICAgIHZhciBzdXBwb3J0c1BsYWNlaG9sZGVyID0gd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNQbGFjZWhvbGRlckF0dHJpYnV0ZU9uKHRoaXMuZWxlbWVudCksXG4gICAgICAgIHBsYWNlaG9sZGVyVGV4dCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKSB8fCBudWxsLFxuICAgICAgICB2YWx1ZSA9IHRoaXMuZWxlbWVudC52YWx1ZSxcbiAgICAgICAgaXNFbXB0eSA9ICF2YWx1ZTtcbiAgICByZXR1cm4gc3VwcG9ydHNQbGFjZWhvbGRlciAmJiBpc0VtcHR5IHx8IHZhbHVlID09PSBwbGFjZWhvbGRlclRleHQ7XG4gIH0sXG5cbiAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXd5c2lodG1sNS5sYW5nLnN0cmluZyh0aGlzLmVsZW1lbnQudmFsdWUpLnRyaW0oKSB8fCB0aGlzLmhhc1BsYWNlaG9sZGVyU2V0KCk7XG4gIH0sXG5cbiAgX29ic2VydmU6IGZ1bmN0aW9uIF9vYnNlcnZlKCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgICAgZXZlbnRNYXBwaW5nID0ge1xuICAgICAgZm9jdXNpbjogXCJmb2N1c1wiLFxuICAgICAgZm9jdXNvdXQ6IFwiYmx1clwiXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGxpbmcgZm9jdXMoKSBvciBibHVyKCkgb24gYW4gZWxlbWVudCBkb2Vzbid0IHN5bmNocm9ub3VzbHkgdHJpZ2dlciB0aGUgYXR0YWNoZWQgZm9jdXMvYmx1ciBldmVudHNcbiAgICAgKiBUaGlzIGlzIHRoZSBjYXNlIGZvciBmb2N1c2luIGFuZCBmb2N1c291dCwgc28gbGV0J3MgdXNlIHRoZW0gd2hlbmV2ZXIgcG9zc2libGUsIGtrdGh4YmFpXG4gICAgICovXG4gICAgZXZlbnRzID0gd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNFdmVudChcImZvY3VzaW5cIikgPyBbXCJmb2N1c2luXCIsIFwiZm9jdXNvdXRcIiwgXCJjaGFuZ2VcIl0gOiBbXCJmb2N1c1wiLCBcImJsdXJcIiwgXCJjaGFuZ2VcIl07XG5cbiAgICBwYXJlbnQub2JzZXJ2ZShcImJlZm9yZWxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgd3lzaWh0bWw1LmRvbS5vYnNlcnZlKGVsZW1lbnQsIGV2ZW50cywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudE1hcHBpbmdbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgICAgICAgcGFyZW50LmZpcmUoZXZlbnROYW1lKS5maXJlKGV2ZW50TmFtZSArIFwiOnRleHRhcmVhXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIHd5c2lodG1sNS5kb20ub2JzZXJ2ZShlbGVtZW50LCBbXCJwYXN0ZVwiLCBcImRyb3BcIl0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGFyZW50LmZpcmUoXCJwYXN0ZVwiKS5maXJlKFwicGFzdGU6dGV4dGFyZWFcIik7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pOyAvKipcbiAgICAqIFRvb2xiYXIgRGlhbG9nXG4gICAgKlxuICAgICogQHBhcmFtIHtFbGVtZW50fSBsaW5rIFRoZSB0b29sYmFyIGxpbmsgd2hpY2ggY2F1c2VzIHRoZSBkaWFsb2cgdG8gc2hvdyB1cFxuICAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgVGhlIGRpYWxvZyBjb250YWluZXJcbiAgICAqXG4gICAgKiBAZXhhbXBsZVxuICAgICogICAgPCEtLSBUb29sYmFyIGxpbmsgLS0+XG4gICAgKiAgICA8YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPVwiaW5zZXJ0SW1hZ2VcIj5pbnNlcnQgYW4gaW1hZ2U8L2E+XG4gICAgKlxuICAgICogICAgPCEtLSBEaWFsb2cgLS0+XG4gICAgKiAgICA8ZGl2IGRhdGEtd3lzaWh0bWw1LWRpYWxvZz1cImluc2VydEltYWdlXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lO1wiPlxuICAgICogICAgICA8bGFiZWw+XG4gICAgKiAgICAgICAgVVJMOiA8aW5wdXQgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVwic3JjXCIgdmFsdWU9XCJodHRwOi8vXCI+XG4gICAgKiAgICAgIDwvbGFiZWw+XG4gICAgKiAgICAgIDxsYWJlbD5cbiAgICAqICAgICAgICBBbHRlcm5hdGl2ZSB0ZXh0OiA8aW5wdXQgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVwiYWx0XCIgdmFsdWU9XCJcIj5cbiAgICAqICAgICAgPC9sYWJlbD5cbiAgICAqICAgIDwvZGl2PlxuICAgICpcbiAgICAqICAgIDxzY3JpcHQ+XG4gICAgKiAgICAgIHZhciBkaWFsb2cgPSBuZXcgd3lzaWh0bWw1LnRvb2xiYXIuRGlhbG9nKFxuICAgICogICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS13eXNpaHRtbDUtY29tbWFuZD0naW5zZXJ0SW1hZ2UnXVwiKSxcbiAgICAqICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtd3lzaWh0bWw1LWRpYWxvZz0naW5zZXJ0SW1hZ2UnXVwiKVxuICAgICogICAgICApO1xuICAgICogICAgICBkaWFsb2cub2JzZXJ2ZShcInNhdmVcIiwgZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICogICAgICAgIC8vIGRvIHNvbWV0aGluZ1xuICAgICogICAgICB9KTtcbiAgICAqICAgIDwvc2NyaXB0PlxuICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgZG9tID0gd3lzaWh0bWw1LmRvbSxcbiAgICAgIENMQVNTX05BTUVfT1BFTkVEID0gXCJ3eXNpaHRtbDUtY29tbWFuZC1kaWFsb2ctb3BlbmVkXCIsXG4gICAgICBTRUxFQ1RPUl9GT1JNX0VMRU1FTlRTID0gXCJpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYVwiLFxuICAgICAgU0VMRUNUT1JfRklFTERTID0gXCJbZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkXVwiLFxuICAgICAgQVRUUklCVVRFX0ZJRUxEUyA9IFwiZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkXCI7XG5cbiAgd3lzaWh0bWw1LnRvb2xiYXIuRGlhbG9nID0gd3lzaWh0bWw1LmxhbmcuRGlzcGF0Y2hlci5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LnRvb2xiYXIuRGlhbG9nLnByb3RvdHlwZSAqL3tcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gY29uc3RydWN0b3IobGluaywgY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmxpbmsgPSBsaW5rO1xuICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfSxcblxuICAgIF9vYnNlcnZlOiBmdW5jdGlvbiBfb2JzZXJ2ZSgpIHtcbiAgICAgIGlmICh0aGlzLl9vYnNlcnZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBjYWxsYmFja1dyYXBwZXIgPSBmdW5jdGlvbiBjYWxsYmFja1dyYXBwZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGF0Ll9zZXJpYWxpemUoKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMgPT0gdGhhdC5lbGVtZW50VG9DaGFuZ2UpIHtcbiAgICAgICAgICB0aGF0LmZpcmUoXCJlZGl0XCIsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoYXQuZmlyZShcInNhdmVcIiwgYXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5oaWRlKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfTtcblxuICAgICAgZG9tLm9ic2VydmUodGhhdC5saW5rLCBcImNsaWNrXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZG9tLmhhc0NsYXNzKHRoYXQubGluaywgQ0xBU1NfTkFNRV9PUEVORUQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LmhpZGUoKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGRvbS5vYnNlcnZlKHRoaXMuY29udGFpbmVyLCBcImtleWRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IHd5c2lodG1sNS5FTlRFUl9LRVkpIHtcbiAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlDb2RlID09PSB3eXNpaHRtbDUuRVNDQVBFX0tFWSkge1xuICAgICAgICAgIC8vIHRoYXQuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZG9tLmRlbGVnYXRlKHRoaXMuY29udGFpbmVyLCBcIltkYXRhLXd5c2lodG1sNS1kaWFsb2ctYWN0aW9uPXNhdmVdXCIsIFwiY2xpY2tcIiwgY2FsbGJhY2tXcmFwcGVyKTtcblxuICAgICAgZG9tLmRlbGVnYXRlKHRoaXMuY29udGFpbmVyLCBcIltkYXRhLXd5c2lodG1sNS1kaWFsb2ctYWN0aW9uPWNhbmNlbF1cIiwgXCJjbGlja1wiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhhdC5maXJlKFwiY2FuY2VsXCIpO1xuICAgICAgICB0aGF0LmhpZGUoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGZvcm1FbGVtZW50cyA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfRk9STV9FTEVNRU5UUyksXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gZm9ybUVsZW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBfY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uIF9jbGVhckludGVydmFsKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoYXQuaW50ZXJ2YWwpO1xuICAgICAgfTtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZG9tLm9ic2VydmUoZm9ybUVsZW1lbnRzW2ldLCBcImNoYW5nZVwiLCBfY2xlYXJJbnRlcnZhbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29ic2VydmVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR3JhYnMgYWxsIGZpZWxkcyBpbiB0aGUgZGlhbG9nIGFuZCBwdXRzIHRoZW0gaW4ga2V5PT52YWx1ZSBzdHlsZSBpbiBhbiBvYmplY3Qgd2hpY2hcbiAgICAgKiB0aGVuIGdldHMgcmV0dXJuZWRcbiAgICAgKi9cbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbiBfc2VyaWFsaXplKCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmVsZW1lbnRUb0NoYW5nZSB8fCB7fSxcbiAgICAgICAgICBmaWVsZHMgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0ZJRUxEUyksXG4gICAgICAgICAgbGVuZ3RoID0gZmllbGRzLmxlbmd0aCxcbiAgICAgICAgICBpID0gMDtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtmaWVsZHNbaV0uZ2V0QXR0cmlidXRlKEFUVFJJQlVURV9GSUVMRFMpXSA9IGZpZWxkc1tpXS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyB0aGUgYXR0cmlidXRlcyBvZiB0aGUgXCJlbGVtZW50VG9DaGFuZ2VcIlxuICAgICAqIGFuZCBpbnNlcnRzIHRoZW0gaW4gdGhlaXIgY29ycmVzcG9uZGluZyBkaWFsb2cgaW5wdXQgZmllbGRzXG4gICAgICogXG4gICAgICogQXNzdW1lIHRoZSBcImVsZW1lbnRUb0NoYW5nZVwiIGxvb2tzIGxpa2UgdGhpczpcbiAgICAgKiAgICA8YSBocmVmPVwiaHR0cDovL3d3dy5nb29nbGUuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+Zm9vPC9hPlxuICAgICAqXG4gICAgICogYW5kIHdlIGhhdmUgdGhlIGZvbGxvd2luZyBkaWFsb2c6XG4gICAgICogICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVwiaHJlZlwiIHZhbHVlPVwiXCI+XG4gICAgICogICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVwidGFyZ2V0XCIgdmFsdWU9XCJcIj5cbiAgICAgKiBcbiAgICAgKiBhZnRlciBjYWxsaW5nIF9pbnRlcnBvbGF0ZSgpIHRoZSBkaWFsb2cgd2lsbCBsb29rIGxpa2UgdGhpc1xuICAgICAqICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtd3lzaWh0bWw1LWRpYWxvZy1maWVsZD1cImhyZWZcIiB2YWx1ZT1cImh0dHA6Ly93d3cuZ29vZ2xlLmNvbVwiPlxuICAgICAqICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtd3lzaWh0bWw1LWRpYWxvZy1maWVsZD1cInRhcmdldFwiIHZhbHVlPVwiX2JsYW5rXCI+XG4gICAgICpcbiAgICAgKiBCYXNpY2FsbHkgaXQgYWRvcHRlZCB0aGUgYXR0cmlidXRlIHZhbHVlcyBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIGlucHV0IGZpZWxkc1xuICAgICAqXG4gICAgICovXG4gICAgX2ludGVycG9sYXRlOiBmdW5jdGlvbiBfaW50ZXJwb2xhdGUoYXZvaWRIaWRkZW5GaWVsZHMpIHtcbiAgICAgIHZhciBmaWVsZCxcbiAgICAgICAgICBmaWVsZE5hbWUsXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgZm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiOmZvY3VzXCIpLFxuICAgICAgICAgIGZpZWxkcyA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfRklFTERTKSxcbiAgICAgICAgICBsZW5ndGggPSBmaWVsZHMubGVuZ3RoLFxuICAgICAgICAgIGkgPSAwO1xuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBmaWVsZCA9IGZpZWxkc1tpXTtcblxuICAgICAgICAvLyBOZXZlciBjaGFuZ2UgZWxlbWVudHMgd2hlcmUgdGhlIHVzZXIgaXMgY3VycmVudGx5IHR5cGluZyBpblxuICAgICAgICBpZiAoZmllbGQgPT09IGZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb24ndCB1cGRhdGUgaGlkZGVuIGZpZWxkc1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3hpbmcvd3lzaWh0bWw1L3B1bGwvMTRcbiAgICAgICAgaWYgKGF2b2lkSGlkZGVuRmllbGRzICYmIGZpZWxkLnR5cGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkLmdldEF0dHJpYnV0ZShBVFRSSUJVVEVfRklFTERTKTtcbiAgICAgICAgbmV3VmFsdWUgPSB0aGlzLmVsZW1lbnRUb0NoYW5nZSA/IHRoaXMuZWxlbWVudFRvQ2hhbmdlW2ZpZWxkTmFtZV0gfHwgXCJcIiA6IGZpZWxkLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgZmllbGQudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgZGlhbG9nIGVsZW1lbnRcbiAgICAgKi9cbiAgICBzaG93OiBmdW5jdGlvbiBzaG93KGVsZW1lbnRUb0NoYW5nZSkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIGZpcnN0RmllbGQgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX0ZPUk1fRUxFTUVOVFMpO1xuICAgICAgdGhpcy5lbGVtZW50VG9DaGFuZ2UgPSBlbGVtZW50VG9DaGFuZ2U7XG4gICAgICB0aGlzLl9vYnNlcnZlKCk7XG4gICAgICB0aGlzLl9pbnRlcnBvbGF0ZSgpO1xuICAgICAgaWYgKGVsZW1lbnRUb0NoYW5nZSkge1xuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuX2ludGVycG9sYXRlKHRydWUpO1xuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgICAgZG9tLmFkZENsYXNzKHRoaXMubGluaywgQ0xBU1NfTkFNRV9PUEVORUQpO1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICB0aGlzLmZpcmUoXCJzaG93XCIpO1xuICAgICAgaWYgKGZpcnN0RmllbGQgJiYgIWVsZW1lbnRUb0NoYW5nZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZpcnN0RmllbGQuZm9jdXMoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgZGlhbG9nIGVsZW1lbnRcbiAgICAgKi9cbiAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgIHRoaXMuZWxlbWVudFRvQ2hhbmdlID0gbnVsbDtcbiAgICAgIGRvbS5yZW1vdmVDbGFzcyh0aGlzLmxpbmssIENMQVNTX05BTUVfT1BFTkVEKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIHRoaXMuZmlyZShcImhpZGVcIik7XG4gICAgfVxuICB9KTtcbn0pKHd5c2lodG1sNSk7XG4vKipcbiAqIENvbnZlcnRzIHNwZWVjaC10by10ZXh0IGFuZCBpbnNlcnRzIHRoaXMgaW50byB0aGUgZWRpdG9yXG4gKiBBcyBvZiBub3cgKDIwMTEvMDMvMjUpIHRoaXMgb25seSBpcyBzdXBwb3J0ZWQgaW4gQ2hyb21lID49IDExXG4gKlxuICogTm90ZSB0aGF0IGl0IHNlbmRzIHRoZSByZWNvcmRlZCBhdWRpbyB0byB0aGUgZ29vZ2xlIHNwZWVjaCByZWNvZ25pdGlvbiBhcGk6XG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQzNjE4MjYvZG9lcy1jaHJvbWUtaGF2ZS1idWlsLWluLXNwZWVjaC1yZWNvZ25pdGlvbi1mb3ItaW5wdXQtdHlwZS10ZXh0LXgtd2Via2l0LXNwZWVjXG4gKlxuICogQ3VycmVudCBIVE1MNSBkcmFmdCBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cDovL2xpc3RzLnczLm9yZy9BcmNoaXZlcy9QdWJsaWMvcHVibGljLXhnLWh0bWxzcGVlY2gvMjAxMUZlYi9hdHQtMDAyMC9hcGktZHJhZnQuaHRtbFxuICogXG4gKiBcIkFjY2Vzc2luZyBHb29nbGUgU3BlZWNoIEFQSSBDaHJvbWUgMTFcIlxuICogaHR0cDovL21pa2VwdWx0ei5jb20vMjAxMS8wMy9hY2Nlc3NpbmctZ29vZ2xlLXNwZWVjaC1hcGktY2hyb21lLTExL1xuICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgZG9tID0gd3lzaWh0bWw1LmRvbTtcblxuICB2YXIgbGlua1N0eWxlcyA9IHtcbiAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiXG4gIH07XG5cbiAgdmFyIHdyYXBwZXJTdHlsZXMgPSB7XG4gICAgbGVmdDogMCxcbiAgICBtYXJnaW46IDAsXG4gICAgb3BhY2l0eTogMCxcbiAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICBwYWRkaW5nOiAwLFxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgdG9wOiAwLFxuICAgIHpJbmRleDogMVxuICB9O1xuXG4gIHZhciBpbnB1dFN0eWxlcyA9IHtcbiAgICBjdXJzb3I6IFwiaW5oZXJpdFwiLFxuICAgIGZvbnRTaXplOiBcIjUwcHhcIixcbiAgICBoZWlnaHQ6IFwiNTBweFwiLFxuICAgIG1hcmdpblRvcDogXCItMjVweFwiLFxuICAgIG91dGxpbmU6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIHJpZ2h0OiBcIi00cHhcIixcbiAgICB0b3A6IFwiNTAlXCJcbiAgfTtcblxuICB2YXIgaW5wdXRBdHRyaWJ1dGVzID0ge1xuICAgIFwieC13ZWJraXQtc3BlZWNoXCI6IFwiXCIsXG4gICAgXCJzcGVlY2hcIjogXCJcIlxuICB9O1xuXG4gIHd5c2lodG1sNS50b29sYmFyLlNwZWVjaCA9IGZ1bmN0aW9uIChwYXJlbnQsIGxpbmspIHtcbiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c1NwZWVjaEFwaU9uKGlucHV0KSkge1xuICAgICAgbGluay5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgd3lzaWh0bWw1Lmxhbmcub2JqZWN0KHdyYXBwZXJTdHlsZXMpLm1lcmdlKHtcbiAgICAgIHdpZHRoOiBsaW5rLm9mZnNldFdpZHRoICsgXCJweFwiLFxuICAgICAgaGVpZ2h0OiBsaW5rLm9mZnNldEhlaWdodCArIFwicHhcIlxuICAgIH0pO1xuXG4gICAgZG9tLmluc2VydChpbnB1dCkuaW50byh3cmFwcGVyKTtcbiAgICBkb20uaW5zZXJ0KHdyYXBwZXIpLmludG8obGluayk7XG5cbiAgICBkb20uc2V0U3R5bGVzKGlucHV0U3R5bGVzKS5vbihpbnB1dCk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZXMoaW5wdXRBdHRyaWJ1dGVzKS5vbihpbnB1dCk7XG5cbiAgICBkb20uc2V0U3R5bGVzKHdyYXBwZXJTdHlsZXMpLm9uKHdyYXBwZXIpO1xuICAgIGRvbS5zZXRTdHlsZXMobGlua1N0eWxlcykub24obGluayk7XG5cbiAgICB2YXIgZXZlbnROYW1lID0gXCJvbndlYmtpdHNwZWVjaGNoYW5nZVwiIGluIGlucHV0ID8gXCJ3ZWJraXRzcGVlY2hjaGFuZ2VcIiA6IFwic3BlZWNoY2hhbmdlXCI7XG4gICAgZG9tLm9ic2VydmUoaW5wdXQsIGV2ZW50TmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgcGFyZW50LmV4ZWNDb21tYW5kKFwiaW5zZXJ0VGV4dFwiLCBpbnB1dC52YWx1ZSk7XG4gICAgICBpbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgfSk7XG5cbiAgICBkb20ub2JzZXJ2ZShpbnB1dCwgXCJjbGlja1wiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChkb20uaGFzQ2xhc3MobGluaywgXCJ3eXNpaHRtbDUtY29tbWFuZC1kaXNhYmxlZFwiKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcbiAgfTtcbn0pKHd5c2lodG1sNSk7IC8qKlxuICAgICAgICAgICAgICAgKiBUb29sYmFyXG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgUmVmZXJlbmNlIHRvIGluc3RhbmNlIG9mIEVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciBSZWZlcmVuY2UgdG8gdGhlIHRvb2xiYXIgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICogICAgPGRpdiBpZD1cInRvb2xiYXJcIj5cbiAgICAgICAgICAgICAgICogICAgICA8YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPVwiY3JlYXRlTGlua1wiPmluc2VydCBsaW5rPC9hPlxuICAgICAgICAgICAgICAgKiAgICAgIDxhIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XCJmb3JtYXRCbG9ja1wiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XCJoMVwiPmluc2VydCBoMTwvYT5cbiAgICAgICAgICAgICAgICogICAgPC9kaXY+XG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqICAgIDxzY3JpcHQ+XG4gICAgICAgICAgICAgICAqICAgICAgdmFyIHRvb2xiYXIgPSBuZXcgd3lzaWh0bWw1LnRvb2xiYXIuVG9vbGJhcihlZGl0b3IsIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidG9vbGJhclwiKSk7XG4gICAgICAgICAgICAgICAqICAgIDwvc2NyaXB0PlxuICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciBDTEFTU19OQU1FX0NPTU1BTkRfRElTQUJMRUQgPSBcInd5c2lodG1sNS1jb21tYW5kLWRpc2FibGVkXCIsXG4gICAgICBDTEFTU19OQU1FX0NPTU1BTkRTX0RJU0FCTEVEID0gXCJ3eXNpaHRtbDUtY29tbWFuZHMtZGlzYWJsZWRcIixcbiAgICAgIENMQVNTX05BTUVfQ09NTUFORF9BQ1RJVkUgPSBcInd5c2lodG1sNS1jb21tYW5kLWFjdGl2ZVwiLFxuICAgICAgQ0xBU1NfTkFNRV9BQ1RJT05fQUNUSVZFID0gXCJ3eXNpaHRtbDUtYWN0aW9uLWFjdGl2ZVwiLFxuICAgICAgZG9tID0gd3lzaWh0bWw1LmRvbTtcblxuICB3eXNpaHRtbDUudG9vbGJhci5Ub29sYmFyID0gQmFzZS5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LnRvb2xiYXIuVG9vbGJhci5wcm90b3R5cGUgKi97XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKGVkaXRvciwgY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gdHlwZW9mIGNvbnRhaW5lciA9PT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRhaW5lcikgOiBjb250YWluZXI7XG4gICAgICB0aGlzLmNvbXBvc2VyID0gZWRpdG9yLmNvbXBvc2VyO1xuXG4gICAgICB0aGlzLl9nZXRMaW5rcyhcImNvbW1hbmRcIik7XG4gICAgICB0aGlzLl9nZXRMaW5rcyhcImFjdGlvblwiKTtcblxuICAgICAgdGhpcy5fb2JzZXJ2ZSgpO1xuICAgICAgdGhpcy5zaG93KCk7XG5cbiAgICAgIHZhciBzcGVlY2hJbnB1dExpbmtzID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLXd5c2lodG1sNS1jb21tYW5kPWluc2VydFNwZWVjaF1cIiksXG4gICAgICAgICAgbGVuZ3RoID0gc3BlZWNoSW5wdXRMaW5rcy5sZW5ndGgsXG4gICAgICAgICAgaSA9IDA7XG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ldyB3eXNpaHRtbDUudG9vbGJhci5TcGVlY2godGhpcywgc3BlZWNoSW5wdXRMaW5rc1tpXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9nZXRMaW5rczogZnVuY3Rpb24gX2dldExpbmtzKHR5cGUpIHtcbiAgICAgIHZhciBsaW5rcyA9IHRoaXNbdHlwZSArIFwiTGlua3NcIl0gPSB3eXNpaHRtbDUubGFuZy5hcnJheSh0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtd3lzaWh0bWw1LVwiICsgdHlwZSArIFwiXVwiKSkuZ2V0KCksXG4gICAgICAgICAgbGVuZ3RoID0gbGlua3MubGVuZ3RoLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzW3R5cGUgKyBcIk1hcHBpbmdcIl0gPSB7fSxcbiAgICAgICAgICBsaW5rLFxuICAgICAgICAgIGdyb3VwLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZGlhbG9nO1xuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBsaW5rID0gbGlua3NbaV07XG4gICAgICAgIG5hbWUgPSBsaW5rLmdldEF0dHJpYnV0ZShcImRhdGEtd3lzaWh0bWw1LVwiICsgdHlwZSk7XG4gICAgICAgIHZhbHVlID0gbGluay5nZXRBdHRyaWJ1dGUoXCJkYXRhLXd5c2lodG1sNS1cIiArIHR5cGUgKyBcIi12YWx1ZVwiKTtcbiAgICAgICAgZ3JvdXAgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtd3lzaWh0bWw1LVwiICsgdHlwZSArIFwiLWdyb3VwPSdcIiArIG5hbWUgKyBcIiddXCIpO1xuICAgICAgICBkaWFsb2cgPSB0aGlzLl9nZXREaWFsb2cobGluaywgbmFtZSk7XG5cbiAgICAgICAgbWFwcGluZ1tuYW1lICsgXCI6XCIgKyB2YWx1ZV0gPSB7XG4gICAgICAgICAgbGluazogbGluayxcbiAgICAgICAgICBncm91cDogZ3JvdXAsXG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgZGlhbG9nOiBkaWFsb2csXG4gICAgICAgICAgc3RhdGU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9nZXREaWFsb2c6IGZ1bmN0aW9uIF9nZXREaWFsb2cobGluaywgY29tbWFuZCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIGRpYWxvZ0VsZW1lbnQgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtd3lzaWh0bWw1LWRpYWxvZz0nXCIgKyBjb21tYW5kICsgXCInXVwiKSxcbiAgICAgICAgICBkaWFsb2csXG4gICAgICAgICAgY2FyZXRCb29rbWFyaztcblxuICAgICAgaWYgKGRpYWxvZ0VsZW1lbnQpIHtcbiAgICAgICAgZGlhbG9nID0gbmV3IHd5c2lodG1sNS50b29sYmFyLkRpYWxvZyhsaW5rLCBkaWFsb2dFbGVtZW50KTtcblxuICAgICAgICBkaWFsb2cub2JzZXJ2ZShcInNob3dcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhcmV0Qm9va21hcmsgPSB0aGF0LmNvbXBvc2VyLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuXG4gICAgICAgICAgdGhhdC5lZGl0b3IuZmlyZShcInNob3c6ZGlhbG9nXCIsIHsgY29tbWFuZDogY29tbWFuZCwgZGlhbG9nQ29udGFpbmVyOiBkaWFsb2dFbGVtZW50LCBjb21tYW5kTGluazogbGluayB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGlhbG9nLm9ic2VydmUoXCJzYXZlXCIsIGZ1bmN0aW9uIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgaWYgKGNhcmV0Qm9va21hcmspIHtcbiAgICAgICAgICAgIHRoYXQuY29tcG9zZXIuc2VsZWN0aW9uLnNldEJvb2ttYXJrKGNhcmV0Qm9va21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGF0Ll9leGVjQ29tbWFuZChjb21tYW5kLCBhdHRyaWJ1dGVzKTtcblxuICAgICAgICAgIHRoYXQuZWRpdG9yLmZpcmUoXCJzYXZlOmRpYWxvZ1wiLCB7IGNvbW1hbmQ6IGNvbW1hbmQsIGRpYWxvZ0NvbnRhaW5lcjogZGlhbG9nRWxlbWVudCwgY29tbWFuZExpbms6IGxpbmsgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRpYWxvZy5vYnNlcnZlKFwiY2FuY2VsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LmVkaXRvci5mb2N1cyhmYWxzZSk7XG4gICAgICAgICAgdGhhdC5lZGl0b3IuZmlyZShcImNhbmNlbDpkaWFsb2dcIiwgeyBjb21tYW5kOiBjb21tYW5kLCBkaWFsb2dDb250YWluZXI6IGRpYWxvZ0VsZW1lbnQsIGNvbW1hbmRMaW5rOiBsaW5rIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaWFsb2c7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgdmFyIHRvb2xiYXIgPSBuZXcgd3lzaWh0bWw1LlRvb2xiYXIoKTtcbiAgICAgKiAgICAvLyBJbnNlcnQgYSA8YmxvY2txdW90ZT4gZWxlbWVudCBvciB3cmFwIGN1cnJlbnQgc2VsZWN0aW9uIGluIDxibG9ja3F1b3RlPlxuICAgICAqICAgIHRvb2xiYXIuZXhlY0NvbW1hbmQoXCJmb3JtYXRCbG9ja1wiLCBcImJsb2NrcXVvdGVcIik7XG4gICAgICovXG4gICAgZXhlY0NvbW1hbmQ6IGZ1bmN0aW9uIGV4ZWNDb21tYW5kKGNvbW1hbmQsIGNvbW1hbmRWYWx1ZSkge1xuICAgICAgaWYgKHRoaXMuY29tbWFuZHNEaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21tYW5kT2JqID0gdGhpcy5jb21tYW5kTWFwcGluZ1tjb21tYW5kICsgXCI6XCIgKyBjb21tYW5kVmFsdWVdO1xuXG4gICAgICAvLyBTaG93IGRpYWxvZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgaWYgKGNvbW1hbmRPYmogJiYgY29tbWFuZE9iai5kaWFsb2cgJiYgIWNvbW1hbmRPYmouc3RhdGUpIHtcbiAgICAgICAgY29tbWFuZE9iai5kaWFsb2cuc2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXhlY0NvbW1hbmQoY29tbWFuZCwgY29tbWFuZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2V4ZWNDb21tYW5kOiBmdW5jdGlvbiBfZXhlY0NvbW1hbmQoY29tbWFuZCwgY29tbWFuZFZhbHVlKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCBjb21wb3NlciBpcyBmb2N1c3NlZCAoZmFsc2UgPT4gZG9uJ3QgbW92ZSBjYXJldCB0byB0aGUgZW5kKVxuICAgICAgdGhpcy5lZGl0b3IuZm9jdXMoZmFsc2UpO1xuXG4gICAgICB0aGlzLmNvbXBvc2VyLmNvbW1hbmRzLmV4ZWMoY29tbWFuZCwgY29tbWFuZFZhbHVlKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUxpbmtTdGF0ZXMoKTtcbiAgICB9LFxuXG4gICAgZXhlY0FjdGlvbjogZnVuY3Rpb24gZXhlY0FjdGlvbihhY3Rpb24pIHtcbiAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJjaGFuZ2Vfdmlld1wiOlxuICAgICAgICAgIGlmIChlZGl0b3IuY3VycmVudFZpZXcgPT09IGVkaXRvci50ZXh0YXJlYSkge1xuICAgICAgICAgICAgZWRpdG9yLmZpcmUoXCJjaGFuZ2Vfdmlld1wiLCBcImNvbXBvc2VyXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZGl0b3IuZmlyZShcImNoYW5nZV92aWV3XCIsIFwidGV4dGFyZWFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfb2JzZXJ2ZTogZnVuY3Rpb24gX29ic2VydmUoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgZWRpdG9yID0gdGhpcy5lZGl0b3IsXG4gICAgICAgICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgbGlua3MgPSB0aGlzLmNvbW1hbmRMaW5rcy5jb25jYXQodGhpcy5hY3Rpb25MaW5rcyksXG4gICAgICAgICAgbGVuZ3RoID0gbGlua3MubGVuZ3RoLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vICdqYXZhc2NyaXB0OjsnIGFuZCB1bnNlbGVjdGFibGU9b24gTmVlZGVkIGZvciBJRSwgYnV0IGRvbmUgaW4gYWxsIGJyb3dzZXJzIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBnZXQgdGhlIHNhbWUgY3NzIGFwcGxpZWRcbiAgICAgICAgLy8gKHlvdSBrbm93LCBhOmxpbmsgeyAuLi4gfSBkb2Vzbid0IG1hdGNoIGFuY2hvcnMgd2l0aCBtaXNzaW5nIGhyZWYgYXR0cmlidXRlKVxuICAgICAgICBkb20uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgaHJlZjogXCJqYXZhc2NyaXB0OjtcIixcbiAgICAgICAgICB1bnNlbGVjdGFibGU6IFwib25cIlxuICAgICAgICB9KS5vbihsaW5rc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5lZWRlZCBmb3Igb3BlcmFcbiAgICAgIGRvbS5kZWxlZ2F0ZShjb250YWluZXIsIFwiW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmRdXCIsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGRvbS5kZWxlZ2F0ZShjb250YWluZXIsIFwiW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmRdXCIsIFwiY2xpY2tcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcyxcbiAgICAgICAgICAgIGNvbW1hbmQgPSBsaW5rLmdldEF0dHJpYnV0ZShcImRhdGEtd3lzaWh0bWw1LWNvbW1hbmRcIiksXG4gICAgICAgICAgICBjb21tYW5kVmFsdWUgPSBsaW5rLmdldEF0dHJpYnV0ZShcImRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWVcIik7XG4gICAgICAgIHRoYXQuZXhlY0NvbW1hbmQoY29tbWFuZCwgY29tbWFuZFZhbHVlKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBkb20uZGVsZWdhdGUoY29udGFpbmVyLCBcIltkYXRhLXd5c2lodG1sNS1hY3Rpb25dXCIsIFwiY2xpY2tcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtd3lzaWh0bWw1LWFjdGlvblwiKTtcbiAgICAgICAgdGhhdC5leGVjQWN0aW9uKGFjdGlvbik7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcblxuICAgICAgZWRpdG9yLm9ic2VydmUoXCJmb2N1czpjb21wb3NlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQuYm9va21hcmsgPSBudWxsO1xuICAgICAgICBjbGVhckludGVydmFsKHRoYXQuaW50ZXJ2YWwpO1xuICAgICAgICB0aGF0LmludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuX3VwZGF0ZUxpbmtTdGF0ZXMoKTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBlZGl0b3Iub2JzZXJ2ZShcImJsdXI6Y29tcG9zZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoYXQuaW50ZXJ2YWwpO1xuICAgICAgfSk7XG5cbiAgICAgIGVkaXRvci5vYnNlcnZlKFwiZGVzdHJveTpjb21wb3NlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhhdC5pbnRlcnZhbCk7XG4gICAgICB9KTtcblxuICAgICAgZWRpdG9yLm9ic2VydmUoXCJjaGFuZ2Vfdmlld1wiLCBmdW5jdGlvbiAoY3VycmVudFZpZXcpIHtcbiAgICAgICAgLy8gU2V0IHRpbWVvdXQgbmVlZGVkIGluIG9yZGVyIHRvIGxldCB0aGUgYmx1ciBldmVudCBmaXJlIGZpcnN0XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuY29tbWFuZHNEaXNhYmxlZCA9IGN1cnJlbnRWaWV3ICE9PSBcImNvbXBvc2VyXCI7XG4gICAgICAgICAgdGhhdC5fdXBkYXRlTGlua1N0YXRlcygpO1xuICAgICAgICAgIGlmICh0aGF0LmNvbW1hbmRzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhjb250YWluZXIsIENMQVNTX05BTUVfQ09NTUFORFNfRElTQUJMRUQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBDTEFTU19OQU1FX0NPTU1BTkRTX0RJU0FCTEVEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF91cGRhdGVMaW5rU3RhdGVzOiBmdW5jdGlvbiBfdXBkYXRlTGlua1N0YXRlcygpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb21wb3Nlci5lbGVtZW50LFxuICAgICAgICAgIGNvbW1hbmRNYXBwaW5nID0gdGhpcy5jb21tYW5kTWFwcGluZyxcbiAgICAgICAgICBhY3Rpb25NYXBwaW5nID0gdGhpcy5hY3Rpb25NYXBwaW5nLFxuICAgICAgICAgIGksXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIGNvbW1hbmQ7XG4gICAgICAvLyBldmVyeSBtaWxsaXNlY29uZCBjb3VudHMuLi4gdGhpcyBpcyBleGVjdXRlZCBxdWl0ZSBvZnRlblxuICAgICAgZm9yIChpIGluIGNvbW1hbmRNYXBwaW5nKSB7XG4gICAgICAgIGNvbW1hbmQgPSBjb21tYW5kTWFwcGluZ1tpXTtcbiAgICAgICAgaWYgKHRoaXMuY29tbWFuZHNEaXNhYmxlZCkge1xuICAgICAgICAgIHN0YXRlID0gZmFsc2U7XG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbW1hbmQubGluaywgQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSk7XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZ3JvdXApIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb21tYW5kLmdyb3VwLCBDTEFTU19OQU1FX0NPTU1BTkRfQUNUSVZFKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZGlhbG9nKSB7XG4gICAgICAgICAgICBjb21tYW5kLmRpYWxvZy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gdGhpcy5jb21wb3Nlci5jb21tYW5kcy5zdGF0ZShjb21tYW5kLm5hbWUsIGNvbW1hbmQudmFsdWUpO1xuICAgICAgICAgIGlmICh3eXNpaHRtbDUubGFuZy5vYmplY3Qoc3RhdGUpLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgLy8gR3JhYiBmaXJzdCBhbmQgb25seSBvYmplY3QvZWxlbWVudCBpbiBzdGF0ZSBhcnJheSwgb3RoZXJ3aXNlIGNvbnZlcnQgc3RhdGUgaW50byBib29sZWFuXG4gICAgICAgICAgICAvLyB0byBhdm9pZCBzaG93aW5nIGEgZGlhbG9nIGZvciBtdWx0aXBsZSBzZWxlY3RlZCBlbGVtZW50cyB3aGljaCBtYXkgaGF2ZSBkaWZmZXJlbnQgYXR0cmlidXRlc1xuICAgICAgICAgICAgLy8gZWcuIHdoZW4gdHdvIGxpbmtzIHdpdGggZGlmZmVyZW50IGhyZWYgYXJlIHNlbGVjdGVkLCB0aGUgc3RhdGUgd2lsbCBiZSBhbiBhcnJheSBjb25zaXN0aW5nIG9mIGJvdGggbGluayBlbGVtZW50c1xuICAgICAgICAgICAgLy8gYnV0IHRoZSBkaWFsb2cgaW50ZXJmYWNlIGNhbiBvbmx5IHVwZGF0ZSBvbmVcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUubGVuZ3RoID09PSAxID8gc3RhdGVbMF0gOiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29tbWFuZC5saW5rLCBDTEFTU19OQU1FX0NPTU1BTkRfRElTQUJMRUQpO1xuICAgICAgICAgIGlmIChjb21tYW5kLmdyb3VwKSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29tbWFuZC5ncm91cCwgQ0xBU1NfTkFNRV9DT01NQU5EX0RJU0FCTEVEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbWFuZC5zdGF0ZSA9PT0gc3RhdGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbW1hbmQuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKGNvbW1hbmQubGluaywgQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSk7XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZ3JvdXApIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhjb21tYW5kLmdyb3VwLCBDTEFTU19OQU1FX0NPTU1BTkRfQUNUSVZFKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZGlhbG9nKSB7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBzdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHN0YXRlKSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgY29tbWFuZC5kaWFsb2cuc2hvdyhzdGF0ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb21tYW5kLmRpYWxvZy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb21tYW5kLmxpbmssIENMQVNTX05BTUVfQ09NTUFORF9BQ1RJVkUpO1xuICAgICAgICAgIGlmIChjb21tYW5kLmdyb3VwKSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29tbWFuZC5ncm91cCwgQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb21tYW5kLmRpYWxvZykge1xuICAgICAgICAgICAgY29tbWFuZC5kaWFsb2cuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgaW4gYWN0aW9uTWFwcGluZykge1xuICAgICAgICBhY3Rpb24gPSBhY3Rpb25NYXBwaW5nW2ldO1xuXG4gICAgICAgIGlmIChhY3Rpb24ubmFtZSA9PT0gXCJjaGFuZ2Vfdmlld1wiKSB7XG4gICAgICAgICAgYWN0aW9uLnN0YXRlID0gdGhpcy5lZGl0b3IuY3VycmVudFZpZXcgPT09IHRoaXMuZWRpdG9yLnRleHRhcmVhO1xuICAgICAgICAgIGlmIChhY3Rpb24uc3RhdGUpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhhY3Rpb24ubGluaywgQ0xBU1NfTkFNRV9BQ1RJT05fQUNUSVZFKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGFjdGlvbi5saW5rLCBDTEFTU19OQU1FX0FDVElPTl9BQ1RJVkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxuICB9KTtcbn0pKHd5c2lodG1sNSk7XG4vKipcbiAqIFdZU0lIVE1MNSBFZGl0b3JcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRleHRhcmVhRWxlbWVudCBSZWZlcmVuY2UgdG8gdGhlIHRleHRhcmVhIHdoaWNoIHNob3VsZCBiZSB0dXJuZWQgaW50byBhIHJpY2ggdGV4dCBpbnRlcmZhY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBTZWUgZGVmYXVsdENvbmZpZyBvYmplY3QgYmVsb3cgZm9yIGV4cGxhbmF0aW9uIG9mIGVhY2ggaW5kaXZpZHVhbCBjb25maWcgb3B0aW9uXG4gKlxuICogQGV2ZW50c1xuICogICAgbG9hZFxuICogICAgYmVmb3JlbG9hZCAoZm9yIGludGVybmFsIHVzZSBvbmx5KVxuICogICAgZm9jdXNcbiAqICAgIGZvY3VzOmNvbXBvc2VyXG4gKiAgICBmb2N1czp0ZXh0YXJlYVxuICogICAgYmx1clxuICogICAgYmx1cjpjb21wb3NlclxuICogICAgYmx1cjp0ZXh0YXJlYVxuICogICAgY2hhbmdlXG4gKiAgICBjaGFuZ2U6Y29tcG9zZXJcbiAqICAgIGNoYW5nZTp0ZXh0YXJlYVxuICogICAgcGFzdGVcbiAqICAgIHBhc3RlOmNvbXBvc2VyXG4gKiAgICBwYXN0ZTp0ZXh0YXJlYVxuICogICAgbmV3d29yZDpjb21wb3NlclxuICogICAgZGVzdHJveTpjb21wb3NlclxuICogICAgdW5kbzpjb21wb3NlclxuICogICAgcmVkbzpjb21wb3NlclxuICogICAgYmVmb3JlY29tbWFuZDpjb21wb3NlclxuICogICAgYWZ0ZXJjb21tYW5kOmNvbXBvc2VyXG4gKiAgICBjaGFuZ2Vfdmlld1xuICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWY7XG5cbiAgdmFyIGRlZmF1bHRDb25maWcgPSB7XG4gICAgLy8gR2l2ZSB0aGUgZWRpdG9yIGEgbmFtZSwgdGhlIG5hbWUgd2lsbCBhbHNvIGJlIHNldCBhcyBjbGFzcyBuYW1lIG9uIHRoZSBpZnJhbWUgYW5kIG9uIHRoZSBpZnJhbWUncyBib2R5IFxuICAgIG5hbWU6IHVuZGVmLFxuICAgIC8vIFdoZXRoZXIgdGhlIGVkaXRvciBzaG91bGQgbG9vayBsaWtlIHRoZSB0ZXh0YXJlYSAoYnkgYWRvcHRpbmcgc3R5bGVzKVxuICAgIHN0eWxlOiB0cnVlLFxuICAgIC8vIElkIG9mIHRoZSB0b29sYmFyIGVsZW1lbnQsIHBhc3MgZmFsc2V5IHZhbHVlIGlmIHlvdSBkb24ndCB3YW50IGFueSB0b29sYmFyIGxvZ2ljXG4gICAgdG9vbGJhcjogdW5kZWYsXG4gICAgLy8gV2hldGhlciB1cmxzLCBlbnRlcmVkIGJ5IHRoZSB1c2VyIHNob3VsZCBhdXRvbWF0aWNhbGx5IGJlY29tZSBjbGlja2FibGUtbGlua3NcbiAgICBhdXRvTGluazogdHJ1ZSxcbiAgICAvLyBPYmplY3Qgd2hpY2ggaW5jbHVkZXMgcGFyc2VyIHJ1bGVzIHRvIGFwcGx5IHdoZW4gaHRtbCBnZXRzIGluc2VydGVkIHZpYSBjb3B5ICYgcGFzdGVcbiAgICAvLyBTZWUgcGFyc2VyX3J1bGVzLyouanMgZm9yIGV4YW1wbGVzXG4gICAgcGFyc2VyUnVsZXM6IHsgdGFnczogeyBicjoge30sIHNwYW46IHt9LCBkaXY6IHt9LCBwOiB7fSB9LCBjbGFzc2VzOiB7fSB9LFxuICAgIC8vIFBhcnNlciBtZXRob2QgdG8gdXNlIHdoZW4gdGhlIHVzZXIgaW5zZXJ0cyBjb250ZW50IHZpYSBjb3B5ICYgcGFzdGVcbiAgICBwYXJzZXI6IHd5c2lodG1sNS5kb20ucGFyc2UsXG4gICAgLy8gQ2xhc3MgbmFtZSB3aGljaCBzaG91bGQgYmUgc2V0IG9uIHRoZSBjb250ZW50RWRpdGFibGUgZWxlbWVudCBpbiB0aGUgY3JlYXRlZCBzYW5kYm94IGlmcmFtZSwgY2FuIGJlIHN0eWxlZCB2aWEgdGhlICdzdHlsZXNoZWV0cycgb3B0aW9uXG4gICAgY29tcG9zZXJDbGFzc05hbWU6IFwid3lzaWh0bWw1LWVkaXRvclwiLFxuICAgIC8vIENsYXNzIG5hbWUgdG8gYWRkIHRvIHRoZSBib2R5IHdoZW4gdGhlIHd5c2lodG1sNSBlZGl0b3IgaXMgc3VwcG9ydGVkXG4gICAgYm9keUNsYXNzTmFtZTogXCJ3eXNpaHRtbDUtc3VwcG9ydGVkXCIsXG4gICAgLy8gQXJyYXkgKG9yIHNpbmdsZSBzdHJpbmcpIG9mIHN0eWxlc2hlZXQgdXJscyB0byBiZSBsb2FkZWQgaW4gdGhlIGVkaXRvcidzIGlmcmFtZVxuICAgIHN0eWxlc2hlZXRzOiBbXSxcbiAgICAvLyBQbGFjZWhvbGRlciB0ZXh0IHRvIHVzZSwgZGVmYXVsdHMgdG8gdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZSBvbiB0aGUgdGV4dGFyZWEgZWxlbWVudFxuICAgIHBsYWNlaG9sZGVyVGV4dDogdW5kZWYsXG4gICAgLy8gV2hldGhlciB0aGUgY29tcG9zZXIgc2hvdWxkIGFsbG93IHRoZSB1c2VyIHRvIG1hbnVhbGx5IHJlc2l6ZSBpbWFnZXMsIHRhYmxlcyBldGMuXG4gICAgYWxsb3dPYmplY3RSZXNpemluZzogdHJ1ZSxcbiAgICAvLyBXaGV0aGVyIHRoZSByaWNoIHRleHQgZWRpdG9yIHNob3VsZCBiZSByZW5kZXJlZCBvbiB0b3VjaCBkZXZpY2VzICh3eXNpaHRtbDUgPj0gMC4zLjAgY29tZXMgd2l0aCBiYXNpYyBzdXBwb3J0IGZvciBpT1MgNSlcbiAgICBzdXBwb3J0VG91Y2hEZXZpY2VzOiB0cnVlXG4gIH07XG5cbiAgd3lzaWh0bWw1LkVkaXRvciA9IHd5c2lodG1sNS5sYW5nLkRpc3BhdGNoZXIuZXh0ZW5kKFxuICAvKiogQHNjb3BlIHd5c2lodG1sNS5FZGl0b3IucHJvdG90eXBlICove1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBjb25zdHJ1Y3Rvcih0ZXh0YXJlYUVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgdGhpcy50ZXh0YXJlYUVsZW1lbnQgPSB0eXBlb2YgdGV4dGFyZWFFbGVtZW50ID09PSBcInN0cmluZ1wiID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGV4dGFyZWFFbGVtZW50KSA6IHRleHRhcmVhRWxlbWVudDtcbiAgICAgIHRoaXMuY29uZmlnID0gd3lzaWh0bWw1Lmxhbmcub2JqZWN0KHt9KS5tZXJnZShkZWZhdWx0Q29uZmlnKS5tZXJnZShjb25maWcpLmdldCgpO1xuICAgICAgdGhpcy50ZXh0YXJlYSA9IG5ldyB3eXNpaHRtbDUudmlld3MuVGV4dGFyZWEodGhpcywgdGhpcy50ZXh0YXJlYUVsZW1lbnQsIHRoaXMuY29uZmlnKTtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcgPSB0aGlzLnRleHRhcmVhO1xuICAgICAgdGhpcy5faXNDb21wYXRpYmxlID0gd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydGVkKCk7XG5cbiAgICAgIC8vIFNvcnQgb3V0IHVuc3VwcG9ydGVkL3Vud2FudGVkIGJyb3dzZXJzIGhlcmVcbiAgICAgIGlmICghdGhpcy5faXNDb21wYXRpYmxlIHx8ICF0aGlzLmNvbmZpZy5zdXBwb3J0VG91Y2hEZXZpY2VzICYmIHd5c2lodG1sNS5icm93c2VyLmlzVG91Y2hEZXZpY2UoKSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuZmlyZShcImJlZm9yZWxvYWRcIikuZmlyZShcImxvYWRcIik7XG4gICAgICAgIH0sIDApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBjbGFzcyBuYW1lIHRvIGJvZHksIHRvIGluZGljYXRlIHRoYXQgdGhlIGVkaXRvciBpcyBzdXBwb3J0ZWRcbiAgICAgIHd5c2lodG1sNS5kb20uYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgdGhpcy5jb25maWcuYm9keUNsYXNzTmFtZSk7XG5cbiAgICAgIHRoaXMuY29tcG9zZXIgPSBuZXcgd3lzaWh0bWw1LnZpZXdzLkNvbXBvc2VyKHRoaXMsIHRoaXMudGV4dGFyZWFFbGVtZW50LCB0aGlzLmNvbmZpZyk7XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gdGhpcy5jb21wb3NlcjtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZy5wYXJzZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLl9pbml0UGFyc2VyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub2JzZXJ2ZShcImJlZm9yZWxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplciA9IG5ldyB3eXNpaHRtbDUudmlld3MuU3luY2hyb25pemVyKHRoaXMsIHRoaXMudGV4dGFyZWEsIHRoaXMuY29tcG9zZXIpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcudG9vbGJhcikge1xuICAgICAgICAgIHRoaXMudG9vbGJhciA9IG5ldyB3eXNpaHRtbDUudG9vbGJhci5Ub29sYmFyKHRoaXMsIHRoaXMuY29uZmlnLnRvb2xiYXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJIZXlhISBUaGlzIHBhZ2UgaXMgdXNpbmcgd3lzaWh0bWw1IGZvciByaWNoIHRleHQgZWRpdGluZy4gQ2hlY2sgb3V0IGh0dHBzOi8vZ2l0aHViLmNvbS94aW5nL3d5c2lodG1sNVwiKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSxcblxuICAgIGlzQ29tcGF0aWJsZTogZnVuY3Rpb24gaXNDb21wYXRpYmxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzQ29tcGF0aWJsZTtcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5jdXJyZW50Vmlldy5jbGVhcigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShwYXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFZpZXcuZ2V0VmFsdWUocGFyc2UpO1xuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUoaHRtbCwgcGFyc2UpIHtcbiAgICAgIGlmICghaHRtbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGVhcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50Vmlldy5zZXRWYWx1ZShodG1sLCBwYXJzZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKHNldFRvRW5kKSB7XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3LmZvY3VzKHNldFRvRW5kKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRlIGVkaXRvciAobWFrZSBpdCByZWFkb25seSlcbiAgICAgKi9cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgdGhpcy5jdXJyZW50Vmlldy5kaXNhYmxlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGUgZWRpdG9yXG4gICAgICovXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3LmVuYWJsZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50Vmlldy5pc0VtcHR5KCk7XG4gICAgfSxcblxuICAgIGhhc1BsYWNlaG9sZGVyU2V0OiBmdW5jdGlvbiBoYXNQbGFjZWhvbGRlclNldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWaWV3Lmhhc1BsYWNlaG9sZGVyU2V0KCk7XG4gICAgfSxcblxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShodG1sT3JFbGVtZW50KSB7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSB0aGlzLmNvbmZpZy5wYXJzZXIoaHRtbE9yRWxlbWVudCwgdGhpcy5jb25maWcucGFyc2VyUnVsZXMsIHRoaXMuY29tcG9zZXIuc2FuZGJveC5nZXREb2N1bWVudCgpLCB0cnVlKTtcbiAgICAgIGlmICgodHlwZW9mIGh0bWxPckVsZW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihodG1sT3JFbGVtZW50KSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcoaHRtbE9yRWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgaHRtbCBwYXJzZXIgbG9naWNcbiAgICAgKiAgLSBPYnNlcnZlcyBmb3IgcGFzdGUgYW5kIGRyb3BcbiAgICAgKi9cbiAgICBfaW5pdFBhcnNlcjogZnVuY3Rpb24gX2luaXRQYXJzZXIoKSB7XG4gICAgICB0aGlzLm9ic2VydmUoXCJwYXN0ZTpjb21wb3NlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrZWVwU2Nyb2xsUG9zaXRpb24gPSB0cnVlLFxuICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoYXQuY29tcG9zZXIuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3eXNpaHRtbDUucXVpcmtzLmNsZWFuUGFzdGVkSFRNTCh0aGF0LmNvbXBvc2VyLmVsZW1lbnQpO1xuICAgICAgICAgIHRoYXQucGFyc2UodGhhdC5jb21wb3Nlci5lbGVtZW50KTtcbiAgICAgICAgfSwga2VlcFNjcm9sbFBvc2l0aW9uKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm9ic2VydmUoXCJwYXN0ZTp0ZXh0YXJlYVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudGV4dGFyZWEuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgIG5ld1ZhbHVlO1xuICAgICAgICBuZXdWYWx1ZSA9IHRoaXMucGFyc2UodmFsdWUpO1xuICAgICAgICB0aGlzLnRleHRhcmVhLnNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59KSh3eXNpaHRtbDUpO1xuLyoqXG5Cb290c3RyYXAgd3lzaWh0bWw1IGVkaXRvci4gQmFzZWQgb24gW2Jvb3RzdHJhcC13eXNpaHRtbDVdKGh0dHBzOi8vZ2l0aHViLmNvbS9qaG9sbGluZ3dvcnRoL2Jvb3RzdHJhcC13eXNpaHRtbDUpLiAgXG5Zb3Ugc2hvdWxkIGluY2x1ZGUgKiptYW51YWxseSoqIGRpc3RyaWJ1dGl2ZXMgb2YgYHd5c2lodG1sNWAgYW5kIGBib290c3RyYXAtd3lzaWh0bWw1YDpcblxuICAgIDxsaW5rIGhyZWY9XCJqcy9pbnB1dHMtZXh0L3d5c2lodG1sNS9ib290c3RyYXAtd3lzaWh0bWw1LTAuMC4yL2Jvb3RzdHJhcC13eXNpaHRtbDUtMC4wLjIuY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiIHR5cGU9XCJ0ZXh0L2Nzc1wiPjwvbGluaz4gIFxuICAgIDxzY3JpcHQgc3JjPVwianMvaW5wdXRzLWV4dC93eXNpaHRtbDUvYm9vdHN0cmFwLXd5c2lodG1sNS0wLjAuMi93eXNpaHRtbDUtMC4zLjAubWluLmpzXCI+PC9zY3JpcHQ+ICBcbiAgICA8c2NyaXB0IHNyYz1cImpzL2lucHV0cy1leHQvd3lzaWh0bWw1L2Jvb3RzdHJhcC13eXNpaHRtbDUtMC4wLjIvYm9vdHN0cmFwLXd5c2lodG1sNS0wLjAuMi5taW4uanNcIj48L3NjcmlwdD5cbiAgICBcbkFuZCBhbHNvIGluY2x1ZGUgYHd5c2lodG1sNS5qc2AgZnJvbSBgaW5wdXRzLWV4dGAgZGlyZWN0b3J5IG9mIHgtZWRpdGFibGU6XG4gICAgICBcbiAgICA8c2NyaXB0IHNyYz1cImpzL2lucHV0cy1leHQvd3lzaWh0bWw1L3d5c2lodG1sNS5qc1wiPjwvc2NyaXB0PiAgXG5cbioqTm90ZToqKiBJdCdzIGJldHRlciB0byB1c2UgZnJlc2ggYm9vdHN0cmFwLXd5c2lodG1sNSBmcm9tIGl0J3MgW21hc3RlciBicmFuY2hdKGh0dHBzOi8vZ2l0aHViLmNvbS9qaG9sbGluZ3dvcnRoL2Jvb3RzdHJhcC13eXNpaHRtbDUvdHJlZS9tYXN0ZXIvc3JjKSBhcyB0aGVyZSBpcyB1cGRhdGUgZm9yIGNvcnJlY3QgaW1hZ2UgaW5zZXJ0aW9uLiAgICBcbiAgICBcbkBjbGFzcyB3eXNpaHRtbDVcbkBleHRlbmRzIGFic3RyYWN0aW5wdXRcbkBmaW5hbFxuQHNpbmNlIDEuNC4wXG5AZXhhbXBsZVxuPGRpdiBpZD1cImNvbW1lbnRzXCIgZGF0YS10eXBlPVwid3lzaWh0bWw1XCIgZGF0YS1waz1cIjFcIj48aDI+YXdlc29tZTwvaDI+IGNvbW1lbnQhPC9kaXY+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNjb21tZW50cycpLmVkaXRhYmxlKHtcbiAgICAgICAgdXJsOiAnL3Bvc3QnLFxuICAgICAgICB0aXRsZTogJ0VudGVyIGNvbW1lbnRzJ1xuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG5cbiAgd2luZG93Lld5c2lodG1sNSA9IGZ1bmN0aW9uIFd5c2lodG1sNShvcHRpb25zKSB7XG4gICAgdGhpcy5pbml0KCd3eXNpaHRtbDUnLCBvcHRpb25zLCBXeXNpaHRtbDUuZGVmYXVsdHMpO1xuXG4gICAgLy9leHRlbmQgd3lzaWh0bWw1IG1hbnVhbGx5IGFzICQuZXh0ZW5kIG5vdCByZWN1cnNpdmUgXG4gICAgdGhpcy5vcHRpb25zLnd5c2lodG1sNSA9ICQuZXh0ZW5kKHt9LCBXeXNpaHRtbDUuZGVmYXVsdHMud3lzaWh0bWw1LCBvcHRpb25zLnd5c2lodG1sNSk7XG4gIH07XG5cbiAgd2luZG93LiQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KFd5c2lodG1sNSwgd2luZG93LiQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTtcblxuICAkLmV4dGVuZChXeXNpaHRtbDUucHJvdG90eXBlLCB7XG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCksXG4gICAgICAgICAgbXNpZU9sZDtcblxuICAgICAgLy9nZW5lcmF0ZSB1bmlxdWUgaWQgYXMgaXQgcmVxdWlyZWQgZm9yIHd5c2lodG1sNVxuICAgICAgdGhpcy4kaW5wdXQuYXR0cignaWQnLCAndGV4dGFyZWFfJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcblxuICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgdGhpcy5zZXRBdHRyKCdwbGFjZWhvbGRlcicpO1xuXG4gICAgICAvL3Jlc29sdmUgZGVmZmVyZWQgd2hlbiB3aWRnZXQgbG9hZGVkXG4gICAgICAkLmV4dGVuZCh0aGlzLm9wdGlvbnMud3lzaWh0bWw1LCB7XG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy4kaW5wdXQud3lzaWh0bWw1KHRoaXMub3B0aW9ucy53eXNpaHRtbDUpO1xuXG4gICAgICAvKlxuICAgICAgIEluIElFOCB3eXNpaHRtbDUgaWZyYW1lIHN0YXlzIG9uIHRoZSBzYW1lIGxpbmUgd2l0aCBidXR0b25zIHRvb2xiYXIgKGluc2lkZSBwb3BvdmVyKS5cbiAgICAgICBUaGUgb25seSBzb2x1dGlvbiBJIGZvdW5kIGlzIHRvIGFkZCA8YnI+LiBJZiB5b3UgZmluZSBiZXR0ZXIgd2F5LCBwbGVhc2Ugc2VuZCBQUi4gICBcbiAgICAgICovXG4gICAgICBtc2llT2xkID0gL21zaWVcXHMqKDh8N3w2KS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKG1zaWVPbGQpIHtcbiAgICAgICAgdGhpcy4kaW5wdXQuYmVmb3JlKCc8YnI+PGJyPicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgIH0sXG5cbiAgICB2YWx1ZTJodG1sOiBmdW5jdGlvbiB2YWx1ZTJodG1sKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAkKGVsZW1lbnQpLmh0bWwodmFsdWUpO1xuICAgIH0sXG5cbiAgICBodG1sMnZhbHVlOiBmdW5jdGlvbiBodG1sMnZhbHVlKGh0bWwpIHtcbiAgICAgIHJldHVybiBodG1sO1xuICAgIH0sXG5cbiAgICB2YWx1ZTJpbnB1dDogZnVuY3Rpb24gdmFsdWUyaW5wdXQodmFsdWUpIHtcbiAgICAgIHRoaXMuJGlucHV0LmRhdGEoXCJ3eXNpaHRtbDVcIikuZWRpdG9yLnNldFZhbHVlKHZhbHVlLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgYWN0aXZhdGU6IGZ1bmN0aW9uIGFjdGl2YXRlKCkge1xuICAgICAgdGhpcy4kaW5wdXQuZGF0YShcInd5c2lodG1sNVwiKS5lZGl0b3IuZm9jdXMoKTtcbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eSgkZWxlbWVudCkge1xuICAgICAgaWYgKCQudHJpbSgkZWxlbWVudC5odG1sKCkpID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoJC50cmltKCRlbGVtZW50LnRleHQoKSkgIT09ICcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vZS5nLiAnPGltZz4nLCAnPGJyPicsICc8cD48L3A+J1xuICAgICAgICByZXR1cm4gISRlbGVtZW50LmhlaWdodCgpIHx8ICEkZWxlbWVudC53aWR0aCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgV3lzaWh0bWw1LmRlZmF1bHRzID0gJC5leHRlbmQoe30sIHdpbmRvdy4kLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgIC8qKlxuICAgIEBwcm9wZXJ0eSB0cGxcbiAgICBAZGVmYXVsdCA8dGV4dGFyZWE+PC90ZXh0YXJlYT5cbiAgICAqKi9cbiAgICB0cGw6ICc8dGV4dGFyZWE+PC90ZXh0YXJlYT4nLFxuICAgIC8qKlxuICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzXG4gICAgQGRlZmF1bHQgZWRpdGFibGUtd3lzaWh0bWw1XG4gICAgKiovXG4gICAgaW5wdXRjbGFzczogJ2VkaXRhYmxlLXd5c2lodG1sNScsXG4gICAgLyoqXG4gICAgUGxhY2Vob2xkZXIgYXR0cmlidXRlIG9mIGlucHV0LiBTaG93biB3aGVuIGlucHV0IGlzIGVtcHR5LlxuICAgICBAcHJvcGVydHkgcGxhY2Vob2xkZXJcbiAgICBAdHlwZSBzdHJpbmdcbiAgICBAZGVmYXVsdCBudWxsXG4gICAgKiovXG4gICAgcGxhY2Vob2xkZXI6IG51bGwsXG4gICAgLyoqXG4gICAgV3lzaWh0bWw1IGRlZmF1bHQgb3B0aW9ucy4gIFxuICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamhvbGxpbmd3b3J0aC9ib290c3RyYXAtd3lzaWh0bWw1I29wdGlvbnNcbiAgICAgQHByb3BlcnR5IHd5c2lodG1sNVxuICAgIEB0eXBlIG9iamVjdFxuICAgIEBkZWZhdWx0IHtzdHlsZXNoZWV0czogZmFsc2V9XG4gICAgKiovXG4gICAgd3lzaWh0bWw1OiB7XG4gICAgICBzdHlsZXNoZWV0czogZmFsc2VcbiAgICB9XG4gIH0pO1xuXG4gIHdpbmRvdy4kLmZuLmVkaXRhYmxldHlwZXMud3lzaWh0bWw1ID0gV3lzaWh0bWw1O1xufSkod2luZG93LmpRdWVyeSk7XG5cbiFmdW5jdGlvbiAoJCwgd3lzaSkge1xuXG4gIHZhciB0cGwgPSB7XG4gICAgXCJmb250LXN0eWxlc1wiOiBmdW5jdGlvbiBmb250U3R5bGVzKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHNpemUgPSBvcHRpb25zICYmIG9wdGlvbnMuc2l6ZSA/ICcgYnRuLScgKyBvcHRpb25zLnNpemUgOiAnJztcbiAgICAgIHJldHVybiBcIjxsaSBjbGFzcz0nZHJvcGRvd24nPlwiICsgXCI8YSBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0IGRyb3Bkb3duLXRvZ2dsZVwiICsgc2l6ZSArIFwiJyBkYXRhLXRvZ2dsZT0nZHJvcGRvd24nIGhyZWY9JyMnPlwiICsgXCI8aSBjbGFzcz0nZmEgZmEtZm9udCc+PC9pPiZuYnNwOzxzcGFuIGNsYXNzPSdjdXJyZW50LWZvbnQnPlwiICsgbG9jYWxlLmZvbnRfc3R5bGVzLm5vcm1hbCArIFwiPC9zcGFuPiZuYnNwOzxiIGNsYXNzPSdjYXJldCc+PC9iPlwiICsgXCI8L2E+XCIgKyBcIjx1bCBjbGFzcz0nZHJvcGRvd24tbWVudSc+XCIgKyBcIjxsaT48YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JtYXRCbG9jaycgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0nZGl2JyB0YWJpbmRleD0nLTEnPlwiICsgbG9jYWxlLmZvbnRfc3R5bGVzLm5vcm1hbCArIFwiPC9hPjwvbGk+XCIgKyBcIjxsaT48YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JtYXRCbG9jaycgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0naDEnIHRhYmluZGV4PSctMSc+XCIgKyBsb2NhbGUuZm9udF9zdHlsZXMuaDEgKyBcIjwvYT48L2xpPlwiICsgXCI8bGk+PGEgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nZm9ybWF0QmxvY2snIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J2gyJyB0YWJpbmRleD0nLTEnPlwiICsgbG9jYWxlLmZvbnRfc3R5bGVzLmgyICsgXCI8L2E+PC9saT5cIiArIFwiPGxpPjxhIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2Zvcm1hdEJsb2NrJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdoMycgdGFiaW5kZXg9Jy0xJz5cIiArIGxvY2FsZS5mb250X3N0eWxlcy5oMyArIFwiPC9hPjwvbGk+XCIgKyBcIjwvdWw+XCIgKyBcIjwvbGk+XCI7XG4gICAgfSxcblxuICAgIFwiZW1waGFzaXNcIjogZnVuY3Rpb24gZW1waGFzaXMobG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2l6ZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaXplID8gJyBidG4tJyArIG9wdGlvbnMuc2l6ZSA6ICcnO1xuICAgICAgcmV0dXJuIFwiPGxpPlwiICsgXCI8ZGl2IGNsYXNzPSdidG4tZ3JvdXAnPlwiICsgXCI8YSBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0XCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2JvbGQnIHRpdGxlPSdDVFJMK0InIHRhYmluZGV4PSctMSc+XCIgKyBsb2NhbGUuZW1waGFzaXMuYm9sZCArIFwiPC9hPlwiICsgXCI8YSBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0XCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2l0YWxpYycgdGl0bGU9J0NUUkwrSScgdGFiaW5kZXg9Jy0xJz5cIiArIGxvY2FsZS5lbXBoYXNpcy5pdGFsaWMgKyBcIjwvYT5cIiArIFwiPGEgY2xhc3M9J2J0biBidG4tZGVmYXVsdFwiICsgc2l6ZSArIFwiJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSd1bmRlcmxpbmUnIHRpdGxlPSdDVFJMK1UnIHRhYmluZGV4PSctMSc+XCIgKyBsb2NhbGUuZW1waGFzaXMudW5kZXJsaW5lICsgXCI8L2E+XCIgKyBcIjwvZGl2PlwiICsgXCI8L2xpPlwiO1xuICAgIH0sXG5cbiAgICBcImxpc3RzXCI6IGZ1bmN0aW9uIGxpc3RzKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHNpemUgPSBvcHRpb25zICYmIG9wdGlvbnMuc2l6ZSA/ICcgYnRuLScgKyBvcHRpb25zLnNpemUgOiAnJztcbiAgICAgIHJldHVybiBcIjxsaT5cIiArIFwiPGRpdiBjbGFzcz0nYnRuLWdyb3VwJz5cIiArIFwiPGEgY2xhc3M9J2J0biBidG4tZGVmYXVsdFwiICsgc2l6ZSArIFwiJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdpbnNlcnRVbm9yZGVyZWRMaXN0JyB0aXRsZT0nXCIgKyBsb2NhbGUubGlzdHMudW5vcmRlcmVkICsgXCInIHRhYmluZGV4PSctMSc+PGkgY2xhc3M9J2ZhIGZhLWxpc3QnPjwvaT48L2E+XCIgKyBcIjxhIGNsYXNzPSdidG4gYnRuLWRlZmF1bHRcIiArIHNpemUgKyBcIicgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0naW5zZXJ0T3JkZXJlZExpc3QnIHRpdGxlPSdcIiArIGxvY2FsZS5saXN0cy5vcmRlcmVkICsgXCInIHRhYmluZGV4PSctMSc+PGkgY2xhc3M9J2ZhIGZhLXRoLWxpc3QnPjwvaT48L2E+XCIgKyBcIjxhIGNsYXNzPSdidG4gYnRuLWRlZmF1bHRcIiArIHNpemUgKyBcIicgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nY2xlYXInIHRpdGxlPSdiYW4nIHRhYmluZGV4PSctMSc+PGkgY2xhc3M9J2ZhIGZhLWJhbic+PC9pPjwvYT5cIiArIFwiPC9kaXY+XCIgKyBcIjwvbGk+XCI7XG4gICAgfSxcblxuICAgIFwibGlua1wiOiBmdW5jdGlvbiBsaW5rKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHNpemUgPSBvcHRpb25zICYmIG9wdGlvbnMuc2l6ZSA/ICcgYnRuLScgKyBvcHRpb25zLnNpemUgOiAnJztcbiAgICAgIHJldHVybiBcIjxsaT5cIiArIFwiPGRpdiBjbGFzcz0nYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtbGluay1tb2RhbCBtb2RhbCBoaWRlIGZhZGUnPlwiICsgXCI8ZGl2IGNsYXNzPSdtb2RhbC1oZWFkZXInPlwiICsgXCI8YSBjbGFzcz0nY2xvc2UnIGRhdGEtZGlzbWlzcz0nbW9kYWwnPiZ0aW1lczs8L2E+XCIgKyBcIjxoMz5cIiArIGxvY2FsZS5saW5rLmluc2VydCArIFwiPC9oMz5cIiArIFwiPC9kaXY+XCIgKyBcIjxkaXYgY2xhc3M9J21vZGFsLWJvZHknPlwiICsgXCI8aW5wdXQgdmFsdWU9J2h0dHA6Ly8nIGNsYXNzPSdib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1saW5rLXVybCBpbnB1dC14bGFyZ2UnPlwiICsgXCI8L2Rpdj5cIiArIFwiPGRpdiBjbGFzcz0nbW9kYWwtZm9vdGVyJz5cIiArIFwiPGEgaHJlZj0nIycgY2xhc3M9J2J0biBidG4tZGVmYXVsdCcgZGF0YS1kaXNtaXNzPSdtb2RhbCc+XCIgKyBsb2NhbGUubGluay5jYW5jZWwgKyBcIjwvYT5cIiArIFwiPGEgaHJlZj0nIycgY2xhc3M9J2J0biBidG4tcHJpbWFyeScgZGF0YS1kaXNtaXNzPSdtb2RhbCc+XCIgKyBsb2NhbGUubGluay5pbnNlcnQgKyBcIjwvYT5cIiArIFwiPC9kaXY+XCIgKyBcIjwvZGl2PlwiICsgXCI8YSBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0XCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2NyZWF0ZUxpbmsnIHRpdGxlPSdcIiArIGxvY2FsZS5saW5rLmluc2VydCArIFwiJyB0YWJpbmRleD0nLTEnPjxpIGNsYXNzPSdmYSBmYS1zaGFyZSc+PC9pPjwvYT5cIiArIFwiPC9saT5cIjtcbiAgICB9LFxuXG4gICAgXCJpbWFnZVwiOiBmdW5jdGlvbiBpbWFnZShsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaXplID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpemUgPyAnIGJ0bi0nICsgb3B0aW9ucy5zaXplIDogJyc7XG4gICAgICByZXR1cm4gXCI8bGk+XCIgKyBcIjxkaXYgY2xhc3M9J2Jvb3RzdHJhcC13eXNpaHRtbDUtaW5zZXJ0LWltYWdlLW1vZGFsIG1vZGFsIGhpZGUgZmFkZSc+XCIgKyBcIjxkaXYgY2xhc3M9J21vZGFsLWhlYWRlcic+XCIgKyBcIjxhIGNsYXNzPSdjbG9zZScgZGF0YS1kaXNtaXNzPSdtb2RhbCc+JnRpbWVzOzwvYT5cIiArIFwiPGgzPlwiICsgbG9jYWxlLmltYWdlLmluc2VydCArIFwiPC9oMz5cIiArIFwiPC9kaXY+XCIgKyBcIjxkaXYgY2xhc3M9J21vZGFsLWJvZHknPlwiICsgXCI8aW5wdXQgdmFsdWU9J2h0dHA6Ly8nIGNsYXNzPSdib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1pbWFnZS11cmwgaW5wdXQteGxhcmdlJz5cIiArIFwiPC9kaXY+XCIgKyBcIjxkaXYgY2xhc3M9J21vZGFsLWZvb3Rlcic+XCIgKyBcIjxhIGhyZWY9JyMnIGNsYXNzPSdidG4gYnRuLWRlZmF1bHQnIGRhdGEtZGlzbWlzcz0nbW9kYWwnPlwiICsgbG9jYWxlLmltYWdlLmNhbmNlbCArIFwiPC9hPlwiICsgXCI8YSBocmVmPScjJyBjbGFzcz0nYnRuIGJ0bi1wcmltYXJ5JyBkYXRhLWRpc21pc3M9J21vZGFsJz5cIiArIGxvY2FsZS5pbWFnZS5pbnNlcnQgKyBcIjwvYT5cIiArIFwiPC9kaXY+XCIgKyBcIjwvZGl2PlwiICsgXCI8YSBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0XCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2luc2VydEltYWdlJyB0aXRsZT0nXCIgKyBsb2NhbGUuaW1hZ2UuaW5zZXJ0ICsgXCInIHRhYmluZGV4PSctMSc+PGkgY2xhc3M9J2ZhIGZhLXBpY3R1cmUnPjwvaT48L2E+XCIgKyBcIjwvbGk+XCI7XG4gICAgfSxcblxuICAgIFwiaHRtbFwiOiBmdW5jdGlvbiBodG1sKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHNpemUgPSBvcHRpb25zICYmIG9wdGlvbnMuc2l6ZSA/ICcgYnRuLScgKyBvcHRpb25zLnNpemUgOiAnJztcbiAgICAgIHJldHVybiBcIjxsaT5cIiArIFwiPGRpdiBjbGFzcz0nYnRuLWdyb3VwJz5cIiArIFwiPGEgY2xhc3M9J2J0biBidG4tZGVmYXVsdFwiICsgc2l6ZSArIFwiJyBkYXRhLXd5c2lodG1sNS1hY3Rpb249J2NoYW5nZV92aWV3JyB0aXRsZT0nXCIgKyBsb2NhbGUuaHRtbC5lZGl0ICsgXCInIHRhYmluZGV4PSctMSc+PGkgY2xhc3M9J2ZhIGZhLXBlbmNpbCc+PC9pPjwvYT5cIiArIFwiPC9kaXY+XCIgKyBcIjwvbGk+XCI7XG4gICAgfSxcblxuICAgIFwiY29sb3JcIjogZnVuY3Rpb24gY29sb3IobG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2l6ZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaXplID8gJyBidG4tJyArIG9wdGlvbnMuc2l6ZSA6ICcnO1xuICAgICAgcmV0dXJuIFwiPGxpIGNsYXNzPSdkcm9wZG93bic+XCIgKyBcIjxhIGNsYXNzPSdidG4gYnRuLWRlZmF1bHQgZHJvcGRvd24tdG9nZ2xlXCIgKyBzaXplICsgXCInIGRhdGEtdG9nZ2xlPSdkcm9wZG93bicgaHJlZj0nIycgdGFiaW5kZXg9Jy0xJz5cIiArIFwiPHNwYW4gY2xhc3M9J2N1cnJlbnQtY29sb3InPuWOn+iJsjwvc3Bhbj4mbmJzcDs8YiBjbGFzcz0nY2FyZXQnPjwvYj5cIiArIFwiPC9hPlwiICsgXCI8dWwgY2xhc3M9J2Ryb3Bkb3duLW1lbnUnPlwiICsgXCI8bGk+PGRpdiBjbGFzcz0nd3lzaWh0bWw1LWNvbG9ycycgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0nY2xlYXInPjwvZGl2PjxhIGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzLXRpdGxlJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JlQ29sb3InIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J2NsZWFyJz5cIiArIGxvY2FsZS5jb2xvdXJzLmNsZWFyICsgXCI8L2E+PC9saT5cIiArIFwiPGxpPjxkaXYgY2xhc3M9J3d5c2lodG1sNS1jb2xvcnMnIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J2ZpcnN0Jz48L2Rpdj48YSBjbGFzcz0nd3lzaWh0bWw1LWNvbG9ycy10aXRsZScgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nZm9yZUNvbG9yJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdmaXJzdCc+XCIgKyBsb2NhbGUuY29sb3Vycy5maXJzdCArIFwiPC9hPjwvbGk+XCIgKyBcIjxsaT48ZGl2IGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdzZWNvbmQnPjwvZGl2PjxhIGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzLXRpdGxlJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JlQ29sb3InIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J3NlY29uZCc+XCIgKyBsb2NhbGUuY29sb3Vycy5zZWNvbmQgKyBcIjwvYT48L2xpPlwiICsgXCI8bGk+PGRpdiBjbGFzcz0nd3lzaWh0bWw1LWNvbG9ycycgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0ndGhyZWUnPjwvZGl2PjxhIGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzLXRpdGxlJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JlQ29sb3InIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J3RocmVlJz5cIiArIGxvY2FsZS5jb2xvdXJzLnRocmVlICsgXCI8L2E+PC9saT5cIiArIFwiPC91bD5cIiArIFwiPC9saT5cIjtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHRlbXBsYXRlcyA9IGZ1bmN0aW9uIHRlbXBsYXRlcyhrZXksIGxvY2FsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0cGxba2V5XShsb2NhbGUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHZhciBXeXNpaHRtbDUgPSBmdW5jdGlvbiBXeXNpaHRtbDUoZWwsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdmFyIHRvb2xiYXJPcHRzID0gb3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucztcbiAgICBmb3IgKHZhciB0IGluIHRvb2xiYXJPcHRzLmN1c3RvbVRlbXBsYXRlcykge1xuICAgICAgdHBsW3RdID0gdG9vbGJhck9wdHMuY3VzdG9tVGVtcGxhdGVzW3RdO1xuICAgIH1cbiAgICB0aGlzLnRvb2xiYXIgPSB0aGlzLmNyZWF0ZVRvb2xiYXIoZWwsIHRvb2xiYXJPcHRzKTtcbiAgICB0aGlzLmVkaXRvciA9IHRoaXMuY3JlYXRlRWRpdG9yKG9wdGlvbnMpO1xuXG4gICAgd2luZG93LmVkaXRvciA9IHRoaXMuZWRpdG9yO1xuXG4gICAgJCgnaWZyYW1lLnd5c2lodG1sNS1zYW5kYm94JykuZWFjaChmdW5jdGlvbiAoaSwgZWwpIHtcbiAgICAgICQoZWwuY29udGVudFdpbmRvdykub2ZmKCdmb2N1cy53eXNpaHRtbDUnKS5vbih7XG4gICAgICAgICdmb2N1cy53eXNpaHRtbDUnOiBmdW5jdGlvbiBmb2N1c1d5c2lodG1sNSgpIHtcbiAgICAgICAgICAkKCdsaS5kcm9wZG93bicpLnJlbW92ZUNsYXNzKCdvcGVuJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFd5c2lodG1sNS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogV3lzaWh0bWw1LFxuXG4gICAgY3JlYXRlRWRpdG9yOiBmdW5jdGlvbiBjcmVhdGVFZGl0b3Iob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIEFkZCB0aGUgdG9vbGJhciB0byBhIGNsb25lIG9mIHRoZSBvcHRpb25zIG9iamVjdCBzbyBtdWx0aXBsZSBpbnN0YW5jZXNcbiAgICAgIC8vIG9mIHRoZSBXWUlTWVdHIGRvbid0IGJyZWFrIGJlY2F1c2UgXCJ0b29sYmFyXCIgaXMgYWxyZWFkeSBkZWZpbmVkXG4gICAgICBvcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy50b29sYmFyID0gdGhpcy50b29sYmFyWzBdO1xuXG4gICAgICB2YXIgZWRpdG9yID0gbmV3IHd5c2lodG1sNS5FZGl0b3IodGhpcy5lbFswXSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBvcHRpb25zLmV2ZW50cykge1xuICAgICAgICAgIGVkaXRvci5vbihldmVudE5hbWUsIG9wdGlvbnMuZXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRpdG9yO1xuICAgIH0sXG5cbiAgICBjcmVhdGVUb29sYmFyOiBmdW5jdGlvbiBjcmVhdGVUb29sYmFyKGVsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgdG9vbGJhciA9ICQoXCI8dWwvPlwiLCB7XG4gICAgICAgICdjbGFzcyc6IFwid3lzaWh0bWw1LXRvb2xiYXJcIixcbiAgICAgICAgJ3N0eWxlJzogXCJkaXNwbGF5Om5vbmVcIlxuICAgICAgfSk7XG4gICAgICB2YXIgY3VsdHVyZSA9IG9wdGlvbnMubG9jYWxlIHx8IGRlZmF1bHRPcHRpb25zLmxvY2FsZSB8fCBcImVuXCI7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gd2luZG93LiQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvcHRpb25zW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChvcHRpb25zW2tleV0gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBkZWZhdWx0T3B0aW9uc1trZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgdG9vbGJhci5hcHBlbmQodGVtcGxhdGVzKGtleSwgbG9jYWxlW2N1bHR1cmVdLCBvcHRpb25zKSk7XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSBcImh0bWxcIikge1xuICAgICAgICAgICAgdGhpcy5pbml0SHRtbCh0b29sYmFyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSBcImxpbmtcIikge1xuICAgICAgICAgICAgdGhpcy5pbml0SW5zZXJ0TGluayh0b29sYmFyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdEluc2VydEltYWdlKHRvb2xiYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50b29sYmFyKSB7XG4gICAgICAgIGZvciAoa2V5IGluIG9wdGlvbnMudG9vbGJhcikge1xuICAgICAgICAgIHRvb2xiYXIuYXBwZW5kKG9wdGlvbnMudG9vbGJhcltrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b29sYmFyLmZpbmQoXCJhW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2Zvcm1hdEJsb2NrJ11cIikuY2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICAgICAgdmFyIGVsID0gJCh0YXJnZXQpO1xuICAgICAgICBzZWxmLnRvb2xiYXIuZmluZCgnLmN1cnJlbnQtZm9udCcpLnRleHQoZWwuaHRtbCgpKTtcbiAgICAgIH0pO1xuXG4gICAgICB0b29sYmFyLmZpbmQoXCJhW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2ZvcmVDb2xvciddXCIpLmNsaWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgICAgIHZhciBlbCA9ICQodGFyZ2V0KTtcbiAgICAgICAgc2VsZi50b29sYmFyLmZpbmQoJy5jdXJyZW50LWNvbG9yJykudGV4dChlbC5odG1sKCkpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZWwuYmVmb3JlKHRvb2xiYXIpO1xuXG4gICAgICByZXR1cm4gdG9vbGJhcjtcbiAgICB9LFxuXG4gICAgaW5pdEh0bWw6IGZ1bmN0aW9uIGluaXRIdG1sKHRvb2xiYXIpIHtcbiAgICAgIHZhciBjaGFuZ2VWaWV3U2VsZWN0b3IgPSBcImFbZGF0YS13eXNpaHRtbDUtYWN0aW9uPSdjaGFuZ2VfdmlldyddXCI7XG4gICAgICB0b29sYmFyLmZpbmQoY2hhbmdlVmlld1NlbGVjdG9yKS5jbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICB0b29sYmFyLmZpbmQoJ2EuYnRuJykubm90KGNoYW5nZVZpZXdTZWxlY3RvcikudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5pdEluc2VydEltYWdlOiBmdW5jdGlvbiBpbml0SW5zZXJ0SW1hZ2UodG9vbGJhcikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGluc2VydEltYWdlTW9kYWwgPSB0b29sYmFyLmZpbmQoJy5ib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1pbWFnZS1tb2RhbCcpO1xuICAgICAgdmFyIHVybElucHV0ID0gaW5zZXJ0SW1hZ2VNb2RhbC5maW5kKCcuYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtaW1hZ2UtdXJsJyk7XG4gICAgICB2YXIgaW5zZXJ0QnV0dG9uID0gaW5zZXJ0SW1hZ2VNb2RhbC5maW5kKCdhLmJ0bi1wcmltYXJ5Jyk7XG4gICAgICB2YXIgaW5pdGlhbFZhbHVlID0gdXJsSW5wdXQudmFsKCk7XG4gICAgICB2YXIgY2FyZXRCb29rbWFyaztcblxuICAgICAgdmFyIGluc2VydEltYWdlID0gZnVuY3Rpb24gaW5zZXJ0SW1hZ2UoKSB7XG4gICAgICAgIHZhciB1cmwgPSB1cmxJbnB1dC52YWwoKTtcbiAgICAgICAgdXJsSW5wdXQudmFsKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIHNlbGYuZWRpdG9yLmN1cnJlbnRWaWV3LmVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgaWYgKGNhcmV0Qm9va21hcmspIHtcbiAgICAgICAgICBzZWxmLmVkaXRvci5jb21wb3Nlci5zZWxlY3Rpb24uc2V0Qm9va21hcmsoY2FyZXRCb29rbWFyayk7XG4gICAgICAgICAgY2FyZXRCb29rbWFyayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5lZGl0b3IuY29tcG9zZXIuY29tbWFuZHMuZXhlYyhcImluc2VydEltYWdlXCIsIHVybCk7XG4gICAgICB9O1xuXG4gICAgICB1cmxJbnB1dC5rZXlwcmVzcyhmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS53aGljaCA9PSAxMykge1xuICAgICAgICAgIGluc2VydEltYWdlKCk7XG4gICAgICAgICAgaW5zZXJ0SW1hZ2VNb2RhbC5tb2RhbCgnaGlkZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaW5zZXJ0QnV0dG9uLmNsaWNrKGluc2VydEltYWdlKTtcblxuICAgICAgaW5zZXJ0SW1hZ2VNb2RhbC5vbignc2hvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHVybElucHV0LmZvY3VzKCk7XG4gICAgICB9KTtcblxuICAgICAgaW5zZXJ0SW1hZ2VNb2RhbC5vbignaGlkZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5lZGl0b3IuY3VycmVudFZpZXcuZWxlbWVudC5mb2N1cygpO1xuICAgICAgfSk7XG5cbiAgICAgIHRvb2xiYXIuZmluZCgnYVtkYXRhLXd5c2lodG1sNS1jb21tYW5kPWluc2VydEltYWdlXScpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUJ1dHRvbiA9ICQodGhpcykuaGFzQ2xhc3MoXCJ3eXNpaHRtbDUtY29tbWFuZC1hY3RpdmVcIik7XG5cbiAgICAgICAgaWYgKCFhY3RpdmVCdXR0b24pIHtcbiAgICAgICAgICBzZWxmLmVkaXRvci5jdXJyZW50Vmlldy5lbGVtZW50LmZvY3VzKGZhbHNlKTtcbiAgICAgICAgICBjYXJldEJvb2ttYXJrID0gc2VsZi5lZGl0b3IuY29tcG9zZXIuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCk7XG4gICAgICAgICAgaW5zZXJ0SW1hZ2VNb2RhbC5hcHBlbmRUbygnYm9keScpLm1vZGFsKCdzaG93Jyk7XG4gICAgICAgICAgaW5zZXJ0SW1hZ2VNb2RhbC5vbignY2xpY2suZGlzbWlzcy5tb2RhbCcsICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpbml0SW5zZXJ0TGluazogZnVuY3Rpb24gaW5pdEluc2VydExpbmsodG9vbGJhcikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGluc2VydExpbmtNb2RhbCA9IHRvb2xiYXIuZmluZCgnLmJvb3RzdHJhcC13eXNpaHRtbDUtaW5zZXJ0LWxpbmstbW9kYWwnKTtcbiAgICAgIHZhciB1cmxJbnB1dCA9IGluc2VydExpbmtNb2RhbC5maW5kKCcuYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtbGluay11cmwnKTtcbiAgICAgIHZhciBpbnNlcnRCdXR0b24gPSBpbnNlcnRMaW5rTW9kYWwuZmluZCgnYS5idG4tcHJpbWFyeScpO1xuICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IHVybElucHV0LnZhbCgpO1xuICAgICAgdmFyIGNhcmV0Qm9va21hcms7XG5cbiAgICAgIHZhciBpbnNlcnRMaW5rID0gZnVuY3Rpb24gaW5zZXJ0TGluaygpIHtcbiAgICAgICAgdmFyIHVybCA9IHVybElucHV0LnZhbCgpO1xuICAgICAgICB1cmxJbnB1dC52YWwoaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgc2VsZi5lZGl0b3IuY3VycmVudFZpZXcuZWxlbWVudC5mb2N1cygpO1xuICAgICAgICBpZiAoY2FyZXRCb29rbWFyaykge1xuICAgICAgICAgIHNlbGYuZWRpdG9yLmNvbXBvc2VyLnNlbGVjdGlvbi5zZXRCb29rbWFyayhjYXJldEJvb2ttYXJrKTtcbiAgICAgICAgICBjYXJldEJvb2ttYXJrID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmVkaXRvci5jb21wb3Nlci5jb21tYW5kcy5leGVjKFwiY3JlYXRlTGlua1wiLCB7XG4gICAgICAgICAgaHJlZjogdXJsLFxuICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICByZWw6IFwibm9mb2xsb3dcIlxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB2YXIgcHJlc3NlZEVudGVyID0gZmFsc2U7XG5cbiAgICAgIHVybElucHV0LmtleXByZXNzKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLndoaWNoID09IDEzKSB7XG4gICAgICAgICAgaW5zZXJ0TGluaygpO1xuICAgICAgICAgIGluc2VydExpbmtNb2RhbC5tb2RhbCgnaGlkZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaW5zZXJ0QnV0dG9uLmNsaWNrKGluc2VydExpbmspO1xuXG4gICAgICBpbnNlcnRMaW5rTW9kYWwub24oJ3Nob3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB1cmxJbnB1dC5mb2N1cygpO1xuICAgICAgfSk7XG5cbiAgICAgIGluc2VydExpbmtNb2RhbC5vbignaGlkZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5lZGl0b3IuY3VycmVudFZpZXcuZWxlbWVudC5mb2N1cygpO1xuICAgICAgfSk7XG5cbiAgICAgIHRvb2xiYXIuZmluZCgnYVtkYXRhLXd5c2lodG1sNS1jb21tYW5kPWNyZWF0ZUxpbmtdJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWN0aXZlQnV0dG9uID0gJCh0aGlzKS5oYXNDbGFzcyhcInd5c2lodG1sNS1jb21tYW5kLWFjdGl2ZVwiKTtcblxuICAgICAgICBpZiAoIWFjdGl2ZUJ1dHRvbikge1xuICAgICAgICAgIHNlbGYuZWRpdG9yLmN1cnJlbnRWaWV3LmVsZW1lbnQuZm9jdXMoZmFsc2UpO1xuICAgICAgICAgIGNhcmV0Qm9va21hcmsgPSBzZWxmLmVkaXRvci5jb21wb3Nlci5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKTtcbiAgICAgICAgICBpbnNlcnRMaW5rTW9kYWwuYXBwZW5kVG8oJ2JvZHknKS5tb2RhbCgnc2hvdycpO1xuICAgICAgICAgIGluc2VydExpbmtNb2RhbC5vbignY2xpY2suZGlzbWlzcy5tb2RhbCcsICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyB0aGVzZSBkZWZpbmUgb3VyIHB1YmxpYyBhcGlcbiAgdmFyIG1ldGhvZHMgPSB7XG4gICAgcmVzZXREZWZhdWx0czogZnVuY3Rpb24gcmVzZXREZWZhdWx0cygpIHtcbiAgICAgIHdpbmRvdy4kLmZuLnd5c2lodG1sNS5kZWZhdWx0T3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCB3aW5kb3cuJC5mbi53eXNpaHRtbDUuZGVmYXVsdE9wdGlvbnNDYWNoZSk7XG4gICAgfSxcbiAgICBieXBhc3NEZWZhdWx0czogZnVuY3Rpb24gYnlwYXNzRGVmYXVsdHMob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICR0aGlzLmRhdGEoJ3d5c2lodG1sNScsIG5ldyBXeXNpaHRtbDUoJHRoaXMsIG9wdGlvbnMpKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2hhbGxvd0V4dGVuZDogZnVuY3Rpb24gc2hhbGxvd0V4dGVuZChvcHRpb25zKSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgd2luZG93LiQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHJldHVybiBtZXRob2RzLmJ5cGFzc0RlZmF1bHRzLmFwcGx5KHRoYXQsIFtzZXR0aW5nc10pO1xuICAgIH0sXG4gICAgZGVlcEV4dGVuZDogZnVuY3Rpb24gZGVlcEV4dGVuZChvcHRpb25zKSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSAkLmV4dGVuZCh0cnVlLCB7fSwgd2luZG93LiQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHJldHVybiBtZXRob2RzLmJ5cGFzc0RlZmF1bHRzLmFwcGx5KHRoYXQsIFtzZXR0aW5nc10pO1xuICAgIH0sXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICByZXR1cm4gbWV0aG9kcy5zaGFsbG93RXh0ZW5kLmFwcGx5KHRoYXQsIFtvcHRpb25zXSk7XG4gICAgfVxuICB9O1xuXG4gIHdpbmRvdy4kLmZuLnd5c2lodG1sNSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICBpZiAobWV0aG9kc1ttZXRob2RdKSB7XG4gICAgICByZXR1cm4gbWV0aG9kc1ttZXRob2RdLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBtZXRob2QgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihtZXRob2QpKSA9PT0gJ29iamVjdCcgfHwgIW1ldGhvZCkge1xuICAgICAgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkLmVycm9yKCdNZXRob2QgJyArIG1ldGhvZCArICcgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5Lnd5c2lodG1sNScpO1xuICAgIH1cbiAgfTtcblxuICB3aW5kb3cuJC5mbi53eXNpaHRtbDUuQ29uc3RydWN0b3IgPSBXeXNpaHRtbDU7XG5cbiAgd2luZG93LiQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zID0ge1xuICAgIFwiZm9udC1zdHlsZXNcIjogdHJ1ZSxcbiAgICBcImNvbG9yXCI6IGZhbHNlLFxuICAgIFwiZW1waGFzaXNcIjogdHJ1ZSxcbiAgICBcImxpc3RzXCI6IHRydWUsXG4gICAgXCJodG1sXCI6IGZhbHNlLFxuICAgIFwibGlua1wiOiB0cnVlLFxuICAgIFwiaW1hZ2VcIjogdHJ1ZSxcbiAgICBldmVudHM6IHt9LFxuICAgIHBhcnNlclJ1bGVzOiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgIC8vIChwYXRoX3RvX3Byb2plY3QvbGliL2Nzcy93eXNpd3lnLWNvbG9yLmNzcylcbiAgICAgICAgXCJ3eXNpd3lnLWNvbG9yLWNsZWFyXCI6IDEsXG4gICAgICAgIFwid3lzaXd5Zy1jb2xvci1maXJzdFwiOiAxLFxuICAgICAgICBcInd5c2l3eWctY29sb3Itc2Vjb25kXCI6IDEsXG4gICAgICAgIFwid3lzaXd5Zy1jb2xvci10aHJlZVwiOiAxXG4gICAgICB9LFxuICAgICAgdGFnczoge1xuICAgICAgICBcImJcIjoge30sXG4gICAgICAgIFwiaVwiOiB7fSxcbiAgICAgICAgXCJiclwiOiB7fSxcbiAgICAgICAgXCJvbFwiOiB7fSxcbiAgICAgICAgXCJ1bFwiOiB7fSxcbiAgICAgICAgXCJsaVwiOiB7fSxcbiAgICAgICAgXCJoMVwiOiB7fSxcbiAgICAgICAgXCJoMlwiOiB7fSxcbiAgICAgICAgXCJoM1wiOiB7fSxcbiAgICAgICAgXCJibG9ja3F1b3RlXCI6IHt9LFxuICAgICAgICBcInVcIjogMSxcbiAgICAgICAgXCJpbWdcIjoge1xuICAgICAgICAgIFwiY2hlY2tfYXR0cmlidXRlc1wiOiB7XG4gICAgICAgICAgICBcIndpZHRoXCI6IFwibnVtYmVyc1wiLFxuICAgICAgICAgICAgXCJhbHRcIjogXCJhbHRcIixcbiAgICAgICAgICAgIFwic3JjXCI6IFwidXJsXCIsXG4gICAgICAgICAgICBcImhlaWdodFwiOiBcIm51bWJlcnNcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJhXCI6IHtcbiAgICAgICAgICBzZXRfYXR0cmlidXRlczoge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgcmVsOiBcIm5vZm9sbG93XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoZWNrX2F0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIGhyZWY6IFwidXJsXCIgLy8gaW1wb3J0YW50IHRvIGF2b2lkIFhTU1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzcGFuXCI6IDEsXG4gICAgICAgIFwiZGl2XCI6IDEsXG4gICAgICAgIC8vIHRvIGFsbG93IHNhdmUgYW5kIGVkaXQgZmlsZXMgd2l0aCBjb2RlIHRhZyBoYWNrc1xuICAgICAgICBcImNvZGVcIjogMSxcbiAgICAgICAgXCJwcmVcIjogMVxuICAgICAgfVxuICAgIH0sXG4gICAgc3R5bGVzaGVldHM6IFtcIi4vbGliL2Nzcy93eXNpd3lnLWNvbG9yLmNzc1wiXSwgLy8gKHBhdGhfdG9fcHJvamVjdC9saWIvY3NzL3d5c2l3eWctY29sb3IuY3NzKVxuICAgIGxvY2FsZTogXCJlblwiXG4gIH07XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cuJC5mbi53eXNpaHRtbDUuZGVmYXVsdE9wdGlvbnNDYWNoZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuJC5mbi53eXNpaHRtbDUuZGVmYXVsdE9wdGlvbnNDYWNoZSA9ICQuZXh0ZW5kKHRydWUsIHt9LCB3aW5kb3cuJC5mbi53eXNpaHRtbDUuZGVmYXVsdE9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIGxvY2FsZSA9IHdpbmRvdy4kLmZuLnd5c2lodG1sNS5sb2NhbGUgPSB7XG4gICAgZW46IHtcbiAgICAgIGZvbnRfc3R5bGVzOiB7XG4gICAgICAgIG5vcm1hbDogXCJOb3JtYWwgdGV4dFwiLFxuICAgICAgICBoMTogXCJIZWFkaW5nIDFcIixcbiAgICAgICAgaDI6IFwiSGVhZGluZyAyXCIsXG4gICAgICAgIGgzOiBcIkhlYWRpbmcgM1wiXG4gICAgICB9LFxuICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgYm9sZDogXCJCb2xkXCIsXG4gICAgICAgIGl0YWxpYzogXCJJdGFsaWNcIixcbiAgICAgICAgdW5kZXJsaW5lOiBcIlVuZGVybGluZVwiXG4gICAgICB9LFxuICAgICAgbGlzdHM6IHtcbiAgICAgICAgdW5vcmRlcmVkOiBcIlVub3JkZXJlZCBsaXN0XCIsXG4gICAgICAgIG9yZGVyZWQ6IFwiT3JkZXJlZCBsaXN0XCIsXG4gICAgICAgIG91dGRlbnQ6IFwiT3V0ZGVudFwiLFxuICAgICAgICBpbmRlbnQ6IFwiSW5kZW50XCJcbiAgICAgIH0sXG4gICAgICBsaW5rOiB7XG4gICAgICAgIGluc2VydDogXCJJbnNlcnQgbGlua1wiLFxuICAgICAgICBjYW5jZWw6IFwiQ2FuY2VsXCJcbiAgICAgIH0sXG4gICAgICBpbWFnZToge1xuICAgICAgICBpbnNlcnQ6IFwiSW5zZXJ0IGltYWdlXCIsXG4gICAgICAgIGNhbmNlbDogXCJDYW5jZWxcIlxuICAgICAgfSxcbiAgICAgIGh0bWw6IHtcbiAgICAgICAgZWRpdDogXCJFZGl0IEhUTUxcIlxuICAgICAgfSxcbiAgICAgIGNvbG91cnM6IHtcbiAgICAgICAgY2xlYXI6IFwiQ2xlYXJcIixcbiAgICAgICAgZmlyc3Q6IFwi6aaW6YCJXCIsXG4gICAgICAgIHNlY29uZDogXCLmrKHpgIlcIixcbiAgICAgICAgdGhyZWU6IFwi5aSH6YCJXCIsXG4gICAgICAgIGJsYWNrOiBcIkJsYWNrXCIsXG4gICAgICAgIHNpbHZlcjogXCJTaWx2ZXJcIixcbiAgICAgICAgZ3JheTogXCJHcmV5XCIsXG4gICAgICAgIG1hcm9vbjogXCJNYXJvb25cIixcbiAgICAgICAgcmVkOiBcIlJlZFwiLFxuICAgICAgICBwdXJwbGU6IFwiUHVycGxlXCIsXG4gICAgICAgIGdyZWVuOiBcIkdyZWVuXCIsXG4gICAgICAgIG9saXZlOiBcIk9saXZlXCIsXG4gICAgICAgIG5hdnk6IFwiTmF2eVwiLFxuICAgICAgICBibHVlOiBcIkJsdWVcIixcbiAgICAgICAgb3JhbmdlOiBcIk9yYW5nZVwiXG4gICAgICB9XG4gICAgfVxuICB9O1xufSh3aW5kb3cualF1ZXJ5LCB3aW5kb3cud3lzaWh0bWw1KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lZGl0YWJsZS9qcy93eXNpaHRtbDUuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Editable_vue__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Editable_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__Editable_vue__);\n\nVue.component('editable', __WEBPACK_IMPORTED_MODULE_0__Editable_vue___default.a);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbIlZ1ZSIsImNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQUEsSUFBSUMsU0FBSixDQUFjLFVBQWQsRUFBMEIscURBQTFCIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRWRpdGFibGUgZnJvbSAnLi9FZGl0YWJsZS52dWUnXG5WdWUuY29tcG9uZW50KCdlZGl0YWJsZScsIEVkaXRhYmxlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYWluLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(0)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, "/*! X-editable - v1.5.1 \\n* In-place editing with Twitter Bootstrap, jQuery UI or pure jQuery\\n* http://github.com/vitalets/x-editable\\n* Copyright (c) 2013 Vitaliy Potapov; Licensed MIT */.editableform{margin-bottom:0}.editableform .control-group{margin-bottom:0;white-space:nowrap;line-height:20px}.editableform .form-control{width:auto}.editable-buttons{display:inline-block;vertical-align:top;margin-left:7px;zoom:1;*display:inline}.editable-buttons.editable-buttons-bottom{display:block;margin-top:7px;margin-left:0}.editable-input{vertical-align:top;display:inline-block;width:auto;white-space:normal;zoom:1;*display:inline}.editable-buttons .editable-cancel{margin-left:7px}.editable-buttons button.ui-button-icon-only{height:24px;width:30px}.editableform-loading{background:url(" + __webpack_require__(13) + ") 50% no-repeat;height:25px;width:auto;min-width:25px}.editable-inline .editableform-loading{background-position:left 5px}.editable-error-block{max-width:300px;margin:5px 0 0;width:auto;white-space:normal}.editable-error-block.ui-state-error{padding:3px}.editable-error{color:red}.editableform .editable-date{padding:0;margin:0;float:left}.editable-inline .add-on .icon-th{margin-top:3px;margin-left:1px}.editable-checklist label input[type=checkbox],.editable-checklist label span{vertical-align:middle;margin:0}.editable-checklist label{white-space:nowrap}.editable-wysihtml5{width:566px;height:250px}.editable-clear{clear:both;font-size:.9em;text-decoration:none;text-align:right}.editable-clear-x{background:url(" + __webpack_require__(12) + ") 50% no-repeat;display:block;width:13px;height:13px;position:absolute;opacity:.6;z-index:100;top:50%;right:6px;margin-top:-6px}.editable-clear-x:hover{opacity:1}.editable-pre-wrapped{white-space:pre-wrap}.editable-container.editable-popup{max-width:none!important}.editable-container.popover{width:auto}.editable-container.editable-inline{display:inline-block;vertical-align:middle;width:auto;zoom:1;*display:inline}.editable-container.ui-widget{font-size:inherit;z-index:9990}.editable-click,a.editable-click,a.editable-click:hover{text-decoration:none;border-bottom:1px dashed #08c}.editable-click.editable-disabled,a.editable-click.editable-disabled,a.editable-click.editable-disabled:hover{color:#585858;cursor:default;border-bottom:none}.editable-empty,.editable-empty:focus,.editable-empty:hover{font-style:italic;color:#d14;text-decoration:none}.editable-unsaved{font-weight:700}.editable-bg-transition{-webkit-transition:background-color 1.4s ease-out;-moz-transition:background-color 1.4s ease-out;-o-transition:background-color 1.4s ease-out;-ms-transition:background-color 1.4s ease-out;transition:background-color 1.4s ease-out}.form-horizontal .editable{padding-top:5px;display:inline-block}\\n\\n\\n/*!\\n * Datepicker for Bootstrap\\n *\\n * Copyright 2012 Stefan Petre\\n * Improvements by Andrew Rowls\\n * Licensed under the Apache License v2.0\\n * http://www.apache.org/licenses/LICENSE-2.0\\n *\\n */.datepicker{padding:4px;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;direction:ltr}.datepicker-inline{width:220px}.datepicker.datepicker-rtl{direction:rtl}.datepicker.datepicker-rtl table tr td span{float:right}.datepicker-dropdown{top:0;left:0}.datepicker-dropdown:before{content:\\"\\";display:inline-block;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #ccc;border-bottom-color:rgba(0,0,0,.2);position:absolute;top:-7px;left:6px}.datepicker-dropdown:after{content:\\"\\";display:inline-block;border-left:6px solid transparent;border-right:6px solid transparent;border-bottom:6px solid #fff;position:absolute;top:-6px;left:7px}.datepicker>div{display:none}.datepicker.days div.datepicker-days,.datepicker.months div.datepicker-months,.datepicker.years div.datepicker-years{display:block}.datepicker table{margin:0}.datepicker td,.datepicker th{text-align:center;width:20px;height:20px;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;border:none}.table-striped .datepicker table tr td,.table-striped .datepicker table tr th{background-color:transparent}.datepicker table tr td.day:hover{background:#eee;cursor:pointer}.datepicker table tr td.new,.datepicker table tr td.old{color:#999}.datepicker table tr td.disabled,.datepicker table tr td.disabled:hover{background:none;color:#999;cursor:default}.datepicker table tr td.today,.datepicker table tr td.today.disabled,.datepicker table tr td.today.disabled:hover,.datepicker table tr td.today:hover{background-color:#fde19a;background-image:-moz-linear-gradient(top,#fdd49a,#fdf59a);background-image:-ms-linear-gradient(top,#fdd49a,#fdf59a);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fdd49a),to(#fdf59a));background-image:-webkit-linear-gradient(top,#fdd49a,#fdf59a);background-image:-o-linear-gradient(top,#fdd49a,#fdf59a);background-image:linear-gradient(top,#fdd49a,#fdf59a);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#fdd49a\\",endColorstr=\\"#fdf59a\\",GradientType=0);border-color:#fdf59a #fdf59a #fbed50;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);color:#000}.datepicker table tr td.today.active,.datepicker table tr td.today.disabled,.datepicker table tr td.today.disabled.active,.datepicker table tr td.today.disabled.disabled,.datepicker table tr td.today.disabled:active,.datepicker table tr td.today.disabled:hover,.datepicker table tr td.today.disabled:hover.active,.datepicker table tr td.today.disabled:hover.disabled,.datepicker table tr td.today.disabled:hover:active,.datepicker table tr td.today.disabled:hover:hover,.datepicker table tr td.today.disabled:hover[disabled],.datepicker table tr td.today.disabled[disabled],.datepicker table tr td.today:active,.datepicker table tr td.today:hover,.datepicker table tr td.today:hover.active,.datepicker table tr td.today:hover.disabled,.datepicker table tr td.today:hover:active,.datepicker table tr td.today:hover:hover,.datepicker table tr td.today:hover[disabled],.datepicker table tr td.today[disabled]{background-color:#fdf59a}.datepicker table tr td.today.active,.datepicker table tr td.today.disabled.active,.datepicker table tr td.today.disabled:active,.datepicker table tr td.today.disabled:hover.active,.datepicker table tr td.today.disabled:hover:active,.datepicker table tr td.today:active,.datepicker table tr td.today:hover.active,.datepicker table tr td.today:hover:active{background-color:#fbf069\\\\9}.datepicker table tr td.today:hover:hover{color:#000}.datepicker table tr td.today.active:hover{color:#fff}.datepicker table tr td.range,.datepicker table tr td.range.disabled,.datepicker table tr td.range.disabled:hover,.datepicker table tr td.range:hover{background:#eee;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.datepicker table tr td.range.today,.datepicker table tr td.range.today.disabled,.datepicker table tr td.range.today.disabled:hover,.datepicker table tr td.range.today:hover{background-color:#f3d17a;background-image:-moz-linear-gradient(top,#f3c17a,#f3e97a);background-image:-ms-linear-gradient(top,#f3c17a,#f3e97a);background-image:-webkit-gradient(linear,0 0,0 100%,from(#f3c17a),to(#f3e97a));background-image:-webkit-linear-gradient(top,#f3c17a,#f3e97a);background-image:-o-linear-gradient(top,#f3c17a,#f3e97a);background-image:linear-gradient(top,#f3c17a,#f3e97a);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#f3c17a\\",endColorstr=\\"#f3e97a\\",GradientType=0);border-color:#f3e97a #f3e97a #edde34;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.datepicker table tr td.range.today.active,.datepicker table tr td.range.today.disabled,.datepicker table tr td.range.today.disabled.active,.datepicker table tr td.range.today.disabled.disabled,.datepicker table tr td.range.today.disabled:active,.datepicker table tr td.range.today.disabled:hover,.datepicker table tr td.range.today.disabled:hover.active,.datepicker table tr td.range.today.disabled:hover.disabled,.datepicker table tr td.range.today.disabled:hover:active,.datepicker table tr td.range.today.disabled:hover:hover,.datepicker table tr td.range.today.disabled:hover[disabled],.datepicker table tr td.range.today.disabled[disabled],.datepicker table tr td.range.today:active,.datepicker table tr td.range.today:hover,.datepicker table tr td.range.today:hover.active,.datepicker table tr td.range.today:hover.disabled,.datepicker table tr td.range.today:hover:active,.datepicker table tr td.range.today:hover:hover,.datepicker table tr td.range.today:hover[disabled],.datepicker table tr td.range.today[disabled]{background-color:#f3e97a}.datepicker table tr td.range.today.active,.datepicker table tr td.range.today.disabled.active,.datepicker table tr td.range.today.disabled:active,.datepicker table tr td.range.today.disabled:hover.active,.datepicker table tr td.range.today.disabled:hover:active,.datepicker table tr td.range.today:active,.datepicker table tr td.range.today:hover.active,.datepicker table tr td.range.today:hover:active{background-color:#efe24b\\\\9}.datepicker table tr td.selected,.datepicker table tr td.selected.disabled,.datepicker table tr td.selected.disabled:hover,.datepicker table tr td.selected:hover{background-color:#9e9e9e;background-image:-moz-linear-gradient(top,#b3b3b3,gray);background-image:-ms-linear-gradient(top,#b3b3b3,gray);background-image:-webkit-gradient(linear,0 0,0 100%,from(#b3b3b3),to(gray));background-image:-webkit-linear-gradient(top,#b3b3b3,gray);background-image:-o-linear-gradient(top,#b3b3b3,gray);background-image:linear-gradient(top,#b3b3b3,gray);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#b3b3b3\\",endColorstr=\\"#808080\\",GradientType=0);border-color:gray gray #595959;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25)}.datepicker table tr td.selected.active,.datepicker table tr td.selected.disabled,.datepicker table tr td.selected.disabled.active,.datepicker table tr td.selected.disabled.disabled,.datepicker table tr td.selected.disabled:active,.datepicker table tr td.selected.disabled:hover,.datepicker table tr td.selected.disabled:hover.active,.datepicker table tr td.selected.disabled:hover.disabled,.datepicker table tr td.selected.disabled:hover:active,.datepicker table tr td.selected.disabled:hover:hover,.datepicker table tr td.selected.disabled:hover[disabled],.datepicker table tr td.selected.disabled[disabled],.datepicker table tr td.selected:active,.datepicker table tr td.selected:hover,.datepicker table tr td.selected:hover.active,.datepicker table tr td.selected:hover.disabled,.datepicker table tr td.selected:hover:active,.datepicker table tr td.selected:hover:hover,.datepicker table tr td.selected:hover[disabled],.datepicker table tr td.selected[disabled]{background-color:gray}.datepicker table tr td.selected.active,.datepicker table tr td.selected.disabled.active,.datepicker table tr td.selected.disabled:active,.datepicker table tr td.selected.disabled:hover.active,.datepicker table tr td.selected.disabled:hover:active,.datepicker table tr td.selected:active,.datepicker table tr td.selected:hover.active,.datepicker table tr td.selected:hover:active{background-color:#666\\\\9}.datepicker table tr td.active,.datepicker table tr td.active.disabled,.datepicker table tr td.active.disabled:hover,.datepicker table tr td.active:hover{background-color:#006dcc;background-image:-moz-linear-gradient(top,#08c,#04c);background-image:-ms-linear-gradient(top,#08c,#04c);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#04c));background-image:-webkit-linear-gradient(top,#08c,#04c);background-image:-o-linear-gradient(top,#08c,#04c);background-image:linear-gradient(top,#08c,#04c);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#0088cc\\",endColorstr=\\"#0044cc\\",GradientType=0);border-color:#04c #04c #002a80;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25)}.datepicker table tr td.active.active,.datepicker table tr td.active.disabled,.datepicker table tr td.active.disabled.active,.datepicker table tr td.active.disabled.disabled,.datepicker table tr td.active.disabled:active,.datepicker table tr td.active.disabled:hover,.datepicker table tr td.active.disabled:hover.active,.datepicker table tr td.active.disabled:hover.disabled,.datepicker table tr td.active.disabled:hover:active,.datepicker table tr td.active.disabled:hover:hover,.datepicker table tr td.active.disabled:hover[disabled],.datepicker table tr td.active.disabled[disabled],.datepicker table tr td.active:active,.datepicker table tr td.active:hover,.datepicker table tr td.active:hover.active,.datepicker table tr td.active:hover.disabled,.datepicker table tr td.active:hover:active,.datepicker table tr td.active:hover:hover,.datepicker table tr td.active:hover[disabled],.datepicker table tr td.active[disabled]{background-color:#04c}.datepicker table tr td.active.active,.datepicker table tr td.active.disabled.active,.datepicker table tr td.active.disabled:active,.datepicker table tr td.active.disabled:hover.active,.datepicker table tr td.active.disabled:hover:active,.datepicker table tr td.active:active,.datepicker table tr td.active:hover.active,.datepicker table tr td.active:hover:active{background-color:#039\\\\9}.datepicker table tr td span{display:block;width:23%;height:54px;line-height:54px;float:left;margin:1%;cursor:pointer;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.datepicker table tr td span:hover{background:#eee}.datepicker table tr td span.disabled,.datepicker table tr td span.disabled:hover{background:none;color:#999;cursor:default}.datepicker table tr td span.active,.datepicker table tr td span.active.disabled,.datepicker table tr td span.active.disabled:hover,.datepicker table tr td span.active:hover{background-color:#006dcc;background-image:-moz-linear-gradient(top,#08c,#04c);background-image:-ms-linear-gradient(top,#08c,#04c);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#04c));background-image:-webkit-linear-gradient(top,#08c,#04c);background-image:-o-linear-gradient(top,#08c,#04c);background-image:linear-gradient(top,#08c,#04c);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#0088cc\\",endColorstr=\\"#0044cc\\",GradientType=0);border-color:#04c #04c #002a80;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25)}.datepicker table tr td span.active.active,.datepicker table tr td span.active.disabled,.datepicker table tr td span.active.disabled.active,.datepicker table tr td span.active.disabled.disabled,.datepicker table tr td span.active.disabled:active,.datepicker table tr td span.active.disabled:hover,.datepicker table tr td span.active.disabled:hover.active,.datepicker table tr td span.active.disabled:hover.disabled,.datepicker table tr td span.active.disabled:hover:active,.datepicker table tr td span.active.disabled:hover:hover,.datepicker table tr td span.active.disabled:hover[disabled],.datepicker table tr td span.active.disabled[disabled],.datepicker table tr td span.active:active,.datepicker table tr td span.active:hover,.datepicker table tr td span.active:hover.active,.datepicker table tr td span.active:hover.disabled,.datepicker table tr td span.active:hover:active,.datepicker table tr td span.active:hover:hover,.datepicker table tr td span.active:hover[disabled],.datepicker table tr td span.active[disabled]{background-color:#04c}.datepicker table tr td span.active.active,.datepicker table tr td span.active.disabled.active,.datepicker table tr td span.active.disabled:active,.datepicker table tr td span.active.disabled:hover.active,.datepicker table tr td span.active.disabled:hover:active,.datepicker table tr td span.active:active,.datepicker table tr td span.active:hover.active,.datepicker table tr td span.active:hover:active{background-color:#039\\\\9}.datepicker table tr td span.new,.datepicker table tr td span.old{color:#999}.datepicker th.datepicker-switch{width:145px}.datepicker tfoot tr th,.datepicker thead tr:first-child th{cursor:pointer}.datepicker tfoot tr th:hover,.datepicker thead tr:first-child th:hover{background:#eee}.datepicker .cw{font-size:10px;width:12px;padding:0 2px 0 5px;vertical-align:middle}.datepicker thead tr:first-child th.cw{cursor:default;background-color:transparent}.input-append.date .add-on i,.input-prepend.date .add-on i{display:block;cursor:pointer;width:16px;height:16px}.input-daterange input{text-align:center}.input-daterange input:first-child{-webkit-border-radius:3px 0 0 3px;-moz-border-radius:3px 0 0 3px;border-radius:3px 0 0 3px}.input-daterange input:last-child{-webkit-border-radius:0 3px 3px 0;-moz-border-radius:0 3px 3px 0;border-radius:0 3px 3px 0}.input-daterange .add-on{display:inline-block;width:auto;min-width:16px;height:18px;padding:4px 5px;font-weight:400;line-height:18px;text-align:center;text-shadow:0 1px 0 #fff;vertical-align:middle;background-color:#eee;border:1px solid #ccc;margin-left:-5px;margin-right:-5px}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC1lZGl0YWJsZS5jc3M/YmMwMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLHNNQUF1TSw4QkFBOEIsZ0JBQWdCLDZCQUE2QixnQkFBZ0IsbUJBQW1CLGlCQUFpQiw0QkFBNEIsV0FBVyxrQkFBa0IscUJBQXFCLG1CQUFtQixnQkFBZ0IsT0FBTyxnQkFBZ0IsMENBQTBDLGNBQWMsZUFBZSxjQUFjLGdCQUFnQixtQkFBbUIscUJBQXFCLFdBQVcsbUJBQW1CLE9BQU8sZ0JBQWdCLG1DQUFtQyxnQkFBZ0IsNkNBQTZDLFlBQVksV0FBVyxzQkFBc0IsOERBQW9FLFlBQVksV0FBVyxlQUFlLHVDQUF1Qyw2QkFBNkIsc0JBQXNCLGdCQUFnQixlQUFlLFdBQVcsbUJBQW1CLHFDQUFxQyxZQUFZLGdCQUFnQixVQUFVLDZCQUE2QixVQUFVLFNBQVMsV0FBVyxrQ0FBa0MsZUFBZSxnQkFBZ0IsOEVBQThFLHNCQUFzQixTQUFTLDBCQUEwQixtQkFBbUIsb0JBQW9CLFlBQVksYUFBYSxnQkFBZ0IsV0FBVyxlQUFlLHFCQUFxQixpQkFBaUIsa0JBQWtCLDhEQUFrRSxjQUFjLFdBQVcsWUFBWSxrQkFBa0IsV0FBVyxZQUFZLFFBQVEsVUFBVSxnQkFBZ0Isd0JBQXdCLFVBQVUsc0JBQXNCLHFCQUFxQixtQ0FBbUMseUJBQXlCLDRCQUE0QixXQUFXLG9DQUFvQyxxQkFBcUIsc0JBQXNCLFdBQVcsT0FBTyxnQkFBZ0IsOEJBQThCLGtCQUFrQixhQUFhLHdEQUF3RCxxQkFBcUIsOEJBQThCLDhHQUE4RyxjQUFjLGVBQWUsbUJBQW1CLDREQUE0RCxrQkFBa0IsV0FBVyxxQkFBcUIsa0JBQWtCLGdCQUFnQix3QkFBd0Isa0RBQWtELCtDQUErQyw2Q0FBNkMsOENBQThDLDBDQUEwQywyQkFBMkIsZ0JBQWdCLHFCQUFxQiwwTkFBME4sWUFBWSwwQkFBMEIsdUJBQXVCLGtCQUFrQixjQUFjLG1CQUFtQixZQUFZLDJCQUEyQixjQUFjLDRDQUE0QyxZQUFZLHFCQUFxQixNQUFNLE9BQU8sNEJBQTRCLGFBQWEscUJBQXFCLGtDQUFrQyxtQ0FBbUMsNkJBQTZCLG1DQUFtQyxrQkFBa0IsU0FBUyxTQUFTLDJCQUEyQixhQUFhLHFCQUFxQixrQ0FBa0MsbUNBQW1DLDZCQUE2QixrQkFBa0IsU0FBUyxTQUFTLGdCQUFnQixhQUFhLHFIQUFxSCxjQUFjLGtCQUFrQixTQUFTLDhCQUE4QixrQkFBa0IsV0FBVyxZQUFZLDBCQUEwQix1QkFBdUIsa0JBQWtCLFlBQVksOEVBQThFLDZCQUE2QixrQ0FBa0MsZ0JBQWdCLGVBQWUsd0RBQXdELFdBQVcsd0VBQXdFLGdCQUFnQixXQUFXLGVBQWUsc0pBQXNKLHlCQUF5QiwyREFBMkQsMERBQTBELCtFQUErRSw4REFBOEQseURBQXlELHNEQUFzRCwyQkFBMkIsb0hBQW9ILHFDQUFxQywyREFBMkQsaUVBQWlFLFdBQVcsMDRCQUEwNEIseUJBQXlCLG9XQUFvVyw0QkFBNEIsMENBQTBDLFdBQVcsMkNBQTJDLFdBQVcsc0pBQXNKLGdCQUFnQix3QkFBd0IscUJBQXFCLGdCQUFnQiw4S0FBOEsseUJBQXlCLDJEQUEyRCwwREFBMEQsK0VBQStFLDhEQUE4RCx5REFBeUQsc0RBQXNELDJCQUEyQixvSEFBb0gscUNBQXFDLDJEQUEyRCxpRUFBaUUsd0JBQXdCLHFCQUFxQixnQkFBZ0Isa2dDQUFrZ0MseUJBQXlCLG9aQUFvWiw0QkFBNEIsa0tBQWtLLHlCQUF5Qix3REFBd0QsdURBQXVELDRFQUE0RSwyREFBMkQsc0RBQXNELG1EQUFtRCwyQkFBMkIsb0hBQW9ILCtCQUErQiwyREFBMkQsaUVBQWlFLFdBQVcscUNBQXFDLHM4QkFBczhCLHNCQUFzQiw0WEFBNFgseUJBQXlCLDBKQUEwSix5QkFBeUIscURBQXFELG9EQUFvRCx5RUFBeUUsd0RBQXdELG1EQUFtRCxnREFBZ0QsMkJBQTJCLG9IQUFvSCwrQkFBK0IsMkRBQTJELGlFQUFpRSxXQUFXLHFDQUFxQyw4NUJBQTg1QixzQkFBc0IsNFdBQTRXLHlCQUF5Qiw2QkFBNkIsY0FBYyxVQUFVLFlBQVksaUJBQWlCLFdBQVcsVUFBVSxlQUFlLDBCQUEwQix1QkFBdUIsa0JBQWtCLG1DQUFtQyxnQkFBZ0Isa0ZBQWtGLGdCQUFnQixXQUFXLGVBQWUsOEtBQThLLHlCQUF5QixxREFBcUQsb0RBQW9ELHlFQUF5RSx3REFBd0QsbURBQW1ELGdEQUFnRCwyQkFBMkIsb0hBQW9ILCtCQUErQiwyREFBMkQsaUVBQWlFLFdBQVcscUNBQXFDLGtnQ0FBa2dDLHNCQUFzQixvWkFBb1oseUJBQXlCLGtFQUFrRSxXQUFXLGlDQUFpQyxZQUFZLDREQUE0RCxlQUFlLHdFQUF3RSxnQkFBZ0IsZ0JBQWdCLGVBQWUsV0FBVyxvQkFBb0Isc0JBQXNCLHVDQUF1QyxlQUFlLDZCQUE2QiwyREFBMkQsY0FBYyxlQUFlLFdBQVcsWUFBWSx1QkFBdUIsa0JBQWtCLG1DQUFtQyxrQ0FBa0MsK0JBQStCLDBCQUEwQixrQ0FBa0Msa0NBQWtDLCtCQUErQiwwQkFBMEIseUJBQXlCLHFCQUFxQixXQUFXLGVBQWUsWUFBWSxnQkFBZ0IsZ0JBQWdCLGlCQUFpQixrQkFBa0IseUJBQXlCLHNCQUFzQixzQkFBc0Isc0JBQXNCLGlCQUFpQixrQkFBa0I7O0FBRXJ1aUIiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qISBYLWVkaXRhYmxlIC0gdjEuNS4xIFxcbiogSW4tcGxhY2UgZWRpdGluZyB3aXRoIFR3aXR0ZXIgQm9vdHN0cmFwLCBqUXVlcnkgVUkgb3IgcHVyZSBqUXVlcnlcXG4qIGh0dHA6Ly9naXRodWIuY29tL3ZpdGFsZXRzL3gtZWRpdGFibGVcXG4qIENvcHlyaWdodCAoYykgMjAxMyBWaXRhbGl5IFBvdGFwb3Y7IExpY2Vuc2VkIE1JVCAqLy5lZGl0YWJsZWZvcm17bWFyZ2luLWJvdHRvbTowfS5lZGl0YWJsZWZvcm0gLmNvbnRyb2wtZ3JvdXB7bWFyZ2luLWJvdHRvbTowO3doaXRlLXNwYWNlOm5vd3JhcDtsaW5lLWhlaWdodDoyMHB4fS5lZGl0YWJsZWZvcm0gLmZvcm0tY29udHJvbHt3aWR0aDphdXRvfS5lZGl0YWJsZS1idXR0b25ze2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOnRvcDttYXJnaW4tbGVmdDo3cHg7em9vbToxOypkaXNwbGF5OmlubGluZX0uZWRpdGFibGUtYnV0dG9ucy5lZGl0YWJsZS1idXR0b25zLWJvdHRvbXtkaXNwbGF5OmJsb2NrO21hcmdpbi10b3A6N3B4O21hcmdpbi1sZWZ0OjB9LmVkaXRhYmxlLWlucHV0e3ZlcnRpY2FsLWFsaWduOnRvcDtkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDphdXRvO3doaXRlLXNwYWNlOm5vcm1hbDt6b29tOjE7KmRpc3BsYXk6aW5saW5lfS5lZGl0YWJsZS1idXR0b25zIC5lZGl0YWJsZS1jYW5jZWx7bWFyZ2luLWxlZnQ6N3B4fS5lZGl0YWJsZS1idXR0b25zIGJ1dHRvbi51aS1idXR0b24taWNvbi1vbmx5e2hlaWdodDoyNHB4O3dpZHRoOjMwcHh9LmVkaXRhYmxlZm9ybS1sb2FkaW5ne2JhY2tncm91bmQ6dXJsKFwiICsgcmVxdWlyZShcIi4uL2ltZy9sb2FkaW5nLmdpZlwiKSArIFwiKSA1MCUgbm8tcmVwZWF0O2hlaWdodDoyNXB4O3dpZHRoOmF1dG87bWluLXdpZHRoOjI1cHh9LmVkaXRhYmxlLWlubGluZSAuZWRpdGFibGVmb3JtLWxvYWRpbmd7YmFja2dyb3VuZC1wb3NpdGlvbjpsZWZ0IDVweH0uZWRpdGFibGUtZXJyb3ItYmxvY2t7bWF4LXdpZHRoOjMwMHB4O21hcmdpbjo1cHggMCAwO3dpZHRoOmF1dG87d2hpdGUtc3BhY2U6bm9ybWFsfS5lZGl0YWJsZS1lcnJvci1ibG9jay51aS1zdGF0ZS1lcnJvcntwYWRkaW5nOjNweH0uZWRpdGFibGUtZXJyb3J7Y29sb3I6cmVkfS5lZGl0YWJsZWZvcm0gLmVkaXRhYmxlLWRhdGV7cGFkZGluZzowO21hcmdpbjowO2Zsb2F0OmxlZnR9LmVkaXRhYmxlLWlubGluZSAuYWRkLW9uIC5pY29uLXRoe21hcmdpbi10b3A6M3B4O21hcmdpbi1sZWZ0OjFweH0uZWRpdGFibGUtY2hlY2tsaXN0IGxhYmVsIGlucHV0W3R5cGU9Y2hlY2tib3hdLC5lZGl0YWJsZS1jaGVja2xpc3QgbGFiZWwgc3Bhbnt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7bWFyZ2luOjB9LmVkaXRhYmxlLWNoZWNrbGlzdCBsYWJlbHt3aGl0ZS1zcGFjZTpub3dyYXB9LmVkaXRhYmxlLXd5c2lodG1sNXt3aWR0aDo1NjZweDtoZWlnaHQ6MjUwcHh9LmVkaXRhYmxlLWNsZWFye2NsZWFyOmJvdGg7Zm9udC1zaXplOi45ZW07dGV4dC1kZWNvcmF0aW9uOm5vbmU7dGV4dC1hbGlnbjpyaWdodH0uZWRpdGFibGUtY2xlYXIteHtiYWNrZ3JvdW5kOnVybChcIiArIHJlcXVpcmUoXCIuLi9pbWcvY2xlYXIucG5nXCIpICsgXCIpIDUwJSBuby1yZXBlYXQ7ZGlzcGxheTpibG9jazt3aWR0aDoxM3B4O2hlaWdodDoxM3B4O3Bvc2l0aW9uOmFic29sdXRlO29wYWNpdHk6LjY7ei1pbmRleDoxMDA7dG9wOjUwJTtyaWdodDo2cHg7bWFyZ2luLXRvcDotNnB4fS5lZGl0YWJsZS1jbGVhci14OmhvdmVye29wYWNpdHk6MX0uZWRpdGFibGUtcHJlLXdyYXBwZWR7d2hpdGUtc3BhY2U6cHJlLXdyYXB9LmVkaXRhYmxlLWNvbnRhaW5lci5lZGl0YWJsZS1wb3B1cHttYXgtd2lkdGg6bm9uZSFpbXBvcnRhbnR9LmVkaXRhYmxlLWNvbnRhaW5lci5wb3BvdmVye3dpZHRoOmF1dG99LmVkaXRhYmxlLWNvbnRhaW5lci5lZGl0YWJsZS1pbmxpbmV7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlO3dpZHRoOmF1dG87em9vbToxOypkaXNwbGF5OmlubGluZX0uZWRpdGFibGUtY29udGFpbmVyLnVpLXdpZGdldHtmb250LXNpemU6aW5oZXJpdDt6LWluZGV4Ojk5OTB9LmVkaXRhYmxlLWNsaWNrLGEuZWRpdGFibGUtY2xpY2ssYS5lZGl0YWJsZS1jbGljazpob3Zlcnt0ZXh0LWRlY29yYXRpb246bm9uZTtib3JkZXItYm90dG9tOjFweCBkYXNoZWQgIzA4Y30uZWRpdGFibGUtY2xpY2suZWRpdGFibGUtZGlzYWJsZWQsYS5lZGl0YWJsZS1jbGljay5lZGl0YWJsZS1kaXNhYmxlZCxhLmVkaXRhYmxlLWNsaWNrLmVkaXRhYmxlLWRpc2FibGVkOmhvdmVye2NvbG9yOiM1ODU4NTg7Y3Vyc29yOmRlZmF1bHQ7Ym9yZGVyLWJvdHRvbTpub25lfS5lZGl0YWJsZS1lbXB0eSwuZWRpdGFibGUtZW1wdHk6Zm9jdXMsLmVkaXRhYmxlLWVtcHR5OmhvdmVye2ZvbnQtc3R5bGU6aXRhbGljO2NvbG9yOiNkMTQ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmVkaXRhYmxlLXVuc2F2ZWR7Zm9udC13ZWlnaHQ6NzAwfS5lZGl0YWJsZS1iZy10cmFuc2l0aW9uey13ZWJraXQtdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIDEuNHMgZWFzZS1vdXQ7LW1vei10cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgMS40cyBlYXNlLW91dDstby10cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgMS40cyBlYXNlLW91dDstbXMtdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIDEuNHMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIDEuNHMgZWFzZS1vdXR9LmZvcm0taG9yaXpvbnRhbCAuZWRpdGFibGV7cGFkZGluZy10b3A6NXB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrfVxcblxcblxcbi8qIVxcbiAqIERhdGVwaWNrZXIgZm9yIEJvb3RzdHJhcFxcbiAqXFxuICogQ29weXJpZ2h0IDIwMTIgU3RlZmFuIFBldHJlXFxuICogSW1wcm92ZW1lbnRzIGJ5IEFuZHJldyBSb3dsc1xcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSB2Mi4wXFxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXFxuICpcXG4gKi8uZGF0ZXBpY2tlcntwYWRkaW5nOjRweDstd2Via2l0LWJvcmRlci1yYWRpdXM6NHB4Oy1tb3otYm9yZGVyLXJhZGl1czo0cHg7Ym9yZGVyLXJhZGl1czo0cHg7ZGlyZWN0aW9uOmx0cn0uZGF0ZXBpY2tlci1pbmxpbmV7d2lkdGg6MjIwcHh9LmRhdGVwaWNrZXIuZGF0ZXBpY2tlci1ydGx7ZGlyZWN0aW9uOnJ0bH0uZGF0ZXBpY2tlci5kYXRlcGlja2VyLXJ0bCB0YWJsZSB0ciB0ZCBzcGFue2Zsb2F0OnJpZ2h0fS5kYXRlcGlja2VyLWRyb3Bkb3due3RvcDowO2xlZnQ6MH0uZGF0ZXBpY2tlci1kcm9wZG93bjpiZWZvcmV7Y29udGVudDpcXFwiXFxcIjtkaXNwbGF5OmlubGluZS1ibG9jaztib3JkZXItbGVmdDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjdweCBzb2xpZCAjY2NjO2JvcmRlci1ib3R0b20tY29sb3I6cmdiYSgwLDAsMCwuMik7cG9zaXRpb246YWJzb2x1dGU7dG9wOi03cHg7bGVmdDo2cHh9LmRhdGVwaWNrZXItZHJvcGRvd246YWZ0ZXJ7Y29udGVudDpcXFwiXFxcIjtkaXNwbGF5OmlubGluZS1ibG9jaztib3JkZXItbGVmdDo2cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjZweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjZweCBzb2xpZCAjZmZmO3Bvc2l0aW9uOmFic29sdXRlO3RvcDotNnB4O2xlZnQ6N3B4fS5kYXRlcGlja2VyPmRpdntkaXNwbGF5Om5vbmV9LmRhdGVwaWNrZXIuZGF5cyBkaXYuZGF0ZXBpY2tlci1kYXlzLC5kYXRlcGlja2VyLm1vbnRocyBkaXYuZGF0ZXBpY2tlci1tb250aHMsLmRhdGVwaWNrZXIueWVhcnMgZGl2LmRhdGVwaWNrZXIteWVhcnN7ZGlzcGxheTpibG9ja30uZGF0ZXBpY2tlciB0YWJsZXttYXJnaW46MH0uZGF0ZXBpY2tlciB0ZCwuZGF0ZXBpY2tlciB0aHt0ZXh0LWFsaWduOmNlbnRlcjt3aWR0aDoyMHB4O2hlaWdodDoyMHB4Oy13ZWJraXQtYm9yZGVyLXJhZGl1czo0cHg7LW1vei1ib3JkZXItcmFkaXVzOjRweDtib3JkZXItcmFkaXVzOjRweDtib3JkZXI6bm9uZX0udGFibGUtc3RyaXBlZCAuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCwudGFibGUtc3RyaXBlZCAuZGF0ZXBpY2tlciB0YWJsZSB0ciB0aHtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmRheTpob3ZlcntiYWNrZ3JvdW5kOiNlZWU7Y3Vyc29yOnBvaW50ZXJ9LmRhdGVwaWNrZXIgdGFibGUgdHIgdGQubmV3LC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLm9sZHtjb2xvcjojOTk5fS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmRpc2FibGVkOmhvdmVye2JhY2tncm91bmQ6bm9uZTtjb2xvcjojOTk5O2N1cnNvcjpkZWZhdWx0fS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmhvdmVye2JhY2tncm91bmQtY29sb3I6I2ZkZTE5YTtiYWNrZ3JvdW5kLWltYWdlOi1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwjZmRkNDlhLCNmZGY1OWEpO2JhY2tncm91bmQtaW1hZ2U6LW1zLWxpbmVhci1ncmFkaWVudCh0b3AsI2ZkZDQ5YSwjZmRmNTlhKTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLDAgMCwwIDEwMCUsZnJvbSgjZmRkNDlhKSx0bygjZmRmNTlhKSk7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsI2ZkZDQ5YSwjZmRmNTlhKTtiYWNrZ3JvdW5kLWltYWdlOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsI2ZkZDQ5YSwjZmRmNTlhKTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0b3AsI2ZkZDQ5YSwjZmRmNTlhKTtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9XFxcIiNmZGQ0OWFcXFwiLGVuZENvbG9yc3RyPVxcXCIjZmRmNTlhXFxcIixHcmFkaWVudFR5cGU9MCk7Ym9yZGVyLWNvbG9yOiNmZGY1OWEgI2ZkZjU5YSAjZmJlZDUwO2JvcmRlci1jb2xvcjpyZ2JhKDAsMCwwLC4xKSByZ2JhKDAsMCwwLC4xKSByZ2JhKDAsMCwwLC4yNSk7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChlbmFibGVkPWZhbHNlKTtjb2xvcjojMDAwfS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5kaXNhYmxlZC5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQuZGlzYWJsZWQsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQ6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkOmhvdmVyLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5kaXNhYmxlZDpob3Zlci5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5kaXNhYmxlZDpob3ZlcjphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQ6aG92ZXI6aG92ZXIsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQ6aG92ZXJbZGlzYWJsZWRdLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkW2Rpc2FibGVkXSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheTphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXk6aG92ZXIsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXk6aG92ZXIuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmhvdmVyLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmhvdmVyOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheTpob3Zlcjpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheTpob3ZlcltkaXNhYmxlZF0sLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXlbZGlzYWJsZWRde2JhY2tncm91bmQtY29sb3I6I2ZkZjU5YX0uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5kaXNhYmxlZDpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQ6aG92ZXI6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheTpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXk6aG92ZXI6YWN0aXZle2JhY2tncm91bmQtY29sb3I6I2ZiZjA2OVxcXFw5fS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmhvdmVyOmhvdmVye2NvbG9yOiMwMDB9LmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuYWN0aXZlOmhvdmVye2NvbG9yOiNmZmZ9LmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UuZGlzYWJsZWQsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UuZGlzYWJsZWQ6aG92ZXIsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2U6aG92ZXJ7YmFja2dyb3VuZDojZWVlOy13ZWJraXQtYm9yZGVyLXJhZGl1czowOy1tb3otYm9yZGVyLXJhZGl1czowO2JvcmRlci1yYWRpdXM6MH0uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZDpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmM2QxN2E7YmFja2dyb3VuZC1pbWFnZTotbW96LWxpbmVhci1ncmFkaWVudCh0b3AsI2YzYzE3YSwjZjNlOTdhKTtiYWNrZ3JvdW5kLWltYWdlOi1tcy1saW5lYXItZ3JhZGllbnQodG9wLCNmM2MxN2EsI2YzZTk3YSk7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhciwwIDAsMCAxMDAlLGZyb20oI2YzYzE3YSksdG8oI2YzZTk3YSkpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCNmM2MxN2EsI2YzZTk3YSk7YmFja2dyb3VuZC1pbWFnZTotby1saW5lYXItZ3JhZGllbnQodG9wLCNmM2MxN2EsI2YzZTk3YSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG9wLCNmM2MxN2EsI2YzZTk3YSk7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPVxcXCIjZjNjMTdhXFxcIixlbmRDb2xvcnN0cj1cXFwiI2YzZTk3YVxcXCIsR3JhZGllbnRUeXBlPTApO2JvcmRlci1jb2xvcjojZjNlOTdhICNmM2U5N2EgI2VkZGUzNDtib3JkZXItY29sb3I6cmdiYSgwLDAsMCwuMSkgcmdiYSgwLDAsMCwuMSkgcmdiYSgwLDAsMCwuMjUpO2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoZW5hYmxlZD1mYWxzZSk7LXdlYmtpdC1ib3JkZXItcmFkaXVzOjA7LW1vei1ib3JkZXItcmFkaXVzOjA7Ym9yZGVyLXJhZGl1czowfS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZC5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQuZGlzYWJsZWQsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQ6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmRpc2FibGVkOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmRpc2FibGVkOmhvdmVyLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZDpob3Zlci5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZDpob3ZlcjphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQ6aG92ZXI6aG92ZXIsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQ6aG92ZXJbZGlzYWJsZWRdLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmRpc2FibGVkW2Rpc2FibGVkXSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheTphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXk6aG92ZXIsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXk6aG92ZXIuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5OmhvdmVyLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5OmhvdmVyOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheTpob3Zlcjpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheTpob3ZlcltkaXNhYmxlZF0sLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXlbZGlzYWJsZWRde2JhY2tncm91bmQtY29sb3I6I2YzZTk3YX0uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmRpc2FibGVkOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZDpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQ6aG92ZXI6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5OmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheTpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXk6aG92ZXI6YWN0aXZle2JhY2tncm91bmQtY29sb3I6I2VmZTI0YlxcXFw5fS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzllOWU5ZTtiYWNrZ3JvdW5kLWltYWdlOi1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwjYjNiM2IzLGdyYXkpO2JhY2tncm91bmQtaW1hZ2U6LW1zLWxpbmVhci1ncmFkaWVudCh0b3AsI2IzYjNiMyxncmF5KTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLDAgMCwwIDEwMCUsZnJvbSgjYjNiM2IzKSx0byhncmF5KSk7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsI2IzYjNiMyxncmF5KTtiYWNrZ3JvdW5kLWltYWdlOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsI2IzYjNiMyxncmF5KTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0b3AsI2IzYjNiMyxncmF5KTtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9XFxcIiNiM2IzYjNcXFwiLGVuZENvbG9yc3RyPVxcXCIjODA4MDgwXFxcIixHcmFkaWVudFR5cGU9MCk7Ym9yZGVyLWNvbG9yOmdyYXkgZ3JheSAjNTk1OTU5O2JvcmRlci1jb2xvcjpyZ2JhKDAsMCwwLC4xKSByZ2JhKDAsMCwwLC4xKSByZ2JhKDAsMCwwLC4yNSk7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChlbmFibGVkPWZhbHNlKTtjb2xvcjojZmZmO3RleHQtc2hhZG93OjAgLTFweCAwIHJnYmEoMCwwLDAsLjI1KX0uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5kaXNhYmxlZDpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5kaXNhYmxlZDpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQ6aG92ZXIuZGlzYWJsZWQsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQ6aG92ZXI6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkOmhvdmVyOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkOmhvdmVyW2Rpc2FibGVkXSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5kaXNhYmxlZFtkaXNhYmxlZF0sLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQ6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkOmhvdmVyLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZDpob3Zlci5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZDpob3ZlcjphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQ6aG92ZXI6aG92ZXIsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQ6aG92ZXJbZGlzYWJsZWRdLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkW2Rpc2FibGVkXXtiYWNrZ3JvdW5kLWNvbG9yOmdyYXl9LmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5kaXNhYmxlZDphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQ6aG92ZXIuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkOmhvdmVyOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZDphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQ6aG92ZXIuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkOmhvdmVyOmFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiM2NjZcXFxcOX0uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZDpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMDA2ZGNjO2JhY2tncm91bmQtaW1hZ2U6LW1vei1saW5lYXItZ3JhZGllbnQodG9wLCMwOGMsIzA0Yyk7YmFja2dyb3VuZC1pbWFnZTotbXMtbGluZWFyLWdyYWRpZW50KHRvcCwjMDhjLCMwNGMpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsMCAwLDAgMTAwJSxmcm9tKCMwOGMpLHRvKCMwNGMpKTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjMDhjLCMwNGMpO2JhY2tncm91bmQtaW1hZ2U6LW8tbGluZWFyLWdyYWRpZW50KHRvcCwjMDhjLCMwNGMpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvcCwjMDhjLCMwNGMpO2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj1cXFwiIzAwODhjY1xcXCIsZW5kQ29sb3JzdHI9XFxcIiMwMDQ0Y2NcXFwiLEdyYWRpZW50VHlwZT0wKTtib3JkZXItY29sb3I6IzA0YyAjMDRjICMwMDJhODA7Ym9yZGVyLWNvbG9yOnJnYmEoMCwwLDAsLjEpIHJnYmEoMCwwLDAsLjEpIHJnYmEoMCwwLDAsLjI1KTtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KGVuYWJsZWQ9ZmFsc2UpO2NvbG9yOiNmZmY7dGV4dC1zaGFkb3c6MCAtMXB4IDAgcmdiYSgwLDAsMCwuMjUpfS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZC5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZDphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZDpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkOmhvdmVyLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZDpob3ZlcjphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkOmhvdmVyOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZDpob3ZlcltkaXNhYmxlZF0sLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkW2Rpc2FibGVkXSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZTpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6aG92ZXIuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZTpob3Zlci5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6aG92ZXI6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZTpob3Zlcjpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6aG92ZXJbZGlzYWJsZWRdLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZVtkaXNhYmxlZF17YmFja2dyb3VuZC1jb2xvcjojMDRjfS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmUuZGlzYWJsZWQ6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZDpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkOmhvdmVyOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZTpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlOmhvdmVyOmFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiMwMzlcXFxcOX0uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFue2Rpc3BsYXk6YmxvY2s7d2lkdGg6MjMlO2hlaWdodDo1NHB4O2xpbmUtaGVpZ2h0OjU0cHg7ZmxvYXQ6bGVmdDttYXJnaW46MSU7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC1ib3JkZXItcmFkaXVzOjRweDstbW96LWJvcmRlci1yYWRpdXM6NHB4O2JvcmRlci1yYWRpdXM6NHB4fS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW46aG92ZXJ7YmFja2dyb3VuZDojZWVlfS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uZGlzYWJsZWQsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5kaXNhYmxlZDpob3ZlcntiYWNrZ3JvdW5kOm5vbmU7Y29sb3I6Izk5OTtjdXJzb3I6ZGVmYXVsdH0uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZDpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMwMDZkY2M7YmFja2dyb3VuZC1pbWFnZTotbW96LWxpbmVhci1ncmFkaWVudCh0b3AsIzA4YywjMDRjKTtiYWNrZ3JvdW5kLWltYWdlOi1tcy1saW5lYXItZ3JhZGllbnQodG9wLCMwOGMsIzA0Yyk7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhciwwIDAsMCAxMDAlLGZyb20oIzA4YyksdG8oIzA0YykpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCMwOGMsIzA0Yyk7YmFja2dyb3VuZC1pbWFnZTotby1saW5lYXItZ3JhZGllbnQodG9wLCMwOGMsIzA0Yyk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG9wLCMwOGMsIzA0Yyk7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPVxcXCIjMDA4OGNjXFxcIixlbmRDb2xvcnN0cj1cXFwiIzAwNDRjY1xcXCIsR3JhZGllbnRUeXBlPTApO2JvcmRlci1jb2xvcjojMDRjICMwNGMgIzAwMmE4MDtib3JkZXItY29sb3I6cmdiYSgwLDAsMCwuMSkgcmdiYSgwLDAsMCwuMSkgcmdiYSgwLDAsMCwuMjUpO2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoZW5hYmxlZD1mYWxzZSk7Y29sb3I6I2ZmZjt0ZXh0LXNoYWRvdzowIC0xcHggMCByZ2JhKDAsMCwwLC4yNSl9LmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZC5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZDphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuZGlzYWJsZWQ6aG92ZXIsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuZGlzYWJsZWQ6aG92ZXIuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkOmhvdmVyLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkOmhvdmVyOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZDpob3Zlcjpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZDpob3ZlcltkaXNhYmxlZF0sLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuZGlzYWJsZWRbZGlzYWJsZWRdLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZTpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZTpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmU6aG92ZXIuZGlzYWJsZWQsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmU6aG92ZXI6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlOmhvdmVyOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlOmhvdmVyW2Rpc2FibGVkXSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZVtkaXNhYmxlZF17YmFja2dyb3VuZC1jb2xvcjojMDRjfS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZC5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuZGlzYWJsZWQ6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkOmhvdmVyLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZDpob3ZlcjphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmU6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlOmhvdmVyLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZTpob3ZlcjphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojMDM5XFxcXDl9LmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5uZXcsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5vbGR7Y29sb3I6Izk5OX0uZGF0ZXBpY2tlciB0aC5kYXRlcGlja2VyLXN3aXRjaHt3aWR0aDoxNDVweH0uZGF0ZXBpY2tlciB0Zm9vdCB0ciB0aCwuZGF0ZXBpY2tlciB0aGVhZCB0cjpmaXJzdC1jaGlsZCB0aHtjdXJzb3I6cG9pbnRlcn0uZGF0ZXBpY2tlciB0Zm9vdCB0ciB0aDpob3ZlciwuZGF0ZXBpY2tlciB0aGVhZCB0cjpmaXJzdC1jaGlsZCB0aDpob3ZlcntiYWNrZ3JvdW5kOiNlZWV9LmRhdGVwaWNrZXIgLmN3e2ZvbnQtc2l6ZToxMHB4O3dpZHRoOjEycHg7cGFkZGluZzowIDJweCAwIDVweDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmRhdGVwaWNrZXIgdGhlYWQgdHI6Zmlyc3QtY2hpbGQgdGguY3d7Y3Vyc29yOmRlZmF1bHQ7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0uaW5wdXQtYXBwZW5kLmRhdGUgLmFkZC1vbiBpLC5pbnB1dC1wcmVwZW5kLmRhdGUgLmFkZC1vbiBpe2Rpc3BsYXk6YmxvY2s7Y3Vyc29yOnBvaW50ZXI7d2lkdGg6MTZweDtoZWlnaHQ6MTZweH0uaW5wdXQtZGF0ZXJhbmdlIGlucHV0e3RleHQtYWxpZ246Y2VudGVyfS5pbnB1dC1kYXRlcmFuZ2UgaW5wdXQ6Zmlyc3QtY2hpbGR7LXdlYmtpdC1ib3JkZXItcmFkaXVzOjNweCAwIDAgM3B4Oy1tb3otYm9yZGVyLXJhZGl1czozcHggMCAwIDNweDtib3JkZXItcmFkaXVzOjNweCAwIDAgM3B4fS5pbnB1dC1kYXRlcmFuZ2UgaW5wdXQ6bGFzdC1jaGlsZHstd2Via2l0LWJvcmRlci1yYWRpdXM6MCAzcHggM3B4IDA7LW1vei1ib3JkZXItcmFkaXVzOjAgM3B4IDNweCAwO2JvcmRlci1yYWRpdXM6MCAzcHggM3B4IDB9LmlucHV0LWRhdGVyYW5nZSAuYWRkLW9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmF1dG87bWluLXdpZHRoOjE2cHg7aGVpZ2h0OjE4cHg7cGFkZGluZzo0cHggNXB4O2ZvbnQtd2VpZ2h0OjQwMDtsaW5lLWhlaWdodDoxOHB4O3RleHQtYWxpZ246Y2VudGVyO3RleHQtc2hhZG93OjAgMXB4IDAgI2ZmZjt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7YmFja2dyb3VuZC1jb2xvcjojZWVlO2JvcmRlcjoxcHggc29saWQgI2NjYzttYXJnaW4tbGVmdDotNXB4O21hcmdpbi1yaWdodDotNXB4fVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vc3JjL2VkaXRhYmxlL2Nzcy9ib290c3RyYXAtZWRpdGFibGUuY3NzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(0)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, "ul.wysihtml5-toolbar{margin:0;padding:0;display:block}ul.wysihtml5-toolbar:after{clear:both;display:table;content:\\"\\"}ul.wysihtml5-toolbar>li{float:left;display:list-item;list-style:none;margin:0 5px 10px 0}ul.wysihtml5-toolbar a[data-wysihtml5-command=bold]{font-weight:700}ul.wysihtml5-toolbar a[data-wysihtml5-command=italic]{font-style:italic}ul.wysihtml5-toolbar a[data-wysihtml5-command=underline]{text-decoration:underline}ul.wysihtml5-toolbar a.btn.wysihtml5-command-active{background-image:none;-webkit-box-shadow:inset 0 2px 4px rgba(0,0,0,.15),0 1px 2px rgba(0,0,0,.05);-moz-box-shadow:inset 0 2px 4px rgba(0,0,0,.15),0 1px 2px rgba(0,0,0,.05);box-shadow:inset 0 2px 4px rgba(0,0,0,.15),0 1px 2px rgba(0,0,0,.05);background-color:#e6e6e6;background-color:#d9d9d9;outline:0}ul.wysihtml5-commands-disabled .dropdown-menu{display:none!important}ul.wysihtml5-toolbar div.wysihtml5-colors{display:block;width:50px;height:20px;margin-top:2px;margin-left:5px;position:absolute;pointer-events:none}ul.wysihtml5-toolbar a.wysihtml5-colors-title{padding-left:70px}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=clear]{background:#a38a77!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=black]{background:#000!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=silver]{background:silver!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=gray]{background:gray!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=maroon]{background:maroon!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=red]{background:red!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=purple]{background:purple!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=green]{background:green!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=olive]{background:olive!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=navy]{background:navy!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=blue]{background:blue!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=orange]{background:orange!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=first]{background:#149d9a!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=second]{background:#e02924!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=three]{background:#2954a4!important}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzPzIyYzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSw4Q0FBK0MsU0FBUyxVQUFVLGNBQWMsMkJBQTJCLFdBQVcsY0FBYyxhQUFhLHdCQUF3QixXQUFXLGtCQUFrQixnQkFBZ0Isb0JBQW9CLG9EQUFvRCxnQkFBZ0Isc0RBQXNELGtCQUFrQix5REFBeUQsMEJBQTBCLG9EQUFvRCxzQkFBc0IsNkVBQTZFLDBFQUEwRSxxRUFBcUUseUJBQXlCLHlCQUF5QixVQUFVLDhDQUE4Qyx1QkFBdUIsMENBQTBDLGNBQWMsV0FBVyxZQUFZLGVBQWUsZ0JBQWdCLGtCQUFrQixvQkFBb0IsOENBQThDLGtCQUFrQiw2REFBNkQsNkJBQTZCLDZEQUE2RCwwQkFBMEIsOERBQThELDRCQUE0Qiw0REFBNEQsMEJBQTBCLDhEQUE4RCw0QkFBNEIsMkRBQTJELHlCQUF5Qiw4REFBOEQsNEJBQTRCLDZEQUE2RCwyQkFBMkIsNkRBQTZELDJCQUEyQiw0REFBNEQsMEJBQTBCLDREQUE0RCwwQkFBMEIsOERBQThELDRCQUE0Qiw2REFBNkQsNkJBQTZCLDhEQUE4RCw2QkFBNkIsNkRBQTZELDZCQUE2Qjs7QUFFbDNFIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwidWwud3lzaWh0bWw1LXRvb2xiYXJ7bWFyZ2luOjA7cGFkZGluZzowO2Rpc3BsYXk6YmxvY2t9dWwud3lzaWh0bWw1LXRvb2xiYXI6YWZ0ZXJ7Y2xlYXI6Ym90aDtkaXNwbGF5OnRhYmxlO2NvbnRlbnQ6XFxcIlxcXCJ9dWwud3lzaWh0bWw1LXRvb2xiYXI+bGl7ZmxvYXQ6bGVmdDtkaXNwbGF5Omxpc3QtaXRlbTtsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjAgNXB4IDEwcHggMH11bC53eXNpaHRtbDUtdG9vbGJhciBhW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9Ym9sZF17Zm9udC13ZWlnaHQ6NzAwfXVsLnd5c2lodG1sNS10b29sYmFyIGFbZGF0YS13eXNpaHRtbDUtY29tbWFuZD1pdGFsaWNde2ZvbnQtc3R5bGU6aXRhbGljfXVsLnd5c2lodG1sNS10b29sYmFyIGFbZGF0YS13eXNpaHRtbDUtY29tbWFuZD11bmRlcmxpbmVde3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9dWwud3lzaWh0bWw1LXRvb2xiYXIgYS5idG4ud3lzaWh0bWw1LWNvbW1hbmQtYWN0aXZle2JhY2tncm91bmQtaW1hZ2U6bm9uZTstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAycHggNHB4IHJnYmEoMCwwLDAsLjE1KSwwIDFweCAycHggcmdiYSgwLDAsMCwuMDUpOy1tb3otYm94LXNoYWRvdzppbnNldCAwIDJweCA0cHggcmdiYSgwLDAsMCwuMTUpLDAgMXB4IDJweCByZ2JhKDAsMCwwLC4wNSk7Ym94LXNoYWRvdzppbnNldCAwIDJweCA0cHggcmdiYSgwLDAsMCwuMTUpLDAgMXB4IDJweCByZ2JhKDAsMCwwLC4wNSk7YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2O2JhY2tncm91bmQtY29sb3I6I2Q5ZDlkOTtvdXRsaW5lOjB9dWwud3lzaWh0bWw1LWNvbW1hbmRzLWRpc2FibGVkIC5kcm9wZG93bi1tZW51e2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9dWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2Lnd5c2lodG1sNS1jb2xvcnN7ZGlzcGxheTpibG9jazt3aWR0aDo1MHB4O2hlaWdodDoyMHB4O21hcmdpbi10b3A6MnB4O21hcmdpbi1sZWZ0OjVweDtwb3NpdGlvbjphYnNvbHV0ZTtwb2ludGVyLWV2ZW50czpub25lfXVsLnd5c2lodG1sNS10b29sYmFyIGEud3lzaWh0bWw1LWNvbG9ycy10aXRsZXtwYWRkaW5nLWxlZnQ6NzBweH11bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1jbGVhcl17YmFja2dyb3VuZDojYTM4YTc3IWltcG9ydGFudH11bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1ibGFja117YmFja2dyb3VuZDojMDAwIWltcG9ydGFudH11bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1zaWx2ZXJde2JhY2tncm91bmQ6c2lsdmVyIWltcG9ydGFudH11bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1ncmF5XXtiYWNrZ3JvdW5kOmdyYXkhaW1wb3J0YW50fXVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPW1hcm9vbl17YmFja2dyb3VuZDptYXJvb24haW1wb3J0YW50fXVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPXJlZF17YmFja2dyb3VuZDpyZWQhaW1wb3J0YW50fXVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPXB1cnBsZV17YmFja2dyb3VuZDpwdXJwbGUhaW1wb3J0YW50fXVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPWdyZWVuXXtiYWNrZ3JvdW5kOmdyZWVuIWltcG9ydGFudH11bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1vbGl2ZV17YmFja2dyb3VuZDpvbGl2ZSFpbXBvcnRhbnR9dWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9bmF2eV17YmFja2dyb3VuZDpuYXZ5IWltcG9ydGFudH11bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1ibHVlXXtiYWNrZ3JvdW5kOmJsdWUhaW1wb3J0YW50fXVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPW9yYW5nZV17YmFja2dyb3VuZDpvcmFuZ2UhaW1wb3J0YW50fXVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPWZpcnN0XXtiYWNrZ3JvdW5kOiMxNDlkOWEhaW1wb3J0YW50fXVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPXNlY29uZF17YmFja2dyb3VuZDojZTAyOTI0IWltcG9ydGFudH11bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT10aHJlZV17YmFja2dyb3VuZDojMjk1NGE0IWltcG9ydGFudH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL3NyYy9lZGl0YWJsZS9jc3MvYm9vdHN0cmFwLXd5c2lodG1sNS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(0)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, "/*!\\n * Bootstrap v3.3.7 (http://getbootstrap.com)\\n * Copyright 2011-2017 Twitter, Inc.\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n */\\n\\n/*!\\n * Generated using the Bootstrap Customizer (https://getbootstrap.com/docs/3.3/customize/?id=6729ca5bfebd0b65e0f15f121902b07d)\\n * Config saved to config.json and https://gist.github.com/6729ca5bfebd0b65e0f15f121902b07d\\n *//*!\\n * Bootstrap v3.3.7 (http://getbootstrap.com)\\n * Copyright 2011-2016 Twitter, Inc.\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n *//*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}*,:after,:before{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:Helvetica Neue,Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#333;background-color:#fff}button,input,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#337ab7;text-decoration:none}a:focus,a:hover{color:#23527c;text-decoration:underline}a:focus{outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}figure{margin:0}img{vertical-align:middle}.img-responsive{display:block;max-width:100%;height:auto}.img-rounded{border-radius:6px}.img-thumbnail{padding:4px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out;display:inline-block;max-width:100%;height:auto}.img-circle{border-radius:50%}hr{margin-top:20px;margin-bottom:20px;border:0;border-top:1px solid #eee}.sr-only{position:absolute;width:1px;height:1px;margin:-1px;padding:0;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}.btn,[role=button]{cursor:pointer}.btn{display:inline-block;margin-bottom:0;font-weight:400;text-align:center;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;background-image:none;border:1px solid transparent;white-space:nowrap;padding:6px 12px;font-size:14px;line-height:1.42857143;border-radius:4px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.btn.active.focus,.btn.active:focus,.btn.focus,.btn:active.focus,.btn:active:focus,.btn:focus{outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.focus,.btn:focus,.btn:hover{color:#333;text-decoration:none}.btn.active,.btn:active{outline:0;background-image:none;-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{cursor:not-allowed;opacity:.65;filter:alpha(opacity=65);-webkit-box-shadow:none;box-shadow:none}a.btn.disabled,fieldset[disabled] a.btn{pointer-events:none}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default.focus,.btn-default:focus{color:#333;background-color:#e6e6e6;border-color:#8c8c8c}.btn-default.active,.btn-default:active,.btn-default:hover,.open>.dropdown-toggle.btn-default{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default.active.focus,.btn-default.active:focus,.btn-default.active:hover,.btn-default:active.focus,.btn-default:active:focus,.btn-default:active:hover,.open>.dropdown-toggle.btn-default.focus,.open>.dropdown-toggle.btn-default:focus,.open>.dropdown-toggle.btn-default:hover{color:#333;background-color:#d4d4d4;border-color:#8c8c8c}.btn-default.active,.btn-default:active,.open>.dropdown-toggle.btn-default{background-image:none}.btn-default.disabled.focus,.btn-default.disabled:focus,.btn-default.disabled:hover,.btn-default[disabled].focus,.btn-default[disabled]:focus,.btn-default[disabled]:hover,fieldset[disabled] .btn-default.focus,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:hover{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#337ab7;border-color:#2e6da4}.btn-primary.focus,.btn-primary:focus{color:#fff;background-color:#286090;border-color:#122b40}.btn-primary.active,.btn-primary:active,.btn-primary:hover,.open>.dropdown-toggle.btn-primary{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary.active.focus,.btn-primary.active:focus,.btn-primary.active:hover,.btn-primary:active.focus,.btn-primary:active:focus,.btn-primary:active:hover,.open>.dropdown-toggle.btn-primary.focus,.open>.dropdown-toggle.btn-primary:focus,.open>.dropdown-toggle.btn-primary:hover{color:#fff;background-color:#204d74;border-color:#122b40}.btn-primary.active,.btn-primary:active,.open>.dropdown-toggle.btn-primary{background-image:none}.btn-primary.disabled.focus,.btn-primary.disabled:focus,.btn-primary.disabled:hover,.btn-primary[disabled].focus,.btn-primary[disabled]:focus,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary.focus,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:hover{background-color:#337ab7;border-color:#2e6da4}.btn-primary .badge{color:#337ab7;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success.focus,.btn-success:focus{color:#fff;background-color:#449d44;border-color:#255625}.btn-success.active,.btn-success:active,.btn-success:hover,.open>.dropdown-toggle.btn-success{color:#fff;background-color:#449d44;border-color:#398439}.btn-success.active.focus,.btn-success.active:focus,.btn-success.active:hover,.btn-success:active.focus,.btn-success:active:focus,.btn-success:active:hover,.open>.dropdown-toggle.btn-success.focus,.open>.dropdown-toggle.btn-success:focus,.open>.dropdown-toggle.btn-success:hover{color:#fff;background-color:#398439;border-color:#255625}.btn-success.active,.btn-success:active,.open>.dropdown-toggle.btn-success{background-image:none}.btn-success.disabled.focus,.btn-success.disabled:focus,.btn-success.disabled:hover,.btn-success[disabled].focus,.btn-success[disabled]:focus,.btn-success[disabled]:hover,fieldset[disabled] .btn-success.focus,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:hover{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#5bc0de;border-color:#46b8da}.btn-info.focus,.btn-info:focus{color:#fff;background-color:#31b0d5;border-color:#1b6d85}.btn-info.active,.btn-info:active,.btn-info:hover,.open>.dropdown-toggle.btn-info{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info.active.focus,.btn-info.active:focus,.btn-info.active:hover,.btn-info:active.focus,.btn-info:active:focus,.btn-info:active:hover,.open>.dropdown-toggle.btn-info.focus,.open>.dropdown-toggle.btn-info:focus,.open>.dropdown-toggle.btn-info:hover{color:#fff;background-color:#269abc;border-color:#1b6d85}.btn-info.active,.btn-info:active,.open>.dropdown-toggle.btn-info{background-image:none}.btn-info.disabled.focus,.btn-info.disabled:focus,.btn-info.disabled:hover,.btn-info[disabled].focus,.btn-info[disabled]:focus,.btn-info[disabled]:hover,fieldset[disabled] .btn-info.focus,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:hover{background-color:#5bc0de;border-color:#46b8da}.btn-info .badge{color:#5bc0de;background-color:#fff}.btn-warning{color:#fff;background-color:#f0ad4e;border-color:#eea236}.btn-warning.focus,.btn-warning:focus{color:#fff;background-color:#ec971f;border-color:#985f0d}.btn-warning.active,.btn-warning:active,.btn-warning:hover,.open>.dropdown-toggle.btn-warning{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning.active.focus,.btn-warning.active:focus,.btn-warning.active:hover,.btn-warning:active.focus,.btn-warning:active:focus,.btn-warning:active:hover,.open>.dropdown-toggle.btn-warning.focus,.open>.dropdown-toggle.btn-warning:focus,.open>.dropdown-toggle.btn-warning:hover{color:#fff;background-color:#d58512;border-color:#985f0d}.btn-warning.active,.btn-warning:active,.open>.dropdown-toggle.btn-warning{background-image:none}.btn-warning.disabled.focus,.btn-warning.disabled:focus,.btn-warning.disabled:hover,.btn-warning[disabled].focus,.btn-warning[disabled]:focus,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning.focus,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:hover{background-color:#f0ad4e;border-color:#eea236}.btn-warning .badge{color:#f0ad4e;background-color:#fff}.btn-danger{color:#fff;background-color:#d9534f;border-color:#d43f3a}.btn-danger.focus,.btn-danger:focus{color:#fff;background-color:#c9302c;border-color:#761c19}.btn-danger.active,.btn-danger:active,.btn-danger:hover,.open>.dropdown-toggle.btn-danger{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger.active.focus,.btn-danger.active:focus,.btn-danger.active:hover,.btn-danger:active.focus,.btn-danger:active:focus,.btn-danger:active:hover,.open>.dropdown-toggle.btn-danger.focus,.open>.dropdown-toggle.btn-danger:focus,.open>.dropdown-toggle.btn-danger:hover{color:#fff;background-color:#ac2925;border-color:#761c19}.btn-danger.active,.btn-danger:active,.open>.dropdown-toggle.btn-danger{background-image:none}.btn-danger.disabled.focus,.btn-danger.disabled:focus,.btn-danger.disabled:hover,.btn-danger[disabled].focus,.btn-danger[disabled]:focus,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger.focus,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:hover{background-color:#d9534f;border-color:#d43f3a}.btn-danger .badge{color:#d9534f;background-color:#fff}.btn-link{color:#337ab7;font-weight:400;border-radius:0}.btn-link,.btn-link.active,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.btn-link,.btn-link:active,.btn-link:focus,.btn-link:hover{border-color:transparent}.btn-link:focus,.btn-link:hover{color:#23527c;text-decoration:underline;background-color:transparent}.btn-link[disabled]:focus,.btn-link[disabled]:hover,fieldset[disabled] .btn-link:focus,fieldset[disabled] .btn-link:hover{color:#777;text-decoration:none}.btn-group-lg>.btn,.btn-lg{padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}.btn-group-sm>.btn,.btn-sm{padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.btn-group-xs>.btn,.btn-xs{padding:1px 5px;font-size:12px;line-height:1.5;border-radius:3px}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type=button].btn-block,input[type=reset].btn-block,input[type=submit].btn-block{width:100%}.caret{display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-top:4px dashed;border-top:4px solid\\\\9;border-right:4px solid transparent;border-left:4px solid transparent}.dropdown,.dropup{position:relative}.dropdown-toggle:focus{outline:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;list-style:none;font-size:14px;text-align:left;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,.15);border-radius:4px;-webkit-box-shadow:0 6px 12px rgba(0,0,0,.175);box-shadow:0 6px 12px rgba(0,0,0,.175);-webkit-background-clip:padding-box;background-clip:padding-box}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:400;line-height:1.42857143;color:#333;white-space:nowrap}.dropdown-menu>li>a:focus,.dropdown-menu>li>a:hover{text-decoration:none;color:#262626;background-color:#f5f5f5}.dropdown-menu>.active>a,.dropdown-menu>.active>a:focus,.dropdown-menu>.active>a:hover{color:#fff;text-decoration:none;outline:0;background-color:#337ab7}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{color:#777}.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{text-decoration:none;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled = false);cursor:not-allowed}.open>.dropdown-menu{display:block}.open>a{outline:0}.dropdown-menu-right{left:auto;right:0}.dropdown-menu-left{left:0;right:auto}.dropdown-header{display:block;padding:3px 20px;font-size:12px;line-height:1.42857143;color:#777;white-space:nowrap}.dropdown-backdrop{position:fixed;left:0;right:0;bottom:0;top:0;z-index:990}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{border-top:0;border-bottom:4px dashed;border-bottom:4px solid\\\\9;content:\\"\\"}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:2px}@media (min-width:768px){.navbar-right .dropdown-menu{left:auto;right:0}.navbar-right .dropdown-menu-left{left:0;right:auto}}.btn-group,.btn-group-vertical{position:relative;display:inline-block;vertical-align:middle}.btn-group-vertical>.btn,.btn-group>.btn{position:relative;float:left}.btn-group-vertical>.btn.active,.btn-group-vertical>.btn:active,.btn-group-vertical>.btn:focus,.btn-group-vertical>.btn:hover,.btn-group>.btn.active,.btn-group>.btn:active,.btn-group>.btn:focus,.btn-group>.btn:hover{z-index:2}.btn-group .btn+.btn,.btn-group .btn+.btn-group,.btn-group .btn-group+.btn,.btn-group .btn-group+.btn-group{margin-left:-1px}.btn-toolbar{margin-left:-5px}.btn-toolbar .btn,.btn-toolbar .btn-group,.btn-toolbar .input-group{float:left}.btn-toolbar>.btn,.btn-toolbar>.btn-group,.btn-toolbar>.input-group{margin-left:5px}.btn-group>.btn:not(:first-child):not(:last-child):not(.dropdown-toggle){border-radius:0}.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn:first-child:not(:last-child):not(.dropdown-toggle){border-bottom-right-radius:0;border-top-right-radius:0}.btn-group>.btn:last-child:not(:first-child),.btn-group>.dropdown-toggle:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0}.btn-group>.btn-group{float:left}.btn-group>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-top-right-radius:0}.btn-group>.btn-group:last-child:not(:first-child)>.btn:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{padding-left:8px;padding-right:8px}.btn-group>.btn-lg+.dropdown-toggle{padding-left:12px;padding-right:12px}.btn-group.open .dropdown-toggle{-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn-group.open .dropdown-toggle.btn-link{-webkit-box-shadow:none;box-shadow:none}.btn .caret{margin-left:0}.btn-lg .caret{border-width:5px 5px 0;border-bottom-width:0}.dropup .btn-lg .caret{border-width:0 5px 5px}.btn-group-vertical>.btn,.btn-group-vertical>.btn-group,.btn-group-vertical>.btn-group>.btn{display:block;float:none;width:100%;max-width:100%}.btn-group-vertical>.btn-group>.btn{float:none}.btn-group-vertical>.btn+.btn,.btn-group-vertical>.btn+.btn-group,.btn-group-vertical>.btn-group+.btn,.btn-group-vertical>.btn-group+.btn-group{margin-top:-1px;margin-left:0}.btn-group-vertical>.btn:not(:first-child):not(:last-child){border-radius:0}.btn-group-vertical>.btn:first-child:not(:last-child){border-top-right-radius:4px;border-top-left-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn:last-child:not(:first-child){border-top-right-radius:0;border-top-left-radius:0;border-bottom-right-radius:4px;border-bottom-left-radius:4px}.btn-group-vertical>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group-vertical>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group-vertical>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-right-radius:0;border-top-left-radius:0}.btn-group-justified{display:table;width:100%;table-layout:fixed;border-collapse:separate}.btn-group-justified>.btn,.btn-group-justified>.btn-group{float:none;display:table-cell;width:1%}.btn-group-justified>.btn-group .btn{width:100%}.btn-group-justified>.btn-group .dropdown-menu{left:auto}[data-toggle=buttons]>.btn-group>.btn input[type=checkbox],[data-toggle=buttons]>.btn-group>.btn input[type=radio],[data-toggle=buttons]>.btn input[type=checkbox],[data-toggle=buttons]>.btn input[type=radio]{position:absolute;clip:rect(0,0,0,0);pointer-events:none}.tooltip{position:absolute;z-index:1070;display:block;font-family:Helvetica Neue,Helvetica,Arial,sans-serif;font-style:normal;font-weight:400;letter-spacing:normal;line-break:auto;line-height:1.42857143;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;white-space:normal;word-break:normal;word-spacing:normal;word-wrap:normal;font-size:12px;opacity:0;filter:alpha(opacity=0)}.tooltip.in{opacity:.9;filter:alpha(opacity=90)}.tooltip.top{margin-top:-3px;padding:5px 0}.tooltip.right{margin-left:3px;padding:0 5px}.tooltip.bottom{margin-top:3px;padding:5px 0}.tooltip.left{margin-left:-3px;padding:0 5px}.tooltip-inner{max-width:200px;padding:3px 8px;color:#fff;text-align:center;background-color:#000;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-left .tooltip-arrow{right:5px}.tooltip.top-left .tooltip-arrow,.tooltip.top-right .tooltip-arrow{bottom:0;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-right .tooltip-arrow{left:5px}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-width:5px 5px 5px 0;border-right-color:#000}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-width:5px 0 5px 5px;border-left-color:#000}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-left .tooltip-arrow{top:0;right:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-right .tooltip-arrow{top:0;left:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.btn-group-vertical>.btn-group:after,.btn-group-vertical>.btn-group:before,.btn-toolbar:after,.btn-toolbar:before,.clearfix:after,.clearfix:before{content:\\" \\";display:table}.btn-group-vertical>.btn-group:after,.btn-toolbar:after,.clearfix:after{clear:both}.center-block{display:block;margin-left:auto;margin-right:auto}.pull-right{float:right!important}.pull-left{float:left!important}.hide{display:none!important}.show{display:block!important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none!important}.affix{position:fixed}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC5taW4uY3NzPzlhYWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSwycUJBQTRxQix1QkFBdUIsMEJBQTBCLDhCQUE4QiwyRkFBMkYsY0FBYyw0QkFBNEIscUJBQXFCLHdCQUF3QixzQkFBc0IsYUFBYSxTQUFTLGtCQUFrQixhQUFhLEVBQUUsNkJBQTZCLGlCQUFpQixVQUFVLFlBQVkseUJBQXlCLFNBQVMsZ0JBQWdCLElBQUksa0JBQWtCLEdBQUcsY0FBYyxlQUFlLEtBQUssZ0JBQWdCLFdBQVcsTUFBTSxjQUFjLFFBQVEsY0FBYyxjQUFjLGtCQUFrQix3QkFBd0IsSUFBSSxVQUFVLElBQUksY0FBYyxJQUFJLFNBQVMsZUFBZSxnQkFBZ0IsT0FBTyxnQkFBZ0IsR0FBRywrQkFBK0IsNEJBQTRCLHVCQUF1QixTQUFTLElBQUksY0FBYyxrQkFBa0IsZ0NBQWdDLGNBQWMsc0NBQXNDLGNBQWMsYUFBYSxTQUFTLE9BQU8saUJBQWlCLGNBQWMsb0JBQW9CLG9FQUFvRSwwQkFBMEIsZUFBZSxzQ0FBc0MsZUFBZSxpREFBaUQsU0FBUyxVQUFVLE1BQU0sbUJBQW1CLHVDQUF1Qyw4QkFBOEIsMkJBQTJCLHNCQUFzQixVQUFVLDRGQUE0RixZQUFZLG1CQUFtQiw2QkFBNkIsK0JBQStCLDRCQUE0Qix1QkFBdUIsK0ZBQStGLHdCQUF3QixTQUFTLHdCQUF3QixhQUFhLDJCQUEyQixPQUFPLFNBQVMsVUFBVSxTQUFTLGNBQWMsU0FBUyxnQkFBZ0IsTUFBTSx5QkFBeUIsaUJBQWlCLE1BQU0sVUFBVSxpQkFBaUIsOEJBQThCLDJCQUEyQixzQkFBc0IsS0FBSyxlQUFlLDBDQUEwQyxLQUFLLHNEQUFzRCxlQUFlLHVCQUF1QixXQUFXLHNCQUFzQiw2QkFBNkIsb0JBQW9CLGtCQUFrQixvQkFBb0IsRUFBRSxjQUFjLHFCQUFxQixnQkFBZ0IsY0FBYywwQkFBMEIsUUFB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UyxpQkFBaUIsdUJBQXVCLHlCQUF5QixvQ0FBb0MsTUFBTSxVQUFVLGdCQUFnQix1QkFBdUIseUJBQXlCLHFDQUFxQyxNQUFNLFNBQVMsZ0JBQWdCLHVCQUF1Qix5QkFBeUIsbUpBQW1KLGNBQWMsY0FBYyx3RUFBd0UsV0FBVyxjQUFjLGNBQWMsaUJBQWlCLGtCQUFrQixZQUFZLHNCQUFzQixXQUFXLHFCQUFxQixNQUFNLHVCQUF1QixNQUFNLHdCQUF3QixXQUFXLGtCQUFrQixXQUFXLFdBQVcsa0JBQWtCLGlCQUFpQiw2QkFBNkIsU0FBUyxRQUFRLHVCQUF1QixPQUFPLGVBQWU7O0FBRXBwcEIiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiFcXG4gKiBCb290c3RyYXAgdjMuMy43IChodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbSlcXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE3IFR3aXR0ZXIsIEluYy5cXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxcbiAqL1xcblxcbi8qIVxcbiAqIEdlbmVyYXRlZCB1c2luZyB0aGUgQm9vdHN0cmFwIEN1c3RvbWl6ZXIgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS9kb2NzLzMuMy9jdXN0b21pemUvP2lkPTY3MjljYTViZmViZDBiNjVlMGYxNWYxMjE5MDJiMDdkKVxcbiAqIENvbmZpZyBzYXZlZCB0byBjb25maWcuanNvbiBhbmQgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vNjcyOWNhNWJmZWJkMGI2NWUwZjE1ZjEyMTkwMmIwN2RcXG4gKi8vKiFcXG4gKiBCb290c3RyYXAgdjMuMy43IChodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbSlcXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE2IFR3aXR0ZXIsIEluYy5cXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxcbiAqLy8qISBub3JtYWxpemUuY3NzIHYzLjAuMyB8IE1JVCBMaWNlbnNlIHwgZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MgKi9odG1se2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWY7LW1zLXRleHQtc2l6ZS1hZGp1c3Q6MTAwJTstd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6MTAwJX1hcnRpY2xlLGFzaWRlLGRldGFpbHMsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsbWFpbixtZW51LG5hdixzZWN0aW9uLHN1bW1hcnl7ZGlzcGxheTpibG9ja31hdWRpbyxjYW52YXMscHJvZ3Jlc3MsdmlkZW97ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9YXVkaW86bm90KFtjb250cm9sc10pe2Rpc3BsYXk6bm9uZTtoZWlnaHQ6MH1baGlkZGVuXSx0ZW1wbGF0ZXtkaXNwbGF5Om5vbmV9YXtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fWE6YWN0aXZlLGE6aG92ZXJ7b3V0bGluZTowfWFiYnJbdGl0bGVde2JvcmRlci1ib3R0b206MXB4IGRvdHRlZH1iLHN0cm9uZ3tmb250LXdlaWdodDo3MDB9ZGZue2ZvbnQtc3R5bGU6aXRhbGljfWgxe2ZvbnQtc2l6ZToyZW07bWFyZ2luOi42N2VtIDB9bWFya3tiYWNrZ3JvdW5kOiNmZjA7Y29sb3I6IzAwMH1zbWFsbHtmb250LXNpemU6ODAlfXN1YixzdXB7Zm9udC1zaXplOjc1JTtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfXN1cHt0b3A6LS41ZW19c3Vie2JvdHRvbTotLjI1ZW19aW1ne2JvcmRlcjowfXN2Zzpub3QoOnJvb3Qpe292ZXJmbG93OmhpZGRlbn1maWd1cmV7bWFyZ2luOjFlbSA0MHB4fWhyey13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtoZWlnaHQ6MH1wcmV7b3ZlcmZsb3c6YXV0b31jb2RlLGtiZCxwcmUsc2FtcHtmb250LWZhbWlseTptb25vc3BhY2UsbW9ub3NwYWNlO2ZvbnQtc2l6ZToxZW19YnV0dG9uLGlucHV0LG9wdGdyb3VwLHNlbGVjdCx0ZXh0YXJlYXtjb2xvcjppbmhlcml0O2ZvbnQ6aW5oZXJpdDttYXJnaW46MH1idXR0b257b3ZlcmZsb3c6dmlzaWJsZX1idXR0b24sc2VsZWN0e3RleHQtdHJhbnNmb3JtOm5vbmV9YnV0dG9uLGh0bWwgaW5wdXRbdHlwZT1idXR0b25dLGlucHV0W3R5cGU9cmVzZXRdLGlucHV0W3R5cGU9c3VibWl0XXstd2Via2l0LWFwcGVhcmFuY2U6YnV0dG9uO2N1cnNvcjpwb2ludGVyfWJ1dHRvbltkaXNhYmxlZF0saHRtbCBpbnB1dFtkaXNhYmxlZF17Y3Vyc29yOmRlZmF1bHR9YnV0dG9uOjotbW96LWZvY3VzLWlubmVyLGlucHV0OjotbW96LWZvY3VzLWlubmVye2JvcmRlcjowO3BhZGRpbmc6MH1pbnB1dHtsaW5lLWhlaWdodDpub3JtYWx9aW5wdXRbdHlwZT1jaGVja2JveF0saW5wdXRbdHlwZT1yYWRpb117LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6MH1pbnB1dFt0eXBlPW51bWJlcl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24saW5wdXRbdHlwZT1udW1iZXJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9ue2hlaWdodDphdXRvfWlucHV0W3R5cGU9c2VhcmNoXXstd2Via2l0LWFwcGVhcmFuY2U6dGV4dGZpZWxkOy13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveH1pbnB1dFt0eXBlPXNlYXJjaF06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24saW5wdXRbdHlwZT1zZWFyY2hdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uey13ZWJraXQtYXBwZWFyYW5jZTpub25lfWZpZWxkc2V0e2JvcmRlcjoxcHggc29saWQgc2lsdmVyO21hcmdpbjowIDJweDtwYWRkaW5nOi4zNWVtIC42MjVlbSAuNzVlbX1sZWdlbmR7Ym9yZGVyOjA7cGFkZGluZzowfXRleHRhcmVhe292ZXJmbG93OmF1dG99b3B0Z3JvdXB7Zm9udC13ZWlnaHQ6NzAwfXRhYmxle2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZTtib3JkZXItc3BhY2luZzowfXRkLHRoe3BhZGRpbmc6MH0qLDphZnRlciw6YmVmb3Jley13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH1odG1se2ZvbnQtc2l6ZToxMHB4Oy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjpyZ2JhKDAsMCwwLDApfWJvZHl7Zm9udC1mYW1pbHk6SGVsdmV0aWNhIE5ldWUsSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS40Mjg1NzE0Mztjb2xvcjojMzMzO2JhY2tncm91bmQtY29sb3I6I2ZmZn1idXR0b24saW5wdXQsc2VsZWN0LHRleHRhcmVhe2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOmluaGVyaXQ7bGluZS1oZWlnaHQ6aW5oZXJpdH1he2NvbG9yOiMzMzdhYjc7dGV4dC1kZWNvcmF0aW9uOm5vbmV9YTpmb2N1cyxhOmhvdmVye2NvbG9yOiMyMzUyN2M7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZX1hOmZvY3Vze291dGxpbmU6NXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yO291dGxpbmUtb2Zmc2V0Oi0ycHh9ZmlndXJle21hcmdpbjowfWltZ3t2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmltZy1yZXNwb25zaXZle2Rpc3BsYXk6YmxvY2s7bWF4LXdpZHRoOjEwMCU7aGVpZ2h0OmF1dG99LmltZy1yb3VuZGVke2JvcmRlci1yYWRpdXM6NnB4fS5pbWctdGh1bWJuYWlse3BhZGRpbmc6NHB4O2xpbmUtaGVpZ2h0OjEuNDI4NTcxNDM7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI2RkZDtib3JkZXItcmFkaXVzOjRweDstd2Via2l0LXRyYW5zaXRpb246YWxsIC4ycyBlYXNlLWluLW91dDstby10cmFuc2l0aW9uOmFsbCAuMnMgZWFzZS1pbi1vdXQ7dHJhbnNpdGlvbjphbGwgLjJzIGVhc2UtaW4tb3V0O2Rpc3BsYXk6aW5saW5lLWJsb2NrO21heC13aWR0aDoxMDAlO2hlaWdodDphdXRvfS5pbWctY2lyY2xle2JvcmRlci1yYWRpdXM6NTAlfWhye21hcmdpbi10b3A6MjBweDttYXJnaW4tYm90dG9tOjIwcHg7Ym9yZGVyOjA7Ym9yZGVyLXRvcDoxcHggc29saWQgI2VlZX0uc3Itb25seXtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxcHg7aGVpZ2h0OjFweDttYXJnaW46LTFweDtwYWRkaW5nOjA7b3ZlcmZsb3c6aGlkZGVuO2NsaXA6cmVjdCgwLDAsMCwwKTtib3JkZXI6MH0uc3Itb25seS1mb2N1c2FibGU6YWN0aXZlLC5zci1vbmx5LWZvY3VzYWJsZTpmb2N1c3twb3NpdGlvbjpzdGF0aWM7d2lkdGg6YXV0bztoZWlnaHQ6YXV0bzttYXJnaW46MDtvdmVyZmxvdzp2aXNpYmxlO2NsaXA6YXV0b30uYnRuLFtyb2xlPWJ1dHRvbl17Y3Vyc29yOnBvaW50ZXJ9LmJ0bntkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tYm90dG9tOjA7Zm9udC13ZWlnaHQ6NDAwO3RleHQtYWxpZ246Y2VudGVyO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTstbXMtdG91Y2gtYWN0aW9uOm1hbmlwdWxhdGlvbjt0b3VjaC1hY3Rpb246bWFuaXB1bGF0aW9uO2JhY2tncm91bmQtaW1hZ2U6bm9uZTtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O3doaXRlLXNwYWNlOm5vd3JhcDtwYWRkaW5nOjZweCAxMnB4O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjEuNDI4NTcxNDM7Ym9yZGVyLXJhZGl1czo0cHg7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5idG4uYWN0aXZlLmZvY3VzLC5idG4uYWN0aXZlOmZvY3VzLC5idG4uZm9jdXMsLmJ0bjphY3RpdmUuZm9jdXMsLmJ0bjphY3RpdmU6Zm9jdXMsLmJ0bjpmb2N1c3tvdXRsaW5lOjVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcjtvdXRsaW5lLW9mZnNldDotMnB4fS5idG4uZm9jdXMsLmJ0bjpmb2N1cywuYnRuOmhvdmVye2NvbG9yOiMzMzM7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmJ0bi5hY3RpdmUsLmJ0bjphY3RpdmV7b3V0bGluZTowO2JhY2tncm91bmQtaW1hZ2U6bm9uZTstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAzcHggNXB4IHJnYmEoMCwwLDAsLjEyNSk7Ym94LXNoYWRvdzppbnNldCAwIDNweCA1cHggcmdiYSgwLDAsMCwuMTI1KX0uYnRuLmRpc2FibGVkLC5idG5bZGlzYWJsZWRdLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRue2N1cnNvcjpub3QtYWxsb3dlZDtvcGFjaXR5Oi42NTtmaWx0ZXI6YWxwaGEob3BhY2l0eT02NSk7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lfWEuYnRuLmRpc2FibGVkLGZpZWxkc2V0W2Rpc2FibGVkXSBhLmJ0bntwb2ludGVyLWV2ZW50czpub25lfS5idG4tZGVmYXVsdHtjb2xvcjojMzMzO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXItY29sb3I6I2NjY30uYnRuLWRlZmF1bHQuZm9jdXMsLmJ0bi1kZWZhdWx0OmZvY3Vze2NvbG9yOiMzMzM7YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2O2JvcmRlci1jb2xvcjojOGM4YzhjfS5idG4tZGVmYXVsdC5hY3RpdmUsLmJ0bi1kZWZhdWx0OmFjdGl2ZSwuYnRuLWRlZmF1bHQ6aG92ZXIsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tZGVmYXVsdHtjb2xvcjojMzMzO2JhY2tncm91bmQtY29sb3I6I2U2ZTZlNjtib3JkZXItY29sb3I6I2FkYWRhZH0uYnRuLWRlZmF1bHQuYWN0aXZlLmZvY3VzLC5idG4tZGVmYXVsdC5hY3RpdmU6Zm9jdXMsLmJ0bi1kZWZhdWx0LmFjdGl2ZTpob3ZlciwuYnRuLWRlZmF1bHQ6YWN0aXZlLmZvY3VzLC5idG4tZGVmYXVsdDphY3RpdmU6Zm9jdXMsLmJ0bi1kZWZhdWx0OmFjdGl2ZTpob3Zlciwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1kZWZhdWx0LmZvY3VzLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLWRlZmF1bHQ6Zm9jdXMsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tZGVmYXVsdDpob3Zlcntjb2xvcjojMzMzO2JhY2tncm91bmQtY29sb3I6I2Q0ZDRkNDtib3JkZXItY29sb3I6IzhjOGM4Y30uYnRuLWRlZmF1bHQuYWN0aXZlLC5idG4tZGVmYXVsdDphY3RpdmUsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tZGVmYXVsdHtiYWNrZ3JvdW5kLWltYWdlOm5vbmV9LmJ0bi1kZWZhdWx0LmRpc2FibGVkLmZvY3VzLC5idG4tZGVmYXVsdC5kaXNhYmxlZDpmb2N1cywuYnRuLWRlZmF1bHQuZGlzYWJsZWQ6aG92ZXIsLmJ0bi1kZWZhdWx0W2Rpc2FibGVkXS5mb2N1cywuYnRuLWRlZmF1bHRbZGlzYWJsZWRdOmZvY3VzLC5idG4tZGVmYXVsdFtkaXNhYmxlZF06aG92ZXIsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4tZGVmYXVsdC5mb2N1cyxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1kZWZhdWx0OmZvY3VzLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLWRlZmF1bHQ6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlci1jb2xvcjojY2NjfS5idG4tZGVmYXVsdCAuYmFkZ2V7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMzMzN9LmJ0bi1wcmltYXJ5e2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMzM3YWI3O2JvcmRlci1jb2xvcjojMmU2ZGE0fS5idG4tcHJpbWFyeS5mb2N1cywuYnRuLXByaW1hcnk6Zm9jdXN7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMyODYwOTA7Ym9yZGVyLWNvbG9yOiMxMjJiNDB9LmJ0bi1wcmltYXJ5LmFjdGl2ZSwuYnRuLXByaW1hcnk6YWN0aXZlLC5idG4tcHJpbWFyeTpob3Zlciwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1wcmltYXJ5e2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMjg2MDkwO2JvcmRlci1jb2xvcjojMjA0ZDc0fS5idG4tcHJpbWFyeS5hY3RpdmUuZm9jdXMsLmJ0bi1wcmltYXJ5LmFjdGl2ZTpmb2N1cywuYnRuLXByaW1hcnkuYWN0aXZlOmhvdmVyLC5idG4tcHJpbWFyeTphY3RpdmUuZm9jdXMsLmJ0bi1wcmltYXJ5OmFjdGl2ZTpmb2N1cywuYnRuLXByaW1hcnk6YWN0aXZlOmhvdmVyLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXByaW1hcnkuZm9jdXMsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tcHJpbWFyeTpmb2N1cywub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1wcmltYXJ5OmhvdmVye2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMjA0ZDc0O2JvcmRlci1jb2xvcjojMTIyYjQwfS5idG4tcHJpbWFyeS5hY3RpdmUsLmJ0bi1wcmltYXJ5OmFjdGl2ZSwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1wcmltYXJ5e2JhY2tncm91bmQtaW1hZ2U6bm9uZX0uYnRuLXByaW1hcnkuZGlzYWJsZWQuZm9jdXMsLmJ0bi1wcmltYXJ5LmRpc2FibGVkOmZvY3VzLC5idG4tcHJpbWFyeS5kaXNhYmxlZDpob3ZlciwuYnRuLXByaW1hcnlbZGlzYWJsZWRdLmZvY3VzLC5idG4tcHJpbWFyeVtkaXNhYmxlZF06Zm9jdXMsLmJ0bi1wcmltYXJ5W2Rpc2FibGVkXTpob3ZlcixmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1wcmltYXJ5LmZvY3VzLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLXByaW1hcnk6Zm9jdXMsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4tcHJpbWFyeTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMzMzdhYjc7Ym9yZGVyLWNvbG9yOiMyZTZkYTR9LmJ0bi1wcmltYXJ5IC5iYWRnZXtjb2xvcjojMzM3YWI3O2JhY2tncm91bmQtY29sb3I6I2ZmZn0uYnRuLXN1Y2Nlc3N7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiM1Y2I4NWM7Ym9yZGVyLWNvbG9yOiM0Y2FlNGN9LmJ0bi1zdWNjZXNzLmZvY3VzLC5idG4tc3VjY2Vzczpmb2N1c3tjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzQ0OWQ0NDtib3JkZXItY29sb3I6IzI1NTYyNX0uYnRuLXN1Y2Nlc3MuYWN0aXZlLC5idG4tc3VjY2VzczphY3RpdmUsLmJ0bi1zdWNjZXNzOmhvdmVyLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXN1Y2Nlc3N7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiM0NDlkNDQ7Ym9yZGVyLWNvbG9yOiMzOTg0Mzl9LmJ0bi1zdWNjZXNzLmFjdGl2ZS5mb2N1cywuYnRuLXN1Y2Nlc3MuYWN0aXZlOmZvY3VzLC5idG4tc3VjY2Vzcy5hY3RpdmU6aG92ZXIsLmJ0bi1zdWNjZXNzOmFjdGl2ZS5mb2N1cywuYnRuLXN1Y2Nlc3M6YWN0aXZlOmZvY3VzLC5idG4tc3VjY2VzczphY3RpdmU6aG92ZXIsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tc3VjY2Vzcy5mb2N1cywub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1zdWNjZXNzOmZvY3VzLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXN1Y2Nlc3M6aG92ZXJ7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMzOTg0Mzk7Ym9yZGVyLWNvbG9yOiMyNTU2MjV9LmJ0bi1zdWNjZXNzLmFjdGl2ZSwuYnRuLXN1Y2Nlc3M6YWN0aXZlLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXN1Y2Nlc3N7YmFja2dyb3VuZC1pbWFnZTpub25lfS5idG4tc3VjY2Vzcy5kaXNhYmxlZC5mb2N1cywuYnRuLXN1Y2Nlc3MuZGlzYWJsZWQ6Zm9jdXMsLmJ0bi1zdWNjZXNzLmRpc2FibGVkOmhvdmVyLC5idG4tc3VjY2Vzc1tkaXNhYmxlZF0uZm9jdXMsLmJ0bi1zdWNjZXNzW2Rpc2FibGVkXTpmb2N1cywuYnRuLXN1Y2Nlc3NbZGlzYWJsZWRdOmhvdmVyLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLXN1Y2Nlc3MuZm9jdXMsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4tc3VjY2Vzczpmb2N1cyxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1zdWNjZXNzOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzVjYjg1Yztib3JkZXItY29sb3I6IzRjYWU0Y30uYnRuLXN1Y2Nlc3MgLmJhZGdle2NvbG9yOiM1Y2I4NWM7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5idG4taW5mb3tjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzViYzBkZTtib3JkZXItY29sb3I6IzQ2YjhkYX0uYnRuLWluZm8uZm9jdXMsLmJ0bi1pbmZvOmZvY3Vze2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMzFiMGQ1O2JvcmRlci1jb2xvcjojMWI2ZDg1fS5idG4taW5mby5hY3RpdmUsLmJ0bi1pbmZvOmFjdGl2ZSwuYnRuLWluZm86aG92ZXIsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4taW5mb3tjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzMxYjBkNTtib3JkZXItY29sb3I6IzI2OWFiY30uYnRuLWluZm8uYWN0aXZlLmZvY3VzLC5idG4taW5mby5hY3RpdmU6Zm9jdXMsLmJ0bi1pbmZvLmFjdGl2ZTpob3ZlciwuYnRuLWluZm86YWN0aXZlLmZvY3VzLC5idG4taW5mbzphY3RpdmU6Zm9jdXMsLmJ0bi1pbmZvOmFjdGl2ZTpob3Zlciwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1pbmZvLmZvY3VzLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLWluZm86Zm9jdXMsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4taW5mbzpob3Zlcntjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzI2OWFiYztib3JkZXItY29sb3I6IzFiNmQ4NX0uYnRuLWluZm8uYWN0aXZlLC5idG4taW5mbzphY3RpdmUsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4taW5mb3tiYWNrZ3JvdW5kLWltYWdlOm5vbmV9LmJ0bi1pbmZvLmRpc2FibGVkLmZvY3VzLC5idG4taW5mby5kaXNhYmxlZDpmb2N1cywuYnRuLWluZm8uZGlzYWJsZWQ6aG92ZXIsLmJ0bi1pbmZvW2Rpc2FibGVkXS5mb2N1cywuYnRuLWluZm9bZGlzYWJsZWRdOmZvY3VzLC5idG4taW5mb1tkaXNhYmxlZF06aG92ZXIsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4taW5mby5mb2N1cyxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1pbmZvOmZvY3VzLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLWluZm86aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojNWJjMGRlO2JvcmRlci1jb2xvcjojNDZiOGRhfS5idG4taW5mbyAuYmFkZ2V7Y29sb3I6IzViYzBkZTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LmJ0bi13YXJuaW5ne2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojZjBhZDRlO2JvcmRlci1jb2xvcjojZWVhMjM2fS5idG4td2FybmluZy5mb2N1cywuYnRuLXdhcm5pbmc6Zm9jdXN7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiNlYzk3MWY7Ym9yZGVyLWNvbG9yOiM5ODVmMGR9LmJ0bi13YXJuaW5nLmFjdGl2ZSwuYnRuLXdhcm5pbmc6YWN0aXZlLC5idG4td2FybmluZzpob3Zlciwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi13YXJuaW5ne2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojZWM5NzFmO2JvcmRlci1jb2xvcjojZDU4NTEyfS5idG4td2FybmluZy5hY3RpdmUuZm9jdXMsLmJ0bi13YXJuaW5nLmFjdGl2ZTpmb2N1cywuYnRuLXdhcm5pbmcuYWN0aXZlOmhvdmVyLC5idG4td2FybmluZzphY3RpdmUuZm9jdXMsLmJ0bi13YXJuaW5nOmFjdGl2ZTpmb2N1cywuYnRuLXdhcm5pbmc6YWN0aXZlOmhvdmVyLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXdhcm5pbmcuZm9jdXMsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4td2FybmluZzpmb2N1cywub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi13YXJuaW5nOmhvdmVye2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojZDU4NTEyO2JvcmRlci1jb2xvcjojOTg1ZjBkfS5idG4td2FybmluZy5hY3RpdmUsLmJ0bi13YXJuaW5nOmFjdGl2ZSwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi13YXJuaW5ne2JhY2tncm91bmQtaW1hZ2U6bm9uZX0uYnRuLXdhcm5pbmcuZGlzYWJsZWQuZm9jdXMsLmJ0bi13YXJuaW5nLmRpc2FibGVkOmZvY3VzLC5idG4td2FybmluZy5kaXNhYmxlZDpob3ZlciwuYnRuLXdhcm5pbmdbZGlzYWJsZWRdLmZvY3VzLC5idG4td2FybmluZ1tkaXNhYmxlZF06Zm9jdXMsLmJ0bi13YXJuaW5nW2Rpc2FibGVkXTpob3ZlcixmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi13YXJuaW5nLmZvY3VzLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLXdhcm5pbmc6Zm9jdXMsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4td2FybmluZzpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmMGFkNGU7Ym9yZGVyLWNvbG9yOiNlZWEyMzZ9LmJ0bi13YXJuaW5nIC5iYWRnZXtjb2xvcjojZjBhZDRlO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uYnRuLWRhbmdlcntjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6I2Q5NTM0Zjtib3JkZXItY29sb3I6I2Q0M2YzYX0uYnRuLWRhbmdlci5mb2N1cywuYnRuLWRhbmdlcjpmb2N1c3tjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6I2M5MzAyYztib3JkZXItY29sb3I6Izc2MWMxOX0uYnRuLWRhbmdlci5hY3RpdmUsLmJ0bi1kYW5nZXI6YWN0aXZlLC5idG4tZGFuZ2VyOmhvdmVyLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLWRhbmdlcntjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6I2M5MzAyYztib3JkZXItY29sb3I6I2FjMjkyNX0uYnRuLWRhbmdlci5hY3RpdmUuZm9jdXMsLmJ0bi1kYW5nZXIuYWN0aXZlOmZvY3VzLC5idG4tZGFuZ2VyLmFjdGl2ZTpob3ZlciwuYnRuLWRhbmdlcjphY3RpdmUuZm9jdXMsLmJ0bi1kYW5nZXI6YWN0aXZlOmZvY3VzLC5idG4tZGFuZ2VyOmFjdGl2ZTpob3Zlciwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1kYW5nZXIuZm9jdXMsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tZGFuZ2VyOmZvY3VzLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLWRhbmdlcjpob3Zlcntjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6I2FjMjkyNTtib3JkZXItY29sb3I6Izc2MWMxOX0uYnRuLWRhbmdlci5hY3RpdmUsLmJ0bi1kYW5nZXI6YWN0aXZlLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLWRhbmdlcntiYWNrZ3JvdW5kLWltYWdlOm5vbmV9LmJ0bi1kYW5nZXIuZGlzYWJsZWQuZm9jdXMsLmJ0bi1kYW5nZXIuZGlzYWJsZWQ6Zm9jdXMsLmJ0bi1kYW5nZXIuZGlzYWJsZWQ6aG92ZXIsLmJ0bi1kYW5nZXJbZGlzYWJsZWRdLmZvY3VzLC5idG4tZGFuZ2VyW2Rpc2FibGVkXTpmb2N1cywuYnRuLWRhbmdlcltkaXNhYmxlZF06aG92ZXIsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4tZGFuZ2VyLmZvY3VzLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLWRhbmdlcjpmb2N1cyxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1kYW5nZXI6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZDk1MzRmO2JvcmRlci1jb2xvcjojZDQzZjNhfS5idG4tZGFuZ2VyIC5iYWRnZXtjb2xvcjojZDk1MzRmO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uYnRuLWxpbmt7Y29sb3I6IzMzN2FiNztmb250LXdlaWdodDo0MDA7Ym9yZGVyLXJhZGl1czowfS5idG4tbGluaywuYnRuLWxpbmsuYWN0aXZlLC5idG4tbGluazphY3RpdmUsLmJ0bi1saW5rW2Rpc2FibGVkXSxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1saW5re2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lfS5idG4tbGluaywuYnRuLWxpbms6YWN0aXZlLC5idG4tbGluazpmb2N1cywuYnRuLWxpbms6aG92ZXJ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50fS5idG4tbGluazpmb2N1cywuYnRuLWxpbms6aG92ZXJ7Y29sb3I6IzIzNTI3Yzt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9LmJ0bi1saW5rW2Rpc2FibGVkXTpmb2N1cywuYnRuLWxpbmtbZGlzYWJsZWRdOmhvdmVyLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLWxpbms6Zm9jdXMsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4tbGluazpob3Zlcntjb2xvcjojNzc3O3RleHQtZGVjb3JhdGlvbjpub25lfS5idG4tZ3JvdXAtbGc+LmJ0biwuYnRuLWxne3BhZGRpbmc6MTBweCAxNnB4O2ZvbnQtc2l6ZToxOHB4O2xpbmUtaGVpZ2h0OjEuMzMzMzMzMztib3JkZXItcmFkaXVzOjZweH0uYnRuLWdyb3VwLXNtPi5idG4sLmJ0bi1zbXtwYWRkaW5nOjVweCAxMHB4O2ZvbnQtc2l6ZToxMnB4O2xpbmUtaGVpZ2h0OjEuNTtib3JkZXItcmFkaXVzOjNweH0uYnRuLWdyb3VwLXhzPi5idG4sLmJ0bi14c3twYWRkaW5nOjFweCA1cHg7Zm9udC1zaXplOjEycHg7bGluZS1oZWlnaHQ6MS41O2JvcmRlci1yYWRpdXM6M3B4fS5idG4tYmxvY2t7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlfS5idG4tYmxvY2srLmJ0bi1ibG9ja3ttYXJnaW4tdG9wOjVweH1pbnB1dFt0eXBlPWJ1dHRvbl0uYnRuLWJsb2NrLGlucHV0W3R5cGU9cmVzZXRdLmJ0bi1ibG9jayxpbnB1dFt0eXBlPXN1Ym1pdF0uYnRuLWJsb2Nre3dpZHRoOjEwMCV9LmNhcmV0e2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7bWFyZ2luLWxlZnQ6MnB4O3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtib3JkZXItdG9wOjRweCBkYXNoZWQ7Ym9yZGVyLXRvcDo0cHggc29saWRcXFxcOTtib3JkZXItcmlnaHQ6NHB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjRweCBzb2xpZCB0cmFuc3BhcmVudH0uZHJvcGRvd24sLmRyb3B1cHtwb3NpdGlvbjpyZWxhdGl2ZX0uZHJvcGRvd24tdG9nZ2xlOmZvY3Vze291dGxpbmU6MH0uZHJvcGRvd24tbWVudXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTAwJTtsZWZ0OjA7ei1pbmRleDoxMDAwO2Rpc3BsYXk6bm9uZTtmbG9hdDpsZWZ0O21pbi13aWR0aDoxNjBweDtwYWRkaW5nOjVweCAwO21hcmdpbjoycHggMCAwO2xpc3Qtc3R5bGU6bm9uZTtmb250LXNpemU6MTRweDt0ZXh0LWFsaWduOmxlZnQ7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI2NjYztib3JkZXI6MXB4IHNvbGlkIHJnYmEoMCwwLDAsLjE1KTtib3JkZXItcmFkaXVzOjRweDstd2Via2l0LWJveC1zaGFkb3c6MCA2cHggMTJweCByZ2JhKDAsMCwwLC4xNzUpO2JveC1zaGFkb3c6MCA2cHggMTJweCByZ2JhKDAsMCwwLC4xNzUpOy13ZWJraXQtYmFja2dyb3VuZC1jbGlwOnBhZGRpbmctYm94O2JhY2tncm91bmQtY2xpcDpwYWRkaW5nLWJveH0uZHJvcGRvd24tbWVudS5wdWxsLXJpZ2h0e3JpZ2h0OjA7bGVmdDphdXRvfS5kcm9wZG93bi1tZW51IC5kaXZpZGVye2hlaWdodDoxcHg7bWFyZ2luOjlweCAwO292ZXJmbG93OmhpZGRlbjtiYWNrZ3JvdW5kLWNvbG9yOiNlNWU1ZTV9LmRyb3Bkb3duLW1lbnU+bGk+YXtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6M3B4IDIwcHg7Y2xlYXI6Ym90aDtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MS40Mjg1NzE0Mztjb2xvcjojMzMzO3doaXRlLXNwYWNlOm5vd3JhcH0uZHJvcGRvd24tbWVudT5saT5hOmZvY3VzLC5kcm9wZG93bi1tZW51PmxpPmE6aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7Y29sb3I6IzI2MjYyNjtiYWNrZ3JvdW5kLWNvbG9yOiNmNWY1ZjV9LmRyb3Bkb3duLW1lbnU+LmFjdGl2ZT5hLC5kcm9wZG93bi1tZW51Pi5hY3RpdmU+YTpmb2N1cywuZHJvcGRvd24tbWVudT4uYWN0aXZlPmE6aG92ZXJ7Y29sb3I6I2ZmZjt0ZXh0LWRlY29yYXRpb246bm9uZTtvdXRsaW5lOjA7YmFja2dyb3VuZC1jb2xvcjojMzM3YWI3fS5kcm9wZG93bi1tZW51Pi5kaXNhYmxlZD5hLC5kcm9wZG93bi1tZW51Pi5kaXNhYmxlZD5hOmZvY3VzLC5kcm9wZG93bi1tZW51Pi5kaXNhYmxlZD5hOmhvdmVye2NvbG9yOiM3Nzd9LmRyb3Bkb3duLW1lbnU+LmRpc2FibGVkPmE6Zm9jdXMsLmRyb3Bkb3duLW1lbnU+LmRpc2FibGVkPmE6aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtiYWNrZ3JvdW5kLWltYWdlOm5vbmU7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChlbmFibGVkID0gZmFsc2UpO2N1cnNvcjpub3QtYWxsb3dlZH0ub3Blbj4uZHJvcGRvd24tbWVudXtkaXNwbGF5OmJsb2NrfS5vcGVuPmF7b3V0bGluZTowfS5kcm9wZG93bi1tZW51LXJpZ2h0e2xlZnQ6YXV0bztyaWdodDowfS5kcm9wZG93bi1tZW51LWxlZnR7bGVmdDowO3JpZ2h0OmF1dG99LmRyb3Bkb3duLWhlYWRlcntkaXNwbGF5OmJsb2NrO3BhZGRpbmc6M3B4IDIwcHg7Zm9udC1zaXplOjEycHg7bGluZS1oZWlnaHQ6MS40Mjg1NzE0Mztjb2xvcjojNzc3O3doaXRlLXNwYWNlOm5vd3JhcH0uZHJvcGRvd24tYmFja2Ryb3B7cG9zaXRpb246Zml4ZWQ7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7dG9wOjA7ei1pbmRleDo5OTB9LnB1bGwtcmlnaHQ+LmRyb3Bkb3duLW1lbnV7cmlnaHQ6MDtsZWZ0OmF1dG99LmRyb3B1cCAuY2FyZXQsLm5hdmJhci1maXhlZC1ib3R0b20gLmRyb3Bkb3duIC5jYXJldHtib3JkZXItdG9wOjA7Ym9yZGVyLWJvdHRvbTo0cHggZGFzaGVkO2JvcmRlci1ib3R0b206NHB4IHNvbGlkXFxcXDk7Y29udGVudDpcXFwiXFxcIn0uZHJvcHVwIC5kcm9wZG93bi1tZW51LC5uYXZiYXItZml4ZWQtYm90dG9tIC5kcm9wZG93biAuZHJvcGRvd24tbWVudXt0b3A6YXV0bztib3R0b206MTAwJTttYXJnaW4tYm90dG9tOjJweH1AbWVkaWEgKG1pbi13aWR0aDo3NjhweCl7Lm5hdmJhci1yaWdodCAuZHJvcGRvd24tbWVudXtsZWZ0OmF1dG87cmlnaHQ6MH0ubmF2YmFyLXJpZ2h0IC5kcm9wZG93bi1tZW51LWxlZnR7bGVmdDowO3JpZ2h0OmF1dG99fS5idG4tZ3JvdXAsLmJ0bi1ncm91cC12ZXJ0aWNhbHtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuLC5idG4tZ3JvdXA+LmJ0bntwb3NpdGlvbjpyZWxhdGl2ZTtmbG9hdDpsZWZ0fS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi5hY3RpdmUsLmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuOmFjdGl2ZSwuYnRuLWdyb3VwLXZlcnRpY2FsPi5idG46Zm9jdXMsLmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuOmhvdmVyLC5idG4tZ3JvdXA+LmJ0bi5hY3RpdmUsLmJ0bi1ncm91cD4uYnRuOmFjdGl2ZSwuYnRuLWdyb3VwPi5idG46Zm9jdXMsLmJ0bi1ncm91cD4uYnRuOmhvdmVye3otaW5kZXg6Mn0uYnRuLWdyb3VwIC5idG4rLmJ0biwuYnRuLWdyb3VwIC5idG4rLmJ0bi1ncm91cCwuYnRuLWdyb3VwIC5idG4tZ3JvdXArLmJ0biwuYnRuLWdyb3VwIC5idG4tZ3JvdXArLmJ0bi1ncm91cHttYXJnaW4tbGVmdDotMXB4fS5idG4tdG9vbGJhcnttYXJnaW4tbGVmdDotNXB4fS5idG4tdG9vbGJhciAuYnRuLC5idG4tdG9vbGJhciAuYnRuLWdyb3VwLC5idG4tdG9vbGJhciAuaW5wdXQtZ3JvdXB7ZmxvYXQ6bGVmdH0uYnRuLXRvb2xiYXI+LmJ0biwuYnRuLXRvb2xiYXI+LmJ0bi1ncm91cCwuYnRuLXRvb2xiYXI+LmlucHV0LWdyb3Vwe21hcmdpbi1sZWZ0OjVweH0uYnRuLWdyb3VwPi5idG46bm90KDpmaXJzdC1jaGlsZCk6bm90KDpsYXN0LWNoaWxkKTpub3QoLmRyb3Bkb3duLXRvZ2dsZSl7Ym9yZGVyLXJhZGl1czowfS5idG4tZ3JvdXA+LmJ0bjpmaXJzdC1jaGlsZHttYXJnaW4tbGVmdDowfS5idG4tZ3JvdXA+LmJ0bjpmaXJzdC1jaGlsZDpub3QoOmxhc3QtY2hpbGQpOm5vdCguZHJvcGRvd24tdG9nZ2xlKXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjB9LmJ0bi1ncm91cD4uYnRuOmxhc3QtY2hpbGQ6bm90KDpmaXJzdC1jaGlsZCksLmJ0bi1ncm91cD4uZHJvcGRvd24tdG9nZ2xlOm5vdCg6Zmlyc3QtY2hpbGQpe2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjB9LmJ0bi1ncm91cD4uYnRuLWdyb3Vwe2Zsb2F0OmxlZnR9LmJ0bi1ncm91cD4uYnRuLWdyb3VwOm5vdCg6Zmlyc3QtY2hpbGQpOm5vdCg6bGFzdC1jaGlsZCk+LmJ0bntib3JkZXItcmFkaXVzOjB9LmJ0bi1ncm91cD4uYnRuLWdyb3VwOmZpcnN0LWNoaWxkOm5vdCg6bGFzdC1jaGlsZCk+LmJ0bjpsYXN0LWNoaWxkLC5idG4tZ3JvdXA+LmJ0bi1ncm91cDpmaXJzdC1jaGlsZDpub3QoOmxhc3QtY2hpbGQpPi5kcm9wZG93bi10b2dnbGV7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowfS5idG4tZ3JvdXA+LmJ0bi1ncm91cDpsYXN0LWNoaWxkOm5vdCg6Zmlyc3QtY2hpbGQpPi5idG46Zmlyc3QtY2hpbGR7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MH0uYnRuLWdyb3VwIC5kcm9wZG93bi10b2dnbGU6YWN0aXZlLC5idG4tZ3JvdXAub3BlbiAuZHJvcGRvd24tdG9nZ2xle291dGxpbmU6MH0uYnRuLWdyb3VwPi5idG4rLmRyb3Bkb3duLXRvZ2dsZXtwYWRkaW5nLWxlZnQ6OHB4O3BhZGRpbmctcmlnaHQ6OHB4fS5idG4tZ3JvdXA+LmJ0bi1sZysuZHJvcGRvd24tdG9nZ2xle3BhZGRpbmctbGVmdDoxMnB4O3BhZGRpbmctcmlnaHQ6MTJweH0uYnRuLWdyb3VwLm9wZW4gLmRyb3Bkb3duLXRvZ2dsZXstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAzcHggNXB4IHJnYmEoMCwwLDAsLjEyNSk7Ym94LXNoYWRvdzppbnNldCAwIDNweCA1cHggcmdiYSgwLDAsMCwuMTI1KX0uYnRuLWdyb3VwLm9wZW4gLmRyb3Bkb3duLXRvZ2dsZS5idG4tbGlua3std2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9LmJ0biAuY2FyZXR7bWFyZ2luLWxlZnQ6MH0uYnRuLWxnIC5jYXJldHtib3JkZXItd2lkdGg6NXB4IDVweCAwO2JvcmRlci1ib3R0b20td2lkdGg6MH0uZHJvcHVwIC5idG4tbGcgLmNhcmV0e2JvcmRlci13aWR0aDowIDVweCA1cHh9LmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cCwuYnRuLWdyb3VwLXZlcnRpY2FsPi5idG4tZ3JvdXA+LmJ0bntkaXNwbGF5OmJsb2NrO2Zsb2F0Om5vbmU7d2lkdGg6MTAwJTttYXgtd2lkdGg6MTAwJX0uYnRuLWdyb3VwLXZlcnRpY2FsPi5idG4tZ3JvdXA+LmJ0bntmbG9hdDpub25lfS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bisuYnRuLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bisuYnRuLWdyb3VwLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cCsuYnRuLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cCsuYnRuLWdyb3Vwe21hcmdpbi10b3A6LTFweDttYXJnaW4tbGVmdDowfS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bjpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1yYWRpdXM6MH0uYnRuLWdyb3VwLXZlcnRpY2FsPi5idG46Zmlyc3QtY2hpbGQ6bm90KDpsYXN0LWNoaWxkKXtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czo0cHg7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czo0cHg7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjB9LmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuOmxhc3QtY2hpbGQ6bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6NHB4O2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6NHB4fS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cDpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpPi5idG57Ym9yZGVyLXJhZGl1czowfS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cDpmaXJzdC1jaGlsZDpub3QoOmxhc3QtY2hpbGQpPi5idG46bGFzdC1jaGlsZCwuYnRuLWdyb3VwLXZlcnRpY2FsPi5idG4tZ3JvdXA6Zmlyc3QtY2hpbGQ6bm90KDpsYXN0LWNoaWxkKT4uZHJvcGRvd24tdG9nZ2xle2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowfS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cDpsYXN0LWNoaWxkOm5vdCg6Zmlyc3QtY2hpbGQpPi5idG46Zmlyc3QtY2hpbGR7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjB9LmJ0bi1ncm91cC1qdXN0aWZpZWR7ZGlzcGxheTp0YWJsZTt3aWR0aDoxMDAlO3RhYmxlLWxheW91dDpmaXhlZDtib3JkZXItY29sbGFwc2U6c2VwYXJhdGV9LmJ0bi1ncm91cC1qdXN0aWZpZWQ+LmJ0biwuYnRuLWdyb3VwLWp1c3RpZmllZD4uYnRuLWdyb3Vwe2Zsb2F0Om5vbmU7ZGlzcGxheTp0YWJsZS1jZWxsO3dpZHRoOjElfS5idG4tZ3JvdXAtanVzdGlmaWVkPi5idG4tZ3JvdXAgLmJ0bnt3aWR0aDoxMDAlfS5idG4tZ3JvdXAtanVzdGlmaWVkPi5idG4tZ3JvdXAgLmRyb3Bkb3duLW1lbnV7bGVmdDphdXRvfVtkYXRhLXRvZ2dsZT1idXR0b25zXT4uYnRuLWdyb3VwPi5idG4gaW5wdXRbdHlwZT1jaGVja2JveF0sW2RhdGEtdG9nZ2xlPWJ1dHRvbnNdPi5idG4tZ3JvdXA+LmJ0biBpbnB1dFt0eXBlPXJhZGlvXSxbZGF0YS10b2dnbGU9YnV0dG9uc10+LmJ0biBpbnB1dFt0eXBlPWNoZWNrYm94XSxbZGF0YS10b2dnbGU9YnV0dG9uc10+LmJ0biBpbnB1dFt0eXBlPXJhZGlvXXtwb3NpdGlvbjphYnNvbHV0ZTtjbGlwOnJlY3QoMCwwLDAsMCk7cG9pbnRlci1ldmVudHM6bm9uZX0udG9vbHRpcHtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjEwNzA7ZGlzcGxheTpibG9jaztmb250LWZhbWlseTpIZWx2ZXRpY2EgTmV1ZSxIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZjtmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDo0MDA7bGV0dGVyLXNwYWNpbmc6bm9ybWFsO2xpbmUtYnJlYWs6YXV0bztsaW5lLWhlaWdodDoxLjQyODU3MTQzO3RleHQtYWxpZ246bGVmdDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO3RleHQtc2hhZG93Om5vbmU7dGV4dC10cmFuc2Zvcm06bm9uZTt3aGl0ZS1zcGFjZTpub3JtYWw7d29yZC1icmVhazpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt3b3JkLXdyYXA6bm9ybWFsO2ZvbnQtc2l6ZToxMnB4O29wYWNpdHk6MDtmaWx0ZXI6YWxwaGEob3BhY2l0eT0wKX0udG9vbHRpcC5pbntvcGFjaXR5Oi45O2ZpbHRlcjphbHBoYShvcGFjaXR5PTkwKX0udG9vbHRpcC50b3B7bWFyZ2luLXRvcDotM3B4O3BhZGRpbmc6NXB4IDB9LnRvb2x0aXAucmlnaHR7bWFyZ2luLWxlZnQ6M3B4O3BhZGRpbmc6MCA1cHh9LnRvb2x0aXAuYm90dG9te21hcmdpbi10b3A6M3B4O3BhZGRpbmc6NXB4IDB9LnRvb2x0aXAubGVmdHttYXJnaW4tbGVmdDotM3B4O3BhZGRpbmc6MCA1cHh9LnRvb2x0aXAtaW5uZXJ7bWF4LXdpZHRoOjIwMHB4O3BhZGRpbmc6M3B4IDhweDtjb2xvcjojZmZmO3RleHQtYWxpZ246Y2VudGVyO2JhY2tncm91bmQtY29sb3I6IzAwMDtib3JkZXItcmFkaXVzOjRweH0udG9vbHRpcC1hcnJvd3twb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDowO2hlaWdodDowO2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItc3R5bGU6c29saWR9LnRvb2x0aXAudG9wIC50b29sdGlwLWFycm93e2JvdHRvbTowO2xlZnQ6NTAlO21hcmdpbi1sZWZ0Oi01cHg7Ym9yZGVyLXdpZHRoOjVweCA1cHggMDtib3JkZXItdG9wLWNvbG9yOiMwMDB9LnRvb2x0aXAudG9wLWxlZnQgLnRvb2x0aXAtYXJyb3d7cmlnaHQ6NXB4fS50b29sdGlwLnRvcC1sZWZ0IC50b29sdGlwLWFycm93LC50b29sdGlwLnRvcC1yaWdodCAudG9vbHRpcC1hcnJvd3tib3R0b206MDttYXJnaW4tYm90dG9tOi01cHg7Ym9yZGVyLXdpZHRoOjVweCA1cHggMDtib3JkZXItdG9wLWNvbG9yOiMwMDB9LnRvb2x0aXAudG9wLXJpZ2h0IC50b29sdGlwLWFycm93e2xlZnQ6NXB4fS50b29sdGlwLnJpZ2h0IC50b29sdGlwLWFycm93e3RvcDo1MCU7bGVmdDowO21hcmdpbi10b3A6LTVweDtib3JkZXItd2lkdGg6NXB4IDVweCA1cHggMDtib3JkZXItcmlnaHQtY29sb3I6IzAwMH0udG9vbHRpcC5sZWZ0IC50b29sdGlwLWFycm93e3RvcDo1MCU7cmlnaHQ6MDttYXJnaW4tdG9wOi01cHg7Ym9yZGVyLXdpZHRoOjVweCAwIDVweCA1cHg7Ym9yZGVyLWxlZnQtY29sb3I6IzAwMH0udG9vbHRpcC5ib3R0b20gLnRvb2x0aXAtYXJyb3d7dG9wOjA7bGVmdDo1MCU7bWFyZ2luLWxlZnQ6LTVweDtib3JkZXItd2lkdGg6MCA1cHggNXB4O2JvcmRlci1ib3R0b20tY29sb3I6IzAwMH0udG9vbHRpcC5ib3R0b20tbGVmdCAudG9vbHRpcC1hcnJvd3t0b3A6MDtyaWdodDo1cHg7bWFyZ2luLXRvcDotNXB4O2JvcmRlci13aWR0aDowIDVweCA1cHg7Ym9yZGVyLWJvdHRvbS1jb2xvcjojMDAwfS50b29sdGlwLmJvdHRvbS1yaWdodCAudG9vbHRpcC1hcnJvd3t0b3A6MDtsZWZ0OjVweDttYXJnaW4tdG9wOi01cHg7Ym9yZGVyLXdpZHRoOjAgNXB4IDVweDtib3JkZXItYm90dG9tLWNvbG9yOiMwMDB9LmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuLWdyb3VwOmFmdGVyLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cDpiZWZvcmUsLmJ0bi10b29sYmFyOmFmdGVyLC5idG4tdG9vbGJhcjpiZWZvcmUsLmNsZWFyZml4OmFmdGVyLC5jbGVhcmZpeDpiZWZvcmV7Y29udGVudDpcXFwiIFxcXCI7ZGlzcGxheTp0YWJsZX0uYnRuLWdyb3VwLXZlcnRpY2FsPi5idG4tZ3JvdXA6YWZ0ZXIsLmJ0bi10b29sYmFyOmFmdGVyLC5jbGVhcmZpeDphZnRlcntjbGVhcjpib3RofS5jZW50ZXItYmxvY2t7ZGlzcGxheTpibG9jazttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvfS5wdWxsLXJpZ2h0e2Zsb2F0OnJpZ2h0IWltcG9ydGFudH0ucHVsbC1sZWZ0e2Zsb2F0OmxlZnQhaW1wb3J0YW50fS5oaWRle2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9LnNob3d7ZGlzcGxheTpibG9jayFpbXBvcnRhbnR9LmludmlzaWJsZXt2aXNpYmlsaXR5OmhpZGRlbn0udGV4dC1oaWRle2ZvbnQ6MC8wIGE7Y29sb3I6dHJhbnNwYXJlbnQ7dGV4dC1zaGFkb3c6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlcjowfS5oaWRkZW57ZGlzcGxheTpub25lIWltcG9ydGFudH0uYWZmaXh7cG9zaXRpb246Zml4ZWR9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC5taW4uY3NzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "clear.png?f470863024f982806a178d720710f024";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvaW1nL2NsZWFyLnBuZz80ODNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiY2xlYXIucG5nP2Y0NzA4NjMwMjRmOTgyODA2YTE3OGQ3MjA3MTBmMDI0XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZWRpdGFibGUvaW1nL2NsZWFyLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "loading.gif?7b9776076d5fceef4993b55c9383dedd";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvaW1nL2xvYWRpbmcuZ2lmPzdiODgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJsb2FkaW5nLmdpZj83Yjk3NzYwNzZkNWZjZWVmNDk5M2I1NWM5MzgzZGVkZFwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2VkaXRhYmxlL2ltZy9sb2FkaW5nLmdpZlxuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n')},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(9);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(1)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!./bootstrap-editable.css\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!./bootstrap-editable.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC1lZGl0YWJsZS5jc3M/ZTIzZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYm9vdHN0cmFwLWVkaXRhYmxlLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ib290c3RyYXAtZWRpdGFibGUuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC1lZGl0YWJsZS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2VkaXRhYmxlL2Nzcy9ib290c3RyYXAtZWRpdGFibGUuY3NzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(10);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(1)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!./bootstrap-wysihtml5.css\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!./bootstrap-wysihtml5.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzPzM2MDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9lZGl0YWJsZS9jc3MvYm9vdHN0cmFwLXd5c2lodG1sNS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(11);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(1)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!./bootstrap.min.css\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!./bootstrap.min.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC5taW4uY3NzPzIwNTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC5taW4uY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC5taW4uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC5taW4uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9lZGl0YWJsZS9jc3MvYm9vdHN0cmFwLm1pbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n")},function(module,exports){eval('\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function "fixes" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== "undefined" && window.location;\n\n  if (!location) {\n    throw new Error("fixUrls requires window.location");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== "string") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + "//" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, "/");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word "url" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn\'t a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn\'t a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn\'t a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^"(.*)"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^\'(.*)\'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf("//") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf("/") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with \'/\'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, ""); // Strip leading \'./\'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn "url(" + JSON.stringify(newUrl) + ")";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9saWIvdXJscy5qcz85YzMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxFQUFFO0FBQ3JELHdDQUF3QyxXQUFXLEVBQUU7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDO0FBQ3RDLEdBQUc7QUFDSDtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n')},function(module,exports){eval("/* globals __VUE_SSR_CONTEXT__ */\n\n// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzP2Q0ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gdGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICB2YXIgZnVuY3Rpb25hbCA9IG9wdGlvbnMuZnVuY3Rpb25hbFxuICAgIHZhciBleGlzdGluZyA9IGZ1bmN0aW9uYWxcbiAgICAgID8gb3B0aW9ucy5yZW5kZXJcbiAgICAgIDogb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICBpZiAoIWZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBleGlzdGluZyhoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n")},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'a\', {\n    attrs: {\n      "href": "javascript:;",\n      "data-type": _vm.type,\n      "disabled": _vm.disabled,\n      "emptytext": _vm.emptytext\n    }\n  }, [_vm._v(_vm._s(_vm.value))])\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRWRpdGFibGUudnVlP2ZiNzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2EnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaHJlZlwiOiBcImphdmFzY3JpcHQ6O1wiLFxuICAgICAgXCJkYXRhLXR5cGVcIjogX3ZtLnR5cGUsXG4gICAgICBcImRpc2FibGVkXCI6IF92bS5kaXNhYmxlZCxcbiAgICAgIFwiZW1wdHl0ZXh0XCI6IF92bS5lbXB0eXRleHRcbiAgICB9XG4gIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS52YWx1ZSkpXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00MDliNDgxNlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvRWRpdGFibGUudnVlXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n')},function(module,exports){eval('module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, "loaded", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, "id", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2MzYzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///20\n')}]);