/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!function ($, wysi) {\n    \"use strict\";\n\n    var tpl = {\n        \"font-styles\": function fontStyles(locale, options) {\n            var size = options && options.size ? ' btn-' + options.size : '';\n            return \"<li class='dropdown'>\" + \"<a class='btn dropdown-toggle\" + size + \"' data-toggle='dropdown' href='#'>\" + \"<i class='icon-font'></i>&nbsp;<span class='current-font'>\" + locale.font_styles.normal + \"</span>&nbsp;<b class='caret'></b>\" + \"</a>\" + \"<ul class='dropdown-menu'>\" + \"<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='div' tabindex='-1'>\" + locale.font_styles.normal + \"</a></li>\" + \"<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='h1' tabindex='-1'>\" + locale.font_styles.h1 + \"</a></li>\" + \"<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='h2' tabindex='-1'>\" + locale.font_styles.h2 + \"</a></li>\" + \"<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='h3' tabindex='-1'>\" + locale.font_styles.h3 + \"</a></li>\" + \"</ul>\" + \"</li>\";\n        },\n\n        \"emphasis\": function emphasis(locale, options) {\n            var size = options && options.size ? ' btn-' + options.size : '';\n            return \"<li>\" + \"<div class='btn-group'>\" + \"<a class='btn\" + size + \"' data-wysihtml5-command='bold' title='CTRL+B' tabindex='-1'>\" + locale.emphasis.bold + \"</a>\" + \"<a class='btn\" + size + \"' data-wysihtml5-command='italic' title='CTRL+I' tabindex='-1'>\" + locale.emphasis.italic + \"</a>\" + \"<a class='btn\" + size + \"' data-wysihtml5-command='underline' title='CTRL+U' tabindex='-1'>\" + locale.emphasis.underline + \"</a>\" + \"</div>\" + \"</li>\";\n        },\n\n        \"lists\": function lists(locale, options) {\n            var size = options && options.size ? ' btn-' + options.size : '';\n            return \"<li>\" + \"<div class='btn-group'>\" + \"<a class='btn\" + size + \"' data-wysihtml5-command='insertUnorderedList' title='\" + locale.lists.unordered + \"' tabindex='-1'><i class='icon-list'></i></a>\" + \"<a class='btn\" + size + \"' data-wysihtml5-command='insertOrderedList' title='\" + locale.lists.ordered + \"' tabindex='-1'><i class='icon-th-list'></i></a>\" + \"<a class='btn\" + size + \"' data-wysihtml5-command='Outdent' title='\" + locale.lists.outdent + \"' tabindex='-1'><i class='icon-indent-right'></i></a>\" + \"<a class='btn\" + size + \"' data-wysihtml5-command='Indent' title='\" + locale.lists.indent + \"' tabindex='-1'><i class='icon-indent-left'></i></a>\" + \"</div>\" + \"</li>\";\n        },\n\n        \"link\": function link(locale, options) {\n            var size = options && options.size ? ' btn-' + options.size : '';\n            return \"<li>\" + \"<div class='bootstrap-wysihtml5-insert-link-modal modal hide fade'>\" + \"<div class='modal-header'>\" + \"<a class='close' data-dismiss='modal'>&times;</a>\" + \"<h3>\" + locale.link.insert + \"</h3>\" + \"</div>\" + \"<div class='modal-body'>\" + \"<input value='http://' class='bootstrap-wysihtml5-insert-link-url input-xlarge'>\" + \"</div>\" + \"<div class='modal-footer'>\" + \"<a href='#' class='btn' data-dismiss='modal'>\" + locale.link.cancel + \"</a>\" + \"<a href='#' class='btn btn-primary' data-dismiss='modal'>\" + locale.link.insert + \"</a>\" + \"</div>\" + \"</div>\" + \"<a class='btn\" + size + \"' data-wysihtml5-command='createLink' title='\" + locale.link.insert + \"' tabindex='-1'><i class='icon-share'></i></a>\" + \"</li>\";\n        },\n\n        \"image\": function image(locale, options) {\n            var size = options && options.size ? ' btn-' + options.size : '';\n            return \"<li>\" + \"<div class='bootstrap-wysihtml5-insert-image-modal modal hide fade'>\" + \"<div class='modal-header'>\" + \"<a class='close' data-dismiss='modal'>&times;</a>\" + \"<h3>\" + locale.image.insert + \"</h3>\" + \"</div>\" + \"<div class='modal-body'>\" + \"<input value='http://' class='bootstrap-wysihtml5-insert-image-url input-xlarge'>\" + \"</div>\" + \"<div class='modal-footer'>\" + \"<a href='#' class='btn' data-dismiss='modal'>\" + locale.image.cancel + \"</a>\" + \"<a href='#' class='btn btn-primary' data-dismiss='modal'>\" + locale.image.insert + \"</a>\" + \"</div>\" + \"</div>\" + \"<a class='btn\" + size + \"' data-wysihtml5-command='insertImage' title='\" + locale.image.insert + \"' tabindex='-1'><i class='icon-picture'></i></a>\" + \"</li>\";\n        },\n\n        \"html\": function html(locale, options) {\n            var size = options && options.size ? ' btn-' + options.size : '';\n            return \"<li>\" + \"<div class='btn-group'>\" + \"<a class='btn\" + size + \"' data-wysihtml5-action='change_view' title='\" + locale.html.edit + \"' tabindex='-1'><i class='icon-pencil'></i></a>\" + \"</div>\" + \"</li>\";\n        },\n\n        \"color\": function color(locale, options) {\n            var size = options && options.size ? ' btn-' + options.size : '';\n            return \"<li class='dropdown'>\" + \"<a class='btn dropdown-toggle\" + size + \"' data-toggle='dropdown' href='#' tabindex='-1'>\" + \"<span class='current-color'>\" + locale.colours.black + \"</span>&nbsp;<b class='caret'></b>\" + \"</a>\" + \"<ul class='dropdown-menu'>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='black'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='black'>\" + locale.colours.black + \"</a></li>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='silver'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='silver'>\" + locale.colours.silver + \"</a></li>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='gray'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='gray'>\" + locale.colours.gray + \"</a></li>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='maroon'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='maroon'>\" + locale.colours.maroon + \"</a></li>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='red'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='red'>\" + locale.colours.red + \"</a></li>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='purple'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='purple'>\" + locale.colours.purple + \"</a></li>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='green'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='green'>\" + locale.colours.green + \"</a></li>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='olive'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='olive'>\" + locale.colours.olive + \"</a></li>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='navy'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='navy'>\" + locale.colours.navy + \"</a></li>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='blue'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='blue'>\" + locale.colours.blue + \"</a></li>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='orange'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='orange'>\" + locale.colours.orange + \"</a></li>\" + \"</ul>\" + \"</li>\";\n        }\n    };\n\n    var templates = function templates(key, locale, options) {\n        return tpl[key](locale, options);\n    };\n\n    var Wysihtml5 = function Wysihtml5(el, options) {\n        this.el = el;\n        var toolbarOpts = options || defaultOptions;\n        for (var t in toolbarOpts.customTemplates) {\n            tpl[t] = toolbarOpts.customTemplates[t];\n        }\n        this.toolbar = this.createToolbar(el, toolbarOpts);\n        this.editor = this.createEditor(options);\n\n        window.editor = this.editor;\n\n        $('iframe.wysihtml5-sandbox').each(function (i, el) {\n            $(el.contentWindow).off('focus.wysihtml5').on({\n                'focus.wysihtml5': function focusWysihtml5() {\n                    $('li.dropdown').removeClass('open');\n                }\n            });\n        });\n    };\n\n    Wysihtml5.prototype = {\n\n        constructor: Wysihtml5,\n\n        createEditor: function createEditor(options) {\n            options = options || {};\n\n            // Add the toolbar to a clone of the options object so multiple instances\n            // of the WYISYWG don't break because \"toolbar\" is already defined\n            options = $.extend(true, {}, options);\n            options.toolbar = this.toolbar[0];\n\n            var editor = new wysi.Editor(this.el[0], options);\n\n            if (options && options.events) {\n                for (var eventName in options.events) {\n                    editor.on(eventName, options.events[eventName]);\n                }\n            }\n            return editor;\n        },\n\n        createToolbar: function createToolbar(el, options) {\n            var self = this;\n            var toolbar = $(\"<ul/>\", {\n                'class': \"wysihtml5-toolbar\",\n                'style': \"display:none\"\n            });\n            var culture = options.locale || defaultOptions.locale || \"en\";\n            for (var key in defaultOptions) {\n                var value = false;\n\n                if (options[key] !== undefined) {\n                    if (options[key] === true) {\n                        value = true;\n                    }\n                } else {\n                    value = defaultOptions[key];\n                }\n\n                if (value === true) {\n                    toolbar.append(templates(key, locale[culture], options));\n\n                    if (key === \"html\") {\n                        this.initHtml(toolbar);\n                    }\n\n                    if (key === \"link\") {\n                        this.initInsertLink(toolbar);\n                    }\n\n                    if (key === \"image\") {\n                        this.initInsertImage(toolbar);\n                    }\n                }\n            }\n\n            if (options.toolbar) {\n                for (key in options.toolbar) {\n                    toolbar.append(options.toolbar[key]);\n                }\n            }\n\n            toolbar.find(\"a[data-wysihtml5-command='formatBlock']\").click(function (e) {\n                var target = e.target || e.srcElement;\n                var el = $(target);\n                self.toolbar.find('.current-font').text(el.html());\n            });\n\n            toolbar.find(\"a[data-wysihtml5-command='foreColor']\").click(function (e) {\n                var target = e.target || e.srcElement;\n                var el = $(target);\n                self.toolbar.find('.current-color').text(el.html());\n            });\n\n            this.el.before(toolbar);\n\n            return toolbar;\n        },\n\n        initHtml: function initHtml(toolbar) {\n            var changeViewSelector = \"a[data-wysihtml5-action='change_view']\";\n            toolbar.find(changeViewSelector).click(function (e) {\n                toolbar.find('a.btn').not(changeViewSelector).toggleClass('disabled');\n            });\n        },\n\n        initInsertImage: function initInsertImage(toolbar) {\n            var self = this;\n            var insertImageModal = toolbar.find('.bootstrap-wysihtml5-insert-image-modal');\n            var urlInput = insertImageModal.find('.bootstrap-wysihtml5-insert-image-url');\n            var insertButton = insertImageModal.find('a.btn-primary');\n            var initialValue = urlInput.val();\n            var caretBookmark;\n\n            var insertImage = function insertImage() {\n                var url = urlInput.val();\n                urlInput.val(initialValue);\n                self.editor.currentView.element.focus();\n                if (caretBookmark) {\n                    self.editor.composer.selection.setBookmark(caretBookmark);\n                    caretBookmark = null;\n                }\n                self.editor.composer.commands.exec(\"insertImage\", url);\n            };\n\n            urlInput.keypress(function (e) {\n                if (e.which == 13) {\n                    insertImage();\n                    insertImageModal.modal('hide');\n                }\n            });\n\n            insertButton.click(insertImage);\n\n            insertImageModal.on('shown', function () {\n                urlInput.focus();\n            });\n\n            insertImageModal.on('hide', function () {\n                self.editor.currentView.element.focus();\n            });\n\n            toolbar.find('a[data-wysihtml5-command=insertImage]').click(function () {\n                var activeButton = $(this).hasClass(\"wysihtml5-command-active\");\n\n                if (!activeButton) {\n                    self.editor.currentView.element.focus(false);\n                    caretBookmark = self.editor.composer.selection.getBookmark();\n                    insertImageModal.appendTo('body').modal('show');\n                    insertImageModal.on('click.dismiss.modal', '[data-dismiss=\"modal\"]', function (e) {\n                        e.stopPropagation();\n                    });\n                    return false;\n                } else {\n                    return true;\n                }\n            });\n        },\n\n        initInsertLink: function initInsertLink(toolbar) {\n            var self = this;\n            var insertLinkModal = toolbar.find('.bootstrap-wysihtml5-insert-link-modal');\n            var urlInput = insertLinkModal.find('.bootstrap-wysihtml5-insert-link-url');\n            var insertButton = insertLinkModal.find('a.btn-primary');\n            var initialValue = urlInput.val();\n            var caretBookmark;\n\n            var insertLink = function insertLink() {\n                var url = urlInput.val();\n                urlInput.val(initialValue);\n                self.editor.currentView.element.focus();\n                if (caretBookmark) {\n                    self.editor.composer.selection.setBookmark(caretBookmark);\n                    caretBookmark = null;\n                }\n                self.editor.composer.commands.exec(\"createLink\", {\n                    href: url,\n                    target: \"_blank\",\n                    rel: \"nofollow\"\n                });\n            };\n            var pressedEnter = false;\n\n            urlInput.keypress(function (e) {\n                if (e.which == 13) {\n                    insertLink();\n                    insertLinkModal.modal('hide');\n                }\n            });\n\n            insertButton.click(insertLink);\n\n            insertLinkModal.on('shown', function () {\n                urlInput.focus();\n            });\n\n            insertLinkModal.on('hide', function () {\n                self.editor.currentView.element.focus();\n            });\n\n            toolbar.find('a[data-wysihtml5-command=createLink]').click(function () {\n                var activeButton = $(this).hasClass(\"wysihtml5-command-active\");\n\n                if (!activeButton) {\n                    self.editor.currentView.element.focus(false);\n                    caretBookmark = self.editor.composer.selection.getBookmark();\n                    insertLinkModal.appendTo('body').modal('show');\n                    insertLinkModal.on('click.dismiss.modal', '[data-dismiss=\"modal\"]', function (e) {\n                        e.stopPropagation();\n                    });\n                    return false;\n                } else {\n                    return true;\n                }\n            });\n        }\n    };\n\n    // these define our public api\n    var methods = {\n        resetDefaults: function resetDefaults() {\n            $.fn.wysihtml5.defaultOptions = $.extend(true, {}, $.fn.wysihtml5.defaultOptionsCache);\n        },\n        bypassDefaults: function bypassDefaults(options) {\n            return this.each(function () {\n                var $this = $(this);\n                $this.data('wysihtml5', new Wysihtml5($this, options));\n            });\n        },\n        shallowExtend: function shallowExtend(options) {\n            var settings = $.extend({}, $.fn.wysihtml5.defaultOptions, options || {});\n            var that = this;\n            return methods.bypassDefaults.apply(that, [settings]);\n        },\n        deepExtend: function deepExtend(options) {\n            var settings = $.extend(true, {}, $.fn.wysihtml5.defaultOptions, options || {});\n            var that = this;\n            return methods.bypassDefaults.apply(that, [settings]);\n        },\n        init: function init(options) {\n            var that = this;\n            return methods.shallowExtend.apply(that, [options]);\n        }\n    };\n\n    $.fn.wysihtml5 = function (method) {\n        if (methods[method]) {\n            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n        } else if ((typeof method === \"undefined\" ? \"undefined\" : _typeof(method)) === 'object' || !method) {\n            return methods.init.apply(this, arguments);\n        } else {\n            $.error('Method ' + method + ' does not exist on jQuery.wysihtml5');\n        }\n    };\n\n    $.fn.wysihtml5.Constructor = Wysihtml5;\n\n    var defaultOptions = $.fn.wysihtml5.defaultOptions = {\n        \"font-styles\": true,\n        \"color\": false,\n        \"emphasis\": true,\n        \"lists\": true,\n        \"html\": false,\n        \"link\": true,\n        \"image\": true,\n        events: {},\n        parserRules: {\n            classes: {\n                // (path_to_project/lib/css/wysiwyg-color.css)\n                \"wysiwyg-color-silver\": 1,\n                \"wysiwyg-color-gray\": 1,\n                \"wysiwyg-color-white\": 1,\n                \"wysiwyg-color-maroon\": 1,\n                \"wysiwyg-color-red\": 1,\n                \"wysiwyg-color-purple\": 1,\n                \"wysiwyg-color-fuchsia\": 1,\n                \"wysiwyg-color-green\": 1,\n                \"wysiwyg-color-lime\": 1,\n                \"wysiwyg-color-olive\": 1,\n                \"wysiwyg-color-yellow\": 1,\n                \"wysiwyg-color-navy\": 1,\n                \"wysiwyg-color-blue\": 1,\n                \"wysiwyg-color-teal\": 1,\n                \"wysiwyg-color-aqua\": 1,\n                \"wysiwyg-color-orange\": 1\n            },\n            tags: {\n                \"b\": {},\n                \"i\": {},\n                \"br\": {},\n                \"ol\": {},\n                \"ul\": {},\n                \"li\": {},\n                \"h1\": {},\n                \"h2\": {},\n                \"h3\": {},\n                \"blockquote\": {},\n                \"u\": 1,\n                \"img\": {\n                    \"check_attributes\": {\n                        \"width\": \"numbers\",\n                        \"alt\": \"alt\",\n                        \"src\": \"url\",\n                        \"height\": \"numbers\"\n                    }\n                },\n                \"a\": {\n                    set_attributes: {\n                        target: \"_blank\",\n                        rel: \"nofollow\"\n                    },\n                    check_attributes: {\n                        href: \"url\" // important to avoid XSS\n                    }\n                },\n                \"span\": 1,\n                \"div\": 1,\n                // to allow save and edit files with code tag hacks\n                \"code\": 1,\n                \"pre\": 1\n            }\n        },\n        stylesheets: [\"./lib/css/wysiwyg-color.css\"], // (path_to_project/lib/css/wysiwyg-color.css)\n        locale: \"en\"\n    };\n\n    if (typeof $.fn.wysihtml5.defaultOptionsCache === 'undefined') {\n        $.fn.wysihtml5.defaultOptionsCache = $.extend(true, {}, $.fn.wysihtml5.defaultOptions);\n    }\n\n    var locale = $.fn.wysihtml5.locale = {\n        en: {\n            font_styles: {\n                normal: \"Normal text\",\n                h1: \"Heading 1\",\n                h2: \"Heading 2\",\n                h3: \"Heading 3\"\n            },\n            emphasis: {\n                bold: \"Bold\",\n                italic: \"Italic\",\n                underline: \"Underline\"\n            },\n            lists: {\n                unordered: \"Unordered list\",\n                ordered: \"Ordered list\",\n                outdent: \"Outdent\",\n                indent: \"Indent\"\n            },\n            link: {\n                insert: \"Insert link\",\n                cancel: \"Cancel\"\n            },\n            image: {\n                insert: \"Insert image\",\n                cancel: \"Cancel\"\n            },\n            html: {\n                edit: \"Edit HTML\"\n            },\n            colours: {\n                black: \"Black\",\n                silver: \"Silver\",\n                gray: \"Grey\",\n                maroon: \"Maroon\",\n                red: \"Red\",\n                purple: \"Purple\",\n                green: \"Green\",\n                olive: \"Olive\",\n                navy: \"Navy\",\n                blue: \"Blue\",\n                orange: \"Orange\"\n            }\n        }\n    };\n}(window.jQuery, window.wysihtml5);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvanMvYm9vdHN0cmFwLXd5c2lodG1sNS0wLjAuMi5qcz9jZTg2Il0sIm5hbWVzIjpbIiQiLCJ3eXNpIiwidHBsIiwibG9jYWxlIiwib3B0aW9ucyIsInNpemUiLCJmb250X3N0eWxlcyIsIm5vcm1hbCIsImgxIiwiaDIiLCJoMyIsImVtcGhhc2lzIiwiYm9sZCIsIml0YWxpYyIsInVuZGVybGluZSIsImxpc3RzIiwidW5vcmRlcmVkIiwib3JkZXJlZCIsIm91dGRlbnQiLCJpbmRlbnQiLCJsaW5rIiwiaW5zZXJ0IiwiY2FuY2VsIiwiaW1hZ2UiLCJodG1sIiwiZWRpdCIsImNvbG91cnMiLCJibGFjayIsInNpbHZlciIsImdyYXkiLCJtYXJvb24iLCJyZWQiLCJwdXJwbGUiLCJncmVlbiIsIm9saXZlIiwibmF2eSIsImJsdWUiLCJvcmFuZ2UiLCJ0ZW1wbGF0ZXMiLCJrZXkiLCJXeXNpaHRtbDUiLCJlbCIsInRvb2xiYXJPcHRzIiwiZGVmYXVsdE9wdGlvbnMiLCJ0IiwiY3VzdG9tVGVtcGxhdGVzIiwidG9vbGJhciIsImNyZWF0ZVRvb2xiYXIiLCJlZGl0b3IiLCJjcmVhdGVFZGl0b3IiLCJ3aW5kb3ciLCJlYWNoIiwiaSIsImNvbnRlbnRXaW5kb3ciLCJvZmYiLCJvbiIsInJlbW92ZUNsYXNzIiwicHJvdG90eXBlIiwiY29uc3RydWN0b3IiLCJleHRlbmQiLCJFZGl0b3IiLCJldmVudHMiLCJldmVudE5hbWUiLCJzZWxmIiwiY3VsdHVyZSIsInZhbHVlIiwidW5kZWZpbmVkIiwiYXBwZW5kIiwiaW5pdEh0bWwiLCJpbml0SW5zZXJ0TGluayIsImluaXRJbnNlcnRJbWFnZSIsImZpbmQiLCJjbGljayIsImUiLCJ0YXJnZXQiLCJzcmNFbGVtZW50IiwidGV4dCIsImJlZm9yZSIsImNoYW5nZVZpZXdTZWxlY3RvciIsIm5vdCIsInRvZ2dsZUNsYXNzIiwiaW5zZXJ0SW1hZ2VNb2RhbCIsInVybElucHV0IiwiaW5zZXJ0QnV0dG9uIiwiaW5pdGlhbFZhbHVlIiwidmFsIiwiY2FyZXRCb29rbWFyayIsImluc2VydEltYWdlIiwidXJsIiwiY3VycmVudFZpZXciLCJlbGVtZW50IiwiZm9jdXMiLCJjb21wb3NlciIsInNlbGVjdGlvbiIsInNldEJvb2ttYXJrIiwiY29tbWFuZHMiLCJleGVjIiwia2V5cHJlc3MiLCJ3aGljaCIsIm1vZGFsIiwiYWN0aXZlQnV0dG9uIiwiaGFzQ2xhc3MiLCJnZXRCb29rbWFyayIsImFwcGVuZFRvIiwic3RvcFByb3BhZ2F0aW9uIiwiaW5zZXJ0TGlua01vZGFsIiwiaW5zZXJ0TGluayIsImhyZWYiLCJyZWwiLCJwcmVzc2VkRW50ZXIiLCJtZXRob2RzIiwicmVzZXREZWZhdWx0cyIsImZuIiwid3lzaWh0bWw1IiwiZGVmYXVsdE9wdGlvbnNDYWNoZSIsImJ5cGFzc0RlZmF1bHRzIiwiJHRoaXMiLCJkYXRhIiwic2hhbGxvd0V4dGVuZCIsInNldHRpbmdzIiwidGhhdCIsImFwcGx5IiwiZGVlcEV4dGVuZCIsImluaXQiLCJtZXRob2QiLCJBcnJheSIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsImVycm9yIiwiQ29uc3RydWN0b3IiLCJwYXJzZXJSdWxlcyIsImNsYXNzZXMiLCJ0YWdzIiwic2V0X2F0dHJpYnV0ZXMiLCJjaGVja19hdHRyaWJ1dGVzIiwic3R5bGVzaGVldHMiLCJlbiIsImpRdWVyeSJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxDQUFDLFVBQVNBLENBQVQsRUFBWUMsSUFBWixFQUFrQjtBQUNmOztBQUVBLFFBQUlDLE1BQU07QUFDTix1QkFBZSxvQkFBU0MsTUFBVCxFQUFpQkMsT0FBakIsRUFBMEI7QUFDckMsZ0JBQUlDLE9BQVFELFdBQVdBLFFBQVFDLElBQXBCLEdBQTRCLFVBQVFELFFBQVFDLElBQTVDLEdBQW1ELEVBQTlEO0FBQ0EsbUJBQU8sMEJBQ0wsK0JBREssR0FDNkJBLElBRDdCLEdBQ29DLG9DQURwQyxHQUVMLDREQUZLLEdBRTBERixPQUFPRyxXQUFQLENB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QWxCTjtBQXNCQUMsbUJBQU87QUFDSEYsd0JBQVEsY0FETDtBQUVIQyx3QkFBUTtBQUZMLGFBdEJQO0FBMEJBRSxrQkFBTTtBQUNGQyxzQkFBTTtBQURKLGFBMUJOO0FBNkJBQyxxQkFBUztBQUNMQyx1QkFBTyxPQURGO0FBRUxDLHdCQUFRLFFBRkg7QUFHTEMsc0JBQU0sTUFIRDtBQUlMQyx3QkFBUSxRQUpIO0FBS0xDLHFCQUFLLEtBTEE7QUFNTEMsd0JBQVEsUUFOSDtBQU9MQyx1QkFBTyxPQVBGO0FBUUxDLHVCQUFPLE9BUkY7QUFTTEMsc0JBQU0sTUFURDtBQVVMQyxzQkFBTSxNQVZEO0FBV0xDLHdCQUFRO0FBWEg7QUE3QlQ7QUFENkIsS0FBckM7QUE4Q0gsQ0FsZkEsQ0FrZkNhLE9BQU93RixNQWxmUixFQWtmZ0J4RixPQUFPK0QsU0FsZnZCLENBQUQiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbigkLCB3eXNpKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgdHBsID0ge1xuICAgICAgICBcImZvbnQtc3R5bGVzXCI6IGZ1bmN0aW9uKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNpemUgPSAob3B0aW9ucyAmJiBvcHRpb25zLnNpemUpID8gJyBidG4tJytvcHRpb25zLnNpemUgOiAnJztcbiAgICAgICAgICAgIHJldHVybiBcIjxsaSBjbGFzcz0nZHJvcGRvd24nPlwiICtcbiAgICAgICAgICAgICAgXCI8YSBjbGFzcz0nYnRuIGRyb3Bkb3duLXRvZ2dsZVwiICsgc2l6ZSArIFwiJyBkYXRhLXRvZ2dsZT0nZHJvcGRvd24nIGhyZWY9JyMnPlwiICtcbiAgICAgICAgICAgICAgXCI8aSBjbGFzcz0naWNvbi1mb250Jz48L2k+Jm5ic3A7PHNwYW4gY2xhc3M9J2N1cnJlbnQtZm9udCc+XCIgKyBsb2NhbGUuZm9udF9zdHlsZXMubm9ybWFsICsgXCI8L3NwYW4+Jm5ic3A7PGIgY2xhc3M9J2NhcmV0Jz48L2I+XCIgK1xuICAgICAgICAgICAgICBcIjwvYT5cIiArXG4gICAgICAgICAgICAgIFwiPHVsIGNsYXNzPSdkcm9wZG93bi1tZW51Jz5cIiArXG4gICAgICAgICAgICAgICAgXCI8bGk+PGEgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nZm9ybWF0QmxvY2snIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J2RpdicgdGFiaW5kZXg9Jy0xJz5cIiArIGxvY2FsZS5mb250X3N0eWxlcy5ub3JtYWwgKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgICBcIjxsaT48YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JtYXRCbG9jaycgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0naDEnIHRhYmluZGV4PSctMSc+XCIgKyBsb2NhbGUuZm9udF9zdHlsZXMuaDEgKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgICBcIjxsaT48YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JtYXRCbG9jaycgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0naDInIHRhYmluZGV4PSctMSc+XCIgKyBsb2NhbGUuZm9udF9zdHlsZXMuaDIgKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgICBcIjxsaT48YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JtYXRCbG9jaycgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0naDMnIHRhYmluZGV4PSctMSc+XCIgKyBsb2NhbGUuZm9udF9zdHlsZXMuaDMgKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgXCI8L3VsPlwiICtcbiAgICAgICAgICAgIFwiPC9saT5cIjtcbiAgICAgICAgfSxcblxuICAgICAgICBcImVtcGhhc2lzXCI6IGZ1bmN0aW9uKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNpemUgPSAob3B0aW9ucyAmJiBvcHRpb25zLnNpemUpID8gJyBidG4tJytvcHRpb25zLnNpemUgOiAnJztcbiAgICAgICAgICAgIHJldHVybiBcIjxsaT5cIiArXG4gICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nYnRuLWdyb3VwJz5cIiArXG4gICAgICAgICAgICAgICAgXCI8YSBjbGFzcz0nYnRuXCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2JvbGQnIHRpdGxlPSdDVFJMK0InIHRhYmluZGV4PSctMSc+XCIgKyBsb2NhbGUuZW1waGFzaXMuYm9sZCArIFwiPC9hPlwiICtcbiAgICAgICAgICAgICAgICBcIjxhIGNsYXNzPSdidG5cIiArIHNpemUgKyBcIicgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0naXRhbGljJyB0aXRsZT0nQ1RSTCtJJyB0YWJpbmRleD0nLTEnPlwiICsgbG9jYWxlLmVtcGhhc2lzLml0YWxpYyArIFwiPC9hPlwiICtcbiAgICAgICAgICAgICAgICBcIjxhIGNsYXNzPSdidG5cIiArIHNpemUgKyBcIicgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0ndW5kZXJsaW5lJyB0aXRsZT0nQ1RSTCtVJyB0YWJpbmRleD0nLTEnPlwiICsgbG9jYWxlLmVtcGhhc2lzLnVuZGVybGluZSArIFwiPC9hPlwiICtcbiAgICAgICAgICAgICAgXCI8L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjwvbGk+XCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJsaXN0c1wiOiBmdW5jdGlvbihsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zaXplKSA/ICcgYnRuLScrb3B0aW9ucy5zaXplIDogJyc7XG4gICAgICAgICAgICByZXR1cm4gXCI8bGk+XCIgK1xuICAgICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2J0bi1ncm91cCc+XCIgK1xuICAgICAgICAgICAgICAgIFwiPGEgY2xhc3M9J2J0blwiICsgc2l6ZSArIFwiJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdpbnNlcnRVbm9yZGVyZWRMaXN0JyB0aXRsZT0nXCIgKyBsb2NhbGUubGlzdHMudW5vcmRlcmVkICsgXCInIHRhYmluZGV4PSctMSc+PGkgY2xhc3M9J2ljb24tbGlzdCc+PC9pPjwvYT5cIiArXG4gICAgICAgICAgICAgICAgXCI8YSBjbGFzcz0nYnRuXCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2luc2VydE9yZGVyZWRMaXN0JyB0aXRsZT0nXCIgKyBsb2NhbGUubGlzdHMub3JkZXJlZCArIFwiJyB0YWJpbmRleD0nLTEnPjxpIGNsYXNzPSdpY29uLXRoLWxpc3QnPjwvaT48L2E+XCIgK1xuICAgICAgICAgICAgICAgIFwiPGEgY2xhc3M9J2J0blwiICsgc2l6ZSArIFwiJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdPdXRkZW50JyB0aXRsZT0nXCIgKyBsb2NhbGUubGlzdHMub3V0ZGVudCArIFwiJyB0YWJpbmRleD0nLTEnPjxpIGNsYXNzPSdpY29uLWluZGVudC1yaWdodCc+PC9pPjwvYT5cIiArXG4gICAgICAgICAgICAgICAgXCI8YSBjbGFzcz0nYnRuXCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J0luZGVudCcgdGl0bGU9J1wiICsgbG9jYWxlLmxpc3RzLmluZGVudCArIFwiJyB0YWJpbmRleD0nLTEnPjxpIGNsYXNzPSdpY29uLWluZGVudC1sZWZ0Jz48L2k+PC9hPlwiICtcbiAgICAgICAgICAgICAgXCI8L2Rpdj5cIiArXG4gICAgICAgICAgICBcIjwvbGk+XCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJsaW5rXCI6IGZ1bmN0aW9uKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNpemUgPSAob3B0aW9ucyAmJiBvcHRpb25zLnNpemUpID8gJyBidG4tJytvcHRpb25zLnNpemUgOiAnJztcbiAgICAgICAgICAgIHJldHVybiBcIjxsaT5cIiArXG4gICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtbGluay1tb2RhbCBtb2RhbCBoaWRlIGZhZGUnPlwiICtcbiAgICAgICAgICAgICAgICBcIjxkaXYgY2xhc3M9J21vZGFsLWhlYWRlcic+XCIgK1xuICAgICAgICAgICAgICAgICAgXCI8YSBjbGFzcz0nY2xvc2UnIGRhdGEtZGlzbWlzcz0nbW9kYWwnPiZ0aW1lczs8L2E+XCIgK1xuICAgICAgICAgICAgICAgICAgXCI8aDM+XCIgKyBsb2NhbGUubGluay5pbnNlcnQgKyBcIjwvaDM+XCIgK1xuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIgK1xuICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nbW9kYWwtYm9keSc+XCIgK1xuICAgICAgICAgICAgICAgICAgXCI8aW5wdXQgdmFsdWU9J2h0dHA6Ly8nIGNsYXNzPSdib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1saW5rLXVybCBpbnB1dC14bGFyZ2UnPlwiICtcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiICtcbiAgICAgICAgICAgICAgICBcIjxkaXYgY2xhc3M9J21vZGFsLWZvb3Rlcic+XCIgK1xuICAgICAgICAgICAgICAgICAgXCI8YSBocmVmPScjJyBjbGFzcz0nYnRuJyBkYXRhLWRpc21pc3M9J21vZGFsJz5cIiArIGxvY2FsZS5saW5rLmNhbmNlbCArIFwiPC9hPlwiICtcbiAgICAgICAgICAgICAgICAgIFwiPGEgaHJlZj0nIycgY2xhc3M9J2J0biBidG4tcHJpbWFyeScgZGF0YS1kaXNtaXNzPSdtb2RhbCc+XCIgKyBsb2NhbGUubGluay5pbnNlcnQgKyBcIjwvYT5cIiArXG4gICAgICAgICAgICAgICAgXCI8L2Rpdj5cIiArXG4gICAgICAgICAgICAgIFwiPC9kaXY+XCIgK1xuICAgICAgICAgICAgICBcIjxhIGNsYXNzPSdidG5cIiArIHNpemUgKyBcIicgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nY3JlYXRlTGluaycgdGl0bGU9J1wiICsgbG9jYWxlLmxpbmsuaW5zZXJ0ICsgXCInIHRhYmluZGV4PSctMSc+PGkgY2xhc3M9J2ljb24tc2hhcmUnPjwvaT48L2E+XCIgK1xuICAgICAgICAgICAgXCI8L2xpPlwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwiaW1hZ2VcIjogZnVuY3Rpb24obG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IChvcHRpb25zICYmIG9wdGlvbnMuc2l6ZSkgPyAnIGJ0bi0nK29wdGlvbnMuc2l6ZSA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIFwiPGxpPlwiICtcbiAgICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1pbWFnZS1tb2RhbCBtb2RhbCBoaWRlIGZhZGUnPlwiICtcbiAgICAgICAgICAgICAgICBcIjxkaXYgY2xhc3M9J21vZGFsLWhlYWRlcic+XCIgK1xuICAgICAgICAgICAgICAgICAgXCI8YSBjbGFzcz0nY2xvc2UnIGRhdGEtZGlzbWlzcz0nbW9kYWwnPiZ0aW1lczs8L2E+XCIgK1xuICAgICAgICAgICAgICAgICAgXCI8aDM+XCIgKyBsb2NhbGUuaW1hZ2UuaW5zZXJ0ICsgXCI8L2gzPlwiICtcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiICtcbiAgICAgICAgICAgICAgICBcIjxkaXYgY2xhc3M9J21vZGFsLWJvZHknPlwiICtcbiAgICAgICAgICAgICAgICAgIFwiPGlucHV0IHZhbHVlPSdodHRwOi8vJyBjbGFzcz0nYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtaW1hZ2UtdXJsIGlucHV0LXhsYXJnZSc+XCIgK1xuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIgK1xuICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nbW9kYWwtZm9vdGVyJz5cIiArXG4gICAgICAgICAgICAgICAgICBcIjxhIGhyZWY9JyMnIGNsYXNzPSdidG4nIGRhdGEtZGlzbWlzcz0nbW9kYWwnPlwiICsgbG9jYWxlLmltYWdlLmNhbmNlbCArIFwiPC9hPlwiICtcbiAgICAgICAgICAgICAgICAgIFwiPGEgaHJlZj0nIycgY2xhc3M9J2J0biBidG4tcHJpbWFyeScgZGF0YS1kaXNtaXNzPSdtb2RhbCc+XCIgKyBsb2NhbGUuaW1hZ2UuaW5zZXJ0ICsgXCI8L2E+XCIgK1xuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIgK1xuICAgICAgICAgICAgICBcIjwvZGl2PlwiICtcbiAgICAgICAgICAgICAgXCI8YSBjbGFzcz0nYnRuXCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2luc2VydEltYWdlJyB0aXRsZT0nXCIgKyBsb2NhbGUuaW1hZ2UuaW5zZXJ0ICsgXCInIHRhYmluZGV4PSctMSc+PGkgY2xhc3M9J2ljb24tcGljdHVyZSc+PC9pPjwvYT5cIiArXG4gICAgICAgICAgICBcIjwvbGk+XCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJodG1sXCI6IGZ1bmN0aW9uKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNpemUgPSAob3B0aW9ucyAmJiBvcHRpb25zLnNpemUpID8gJyBidG4tJytvcHRpb25zLnNpemUgOiAnJztcbiAgICAgICAgICAgIHJldHVybiBcIjxsaT5cIiArXG4gICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nYnRuLWdyb3VwJz5cIiArXG4gICAgICAgICAgICAgICAgXCI8YSBjbGFzcz0nYnRuXCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWFjdGlvbj0nY2hhbmdlX3ZpZXcnIHRpdGxlPSdcIiArIGxvY2FsZS5odG1sLmVkaXQgKyBcIicgdGFiaW5kZXg9Jy0xJz48aSBjbGFzcz0naWNvbi1wZW5jaWwnPjwvaT48L2E+XCIgK1xuICAgICAgICAgICAgICBcIjwvZGl2PlwiICtcbiAgICAgICAgICAgIFwiPC9saT5cIjtcbiAgICAgICAgfSxcblxuICAgICAgICBcImNvbG9yXCI6IGZ1bmN0aW9uKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNpemUgPSAob3B0aW9ucyAmJiBvcHRpb25zLnNpemUpID8gJyBidG4tJytvcHRpb25zLnNpemUgOiAnJztcbiAgICAgICAgICAgIHJldHVybiBcIjxsaSBjbGFzcz0nZHJvcGRvd24nPlwiICtcbiAgICAgICAgICAgICAgXCI8YSBjbGFzcz0nYnRuIGRyb3Bkb3duLXRvZ2dsZVwiICsgc2l6ZSArIFwiJyBkYXRhLXRvZ2dsZT0nZHJvcGRvd24nIGhyZWY9JyMnIHRhYmluZGV4PSctMSc+XCIgK1xuICAgICAgICAgICAgICAgIFwiPHNwYW4gY2xhc3M9J2N1cnJlbnQtY29sb3InPlwiICsgbG9jYWxlLmNvbG91cnMuYmxhY2sgKyBcIjwvc3Bhbj4mbmJzcDs8YiBjbGFzcz0nY2FyZXQnPjwvYj5cIiArXG4gICAgICAgICAgICAgIFwiPC9hPlwiICtcbiAgICAgICAgICAgICAgXCI8dWwgY2xhc3M9J2Ryb3Bkb3duLW1lbnUnPlwiICtcbiAgICAgICAgICAgICAgICBcIjxsaT48ZGl2IGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdibGFjayc+PC9kaXY+PGEgY2xhc3M9J3d5c2lodG1sNS1jb2xvcnMtdGl0bGUnIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2ZvcmVDb2xvcicgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0nYmxhY2snPlwiICsgbG9jYWxlLmNvbG91cnMuYmxhY2sgKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgICBcIjxsaT48ZGl2IGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdzaWx2ZXInPjwvZGl2PjxhIGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzLXRpdGxlJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JlQ29sb3InIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J3NpbHZlcic+XCIgKyBsb2NhbGUuY29sb3Vycy5zaWx2ZXIgKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgICBcIjxsaT48ZGl2IGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdncmF5Jz48L2Rpdj48YSBjbGFzcz0nd3lzaWh0bWw1LWNvbG9ycy10aXRsZScgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nZm9yZUNvbG9yJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdncmF5Jz5cIiArIGxvY2FsZS5jb2xvdXJzLmdyYXkgKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgICBcIjxsaT48ZGl2IGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdtYXJvb24nPjwvZGl2PjxhIGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzLXRpdGxlJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JlQ29sb3InIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J21hcm9vbic+XCIgKyBsb2NhbGUuY29sb3Vycy5tYXJvb24gKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgICBcIjxsaT48ZGl2IGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdyZWQnPjwvZGl2PjxhIGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzLXRpdGxlJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JlQ29sb3InIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J3JlZCc+XCIgKyBsb2NhbGUuY29sb3Vycy5yZWQgKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgICBcIjxsaT48ZGl2IGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdwdXJwbGUnPjwvZGl2PjxhIGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzLXRpdGxlJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JlQ29sb3InIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J3B1cnBsZSc+XCIgKyBsb2NhbGUuY29sb3Vycy5wdXJwbGUgKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgICBcIjxsaT48ZGl2IGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdncmVlbic+PC9kaXY+PGEgY2xhc3M9J3d5c2lodG1sNS1jb2xvcnMtdGl0bGUnIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2ZvcmVDb2xvcicgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0nZ3JlZW4nPlwiICsgbG9jYWxlLmNvbG91cnMuZ3JlZW4gKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgICBcIjxsaT48ZGl2IGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdvbGl2ZSc+PC9kaXY+PGEgY2xhc3M9J3d5c2lodG1sNS1jb2xvcnMtdGl0bGUnIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2ZvcmVDb2xvcicgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0nb2xpdmUnPlwiICsgbG9jYWxlLmNvbG91cnMub2xpdmUgKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgICBcIjxsaT48ZGl2IGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSduYXZ5Jz48L2Rpdj48YSBjbGFzcz0nd3lzaWh0bWw1LWNvbG9ycy10aXRsZScgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nZm9yZUNvbG9yJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSduYXZ5Jz5cIiArIGxvY2FsZS5jb2xvdXJzLm5hdnkgKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgICBcIjxsaT48ZGl2IGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdibHVlJz48L2Rpdj48YSBjbGFzcz0nd3lzaWh0bWw1LWNvbG9ycy10aXRsZScgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nZm9yZUNvbG9yJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdibHVlJz5cIiArIGxvY2FsZS5jb2xvdXJzLmJsdWUgKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgICBcIjxsaT48ZGl2IGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdvcmFuZ2UnPjwvZGl2PjxhIGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzLXRpdGxlJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JlQ29sb3InIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J29yYW5nZSc+XCIgKyBsb2NhbGUuY29sb3Vycy5vcmFuZ2UgKyBcIjwvYT48L2xpPlwiICtcbiAgICAgICAgICAgICAgXCI8L3VsPlwiICtcbiAgICAgICAgICAgIFwiPC9saT5cIjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdGVtcGxhdGVzID0gZnVuY3Rpb24oa2V5LCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRwbFtrZXldKGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgfTtcblxuXG4gICAgdmFyIFd5c2lodG1sNSA9IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdmFyIHRvb2xiYXJPcHRzID0gb3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgZm9yKHZhciB0IGluIHRvb2xiYXJPcHRzLmN1c3RvbVRlbXBsYXRlcykge1xuICAgICAgICAgIHRwbFt0XSA9IHRvb2xiYXJPcHRzLmN1c3RvbVRlbXBsYXRlc1t0XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvb2xiYXIgPSB0aGlzLmNyZWF0ZVRvb2xiYXIoZWwsIHRvb2xiYXJPcHRzKTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSAgdGhpcy5jcmVhdGVFZGl0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgd2luZG93LmVkaXRvciA9IHRoaXMuZWRpdG9yO1xuXG4gICAgICAgICQoJ2lmcmFtZS53eXNpaHRtbDUtc2FuZGJveCcpLmVhY2goZnVuY3Rpb24oaSwgZWwpe1xuICAgICAgICAgICAgJChlbC5jb250ZW50V2luZG93KS5vZmYoJ2ZvY3VzLnd5c2lodG1sNScpLm9uKHtcbiAgICAgICAgICAgICAgICAnZm9jdXMud3lzaWh0bWw1JyA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICQoJ2xpLmRyb3Bkb3duJykucmVtb3ZlQ2xhc3MoJ29wZW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIFd5c2lodG1sNS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFd5c2lodG1sNSxcblxuICAgICAgICBjcmVhdGVFZGl0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHRvb2xiYXIgdG8gYSBjbG9uZSBvZiB0aGUgb3B0aW9ucyBvYmplY3Qgc28gbXVsdGlwbGUgaW5zdGFuY2VzXG4gICAgICAgICAgICAvLyBvZiB0aGUgV1lJU1lXRyBkb24ndCBicmVhayBiZWNhdXNlIFwidG9vbGJhclwiIGlzIGFscmVhZHkgZGVmaW5lZFxuICAgICAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIG9wdGlvbnMudG9vbGJhciA9IHRoaXMudG9vbGJhclswXTtcblxuICAgICAgICAgICAgdmFyIGVkaXRvciA9IG5ldyB3eXNpLkVkaXRvcih0aGlzLmVsWzBdLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLmV2ZW50cykge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgZXZlbnROYW1lIGluIG9wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5vbihldmVudE5hbWUsIG9wdGlvbnMuZXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlVG9vbGJhcjogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciB0b29sYmFyID0gJChcIjx1bC8+XCIsIHtcbiAgICAgICAgICAgICAgICAnY2xhc3MnIDogXCJ3eXNpaHRtbDUtdG9vbGJhclwiLFxuICAgICAgICAgICAgICAgICdzdHlsZSc6IFwiZGlzcGxheTpub25lXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGN1bHR1cmUgPSBvcHRpb25zLmxvY2FsZSB8fCBkZWZhdWx0T3B0aW9ucy5sb2NhbGUgfHwgXCJlblwiO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmKG9wdGlvbnNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdGlvbnNba2V5XSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBkZWZhdWx0T3B0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xiYXIuYXBwZW5kKHRlbXBsYXRlcyhrZXksIGxvY2FsZVtjdWx0dXJlXSwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGtleSA9PT0gXCJodG1sXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdEh0bWwodG9vbGJhcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZihrZXkgPT09IFwibGlua1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRJbnNlcnRMaW5rKHRvb2xiYXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoa2V5ID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdEluc2VydEltYWdlKHRvb2xiYXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihvcHRpb25zLnRvb2xiYXIpIHtcbiAgICAgICAgICAgICAgICBmb3Ioa2V5IGluIG9wdGlvbnMudG9vbGJhcikge1xuICAgICAgICAgICAgICAgICAgICB0b29sYmFyLmFwcGVuZChvcHRpb25zLnRvb2xiYXJba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b29sYmFyLmZpbmQoXCJhW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2Zvcm1hdEJsb2NrJ11cIikuY2xpY2soZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gJCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHNlbGYudG9vbGJhci5maW5kKCcuY3VycmVudC1mb250JykudGV4dChlbC5odG1sKCkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRvb2xiYXIuZmluZChcImFbZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nZm9yZUNvbG9yJ11cIikuY2xpY2soZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gJCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHNlbGYudG9vbGJhci5maW5kKCcuY3VycmVudC1jb2xvcicpLnRleHQoZWwuaHRtbCgpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmVsLmJlZm9yZSh0b29sYmFyKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRvb2xiYXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdEh0bWw6IGZ1bmN0aW9uKHRvb2xiYXIpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VWaWV3U2VsZWN0b3IgPSBcImFbZGF0YS13eXNpaHRtbDUtYWN0aW9uPSdjaGFuZ2VfdmlldyddXCI7XG4gICAgICAgICAgICB0b29sYmFyLmZpbmQoY2hhbmdlVmlld1NlbGVjdG9yKS5jbGljayhmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdG9vbGJhci5maW5kKCdhLmJ0bicpLm5vdChjaGFuZ2VWaWV3U2VsZWN0b3IpLnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdEluc2VydEltYWdlOiBmdW5jdGlvbih0b29sYmFyKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0SW1hZ2VNb2RhbCA9IHRvb2xiYXIuZmluZCgnLmJvb3RzdHJhcC13eXNpaHRtbDUtaW5zZXJ0LWltYWdlLW1vZGFsJyk7XG4gICAgICAgICAgICB2YXIgdXJsSW5wdXQgPSBpbnNlcnRJbWFnZU1vZGFsLmZpbmQoJy5ib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1pbWFnZS11cmwnKTtcbiAgICAgICAgICAgIHZhciBpbnNlcnRCdXR0b24gPSBpbnNlcnRJbWFnZU1vZGFsLmZpbmQoJ2EuYnRuLXByaW1hcnknKTtcbiAgICAgICAgICAgIHZhciBpbml0aWFsVmFsdWUgPSB1cmxJbnB1dC52YWwoKTtcbiAgICAgICAgICAgIHZhciBjYXJldEJvb2ttYXJrO1xuXG4gICAgICAgICAgICB2YXIgaW5zZXJ0SW1hZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gdXJsSW5wdXQudmFsKCk7XG4gICAgICAgICAgICAgICAgdXJsSW5wdXQudmFsKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5lZGl0b3IuY3VycmVudFZpZXcuZWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGlmIChjYXJldEJvb2ttYXJrKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLmVkaXRvci5jb21wb3Nlci5zZWxlY3Rpb24uc2V0Qm9va21hcmsoY2FyZXRCb29rbWFyayk7XG4gICAgICAgICAgICAgICAgICBjYXJldEJvb2ttYXJrID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5lZGl0b3IuY29tcG9zZXIuY29tbWFuZHMuZXhlYyhcImluc2VydEltYWdlXCIsIHVybCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB1cmxJbnB1dC5rZXlwcmVzcyhmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYoZS53aGljaCA9PSAxMykge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRJbWFnZU1vZGFsLm1vZGFsKCdoaWRlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGluc2VydEJ1dHRvbi5jbGljayhpbnNlcnRJbWFnZSk7XG5cbiAgICAgICAgICAgIGluc2VydEltYWdlTW9kYWwub24oJ3Nob3duJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdXJsSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbnNlcnRJbWFnZU1vZGFsLm9uKCdoaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lZGl0b3IuY3VycmVudFZpZXcuZWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRvb2xiYXIuZmluZCgnYVtkYXRhLXd5c2lodG1sNS1jb21tYW5kPWluc2VydEltYWdlXScpLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVCdXR0b24gPSAkKHRoaXMpLmhhc0NsYXNzKFwid3lzaWh0bWw1LWNvbW1hbmQtYWN0aXZlXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFhY3RpdmVCdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lZGl0b3IuY3VycmVudFZpZXcuZWxlbWVudC5mb2N1cyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0Qm9va21hcmsgPSBzZWxmLmVkaXRvci5jb21wb3Nlci5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0SW1hZ2VNb2RhbC5hcHBlbmRUbygnYm9keScpLm1vZGFsKCdzaG93Jyk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydEltYWdlTW9kYWwub24oJ2NsaWNrLmRpc21pc3MubW9kYWwnLCAnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRJbnNlcnRMaW5rOiBmdW5jdGlvbih0b29sYmFyKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0TGlua01vZGFsID0gdG9vbGJhci5maW5kKCcuYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtbGluay1tb2RhbCcpO1xuICAgICAgICAgICAgdmFyIHVybElucHV0ID0gaW5zZXJ0TGlua01vZGFsLmZpbmQoJy5ib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1saW5rLXVybCcpO1xuICAgICAgICAgICAgdmFyIGluc2VydEJ1dHRvbiA9IGluc2VydExpbmtNb2RhbC5maW5kKCdhLmJ0bi1wcmltYXJ5Jyk7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbFZhbHVlID0gdXJsSW5wdXQudmFsKCk7XG4gICAgICAgICAgICB2YXIgY2FyZXRCb29rbWFyaztcblxuICAgICAgICAgICAgdmFyIGluc2VydExpbmsgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gdXJsSW5wdXQudmFsKCk7XG4gICAgICAgICAgICAgICAgdXJsSW5wdXQudmFsKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5lZGl0b3IuY3VycmVudFZpZXcuZWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGlmIChjYXJldEJvb2ttYXJrKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLmVkaXRvci5jb21wb3Nlci5zZWxlY3Rpb24uc2V0Qm9va21hcmsoY2FyZXRCb29rbWFyayk7XG4gICAgICAgICAgICAgICAgICBjYXJldEJvb2ttYXJrID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5lZGl0b3IuY29tcG9zZXIuY29tbWFuZHMuZXhlYyhcImNyZWF0ZUxpbmtcIiwge1xuICAgICAgICAgICAgICAgICAgICBocmVmOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgICAgICAgcmVsOiBcIm5vZm9sbG93XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcHJlc3NlZEVudGVyID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHVybElucHV0LmtleXByZXNzKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZihlLndoaWNoID09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydExpbmsoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0TGlua01vZGFsLm1vZGFsKCdoaWRlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGluc2VydEJ1dHRvbi5jbGljayhpbnNlcnRMaW5rKTtcblxuICAgICAgICAgICAgaW5zZXJ0TGlua01vZGFsLm9uKCdzaG93bicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHVybElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaW5zZXJ0TGlua01vZGFsLm9uKCdoaWRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lZGl0b3IuY3VycmVudFZpZXcuZWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRvb2xiYXIuZmluZCgnYVtkYXRhLXd5c2lodG1sNS1jb21tYW5kPWNyZWF0ZUxpbmtdJykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZUJ1dHRvbiA9ICQodGhpcykuaGFzQ2xhc3MoXCJ3eXNpaHRtbDUtY29tbWFuZC1hY3RpdmVcIik7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWFjdGl2ZUJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVkaXRvci5jdXJyZW50Vmlldy5lbGVtZW50LmZvY3VzKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRCb29rbWFyayA9IHNlbGYuZWRpdG9yLmNvbXBvc2VyLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRMaW5rTW9kYWwuYXBwZW5kVG8oJ2JvZHknKS5tb2RhbCgnc2hvdycpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRMaW5rTW9kYWwub24oJ2NsaWNrLmRpc21pc3MubW9kYWwnLCAnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHRoZXNlIGRlZmluZSBvdXIgcHVibGljIGFwaVxuICAgIHZhciBtZXRob2RzID0ge1xuICAgICAgICByZXNldERlZmF1bHRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sICQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zQ2FjaGUpO1xuICAgICAgICB9LFxuICAgICAgICBieXBhc3NEZWZhdWx0czogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKCd3eXNpaHRtbDUnLCBuZXcgV3lzaWh0bWw1KCR0aGlzLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2hhbGxvd0V4dGVuZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCAkLmZuLnd5c2lodG1sNS5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5ieXBhc3NEZWZhdWx0cy5hcHBseSh0aGF0LCBbc2V0dGluZ3NdKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVlcEV4dGVuZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQodHJ1ZSwge30sICQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmJ5cGFzc0RlZmF1bHRzLmFwcGx5KHRoYXQsIFtzZXR0aW5nc10pO1xuICAgICAgICB9LFxuICAgICAgICBpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5zaGFsbG93RXh0ZW5kLmFwcGx5KHRoYXQsIFtvcHRpb25zXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5mbi53eXNpaHRtbDUgPSBmdW5jdGlvbiAoIG1ldGhvZCApIHtcbiAgICAgICAgaWYgKCBtZXRob2RzW21ldGhvZF0gKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kc1ttZXRob2RdLmFwcGx5KCB0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICkpO1xuICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhIG1ldGhvZCApIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJC5lcnJvciggJ01ldGhvZCAnICsgIG1ldGhvZCArICcgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5Lnd5c2lodG1sNScgKTtcbiAgICAgICAgfSAgICBcbiAgICB9O1xuXG4gICAgJC5mbi53eXNpaHRtbDUuQ29uc3RydWN0b3IgPSBXeXNpaHRtbDU7XG5cbiAgICB2YXIgZGVmYXVsdE9wdGlvbnMgPSAkLmZuLnd5c2lodG1sNS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgXCJmb250LXN0eWxlc1wiOiB0cnVlLFxuICAgICAgICBcImNvbG9yXCI6IGZhbHNlLFxuICAgICAgICBcImVtcGhhc2lzXCI6IHRydWUsXG4gICAgICAgIFwibGlzdHNcIjogdHJ1ZSxcbiAgICAgICAgXCJodG1sXCI6IGZhbHNlLFxuICAgICAgICBcImxpbmtcIjogdHJ1ZSxcbiAgICAgICAgXCJpbWFnZVwiOiB0cnVlLFxuICAgICAgICBldmVudHM6IHt9LFxuICAgICAgICBwYXJzZXJSdWxlczoge1xuICAgICAgICAgICAgY2xhc3Nlczoge1xuICAgICAgICAgICAgICAgIC8vIChwYXRoX3RvX3Byb2plY3QvbGliL2Nzcy93eXNpd3lnLWNvbG9yLmNzcylcbiAgICAgICAgICAgICAgICBcInd5c2l3eWctY29sb3Itc2lsdmVyXCIgOiAxLFxuICAgICAgICAgICAgICAgIFwid3lzaXd5Zy1jb2xvci1ncmF5XCIgOiAxLFxuICAgICAgICAgICAgICAgIFwid3lzaXd5Zy1jb2xvci13aGl0ZVwiIDogMSxcbiAgICAgICAgICAgICAgICBcInd5c2l3eWctY29sb3ItbWFyb29uXCIgOiAxLFxuICAgICAgICAgICAgICAgIFwid3lzaXd5Zy1jb2xvci1yZWRcIiA6IDEsXG4gICAgICAgICAgICAgICAgXCJ3eXNpd3lnLWNvbG9yLXB1cnBsZVwiIDogMSxcbiAgICAgICAgICAgICAgICBcInd5c2l3eWctY29sb3ItZnVjaHNpYVwiIDogMSxcbiAgICAgICAgICAgICAgICBcInd5c2l3eWctY29sb3ItZ3JlZW5cIiA6IDEsXG4gICAgICAgICAgICAgICAgXCJ3eXNpd3lnLWNvbG9yLWxpbWVcIiA6IDEsXG4gICAgICAgICAgICAgICAgXCJ3eXNpd3lnLWNvbG9yLW9saXZlXCIgOiAxLFxuICAgICAgICAgICAgICAgIFwid3lzaXd5Zy1jb2xvci15ZWxsb3dcIiA6IDEsXG4gICAgICAgICAgICAgICAgXCJ3eXNpd3lnLWNvbG9yLW5hdnlcIiA6IDEsXG4gICAgICAgICAgICAgICAgXCJ3eXNpd3lnLWNvbG9yLWJsdWVcIiA6IDEsXG4gICAgICAgICAgICAgICAgXCJ3eXNpd3lnLWNvbG9yLXRlYWxcIiA6IDEsXG4gICAgICAgICAgICAgICAgXCJ3eXNpd3lnLWNvbG9yLWFxdWFcIiA6IDEsXG4gICAgICAgICAgICAgICAgXCJ3eXNpd3lnLWNvbG9yLW9yYW5nZVwiIDogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRhZ3M6IHtcbiAgICAgICAgICAgICAgICBcImJcIjogIHt9LFxuICAgICAgICAgICAgICAgIFwiaVwiOiAge30sXG4gICAgICAgICAgICAgICAgXCJiclwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIm9sXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwidWxcIjoge30sXG4gICAgICAgICAgICAgICAgXCJsaVwiOiB7fSxcbiAgICAgICAgICAgICAgICBcImgxXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiaDJcIjoge30sXG4gICAgICAgICAgICAgICAgXCJoM1wiOiB7fSxcbiAgICAgICAgICAgICAgICBcImJsb2NrcXVvdGVcIjoge30sXG4gICAgICAgICAgICAgICAgXCJ1XCI6IDEsXG4gICAgICAgICAgICAgICAgXCJpbWdcIjoge1xuICAgICAgICAgICAgICAgICAgICBcImNoZWNrX2F0dHJpYnV0ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIm51bWJlcnNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYWx0XCI6IFwiYWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNyY1wiOiBcInVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCJudW1iZXJzXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhXCI6ICB7XG4gICAgICAgICAgICAgICAgICAgIHNldF9hdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWw6ICAgIFwibm9mb2xsb3dcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjaGVja19hdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAgIFwidXJsXCIgLy8gaW1wb3J0YW50IHRvIGF2b2lkIFhTU1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInNwYW5cIjogMSxcbiAgICAgICAgICAgICAgICBcImRpdlwiOiAxLFxuICAgICAgICAgICAgICAgIC8vIHRvIGFsbG93IHNhdmUgYW5kIGVkaXQgZmlsZXMgd2l0aCBjb2RlIHRhZyBoYWNrc1xuICAgICAgICAgICAgICAgIFwiY29kZVwiOiAxLFxuICAgICAgICAgICAgICAgIFwicHJlXCI6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGVzaGVldHM6IFtcIi4vbGliL2Nzcy93eXNpd3lnLWNvbG9yLmNzc1wiXSwgLy8gKHBhdGhfdG9fcHJvamVjdC9saWIvY3NzL3d5c2l3eWctY29sb3IuY3NzKVxuICAgICAgICBsb2NhbGU6IFwiZW5cIlxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mICQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zQ2FjaGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zQ2FjaGUgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5mbi53eXNpaHRtbDUuZGVmYXVsdE9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBsb2NhbGUgPSAkLmZuLnd5c2lodG1sNS5sb2NhbGUgPSB7XG4gICAgICAgIGVuOiB7XG4gICAgICAgICAgICBmb250X3N0eWxlczoge1xuICAgICAgICAgICAgICAgIG5vcm1hbDogXCJOb3JtYWwgdGV4dFwiLFxuICAgICAgICAgICAgICAgIGgxOiBcIkhlYWRpbmcgMVwiLFxuICAgICAgICAgICAgICAgIGgyOiBcIkhlYWRpbmcgMlwiLFxuICAgICAgICAgICAgICAgIGgzOiBcIkhlYWRpbmcgM1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgICAgICAgICBib2xkOiBcIkJvbGRcIixcbiAgICAgICAgICAgICAgICBpdGFsaWM6IFwiSXRhbGljXCIsXG4gICAgICAgICAgICAgICAgdW5kZXJsaW5lOiBcIlVuZGVybGluZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGlzdHM6IHtcbiAgICAgICAgICAgICAgICB1bm9yZGVyZWQ6IFwiVW5vcmRlcmVkIGxpc3RcIixcbiAgICAgICAgICAgICAgICBvcmRlcmVkOiBcIk9yZGVyZWQgbGlzdFwiLFxuICAgICAgICAgICAgICAgIG91dGRlbnQ6IFwiT3V0ZGVudFwiLFxuICAgICAgICAgICAgICAgIGluZGVudDogXCJJbmRlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IHtcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IFwiSW5zZXJ0IGxpbmtcIixcbiAgICAgICAgICAgICAgICBjYW5jZWw6IFwiQ2FuY2VsXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgICAgIGluc2VydDogXCJJbnNlcnQgaW1hZ2VcIixcbiAgICAgICAgICAgICAgICBjYW5jZWw6IFwiQ2FuY2VsXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBodG1sOiB7XG4gICAgICAgICAgICAgICAgZWRpdDogXCJFZGl0IEhUTUxcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbG91cnM6IHtcbiAgICAgICAgICAgICAgICBibGFjazogXCJCbGFja1wiLFxuICAgICAgICAgICAgICAgIHNpbHZlcjogXCJTaWx2ZXJcIixcbiAgICAgICAgICAgICAgICBncmF5OiBcIkdyZXlcIixcbiAgICAgICAgICAgICAgICBtYXJvb246IFwiTWFyb29uXCIsXG4gICAgICAgICAgICAgICAgcmVkOiBcIlJlZFwiLFxuICAgICAgICAgICAgICAgIHB1cnBsZTogXCJQdXJwbGVcIixcbiAgICAgICAgICAgICAgICBncmVlbjogXCJHcmVlblwiLFxuICAgICAgICAgICAgICAgIG9saXZlOiBcIk9saXZlXCIsXG4gICAgICAgICAgICAgICAgbmF2eTogXCJOYXZ5XCIsXG4gICAgICAgICAgICAgICAgYmx1ZTogXCJCbHVlXCIsXG4gICAgICAgICAgICAgICAgb3JhbmdlOiBcIk9yYW5nZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG59KHdpbmRvdy5qUXVlcnksIHdpbmRvdy53eXNpaHRtbDUpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lZGl0YWJsZS9qcy9ib290c3RyYXAtd3lzaWh0bWw1LTAuMC4yLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * @license wysihtml5 v0.3.0\n * https://github.com/xing/wysihtml5\n *\n * Author: Christopher Blum (https://github.com/tiff)\n *\n * Copyright (C) 2012 XING AG\n * Licensed under the MIT license (MIT)\n *\n */\nvar wysihtml5 = {\n  version: \"0.3.0\",\n\n  // namespaces\n  commands: {},\n  dom: {},\n  quirks: {},\n  toolbar: {},\n  lang: {},\n  selection: {},\n  views: {},\n\n  INVISIBLE_SPACE: \"\\uFEFF\",\n\n  EMPTY_FUNCTION: function EMPTY_FUNCTION() {},\n\n  ELEMENT_NODE: 1,\n  TEXT_NODE: 3,\n\n  BACKSPACE_KEY: 8,\n  ENTER_KEY: 13,\n  ESCAPE_KEY: 27,\n  SPACE_KEY: 32,\n  DELETE_KEY: 46\n}; /**\n   * @license Rangy, a cross-browser JavaScript range and selection library\n   * http://code.google.com/p/rangy/\n   *\n   * Copyright 2011, Tim Down\n   * Licensed under the MIT license.\n   * Version: 1.2.2\n   * Build date: 13 November 2011\n   */\nwindow['rangy'] = function () {\n\n  var OBJECT = \"object\",\n      FUNCTION = \"function\",\n      UNDEFINED = \"undefined\";\n\n  var domRangeProperties = [\"startContainer\", \"startOffset\", \"endContainer\", \"endOffset\", \"collapsed\", \"commonAncestorContainer\", \"START_TO_START\", \"START_TO_END\", \"END_TO_START\", \"END_TO_END\"];\n\n  var domRangeMethods = [\"setStart\", \"setStartBefore\", \"setStartAfter\", \"setEnd\", \"setEndBefore\", \"setEndAfter\", \"collapse\", \"selectNode\", \"selectNodeContents\", \"compareBoundaryPoints\", \"deleteContents\", \"extractContents\", \"cloneContents\", \"insertNode\", \"surroundContents\", \"cloneRange\", \"toString\", \"detach\"];\n\n  var textRangeProperties = [\"boundingHeight\", \"boundingLeft\", \"boundingTop\", \"boundingWidth\", \"htmlText\", \"text\"];\n\n  // Subset of TextRange's full set of methods that we're interested in\n  var textRangeMethods = [\"collapse\", \"compareEndPoints\", \"duplicate\", \"getBookmark\", \"moveToBookmark\", \"moveToElementText\", \"parentElement\", \"pasteHTML\", \"select\", \"setEndPoint\", \"getBoundingClientRect\"];\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Trio of functions taken from Peter Michaux's article:\n  // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting\n  function isHostMethod(o, p) {\n    var t = _typeof(o[p]);\n    return t == FUNCTION || !!(t == OBJECT && o[p]) || t == \"unknown\";\n  }\n\n  function isHostObject(o, p) {\n    return !!(_typeof(o[p]) == OBJECT && o[p]);\n  }\n\n  function isHostProperty(o, p) {\n    return _typeof(o[p]) != UNDEFINED;\n  }\n\n  // Creates a convenience function to save verbose repeated calls to tests functions\n  function createMultiplePropertyTest(testFunc) {\n    return function (o, props) {\n      var i = props.length;\n      while (i--) {\n        if (!testFunc(o, props[i])) {\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n\n  // Next trio of functions are a convenience to save verbose repeated calls to previous two functions\n  var areHostMethods = createMultiplePropertyTest(isHostMethod);\n  var areHostObjects = createMultiplePropertyTest(isHostObject);\n  var areHostProperties = createMultiplePropertyTest(isHostProperty);\n\n  function isTextRange(range) {\n    return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);\n  }\n\n  var api = {\n    version: \"1.2.2\",\n    initialized: false,\n    supported: true,\n\n    util: {\n      isHostMethod: isHostMethod,\n      isHostObject: isHostObject,\n      isHostProperty: isHostProperty,\n      areHostMethods: areHostMethods,\n      areHostObjects: areHostObjects,\n      areHostProperties: areHostProperties,\n      isTextRange: isTextRange\n    },\n\n    features: {},\n\n    modules: {},\n    config: {\n      alertOnWarn: false,\n      preferTextRange: false\n    }\n  };\n\n  function fail(reason) {\n    window.alert(\"Rangy not supported in your browser. Reason: \" + reason);\n    api.initialized = true;\n    api.supported = false;\n  }\n\n  api.fail = fail;\n\n  function warn(msg) {\n    var warningMessage = \"Rangy warning: \" + msg;\n    if (api.config.alertOnWarn) {\n      window.alert(warningMessage);\n    } else if (_typeof(window.console) != UNDEFINED && _typeof(window.console.log) != UNDEFINED) {\n      window.console.log(warningMessage);\n    }\n  }\n\n  api.warn = warn;\n\n  if ({}.hasOwnProperty) {\n    api.util.extend = function (o, props) {\n      for (var i in props) {\n        if (props.hasOwnProperty(i)) {\n          o[i] = props[i];\n        }\n      }\n    };\n  } else {\n    fail(\"hasOwnProperty not supported\");\n  }\n\n  var initListeners = [];\n  var moduleInitializers = [];\n\n  // Initialization\n  function init() {\n    if (api.initialized) {\n      return;\n    }\n    var testRange;\n    var implementsDomRange = false,\n        implementsTextRange = false;\n\n    // First, perform basic feature tests\n\n    if (isHostMethod(document, \"createRange\")) {\n      testRange = document.createRange();\n      if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {\n        implementsDomRange = true;\n      }\n      testRange.detach();\n    }\n\n    var body = isHostObject(document, \"body\") ? document.body : document.getElementsByTagName(\"body\")[0];\n\n    if (body && isHostMethod(body, \"createTextRange\")) {\n      testRange = body.createTextRange();\n      if (isTextRange(testRange)) {\n        implementsTextRange = true;\n      }\n    }\n\n    if (!implementsDomRange && !implementsTextRange) {\n      fail(\"Neither Range nor TextRange are implemented\");\n    }\n\n    api.initialized = true;\n    api.features = {\n      implementsDomRange: implementsDomRange,\n      implementsTextRange: implementsTextRange\n    };\n\n    // Initialize modules and call init listeners\n    var allListeners = moduleInitializers.concat(initListeners);\n    for (var i = 0, len = allListeners.length; i < len; ++i) {\n      try {\n        allListeners[i](api);\n      } catch (ex) {\n        if (isHostObject(window, \"console\") && isHostMethod(window.console, \"log\")) {\n          window.console.log(\"Init listener threw an exception. Continuing.\", ex);\n        }\n      }\n    }\n  }\n\n  // Allow external scripts to initialize this library in case it's loaded after the document has loaded\n  api.init = init;\n\n  // Execute listener immediately if already initialized\n  api.addInitListener = function (listener) {\n    if (api.initialized) {\n      listener(api);\n    } else {\n      initListeners.push(listener);\n    }\n  };\n\n  var createMissingNativeApiListeners = [];\n\n  api.addCreateMissingNativeApiListener = function (listener) {\n    createMissingNativeApiListeners.push(listener);\n  };\n\n  function createMissingNativeApi(win) {\n    win = win || window;\n    init();\n\n    // Notify listeners\n    for (var i = 0, len = createMissingNativeApiListeners.length; i < len; ++i) {\n      createMissingNativeApiListeners[i](win);\n    }\n  }\n\n  api.createMissingNativeApi = createMissingNativeApi;\n\n  /**\n   * @constructor\n   */\n  function Module(name) {\n    this.name = name;\n    this.initialized = false;\n    this.supported = false;\n  }\n\n  Module.prototype.fail = function (reason) {\n    this.initialized = true;\n    this.supported = false;\n\n    throw new Error(\"Module '\" + this.name + \"' failed to load: \" + reason);\n  };\n\n  Module.prototype.warn = function (msg) {\n    api.warn(\"Module \" + this.name + \": \" + msg);\n  };\n\n  Module.prototype.createError = function (msg) {\n    return new Error(\"Error in Rangy \" + this.name + \" module: \" + msg);\n  };\n\n  api.createModule = function (name, initFunc) {\n    var module = new Module(name);\n    api.modules[name] = module;\n\n    moduleInitializers.push(function (api) {\n      initFunc(api, module);\n      module.initialized = true;\n      module.supported = true;\n    });\n  };\n\n  api.requireModules = function (modules) {\n    for (var i = 0, len = modules.length, module, moduleName; i < len; ++i) {\n      moduleName = modules[i];\n      module = api.modules[moduleName];\n      if (!module || !(module instanceof Module)) {\n        throw new Error(\"Module '\" + moduleName + \"' not found\");\n      }\n      if (!module.supported) {\n        throw new Error(\"Module '\" + moduleName + \"' not supported\");\n      }\n    }\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Wait for document to load before running tests\n\n  var docReady = false;\n\n  var loadHandler = function loadHandler(e) {\n\n    if (!docReady) {\n      docReady = true;\n      if (!api.initialized) {\n        init();\n      }\n    }\n  };\n\n  // Test whether we have window and document objects that we will need\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) == UNDEFINED) {\n    fail(\"No window found\");\n    return;\n  }\n  if ((typeof document === \"undefined\" ? \"undefined\" : _typeof(document)) == UNDEFINED) {\n    fail(\"No document found\");\n    return;\n  }\n\n  if (isHostMethod(document, \"addEventListener\")) {\n    document.addEventListener(\"DOMContentLoaded\", loadHandler, false);\n  }\n\n  // Add a fallback in case the DOMContentLoaded event isn't supported\n  if (isHostMethod(window, \"addEventListener\")) {\n    window.addEventListener(\"load\", loadHandler, false);\n  } else if (isHostMethod(window, \"attachEvent\")) {\n    window.attachEvent(\"onload\", loadHandler);\n  } else {\n    fail(\"Window does not have required addEventListener or attachEvent method\");\n  }\n\n  return api;\n}();\nrangy.createModule(\"DomUtil\", function (api, module) {\n\n  var UNDEF = \"undefined\";\n  var util = api.util;\n\n  // Perform feature tests\n  if (!util.areHostMethods(document, [\"createDocumentFragment\", \"createElement\", \"createTextNode\"])) {\n    module.fail(\"document missing a Node creation method\");\n  }\n\n  if (!util.isHostMethod(document, \"getElementsByTagName\")) {\n    module.fail(\"document missing getElementsByTagName method\");\n  }\n\n  var el = document.createElement(\"div\");\n  if (!util.areHostMethods(el, [\"insertBefore\", \"appendChild\", \"cloneNode\"] || !util.areHostObjects(el, [\"previousSibling\", \"nextSibling\", \"childNodes\", \"parentNode\"]))) {\n    module.fail(\"Incomplete Element implementation\");\n  }\n\n  // innerHTML is required for Range's createContextualFragment method\n  if (!util.isHostProperty(el, \"innerHTML\")) {\n    module.fail(\"Element is missing innerHTML property\");\n  }\n\n  var textNode = document.createTextNode(\"test\");\n  if (!util.areHostMethods(textNode, [\"splitText\", \"deleteData\", \"insertData\", \"appendData\", \"cloneNode\"] || !util.areHostObjects(el, [\"previousSibling\", \"nextSibling\", \"childNodes\", \"parentNode\"]) || !util.areHostProperties(textNode, [\"data\"]))) {\n    module.fail(\"Incomplete Text Node implementation\");\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven't been\n  // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that\n  // contains just the document as a single element and the value searched for is the document.\n  var arrayContains = /*Array.prototype.indexOf ?\n                      function(arr, val) {\n                      return arr.indexOf(val) > -1;\n                      }:*/\n\n  function arrayContains(arr, val) {\n    var i = arr.length;\n    while (i--) {\n      if (arr[i] === val) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI\n  function isHtmlNamespace(node) {\n    var ns;\n    return _typeof(node.namespaceURI) == UNDEF || (ns = node.namespaceURI) === null || ns == \"http://www.w3.org/1999/xhtml\";\n  }\n\n  function parentElement(node) {\n    var parent = node.parentNode;\n    return parent.nodeType == 1 ? parent : null;\n  }\n\n  function getNodeIndex(node) {\n    var i = 0;\n    while (node = node.previousSibling) {\n      i++;\n    }\n    return i;\n  }\n\n  function getNodeLength(node) {\n    var childNodes;\n    return isCharacterDataNode(node) ? node.length : (childNodes = node.childNodes) ? childNodes.length : 0;\n  }\n\n  function getCommonAncestor(node1, node2) {\n    var ancestors = [],\n        n;\n    for (n = node1; n; n = n.parentNode) {\n      ancestors.push(n);\n    }\n\n    for (n = node2; n; n = n.parentNode) {\n      if (arrayContains(ancestors, n)) {\n        return n;\n      }\n    }\n\n    return null;\n  }\n\n  function isAncestorOf(ancestor, descendant, selfIsAncestor) {\n    var n = selfIsAncestor ? descendant : descendant.parentNode;\n    while (n) {\n      if (n === ancestor) {\n        return true;\n      } else {\n        n = n.parentNode;\n      }\n    }\n    return false;\n  }\n\n  function getClosestAncestorIn(node, ancestor, selfIsAncestor) {\n    var p,\n        n = selfIsAncestor ? node : node.parentNode;\n    while (n) {\n      p = n.parentNode;\n      if (p === ancestor) {\n        return n;\n      }\n      n = p;\n    }\n    return null;\n  }\n\n  function isCharacterDataNode(node) {\n    var t = node.nodeType;\n    return t == 3 || t == 4 || t == 8; // Text, CDataSection or Comment\n  }\n\n  function insertAfter(node, precedingNode) {\n    var nextNode = precedingNode.nextSibling,\n        parent = precedingNode.parentNode;\n    if (nextNode) {\n      parent.insertBefore(node, nextNode);\n    } else {\n      parent.appendChild(node);\n    }\n    return node;\n  }\n\n  // Note that we cannot use splitText() because it is bugridden in IE 9.\n  function splitDataNode(node, index) {\n    var newNode = node.cloneNode(false);\n    newNode.deleteData(0, index);\n    node.deleteData(index, node.length - index);\n    insertAfter(newNode, node);\n    return newNode;\n  }\n\n  function getDocument(node) {\n    if (node.nodeType == 9) {\n      return node;\n    } else if (_typeof(node.ownerDocument) != UNDEF) {\n      return node.ownerDocument;\n    } else if (_typeof(node.document) != UNDEF) {\n      return node.document;\n    } else if (node.parentNode) {\n      return getDocument(node.parentNode);\n    } else {\n      throw new Error(\"getDocument: no document found for node\");\n    }\n  }\n\n  function getWindow(node) {\n    var doc = getDocument(node);\n    if (_typeof(doc.defaultView) != UNDEF) {\n      return doc.defaultView;\n    } else if (_typeof(doc.parentWindow) != UNDEF) {\n      return doc.parentWindow;\n    } else {\n      throw new Error(\"Cannot get a window object for node\");\n    }\n  }\n\n  function getIframeDocument(iframeEl) {\n    if (_typeof(iframeEl.contentDocument) != UNDEF) {\n      return iframeEl.contentDocument;\n    } else if (_typeof(iframeEl.contentWindow) != UNDEF) {\n      return iframeEl.contentWindow.document;\n    } else {\n      throw new Error(\"getIframeWindow: No Document object found for iframe element\");\n    }\n  }\n\n  function getIframeWindow(iframeEl) {\n    if (_typeof(iframeEl.contentWindow) != UNDEF) {\n      return iframeEl.contentWindow;\n    } else if (_typeof(iframeEl.contentDocument) != UNDEF) {\n      return iframeEl.contentDocument.defaultView;\n    } else {\n      throw new Error(\"getIframeWindow: No Window object found for iframe element\");\n    }\n  }\n\n  function getBody(doc) {\n    return util.isHostObject(doc, \"body\") ? doc.body : doc.getElementsByTagName(\"body\")[0];\n  }\n\n  function getRootContainer(node) {\n    var parent;\n    while (parent = node.parentNode) {\n      node = parent;\n    }\n    return node;\n  }\n\n  function comparePoints(nodeA, offsetA, nodeB, offsetB) {\n    // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing\n    var nodeC, root, childA, childB, n;\n    if (nodeA == nodeB) {\n\n      // Case 1: nodes are the same\n      return offsetA === offsetB ? 0 : offsetA < offsetB ? -1 : 1;\n    } else if (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) {\n\n      // Case 2: node C (container B or an ancestor) is a child node of A\n      return offsetA <= getNodeIndex(nodeC) ? -1 : 1;\n    } else if (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) {\n\n      // Case 3: node C (container A or an ancestor) is a child node of B\n      return getNodeIndex(nodeC) < offsetB ? -1 : 1;\n    } else {\n\n      // Case 4: containers are siblings or descendants of siblings\n      root = getCommonAncestor(nodeA, nodeB);\n      childA = nodeA === root ? root : getClosestAncestorIn(nodeA, root, true);\n      childB = nodeB === root ? root : getClosestAncestorIn(nodeB, root, true);\n\n      if (childA === childB) {\n        // This shouldn't be possible\n\n        throw new Error(\"comparePoints got to case 4 and childA and childB are the same!\");\n      } else {\n        n = root.firstChild;\n        while (n) {\n          if (n === childA) {\n            return -1;\n          } else if (n === childB) {\n            return 1;\n          }\n          n = n.nextSibling;\n        }\n        throw new Error(\"Should not be here!\");\n      }\n    }\n  }\n\n  function fragmentFromNodeChildren(node) {\n    var fragment = getDocument(node).createDocumentFragment(),\n        child;\n    while (child = node.firstChild) {\n      fragment.appendChild(child);\n    }\n    return fragment;\n  }\n\n  function inspectNode(node) {\n    if (!node) {\n      return \"[No node]\";\n    }\n    if (isCharacterDataNode(node)) {\n      return '\"' + node.data + '\"';\n    } else if (node.nodeType == 1) {\n      var idAttr = node.id ? ' id=\"' + node.id + '\"' : \"\";\n      return \"<\" + node.nodeName + idAttr + \">[\" + node.childNodes.length + \"]\";\n    } else {\n      return node.nodeName;\n    }\n  }\n\n  /**\n   * @constructor\n   */\n  function NodeIterator(root) {\n    this.root = root;\n    this._next = root;\n  }\n\n  NodeIterator.prototype = {\n    _current: null,\n\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n\n    next: function next() {\n      var n = this._current = this._next;\n      var child, next;\n      if (this._current) {\n        child = n.firstChild;\n        if (child) {\n          this._next = child;\n        } else {\n          next = null;\n          while (n !== this.root && !(next = n.nextSibling)) {\n            n = n.parentNode;\n          }\n          this._next = next;\n        }\n      }\n      return this._current;\n    },\n\n    detach: function detach() {\n      this._current = this._next = this.root = null;\n    }\n  };\n\n  function createIterator(root) {\n    return new NodeIterator(root);\n  }\n\n  /**\n   * @constructor\n   */\n  function DomPosition(node, offset) {\n    this.node = node;\n    this.offset = offset;\n  }\n\n  DomPosition.prototype = {\n    equals: function equals(pos) {\n      return this.node === pos.node & this.offset == pos.offset;\n    },\n\n    inspect: function inspect() {\n      return \"[DomPosition(\" + inspectNode(this.node) + \":\" + this.offset + \")]\";\n    }\n  };\n\n  /**\n   * @constructor\n   */\n  function DOMException(codeName) {\n    this.code = this[codeName];\n    this.codeName = codeName;\n    this.message = \"DOMException: \" + this.codeName;\n  }\n\n  DOMException.prototype = {\n    INDEX_SIZE_ERR: 1,\n    HIERARCHY_REQUEST_ERR: 3,\n    WRONG_DOCUMENT_ERR: 4,\n    NO_MODIFICATION_ALLOWED_ERR: 7,\n    NOT_FOUND_ERR: 8,\n    NOT_SUPPORTED_ERR: 9,\n    INVALID_STATE_ERR: 11\n  };\n\n  DOMException.prototype.toString = function () {\n    return this.message;\n  };\n\n  api.dom = {\n    arrayContains: arrayContains,\n    isHtmlNamespace: isHtmlNamespace,\n    parentElement: parentElement,\n    getNodeIndex: getNodeIndex,\n    getNodeLength: getNodeLength,\n    getCommonAncestor: getCommonAncestor,\n    isAncestorOf: isAncestorOf,\n    getClosestAncestorIn: getClosestAncestorIn,\n    isCharacterDataNode: isCharacterDataNode,\n    insertAfter: insertAfter,\n    splitDataNode: splitDataNode,\n    getDocument: getDocument,\n    getWindow: getWindow,\n    getIframeWindow: getIframeWindow,\n    getIframeDocument: getIframeDocument,\n    getBody: getBody,\n    getRootContainer: getRootContainer,\n    comparePoints: comparePoints,\n    inspectNode: inspectNode,\n    fragmentFromNodeChildren: fragmentFromNodeChildren,\n    createIterator: createIterator,\n    DomPosition: DomPosition\n  };\n\n  api.DOMException = DOMException;\n});rangy.createModule(\"DomRange\", function (api, module) {\n  api.requireModules([\"DomUtil\"]);\n\n  var dom = api.dom;\n  var DomPosition = dom.DomPosition;\n  var DOMException = api.DOMException;\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Utility functions\n\n  function isNonTextPartiallySelected(node, range) {\n    return node.nodeType != 3 && (dom.isAncestorOf(node, range.startContainer, true) || dom.isAncestorOf(node, range.endContainer, true));\n  }\n\n  function getRangeDocument(range) {\n    return dom.getDocument(range.startContainer);\n  }\n\n  function dispatchEvent(range, type, args) {\n    var listeners = range._listeners[type];\n    if (listeners) {\n      for (var i = 0, len = listeners.length; i < len; ++i) {\n        listeners[i].call(range, { target: range, args: args });\n      }\n    }\n  }\n\n  function getBoundaryBeforeNode(node) {\n    return new DomPosition(node.parentNode, dom.getNodeIndex(node));\n  }\n\n  function getBoundaryAfterNode(node) {\n    return new DomPosition(node.parentNode, dom.getNodeIndex(node) + 1);\n  }\n\n  function insertNodeAtPosition(node, n, o) {\n    var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;\n    if (dom.isCharacterDataNode(n)) {\n      if (o == n.length) {\n        dom.insertAfter(node, n);\n      } else {\n        n.parentNode.insertBefore(node, o == 0 ? n : dom.splitDataNode(n, o));\n      }\n    } else if (o >= n.childNodes.length) {\n      n.appendChild(node);\n    } else {\n      n.insertBefore(node, n.childNodes[o]);\n    }\n    return firstNodeInserted;\n  }\n\n  function cloneSubtree(iterator) {\n    var partiallySelected;\n    for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {\n      partiallySelected = iterator.isPartiallySelectedSubtree();\n\n      node = node.cloneNode(!partiallySelected);\n      if (partiallySelected) {\n        subIterator = iterator.getSubtreeIterator();\n        node.appendChild(cloneSubtree(subIterator));\n        subIterator.detach(true);\n      }\n\n      if (node.nodeType == 10) {\n        // DocumentType\n        throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n      }\n      frag.appendChild(node);\n    }\n    return frag;\n  }\n\n  function iterateSubtree(rangeIterator, func, iteratorState) {\n    var it, n;\n    iteratorState = iteratorState || { stop: false };\n    for (var node, subRangeIterator; node = rangeIterator.next();) {\n      //log.debug(\"iterateSubtree, partially selected: \" + rangeIterator.isPartiallySelectedSubtree(), nodeToString(node));\n      if (rangeIterator.isPartiallySelectedSubtree()) {\n        // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of the\n        // node selected by the Range.\n        if (func(node) === false) {\n          iteratorState.stop = true;\n          return;\n        } else {\n          subRangeIterator = rangeIterator.getSubtreeIterator();\n          iterateSubtree(subRangeIterator, func, iteratorState);\n          subRangeIterator.detach(true);\n          if (iteratorState.stop) {\n            return;\n          }\n        }\n      } else {\n        // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its\n        // descendant\n        it = dom.createIterator(node);\n        while (n = it.next()) {\n          if (func(n) === false) {\n            iteratorState.stop = true;\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  function deleteSubtree(iterator) {\n    var subIterator;\n    while (iterator.next()) {\n      if (iterator.isPartiallySelectedSubtree()) {\n        subIterator = iterator.getSubtreeIterator();\n        deleteSubtree(subIterator);\n        subIterator.detach(true);\n      } else {\n        iterator.remove();\n      }\n    }\n  }\n\n  function extractSubtree(iterator) {\n\n    for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {\n\n      if (iterator.isPartiallySelectedSubtree()) {\n        node = node.cloneNode(false);\n        subIterator = iterator.getSubtreeIterator();\n        node.appendChild(extractSubtree(subIterator));\n        subIterator.detach(true);\n      } else {\n        iterator.remove();\n      }\n      if (node.nodeType == 10) {\n        // DocumentType\n        throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n      }\n      frag.appendChild(node);\n    }\n    return frag;\n  }\n\n  function getNodesInRange(range, nodeTypes, filter) {\n    //log.info(\"getNodesInRange, \" + nodeTypes.join(\",\"));\n    var filterNodeTypes = !!(nodeTypes && nodeTypes.length),\n        regex;\n    var filterExists = !!filter;\n    if (filterNodeTypes) {\n      regex = new RegExp(\"^(\" + nodeTypes.join(\"|\") + \")$\");\n    }\n\n    var nodes = [];\n    iterateSubtree(new RangeIterator(range, false), function (node) {\n      if ((!filterNodeTypes || regex.test(node.nodeType)) && (!filterExists || filter(node))) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  }\n\n  function _inspect(range) {\n    var name = typeof range.getName == \"undefined\" ? \"Range\" : range.getName();\n    return \"[\" + name + \"(\" + dom.inspectNode(range.startContainer) + \":\" + range.startOffset + \", \" + dom.inspectNode(range.endContainer) + \":\" + range.endOffset + \")]\";\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)\n\n  /**\n   * @constructor\n   */\n  function RangeIterator(range, clonePartiallySelectedTextNodes) {\n    this.range = range;\n    this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n    if (!range.collapsed) {\n      this.sc = range.startContainer;\n      this.so = range.startOffset;\n      this.ec = range.endContainer;\n      this.eo = range.endOffset;\n      var root = range.commonAncestorContainer;\n\n      if (this.sc === this.ec && dom.isCharacterDataNode(this.sc)) {\n        this.isSingleCharacterDataNode = true;\n        this._first = this._last = this._next = this.sc;\n      } else {\n        this._first = this._next = this.sc === root && !dom.isCharacterDataNode(this.sc) ? this.sc.childNodes[this.so] : dom.getClosestAncestorIn(this.sc, root, true);\n        this._last = this.ec === root && !dom.isCharacterDataNode(this.ec) ? this.ec.childNodes[this.eo - 1] : dom.getClosestAncestorIn(this.ec, root, true);\n      }\n    }\n  }\n\n  RangeIterator.prototype = {\n    _current: null,\n    _next: null,\n    _first: null,\n    _last: null,\n    isSingleCharacterDataNode: false,\n\n    reset: function reset() {\n      this._current = null;\n      this._next = this._first;\n    },\n\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n\n    next: function next() {\n      // Move to next node\n      var current = this._current = this._next;\n      if (current) {\n        this._next = current !== this._last ? current.nextSibling : null;\n\n        // Check for partially selected text nodes\n        if (dom.isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n          if (current === this.ec) {\n\n            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n          }\n          if (this._current === this.sc) {\n\n            (current = current.cloneNode(true)).deleteData(0, this.so);\n          }\n        }\n      }\n\n      return current;\n    },\n\n    remove: function remove() {\n      var current = this._current,\n          start,\n          end;\n\n      if (dom.isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {\n        start = current === this.sc ? this.so : 0;\n        end = current === this.ec ? this.eo : current.length;\n        if (start != end) {\n          current.deleteData(start, end - start);\n        }\n      } else {\n        if (current.parentNode) {\n          current.parentNode.removeChild(current);\n        } else {}\n      }\n    },\n\n    // Checks if the current node is partially selected\n    isPartiallySelectedSubtree: function isPartiallySelectedSubtree() {\n      var current = this._current;\n      return isNonTextPartiallySelected(current, this.range);\n    },\n\n    getSubtreeIterator: function getSubtreeIterator() {\n      var subRange;\n      if (this.isSingleCharacterDataNode) {\n        subRange = this.range.cloneRange();\n        subRange.collapse();\n      } else {\n        subRange = new Range(getRangeDocument(this.range));\n        var current = this._current;\n        var startContainer = current,\n            startOffset = 0,\n            endContainer = current,\n            endOffset = dom.getNodeLength(current);\n\n        if (dom.isAncestorOf(current, this.sc, true)) {\n          startContainer = this.sc;\n          startOffset = this.so;\n        }\n        if (dom.isAncestorOf(current, this.ec, true)) {\n          endContainer = this.ec;\n          endOffset = this.eo;\n        }\n\n        updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);\n      }\n      return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);\n    },\n\n    detach: function detach(detachRange) {\n      if (detachRange) {\n        this.range.detach();\n      }\n      this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;\n    }\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Exceptions\n\n  /**\n   * @constructor\n   */\n  function RangeException(codeName) {\n    this.code = this[codeName];\n    this.codeName = codeName;\n    this.message = \"RangeException: \" + this.codeName;\n  }\n\n  RangeException.prototype = {\n    BAD_BOUNDARYPOINTS_ERR: 1,\n    INVALID_NODE_TYPE_ERR: 2\n  };\n\n  RangeException.prototype.toString = function () {\n    return this.message;\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  /**\n   * Currently iterates through all nodes in the range on creation until I think of a decent way to do it\n   * TODO: Look into making this a proper iterator, not requiring preloading everything first\n   * @constructor\n   */\n  function RangeNodeIterator(range, nodeTypes, filter) {\n    this.nodes = getNodesInRange(range, nodeTypes, filter);\n    this._next = this.nodes[0];\n    this._position = 0;\n  }\n\n  RangeNodeIterator.prototype = {\n    _current: null,\n\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n\n    next: function next() {\n      this._current = this._next;\n      this._next = this.nodes[++this._position];\n      return this._current;\n    },\n\n    detach: function detach() {\n      this._current = this._next = this.nodes = null;\n    }\n  };\n\n  var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];\n  var rootContainerNodeTypes = [2, 9, 11];\n  var readonlyNodeTypes = [5, 6, 10, 12];\n  var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];\n  var surroundNodeTypes = [1, 3, 4, 5, 7, 8];\n\n  function createAncestorFinder(nodeTypes) {\n    return function (node, selfIsAncestor) {\n      var t,\n          n = selfIsAncestor ? node : node.parentNode;\n      while (n) {\n        t = n.nodeType;\n        if (dom.arrayContains(nodeTypes, t)) {\n          return n;\n        }\n        n = n.parentNode;\n      }\n      return null;\n    };\n  }\n\n  var getRootContainer = dom.getRootContainer;\n  var getDocumentOrFragmentContainer = createAncestorFinder([9, 11]);\n  var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);\n  var getDocTypeNotationEntityAncestor = createAncestorFinder([6, 10, 12]);\n\n  function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {\n    if (getDocTypeNotationEntityAncestor(node, allowSelf)) {\n      throw new RangeException(\"INVALID_NODE_TYPE_ERR\");\n    }\n  }\n\n  function assertNotDetached(range) {\n    if (!range.startContainer) {\n      throw new DOMException(\"INVALID_STATE_ERR\");\n    }\n  }\n\n  function assertValidNodeType(node, invalidTypes) {\n    if (!dom.arrayContains(invalidTypes, node.nodeType)) {\n      throw new RangeException(\"INVALID_NODE_TYPE_ERR\");\n    }\n  }\n\n  function assertValidOffset(node, offset) {\n    if (offset < 0 || offset > (dom.isCharacterDataNode(node) ? node.length : node.childNodes.length)) {\n      throw new DOMException(\"INDEX_SIZE_ERR\");\n    }\n  }\n\n  function assertSameDocumentOrFragment(node1, node2) {\n    if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {\n      throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n    }\n  }\n\n  function assertNodeNotReadOnly(node) {\n    if (getReadonlyAncestor(node, true)) {\n      throw new DOMException(\"NO_MODIFICATION_ALLOWED_ERR\");\n    }\n  }\n\n  function assertNode(node, codeName) {\n    if (!node) {\n      throw new DOMException(codeName);\n    }\n  }\n\n  function isOrphan(node) {\n    return !dom.arrayContains(rootContainerNodeTypes, node.nodeType) && !getDocumentOrFragmentContainer(node, true);\n  }\n\n  function isValidOffset(node, offset) {\n    return offset <= (dom.isCharacterDataNode(node) ? node.length : node.childNodes.length);\n  }\n\n  function assertRangeValid(range) {\n    assertNotDetached(range);\n    if (isOrphan(range.startContainer) || isOrphan(range.endContainer) || !isValidOffset(range.startContainer, range.startOffset) || !isValidOffset(range.endContainer, range.endOffset)) {\n      throw new Error(\"Range error: Range is no longer valid after DOM mutation (\" + range.inspect() + \")\");\n    }\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Test the browser's innerHTML support to decide how to implement createContextualFragment\n  var styleEl = document.createElement(\"style\");\n  var htmlParsingConforms = false;\n  try {\n    styleEl.innerHTML = \"<b>x</b>\";\n    htmlParsingConforms = styleEl.firstChild.nodeType == 3; // Opera incorrectly creates an element node\n  } catch (e) {\n    // IE 6 and 7 throw\n  }\n\n  api.features.htmlParsingConforms = htmlParsingConforms;\n\n  var createContextualFragment = htmlParsingConforms ?\n\n  // Implementation as per HTML parsing spec, trusting in the browser's implementation of innerHTML. See\n  // discussion and base code for this implementation at issue 67.\n  // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface\n  // Thanks to Aleks Williams.\n  function (fragmentStr) {\n    // \"Let node the context object's start's node.\"\n    var node = this.startContainer;\n    var doc = dom.getDocument(node);\n\n    // \"If the context object's start's node is null, raise an INVALID_STATE_ERR\n    // exception and abort these steps.\"\n    if (!node) {\n      throw new DOMException(\"INVALID_STATE_ERR\");\n    }\n\n    // \"Let element be as follows, depending on node's interface:\"\n    // Document, Document Fragment: null\n    var el = null;\n\n    // \"Element: node\"\n    if (node.nodeType == 1) {\n      el = node;\n\n      // \"Text, Comment: node's parentElement\"\n    } else if (dom.isCharacterDataNode(node)) {\n      el = dom.parentElement(node);\n    }\n\n    // \"If either element is null or element's ownerDocument is an HTML document\n    // and element's local name is \"html\" and element's namespace is the HTML\n    // namespace\"\n    if (el === null || el.nodeName == \"HTML\" && dom.isHtmlNamespace(dom.getDocument(el).documentElement) && dom.isHtmlNamespace(el)) {\n\n      // \"let element be a new Element with \"body\" as its local name and the HTML\n      // namespace as its namespace.\"\"\n      el = doc.createElement(\"body\");\n    } else {\n      el = el.cloneNode(false);\n    }\n\n    // \"If the node's document is an HTML document: Invoke the HTML fragment parsing algorithm.\"\n    // \"If the node's document is an XML document: Invoke the XML fragment parsing algorithm.\"\n    // \"In either case, the algorithm must be invoked with fragment as the input\n    // and element as the context element.\"\n    el.innerHTML = fragmentStr;\n\n    // \"If this raises an exception, then abort these steps. Otherwise, let new\n    // children be the nodes returned.\"\n\n    // \"Let fragment be a new DocumentFragment.\"\n    // \"Append all new children to fragment.\"\n    // \"Return fragment.\"\n    return dom.fragmentFromNodeChildren(el);\n  } :\n\n  // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that\n  // previous versions of Rangy used (with the exception of using a body element rather than a div)\n  function (fragmentStr) {\n    assertNotDetached(this);\n    var doc = getRangeDocument(this);\n    var el = doc.createElement(\"body\");\n    el.innerHTML = fragmentStr;\n\n    return dom.fragmentFromNodeChildren(el);\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  var rangeProperties = [\"startContainer\", \"startOffset\", \"endContainer\", \"endOffset\", \"collapsed\", \"commonAncestorContainer\"];\n\n  var s2s = 0,\n      s2e = 1,\n      e2e = 2,\n      e2s = 3;\n  var n_b = 0,\n      n_a = 1,\n      n_b_a = 2,\n      n_i = 3;\n\n  function RangePrototype() {}\n\n  RangePrototype.prototype = {\n    attachListener: function attachListener(type, listener) {\n      this._listeners[type].push(listener);\n    },\n\n    compareBoundaryPoints: function compareBoundaryPoints(how, range) {\n      assertRangeValid(this);\n      assertSameDocumentOrFragment(this.startContainer, range.startContainer);\n\n      var nodeA, offsetA, nodeB, offsetB;\n      var prefixA = how == e2s || how == s2s ? \"start\" : \"end\";\n      var prefixB = how == s2e || how == s2s ? \"start\" : \"end\";\n      nodeA = this[prefixA + \"Container\"];\n      offsetA = this[prefixA + \"Offset\"];\n      nodeB = range[prefixB + \"Container\"];\n      offsetB = range[prefixB + \"Offset\"];\n      return dom.comparePoints(nodeA, offsetA, nodeB, offsetB);\n    },\n\n    insertNode: function insertNode(node) {\n      assertRangeValid(this);\n      assertValidNodeType(node, insertableNodeTypes);\n      assertNodeNotReadOnly(this.startContainer);\n\n      if (dom.isAncestorOf(node, this.startContainer, true)) {\n        throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n      }\n\n      // No check for whether the container of the start of the Range is of a type that does not allow\n      // children of the type of node: the browser's DOM implementation should do this for us when we attempt\n      // to add the node\n\n      var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);\n      this.setStartBefore(firstNodeInserted);\n    },\n\n    cloneContents: function cloneContents() {\n      assertRangeValid(this);\n\n      var clone, frag;\n      if (this.collapsed) {\n        return getRangeDocument(this).createDocumentFragment();\n      } else {\n        if (this.startContainer === this.endContainer && dom.isCharacterDataNode(this.startContainer)) {\n          clone = this.startContainer.cloneNode(true);\n          clone.data = clone.data.slice(this.startOffset, this.endOffset);\n          frag = getRangeDocument(this).createDocumentFragment();\n          frag.appendChild(clone);\n          return frag;\n        } else {\n          var iterator = new RangeIterator(this, true);\n          clone = cloneSubtree(iterator);\n          iterator.detach();\n        }\n        return clone;\n      }\n    },\n\n    canSurroundContents: function canSurroundContents() {\n      assertRangeValid(this);\n      assertNodeNotReadOnly(this.startContainer);\n      assertNodeNotReadOnly(this.endContainer);\n\n      // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n      // no non-text nodes.\n      var iterator = new RangeIterator(this, true);\n      var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);\n      iterator.detach();\n      return !boundariesInvalid;\n    },\n\n    surroundContents: function surroundContents(node) {\n      assertValidNodeType(node, surroundNodeTypes);\n\n      if (!this.canSurroundContents()) {\n        throw new RangeException(\"BAD_BOUNDARYPOINTS_ERR\");\n      }\n\n      // Extract the contents\n      var content = this.extractContents();\n\n      // Clear the children of the node\n      if (node.hasChildNodes()) {\n        while (node.lastChild) {\n          node.removeChild(node.lastChild);\n        }\n      }\n\n      // Insert the new node and add the extracted contents\n      insertNodeAtPosition(node, this.startContainer, this.startOffset);\n      node.appendChild(content);\n\n      this.selectNode(node);\n    },\n\n    cloneRange: function cloneRange() {\n      assertRangeValid(this);\n      var range = new Range(getRangeDocument(this));\n      var i = rangeProperties.length,\n          prop;\n      while (i--) {\n        prop = rangeProperties[i];\n        range[prop] = this[prop];\n      }\n      return range;\n    },\n\n    toString: function toString() {\n      assertRangeValid(this);\n      var sc = this.startContainer;\n      if (sc === this.endContainer && dom.isCharacterDataNode(sc)) {\n        return sc.nodeType == 3 || sc.nodeType == 4 ? sc.data.slice(this.startOffset, this.endOffset) : \"\";\n      } else {\n        var textBits = [],\n            iterator = new RangeIterator(this, true);\n\n        iterateSubtree(iterator, function (node) {\n          // Accept only text or CDATA nodes, not comments\n\n          if (node.nodeType == 3 || node.nodeType == 4) {\n            textBits.push(node.data);\n          }\n        });\n        iterator.detach();\n        return textBits.join(\"\");\n      }\n    },\n\n    // The methods below are all non-standard. The following batch were introduced by Mozilla but have since\n    // been removed from Mozilla.\n\n    compareNode: function compareNode(node) {\n      assertRangeValid(this);\n\n      var parent = node.parentNode;\n      var nodeIndex = dom.getNodeIndex(node);\n\n      if (!parent) {\n        throw new DOMException(\"NOT_FOUND_ERR\");\n      }\n\n      var startComparison = this.comparePoint(parent, nodeIndex),\n          endComparison = this.comparePoint(parent, nodeIndex + 1);\n\n      if (startComparison < 0) {\n        // Node starts before\n        return endComparison > 0 ? n_b_a : n_b;\n      } else {\n        return endComparison > 0 ? n_a : n_i;\n      }\n    },\n\n    comparePoint: function comparePoint(node, offset) {\n      assertRangeValid(this);\n      assertNode(node, \"HIERARCHY_REQUEST_ERR\");\n      assertSameDocumentOrFragment(node, this.startContainer);\n\n      if (dom.comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {\n        return -1;\n      } else if (dom.comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {\n        return 1;\n      }\n      return 0;\n    },\n\n    createContextualFragment: createContextualFragment,\n\n    toHtml: function toHtml() {\n      assertRangeValid(this);\n      var container = getRangeDocument(this).createElement(\"div\");\n      container.appendChild(this.cloneContents());\n      return container.innerHTML;\n    },\n\n    // touchingIsIntersecting determines whether this method considers a node that borders a range intersects\n    // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)\n    intersectsNode: function intersectsNode(node, touchingIsIntersecting) {\n      assertRangeValid(this);\n      assertNode(node, \"NOT_FOUND_ERR\");\n      if (dom.getDocument(node) !== getRangeDocument(this)) {\n        return false;\n      }\n\n      var parent = node.parentNode,\n          offset = dom.getNodeIndex(node);\n      assertNode(parent, \"NOT_FOUND_ERR\");\n\n      var startComparison = dom.comparePoints(parent, offset, this.endContainer, this.endOffset),\n          endComparison = dom.comparePoints(parent, offset + 1, this.startContainer, this.startOffset);\n\n      return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n    },\n\n    isPointInRange: function isPointInRange(node, offset) {\n      assertRangeValid(this);\n      assertNode(node, \"HIERARCHY_REQUEST_ERR\");\n      assertSameDocumentOrFragment(node, this.startContainer);\n\n      return dom.comparePoints(node, offset, this.startContainer, this.startOffset) >= 0 && dom.comparePoints(node, offset, this.endContainer, this.endOffset) <= 0;\n    },\n\n    // The methods below are non-standard and invented by me.\n\n    // Sharing a boundary start-to-end or end-to-start does not count as intersection.\n    intersectsRange: function intersectsRange(range, touchingIsIntersecting) {\n      assertRangeValid(this);\n\n      if (getRangeDocument(range) != getRangeDocument(this)) {\n        throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n      }\n\n      var startComparison = dom.comparePoints(this.startContainer, this.startOffset, range.endContainer, range.endOffset),\n          endComparison = dom.comparePoints(this.endContainer, this.endOffset, range.startContainer, range.startOffset);\n\n      return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n    },\n\n    intersection: function intersection(range) {\n      if (this.intersectsRange(range)) {\n        var startComparison = dom.comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),\n            endComparison = dom.comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);\n\n        var intersectionRange = this.cloneRange();\n\n        if (startComparison == -1) {\n          intersectionRange.setStart(range.startContainer, range.startOffset);\n        }\n        if (endComparison == 1) {\n          intersectionRange.setEnd(range.endContainer, range.endOffset);\n        }\n        return intersectionRange;\n      }\n      return null;\n    },\n\n    union: function union(range) {\n      if (this.intersectsRange(range, true)) {\n        var unionRange = this.cloneRange();\n        if (dom.comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {\n          unionRange.setStart(range.startContainer, range.startOffset);\n        }\n        if (dom.comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {\n          unionRange.setEnd(range.endContainer, range.endOffset);\n        }\n        return unionRange;\n      } else {\n        throw new RangeException(\"Ranges do not intersect\");\n      }\n    },\n\n    containsNode: function containsNode(node, allowPartial) {\n      if (allowPartial) {\n        return this.intersectsNode(node, false);\n      } else {\n        return this.compareNode(node) == n_i;\n      }\n    },\n\n    containsNodeContents: function containsNodeContents(node) {\n      return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, dom.getNodeLength(node)) <= 0;\n    },\n\n    containsRange: function containsRange(range) {\n      return this.intersection(range).equals(range);\n    },\n\n    containsNodeText: function containsNodeText(node) {\n      var nodeRange = this.cloneRange();\n      nodeRange.selectNode(node);\n      var textNodes = nodeRange.getNodes([3]);\n      if (textNodes.length > 0) {\n        nodeRange.setStart(textNodes[0], 0);\n        var lastTextNode = textNodes.pop();\n        nodeRange.setEnd(lastTextNode, lastTextNode.length);\n        var contains = this.containsRange(nodeRange);\n        nodeRange.detach();\n        return contains;\n      } else {\n        return this.containsNodeContents(node);\n      }\n    },\n\n    createNodeIterator: function createNodeIterator(nodeTypes, filter) {\n      assertRangeValid(this);\n      return new RangeNodeIterator(this, nodeTypes, filter);\n    },\n\n    getNodes: function getNodes(nodeTypes, filter) {\n      assertRangeValid(this);\n      return getNodesInRange(this, nodeTypes, filter);\n    },\n\n    getDocument: function getDocument() {\n      return getRangeDocument(this);\n    },\n\n    collapseBefore: function collapseBefore(node) {\n      assertNotDetached(this);\n\n      this.setEndBefore(node);\n      this.collapse(false);\n    },\n\n    collapseAfter: function collapseAfter(node) {\n      assertNotDetached(this);\n\n      this.setStartAfter(node);\n      this.collapse(true);\n    },\n\n    getName: function getName() {\n      return \"DomRange\";\n    },\n\n    equals: function equals(range) {\n      return Range.rangesEqual(this, range);\n    },\n\n    inspect: function inspect() {\n      return _inspect(this);\n    }\n  };\n\n  function copyComparisonConstantsToObject(obj) {\n    obj.START_TO_START = s2s;\n    obj.START_TO_END = s2e;\n    obj.END_TO_END = e2e;\n    obj.END_TO_START = e2s;\n\n    obj.NODE_BEFORE = n_b;\n    obj.NODE_AFTER = n_a;\n    obj.NODE_BEFORE_AND_AFTER = n_b_a;\n    obj.NODE_INSIDE = n_i;\n  }\n\n  function copyComparisonConstants(constructor) {\n    copyComparisonConstantsToObject(constructor);\n    copyComparisonConstantsToObject(constructor.prototype);\n  }\n\n  function createRangeContentRemover(remover, boundaryUpdater) {\n    return function () {\n      assertRangeValid(this);\n\n      var sc = this.startContainer,\n          so = this.startOffset,\n          root = this.commonAncestorContainer;\n\n      var iterator = new RangeIterator(this, true);\n\n      // Work out where to position the range after content removal\n      var node, boundary;\n      if (sc !== root) {\n        node = dom.getClosestAncestorIn(sc, root, true);\n        boundary = getBoundaryAfterNode(node);\n        sc = boundary.node;\n        so = boundary.offset;\n      }\n\n      // Check none of the range is read-only\n      iterateSubtree(iterator, assertNodeNotReadOnly);\n\n      iterator.reset();\n\n      // Remove the content\n      var returnValue = remover(iterator);\n      iterator.detach();\n\n      // Move to the new position\n      boundaryUpdater(this, sc, so, sc, so);\n\n      return returnValue;\n    };\n  }\n\n  function createPrototypeRange(constructor, boundaryUpdater, detacher) {\n    function createBeforeAfterNodeSetter(isBefore, isStart) {\n      return function (node) {\n        assertNotDetached(this);\n        assertValidNodeType(node, beforeAfterNodeTypes);\n        assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);\n\n        var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);\n        (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);\n      };\n    }\n\n    function setRangeStart(range, node, offset) {\n      var ec = range.endContainer,\n          eo = range.endOffset;\n      if (node !== range.startContainer || offset !== range.startOffset) {\n        // Check the root containers of the range and the new boundary, and also check whether the new boundary\n        // is after the current end. In either case, collapse the range to the new position\n        if (getRootContainer(node) != getRootContainer(ec) || dom.comparePoints(node, offset, ec, eo) == 1) {\n          ec = node;\n          eo = offset;\n        }\n        boundaryUpdater(range, node, offset, ec, eo);\n      }\n    }\n\n    function setRangeEnd(range, node, offset) {\n      var sc = range.startContainer,\n          so = range.startOffset;\n      if (node !== range.endContainer || offset !== range.endOffset) {\n        // Check the root containers of the range and the new boundary, and also check whether the new boundary\n        // is after the current end. In either case, collapse the range to the new position\n        if (getRootContainer(node) != getRootContainer(sc) || dom.comparePoints(node, offset, sc, so) == -1) {\n          sc = node;\n          so = offset;\n        }\n        boundaryUpdater(range, sc, so, node, offset);\n      }\n    }\n\n    function setRangeStartAndEnd(range, node, offset) {\n      if (node !== range.startContainer || offset !== range.startOffset || node !== range.endContainer || offset !== range.endOffset) {\n        boundaryUpdater(range, node, offset, node, offset);\n      }\n    }\n\n    constructor.prototype = new RangePrototype();\n\n    api.util.extend(constructor.prototype, {\n      setStart: function setStart(node, offset) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n\n        setRangeStart(this, node, offset);\n      },\n\n      setEnd: function setEnd(node, offset) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n\n        setRangeEnd(this, node, offset);\n      },\n\n      setStartBefore: createBeforeAfterNodeSetter(true, true),\n      setStartAfter: createBeforeAfterNodeSetter(false, true),\n      setEndBefore: createBeforeAfterNodeSetter(true, false),\n      setEndAfter: createBeforeAfterNodeSetter(false, false),\n\n      collapse: function collapse(isStart) {\n        assertRangeValid(this);\n        if (isStart) {\n          boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);\n        } else {\n          boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);\n        }\n      },\n\n      selectNodeContents: function selectNodeContents(node) {\n        // This doesn't seem well specified: the spec talks only about selecting the node's contents, which\n        // could be taken to mean only its children. However, browsers implement this the same as selectNode for\n        // text nodes, so I shall do likewise\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n\n        boundaryUpdater(this, node, 0, node, dom.getNodeLength(node));\n      },\n\n      selectNode: function selectNode(node) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, false);\n        assertValidNodeType(node, beforeAfterNodeTypes);\n\n        var start = getBoundaryBeforeNode(node),\n            end = getBoundaryAfterNode(node);\n        boundaryUpdater(this, start.node, start.offset, end.node, end.offset);\n      },\n\n      extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),\n\n      deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),\n\n      canSurroundContents: function canSurroundContents() {\n        assertRangeValid(this);\n        assertNodeNotReadOnly(this.startContainer);\n        assertNodeNotReadOnly(this.endContainer);\n\n        // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n        // no non-text nodes.\n        var iterator = new RangeIterator(this, true);\n        var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);\n        iterator.detach();\n        return !boundariesInvalid;\n      },\n\n      detach: function detach() {\n        detacher(this);\n      },\n\n      splitBoundaries: function splitBoundaries() {\n        assertRangeValid(this);\n\n        var sc = this.startContainer,\n            so = this.startOffset,\n            ec = this.endContainer,\n            eo = this.endOffset;\n        var startEndSame = sc === ec;\n\n        if (dom.isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n          dom.splitDataNode(ec, eo);\n        }\n\n        if (dom.isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n\n          sc = dom.splitDataNode(sc, so);\n          if (startEndSame) {\n            eo -= so;\n            ec = sc;\n          } else if (ec == sc.parentNode && eo >= dom.getNodeIndex(sc)) {\n            eo++;\n          }\n          so = 0;\n        }\n        boundaryUpdater(this, sc, so, ec, eo);\n      },\n\n      normalizeBoundaries: function normalizeBoundaries() {\n        assertRangeValid(this);\n\n        var sc = this.startContainer,\n            so = this.startOffset,\n            ec = this.endContainer,\n            eo = this.endOffset;\n\n        var mergeForward = function mergeForward(node) {\n          var sibling = node.nextSibling;\n          if (sibling && sibling.nodeType == node.nodeType) {\n            ec = node;\n            eo = node.length;\n            node.appendData(sibling.data);\n            sibling.parentNode.removeChild(sibling);\n          }\n        };\n\n        var mergeBackward = function mergeBackward(node) {\n          var sibling = node.previousSibling;\n          if (sibling && sibling.nodeType == node.nodeType) {\n            sc = node;\n            var nodeLength = node.length;\n            so = sibling.length;\n            node.insertData(0, sibling.data);\n            sibling.parentNode.removeChild(sibling);\n            if (sc == ec) {\n              eo += so;\n              ec = sc;\n            } else if (ec == node.parentNode) {\n              var nodeIndex = dom.getNodeIndex(node);\n              if (eo == nodeIndex) {\n                ec = node;\n                eo = nodeLength;\n              } else if (eo > nodeIndex) {\n                eo--;\n              }\n            }\n          }\n        };\n\n        var normalizeStart = true;\n\n        if (dom.isCharacterDataNode(ec)) {\n          if (ec.length == eo) {\n            mergeForward(ec);\n          }\n        } else {\n          if (eo > 0) {\n            var endNode = ec.childNodes[eo - 1];\n            if (endNode && dom.isCharacterDataNode(endNode)) {\n              mergeForward(endNode);\n            }\n          }\n          normalizeStart = !this.collapsed;\n        }\n\n        if (normalizeStart) {\n          if (dom.isCharacterDataNode(sc)) {\n            if (so == 0) {\n              mergeBackward(sc);\n            }\n          } else {\n            if (so < sc.childNodes.length) {\n              var startNode = sc.childNodes[so];\n              if (startNode && dom.isCharacterDataNode(startNode)) {\n                mergeBackward(startNode);\n              }\n            }\n          }\n        } else {\n          sc = ec;\n          so = eo;\n        }\n\n        boundaryUpdater(this, sc, so, ec, eo);\n      },\n\n      collapseToPoint: function collapseToPoint(node, offset) {\n        assertNotDetached(this);\n\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n\n        setRangeStartAndEnd(this, node, offset);\n      }\n    });\n\n    copyComparisonConstants(constructor);\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Updates commonAncestorContainer and collapsed after boundary change\n  function updateCollapsedAndCommonAncestor(range) {\n    range.collapsed = range.startContainer === range.endContainer && range.startOffset === range.endOffset;\n    range.commonAncestorContainer = range.collapsed ? range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);\n  }\n\n  function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {\n    var startMoved = range.startContainer !== startContainer || range.startOffset !== startOffset;\n    var endMoved = range.endContainer !== endContainer || range.endOffset !== endOffset;\n\n    range.startContainer = startContainer;\n    range.startOffset = startOffset;\n    range.endContainer = endContainer;\n    range.endOffset = endOffset;\n\n    updateCollapsedAndCommonAncestor(range);\n    dispatchEvent(range, \"boundarychange\", { startMoved: startMoved, endMoved: endMoved });\n  }\n\n  function detach(range) {\n    assertNotDetached(range);\n    range.startContainer = range.startOffset = range.endContainer = range.endOffset = null;\n    range.collapsed = range.commonAncestorContainer = null;\n    dispatchEvent(range, \"detach\", null);\n    range._listeners = null;\n  }\n\n  /**\n   * @constructor\n   */\n  function Range(doc) {\n    this.startContainer = doc;\n    this.startOffset = 0;\n    this.endContainer = doc;\n    this.endOffset = 0;\n    this._listeners = {\n      boundarychange: [],\n      detach: []\n    };\n    updateCollapsedAndCommonAncestor(this);\n  }\n\n  createPrototypeRange(Range, updateBoundaries, detach);\n\n  api.rangePrototype = RangePrototype.prototype;\n\n  Range.rangeProperties = rangeProperties;\n  Range.RangeIterator = RangeIterator;\n  Range.copyComparisonConstants = copyComparisonConstants;\n  Range.createPrototypeRange = createPrototypeRange;\n  Range.inspect = _inspect;\n  Range.getRangeDocument = getRangeDocument;\n  Range.rangesEqual = function (r1, r2) {\n    return r1.startContainer === r2.startContainer && r1.startOffset === r2.startOffset && r1.endContainer === r2.endContainer && r1.endOffset === r2.endOffset;\n  };\n\n  api.DomRange = Range;\n  api.RangeException = RangeException;\n});rangy.createModule(\"WrappedRange\", function (api, module) {\n  api.requireModules([\"DomUtil\", \"DomRange\"]);\n\n  /**\n   * @constructor\n   */\n  var WrappedRange;\n  var dom = api.dom;\n  var DomPosition = dom.DomPosition;\n  var DomRange = api.DomRange;\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  /*\n  This is a workaround for a bug where IE returns the wrong container element from the TextRange's parentElement()\n  method. For example, in the following (where pipes denote the selection boundaries):\n   <ul id=\"ul\"><li id=\"a\">| a </li><li id=\"b\"> b |</li></ul>\n   var range = document.selection.createRange();\n  alert(range.parentElement().id); // Should alert \"ul\" but alerts \"b\"\n   This method returns the common ancestor node of the following:\n  - the parentElement() of the textRange\n  - the parentElement() of the textRange after calling collapse(true)\n  - the parentElement() of the textRange after calling collapse(false)\n   */\n  function getTextRangeContainerElement(textRange) {\n    var parentEl = textRange.parentElement();\n\n    var range = textRange.duplicate();\n    range.collapse(true);\n    var startEl = range.parentElement();\n    range = textRange.duplicate();\n    range.collapse(false);\n    var endEl = range.parentElement();\n    var startEndContainer = startEl == endEl ? startEl : dom.getCommonAncestor(startEl, endEl);\n\n    return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);\n  }\n\n  function textRangeIsCollapsed(textRange) {\n    return textRange.compareEndPoints(\"StartToEnd\", textRange) == 0;\n  }\n\n  // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started out as\n  // an improved version of code found in Tim Cameron Ryan's IERange (http://code.google.com/p/ierange/) but has\n  // grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange bugs, handling\n  // for inputs and images, plus optimizations.\n  function getTextRangeBoundaryPosition(textRange, wholeRangeContainerElement, isStart, isCollapsed) {\n    var workingRange = textRange.duplicate();\n\n    workingRange.collapse(isStart);\n    var containerElement = workingRange.parentElement();\n\n    // Sometimes collapsing a TextRange that's at the start of a text node can move it into the previous node, so\n    // check for that\n    // TODO: Find out when. Workaround for wholeRangeContainerElement may break this\n    if (!dom.isAncestorOf(wholeRangeContainerElement, containerElement, true)) {\n      containerElement = wholeRangeContainerElement;\n    }\n\n    // Deal with nodes that cannot \"contain rich HTML markup\". In practice, this means form inputs, images and\n    // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx\n    if (!containerElement.canHaveHTML) {\n      return new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));\n    }\n\n    var workingNode = dom.getDocument(containerElement).createElement(\"span\");\n    var comparison,\n        workingComparisonType = isStart ? \"StartToStart\" : \"StartToEnd\";\n    var previousNode, nextNode, boundaryPosition, boundaryNode;\n\n    // Move the working range through the container's children, starting at the end and working backwards, until the\n    // working range reaches or goes past the boundary we're interested in\n    do {\n      containerElement.insertBefore(workingNode, workingNode.previousSibling);\n      workingRange.moveToElementText(workingNode);\n    } while ((comparison = workingRange.compareEndPoints(workingComparisonType, textRange)) > 0 && workingNode.previousSibling);\n\n    // We've now reached or gone past the boundary of the text range we're interested in\n    // so have identified the node we want\n    boundaryNode = workingNode.nextSibling;\n\n    if (comparison == -1 && boundaryNode && dom.isCharacterDataNode(boundaryNode)) {\n      // This is a character data node (text, comment, cdata). The working range is collapsed at the start of the\n      // node containing the text range's boundary, so we move the end of the working range to the boundary point\n      // and measure the length of its text to get the boundary's offset within the node.\n      workingRange.setEndPoint(isStart ? \"EndToStart\" : \"EndToEnd\", textRange);\n\n      var offset;\n\n      if (/[\\r\\n]/.test(boundaryNode.data)) {\n        /*\n        For the particular case of a boundary within a text node containing line breaks (within a <pre> element,\n        for example), we need a slightly complicated approach to get the boundary's offset in IE. The facts:\n         - Each line break is represented as \\r in the text node's data/nodeValue properties\n        - Each line break is represented as \\r\\n in the TextRange's 'text' property\n        - The 'text' property of the TextRange does not contain trailing line breaks\n         To get round the problem presented by the final fact above, we can use the fact that TextRange's\n        moveStart() and moveEnd() methods return the actual number of characters moved, which is not necessarily\n        the same as the number of characters it was instructed to move. The simplest approach is to use this to\n        store the characters moved when moving both the start and end of the range to the start of the document\n        body and subtracting the start offset from the end offset (the \"move-negative-gazillion\" method).\n        However, this is extremely slow when the document is large and the range is near the end of it. Clearly\n        doing the mirror image (i.e. moving the range boundaries to the end of the document) has the same\n        problem.\n         Another approach that works is to use moveStart() to move the start boundary of the range up to the end\n        boundary one character at a time and incrementing a counter with the value returned by the moveStart()\n        call. However, the check for whether the start boundary has reached the end boundary is expensive, so\n        this method is slow (although unlike \"move-negative-gazillion\" is largely unaffected by the location of\n        the range within the document).\n         The method below is a hybrid of the two methods above. It uses the fact that a string containing the\n        TextRange's 'text' property with each \\r\\n converted to a single \\r character cannot be longer than the\n        text of the TextRange, so the start of the range is moved that length initially and then a character at\n        a time to make up for any trailing line breaks not contained in the 'text' property. This has good\n        performance in most situations compared to the previous two methods.\n        */\n        var tempRange = workingRange.duplicate();\n        var rangeLength = tempRange.text.replace(/\\r\\n/g, \"\\r\").length;\n\n        offset = tempRange.moveStart(\"character\", rangeLength);\n        while ((comparison = tempRange.compareEndPoints(\"StartToEnd\", tempRange)) == -1) {\n          offset++;\n          tempRange.moveStart(\"character\", 1);\n        }\n      } else {\n        offset = workingRange.text.length;\n      }\n      boundaryPosition = new DomPosition(boundaryNode, offset);\n    } else {\n\n      // If the boundary immediately follows a character data node and this is the end boundary, we should favour\n      // a position within that, and likewise for a start boundary preceding a character data node\n      previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;\n      nextNode = (isCollapsed || isStart) && workingNode.nextSibling;\n\n      if (nextNode && dom.isCharacterDataNode(nextNode)) {\n        boundaryPosition = new DomPosition(nextNode, 0);\n      } else if (previousNode && dom.isCharacterDataNode(previousNode)) {\n        boundaryPosition = new DomPosition(previousNode, previousNode.length);\n      } else {\n        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));\n      }\n    }\n\n    // Clean up\n    workingNode.parentNode.removeChild(workingNode);\n\n    return boundaryPosition;\n  }\n\n  // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that node.\n  // This function started out as an optimized version of code found in Tim Cameron Ryan's IERange\n  // (http://code.google.com/p/ierange/)\n  function createBoundaryTextRange(boundaryPosition, isStart) {\n    var boundaryNode,\n        boundaryParent,\n        boundaryOffset = boundaryPosition.offset;\n    var doc = dom.getDocument(boundaryPosition.node);\n    var workingNode,\n        childNodes,\n        workingRange = doc.body.createTextRange();\n    var nodeIsDataNode = dom.isCharacterDataNode(boundaryPosition.node);\n\n    if (nodeIsDataNode) {\n      boundaryNode = boundaryPosition.node;\n      boundaryParent = boundaryNode.parentNode;\n    } else {\n      childNodes = boundaryPosition.node.childNodes;\n      boundaryNode = boundaryOffset < childNodes.length ? childNodes[boundaryOffset] : null;\n      boundaryParent = boundaryPosition.node;\n    }\n\n    // Position the range immediately before the node containing the boundary\n    workingNode = doc.createElement(\"span\");\n\n    // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within the\n    // element rather than immediately before or after it, which is what we want\n    workingNode.innerHTML = \"&#feff;\";\n\n    // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report\n    // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12\n    if (boundaryNode) {\n      boundaryParent.insertBefore(workingNode, boundaryNode);\n    } else {\n      boundaryParent.appendChild(workingNode);\n    }\n\n    workingRange.moveToElementText(workingNode);\n    workingRange.collapse(!isStart);\n\n    // Clean up\n    boundaryParent.removeChild(workingNode);\n\n    // Move the working range to the text offset, if required\n    if (nodeIsDataNode) {\n      workingRange[isStart ? \"moveStart\" : \"moveEnd\"](\"character\", boundaryOffset);\n    }\n\n    return workingRange;\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  if (api.features.implementsDomRange && (!api.features.implementsTextRange || !api.config.preferTextRange)) {\n    // This is a wrapper around the browser's native DOM Range. It has two aims:\n    // - Provide workarounds for specific browser bugs\n    // - provide convenient extensions, which are inherited from Rangy's DomRange\n\n    (function () {\n      var rangeProto;\n      var rangeProperties = DomRange.rangeProperties;\n      var canSetRangeStartAfterEnd;\n\n      function updateRangeProperties(range) {\n        var i = rangeProperties.length,\n            prop;\n        while (i--) {\n          prop = rangeProperties[i];\n          range[prop] = range.nativeRange[prop];\n        }\n      }\n\n      function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {\n        var startMoved = range.startContainer !== startContainer || range.startOffset != startOffset;\n        var endMoved = range.endContainer !== endContainer || range.endOffset != endOffset;\n\n        // Always set both boundaries for the benefit of IE9 (see issue 35)\n        if (startMoved || endMoved) {\n          range.setEnd(endContainer, endOffset);\n          range.setStart(startContainer, startOffset);\n        }\n      }\n\n      function detach(range) {\n        range.nativeRange.detach();\n        range.detached = true;\n        var i = rangeProperties.length,\n            prop;\n        while (i--) {\n          prop = rangeProperties[i];\n          range[prop] = null;\n        }\n      }\n\n      var createBeforeAfterNodeSetter;\n\n      WrappedRange = function WrappedRange(range) {\n        if (!range) {\n          throw new Error(\"Range must be specified\");\n        }\n        this.nativeRange = range;\n        updateRangeProperties(this);\n      };\n\n      DomRange.createPrototypeRange(WrappedRange, updateNativeRange, detach);\n\n      rangeProto = WrappedRange.prototype;\n\n      rangeProto.selectNode = function (node) {\n        this.nativeRange.selectNode(node);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.deleteContents = function () {\n        this.nativeRange.deleteContents();\n        updateRangeProperties(this);\n      };\n\n      rangeProto.extractContents = function () {\n        var frag = this.nativeRange.extractContents();\n        updateRangeProperties(this);\n        return frag;\n      };\n\n      rangeProto.cloneContents = function () {\n        return this.nativeRange.cloneContents();\n      };\n\n      // TODO: Until I can find a way to programmatically trigger the Firefox bug (apparently long-standing, still\n      // present in 3.6.8) that throws \"Index or size is negative or greater than the allowed amount\" for\n      // insertNode in some circumstances, all browsers will have to use the Rangy's own implementation of\n      // insertNode, which works but is almost certainly slower than the native implementation.\n      /*\n                  rangeProto.insertNode = function(node) {\n                      this.nativeRange.insertNode(node);\n                      updateRangeProperties(this);\n                  };\n      */\n\n      rangeProto.surroundContents = function (node) {\n        this.nativeRange.surroundContents(node);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.collapse = function (isStart) {\n        this.nativeRange.collapse(isStart);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.cloneRange = function () {\n        return new WrappedRange(this.nativeRange.cloneRange());\n      };\n\n      rangeProto.refresh = function () {\n        updateRangeProperties(this);\n      };\n\n      rangeProto.toString = function () {\n        return this.nativeRange.toString();\n      };\n\n      // Create test range and node for feature detection\n\n      var testTextNode = document.createTextNode(\"test\");\n      dom.getBody(document).appendChild(testTextNode);\n      var range = document.createRange();\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and\n      // correct for it\n\n      range.setStart(testTextNode, 0);\n      range.setEnd(testTextNode, 0);\n\n      try {\n        range.setStart(testTextNode, 1);\n        canSetRangeStartAfterEnd = true;\n\n        rangeProto.setStart = function (node, offset) {\n          this.nativeRange.setStart(node, offset);\n          updateRangeProperties(this);\n        };\n\n        rangeProto.setEnd = function (node, offset) {\n          this.nativeRange.setEnd(node, offset);\n          updateRangeProperties(this);\n        };\n\n        createBeforeAfterNodeSetter = function createBeforeAfterNodeSetter(name) {\n          return function (node) {\n            this.nativeRange[name](node);\n            updateRangeProperties(this);\n          };\n        };\n      } catch (ex) {\n\n        canSetRangeStartAfterEnd = false;\n\n        rangeProto.setStart = function (node, offset) {\n          try {\n            this.nativeRange.setStart(node, offset);\n          } catch (ex) {\n            this.nativeRange.setEnd(node, offset);\n            this.nativeRange.setStart(node, offset);\n          }\n          updateRangeProperties(this);\n        };\n\n        rangeProto.setEnd = function (node, offset) {\n          try {\n            this.nativeRange.setEnd(node, offset);\n          } catch (ex) {\n            this.nativeRange.setStart(node, offset);\n            this.nativeRange.setEnd(node, offset);\n          }\n          updateRangeProperties(this);\n        };\n\n        createBeforeAfterNodeSetter = function createBeforeAfterNodeSetter(name, oppositeName) {\n          return function (node) {\n            try {\n              this.nativeRange[name](node);\n            } catch (ex) {\n              this.nativeRange[oppositeName](node);\n              this.nativeRange[name](node);\n            }\n            updateRangeProperties(this);\n          };\n        };\n      }\n\n      rangeProto.setStartBefore = createBeforeAfterNodeSetter(\"setStartBefore\", \"setEndBefore\");\n      rangeProto.setStartAfter = createBeforeAfterNodeSetter(\"setStartAfter\", \"setEndAfter\");\n      rangeProto.setEndBefore = createBeforeAfterNodeSetter(\"setEndBefore\", \"setStartBefore\");\n      rangeProto.setEndAfter = createBeforeAfterNodeSetter(\"setEndAfter\", \"setStartAfter\");\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for and correct Firefox 2 behaviour with selectNodeContents on text nodes: it collapses the range to\n      // the 0th character of the text node\n      range.selectNodeContents(testTextNode);\n      if (range.startContainer == testTextNode && range.endContainer == testTextNode && range.startOffset == 0 && range.endOffset == testTextNode.length) {\n        rangeProto.selectNodeContents = function (node) {\n          this.nativeRange.selectNodeContents(node);\n          updateRangeProperties(this);\n        };\n      } else {\n        rangeProto.selectNodeContents = function (node) {\n          this.setStart(node, 0);\n          this.setEnd(node, DomRange.getEndOffset(node));\n        };\n      }\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for WebKit bug that has the beahviour of compareBoundaryPoints round the wrong way for constants\n      // START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738\n\n      range.selectNodeContents(testTextNode);\n      range.setEnd(testTextNode, 3);\n\n      var range2 = document.createRange();\n      range2.selectNodeContents(testTextNode);\n      range2.setEnd(testTextNode, 4);\n      range2.setStart(testTextNode, 2);\n\n      if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 & range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {\n        // This is the wrong way round, so correct for it\n\n\n        rangeProto.compareBoundaryPoints = function (type, range) {\n          range = range.nativeRange || range;\n          if (type == range.START_TO_END) {\n            type = range.END_TO_START;\n          } else if (type == range.END_TO_START) {\n            type = range.START_TO_END;\n          }\n          return this.nativeRange.compareBoundaryPoints(type, range);\n        };\n      } else {\n        rangeProto.compareBoundaryPoints = function (type, range) {\n          return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);\n        };\n      }\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for existence of createContextualFragment and delegate to it if it exists\n      if (api.util.isHostMethod(range, \"createContextualFragment\")) {\n        rangeProto.createContextualFragment = function (fragmentStr) {\n          return this.nativeRange.createContextualFragment(fragmentStr);\n        };\n      }\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Clean up\n      dom.getBody(document).removeChild(testTextNode);\n      range.detach();\n      range2.detach();\n    })();\n\n    api.createNativeRange = function (doc) {\n      doc = doc || document;\n      return doc.createRange();\n    };\n  } else if (api.features.implementsTextRange) {\n    // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy's DomRange as a\n    // prototype\n\n    WrappedRange = function WrappedRange(textRange) {\n      this.textRange = textRange;\n      this.refresh();\n    };\n\n    WrappedRange.prototype = new DomRange(document);\n\n    WrappedRange.prototype.refresh = function () {\n      var start, end;\n\n      // TextRange's parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.\n      var rangeContainerElement = getTextRangeContainerElement(this.textRange);\n\n      if (textRangeIsCollapsed(this.textRange)) {\n        end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, true);\n      } else {\n\n        start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);\n        end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false);\n      }\n\n      this.setStart(start.node, start.offset);\n      this.setEnd(end.node, end.offset);\n    };\n\n    DomRange.copyComparisonConstants(WrappedRange);\n\n    // Add WrappedRange as the Range property of the global object to allow expression like Range.END_TO_END to work\n    var globalObj = function () {\n      return this;\n    }();\n    if (typeof globalObj.Range == \"undefined\") {\n      globalObj.Range = WrappedRange;\n    }\n\n    api.createNativeRange = function (doc) {\n      doc = doc || document;\n      return doc.body.createTextRange();\n    };\n  }\n\n  if (api.features.implementsTextRange) {\n    WrappedRange.rangeToTextRange = function (range) {\n      if (range.collapsed) {\n        var tr = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n\n        return tr;\n\n        //return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n      } else {\n        var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n        var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);\n        var textRange = dom.getDocument(range.startContainer).body.createTextRange();\n        textRange.setEndPoint(\"StartToStart\", startRange);\n        textRange.setEndPoint(\"EndToEnd\", endRange);\n        return textRange;\n      }\n    };\n  }\n\n  WrappedRange.prototype.getName = function () {\n    return \"WrappedRange\";\n  };\n\n  api.WrappedRange = WrappedRange;\n\n  api.createRange = function (doc) {\n    doc = doc || document;\n    return new WrappedRange(api.createNativeRange(doc));\n  };\n\n  api.createRangyRange = function (doc) {\n    doc = doc || document;\n    return new DomRange(doc);\n  };\n\n  api.createIframeRange = function (iframeEl) {\n    return api.createRange(dom.getIframeDocument(iframeEl));\n  };\n\n  api.createIframeRangyRange = function (iframeEl) {\n    return api.createRangyRange(dom.getIframeDocument(iframeEl));\n  };\n\n  api.addCreateMissingNativeApiListener(function (win) {\n    var doc = win.document;\n    if (typeof doc.createRange == \"undefined\") {\n      doc.createRange = function () {\n        return api.createRange(this);\n      };\n    }\n    doc = win = null;\n  });\n});rangy.createModule(\"WrappedSelection\", function (api, module) {\n  // This will create a selection object wrapper that follows the Selection object found in the WHATWG draft DOM Range\n  // spec (http://html5.org/specs/dom-range.html)\n\n  api.requireModules([\"DomUtil\", \"DomRange\", \"WrappedRange\"]);\n\n  api.config.checkSelectionRanges = true;\n\n  var BOOLEAN = \"boolean\",\n      windowPropertyName = \"_rangySelection\",\n      dom = api.dom,\n      util = api.util,\n      DomRange = api.DomRange,\n      WrappedRange = api.WrappedRange,\n      DOMException = api.DOMException,\n      DomPosition = dom.DomPosition,\n      getSelection,\n      selectionIsCollapsed,\n      CONTROL = \"Control\";\n\n  function getWinSelection(winParam) {\n    return (winParam || window).getSelection();\n  }\n\n  function getDocSelection(winParam) {\n    return (winParam || window).document.selection;\n  }\n\n  // Test for the Range/TextRange and Selection features required\n  // Test for ability to retrieve selection\n  var implementsWinGetSelection = api.util.isHostMethod(window, \"getSelection\"),\n      implementsDocSelection = api.util.isHostObject(document, \"selection\");\n\n  var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);\n\n  if (useDocumentSelection) {\n    getSelection = getDocSelection;\n    api.isSelectionValid = function (winParam) {\n      var doc = (winParam || window).document,\n          nativeSel = doc.selection;\n\n      // Check whether the selection TextRange is actually contained within the correct document\n      return nativeSel.type != \"None\" || dom.getDocument(nativeSel.createRange().parentElement()) == doc;\n    };\n  } else if (implementsWinGetSelection) {\n    getSelection = getWinSelection;\n    api.isSelectionValid = function () {\n      return true;\n    };\n  } else {\n    module.fail(\"Neither document.selection or window.getSelection() detected.\");\n  }\n\n  api.getNativeSelection = getSelection;\n\n  var testSelection = getSelection();\n  var testRange = api.createNativeRange(document);\n  var body = dom.getBody(document);\n\n  // Obtaining a range from a selection\n  var selectionHasAnchorAndFocus = util.areHostObjects(testSelection, [\"anchorNode\", \"focusNode\"] && util.areHostProperties(testSelection, [\"anchorOffset\", \"focusOffset\"]));\n  api.features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;\n\n  // Test for existence of native selection extend() method\n  var selectionHasExtend = util.isHostMethod(testSelection, \"extend\");\n  api.features.selectionHasExtend = selectionHasExtend;\n\n  // Test if rangeCount exists\n  var selectionHasRangeCount = typeof testSelection.rangeCount == \"number\";\n  api.features.selectionHasRangeCount = selectionHasRangeCount;\n\n  var selectionSupportsMultipleRanges = false;\n  var collapsedNonEditableSelectionsSupported = true;\n\n  if (util.areHostMethods(testSelection, [\"addRange\", \"getRangeAt\", \"removeAllRanges\"]) && typeof testSelection.rangeCount == \"number\" && api.features.implementsDomRange) {\n\n    (function () {\n      var iframe = document.createElement(\"iframe\");\n      body.appendChild(iframe);\n\n      var iframeDoc = dom.getIframeDocument(iframe);\n      iframeDoc.open();\n      iframeDoc.write(\"<html><head></head><body>12</body></html>\");\n      iframeDoc.close();\n\n      var sel = dom.getIframeWindow(iframe).getSelection();\n      var docEl = iframeDoc.documentElement;\n      var iframeBody = docEl.lastChild,\n          textNode = iframeBody.firstChild;\n\n      // Test whether the native selection will allow a collapsed selection within a non-editable element\n      var r1 = iframeDoc.createRange();\n      r1.setStart(textNode, 1);\n      r1.collapse(true);\n      sel.addRange(r1);\n      collapsedNonEditableSelectionsSupported = sel.rangeCount == 1;\n      sel.removeAllRanges();\n\n      // Test whether the native selection is capable of supporting multiple ranges\n      var r2 = r1.cloneRange();\n      r1.setStart(textNode, 0);\n      r2.setEnd(textNode, 2);\n      sel.addRange(r1);\n      sel.addRange(r2);\n\n      selectionSupportsMultipleRanges = sel.rangeCount == 2;\n\n      // Clean up\n      r1.detach();\n      r2.detach();\n\n      body.removeChild(iframe);\n    })();\n  }\n\n  api.features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;\n  api.features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;\n\n  // ControlRanges\n  var implementsControlRange = false,\n      testControlRange;\n\n  if (body && util.isHostMethod(body, \"createControlRange\")) {\n    testControlRange = body.createControlRange();\n    if (util.areHostProperties(testControlRange, [\"item\", \"add\"])) {\n      implementsControlRange = true;\n    }\n  }\n  api.features.implementsControlRange = implementsControlRange;\n\n  // Selection collapsedness\n  if (selectionHasAnchorAndFocus) {\n    selectionIsCollapsed = function selectionIsCollapsed(sel) {\n      return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;\n    };\n  } else {\n    selectionIsCollapsed = function selectionIsCollapsed(sel) {\n      return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;\n    };\n  }\n\n  function updateAnchorAndFocusFromRange(sel, range, backwards) {\n    var anchorPrefix = backwards ? \"end\" : \"start\",\n        focusPrefix = backwards ? \"start\" : \"end\";\n    sel.anchorNode = range[anchorPrefix + \"Container\"];\n    sel.anchorOffset = range[anchorPrefix + \"Offset\"];\n    sel.focusNode = range[focusPrefix + \"Container\"];\n    sel.focusOffset = range[focusPrefix + \"Offset\"];\n  }\n\n  function updateAnchorAndFocusFromNativeSelection(sel) {\n    var nativeSel = sel.nativeSelection;\n    sel.anchorNode = nativeSel.anchorNode;\n    sel.anchorOffset = nativeSel.anchorOffset;\n    sel.focusNode = nativeSel.focusNode;\n    sel.focusOffset = nativeSel.focusOffset;\n  }\n\n  function updateEmptySelection(sel) {\n    sel.anchorNode = sel.focusNode = null;\n    sel.anchorOffset = sel.focusOffset = 0;\n    sel.rangeCount = 0;\n    sel.isCollapsed = true;\n    sel._ranges.length = 0;\n  }\n\n  function getNativeRange(range) {\n    var nativeRange;\n    if (range instanceof DomRange) {\n      nativeRange = range._selectionNativeRange;\n      if (!nativeRange) {\n        nativeRange = api.createNativeRange(dom.getDocument(range.startContainer));\n        nativeRange.setEnd(range.endContainer, range.endOffset);\n        nativeRange.setStart(range.startContainer, range.startOffset);\n        range._selectionNativeRange = nativeRange;\n        range.attachListener(\"detach\", function () {\n\n          this._selectionNativeRange = null;\n        });\n      }\n    } else if (range instanceof WrappedRange) {\n      nativeRange = range.nativeRange;\n    } else if (api.features.implementsDomRange && range instanceof dom.getWindow(range.startContainer).Range) {\n      nativeRange = range;\n    }\n    return nativeRange;\n  }\n\n  function rangeContainsSingleElement(rangeNodes) {\n    if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {\n      return false;\n    }\n    for (var i = 1, len = rangeNodes.length; i < len; ++i) {\n      if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function getSingleElementFromRange(range) {\n    var nodes = range.getNodes();\n    if (!rangeContainsSingleElement(nodes)) {\n      throw new Error(\"getSingleElementFromRange: range \" + range.inspect() + \" did not consist of a single element\");\n    }\n    return nodes[0];\n  }\n\n  function isTextRange(range) {\n    return !!range && typeof range.text != \"undefined\";\n  }\n\n  function updateFromTextRange(sel, range) {\n    // Create a Range from the selected TextRange\n    var wrappedRange = new WrappedRange(range);\n    sel._ranges = [wrappedRange];\n\n    updateAnchorAndFocusFromRange(sel, wrappedRange, false);\n    sel.rangeCount = 1;\n    sel.isCollapsed = wrappedRange.collapsed;\n  }\n\n  function updateControlSelection(sel) {\n    // Update the wrapped selection based on what's now in the native selection\n    sel._ranges.length = 0;\n    if (sel.docSelection.type == \"None\") {\n      updateEmptySelection(sel);\n    } else {\n      var controlRange = sel.docSelection.createRange();\n      if (isTextRange(controlRange)) {\n        // This case (where the selection type is \"Control\" and calling createRange() on the selection returns\n        // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected\n        // ControlRange have been removed from the ControlRange and removed from the document.\n        updateFromTextRange(sel, controlRange);\n      } else {\n        sel.rangeCount = controlRange.length;\n        var range,\n            doc = dom.getDocument(controlRange.item(0));\n        for (var i = 0; i < sel.rangeCount; ++i) {\n          range = api.createRange(doc);\n          range.selectNode(controlRange.item(i));\n          sel._ranges.push(range);\n        }\n        sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;\n        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);\n      }\n    }\n  }\n\n  function addRangeToControlSelection(sel, range) {\n    var controlRange = sel.docSelection.createRange();\n    var rangeElement = getSingleElementFromRange(range);\n\n    // Create a new ControlRange containing all the elements in the selected ControlRange plus the element\n    // contained by the supplied range\n    var doc = dom.getDocument(controlRange.item(0));\n    var newControlRange = dom.getBody(doc).createControlRange();\n    for (var i = 0, len = controlRange.length; i < len; ++i) {\n      newControlRange.add(controlRange.item(i));\n    }\n    try {\n      newControlRange.add(rangeElement);\n    } catch (ex) {\n      throw new Error(\"addRange(): Element within the specified Range could not be added to control selection (does it have layout?)\");\n    }\n    newControlRange.select();\n\n    // Update the wrapped selection based on what's now in the native selection\n    updateControlSelection(sel);\n  }\n\n  var getSelectionRangeAt;\n\n  if (util.isHostMethod(testSelection, \"getRangeAt\")) {\n    getSelectionRangeAt = function getSelectionRangeAt(sel, index) {\n      try {\n        return sel.getRangeAt(index);\n      } catch (ex) {\n        return null;\n      }\n    };\n  } else if (selectionHasAnchorAndFocus) {\n    getSelectionRangeAt = function getSelectionRangeAt(sel) {\n      var doc = dom.getDocument(sel.anchorNode);\n      var range = api.createRange(doc);\n      range.setStart(sel.anchorNode, sel.anchorOffset);\n      range.setEnd(sel.focusNode, sel.focusOffset);\n\n      // Handle the case when the selection was selected backwards (from the end to the start in the\n      // document)\n      if (range.collapsed !== this.isCollapsed) {\n        range.setStart(sel.focusNode, sel.focusOffset);\n        range.setEnd(sel.anchorNode, sel.anchorOffset);\n      }\n\n      return range;\n    };\n  }\n\n  /**\n   * @constructor\n   */\n  function WrappedSelection(selection, docSelection, win) {\n    this.nativeSelection = selection;\n    this.docSelection = docSelection;\n    this._ranges = [];\n    this.win = win;\n    this.refresh();\n  }\n\n  api.getSelection = function (win) {\n    win = win || window;\n    var sel = win[windowPropertyName];\n    var nativeSel = getSelection(win),\n        docSel = implementsDocSelection ? getDocSelection(win) : null;\n    if (sel) {\n      sel.nativeSelection = nativeSel;\n      sel.docSelection = docSel;\n      sel.refresh(win);\n    } else {\n      sel = new WrappedSelection(nativeSel, docSel, win);\n      win[windowPropertyName] = sel;\n    }\n    return sel;\n  };\n\n  api.getIframeSelection = function (iframeEl) {\n    return api.getSelection(dom.getIframeWindow(iframeEl));\n  };\n\n  var selProto = WrappedSelection.prototype;\n\n  function createControlSelection(sel, ranges) {\n    // Ensure that the selection becomes of type \"Control\"\n    var doc = dom.getDocument(ranges[0].startContainer);\n    var controlRange = dom.getBody(doc).createControlRange();\n    for (var i = 0, el; i < rangeCount; ++i) {\n      el = getSingleElementFromRange(ranges[i]);\n      try {\n        controlRange.add(el);\n      } catch (ex) {\n        throw new Error(\"setRanges(): Element within the one of the specified Ranges could not be added to control selection (does it have layout?)\");\n      }\n    }\n    controlRange.select();\n\n    // Update the wrapped selection based on what's now in the native selection\n    updateControlSelection(sel);\n  }\n\n  // Selecting a range\n  if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, [\"removeAllRanges\", \"addRange\"])) {\n    selProto.removeAllRanges = function () {\n      this.nativeSelection.removeAllRanges();\n      updateEmptySelection(this);\n    };\n\n    var addRangeBackwards = function addRangeBackwards(sel, range) {\n      var doc = DomRange.getRangeDocument(range);\n      var endRange = api.createRange(doc);\n      endRange.collapseToPoint(range.endContainer, range.endOffset);\n      sel.nativeSelection.addRange(getNativeRange(endRange));\n      sel.nativeSelection.extend(range.startContainer, range.startOffset);\n      sel.refresh();\n    };\n\n    if (selectionHasRangeCount) {\n      selProto.addRange = function (range, backwards) {\n        if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n          addRangeToControlSelection(this, range);\n        } else {\n          if (backwards && selectionHasExtend) {\n            addRangeBackwards(this, range);\n          } else {\n            var previousRangeCount;\n            if (selectionSupportsMultipleRanges) {\n              previousRangeCount = this.rangeCount;\n            } else {\n              this.removeAllRanges();\n              previousRangeCount = 0;\n            }\n            this.nativeSelection.addRange(getNativeRange(range));\n\n            // Check whether adding the range was successful\n            this.rangeCount = this.nativeSelection.rangeCount;\n\n            if (this.rangeCount == previousRangeCount + 1) {\n              // The range was added successfully\n\n              // Check whether the range that we added to the selection is reflected in the last range extracted from\n              // the selection\n              if (api.config.checkSelectionRanges) {\n                var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);\n                if (nativeRange && !DomRange.rangesEqual(nativeRange, range)) {\n                  // Happens in WebKit with, for example, a selection placed at the start of a text node\n                  range = new WrappedRange(nativeRange);\n                }\n              }\n              this._ranges[this.rangeCount - 1] = range;\n              updateAnchorAndFocusFromRange(this, range, selectionIsBackwards(this.nativeSelection));\n              this.isCollapsed = selectionIsCollapsed(this);\n            } else {\n              // The range was not added successfully. The simplest thing is to refresh\n              this.refresh();\n            }\n          }\n        }\n      };\n    } else {\n      selProto.addRange = function (range, backwards) {\n        if (backwards && selectionHasExtend) {\n          addRangeBackwards(this, range);\n        } else {\n          this.nativeSelection.addRange(getNativeRange(range));\n          this.refresh();\n        }\n      };\n    }\n\n    selProto.setRanges = function (ranges) {\n      if (implementsControlRange && ranges.length > 1) {\n        createControlSelection(this, ranges);\n      } else {\n        this.removeAllRanges();\n        for (var i = 0, len = ranges.length; i < len; ++i) {\n          this.addRange(ranges[i]);\n        }\n      }\n    };\n  } else if (util.isHostMethod(testSelection, \"empty\") && util.isHostMethod(testRange, \"select\") && implementsControlRange && useDocumentSelection) {\n\n    selProto.removeAllRanges = function () {\n      // Added try/catch as fix for issue #21\n      try {\n        this.docSelection.empty();\n\n        // Check for empty() not working (issue #24)\n        if (this.docSelection.type != \"None\") {\n          // Work around failure to empty a control selection by instead selecting a TextRange and then\n          // calling empty()\n          var doc;\n          if (this.anchorNode) {\n            doc = dom.getDocument(this.anchorNode);\n          } else if (this.docSelection.type == CONTROL) {\n            var controlRange = this.docSelection.createRange();\n            if (controlRange.length) {\n              doc = dom.getDocument(controlRange.item(0)).body.createTextRange();\n            }\n          }\n          if (doc) {\n            var textRange = doc.body.createTextRange();\n            textRange.select();\n            this.docSelection.empty();\n          }\n        }\n      } catch (ex) {}\n      updateEmptySelection(this);\n    };\n\n    selProto.addRange = function (range) {\n      if (this.docSelection.type == CONTROL) {\n        addRangeToControlSelection(this, range);\n      } else {\n        WrappedRange.rangeToTextRange(range).select();\n        this._ranges[0] = range;\n        this.rangeCount = 1;\n        this.isCollapsed = this._ranges[0].collapsed;\n        updateAnchorAndFocusFromRange(this, range, false);\n      }\n    };\n\n    selProto.setRanges = function (ranges) {\n      this.removeAllRanges();\n      var rangeCount = ranges.length;\n      if (rangeCount > 1) {\n        createControlSelection(this, ranges);\n      } else if (rangeCount) {\n        this.addRange(ranges[0]);\n      }\n    };\n  } else {\n    module.fail(\"No means of selecting a Range or TextRange was found\");\n    return false;\n  }\n\n  selProto.getRangeAt = function (index) {\n    if (index < 0 || index >= this.rangeCount) {\n      throw new DOMException(\"INDEX_SIZE_ERR\");\n    } else {\n      return this._ranges[index];\n    }\n  };\n\n  var refreshSelection;\n\n  if (useDocumentSelection) {\n    refreshSelection = function refreshSelection(sel) {\n      var range;\n      if (api.isSelectionValid(sel.win)) {\n        range = sel.docSelection.createRange();\n      } else {\n        range = dom.getBody(sel.win.document).createTextRange();\n        range.collapse(true);\n      }\n\n      if (sel.docSelection.type == CONTROL) {\n        updateControlSelection(sel);\n      } else if (isTextRange(range)) {\n        updateFromTextRange(sel, range);\n      } else {\n        updateEmptySelection(sel);\n      }\n    };\n  } else if (util.isHostMethod(testSelection, \"getRangeAt\") && typeof testSelection.rangeCount == \"number\") {\n    refreshSelection = function refreshSelection(sel) {\n      if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {\n        updateControlSelection(sel);\n      } else {\n        sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;\n        if (sel.rangeCount) {\n          for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));\n          }\n          updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackwards(sel.nativeSelection));\n          sel.isCollapsed = selectionIsCollapsed(sel);\n        } else {\n          updateEmptySelection(sel);\n        }\n      }\n    };\n  } else if (selectionHasAnchorAndFocus && _typeof(testSelection.isCollapsed) == BOOLEAN && _typeof(testRange.collapsed) == BOOLEAN && api.features.implementsDomRange) {\n    refreshSelection = function refreshSelection(sel) {\n      var range,\n          nativeSel = sel.nativeSelection;\n      if (nativeSel.anchorNode) {\n        range = getSelectionRangeAt(nativeSel, 0);\n        sel._ranges = [range];\n        sel.rangeCount = 1;\n        updateAnchorAndFocusFromNativeSelection(sel);\n        sel.isCollapsed = selectionIsCollapsed(sel);\n      } else {\n        updateEmptySelection(sel);\n      }\n    };\n  } else {\n    module.fail(\"No means of obtaining a Range or TextRange from the user's selection was found\");\n    return false;\n  }\n\n  selProto.refresh = function (checkForChanges) {\n    var oldRanges = checkForChanges ? this._ranges.slice(0) : null;\n    refreshSelection(this);\n    if (checkForChanges) {\n      var i = oldRanges.length;\n      if (i != this._ranges.length) {\n        return false;\n      }\n      while (i--) {\n        if (!DomRange.rangesEqual(oldRanges[i], this._ranges[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  };\n\n  // Removal of a single range\n  var removeRangeManually = function removeRangeManually(sel, range) {\n    var ranges = sel.getAllRanges(),\n        removed = false;\n    sel.removeAllRanges();\n    for (var i = 0, len = ranges.length; i < len; ++i) {\n      if (removed || range !== ranges[i]) {\n        sel.addRange(ranges[i]);\n      } else {\n        // According to the draft WHATWG Range spec, the same range may be added to the selection multiple\n        // times. removeRange should only remove the first instance, so the following ensures only the first\n        // instance is removed\n        removed = true;\n      }\n    }\n    if (!sel.rangeCount) {\n      updateEmptySelection(sel);\n    }\n  };\n\n  if (implementsControlRange) {\n    selProto.removeRange = function (range) {\n      if (this.docSelection.type == CONTROL) {\n        var controlRange = this.docSelection.createRange();\n        var rangeElement = getSingleElementFromRange(range);\n\n        // Create a new ControlRange containing all the elements in the selected ControlRange minus the\n        // element contained by the supplied range\n        var doc = dom.getDocument(controlRange.item(0));\n        var newControlRange = dom.getBody(doc).createControlRange();\n        var el,\n            removed = false;\n        for (var i = 0, len = controlRange.length; i < len; ++i) {\n          el = controlRange.item(i);\n          if (el !== rangeElement || removed) {\n            newControlRange.add(controlRange.item(i));\n          } else {\n            removed = true;\n          }\n        }\n        newControlRange.select();\n\n        // Update the wrapped selection based on what's now in the native selection\n        updateControlSelection(this);\n      } else {\n        removeRangeManually(this, range);\n      }\n    };\n  } else {\n    selProto.removeRange = function (range) {\n      removeRangeManually(this, range);\n    };\n  }\n\n  // Detecting if a selection is backwards\n  var selectionIsBackwards;\n  if (!useDocumentSelection && selectionHasAnchorAndFocus && api.features.implementsDomRange) {\n    selectionIsBackwards = function selectionIsBackwards(sel) {\n      var backwards = false;\n      if (sel.anchorNode) {\n        backwards = dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1;\n      }\n      return backwards;\n    };\n\n    selProto.isBackwards = function () {\n      return selectionIsBackwards(this);\n    };\n  } else {\n    selectionIsBackwards = selProto.isBackwards = function () {\n      return false;\n    };\n  }\n\n  // Selection text\n  // This is conformant to the new WHATWG DOM Range draft spec but differs from WebKit and Mozilla's implementation\n  selProto.toString = function () {\n\n    var rangeTexts = [];\n    for (var i = 0, len = this.rangeCount; i < len; ++i) {\n      rangeTexts[i] = \"\" + this._ranges[i];\n    }\n    return rangeTexts.join(\"\");\n  };\n\n  function assertNodeInSameDocument(sel, node) {\n    if (sel.anchorNode && dom.getDocument(sel.anchorNode) !== dom.getDocument(node)) {\n      throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n    }\n  }\n\n  // No current browsers conform fully to the HTML 5 draft spec for this method, so Rangy's own method is always used\n  selProto.collapse = function (node, offset) {\n    assertNodeInSameDocument(this, node);\n    var range = api.createRange(dom.getDocument(node));\n    range.collapseToPoint(node, offset);\n    this.removeAllRanges();\n    this.addRange(range);\n    this.isCollapsed = true;\n  };\n\n  selProto.collapseToStart = function () {\n    if (this.rangeCount) {\n      var range = this._ranges[0];\n      this.collapse(range.startContainer, range.startOffset);\n    } else {\n      throw new DOMException(\"INVALID_STATE_ERR\");\n    }\n  };\n\n  selProto.collapseToEnd = function () {\n    if (this.rangeCount) {\n      var range = this._ranges[this.rangeCount - 1];\n      this.collapse(range.endContainer, range.endOffset);\n    } else {\n      throw new DOMException(\"INVALID_STATE_ERR\");\n    }\n  };\n\n  // The HTML 5 spec is very specific on how selectAllChildren should be implemented so the native implementation is\n  // never used by Rangy.\n  selProto.selectAllChildren = function (node) {\n    assertNodeInSameDocument(this, node);\n    var range = api.createRange(dom.getDocument(node));\n    range.selectNodeContents(node);\n    this.removeAllRanges();\n    this.addRange(range);\n  };\n\n  selProto.deleteFromDocument = function () {\n    // Sepcial behaviour required for Control selections\n    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n      var controlRange = this.docSelection.createRange();\n      var element;\n      while (controlRange.length) {\n        element = controlRange.item(0);\n        controlRange.remove(element);\n        element.parentNode.removeChild(element);\n      }\n      this.refresh();\n    } else if (this.rangeCount) {\n      var ranges = this.getAllRanges();\n      this.removeAllRanges();\n      for (var i = 0, len = ranges.length; i < len; ++i) {\n        ranges[i].deleteContents();\n      }\n      // The HTML5 spec says nothing about what the selection should contain after calling deleteContents on each\n      // range. Firefox moves the selection to where the final selected range was, so we emulate that\n      this.addRange(ranges[len - 1]);\n    }\n  };\n\n  // The following are non-standard extensions\n  selProto.getAllRanges = function () {\n    return this._ranges.slice(0);\n  };\n\n  selProto.setSingleRange = function (range) {\n    this.setRanges([range]);\n  };\n\n  selProto.containsNode = function (node, allowPartial) {\n    for (var i = 0, len = this._ranges.length; i < len; ++i) {\n      if (this._ranges[i].containsNode(node, allowPartial)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  selProto.toHtml = function () {\n    var html = \"\";\n    if (this.rangeCount) {\n      var container = DomRange.getRangeDocument(this._ranges[0]).createElement(\"div\");\n      for (var i = 0, len = this._ranges.length; i < len; ++i) {\n        container.appendChild(this._ranges[i].cloneContents());\n      }\n      html = container.innerHTML;\n    }\n    return html;\n  };\n\n  function inspect(sel) {\n    var rangeInspects = [];\n    var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);\n    var focus = new DomPosition(sel.focusNode, sel.focusOffset);\n    var name = typeof sel.getName == \"function\" ? sel.getName() : \"Selection\";\n\n    if (typeof sel.rangeCount != \"undefined\") {\n      for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n        rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));\n      }\n    }\n    return \"[\" + name + \"(Ranges: \" + rangeInspects.join(\", \") + \")(anchor: \" + anchor.inspect() + \", focus: \" + focus.inspect() + \"]\";\n  }\n\n  selProto.getName = function () {\n    return \"WrappedSelection\";\n  };\n\n  selProto.inspect = function () {\n    return inspect(this);\n  };\n\n  selProto.detach = function () {\n    this.win[windowPropertyName] = null;\n    this.win = this.anchorNode = this.focusNode = null;\n  };\n\n  WrappedSelection.inspect = inspect;\n\n  api.Selection = WrappedSelection;\n\n  api.selectionPrototype = selProto;\n\n  api.addCreateMissingNativeApiListener(function (win) {\n    if (typeof win.getSelection == \"undefined\") {\n      win.getSelection = function () {\n        return api.getSelection(this);\n      };\n    }\n    win = null;\n  });\n});\n/*\n\tBase.js, version 1.1a\n\tCopyright 2006-2010, Dean Edwards\n\tLicense: http://www.opensource.org/licenses/mit-license.php\n*/\n\nvar Base = function Base() {\n  // dummy\n};\n\nBase.extend = function (_instance, _static) {\n  // subclass\n  var extend = Base.prototype.extend;\n\n  // build the prototype\n  Base._prototyping = true;\n  var proto = new this();\n  extend.call(proto, _instance);\n  proto.base = function () {\n    // call this method from any other method to invoke that method's ancestor\n  };\n  delete Base._prototyping;\n\n  // create the wrapper for the constructor function\n  //var constructor = proto.constructor.valueOf(); //-dean\n  var constructor = proto.constructor;\n  var klass = proto.constructor = function () {\n    if (!Base._prototyping) {\n      if (this._constructing || this.constructor == klass) {\n        // instantiation\n        this._constructing = true;\n        constructor.apply(this, arguments);\n        delete this._constructing;\n      } else if (arguments[0] != null) {\n        // casting\n        return (arguments[0].extend || extend).call(arguments[0], proto);\n      }\n    }\n  };\n\n  // build the class interface\n  klass.ancestor = this;\n  klass.extend = this.extend;\n  klass.forEach = this.forEach;\n  klass.implement = this.implement;\n  klass.prototype = proto;\n  klass.toString = this.toString;\n  klass.valueOf = function (type) {\n    //return (type == \"object\") ? klass : constructor; //-dean\n    return type == \"object\" ? klass : constructor.valueOf();\n  };\n  extend.call(klass, _static);\n  // class initialisation\n  if (typeof klass.init == \"function\") klass.init();\n  return klass;\n};\n\nBase.prototype = {\n  extend: function extend(source, value) {\n    if (arguments.length > 1) {\n      // extending with a name/value pair\n      var ancestor = this[source];\n      if (ancestor && typeof value == \"function\" && ( // overriding a method?\n      // the valueOf() comparison is to avoid circular references\n      !ancestor.valueOf || ancestor.valueOf() != value.valueOf()) && /\\bbase\\b/.test(value)) {\n        // get the underlying method\n        var method = value.valueOf();\n        // override\n        value = function value() {\n          var previous = this.base || Base.prototype.base;\n          this.base = ancestor;\n          var returnValue = method.apply(this, arguments);\n          this.base = previous;\n          return returnValue;\n        };\n        // point to the underlying method\n        value.valueOf = function (type) {\n          return type == \"object\" ? value : method;\n        };\n        value.toString = Base.toString;\n      }\n      this[source] = value;\n    } else if (source) {\n      // extending with an object literal\n      var extend = Base.prototype.extend;\n      // if this object has a customised extend method then use it\n      if (!Base._prototyping && typeof this != \"function\") {\n        extend = this.extend || extend;\n      }\n      var proto = { toSource: null };\n      // do the \"toString\" and other methods manually\n      var hidden = [\"constructor\", \"toString\", \"valueOf\"];\n      // if we are prototyping then include the constructor\n      var i = Base._prototyping ? 0 : 1;\n      while (key = hidden[i++]) {\n        if (source[key] != proto[key]) {\n          extend.call(this, key, source[key]);\n        }\n      }\n      // copy each of the source object's properties to this object\n      for (var key in source) {\n        if (!proto[key]) extend.call(this, key, source[key]);\n      }\n    }\n    return this;\n  }\n};\n\n// initialise\nBase = Base.extend({\n  constructor: function constructor() {\n    this.extend(arguments[0]);\n  }\n}, {\n  ancestor: Object,\n  version: \"1.1\",\n\n  forEach: function forEach(object, block, context) {\n    for (var key in object) {\n      if (this.prototype[key] === undefined) {\n        block.call(context, object[key], key, object);\n      }\n    }\n  },\n\n  implement: function implement() {\n    for (var i = 0; i < arguments.length; i++) {\n      if (typeof arguments[i] == \"function\") {\n        // if it's a function, call it\n        arguments[i](this.prototype);\n      } else {\n        // add the interface using the extend method\n        this.prototype.extend(arguments[i]);\n      }\n    }\n    return this;\n  },\n\n  toString: function toString() {\n    return String(this.valueOf());\n  }\n}); /**\n    * Detect browser support for specific features\n    */\nwysihtml5.browser = function () {\n  var userAgent = navigator.userAgent,\n      testElement = document.createElement(\"div\"),\n\n  // Browser sniffing is unfortunately needed since some behaviors are impossible to feature detect\n  isIE = userAgent.indexOf(\"MSIE\") !== -1 && userAgent.indexOf(\"Opera\") === -1,\n      isGecko = userAgent.indexOf(\"Gecko\") !== -1 && userAgent.indexOf(\"KHTML\") === -1,\n      isWebKit = userAgent.indexOf(\"AppleWebKit/\") !== -1,\n      isChrome = userAgent.indexOf(\"Chrome/\") !== -1,\n      isOpera = userAgent.indexOf(\"Opera/\") !== -1;\n\n  function iosVersion(userAgent) {\n    return (/ipad|iphone|ipod/.test(userAgent) && userAgent.match(/ os (\\d+).+? like mac os x/) || [, 0])[1];\n  }\n\n  return {\n    // Static variable needed, publicly accessible, to be able override it in unit tests\n    USER_AGENT: userAgent,\n\n    /**\n     * Exclude browsers that are not capable of displaying and handling\n     * contentEditable as desired:\n     *    - iPhone, iPad (tested iOS 4.2.2) and Android (tested 2.2) refuse to make contentEditables focusable\n     *    - IE < 8 create invalid markup and crash randomly from time to time\n     *\n     * @return {Boolean}\n     */\n    supported: function supported() {\n      var userAgent = this.USER_AGENT.toLowerCase(),\n\n      // Essential for making html elements editable\n      hasContentEditableSupport = \"contentEditable\" in testElement,\n\n      // Following methods are needed in order to interact with the contentEditable area\n      hasEditingApiSupport = document.execCommand && document.queryCommandSupported && document.queryCommandState,\n\n      // document selector apis are only supported by IE 8+, Safari 4+, Chrome and Firefox 3.5+\n      hasQuerySelectorSupport = document.querySelector && document.querySelectorAll,\n\n      // contentEditable is unusable in mobile browsers (tested iOS 4.2.2, Android 2.2, Opera Mobile, WebOS 3.05)\n      isIncompatibleMobileBrowser = this.isIos() && iosVersion(userAgent) < 5 || userAgent.indexOf(\"opera mobi\") !== -1 || userAgent.indexOf(\"hpwos/\") !== -1;\n\n      return hasContentEditableSupport && hasEditingApiSupport && hasQuerySelectorSupport && !isIncompatibleMobileBrowser;\n    },\n\n    isTouchDevice: function isTouchDevice() {\n      return this.supportsEvent(\"touchmove\");\n    },\n\n    isIos: function isIos() {\n      var userAgent = this.USER_AGENT.toLowerCase();\n      return userAgent.indexOf(\"webkit\") !== -1 && userAgent.indexOf(\"mobile\") !== -1;\n    },\n\n    /**\n     * Whether the browser supports sandboxed iframes\n     * Currently only IE 6+ offers such feature <iframe security=\"restricted\">\n     *\n     * http://msdn.microsoft.com/en-us/library/ms534622(v=vs.85).aspx\n     * http://blogs.msdn.com/b/ie/archive/2008/01/18/using-frames-more-securely.aspx\n     *\n     * HTML5 sandboxed iframes are still buggy and their DOM is not reachable from the outside (except when using postMessage)\n     */\n    supportsSandboxedIframes: function supportsSandboxedIframes() {\n      return isIE;\n    },\n\n    /**\n     * IE6+7 throw a mixed content warning when the src of an iframe\n     * is empty/unset or about:blank\n     * window.querySelector is implemented as of IE8\n     */\n    throwsMixedContentWarningWhenIframeSrcIsEmpty: function throwsMixedContentWarningWhenIframeSrcIsEmpty() {\n      return !(\"querySelector\" in document);\n    },\n\n    /**\n     * Whether the caret is correctly displayed in contentEditable elements\n     * Firefox sometimes shows a huge caret in the beginning after focusing\n     */\n    displaysCaretInEmptyContentEditableCorrectly: function displaysCaretInEmptyContentEditableCorrectly() {\n      return !isGecko;\n    },\n\n    /**\n     * Opera and IE are the only browsers who offer the css value\n     * in the original unit, thx to the currentStyle object\n     * All other browsers provide the computed style in px via window.getComputedStyle\n     */\n    hasCurrentStyleProperty: function hasCurrentStyleProperty() {\n      return \"currentStyle\" in testElement;\n    },\n\n    /**\n     * Whether the browser inserts a <br> when pressing enter in a contentEditable element\n     */\n    insertsLineBreaksOnReturn: function insertsLineBreaksOnReturn() {\n      return isGecko;\n    },\n\n    supportsPlaceholderAttributeOn: function supportsPlaceholderAttributeOn(element) {\n      return \"placeholder\" in element;\n    },\n\n    supportsEvent: function supportsEvent(eventName) {\n      return \"on\" + eventName in testElement || function () {\n        testElement.setAttribute(\"on\" + eventName, \"return;\");\n        return typeof testElement[\"on\" + eventName] === \"function\";\n      }();\n    },\n\n    /**\n     * Opera doesn't correctly fire focus/blur events when clicking in- and outside of iframe\n     */\n    supportsEventsInIframeCorrectly: function supportsEventsInIframeCorrectly() {\n      return !isOpera;\n    },\n\n    /**\n     * Chrome & Safari only fire the ondrop/ondragend/... events when the ondragover event is cancelled\n     * with event.preventDefault\n     * Firefox 3.6 fires those events anyway, but the mozilla doc says that the dragover/dragenter event needs\n     * to be cancelled\n     */\n    firesOnDropOnlyWhenOnDragOverIsCancelled: function firesOnDropOnlyWhenOnDragOverIsCancelled() {\n      return isWebKit || isGecko;\n    },\n\n    /**\n     * Whether the browser supports the event.dataTransfer property in a proper way\n     */\n    supportsDataTransfer: function supportsDataTransfer() {\n      try {\n        // Firefox doesn't support dataTransfer in a safe way, it doesn't strip script code in the html payload (like Chrome does)\n        return isWebKit && (window.Clipboard || window.DataTransfer).prototype.getData;\n      } catch (e) {\n        return false;\n      }\n    },\n\n    /**\n     * Everything below IE9 doesn't know how to treat HTML5 tags\n     *\n     * @param {Object} context The document object on which to check HTML5 support\n     *\n     * @example\n     *    wysihtml5.browser.supportsHTML5Tags(document);\n     */\n    supportsHTML5Tags: function supportsHTML5Tags(context) {\n      var element = context.createElement(\"div\"),\n          html5 = \"<article>foo</article>\";\n      element.innerHTML = html5;\n      return element.innerHTML.toLowerCase() === html5;\n    },\n\n    /**\n     * Checks whether a document supports a certain queryCommand\n     * In particular, Opera needs a reference to a document that has a contentEditable in it's dom tree\n     * in oder to report correct results\n     *\n     * @param {Object} doc Document object on which to check for a query command\n     * @param {String} command The query command to check for\n     * @return {Boolean}\n     *\n     * @example\n     *    wysihtml5.browser.supportsCommand(document, \"bold\");\n     */\n    supportsCommand: function () {\n      // Following commands are supported but contain bugs in some browsers\n      var buggyCommands = {\n        // formatBlock fails with some tags (eg. <blockquote>)\n        \"formatBlock\": isIE,\n        // When inserting unordered or ordered lists in Firefox, Chrome or Safari, the current selection or line gets\n        // converted into a list (<ul><li>...</li></ul>, <ol><li>...</li></ol>)\n        // IE and Opera act a bit different here as they convert the entire content of the current block element into a list\n        \"insertUnorderedList\": isIE || isOpera || isWebKit,\n        \"insertOrderedList\": isIE || isOpera || isWebKit\n      };\n\n      // Firefox throws errors for queryCommandSupported, so we have to build up our own object of supported commands\n      var supported = {\n        \"insertHTML\": isGecko\n      };\n\n      return function (doc, command) {\n        var isBuggy = buggyCommands[command];\n        if (!isBuggy) {\n          // Firefox throws errors when invoking queryCommandSupported or queryCommandEnabled\n          try {\n            return doc.queryCommandSupported(command);\n          } catch (e1) {}\n\n          try {\n            return doc.queryCommandEnabled(command);\n          } catch (e2) {\n            return !!supported[command];\n          }\n        }\n        return false;\n      };\n    }(),\n\n    /**\n     * IE: URLs starting with:\n     *    www., http://, https://, ftp://, gopher://, mailto:, new:, snews:, telnet:, wasis:, file://,\n     *    nntp://, newsrc:, ldap://, ldaps://, outlook:, mic:// and url:\n     * will automatically be auto-linked when either the user inserts them via copy&paste or presses the\n     * space bar when the caret is directly after such an url.\n     * This behavior cannot easily be avoided in IE < 9 since the logic is hardcoded in the mshtml.dll\n     * (related blog post on msdn\n     * http://blogs.msdn.com/b/ieinternals/archive/2009/09/17/prevent-automatic-hyperlinking-in-contenteditable-html.aspx).\n     */\n    doesAutoLinkingInContentEditable: function doesAutoLinkingInContentEditable() {\n      return isIE;\n    },\n\n    /**\n     * As stated above, IE auto links urls typed into contentEditable elements\n     * Since IE9 it's possible to prevent this behavior\n     */\n    canDisableAutoLinking: function canDisableAutoLinking() {\n      return this.supportsCommand(document, \"AutoUrlDetect\");\n    },\n\n    /**\n     * IE leaves an empty paragraph in the contentEditable element after clearing it\n     * Chrome/Safari sometimes an empty <div>\n     */\n    clearsContentEditableCorrectly: function clearsContentEditableCorrectly() {\n      return isGecko || isOpera || isWebKit;\n    },\n\n    /**\n     * IE gives wrong results for getAttribute\n     */\n    supportsGetAttributeCorrectly: function supportsGetAttributeCorrectly() {\n      var td = document.createElement(\"td\");\n      return td.getAttribute(\"rowspan\") != \"1\";\n    },\n\n    /**\n     * When clicking on images in IE, Opera and Firefox, they are selected, which makes it easy to interact with them.\n     * Chrome and Safari both don't support this\n     */\n    canSelectImagesInContentEditable: function canSelectImagesInContentEditable() {\n      return isGecko || isIE || isOpera;\n    },\n\n    /**\n     * When the caret is in an empty list (<ul><li>|</li></ul>) which is the first child in an contentEditable container\n     * pressing backspace doesn't remove the entire list as done in other browsers\n     */\n    clearsListsInContentEditableCorrectly: function clearsListsInContentEditableCorrectly() {\n      return isGecko || isIE || isWebKit;\n    },\n\n    /**\n     * All browsers except Safari and Chrome automatically scroll the range/caret position into view\n     */\n    autoScrollsToCaret: function autoScrollsToCaret() {\n      return !isWebKit;\n    },\n\n    /**\n     * Check whether the browser automatically closes tags that don't need to be opened\n     */\n    autoClosesUnclosedTags: function autoClosesUnclosedTags() {\n      var clonedTestElement = testElement.cloneNode(false),\n          returnValue,\n          innerHTML;\n\n      clonedTestElement.innerHTML = \"<p><div></div>\";\n      innerHTML = clonedTestElement.innerHTML.toLowerCase();\n      returnValue = innerHTML === \"<p></p><div></div>\" || innerHTML === \"<p><div></div></p>\";\n\n      // Cache result by overwriting current function\n      this.autoClosesUnclosedTags = function () {\n        return returnValue;\n      };\n\n      return returnValue;\n    },\n\n    /**\n     * Whether the browser supports the native document.getElementsByClassName which returns live NodeLists\n     */\n    supportsNativeGetElementsByClassName: function supportsNativeGetElementsByClassName() {\n      return String(document.getElementsByClassName).indexOf(\"[native code]\") !== -1;\n    },\n\n    /**\n     * As of now (19.04.2011) only supported by Firefox 4 and Chrome\n     * See https://developer.mozilla.org/en/DOM/Selection/modify\n     */\n    supportsSelectionModify: function supportsSelectionModify() {\n      return \"getSelection\" in window && \"modify\" in window.getSelection();\n    },\n\n    /**\n     * Whether the browser supports the classList object for fast className manipulation\n     * See https://developer.mozilla.org/en/DOM/element.classList\n     */\n    supportsClassList: function supportsClassList() {\n      return \"classList\" in testElement;\n    },\n\n    /**\n     * Opera needs a white space after a <br> in order to position the caret correctly\n     */\n    needsSpaceAfterLineBreak: function needsSpaceAfterLineBreak() {\n      return isOpera;\n    },\n\n    /**\n     * Whether the browser supports the speech api on the given element\n     * See http://mikepultz.com/2011/03/accessing-google-speech-api-chrome-11/\n     *\n     * @example\n     *    var input = document.createElement(\"input\");\n     *    if (wysihtml5.browser.supportsSpeechApiOn(input)) {\n     *      // ...\n     *    }\n     */\n    supportsSpeechApiOn: function supportsSpeechApiOn(input) {\n      var chromeVersion = userAgent.match(/Chrome\\/(\\d+)/) || [, 0];\n      return chromeVersion[1] >= 11 && (\"onwebkitspeechchange\" in input || \"speech\" in input);\n    },\n\n    /**\n     * IE9 crashes when setting a getter via Object.defineProperty on XMLHttpRequest or XDomainRequest\n     * See https://connect.microsoft.com/ie/feedback/details/650112\n     * or try the POC http://tifftiff.de/ie9_crash/\n     */\n    crashesWhenDefineProperty: function crashesWhenDefineProperty(property) {\n      return isIE && (property === \"XMLHttpRequest\" || property === \"XDomainRequest\");\n    },\n\n    /**\n     * IE is the only browser who fires the \"focus\" event not immediately when .focus() is called on an element\n     */\n    doesAsyncFocus: function doesAsyncFocus() {\n      return isIE;\n    },\n\n    /**\n     * In IE it's impssible for the user and for the selection library to set the caret after an <img> when it's the lastChild in the document\n     */\n    hasProblemsSettingCaretAfterImg: function hasProblemsSettingCaretAfterImg() {\n      return isIE;\n    },\n\n    hasUndoInContextMenu: function hasUndoInContextMenu() {\n      return isGecko || isChrome || isOpera;\n    }\n  };\n}();wysihtml5.lang.array = function (arr) {\n  return {\n    /**\n     * Check whether a given object exists in an array\n     *\n     * @example\n     *    wysihtml5.lang.array([1, 2]).contains(1);\n     *    // => true\n     */\n    contains: function contains(needle) {\n      if (arr.indexOf) {\n        return arr.indexOf(needle) !== -1;\n      } else {\n        for (var i = 0, length = arr.length; i < length; i++) {\n          if (arr[i] === needle) {\n            return true;\n          }\n        }\n        return false;\n      }\n    },\n\n    /**\n     * Substract one array from another\n     *\n     * @example\n     *    wysihtml5.lang.array([1, 2, 3, 4]).without([3, 4]);\n     *    // => [1, 2]\n     */\n    without: function without(arrayToSubstract) {\n      arrayToSubstract = wysihtml5.lang.array(arrayToSubstract);\n      var newArr = [],\n          i = 0,\n          length = arr.length;\n      for (; i < length; i++) {\n        if (!arrayToSubstract.contains(arr[i])) {\n          newArr.push(arr[i]);\n        }\n      }\n      return newArr;\n    },\n\n    /**\n     * Return a clean native array\n     * \n     * Following will convert a Live NodeList to a proper Array\n     * @example\n     *    var childNodes = wysihtml5.lang.array(document.body.childNodes).get();\n     */\n    get: function get() {\n      var i = 0,\n          length = arr.length,\n          newArray = [];\n      for (; i < length; i++) {\n        newArray.push(arr[i]);\n      }\n      return newArray;\n    }\n  };\n};wysihtml5.lang.Dispatcher = Base.extend(\n/** @scope wysihtml5.lang.Dialog.prototype */{\n  observe: function observe(eventName, handler) {\n    this.events = this.events || {};\n    this.events[eventName] = this.events[eventName] || [];\n    this.events[eventName].push(handler);\n    return this;\n  },\n\n  on: function on() {\n    return this.observe.apply(this, wysihtml5.lang.array(arguments).get());\n  },\n\n  fire: function fire(eventName, payload) {\n    this.events = this.events || {};\n    var handlers = this.events[eventName] || [],\n        i = 0;\n    for (; i < handlers.length; i++) {\n      handlers[i].call(this, payload);\n    }\n    return this;\n  },\n\n  stopObserving: function stopObserving(eventName, handler) {\n    this.events = this.events || {};\n    var i = 0,\n        handlers,\n        newHandlers;\n    if (eventName) {\n      handlers = this.events[eventName] || [], newHandlers = [];\n      for (; i < handlers.length; i++) {\n        if (handlers[i] !== handler && handler) {\n          newHandlers.push(handlers[i]);\n        }\n      }\n      this.events[eventName] = newHandlers;\n    } else {\n      // Clean up all events\n      this.events = {};\n    }\n    return this;\n  }\n});wysihtml5.lang.object = function (obj) {\n  return {\n    /**\n     * @example\n     *    wysihtml5.lang.object({ foo: 1, bar: 1 }).merge({ bar: 2, baz: 3 }).get();\n     *    // => { foo: 1, bar: 2, baz: 3 }\n     */\n    merge: function merge(otherObj) {\n      for (var i in otherObj) {\n        obj[i] = otherObj[i];\n      }\n      return this;\n    },\n\n    get: function get() {\n      return obj;\n    },\n\n    /**\n     * @example\n     *    wysihtml5.lang.object({ foo: 1 }).clone();\n     *    // => { foo: 1 }\n     */\n    clone: function clone() {\n      var newObj = {},\n          i;\n      for (i in obj) {\n        newObj[i] = obj[i];\n      }\n      return newObj;\n    },\n\n    /**\n     * @example\n     *    wysihtml5.lang.object([]).isArray();\n     *    // => true\n     */\n    isArray: function isArray() {\n      return Object.prototype.toString.call(obj) === \"[object Array]\";\n    }\n  };\n};(function () {\n  var WHITE_SPACE_START = /^\\s+/,\n      WHITE_SPACE_END = /\\s+$/;\n  wysihtml5.lang.string = function (str) {\n    str = String(str);\n    return {\n      /**\n       * @example\n       *    wysihtml5.lang.string(\"   foo   \").trim();\n       *    // => \"foo\"\n       */\n      trim: function trim() {\n        return str.replace(WHITE_SPACE_START, \"\").replace(WHITE_SPACE_END, \"\");\n      },\n\n      /**\n       * @example\n       *    wysihtml5.lang.string(\"Hello #{name}\").interpolate({ name: \"Christopher\" });\n       *    // => \"Hello Christopher\"\n       */\n      interpolate: function interpolate(vars) {\n        for (var i in vars) {\n          str = this.replace(\"#{\" + i + \"}\").by(vars[i]);\n        }\n        return str;\n      },\n\n      /**\n       * @example\n       *    wysihtml5.lang.string(\"Hello Tom\").replace(\"Tom\").with(\"Hans\");\n       *    // => \"Hello Hans\"\n       */\n      replace: function replace(search) {\n        return {\n          by: function by(replace) {\n            return str.split(search).join(replace);\n          }\n        };\n      }\n    };\n  };\n})(); /**\n      * Find urls in descendant text nodes of an element and auto-links them\n      * Inspired by http://james.padolsey.com/javascript/find-and-replace-text-with-javascript/\n      *\n      * @param {Element} element Container element in which to search for urls\n      *\n      * @example\n      *    <div id=\"text-container\">Please click here: www.google.com</div>\n      *    <script>wysihtml5.dom.autoLink(document.getElementById(\"text-container\"));</script>\n      */\n(function (wysihtml5) {\n  var /**\n       * Don't auto-link urls that are contained in the following elements:\n       */\n  IGNORE_URLS_IN = wysihtml5.lang.array([\"CODE\", \"PRE\", \"A\", \"SCRIPT\", \"HEAD\", \"TITLE\", \"STYLE\"]),\n\n  /**\n   * revision 1:\n   *    /(\\S+\\.{1}[^\\s\\,\\.\\!]+)/g\n   *\n   * revision 2:\n   *    /(\\b(((https?|ftp):\\/\\/)|(www\\.))[-A-Z0-9+&@#\\/%?=~_|!:,.;\\[\\]]*[-A-Z0-9+&@#\\/%=~_|])/gim\n   *\n   * put this in the beginning if you don't wan't to match within a word\n   *    (^|[\\>\\(\\{\\[\\s\\>])\n   */\n  URL_REG_EXP = /((https?:\\/\\/|www\\.)[^\\s<]{3,})/gi,\n      TRAILING_CHAR_REG_EXP = /([^\\w\\/\\-](,?))$/i,\n      MAX_DISPLAY_LENGTH = 100,\n      BRACKETS = { \")\": \"(\", \"]\": \"[\", \"}\": \"{\" };\n\n  function autoLink(element) {\n    if (_hasParentThatShouldBeIgnored(element)) {\n      return element;\n    }\n\n    if (element === element.ownerDocument.documentElement) {\n      element = element.ownerDocument.body;\n    }\n\n    return _parseNode(element);\n  }\n\n  /**\n   * This is basically a rebuild of\n   * the rails auto_link_urls text helper\n   */\n  function _convertUrlsToLinks(str) {\n    return str.replace(URL_REG_EXP, function (match, url) {\n      var punctuation = (url.match(TRAILING_CHAR_REG_EXP) || [])[1] || \"\",\n          opening = BRACKETS[punctuation];\n      url = url.replace(TRAILING_CHAR_REG_EXP, \"\");\n\n      if (url.split(opening).length > url.split(punctuation).length) {\n        url = url + punctuation;\n        punctuation = \"\";\n      }\n      var realUrl = url,\n          displayUrl = url;\n      if (url.length > MAX_DISPLAY_LENGTH) {\n        displayUrl = displayUrl.substr(0, MAX_DISPLAY_LENGTH) + \"...\";\n      }\n      // Add http prefix if necessary\n      if (realUrl.substr(0, 4) === \"www.\") {\n        realUrl = \"http://\" + realUrl;\n      }\n\n      return '<a href=\"' + realUrl + '\">' + displayUrl + '</a>' + punctuation;\n    });\n  }\n\n  /**\n   * Creates or (if already cached) returns a temp element\n   * for the given document object\n   */\n  function _getTempElement(context) {\n    var tempElement = context._wysihtml5_tempElement;\n    if (!tempElement) {\n      tempElement = context._wysihtml5_tempElement = context.createElement(\"div\");\n    }\n    return tempElement;\n  }\n\n  /**\n   * Replaces the original text nodes with the newly auto-linked dom tree\n   */\n  function _wrapMatchesInNode(textNode) {\n    var parentNode = textNode.parentNode,\n        tempElement = _getTempElement(parentNode.ownerDocument);\n\n    // We need to insert an empty/temporary <span /> to fix IE quirks\n    // Elsewise IE would strip white space in the beginning\n    tempElement.innerHTML = \"<span></span>\" + _convertUrlsToLinks(textNode.data);\n    tempElement.removeChild(tempElement.firstChild);\n\n    while (tempElement.firstChild) {\n      // inserts tempElement.firstChild before textNode\n      parentNode.insertBefore(tempElement.firstChild, textNode);\n    }\n    parentNode.removeChild(textNode);\n  }\n\n  function _hasParentThatShouldBeIgnored(node) {\n    var nodeName;\n    while (node.parentNode) {\n      node = node.parentNode;\n      nodeName = node.nodeName;\n      if (IGNORE_URLS_IN.contains(nodeName)) {\n        return true;\n      } else if (nodeName === \"body\") {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  function _parseNode(element) {\n    if (IGNORE_URLS_IN.contains(element.nodeName)) {\n      return;\n    }\n\n    if (element.nodeType === wysihtml5.TEXT_NODE && element.data.match(URL_REG_EXP)) {\n      _wrapMatchesInNode(element);\n      return;\n    }\n\n    var childNodes = wysihtml5.lang.array(element.childNodes).get(),\n        childNodesLength = childNodes.length,\n        i = 0;\n\n    for (; i < childNodesLength; i++) {\n      _parseNode(childNodes[i]);\n    }\n\n    return element;\n  }\n\n  wysihtml5.dom.autoLink = autoLink;\n\n  // Reveal url reg exp to the outside\n  wysihtml5.dom.autoLink.URL_REG_EXP = URL_REG_EXP;\n})(wysihtml5);(function (wysihtml5) {\n  var supportsClassList = wysihtml5.browser.supportsClassList(),\n      api = wysihtml5.dom;\n\n  api.addClass = function (element, className) {\n    if (supportsClassList) {\n      return element.classList.add(className);\n    }\n    if (api.hasClass(element, className)) {\n      return;\n    }\n    element.className += \" \" + className;\n  };\n\n  api.removeClass = function (element, className) {\n    if (supportsClassList) {\n      return element.classList.remove(className);\n    }\n\n    element.className = element.className.replace(new RegExp(\"(^|\\\\s+)\" + className + \"(\\\\s+|$)\"), \" \");\n  };\n\n  api.hasClass = function (element, className) {\n    if (supportsClassList) {\n      return element.classList.contains(className);\n    }\n\n    var elementClassName = element.className;\n    return elementClassName.length > 0 && (elementClassName == className || new RegExp(\"(^|\\\\s)\" + className + \"(\\\\s|$)\").test(elementClassName));\n  };\n})(wysihtml5);\nwysihtml5.dom.contains = function () {\n  var documentElement = document.documentElement;\n  if (documentElement.contains) {\n    return function (container, element) {\n      if (element.nodeType !== wysihtml5.ELEMENT_NODE) {\n        element = element.parentNode;\n      }\n      return container !== element && container.contains(element);\n    };\n  } else if (documentElement.compareDocumentPosition) {\n    return function (container, element) {\n      // https://developer.mozilla.org/en/DOM/Node.compareDocumentPosition\n      return !!(container.compareDocumentPosition(element) & 16);\n    };\n  }\n}(); /**\n     * Converts an HTML fragment/element into a unordered/ordered list\n     *\n     * @param {Element} element The element which should be turned into a list\n     * @param {String} listType The list type in which to convert the tree (either \"ul\" or \"ol\")\n     * @return {Element} The created list\n     *\n     * @example\n     *    <!-- Assume the following dom: -->\n     *    <span id=\"pseudo-list\">\n     *      eminem<br>\n     *      dr. dre\n     *      <div>50 Cent</div>\n     *    </span>\n     *\n     *    <script>\n     *      wysihtml5.dom.convertToList(document.getElementById(\"pseudo-list\"), \"ul\");\n     *    </script>\n     *\n     *    <!-- Will result in: -->\n     *    <ul>\n     *      <li>eminem</li>\n     *      <li>dr. dre</li>\n     *      <li>50 Cent</li>\n     *    </ul>\n     */\nwysihtml5.dom.convertToList = function () {\n  function _createListItem(doc, list) {\n    var listItem = doc.createElement(\"li\");\n    list.appendChild(listItem);\n    return listItem;\n  }\n\n  function _createList(doc, type) {\n    return doc.createElement(type);\n  }\n\n  function convertToList(element, listType) {\n    if (element.nodeName === \"UL\" || element.nodeName === \"OL\" || element.nodeName === \"MENU\") {\n      // Already a list\n      return element;\n    }\n\n    var doc = element.ownerDocument,\n        list = _createList(doc, listType),\n        lineBreaks = element.querySelectorAll(\"br\"),\n        lineBreaksLength = lineBreaks.length,\n        childNodes,\n        childNodesLength,\n        childNode,\n        lineBreak,\n        parentNode,\n        isBlockElement,\n        isLineBreak,\n        currentListItem,\n        i;\n\n    // First find <br> at the end of inline elements and move them behind them\n    for (i = 0; i < lineBreaksLength; i++) {\n      lineBreak = lineBreaks[i];\n      while ((parentNode = lineBreak.parentNode) && parentNode !== element && parentNode.lastChild === lineBreak) {\n        if (wysihtml5.dom.getStyle(\"display\").from(parentNode) === \"block\") {\n          parentNode.removeChild(lineBreak);\n          break;\n        }\n        wysihtml5.dom.insert(lineBreak).after(lineBreak.parentNode);\n      }\n    }\n\n    childNodes = wysihtml5.lang.array(element.childNodes).get();\n    childNodesLength = childNodes.length;\n\n    for (i = 0; i < childNodesLength; i++) {\n      currentListItem = currentListItem || _createListItem(doc, list);\n      childNode = childNodes[i];\n      isBlockElement = wysihtml5.dom.getStyle(\"display\").from(childNode) === \"block\";\n      isLineBreak = childNode.nodeName === \"BR\";\n\n      if (isBlockElement) {\n        // Append blockElement to current <li> if empty, otherwise create a new one\n        currentListItem = currentListItem.firstChild ? _createListItem(doc, list) : currentListItem;\n        currentListItem.appendChild(childNode);\n        currentListItem = null;\n        continue;\n      }\n\n      if (isLineBreak) {\n        // Only create a new list item in the next iteration when the current one has already content\n        currentListItem = currentListItem.firstChild ? null : currentListItem;\n        continue;\n      }\n\n      currentListItem.appendChild(childNode);\n    }\n\n    element.parentNode.replaceChild(list, element);\n    return list;\n  }\n\n  return convertToList;\n}(); /**\n     * Copy a set of attributes from one element to another\n     *\n     * @param {Array} attributesToCopy List of attributes which should be copied\n     * @return {Object} Returns an object which offers the \"from\" method which can be invoked with the element where to\n     *    copy the attributes from., this again returns an object which provides a method named \"to\" which can be invoked \n     *    with the element where to copy the attributes to (see example)\n     *\n     * @example\n     *    var textarea    = document.querySelector(\"textarea\"),\n     *        div         = document.querySelector(\"div[contenteditable=true]\"),\n     *        anotherDiv  = document.querySelector(\"div.preview\");\n     *    wysihtml5.dom.copyAttributes([\"spellcheck\", \"value\", \"placeholder\"]).from(textarea).to(div).andTo(anotherDiv);\n     *\n     */\nwysihtml5.dom.copyAttributes = function (attributesToCopy) {\n  return {\n    from: function from(elementToCopyFrom) {\n      return {\n        to: function to(elementToCopyTo) {\n          var attribute,\n              i = 0,\n              length = attributesToCopy.length;\n          for (; i < length; i++) {\n            attribute = attributesToCopy[i];\n            if (typeof elementToCopyFrom[attribute] !== \"undefined\" && elementToCopyFrom[attribute] !== \"\") {\n              elementToCopyTo[attribute] = elementToCopyFrom[attribute];\n            }\n          }\n          return { andTo: arguments.callee };\n        }\n      };\n    }\n  };\n}; /**\n   * Copy a set of styles from one element to another\n   * Please note that this only works properly across browsers when the element from which to copy the styles\n   * is in the dom\n   *\n   * Interesting article on how to copy styles\n   *\n   * @param {Array} stylesToCopy List of styles which should be copied\n   * @return {Object} Returns an object which offers the \"from\" method which can be invoked with the element where to\n   *    copy the styles from., this again returns an object which provides a method named \"to\" which can be invoked \n   *    with the element where to copy the styles to (see example)\n   *\n   * @example\n   *    var textarea    = document.querySelector(\"textarea\"),\n   *        div         = document.querySelector(\"div[contenteditable=true]\"),\n   *        anotherDiv  = document.querySelector(\"div.preview\");\n   *    wysihtml5.dom.copyStyles([\"overflow-y\", \"width\", \"height\"]).from(textarea).to(div).andTo(anotherDiv);\n   *\n   */\n(function (dom) {\n\n  /**\n   * Mozilla, WebKit and Opera recalculate the computed width when box-sizing: boder-box; is set\n   * So if an element has \"width: 200px; -moz-box-sizing: border-box; border: 1px;\" then \n   * its computed css width will be 198px\n   */\n  var BOX_SIZING_PROPERTIES = [\"-webkit-box-sizing\", \"-moz-box-sizing\", \"-ms-box-sizing\", \"box-sizing\"];\n\n  var shouldIgnoreBoxSizingBorderBox = function shouldIgnoreBoxSizingBorderBox(element) {\n    if (hasBoxSizingBorderBox(element)) {\n      return parseInt(dom.getStyle(\"width\").from(element), 10) < element.offsetWidth;\n    }\n    return false;\n  };\n\n  var hasBoxSizingBorderBox = function hasBoxSizingBorderBox(element) {\n    var i = 0,\n        length = BOX_SIZING_PROPERTIES.length;\n    for (; i < length; i++) {\n      if (dom.getStyle(BOX_SIZING_PROPERTIES[i]).from(element) === \"border-box\") {\n        return BOX_SIZING_PROPERTIES[i];\n      }\n    }\n  };\n\n  dom.copyStyles = function (stylesToCopy) {\n    return {\n      from: function from(element) {\n        if (shouldIgnoreBoxSizingBorderBox(element)) {\n          stylesToCopy = wysihtml5.lang.array(stylesToCopy).without(BOX_SIZING_PROPERTIES);\n        }\n\n        var cssText = \"\",\n            length = stylesToCopy.length,\n            i = 0,\n            property;\n        for (; i < length; i++) {\n          property = stylesToCopy[i];\n          cssText += property + \":\" + dom.getStyle(property).from(element) + \";\";\n        }\n\n        return {\n          to: function to(element) {\n            dom.setStyles(cssText).on(element);\n            return { andTo: arguments.callee };\n          }\n        };\n      }\n    };\n  };\n})(wysihtml5.dom); /**\n                   * Event Delegation\n                   *\n                   * @example\n                   *    wysihtml5.dom.delegate(document.body, \"a\", \"click\", function() {\n                   *      // foo\n                   *    });\n                   */\n(function (wysihtml5) {\n\n  wysihtml5.dom.delegate = function (container, selector, eventName, handler) {\n    return wysihtml5.dom.observe(container, eventName, function (event) {\n      var target = event.target,\n          match = wysihtml5.lang.array(container.querySelectorAll(selector));\n\n      while (target && target !== container) {\n        if (match.contains(target)) {\n          handler.call(target, event);\n          break;\n        }\n        target = target.parentNode;\n      }\n    });\n  };\n})(wysihtml5); /**\n               * Returns the given html wrapped in a div element\n               *\n               * Fixing IE's inability to treat unknown elements (HTML5 section, article, ...) correctly\n               * when inserted via innerHTML\n               * \n               * @param {String} html The html which should be wrapped in a dom element\n               * @param {Obejct} [context] Document object of the context the html belongs to\n               *\n               * @example\n               *    wysihtml5.dom.getAsDom(\"<article>foo</article>\");\n               */\nwysihtml5.dom.getAsDom = function () {\n\n  var _innerHTMLShiv = function _innerHTMLShiv(html, context) {\n    var tempElement = context.createElement(\"div\");\n    tempElement.style.display = \"none\";\n    context.body.appendChild(tempElement);\n    // IE throws an exception when trying to insert <frameset></frameset> via innerHTML\n    try {\n      tempElement.innerHTML = html;\n    } catch (e) {}\n    context.body.removeChild(tempElement);\n    return tempElement;\n  };\n\n  /**\n   * Make sure IE supports HTML5 tags, which is accomplished by simply creating one instance of each element\n   */\n  var _ensureHTML5Compatibility = function _ensureHTML5Compatibility(context) {\n    if (context._wysihtml5_supportsHTML5Tags) {\n      return;\n    }\n    for (var i = 0, length = HTML5_ELEMENTS.length; i < length; i++) {\n      context.createElement(HTML5_ELEMENTS[i]);\n    }\n    context._wysihtml5_supportsHTML5Tags = true;\n  };\n\n  /**\n   * List of html5 tags\n   * taken from http://simon.html5.org/html5-elements\n   */\n  var HTML5_ELEMENTS = [\"abbr\", \"article\", \"aside\", \"audio\", \"bdi\", \"canvas\", \"command\", \"datalist\", \"details\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"keygen\", \"mark\", \"meter\", \"nav\", \"output\", \"progress\", \"rp\", \"rt\", \"ruby\", \"svg\", \"section\", \"source\", \"summary\", \"time\", \"track\", \"video\", \"wbr\"];\n\n  return function (html, context) {\n    context = context || document;\n    var tempElement;\n    if ((typeof html === \"undefined\" ? \"undefined\" : _typeof(html)) === \"object\" && html.nodeType) {\n      tempElement = context.createElement(\"div\");\n      tempElement.appendChild(html);\n    } else if (wysihtml5.browser.supportsHTML5Tags(context)) {\n      tempElement = context.createElement(\"div\");\n      tempElement.innerHTML = html;\n    } else {\n      _ensureHTML5Compatibility(context);\n      tempElement = _innerHTMLShiv(html, context);\n    }\n    return tempElement;\n  };\n}(); /**\n     * Walks the dom tree from the given node up until it finds a match\n     * Designed for optimal performance.\n     *\n     * @param {Element} node The from which to check the parent nodes\n     * @param {Object} matchingSet Object to match against (possible properties: nodeName, className, classRegExp)\n     * @param {Number} [levels] How many parents should the function check up from the current node (defaults to 50)\n     * @return {null|Element} Returns the first element that matched the desiredNodeName(s)\n     * @example\n     *    var listElement = wysihtml5.dom.getParentElement(document.querySelector(\"li\"), { nodeName: [\"MENU\", \"UL\", \"OL\"] });\n     *    // ... or ...\n     *    var unorderedListElement = wysihtml5.dom.getParentElement(document.querySelector(\"li\"), { nodeName: \"UL\" });\n     *    // ... or ...\n     *    var coloredElement = wysihtml5.dom.getParentElement(myTextNode, { nodeName: \"SPAN\", className: \"wysiwyg-color-red\", classRegExp: /wysiwyg-color-[a-z]/g });\n     */\nwysihtml5.dom.getParentElement = function () {\n\n  function _isSameNodeName(nodeName, desiredNodeNames) {\n    if (!desiredNodeNames || !desiredNodeNames.length) {\n      return true;\n    }\n\n    if (typeof desiredNodeNames === \"string\") {\n      return nodeName === desiredNodeNames;\n    } else {\n      return wysihtml5.lang.array(desiredNodeNames).contains(nodeName);\n    }\n  }\n\n  function _isElement(node) {\n    return node.nodeType === wysihtml5.ELEMENT_NODE;\n  }\n\n  function _hasClassName(element, className, classRegExp) {\n    var classNames = (element.className || \"\").match(classRegExp) || [];\n    if (!className) {\n      return !!classNames.length;\n    }\n    return classNames[classNames.length - 1] === className;\n  }\n\n  function _getParentElementWithNodeName(node, nodeName, levels) {\n    while (levels-- && node && node.nodeName !== \"BODY\") {\n      if (_isSameNodeName(node.nodeName, nodeName)) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n    return null;\n  }\n\n  function _getParentElementWithNodeNameAndClassName(node, nodeName, className, classRegExp, levels) {\n    while (levels-- && node && node.nodeName !== \"BODY\") {\n      if (_isElement(node) && _isSameNodeName(node.nodeName, nodeName) && _hasClassName(node, className, classRegExp)) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n    return null;\n  }\n\n  return function (node, matchingSet, levels) {\n    levels = levels || 50; // Go max 50 nodes upwards from current node\n    if (matchingSet.className || matchingSet.classRegExp) {\n      return _getParentElementWithNodeNameAndClassName(node, matchingSet.nodeName, matchingSet.className, matchingSet.classRegExp, levels);\n    } else {\n      return _getParentElementWithNodeName(node, matchingSet.nodeName, levels);\n    }\n  };\n}();\n/**\n * Get element's style for a specific css property\n *\n * @param {Element} element The element on which to retrieve the style\n * @param {String} property The CSS property to retrieve (\"float\", \"display\", \"text-align\", ...)\n *\n * @example\n *    wysihtml5.dom.getStyle(\"display\").from(document.body);\n *    // => \"block\"\n */\nwysihtml5.dom.getStyle = function () {\n  var stylePropertyMapping = {\n    \"float\": \"styleFloat\" in document.createElement(\"div\").style ? \"styleFloat\" : \"cssFloat\"\n  },\n      REG_EXP_CAMELIZE = /\\-[a-z]/g;\n\n  function camelize(str) {\n    return str.replace(REG_EXP_CAMELIZE, function (match) {\n      return match.charAt(1).toUpperCase();\n    });\n  }\n\n  return function (property) {\n    return {\n      from: function from(element) {\n        if (element.nodeType !== wysihtml5.ELEMENT_NODE) {\n          return;\n        }\n\n        var doc = element.ownerDocument,\n            camelizedProperty = stylePropertyMapping[property] || camelize(property),\n            style = element.style,\n            currentStyle = element.currentStyle,\n            styleValue = style[camelizedProperty];\n        if (styleValue) {\n          return styleValue;\n        }\n\n        // currentStyle is no standard and only supported by Opera and IE but it has one important advantage over the standard-compliant\n        // window.getComputedStyle, since it returns css property values in their original unit:\n        // If you set an elements width to \"50%\", window.getComputedStyle will give you it's current width in px while currentStyle\n        // gives you the original \"50%\".\n        // Opera supports both, currentStyle and window.getComputedStyle, that's why checking for currentStyle should have higher prio\n        if (currentStyle) {\n          try {\n            return currentStyle[camelizedProperty];\n          } catch (e) {\n            //ie will occasionally fail for unknown reasons. swallowing exception\n          }\n        }\n\n        var win = doc.defaultView || doc.parentWindow,\n            needsOverflowReset = (property === \"height\" || property === \"width\") && element.nodeName === \"TEXTAREA\",\n            originalOverflow,\n            returnValue;\n\n        if (win.getComputedStyle) {\n          // Chrome and Safari both calculate a wrong width and height for textareas when they have scroll bars\n          // therfore we remove and restore the scrollbar and calculate the value in between\n          if (needsOverflowReset) {\n            originalOverflow = style.overflow;\n            style.overflow = \"hidden\";\n          }\n          returnValue = win.getComputedStyle(element, null).getPropertyValue(property);\n          if (needsOverflowReset) {\n            style.overflow = originalOverflow || \"\";\n          }\n          return returnValue;\n        }\n      }\n    };\n  };\n}(); /**\n     * High performant way to check whether an element with a specific tag name is in the given document\n     * Optimized for being heavily executed\n     * Unleashes the power of live node lists\n     *\n     * @param {Object} doc The document object of the context where to check\n     * @param {String} tagName Upper cased tag name\n     * @example\n     *    wysihtml5.dom.hasElementWithTagName(document, \"IMG\");\n     */\nwysihtml5.dom.hasElementWithTagName = function () {\n  var LIVE_CACHE = {},\n      DOCUMENT_IDENTIFIER = 1;\n\n  function _getDocumentIdentifier(doc) {\n    return doc._wysihtml5_identifier || (doc._wysihtml5_identifier = DOCUMENT_IDENTIFIER++);\n  }\n\n  return function (doc, tagName) {\n    var key = _getDocumentIdentifier(doc) + \":\" + tagName,\n        cacheEntry = LIVE_CACHE[key];\n    if (!cacheEntry) {\n      cacheEntry = LIVE_CACHE[key] = doc.getElementsByTagName(tagName);\n    }\n\n    return cacheEntry.length > 0;\n  };\n}(); /**\n     * High performant way to check whether an element with a specific class name is in the given document\n     * Optimized for being heavily executed\n     * Unleashes the power of live node lists\n     *\n     * @param {Object} doc The document object of the context where to check\n     * @param {String} tagName Upper cased tag name\n     * @example\n     *    wysihtml5.dom.hasElementWithClassName(document, \"foobar\");\n     */\n(function (wysihtml5) {\n  var LIVE_CACHE = {},\n      DOCUMENT_IDENTIFIER = 1;\n\n  function _getDocumentIdentifier(doc) {\n    return doc._wysihtml5_identifier || (doc._wysihtml5_identifier = DOCUMENT_IDENTIFIER++);\n  }\n\n  wysihtml5.dom.hasElementWithClassName = function (doc, className) {\n    // getElementsByClassName is not supported by IE<9\n    // but is sometimes mocked via library code (which then doesn't return live node lists)\n    if (!wysihtml5.browser.supportsNativeGetElementsByClassName()) {\n      return !!doc.querySelector(\".\" + className);\n    }\n\n    var key = _getDocumentIdentifier(doc) + \":\" + className,\n        cacheEntry = LIVE_CACHE[key];\n    if (!cacheEntry) {\n      cacheEntry = LIVE_CACHE[key] = doc.getElementsByClassName(className);\n    }\n\n    return cacheEntry.length > 0;\n  };\n})(wysihtml5);\nwysihtml5.dom.insert = function (elementToInsert) {\n  return {\n    after: function after(element) {\n      element.parentNode.insertBefore(elementToInsert, element.nextSibling);\n    },\n\n    before: function before(element) {\n      element.parentNode.insertBefore(elementToInsert, element);\n    },\n\n    into: function into(element) {\n      element.appendChild(elementToInsert);\n    }\n  };\n};wysihtml5.dom.insertCSS = function (rules) {\n  rules = rules.join(\"\\n\");\n\n  return {\n    into: function into(doc) {\n      var head = doc.head || doc.getElementsByTagName(\"head\")[0],\n          styleElement = doc.createElement(\"style\");\n\n      styleElement.type = \"text/css\";\n\n      if (styleElement.styleSheet) {\n        styleElement.styleSheet.cssText = rules;\n      } else {\n        styleElement.appendChild(doc.createTextNode(rules));\n      }\n\n      if (head) {\n        head.appendChild(styleElement);\n      }\n    }\n  };\n}; /**\n   * Method to set dom events\n   *\n   * @example\n   *    wysihtml5.dom.observe(iframe.contentWindow.document.body, [\"focus\", \"blur\"], function() { ... });\n   */\nwysihtml5.dom.observe = function (element, eventNames, handler) {\n  eventNames = typeof eventNames === \"string\" ? [eventNames] : eventNames;\n\n  var handlerWrapper,\n      eventName,\n      i = 0,\n      length = eventNames.length;\n\n  for (; i < length; i++) {\n    eventName = eventNames[i];\n    if (element.addEventListener) {\n      element.addEventListener(eventName, handler, false);\n    } else {\n      handlerWrapper = function handlerWrapper(event) {\n        if (!(\"target\" in event)) {\n          event.target = event.srcElement;\n        }\n        event.preventDefault = event.preventDefault || function () {\n          this.returnValue = false;\n        };\n        event.stopPropagation = event.stopPropagation || function () {\n          this.cancelBubble = true;\n        };\n        handler.call(element, event);\n      };\n      element.attachEvent(\"on\" + eventName, handlerWrapper);\n    }\n  }\n\n  return {\n    stop: function stop() {\n      var eventName,\n          i = 0,\n          length = eventNames.length;\n      for (; i < length; i++) {\n        eventName = eventNames[i];\n        if (element.removeEventListener) {\n          element.removeEventListener(eventName, handler, false);\n        } else {\n          element.detachEvent(\"on\" + eventName, handlerWrapper);\n        }\n      }\n    }\n  };\n};\n/**\n * HTML Sanitizer\n * Rewrites the HTML based on given rules\n *\n * @param {Element|String} elementOrHtml HTML String to be sanitized OR element whose content should be sanitized\n * @param {Object} [rules] List of rules for rewriting the HTML, if there's no rule for an element it will\n *    be converted to a \"span\". Each rule is a key/value pair where key is the tag to convert, and value the\n *    desired substitution.\n * @param {Object} context Document object in which to parse the html, needed to sandbox the parsing\n *\n * @return {Element|String} Depends on the elementOrHtml parameter. When html then the sanitized html as string elsewise the element.\n *\n * @example\n *    var userHTML = '<div id=\"foo\" onclick=\"alert(1);\"><p><font color=\"red\">foo</font><script>alert(1);</script></p></div>';\n *    wysihtml5.dom.parse(userHTML, {\n *      tags {\n *        p:      \"div\",      // Rename p tags to div tags\n *        font:   \"span\"      // Rename font tags to span tags\n *        div:    true,       // Keep them, also possible (same result when passing: \"div\" or true)\n *        script: undefined   // Remove script elements\n *      }\n *    });\n *    // => <div><div><span>foo bar</span></div></div>\n *\n *    var userHTML = '<table><tbody><tr><td>I'm a table!</td></tr></tbody></table>';\n *    wysihtml5.dom.parse(userHTML);\n *    // => '<span><span><span><span>I'm a table!</span></span></span></span>'\n *\n *    var userHTML = '<div>foobar<br>foobar</div>';\n *    wysihtml5.dom.parse(userHTML, {\n *      tags: {\n *        div: undefined,\n *        br:  true\n *      }\n *    });\n *    // => ''\n *\n *    var userHTML = '<div class=\"red\">foo</div><div class=\"pink\">bar</div>';\n *    wysihtml5.dom.parse(userHTML, {\n *      classes: {\n *        red:    1,\n *        green:  1\n *      },\n *      tags: {\n *        div: {\n *          rename_tag:     \"p\"\n *        }\n *      }\n *    });\n *    // => '<p class=\"red\">foo</p><p>bar</p>'\n */\nwysihtml5.dom.parse = function () {\n\n  /**\n   * It's not possible to use a XMLParser/DOMParser as HTML5 is not always well-formed XML\n   * new DOMParser().parseFromString('<img src=\"foo.gif\">') will cause a parseError since the\n   * node isn't closed\n   *\n   * Therefore we've to use the browser's ordinary HTML parser invoked by setting innerHTML.\n   */\n  var NODE_TYPE_MAPPING = {\n    \"1\": _handleElement,\n    \"3\": _handleText\n  },\n\n  // Rename unknown tags to this\n  DEFAULT_NODE_NAME = \"span\",\n      WHITE_SPACE_REG_EXP = /\\s+/,\n      defaultRules = { tags: {}, classes: {} },\n      currentRules = {};\n\n  /**\n   * Iterates over all childs of the element, recreates them, appends them into a document fragment\n   * which later replaces the entire body content\n   */\n  function parse(elementOrHtml, rules, context, cleanUp) {\n    wysihtml5.lang.object(currentRules).merge(defaultRules).merge(rules).get();\n\n    context = context || elementOrHtml.ownerDocument || document;\n    var fragment = context.createDocumentFragment(),\n        isString = typeof elementOrHtml === \"string\",\n        element,\n        newNode,\n        firstChild;\n\n    if (isString) {\n      element = wysihtml5.dom.getAsDom(elementOrHtml, context);\n    } else {\n      element = elementOrHtml;\n    }\n\n    while (element.firstChild) {\n      firstChild = element.firstChild;\n      element.removeChild(firstChild);\n      newNode = _convert(firstChild, cleanUp);\n      if (newNode) {\n        fragment.appendChild(newNode);\n      }\n    }\n\n    // Clear element contents\n    element.innerHTML = \"\";\n\n    // Insert new DOM tree\n    element.appendChild(fragment);\n\n    return isString ? wysihtml5.quirks.getCorrectInnerHTML(element) : element;\n  }\n\n  function _convert(oldNode, cleanUp) {\n    var oldNodeType = oldNode.nodeType,\n        oldChilds = oldNode.childNodes,\n        oldChildsLength = oldChilds.length,\n        newNode,\n        method = NODE_TYPE_MAPPING[oldNodeType],\n        i = 0;\n\n    newNode = method && method(oldNode);\n\n    if (!newNode) {\n      return null;\n    }\n\n    for (i = 0; i < oldChildsLength; i++) {\n      newChild = _convert(oldChilds[i], cleanUp);\n      if (newChild) {\n        newNode.appendChild(newChild);\n      }\n    }\n\n    // Cleanup senseless <span> elements\n    if (cleanUp && newNode.childNodes.length <= 1 && newNode.nodeName.toLowerCase() === DEFAULT_NODE_NAME && !newNode.attributes.length) {\n      return newNode.firstChild;\n    }\n\n    return newNode;\n  }\n\n  function _handleElement(oldNode) {\n    var rule,\n        newNode,\n        endTag,\n        tagRules = currentRules.tags,\n        nodeName = oldNode.nodeName.toLowerCase(),\n        scopeName = oldNode.scopeName;\n\n    /**\n     * We already parsed that element\n     * ignore it! (yes, this sometimes happens in IE8 when the html is invalid)\n     */\n    if (oldNode._wysihtml5) {\n      return null;\n    }\n    oldNode._wysihtml5 = 1;\n\n    if (oldNode.className === \"wysihtml5-temp\") {\n      return null;\n    }\n\n    /**\n     * IE is the only browser who doesn't include the namespace in the\n     * nodeName, that's why we have to prepend it by ourselves\n     * scopeName is a proprietary IE feature\n     * read more here http://msdn.microsoft.com/en-us/library/ms534388(v=vs.85).aspx\n     */\n    if (scopeName && scopeName != \"HTML\") {\n      nodeName = scopeName + \":\" + nodeName;\n    }\n\n    /**\n     * Repair node\n     * IE is a bit bitchy when it comes to invalid nested markup which includes unclosed tags\n     * A <p> doesn't need to be closed according HTML4-5 spec, we simply replace it with a <div> to preserve its content and layout\n     */\n    if (\"outerHTML\" in oldNode) {\n      if (!wysihtml5.browser.autoClosesUnclosedTags() && oldNode.nodeName === \"P\" && oldNode.outerHTML.slice(-4).toLowerCase() !== \"</p>\") {\n        nodeName = \"div\";\n      }\n    }\n\n    if (nodeName in tagRules) {\n      rule = tagRules[nodeName];\n      if (!rule || rule.remove) {\n        return null;\n      }\n\n      rule = typeof rule === \"string\" ? { rename_tag: rule } : rule;\n    } else if (oldNode.firstChild) {\n      rule = { rename_tag: DEFAULT_NODE_NAME };\n    } else {\n      // Remove empty unknown elements\n      return null;\n    }\n\n    newNode = oldNode.ownerDocument.createElement(rule.rename_tag || nodeName);\n    _handleAttributes(oldNode, newNode, rule);\n\n    oldNode = null;\n    return newNode;\n  }\n\n  function _handleAttributes(oldNode, newNode, rule) {\n    var attributes = {},\n        // fresh new set of attributes to set on newNode\n    setClass = rule.set_class,\n        // classes to set\n    addClass = rule.add_class,\n        // add classes based on existing attributes\n    setAttributes = rule.set_attributes,\n        // attributes to set on the current node\n    checkAttributes = rule.check_attributes,\n        // check/convert values of attributes\n    allowedClasses = currentRules.classes,\n        i = 0,\n        classes = [],\n        newClasses = [],\n        newUniqueClasses = [],\n        oldClasses = [],\n        classesLength,\n        newClassesLength,\n        currentClass,\n        newClass,\n        attributeName,\n        newAttributeValue,\n        method;\n\n    if (setAttributes) {\n      attributes = wysihtml5.lang.object(setAttributes).clone();\n    }\n\n    if (checkAttributes) {\n      for (attributeName in checkAttributes) {\n        method = attributeCheckMethods[checkAttributes[attributeName]];\n        if (!method) {\n          continue;\n        }\n        newAttributeValue = method(_getAttribute(oldNode, attributeName));\n        if (typeof newAttributeValue === \"string\") {\n          attributes[attributeName] = newAttributeValue;\n        }\n      }\n    }\n\n    if (setClass) {\n      classes.push(setClass);\n    }\n\n    if (addClass) {\n      for (attributeName in addClass) {\n        method = addClassMethods[addClass[attributeName]];\n        if (!method) {\n          continue;\n        }\n        newClass = method(_getAttribute(oldNode, attributeName));\n        if (typeof newClass === \"string\") {\n          classes.push(newClass);\n        }\n      }\n    }\n\n    // make sure that wysihtml5 temp class doesn't get stripped out\n    allowedClasses[\"_wysihtml5-temp-placeholder\"] = 1;\n\n    // add old classes last\n    oldClasses = oldNode.getAttribute(\"class\");\n    if (oldClasses) {\n      classes = classes.concat(oldClasses.split(WHITE_SPACE_REG_EXP));\n    }\n    classesLength = classes.length;\n    for (; i < classesLength; i++) {\n      currentClass = classes[i];\n      if (allowedClasses[currentClass]) {\n        newClasses.push(currentClass);\n      }\n    }\n\n    // remove duplicate entries and preserve class specificity\n    newClassesLength = newClasses.length;\n    while (newClassesLength--) {\n      currentClass = newClasses[newClassesLength];\n      if (!wysihtml5.lang.array(newUniqueClasses).contains(currentClass)) {\n        newUniqueClasses.unshift(currentClass);\n      }\n    }\n\n    if (newUniqueClasses.length) {\n      attributes[\"class\"] = newUniqueClasses.join(\" \");\n    }\n\n    // set attributes on newNode\n    for (attributeName in attributes) {\n      // Setting attributes can cause a js error in IE under certain circumstances\n      // eg. on a <img> under https when it's new attribute value is non-https\n      // TODO: Investigate this further and check for smarter handling\n      try {\n        newNode.setAttribute(attributeName, attributes[attributeName]);\n      } catch (e) {}\n    }\n\n    // IE8 sometimes loses the width/height attributes when those are set before the \"src\"\n    // so we make sure to set them again\n    if (attributes.src) {\n      if (typeof attributes.width !== \"undefined\") {\n        newNode.setAttribute(\"width\", attributes.width);\n      }\n      if (typeof attributes.height !== \"undefined\") {\n        newNode.setAttribute(\"height\", attributes.height);\n      }\n    }\n  }\n\n  /**\n   * IE gives wrong results for hasAttribute/getAttribute, for example:\n   *    var td = document.createElement(\"td\");\n   *    td.getAttribute(\"rowspan\"); // => \"1\" in IE\n   *\n   * Therefore we have to check the element's outerHTML for the attribute\n   */\n  var HAS_GET_ATTRIBUTE_BUG = !wysihtml5.browser.supportsGetAttributeCorrectly();\n  function _getAttribute(node, attributeName) {\n    attributeName = attributeName.toLowerCase();\n    var nodeName = node.nodeName;\n    if (nodeName == \"IMG\" && attributeName == \"src\" && _isLoadedImage(node) === true) {\n      // Get 'src' attribute value via object property since this will always contain the\n      // full absolute url (http://...)\n      // this fixes a very annoying bug in firefox (ver 3.6 & 4) and IE 8 where images copied from the same host\n      // will have relative paths, which the sanitizer strips out (see attributeCheckMethods.url)\n      return node.src;\n    } else if (HAS_GET_ATTRIBUTE_BUG && \"outerHTML\" in node) {\n      // Don't trust getAttribute/hasAttribute in IE 6-8, instead check the element's outerHTML\n      var outerHTML = node.outerHTML.toLowerCase(),\n\n      // TODO: This might not work for attributes without value: <input disabled>\n      hasAttribute = outerHTML.indexOf(\" \" + attributeName + \"=\") != -1;\n\n      return hasAttribute ? node.getAttribute(attributeName) : null;\n    } else {\n      return node.getAttribute(attributeName);\n    }\n  }\n\n  /**\n   * Check whether the given node is a proper loaded image\n   * FIXME: Returns undefined when unknown (Chrome, Safari)\n   */\n  function _isLoadedImage(node) {\n    try {\n      return node.complete && !node.mozMatchesSelector(\":-moz-broken\");\n    } catch (e) {\n      if (node.complete && node.readyState === \"complete\") {\n        return true;\n      }\n    }\n  }\n\n  function _handleText(oldNode) {\n    return oldNode.ownerDocument.createTextNode(oldNode.data);\n  }\n\n  // ------------ attribute checks ------------ \\\\\n  var attributeCheckMethods = {\n    url: function () {\n      var REG_EXP = /^https?:\\/\\//i;\n      return function (attributeValue) {\n        if (!attributeValue || !attributeValue.match(REG_EXP)) {\n          return null;\n        }\n        return attributeValue.replace(REG_EXP, function (match) {\n          return match.toLowerCase();\n        });\n      };\n    }(),\n\n    alt: function () {\n      var REG_EXP = /[^ a-z0-9_\\-]/gi;\n      return function (attributeValue) {\n        if (!attributeValue) {\n          return \"\";\n        }\n        return attributeValue.replace(REG_EXP, \"\");\n      };\n    }(),\n\n    numbers: function () {\n      var REG_EXP = /\\D/g;\n      return function (attributeValue) {\n        attributeValue = (attributeValue || \"\").replace(REG_EXP, \"\");\n        return attributeValue || null;\n      };\n    }()\n  };\n\n  // ------------ class converter (converts an html attribute to a class name) ------------ \\\\\n  var addClassMethods = {\n    align_img: function () {\n      var mapping = {\n        left: \"wysiwyg-float-left\",\n        right: \"wysiwyg-float-right\"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).toLowerCase()];\n      };\n    }(),\n\n    align_text: function () {\n      var mapping = {\n        left: \"wysiwyg-text-align-left\",\n        right: \"wysiwyg-text-align-right\",\n        center: \"wysiwyg-text-align-center\",\n        justify: \"wysiwyg-text-align-justify\"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).toLowerCase()];\n      };\n    }(),\n\n    clear_br: function () {\n      var mapping = {\n        left: \"wysiwyg-clear-left\",\n        right: \"wysiwyg-clear-right\",\n        both: \"wysiwyg-clear-both\",\n        all: \"wysiwyg-clear-both\"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).toLowerCase()];\n      };\n    }(),\n\n    size_font: function () {\n      var mapping = {\n        \"1\": \"wysiwyg-font-size-xx-small\",\n        \"2\": \"wysiwyg-font-size-small\",\n        \"3\": \"wysiwyg-font-size-medium\",\n        \"4\": \"wysiwyg-font-size-large\",\n        \"5\": \"wysiwyg-font-size-x-large\",\n        \"6\": \"wysiwyg-font-size-xx-large\",\n        \"7\": \"wysiwyg-font-size-xx-large\",\n        \"-\": \"wysiwyg-font-size-smaller\",\n        \"+\": \"wysiwyg-font-size-larger\"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).charAt(0)];\n      };\n    }()\n  };\n\n  return parse;\n}(); /**\n     * Checks for empty text node childs and removes them\n     *\n     * @param {Element} node The element in which to cleanup\n     * @example\n     *    wysihtml5.dom.removeEmptyTextNodes(element);\n     */\nwysihtml5.dom.removeEmptyTextNodes = function (node) {\n  var childNode,\n      childNodes = wysihtml5.lang.array(node.childNodes).get(),\n      childNodesLength = childNodes.length,\n      i = 0;\n  for (; i < childNodesLength; i++) {\n    childNode = childNodes[i];\n    if (childNode.nodeType === wysihtml5.TEXT_NODE && childNode.data === \"\") {\n      childNode.parentNode.removeChild(childNode);\n    }\n  }\n};\n/**\n * Renames an element (eg. a <div> to a <p>) and keeps its childs\n *\n * @param {Element} element The list element which should be renamed\n * @param {Element} newNodeName The desired tag name\n *\n * @example\n *    <!-- Assume the following dom: -->\n *    <ul id=\"list\">\n *      <li>eminem</li>\n *      <li>dr. dre</li>\n *      <li>50 Cent</li>\n *    </ul>\n *\n *    <script>\n *      wysihtml5.dom.renameElement(document.getElementById(\"list\"), \"ol\");\n *    </script>\n *\n *    <!-- Will result in: -->\n *    <ol>\n *      <li>eminem</li>\n *      <li>dr. dre</li>\n *      <li>50 Cent</li>\n *    </ol>\n */\nwysihtml5.dom.renameElement = function (element, newNodeName) {\n  var newElement = element.ownerDocument.createElement(newNodeName),\n      firstChild;\n  while (firstChild = element.firstChild) {\n    newElement.appendChild(firstChild);\n  }\n  wysihtml5.dom.copyAttributes([\"align\", \"className\"]).from(element).to(newElement);\n  element.parentNode.replaceChild(newElement, element);\n  return newElement;\n}; /**\n   * Takes an element, removes it and replaces it with it's childs\n   * \n   * @param {Object} node The node which to replace with it's child nodes\n   * @example\n   *    <div id=\"foo\">\n   *      <span>hello</span>\n   *    </div>\n   *    <script>\n   *      // Remove #foo and replace with it's children\n   *      wysihtml5.dom.replaceWithChildNodes(document.getElementById(\"foo\"));\n   *    </script>\n   */\nwysihtml5.dom.replaceWithChildNodes = function (node) {\n  if (!node.parentNode) {\n    return;\n  }\n\n  if (!node.firstChild) {\n    node.parentNode.removeChild(node);\n    return;\n  }\n\n  var fragment = node.ownerDocument.createDocumentFragment();\n  while (node.firstChild) {\n    fragment.appendChild(node.firstChild);\n  }\n  node.parentNode.replaceChild(fragment, node);\n  node = fragment = null;\n};\n/**\n * Unwraps an unordered/ordered list\n *\n * @param {Element} element The list element which should be unwrapped\n *\n * @example\n *    <!-- Assume the following dom: -->\n *    <ul id=\"list\">\n *      <li>eminem</li>\n *      <li>dr. dre</li>\n *      <li>50 Cent</li>\n *    </ul>\n *\n *    <script>\n *      wysihtml5.dom.resolveList(document.getElementById(\"list\"));\n *    </script>\n *\n *    <!-- Will result in: -->\n *    eminem<br>\n *    dr. dre<br>\n *    50 Cent<br>\n */\n(function (dom) {\n  function _isBlockElement(node) {\n    return dom.getStyle(\"display\").from(node) === \"block\";\n  }\n\n  function _isLineBreak(node) {\n    return node.nodeName === \"BR\";\n  }\n\n  function _appendLineBreak(element) {\n    var lineBreak = element.ownerDocument.createElement(\"br\");\n    element.appendChild(lineBreak);\n  }\n\n  function resolveList(list) {\n    if (list.nodeName !== \"MENU\" && list.nodeName !== \"UL\" && list.nodeName !== \"OL\") {\n      return;\n    }\n\n    var doc = list.ownerDocument,\n        fragment = doc.createDocumentFragment(),\n        previousSibling = list.previousElementSibling || list.previousSibling,\n        firstChild,\n        lastChild,\n        isLastChild,\n        shouldAppendLineBreak,\n        listItem;\n\n    if (previousSibling && !_isBlockElement(previousSibling)) {\n      _appendLineBreak(fragment);\n    }\n\n    while (listItem = list.firstChild) {\n      lastChild = listItem.lastChild;\n      while (firstChild = listItem.firstChild) {\n        isLastChild = firstChild === lastChild;\n        // This needs to be done before appending it to the fragment, as it otherwise will loose style information\n        shouldAppendLineBreak = isLastChild && !_isBlockElement(firstChild) && !_isLineBreak(firstChild);\n        fragment.appendChild(firstChild);\n        if (shouldAppendLineBreak) {\n          _appendLineBreak(fragment);\n        }\n      }\n\n      listItem.parentNode.removeChild(listItem);\n    }\n    list.parentNode.replaceChild(fragment, list);\n  }\n\n  dom.resolveList = resolveList;\n})(wysihtml5.dom); /**\n                   * Sandbox for executing javascript, parsing css styles and doing dom operations in a secure way\n                   *\n                   * Browser Compatibility:\n                   *  - Secure in MSIE 6+, but only when the user hasn't made changes to his security level \"restricted\"\n                   *  - Partially secure in other browsers (Firefox, Opera, Safari, Chrome, ...)\n                   *\n                   * Please note that this class can't benefit from the HTML5 sandbox attribute for the following reasons:\n                   *    - sandboxing doesn't work correctly with inlined content (src=\"javascript:'<html>...</html>'\")\n                   *    - sandboxing of physical documents causes that the dom isn't accessible anymore from the outside (iframe.contentWindow, ...)\n                   *    - setting the \"allow-same-origin\" flag would fix that, but then still javascript and dom events refuse to fire\n                   *    - therefore the \"allow-scripts\" flag is needed, which then would deactivate any security, as the js executed inside the iframe\n                   *      can do anything as if the sandbox attribute wasn't set\n                   *\n                   * @param {Function} [readyCallback] Method that gets invoked when the sandbox is ready\n                   * @param {Object} [config] Optional parameters\n                   *\n                   * @example\n                   *    new wysihtml5.dom.Sandbox(function(sandbox) {\n                   *      sandbox.getWindow().document.body.innerHTML = '<img src=foo.gif onerror=\"alert(document.cookie)\">';\n                   *    });\n                   */\n(function (wysihtml5) {\n  var /**\n       * Default configuration\n       */\n  doc = document,\n\n  /**\n   * Properties to unset/protect on the window object\n   */\n  windowProperties = [\"parent\", \"top\", \"opener\", \"frameElement\", \"frames\", \"localStorage\", \"globalStorage\", \"sessionStorage\", \"indexedDB\"],\n\n  /**\n   * Properties on the window object which are set to an empty function\n   */\n  windowProperties2 = [\"open\", \"close\", \"openDialog\", \"showModalDialog\", \"alert\", \"confirm\", \"prompt\", \"openDatabase\", \"postMessage\", \"XMLHttpRequest\", \"XDomainRequest\"],\n\n  /**\n   * Properties to unset/protect on the document object\n   */\n  documentProperties = [\"referrer\", \"write\", \"open\", \"close\"];\n\n  wysihtml5.dom.Sandbox = Base.extend(\n  /** @scope wysihtml5.dom.Sandbox.prototype */{\n\n    constructor: function constructor(readyCallback, config) {\n      this.callback = readyCallback || wysihtml5.EMPTY_FUNCTION;\n      this.config = wysihtml5.lang.object({}).merge(config).get();\n      this.iframe = this._createIframe();\n    },\n\n    insertInto: function insertInto(element) {\n      if (typeof element === \"string\") {\n        element = doc.getElementById(element);\n      }\n\n      element.appendChild(this.iframe);\n    },\n\n    getIframe: function getIframe() {\n      return this.iframe;\n    },\n\n    getWindow: function getWindow() {\n      this._readyError();\n    },\n\n    getDocument: function getDocument() {\n      this._readyError();\n    },\n\n    destroy: function destroy() {\n      var iframe = this.getIframe();\n      iframe.parentNode.removeChild(iframe);\n    },\n\n    _readyError: function _readyError() {\n      throw new Error(\"wysihtml5.Sandbox: Sandbox iframe isn't loaded yet\");\n    },\n\n    /**\n     * Creates the sandbox iframe\n     *\n     * Some important notes:\n     *  - We can't use HTML5 sandbox for now:\n     *    setting it causes that the iframe's dom can't be accessed from the outside\n     *    Therefore we need to set the \"allow-same-origin\" flag which enables accessing the iframe's dom\n     *    But then there's another problem, DOM events (focus, blur, change, keypress, ...) aren't fired.\n     *    In order to make this happen we need to set the \"allow-scripts\" flag.\n     *    A combination of allow-scripts and allow-same-origin is almost the same as setting no sandbox attribute at all.\n     *  - Chrome & Safari, doesn't seem to support sandboxing correctly when the iframe's html is inlined (no physical document)\n     *  - IE needs to have the security=\"restricted\" attribute set before the iframe is \n     *    inserted into the dom tree\n     *  - Believe it or not but in IE \"security\" in document.createElement(\"iframe\") is false, even\n     *    though it supports it\n     *  - When an iframe has security=\"restricted\", in IE eval() & execScript() don't work anymore\n     *  - IE doesn't fire the onload event when the content is inlined in the src attribute, therefore we rely\n     *    on the onreadystatechange event\n     */\n    _createIframe: function _createIframe() {\n      var that = this,\n          iframe = doc.createElement(\"iframe\");\n      iframe.className = \"wysihtml5-sandbox\";\n      wysihtml5.dom.setAttributes({\n        \"security\": \"restricted\",\n        \"allowtransparency\": \"true\",\n        \"frameborder\": 0,\n        \"width\": 0,\n        \"height\": 0,\n        \"marginwidth\": 0,\n        \"marginheight\": 0\n      }).on(iframe);\n\n      // Setting the src like this prevents ssl warnings in IE6\n      if (wysihtml5.browser.throwsMixedContentWarningWhenIframeSrcIsEmpty()) {\n        iframe.src = \"javascript:'<html></html>'\";\n      }\n\n      iframe.onload = function () {\n        iframe.onreadystatechange = iframe.onload = null;\n        that._onLoadIframe(iframe);\n      };\n\n      iframe.onreadystatechange = function () {\n        if (/loaded|complete/.test(iframe.readyState)) {\n          iframe.onreadystatechange = iframe.onload = null;\n          that._onLoadIframe(iframe);\n        }\n      };\n\n      return iframe;\n    },\n\n    /**\n     * Callback for when the iframe has finished loading\n     */\n    _onLoadIframe: function _onLoadIframe(iframe) {\n      // don't resume when the iframe got unloaded (eg. by removing it from the dom)\n      if (!wysihtml5.dom.contains(doc.documentElement, iframe)) {\n        return;\n      }\n\n      var that = this,\n          iframeWindow = iframe.contentWindow,\n          iframeDocument = iframe.contentWindow.document,\n          charset = doc.characterSet || doc.charset || \"utf-8\",\n          sandboxHtml = this._getHtml({\n        charset: charset,\n        stylesheets: this.config.stylesheets\n      });\n\n      // Create the basic dom tree including proper DOCTYPE and charset\n      iframeDocument.open(\"text/html\", \"replace\");\n      iframeDocument.write(sandboxHtml);\n      iframeDocument.close();\n\n      this.getWindow = function () {\n        return iframe.contentWindow;\n      };\n      this.getDocument = function () {\n        return iframe.contentWindow.document;\n      };\n\n      // Catch js errors and pass them to the parent's onerror event\n      // addEventListener(\"error\") doesn't work properly in some browsers\n      // TODO: apparently this doesn't work in IE9!\n      iframeWindow.onerror = function (errorMessage, fileName, lineNumber) {\n        throw new Error(\"wysihtml5.Sandbox: \" + errorMessage, fileName, lineNumber);\n      };\n\n      if (!wysihtml5.browser.supportsSandboxedIframes()) {\n        // Unset a bunch of sensitive variables\n        // Please note: This isn't hack safe!  \n        // It more or less just takes care of basic attacks and prevents accidental theft of sensitive information\n        // IE is secure though, which is the most important thing, since IE is the only browser, who\n        // takes over scripts & styles into contentEditable elements when copied from external websites\n        // or applications (Microsoft Word, ...)\n        var i, length;\n        for (i = 0, length = windowProperties.length; i < length; i++) {\n          this._unset(iframeWindow, windowProperties[i]);\n        }\n        for (i = 0, length = windowProperties2.length; i < length; i++) {\n          this._unset(iframeWindow, windowProperties2[i], wysihtml5.EMPTY_FUNCTION);\n        }\n        for (i = 0, length = documentProperties.length; i < length; i++) {\n          this._unset(iframeDocument, documentProperties[i]);\n        }\n        // This doesn't work in Safari 5 \n        // See http://stackoverflow.com/questions/992461/is-it-possible-to-override-document-cookie-in-webkit\n        this._unset(iframeDocument, \"cookie\", \"\", true);\n      }\n\n      this.loaded = true;\n\n      // Trigger the callback\n      setTimeout(function () {\n        that.callback(that);\n      }, 0);\n    },\n\n    _getHtml: function _getHtml(templateVars) {\n      var stylesheets = templateVars.stylesheets,\n          html = \"\",\n          i = 0,\n          length;\n      stylesheets = typeof stylesheets === \"string\" ? [stylesheets] : stylesheets;\n      if (stylesheets) {\n        length = stylesheets.length;\n        for (; i < length; i++) {\n          html += '<link rel=\"stylesheet\" href=\"' + stylesheets[i] + '\">';\n        }\n      }\n      templateVars.stylesheets = html;\n\n      return wysihtml5.lang.string('<!DOCTYPE html><html><head>' + '<meta charset=\"#{charset}\">#{stylesheets}</head>' + '<body></body></html>').interpolate(templateVars);\n    },\n\n    /**\n     * Method to unset/override existing variables\n     * @example\n     *    // Make cookie unreadable and unwritable\n     *    this._unset(document, \"cookie\", \"\", true);\n     */\n    _unset: function _unset(object, property, value, setter) {\n      try {\n        object[property] = value;\n      } catch (e) {}\n\n      try {\n        object.__defineGetter__(property, function () {\n          return value;\n        });\n      } catch (e) {}\n      if (setter) {\n        try {\n          object.__defineSetter__(property, function () {});\n        } catch (e) {}\n      }\n\n      if (!wysihtml5.browser.crashesWhenDefineProperty(property)) {\n        try {\n          var config = {\n            get: function get() {\n              return value;\n            }\n          };\n          if (setter) {\n            config.set = function () {};\n          }\n          Object.defineProperty(object, property, config);\n        } catch (e) {}\n      }\n    }\n  });\n})(wysihtml5);\n(function () {\n  var mapping = {\n    \"className\": \"class\"\n  };\n  wysihtml5.dom.setAttributes = function (attributes) {\n    return {\n      on: function on(element) {\n        for (var i in attributes) {\n          element.setAttribute(mapping[i] || i, attributes[i]);\n        }\n      }\n    };\n  };\n})();wysihtml5.dom.setStyles = function (styles) {\n  return {\n    on: function on(element) {\n      var style = element.style;\n      if (typeof styles === \"string\") {\n        style.cssText += \";\" + styles;\n        return;\n      }\n      for (var i in styles) {\n        if (i === \"float\") {\n          style.cssFloat = styles[i];\n          style.styleFloat = styles[i];\n        } else {\n          style[i] = styles[i];\n        }\n      }\n    }\n  };\n}; /**\n   * Simulate HTML5 placeholder attribute\n   *\n   * Needed since\n   *    - div[contentEditable] elements don't support it\n   *    - older browsers (such as IE8 and Firefox 3.6) don't support it at all\n   *\n   * @param {Object} parent Instance of main wysihtml5.Editor class\n   * @param {Element} view Instance of wysihtml5.views.* class\n   * @param {String} placeholderText\n   *\n   * @example\n   *    wysihtml.dom.simulatePlaceholder(this, composer, \"Foobar\");\n   */\n(function (dom) {\n  dom.simulatePlaceholder = function (editor, view, placeholderText) {\n    var CLASS_NAME = \"placeholder\",\n        unset = function unset() {\n      if (view.hasPlaceholderSet()) {\n        view.clear();\n      }\n      dom.removeClass(view.element, CLASS_NAME);\n    },\n        set = function set() {\n      if (view.isEmpty()) {\n        view.setValue(placeholderText);\n        dom.addClass(view.element, CLASS_NAME);\n      }\n    };\n\n    editor.observe(\"set_placeholder\", set).observe(\"unset_placeholder\", unset).observe(\"focus:composer\", unset).observe(\"paste:composer\", unset).observe(\"blur:composer\", set);\n\n    set();\n  };\n})(wysihtml5.dom);\n(function (dom) {\n  var documentElement = document.documentElement;\n  if (\"textContent\" in documentElement) {\n    dom.setTextContent = function (element, text) {\n      element.textContent = text;\n    };\n\n    dom.getTextContent = function (element) {\n      return element.textContent;\n    };\n  } else if (\"innerText\" in documentElement) {\n    dom.setTextContent = function (element, text) {\n      element.innerText = text;\n    };\n\n    dom.getTextContent = function (element) {\n      return element.innerText;\n    };\n  } else {\n    dom.setTextContent = function (element, text) {\n      element.nodeValue = text;\n    };\n\n    dom.getTextContent = function (element) {\n      return element.nodeValue;\n    };\n  }\n})(wysihtml5.dom);\n\n/**\n * Fix most common html formatting misbehaviors of browsers implementation when inserting\n * content via copy & paste contentEditable\n *\n * @author Christopher Blum\n */\nwysihtml5.quirks.cleanPastedHTML = function () {\n  // TODO: We probably need more rules here\n  var defaultRules = {\n    // When pasting underlined links <a> into a contentEditable, IE thinks, it has to insert <u> to keep the styling\n    \"a u\": wysihtml5.dom.replaceWithChildNodes\n  };\n\n  function cleanPastedHTML(elementOrHtml, rules, context) {\n    rules = rules || defaultRules;\n    context = context || elementOrHtml.ownerDocument || document;\n\n    var element,\n        isString = typeof elementOrHtml === \"string\",\n        method,\n        matches,\n        matchesLength,\n        i,\n        j = 0;\n    if (isString) {\n      element = wysihtml5.dom.getAsDom(elementOrHtml, context);\n    } else {\n      element = elementOrHtml;\n    }\n\n    for (i in rules) {\n      matches = element.querySelectorAll(i);\n      method = rules[i];\n      matchesLength = matches.length;\n      for (; j < matchesLength; j++) {\n        method(matches[j]);\n      }\n    }\n\n    matches = elementOrHtml = rules = null;\n\n    return isString ? element.innerHTML : element;\n  }\n\n  return cleanPastedHTML;\n}(); /**\n     * IE and Opera leave an empty paragraph in the contentEditable element after clearing it\n     *\n     * @param {Object} contentEditableElement The contentEditable element to observe for clearing events\n     * @exaple\n     *    wysihtml5.quirks.ensureProperClearing(myContentEditableElement);\n     */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom;\n\n  wysihtml5.quirks.ensureProperClearing = function () {\n    var clearIfNecessary = function clearIfNecessary(event) {\n      var element = this;\n      setTimeout(function () {\n        var innerHTML = element.innerHTML.toLowerCase();\n        if (innerHTML == \"<p>&nbsp;</p>\" || innerHTML == \"<p>&nbsp;</p><p>&nbsp;</p>\") {\n          element.innerHTML = \"\";\n        }\n      }, 0);\n    };\n\n    return function (composer) {\n      dom.observe(composer.element, [\"cut\", \"keydown\"], clearIfNecessary);\n    };\n  }();\n\n  /**\n   * In Opera when the caret is in the first and only item of a list (<ul><li>|</li></ul>) and the list is the first child of the contentEditable element, it's impossible to delete the list by hitting backspace\n   *\n   * @param {Object} contentEditableElement The contentEditable element to observe for clearing events\n   * @exaple\n   *    wysihtml5.quirks.ensureProperClearing(myContentEditableElement);\n   */\n  wysihtml5.quirks.ensureProperClearingOfLists = function () {\n    var ELEMENTS_THAT_CONTAIN_LI = [\"OL\", \"UL\", \"MENU\"];\n\n    var clearIfNecessary = function clearIfNecessary(element, contentEditableElement) {\n      if (!contentEditableElement.firstChild || !wysihtml5.lang.array(ELEMENTS_THAT_CONTAIN_LI).contains(contentEditableElement.firstChild.nodeName)) {\n        return;\n      }\n\n      var list = dom.getParentElement(element, { nodeName: ELEMENTS_THAT_CONTAIN_LI });\n      if (!list) {\n        return;\n      }\n\n      var listIsFirstChildOfContentEditable = list == contentEditableElement.firstChild;\n      if (!listIsFirstChildOfContentEditable) {\n        return;\n      }\n\n      var hasOnlyOneListItem = list.childNodes.length <= 1;\n      if (!hasOnlyOneListItem) {\n        return;\n      }\n\n      var onlyListItemIsEmpty = list.firstChild ? list.firstChild.innerHTML === \"\" : true;\n      if (!onlyListItemIsEmpty) {\n        return;\n      }\n\n      list.parentNode.removeChild(list);\n    };\n\n    return function (composer) {\n      dom.observe(composer.element, \"keydown\", function (event) {\n        if (event.keyCode !== wysihtml5.BACKSPACE_KEY) {\n          return;\n        }\n\n        var element = composer.selection.getSelectedNode();\n        clearIfNecessary(element, composer.element);\n      });\n    };\n  }();\n})(wysihtml5);\n// See https://bugzilla.mozilla.org/show_bug.cgi?id=664398\n//\n// In Firefox this:\n//      var d = document.createElement(\"div\");\n//      d.innerHTML ='<a href=\"~\"></a>';\n//      d.innerHTML;\n// will result in:\n//      <a href=\"%7E\"></a>\n// which is wrong\n(function (wysihtml5) {\n  var TILDE_ESCAPED = \"%7E\";\n  wysihtml5.quirks.getCorrectInnerHTML = function (element) {\n    var innerHTML = element.innerHTML;\n    if (innerHTML.indexOf(TILDE_ESCAPED) === -1) {\n      return innerHTML;\n    }\n\n    var elementsWithTilde = element.querySelectorAll(\"[href*='~'], [src*='~']\"),\n        url,\n        urlToSearch,\n        length,\n        i;\n    for (i = 0, length = elementsWithTilde.length; i < length; i++) {\n      url = elementsWithTilde[i].href || elementsWithTilde[i].src;\n      urlToSearch = wysihtml5.lang.string(url).replace(\"~\").by(TILDE_ESCAPED);\n      innerHTML = wysihtml5.lang.string(innerHTML).replace(urlToSearch).by(url);\n    }\n    return innerHTML;\n  };\n})(wysihtml5); /**\n               * Some browsers don't insert line breaks when hitting return in a contentEditable element\n               *    - Opera & IE insert new <p> on return\n               *    - Chrome & Safari insert new <div> on return\n               *    - Firefox inserts <br> on return (yippie!)\n               *\n               * @param {Element} element\n               *\n               * @example\n               *    wysihtml5.quirks.insertLineBreakOnReturn(element);\n               */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      USE_NATIVE_LINE_BREAK_WHEN_CARET_INSIDE_TAGS = [\"LI\", \"P\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\"],\n      LIST_TAGS = [\"UL\", \"OL\", \"MENU\"];\n\n  wysihtml5.quirks.insertLineBreakOnReturn = function (composer) {\n    function unwrap(selectedNode) {\n      var parentElement = dom.getParentElement(selectedNode, { nodeName: [\"P\", \"DIV\"] }, 2);\n      if (!parentElement) {\n        return;\n      }\n\n      var invisibleSpace = document.createTextNode(wysihtml5.INVISIBLE_SPACE);\n      dom.insert(invisibleSpace).before(parentElement);\n      dom.replaceWithChildNodes(parentElement);\n      composer.selection.selectNode(invisibleSpace);\n    }\n\n    function keyDown(event) {\n      var keyCode = event.keyCode;\n      if (event.shiftKey || keyCode !== wysihtml5.ENTER_KEY && keyCode !== wysihtml5.BACKSPACE_KEY) {\n        return;\n      }\n\n      var element = event.target,\n          selectedNode = composer.selection.getSelectedNode(),\n          blockElement = dom.getParentElement(selectedNode, { nodeName: USE_NATIVE_LINE_BREAK_WHEN_CARET_INSIDE_TAGS }, 4);\n      if (blockElement) {\n        // Some browsers create <p> elements after leaving a list\n        // check after keydown of backspace and return whether a <p> got inserted and unwrap it\n        if (blockElement.nodeName === \"LI\" && (keyCode === wysihtml5.ENTER_KEY || keyCode === wysihtml5.BACKSPACE_KEY)) {\n          setTimeout(function () {\n            var selectedNode = composer.selection.getSelectedNode(),\n                list,\n                div;\n            if (!selectedNode) {\n              return;\n            }\n\n            list = dom.getParentElement(selectedNode, {\n              nodeName: LIST_TAGS\n            }, 2);\n\n            if (list) {\n              return;\n            }\n\n            unwrap(selectedNode);\n          }, 0);\n        } else if (blockElement.nodeName.match(/H[1-6]/) && keyCode === wysihtml5.ENTER_KEY) {\n          setTimeout(function () {\n            unwrap(composer.selection.getSelectedNode());\n          }, 0);\n        }\n        return;\n      }\n\n      if (keyCode === wysihtml5.ENTER_KEY && !wysihtml5.browser.insertsLineBreaksOnReturn()) {\n        composer.commands.exec(\"insertLineBreak\");\n        event.preventDefault();\n      }\n    }\n\n    // keypress doesn't fire when you hit backspace\n    dom.observe(composer.element.ownerDocument, \"keydown\", keyDown);\n  };\n})(wysihtml5); /**\n               * Force rerendering of a given element\n               * Needed to fix display misbehaviors of IE\n               *\n               * @param {Element} element The element object which needs to be rerendered\n               * @example\n               *    wysihtml5.quirks.redraw(document.body);\n               */\n(function (wysihtml5) {\n  var CLASS_NAME = \"wysihtml5-quirks-redraw\";\n\n  wysihtml5.quirks.redraw = function (element) {\n    wysihtml5.dom.addClass(element, CLASS_NAME);\n    wysihtml5.dom.removeClass(element, CLASS_NAME);\n\n    // Following hack is needed for firefox to make sure that image resize handles are properly removed\n    try {\n      var doc = element.ownerDocument;\n      doc.execCommand(\"italic\", false, null);\n      doc.execCommand(\"italic\", false, null);\n    } catch (e) {}\n  };\n})(wysihtml5); /**\n               * Selection API\n               *\n               * @example\n               *    var selection = new wysihtml5.Selection(editor);\n               */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom;\n\n  function _getCumulativeOffsetTop(element) {\n    var top = 0;\n    if (element.parentNode) {\n      do {\n        top += element.offsetTop || 0;\n        element = element.offsetParent;\n      } while (element);\n    }\n    return top;\n  }\n\n  wysihtml5.Selection = Base.extend(\n  /** @scope wysihtml5.Selection.prototype */{\n    constructor: function constructor(editor) {\n      // Make sure that our external range library is initialized\n      window.rangy.init();\n\n      this.editor = editor;\n      this.composer = editor.composer;\n      this.doc = this.composer.doc;\n    },\n\n    /**\n     * Get the current selection as a bookmark to be able to later restore it\n     *\n     * @return {Object} An object that represents the current selection\n     */\n    getBookmark: function getBookmark() {\n      var range = this.getRange();\n      return range && range.cloneRange();\n    },\n\n    /**\n     * Restore a selection retrieved via wysihtml5.Selection.prototype.getBookmark\n     *\n     * @param {Object} bookmark An object that represents the current selection\n     */\n    setBookmark: function setBookmark(bookmark) {\n      if (!bookmark) {\n        return;\n      }\n\n      this.setSelection(bookmark);\n    },\n\n    /**\n     * Set the caret in front of the given node\n     *\n     * @param {Object} node The element or text node where to position the caret in front of\n     * @example\n     *    selection.setBefore(myElement);\n     */\n    setBefore: function setBefore(node) {\n      var range = rangy.createRange(this.doc);\n      range.setStartBefore(node);\n      range.setEndBefore(node);\n      return this.setSelection(range);\n    },\n\n    /**\n     * Set the caret after the given node\n     *\n     * @param {Object} node The element or text node where to position the caret in front of\n     * @example\n     *    selection.setBefore(myElement);\n     */\n    setAfter: function setAfter(node) {\n      var range = rangy.createRange(this.doc);\n      range.setStartAfter(node);\n      range.setEndAfter(node);\n      return this.setSelection(range);\n    },\n\n    /**\n     * Ability to select/mark nodes\n     *\n     * @param {Element} node The node/element to select\n     * @example\n     *    selection.selectNode(document.getElementById(\"my-image\"));\n     */\n    selectNode: function selectNode(node) {\n      var range = rangy.createRange(this.doc),\n          isElement = node.nodeType === wysihtml5.ELEMENT_NODE,\n          canHaveHTML = \"canHaveHTML\" in node ? node.canHaveHTML : node.nodeName !== \"IMG\",\n          content = isElement ? node.innerHTML : node.data,\n          isEmpty = content === \"\" || content === wysihtml5.INVISIBLE_SPACE,\n          displayStyle = dom.getStyle(\"display\").from(node),\n          isBlockElement = displayStyle === \"block\" || displayStyle === \"list-item\";\n\n      if (isEmpty && isElement && canHaveHTML) {\n        // Make sure that caret is visible in node by inserting a zero width no breaking space\n        try {\n          node.innerHTML = wysihtml5.INVISIBLE_SPACE;\n        } catch (e) {}\n      }\n\n      if (canHaveHTML) {\n        range.selectNodeContents(node);\n      } else {\n        range.selectNode(node);\n      }\n\n      if (canHaveHTML && isEmpty && isElement) {\n        range.collapse(isBlockElement);\n      } else if (canHaveHTML && isEmpty) {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n\n      this.setSelection(range);\n    },\n\n    /**\n     * Get the node which contains the selection\n     *\n     * @param {Boolean} [controlRange] (only IE) Whether it should return the selected ControlRange element when the selection type is a \"ControlRange\"\n     * @return {Object} The node that contains the caret\n     * @example\n     *    var nodeThatContainsCaret = selection.getSelectedNode();\n     */\n    getSelectedNode: function getSelectedNode(controlRange) {\n      var selection, range;\n\n      if (controlRange && this.doc.selection && this.doc.selection.type === \"Control\") {\n        range = this.doc.selection.createRange();\n        if (range && range.length) {\n          return range.item(0);\n        }\n      }\n\n      selection = this.getSelection(this.doc);\n      if (selection.focusNode === selection.anchorNode) {\n        return selection.focusNode;\n      } else {\n        range = this.getRange(this.doc);\n        return range ? range.commonAncestorContainer : this.doc.body;\n      }\n    },\n\n    executeAndRestore: function executeAndRestore(method, restoreScrollPosition) {\n      var body = this.doc.body,\n          oldScrollTop = restoreScrollPosition && body.scrollTop,\n          oldScrollLeft = restoreScrollPosition && body.scrollLeft,\n          className = \"_wysihtml5-temp-placeholder\",\n          placeholderHTML = '<span class=\"' + className + '\">' + wysihtml5.INVISIBLE_SPACE + '</span>',\n          range = this.getRange(this.doc),\n          newRange;\n\n      // Nothing selected, execute and say goodbye\n      if (!range) {\n        method(body, body);\n        return;\n      }\n\n      var node = range.createContextualFragment(placeholderHTML);\n      range.insertNode(node);\n\n      // Make sure that a potential error doesn't cause our placeholder element to be left as a placeholder\n      try {\n        method(range.startContainer, range.endContainer);\n      } catch (e3) {\n        setTimeout(function () {\n          throw e3;\n        }, 0);\n      }\n\n      caretPlaceholder = this.doc.querySelector(\".\" + className);\n      if (caretPlaceholder) {\n        newRange = rangy.createRange(this.doc);\n        newRange.selectNode(caretPlaceholder);\n        newRange.deleteContents();\n        this.setSelection(newRange);\n      } else {\n        // fallback for when all hell breaks loose\n        body.focus();\n      }\n\n      if (restoreScrollPosition) {\n        body.scrollTop = oldScrollTop;\n        body.scrollLeft = oldScrollLeft;\n      }\n\n      // Remove it again, just to make sure that the placeholder is definitely out of the dom tree\n      try {\n        caretPlaceholder.parentNode.removeChild(caretPlaceholder);\n      } catch (e4) {}\n    },\n\n    /**\n     * Different approach of preserving the selection (doesn't modify the dom)\n     * Takes all text nodes in the selection and saves the selection position in the first and last one\n     */\n    executeAndRestoreSimple: function executeAndRestoreSimple(method) {\n      var range = this.getRange(),\n          body = this.doc.body,\n          newRange,\n          firstNode,\n          lastNode,\n          textNodes,\n          rangeBackup;\n\n      // Nothing selected, execute and say goodbye\n      if (!range) {\n        method(body, body);\n        return;\n      }\n\n      textNodes = range.getNodes([3]);\n      firstNode = textNodes[0] || range.startContainer;\n      lastNode = textNodes[textNodes.length - 1] || range.endContainer;\n\n      rangeBackup = {\n        collapsed: range.collapsed,\n        startContainer: firstNode,\n        startOffset: firstNode === range.startContainer ? range.startOffset : 0,\n        endContainer: lastNode,\n        endOffset: lastNode === range.endContainer ? range.endOffset : lastNode.length\n      };\n\n      try {\n        method(range.startContainer, range.endContainer);\n      } catch (e) {\n        setTimeout(function () {\n          throw e;\n        }, 0);\n      }\n\n      newRange = rangy.createRange(this.doc);\n      try {\n        newRange.setStart(rangeBackup.startContainer, rangeBackup.startOffset);\n      } catch (e1) {}\n      try {\n        newRange.setEnd(rangeBackup.endContainer, rangeBackup.endOffset);\n      } catch (e2) {}\n      try {\n        this.setSelection(newRange);\n      } catch (e3) {}\n    },\n\n    /**\n     * Insert html at the caret position and move the cursor after the inserted html\n     *\n     * @param {String} html HTML string to insert\n     * @example\n     *    selection.insertHTML(\"<p>foobar</p>\");\n     */\n    insertHTML: function insertHTML(html) {\n      var range = rangy.createRange(this.doc),\n          node = range.createContextualFragment(html),\n          lastChild = node.lastChild;\n      this.insertNode(node);\n      if (lastChild) {\n        this.setAfter(lastChild);\n      }\n    },\n\n    /**\n     * Insert a node at the caret position and move the cursor behind it\n     *\n     * @param {Object} node HTML string to insert\n     * @example\n     *    selection.insertNode(document.createTextNode(\"foobar\"));\n     */\n    insertNode: function insertNode(node) {\n      var range = this.getRange();\n      if (range) {\n        range.insertNode(node);\n      }\n    },\n\n    /**\n     * Wraps current selection with the given node\n     *\n     * @param {Object} node The node to surround the selected elements with\n     */\n    surround: function surround(node) {\n      var range = this.getRange();\n      if (!range) {\n        return;\n      }\n\n      try {\n        // This only works when the range boundaries are not overlapping other elements\n        range.surroundContents(node);\n        this.selectNode(node);\n      } catch (e) {\n        // fallback\n        node.appendChild(range.extractContents());\n        range.insertNode(node);\n      }\n    },\n\n    /**\n     * Scroll the current caret position into the view\n     * FIXME: This is a bit hacky, there might be a smarter way of doing this\n     *\n     * @example\n     *    selection.scrollIntoView();\n     */\n    scrollIntoView: function scrollIntoView() {\n      var doc = this.doc,\n          hasScrollBars = doc.documentElement.scrollHeight > doc.documentElement.offsetHeight,\n          tempElement = doc._wysihtml5ScrollIntoViewElement = doc._wysihtml5ScrollIntoViewElement || function () {\n        var element = doc.createElement(\"span\");\n        // The element needs content in order to be able to calculate it's position properly\n        element.innerHTML = wysihtml5.INVISIBLE_SPACE;\n        return element;\n      }(),\n          offsetTop;\n\n      if (hasScrollBars) {\n        this.insertNode(tempElement);\n        offsetTop = _getCumulativeOffsetTop(tempElement);\n        tempElement.parentNode.removeChild(tempElement);\n        if (offsetTop > doc.body.scrollTop) {\n          doc.body.scrollTop = offsetTop;\n        }\n      }\n    },\n\n    /**\n     * Select line where the caret is in\n     */\n    selectLine: function selectLine() {\n      if (wysihtml5.browser.supportsSelectionModify()) {\n        this._selectLine_W3C();\n      } else if (this.doc.selection) {\n        this._selectLine_MSIE();\n      }\n    },\n\n    /**\n     * See https://developer.mozilla.org/en/DOM/Selection/modify\n     */\n    _selectLine_W3C: function _selectLine_W3C() {\n      var win = this.doc.defaultView,\n          selection = win.getSelection();\n      selection.modify(\"extend\", \"left\", \"lineboundary\");\n      selection.modify(\"extend\", \"right\", \"lineboundary\");\n    },\n\n    _selectLine_MSIE: function _selectLine_MSIE() {\n      var range = this.doc.selection.createRange(),\n          rangeTop = range.boundingTop,\n          rangeHeight = range.boundingHeight,\n          scrollWidth = this.doc.body.scrollWidth,\n          rangeBottom,\n          rangeEnd,\n          measureNode,\n          i,\n          j;\n\n      if (!range.moveToPoint) {\n        return;\n      }\n\n      if (rangeTop === 0) {\n        // Don't know why, but when the selection ends at the end of a line\n        // range.boundingTop is 0\n        measureNode = this.doc.createElement(\"span\");\n        this.insertNode(measureNode);\n        rangeTop = measureNode.offsetTop;\n        measureNode.parentNode.removeChild(measureNode);\n      }\n\n      rangeTop += 1;\n\n      for (i = -10; i < scrollWidth; i += 2) {\n        try {\n          range.moveToPoint(i, rangeTop);\n          break;\n        } catch (e1) {}\n      }\n\n      // Investigate the following in order to handle multi line selections\n      // rangeBottom = rangeTop + (rangeHeight ? (rangeHeight - 1) : 0);\n      rangeBottom = rangeTop;\n      rangeEnd = this.doc.selection.createRange();\n      for (j = scrollWidth; j >= 0; j--) {\n        try {\n          rangeEnd.moveToPoint(j, rangeBottom);\n          break;\n        } catch (e2) {}\n      }\n\n      range.setEndPoint(\"EndToEnd\", rangeEnd);\n      range.select();\n    },\n\n    getText: function getText() {\n      var selection = this.getSelection();\n      return selection ? selection.toString() : \"\";\n    },\n\n    getNodes: function getNodes(nodeType, filter) {\n      var range = this.getRange();\n      if (range) {\n        return range.getNodes([nodeType], filter);\n      } else {\n        return [];\n      }\n    },\n\n    getRange: function getRange() {\n      var selection = this.getSelection();\n      return selection && selection.rangeCount && selection.getRangeAt(0);\n    },\n\n    getSelection: function getSelection() {\n      return rangy.getSelection(this.doc.defaultView || this.doc.parentWindow);\n    },\n\n    setSelection: function setSelection(range) {\n      var win = this.doc.defaultView || this.doc.parentWindow,\n          selection = rangy.getSelection(win);\n      return selection.setSingleRange(range);\n    }\n  });\n})(wysihtml5);\n/**\n * Inspired by the rangy CSS Applier module written by Tim Down and licensed under the MIT license.\n * http://code.google.com/p/rangy/\n *\n * changed in order to be able ...\n *    - to use custom tags\n *    - to detect and replace similar css classes via reg exp\n */\n(function (wysihtml5, rangy) {\n  var defaultTagName = \"span\";\n\n  var REG_EXP_WHITE_SPACE = /\\s+/g;\n\n  function hasClass(el, cssClass, regExp) {\n    if (!el.className) {\n      return false;\n    }\n\n    var matchingClassNames = el.className.match(regExp) || [];\n    return matchingClassNames[matchingClassNames.length - 1] === cssClass;\n  }\n\n  function addClass(el, cssClass, regExp) {\n    if (el.className) {\n      removeClass(el, regExp);\n      el.className += \" \" + cssClass;\n    } else {\n      el.className = cssClass;\n    }\n  }\n\n  function removeClass(el, regExp) {\n    if (el.className) {\n      el.className = el.className.replace(regExp, \"\");\n    }\n  }\n\n  function hasSameClasses(el1, el2) {\n    return el1.className.replace(REG_EXP_WHITE_SPACE, \" \") == el2.className.replace(REG_EXP_WHITE_SPACE, \" \");\n  }\n\n  function replaceWithOwnChildren(el) {\n    var parent = el.parentNode;\n    while (el.firstChild) {\n      parent.insertBefore(el.firstChild, el);\n    }\n    parent.removeChild(el);\n  }\n\n  function elementsHaveSameNonClassAttributes(el1, el2) {\n    if (el1.attributes.length != el2.attributes.length) {\n      return false;\n    }\n    for (var i = 0, len = el1.attributes.length, attr1, attr2, name; i < len; ++i) {\n      attr1 = el1.attributes[i];\n      name = attr1.name;\n      if (name != \"class\") {\n        attr2 = el2.attributes.getNamedItem(name);\n        if (attr1.specified != attr2.specified) {\n          return false;\n        }\n        if (attr1.specified && attr1.nodeValue !== attr2.nodeValue) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  function isSplitPoint(node, offset) {\n    if (rangy.dom.isCharacterDataNode(node)) {\n      if (offset == 0) {\n        return !!node.previousSibling;\n      } else if (offset == node.length) {\n        return !!node.nextSibling;\n      } else {\n        return true;\n      }\n    }\n\n    return offset > 0 && offset < node.childNodes.length;\n  }\n\n  function splitNodeAt(node, descendantNode, descendantOffset) {\n    var newNode;\n    if (rangy.dom.isCharacterDataNode(descendantNode)) {\n      if (descendantOffset == 0) {\n        descendantOffset = rangy.dom.getNodeIndex(descendantNode);\n        descendantNode = descendantNode.parentNode;\n      } else if (descendantOffset == descendantNode.length) {\n        descendantOffset = rangy.dom.getNodeIndex(descendantNode) + 1;\n        descendantNode = descendantNode.parentNode;\n      } else {\n        newNode = rangy.dom.splitDataNode(descendantNode, descendantOffset);\n      }\n    }\n    if (!newNode) {\n      newNode = descendantNode.cloneNode(false);\n      if (newNode.id) {\n        newNode.removeAttribute(\"id\");\n      }\n      var child;\n      while (child = descendantNode.childNodes[descendantOffset]) {\n        newNode.appendChild(child);\n      }\n      rangy.dom.insertAfter(newNode, descendantNode);\n    }\n    return descendantNode == node ? newNode : splitNodeAt(node, newNode.parentNode, rangy.dom.getNodeIndex(newNode));\n  }\n\n  function Merge(firstNode) {\n    this.isElementMerge = firstNode.nodeType == wysihtml5.ELEMENT_NODE;\n    this.firstTextNode = this.isElementMerge ? firstNode.lastChild : firstNode;\n    this.textNodes = [this.firstTextNode];\n  }\n\n  Merge.prototype = {\n    doMerge: function doMerge() {\n      var textBits = [],\n          textNode,\n          parent,\n          text;\n      for (var i = 0, len = this.textNodes.length; i < len; ++i) {\n        textNode = this.textNodes[i];\n        parent = textNode.parentNode;\n        textBits[i] = textNode.data;\n        if (i) {\n          parent.removeChild(textNode);\n          if (!parent.hasChildNodes()) {\n            parent.parentNode.removeChild(parent);\n          }\n        }\n      }\n      this.firstTextNode.data = text = textBits.join(\"\");\n      return text;\n    },\n\n    getLength: function getLength() {\n      var i = this.textNodes.length,\n          len = 0;\n      while (i--) {\n        len += this.textNodes[i].length;\n      }\n      return len;\n    },\n\n    toString: function toString() {\n      var textBits = [];\n      for (var i = 0, len = this.textNodes.length; i < len; ++i) {\n        textBits[i] = \"'\" + this.textNodes[i].data + \"'\";\n      }\n      return \"[Merge(\" + textBits.join(\",\") + \")]\";\n    }\n  };\n\n  function HTMLApplier(tagNames, cssClass, similarClassRegExp, normalize) {\n    this.tagNames = tagNames || [defaultTagName];\n    this.cssClass = cssClass || \"\";\n    this.similarClassRegExp = similarClassRegExp;\n    this.normalize = normalize;\n    this.applyToAnyTagName = false;\n  }\n\n  HTMLApplier.prototype = {\n    getAncestorWithClass: function getAncestorWithClass(node) {\n      var cssClassMatch;\n      while (node) {\n        cssClassMatch = this.cssClass ? hasClass(node, this.cssClass, this.similarClassRegExp) : true;\n        if (node.nodeType == wysihtml5.ELEMENT_NODE && rangy.dom.arrayContains(this.tagNames, node.tagName.toLowerCase()) && cssClassMatch) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return false;\n    },\n\n    // Normalizes nodes after applying a CSS class to a Range.\n    postApply: function postApply(textNodes, range) {\n      var firstNode = textNodes[0],\n          lastNode = textNodes[textNodes.length - 1];\n\n      var merges = [],\n          currentMerge;\n\n      var rangeStartNode = firstNode,\n          rangeEndNode = lastNode;\n      var rangeStartOffset = 0,\n          rangeEndOffset = lastNode.length;\n\n      var textNode, precedingTextNode;\n\n      for (var i = 0, len = textNodes.length; i < len; ++i) {\n        textNode = textNodes[i];\n        precedingTextNode = this.getAdjacentMergeableTextNode(textNode.parentNode, false);\n        if (precedingTextNode) {\n          if (!currentMerge) {\n            currentMerge = new Merge(precedingTextNode);\n            merges.push(currentMerge);\n          }\n          currentMerge.textNodes.push(textNode);\n          if (textNode === firstNode) {\n            rangeStartNode = currentMerge.firstTextNode;\n            rangeStartOffset = rangeStartNode.length;\n          }\n          if (textNode === lastNode) {\n            rangeEndNode = currentMerge.firstTextNode;\n            rangeEndOffset = currentMerge.getLength();\n          }\n        } else {\n          currentMerge = null;\n        }\n      }\n\n      // Test whether the first node after the range needs merging\n      var nextTextNode = this.getAdjacentMergeableTextNode(lastNode.parentNode, true);\n      if (nextTextNode) {\n        if (!currentMerge) {\n          currentMerge = new Merge(lastNode);\n          merges.push(currentMerge);\n        }\n        currentMerge.textNodes.push(nextTextNode);\n      }\n\n      // Do the merges\n      if (merges.length) {\n        for (i = 0, len = merges.length; i < len; ++i) {\n          merges[i].doMerge();\n        }\n        // Set the range boundaries\n        range.setStart(rangeStartNode, rangeStartOffset);\n        range.setEnd(rangeEndNode, rangeEndOffset);\n      }\n    },\n\n    getAdjacentMergeableTextNode: function getAdjacentMergeableTextNode(node, forward) {\n      var isTextNode = node.nodeType == wysihtml5.TEXT_NODE;\n      var el = isTextNode ? node.parentNode : node;\n      var adjacentNode;\n      var propName = forward ? \"nextSibling\" : \"previousSibling\";\n      if (isTextNode) {\n        // Can merge if the node's previous/next sibling is a text node\n        adjacentNode = node[propName];\n        if (adjacentNode && adjacentNode.nodeType == wysihtml5.TEXT_NODE) {\n          return adjacentNode;\n        }\n      } else {\n        // Compare element with its sibling\n        adjacentNode = el[propName];\n        if (adjacentNode && this.areElementsMergeable(node, adjacentNode)) {\n          return adjacentNode[forward ? \"firstChild\" : \"lastChild\"];\n        }\n      }\n      return null;\n    },\n\n    areElementsMergeable: function areElementsMergeable(el1, el2) {\n      return rangy.dom.arrayContains(this.tagNames, (el1.tagName || \"\").toLowerCase()) && rangy.dom.arrayContains(this.tagNames, (el2.tagName || \"\").toLowerCase()) && hasSameClasses(el1, el2) && elementsHaveSameNonClassAttributes(el1, el2);\n    },\n\n    createContainer: function createContainer(doc) {\n      var el = doc.createElement(this.tagNames[0]);\n      if (this.cssClass) {\n        el.className = this.cssClass;\n      }\n      return el;\n    },\n\n    applyToTextNode: function applyToTextNode(textNode) {\n      var parent = textNode.parentNode;\n      if (parent.childNodes.length == 1 && rangy.dom.arrayContains(this.tagNames, parent.tagName.toLowerCase())) {\n        if (this.cssClass) {\n          addClass(parent, this.cssClass, this.similarClassRegExp);\n        }\n      } else {\n        var el = this.createContainer(rangy.dom.getDocument(textNode));\n        textNode.parentNode.insertBefore(el, textNode);\n        el.appendChild(textNode);\n      }\n    },\n\n    isRemovable: function isRemovable(el) {\n      return rangy.dom.arrayContains(this.tagNames, el.tagName.toLowerCase()) && wysihtml5.lang.string(el.className).trim() == this.cssClass;\n    },\n\n    undoToTextNode: function undoToTextNode(textNode, range, ancestorWithClass) {\n      if (!range.containsNode(ancestorWithClass)) {\n        // Split out the portion of the ancestor from which we can remove the CSS class\n        var ancestorRange = range.cloneRange();\n        ancestorRange.selectNode(ancestorWithClass);\n\n        if (ancestorRange.isPointInRange(range.endContainer, range.endOffset) && isSplitPoint(range.endContainer, range.endOffset)) {\n          splitNodeAt(ancestorWithClass, range.endContainer, range.endOffset);\n          range.setEndAfter(ancestorWithClass);\n        }\n        if (ancestorRange.isPointInRange(range.startContainer, range.startOffset) && isSplitPoint(range.startContainer, range.startOffset)) {\n          ancestorWithClass = splitNodeAt(ancestorWithClass, range.startContainer, range.startOffset);\n        }\n      }\n\n      if (this.similarClassRegExp) {\n        removeClass(ancestorWithClass, this.similarClassRegExp);\n      }\n      if (this.isRemovable(ancestorWithClass)) {\n        replaceWithOwnChildren(ancestorWithClass);\n      }\n    },\n\n    applyToRange: function applyToRange(range) {\n      var textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n      if (!textNodes.length) {\n        try {\n          var node = this.createContainer(range.endContainer.ownerDocument);\n          range.surroundContents(node);\n          this.selectNode(range, node);\n          return;\n        } catch (e) {}\n      }\n\n      range.splitBoundaries();\n      textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n\n      if (textNodes.length) {\n        var textNode;\n\n        for (var i = 0, len = textNodes.length; i < len; ++i) {\n          textNode = textNodes[i];\n          if (!this.getAncestorWithClass(textNode)) {\n            this.applyToTextNode(textNode);\n          }\n        }\n\n        range.setStart(textNodes[0], 0);\n        textNode = textNodes[textNodes.length - 1];\n        range.setEnd(textNode, textNode.length);\n\n        if (this.normalize) {\n          this.postApply(textNodes, range);\n        }\n      }\n    },\n\n    undoToRange: function undoToRange(range) {\n      var textNodes = range.getNodes([wysihtml5.TEXT_NODE]),\n          textNode,\n          ancestorWithClass;\n      if (textNodes.length) {\n        range.splitBoundaries();\n        textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n      } else {\n        var doc = range.endContainer.ownerDocument,\n            node = doc.createTextNode(wysihtml5.INVISIBLE_SPACE);\n        range.insertNode(node);\n        range.selectNode(node);\n        textNodes = [node];\n      }\n\n      for (var i = 0, len = textNodes.length; i < len; ++i) {\n        textNode = textNodes[i];\n        ancestorWithClass = this.getAncestorWithClass(textNode);\n        if (ancestorWithClass) {\n          this.undoToTextNode(textNode, range, ancestorWithClass);\n        }\n      }\n\n      if (len == 1) {\n        this.selectNode(range, textNodes[0]);\n      } else {\n        range.setStart(textNodes[0], 0);\n        textNode = textNodes[textNodes.length - 1];\n        range.setEnd(textNode, textNode.length);\n\n        if (this.normalize) {\n          this.postApply(textNodes, range);\n        }\n      }\n    },\n\n    selectNode: function selectNode(range, node) {\n      var isElement = node.nodeType === wysihtml5.ELEMENT_NODE,\n          canHaveHTML = \"canHaveHTML\" in node ? node.canHaveHTML : true,\n          content = isElement ? node.innerHTML : node.data,\n          isEmpty = content === \"\" || content === wysihtml5.INVISIBLE_SPACE;\n\n      if (isEmpty && isElement && canHaveHTML) {\n        // Make sure that caret is visible in node by inserting a zero width no breaking space\n        try {\n          node.innerHTML = wysihtml5.INVISIBLE_SPACE;\n        } catch (e) {}\n      }\n      range.selectNodeContents(node);\n      if (isEmpty && isElement) {\n        range.collapse(false);\n      } else if (isEmpty) {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n    },\n\n    getTextSelectedByRange: function getTextSelectedByRange(textNode, range) {\n      var textRange = range.cloneRange();\n      textRange.selectNodeContents(textNode);\n\n      var intersectionRange = textRange.intersection(range);\n      var text = intersectionRange ? intersectionRange.toString() : \"\";\n      textRange.detach();\n\n      return text;\n    },\n\n    isAppliedToRange: function isAppliedToRange(range) {\n      var ancestors = [],\n          ancestor,\n          textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n      if (!textNodes.length) {\n        ancestor = this.getAncestorWithClass(range.startContainer);\n        return ancestor ? [ancestor] : false;\n      }\n\n      for (var i = 0, len = textNodes.length, selectedText; i < len; ++i) {\n        selectedText = this.getTextSelectedByRange(textNodes[i], range);\n        ancestor = this.getAncestorWithClass(textNodes[i]);\n        if (selectedText != \"\" && !ancestor) {\n          return false;\n        } else {\n          ancestors.push(ancestor);\n        }\n      }\n      return ancestors;\n    },\n\n    toggleRange: function toggleRange(range) {\n      if (this.isAppliedToRange(range)) {\n        this.undoToRange(range);\n      } else {\n        this.applyToRange(range);\n      }\n    }\n  };\n\n  wysihtml5.selection.HTMLApplier = HTMLApplier;\n})(wysihtml5, rangy); /**\n                      * Rich Text Query/Formatting Commands\n                      * \n                      * @example\n                      *    var commands = new wysihtml5.Commands(editor);\n                      */\nwysihtml5.Commands = Base.extend(\n/** @scope wysihtml5.Commands.prototype */{\n  constructor: function constructor(editor) {\n    this.editor = editor;\n    this.composer = editor.composer;\n    this.doc = this.composer.doc;\n  },\n\n  /**\n   * Check whether the browser supports the given command\n   *\n   * @param {String} command The command string which to check (eg. \"bold\", \"italic\", \"insertUnorderedList\")\n   * @example\n   *    commands.supports(\"createLink\");\n   */\n  support: function support(command) {\n    return wysihtml5.browser.supportsCommand(this.doc, command);\n  },\n\n  /**\n   * Check whether the browser supports the given command\n   *\n   * @param {String} command The command string which to execute (eg. \"bold\", \"italic\", \"insertUnorderedList\")\n   * @param {String} [value] The command value parameter, needed for some commands (\"createLink\", \"insertImage\", ...), optional for commands that don't require one (\"bold\", \"underline\", ...)\n   * @example\n   *    commands.exec(\"insertImage\", \"http://a1.twimg.com/profile_images/113868655/schrei_twitter_reasonably_small.jpg\");\n   */\n  exec: function exec(command, value) {\n    var obj = wysihtml5.commands[command],\n        args = wysihtml5.lang.array(arguments).get(),\n        method = obj && obj.exec,\n        result = null;\n\n    this.editor.fire(\"beforecommand:composer\");\n\n    if (method) {\n      args.unshift(this.composer);\n      result = method.apply(obj, args);\n    } else {\n      try {\n        // try/catch for buggy firefox\n        result = this.doc.execCommand(command, false, value);\n      } catch (e) {}\n    }\n\n    this.editor.fire(\"aftercommand:composer\");\n    return result;\n  },\n\n  /**\n   * Check whether the current command is active\n   * If the caret is within a bold text, then calling this with command \"bold\" should return true\n   *\n   * @param {String} command The command string which to check (eg. \"bold\", \"italic\", \"insertUnorderedList\")\n   * @param {String} [commandValue] The command value parameter (eg. for \"insertImage\" the image src)\n   * @return {Boolean} Whether the command is active\n   * @example\n   *    var isCurrentSelectionBold = commands.state(\"bold\");\n   */\n  state: function state(command, commandValue) {\n    var obj = wysihtml5.commands[command],\n        args = wysihtml5.lang.array(arguments).get(),\n        method = obj && obj.state;\n    if (method) {\n      args.unshift(this.composer);\n      return method.apply(obj, args);\n    } else {\n      try {\n        // try/catch for buggy firefox\n        return this.doc.queryCommandState(command);\n      } catch (e) {\n        return false;\n      }\n    }\n  },\n\n  /**\n   * Get the current command's value\n   *\n   * @param {String} command The command string which to check (eg. \"formatBlock\")\n   * @return {String} The command value\n   * @example\n   *    var currentBlockElement = commands.value(\"formatBlock\");\n   */\n  value: function value(command) {\n    var obj = wysihtml5.commands[command],\n        method = obj && obj.value;\n    if (method) {\n      return method.call(obj, this.composer, command);\n    } else {\n      try {\n        // try/catch for buggy firefox\n        return this.doc.queryCommandValue(command);\n      } catch (e) {\n        return null;\n      }\n    }\n  }\n});\n(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.bold = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatInline.exec(composer, command, \"b\");\n    },\n\n    state: function state(composer, command, color) {\n      // element.ownerDocument.queryCommandState(\"bold\") results:\n      // firefox: only <b>\n      // chrome:  <b>, <strong>, <h1>, <h2>, ...\n      // ie:      <b>, <strong>\n      // opera:   <b>, <strong>\n      return wysihtml5.commands.formatInline.state(composer, command, \"b\");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);\n\n(function (wysihtml5) {\n  var undef,\n      NODE_NAME = \"A\",\n      dom = wysihtml5.dom;\n\n  function _removeFormat(composer, anchors) {\n    var length = anchors.length,\n        i = 0,\n        anchor,\n        codeElement,\n        textContent;\n    for (; i < length; i++) {\n      anchor = anchors[i];\n      codeElement = dom.getParentElement(anchor, { nodeName: \"code\" });\n      textContent = dom.getTextContent(anchor);\n\n      // if <a> contains url-like text content, rename it to <code> to prevent re-autolinking\n      // else replace <a> with its childNodes\n      if (textContent.match(dom.autoLink.URL_REG_EXP) && !codeElement) {\n        // <code> element is used to prevent later auto-linking of the content\n        codeElement = dom.renameElement(anchor, \"code\");\n      } else {\n        dom.replaceWithChildNodes(anchor);\n      }\n    }\n  }\n\n  function _format(composer, attributes) {\n    var doc = composer.doc,\n        tempClass = \"_wysihtml5-temp-\" + +new Date(),\n        tempClassRegExp = /non-matching-class/g,\n        i = 0,\n        length,\n        anchors,\n        anchor,\n        hasElementChild,\n        isEmpty,\n        elementToSetCaretAfter,\n        textContent,\n        whiteSpace,\n        j;\n    wysihtml5.commands.formatInline.exec(composer, undef, NODE_NAME, tempClass, tempClassRegExp);\n    anchors = doc.querySelectorAll(NODE_NAME + \".\" + tempClass);\n    length = anchors.length;\n    for (; i < length; i++) {\n      anchor = anchors[i];\n      anchor.removeAttribute(\"class\");\n      for (j in attributes) {\n        anchor.setAttribute(j, attributes[j]);\n      }\n    }\n\n    elementToSetCaretAfter = anchor;\n    if (length === 1) {\n      textContent = dom.getTextContent(anchor);\n      hasElementChild = !!anchor.querySelector(\"*\");\n      isEmpty = textContent === \"\" || textContent === wysihtml5.INVISIBLE_SPACE;\n      if (!hasElementChild && isEmpty) {\n        dom.setTextContent(anchor, attributes.text || anchor.href);\n        whiteSpace = doc.createTextNode(\" \");\n        composer.selection.setAfter(anchor);\n        composer.selection.insertNode(whiteSpace);\n        elementToSetCaretAfter = whiteSpace;\n      }\n    }\n    composer.selection.setAfter(elementToSetCaretAfter);\n  }\n\n  wysihtml5.commands.createLink = {\n    /**\n     * TODO: Use HTMLApplier or formatInline here\n     *\n     * Turns selection into a link\n     * If selection is already a link, it removes the link and wraps it with a <code> element\n     * The <code> element is needed to avoid auto linking\n     * \n     * @example\n     *    // either ...\n     *    wysihtml5.commands.createLink.exec(composer, \"createLink\", \"http://www.google.de\");\n     *    // ... or ...\n     *    wysihtml5.commands.createLink.exec(composer, \"createLink\", { href: \"http://www.google.de\", target: \"_blank\" });\n     */\n    exec: function exec(composer, command, value) {\n      var anchors = this.state(composer, command);\n      if (anchors) {\n        // Selection contains links\n        composer.selection.executeAndRestore(function () {\n          _removeFormat(composer, anchors);\n        });\n      } else {\n        // Create links\n        value = (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? value : { href: value };\n        _format(composer, value);\n      }\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatInline.state(composer, command, \"A\");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5); /**\n               * document.execCommand(\"fontSize\") will create either inline styles (firefox, chrome) or use font tags\n               * which we don't want\n               * Instead we set a css class\n               */\n(function (wysihtml5) {\n  var undef,\n      REG_EXP = /wysiwyg-font-size-[a-z\\-]+/g;\n\n  wysihtml5.commands.fontSize = {\n    exec: function exec(composer, command, size) {\n      return wysihtml5.commands.formatInline.exec(composer, command, \"span\", \"wysiwyg-font-size-\" + size, REG_EXP);\n    },\n\n    state: function state(composer, command, size) {\n      return wysihtml5.commands.formatInline.state(composer, command, \"span\", \"wysiwyg-font-size-\" + size, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);\n/**\n * document.execCommand(\"foreColor\") will create either inline styles (firefox, chrome) or use font tags\n * which we don't want\n * Instead we set a css class\n */\n(function (wysihtml5) {\n  var undef,\n      REG_EXP = /wysiwyg-color-[a-z]+/g;\n\n  wysihtml5.commands.foreColor = {\n    exec: function exec(composer, command, color) {\n      return wysihtml5.commands.formatInline.exec(composer, command, \"span\", \"wysiwyg-color-\" + color, REG_EXP);\n    },\n\n    state: function state(composer, command, color) {\n      return wysihtml5.commands.formatInline.state(composer, command, \"span\", \"wysiwyg-color-\" + color, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      dom = wysihtml5.dom,\n      DEFAULT_NODE_NAME = \"DIV\",\n\n  // Following elements are grouped\n  // when the caret is within a H1 and the H4 is invoked, the H1 should turn into H4\n  // instead of creating a H4 within a H1 which would result in semantically invalid html\n  BLOCK_ELEMENTS_GROUP = [\"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\", \"P\", \"BLOCKQUOTE\", DEFAULT_NODE_NAME];\n\n  /**\n   * Remove similiar classes (based on classRegExp)\n   * and add the desired class name\n   */\n  function _addClass(element, className, classRegExp) {\n    if (element.className) {\n      _removeClass(element, classRegExp);\n      element.className += \" \" + className;\n    } else {\n      element.className = className;\n    }\n  }\n\n  function _removeClass(element, classRegExp) {\n    element.className = element.className.replace(classRegExp, \"\");\n  }\n\n  /**\n   * Check whether given node is a text node and whether it's empty\n   */\n  function _isBlankTextNode(node) {\n    return node.nodeType === wysihtml5.TEXT_NODE && !wysihtml5.lang.string(node.data).trim();\n  }\n\n  /**\n   * Returns previous sibling node that is not a blank text node\n   */\n  function _getPreviousSiblingThatIsNotBlank(node) {\n    var previousSibling = node.previousSibling;\n    while (previousSibling && _isBlankTextNode(previousSibling)) {\n      previousSibling = previousSibling.previousSibling;\n    }\n    return previousSibling;\n  }\n\n  /**\n   * Returns next sibling node that is not a blank text node\n   */\n  function _getNextSiblingThatIsNotBlank(node) {\n    var nextSibling = node.nextSibling;\n    while (nextSibling && _isBlankTextNode(nextSibling)) {\n      nextSibling = nextSibling.nextSibling;\n    }\n    return nextSibling;\n  }\n\n  /**\n   * Adds line breaks before and after the given node if the previous and next siblings\n   * aren't already causing a visual line break (block element or <br>)\n   */\n  function _addLineBreakBeforeAndAfter(node) {\n    var doc = node.ownerDocument,\n        nextSibling = _getNextSiblingThatIsNotBlank(node),\n        previousSibling = _getPreviousSiblingThatIsNotBlank(node);\n\n    if (nextSibling && !_isLineBreakOrBlockElement(nextSibling)) {\n      node.parentNode.insertBefore(doc.createElement(\"br\"), nextSibling);\n    }\n    if (previousSibling && !_isLineBreakOrBlockElement(previousSibling)) {\n      node.parentNode.insertBefore(doc.createElement(\"br\"), node);\n    }\n  }\n\n  /**\n   * Removes line breaks before and after the given node\n   */\n  function _removeLineBreakBeforeAndAfter(node) {\n    var nextSibling = _getNextSiblingThatIsNotBlank(node),\n        previousSibling = _getPreviousSiblingThatIsNotBlank(node);\n\n    if (nextSibling && _isLineBreak(nextSibling)) {\n      nextSibling.parentNode.removeChild(nextSibling);\n    }\n    if (previousSibling && _isLineBreak(previousSibling)) {\n      previousSibling.parentNode.removeChild(previousSibling);\n    }\n  }\n\n  function _removeLastChildIfLineBreak(node) {\n    var lastChild = node.lastChild;\n    if (lastChild && _isLineBreak(lastChild)) {\n      lastChild.parentNode.removeChild(lastChild);\n    }\n  }\n\n  function _isLineBreak(node) {\n    return node.nodeName === \"BR\";\n  }\n\n  /**\n   * Checks whether the elment causes a visual line break\n   * (<br> or block elements)\n   */\n  function _isLineBreakOrBlockElement(element) {\n    if (_isLineBreak(element)) {\n      return true;\n    }\n\n    if (dom.getStyle(\"display\").from(element) === \"block\") {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Execute native query command\n   * and if necessary modify the inserted node's className\n   */\n  function _execCommand(doc, command, nodeName, className) {\n    if (className) {\n      var eventListener = dom.observe(doc, \"DOMNodeInserted\", function (event) {\n        var target = event.target,\n            displayStyle;\n        if (target.nodeType !== wysihtml5.ELEMENT_NODE) {\n          return;\n        }\n        displayStyle = dom.getStyle(\"display\").from(target);\n        if (displayStyle.substr(0, 6) !== \"inline\") {\n          // Make sure that only block elements receive the given class\n          target.className += \" \" + className;\n        }\n      });\n    }\n    doc.execCommand(command, false, nodeName);\n    if (eventListener) {\n      eventListener.stop();\n    }\n  }\n\n  function _selectLineAndWrap(composer, element) {\n    composer.selection.selectLine();\n    composer.selection.surround(element);\n    _removeLineBreakBeforeAndAfter(element);\n    _removeLastChildIfLineBreak(element);\n    composer.selection.selectNode(element);\n  }\n\n  function _hasClasses(element) {\n    return !!wysihtml5.lang.string(element.className).trim();\n  }\n\n  wysihtml5.commands.formatBlock = {\n    exec: function exec(composer, command, nodeName, className, classRegExp) {\n      var doc = composer.doc,\n          blockElement = this.state(composer, command, nodeName, className, classRegExp),\n          selectedNode;\n\n      nodeName = typeof nodeName === \"string\" ? nodeName.toUpperCase() : nodeName;\n\n      if (blockElement) {\n        composer.selection.executeAndRestoreSimple(function () {\n          if (classRegExp) {\n            _removeClass(blockElement, classRegExp);\n          }\n          var hasClasses = _hasClasses(blockElement);\n          if (!hasClasses && blockElement.nodeName === (nodeName || DEFAULT_NODE_NAME)) {\n            // Insert a line break afterwards and beforewards when there are siblings\n            // that are not of type line break or block element\n            _addLineBreakBeforeAndAfter(blockElement);\n            dom.replaceWithChildNodes(blockElement);\n          } else if (hasClasses) {\n            // Make sure that styling is kept by renaming the element to <div> and copying over the class name\n            dom.renameElement(blockElement, DEFAULT_NODE_NAME);\n          }\n        });\n        return;\n      }\n\n      // Find similiar block element and rename it (<h2 class=\"foo\"></h2>  =>  <h1 class=\"foo\"></h1>)\n      if (nodeName === null || wysihtml5.lang.array(BLOCK_ELEMENTS_GROUP).contains(nodeName)) {\n        selectedNode = composer.selection.getSelectedNode();\n        blockElement = dom.getParentElement(selectedNode, {\n          nodeName: BLOCK_ELEMENTS_GROUP\n        });\n\n        if (blockElement) {\n          composer.selection.executeAndRestoreSimple(function () {\n            // Rename current block element to new block element and add class\n            if (nodeName) {\n              blockElement = dom.renameElement(blockElement, nodeName);\n            }\n            if (className) {\n              _addClass(blockElement, className, classRegExp);\n            }\n          });\n          return;\n        }\n      }\n\n      if (composer.commands.support(command)) {\n        _execCommand(doc, command, nodeName || DEFAULT_NODE_NAME, className);\n        return;\n      }\n\n      blockElement = doc.createElement(nodeName || DEFAULT_NODE_NAME);\n      if (className) {\n        blockElement.className = className;\n      }\n      _selectLineAndWrap(composer, blockElement);\n    },\n\n    state: function state(composer, command, nodeName, className, classRegExp) {\n      nodeName = typeof nodeName === \"string\" ? nodeName.toUpperCase() : nodeName;\n      var selectedNode = composer.selection.getSelectedNode();\n      return dom.getParentElement(selectedNode, {\n        nodeName: nodeName,\n        className: className,\n        classRegExp: classRegExp\n      });\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5); /**\n               * formatInline scenarios for tag \"B\" (| = caret, |foo| = selected text)\n               *\n               *   #1 caret in unformatted text:\n               *      abcdefg|\n               *   output:\n               *      abcdefg<b>|</b>\n               *   \n               *   #2 unformatted text selected:\n               *      abc|deg|h\n               *   output:\n               *      abc<b>|deg|</b>h\n               *   \n               *   #3 unformatted text selected across boundaries:\n               *      ab|c <span>defg|h</span>\n               *   output:\n               *      ab<b>|c </b><span><b>defg</b>|h</span>\n               *\n               *   #4 formatted text entirely selected\n               *      <b>|abc|</b>\n               *   output:\n               *      |abc|\n               *\n               *   #5 formatted text partially selected\n               *      <b>ab|c|</b>\n               *   output:\n               *      <b>ab</b>|c|\n               *\n               *   #6 formatted text selected across boundaries\n               *      <span>ab|c</span> <b>de|fgh</b>\n               *   output:\n               *      <span>ab|c</span> de|<b>fgh</b>\n               */\n(function (wysihtml5) {\n  var undef,\n\n  // Treat <b> as <strong> and vice versa\n  ALIAS_MAPPING = {\n    \"strong\": \"b\",\n    \"em\": \"i\",\n    \"b\": \"strong\",\n    \"i\": \"em\"\n  },\n      htmlApplier = {};\n\n  function _getTagNames(tagName) {\n    var alias = ALIAS_MAPPING[tagName];\n    return alias ? [tagName.toLowerCase(), alias.toLowerCase()] : [tagName.toLowerCase()];\n  }\n\n  function _getApplier(tagName, className, classRegExp) {\n    var identifier = tagName + \":\" + className;\n    if (!htmlApplier[identifier]) {\n      htmlApplier[identifier] = new wysihtml5.selection.HTMLApplier(_getTagNames(tagName), className, classRegExp, true);\n    }\n    return htmlApplier[identifier];\n  }\n\n  wysihtml5.commands.formatInline = {\n    exec: function exec(composer, command, tagName, className, classRegExp) {\n      var range = composer.selection.getRange();\n      if (!range) {\n        return false;\n      }\n      _getApplier(tagName, className, classRegExp).toggleRange(range);\n      composer.selection.setSelection(range);\n    },\n\n    state: function state(composer, command, tagName, className, classRegExp) {\n      var doc = composer.doc,\n          aliasTagName = ALIAS_MAPPING[tagName] || tagName,\n          range;\n\n      // Check whether the document contains a node with the desired tagName\n      if (!wysihtml5.dom.hasElementWithTagName(doc, tagName) && !wysihtml5.dom.hasElementWithTagName(doc, aliasTagName)) {\n        return false;\n      }\n\n      // Check whether the document contains a node with the desired className\n      if (className && !wysihtml5.dom.hasElementWithClassName(doc, className)) {\n        return false;\n      }\n\n      range = composer.selection.getRange();\n      if (!range) {\n        return false;\n      }\n\n      return _getApplier(tagName, className, classRegExp).isAppliedToRange(range);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.insertHTML = {\n    exec: function exec(composer, command, html) {\n      if (composer.commands.support(command)) {\n        composer.doc.execCommand(command, false, html);\n      } else {\n        composer.selection.insertHTML(html);\n      }\n    },\n\n    state: function state() {\n      return false;\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var NODE_NAME = \"IMG\";\n\n  wysihtml5.commands.insertImage = {\n    /**\n     * Inserts an <img>\n     * If selection is already an image link, it removes it\n     * \n     * @example\n     *    // either ...\n     *    wysihtml5.commands.insertImage.exec(composer, \"insertImage\", \"http://www.google.de/logo.jpg\");\n     *    // ... or ...\n     *    wysihtml5.commands.insertImage.exec(composer, \"insertImage\", { src: \"http://www.google.de/logo.jpg\", title: \"foo\" });\n     */\n    exec: function exec(composer, command, value) {\n      value = (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? value : { src: value };\n\n      var doc = composer.doc,\n          image = this.state(composer),\n          textNode,\n          i,\n          parent;\n\n      if (image) {\n        // Image already selected, set the caret before it and delete it\n        composer.selection.setBefore(image);\n        parent = image.parentNode;\n        parent.removeChild(image);\n\n        // and it's parent <a> too if it hasn't got any other relevant child nodes\n        wysihtml5.dom.removeEmptyTextNodes(parent);\n        if (parent.nodeName === \"A\" && !parent.firstChild) {\n          composer.selection.setAfter(parent);\n          parent.parentNode.removeChild(parent);\n        }\n\n        // firefox and ie sometimes don't remove the image handles, even though the image got removed\n        wysihtml5.quirks.redraw(composer.element);\n        return;\n      }\n\n      image = doc.createElement(NODE_NAME);\n\n      for (i in value) {\n        image[i] = value[i];\n      }\n\n      composer.selection.insertNode(image);\n      if (wysihtml5.browser.hasProblemsSettingCaretAfterImg()) {\n        textNode = doc.createTextNode(wysihtml5.INVISIBLE_SPACE);\n        composer.selection.insertNode(textNode);\n        composer.selection.setAfter(textNode);\n      } else {\n        composer.selection.setAfter(image);\n      }\n    },\n\n    state: function state(composer) {\n      var doc = composer.doc,\n          selectedNode,\n          text,\n          imagesInSelection;\n\n      if (!wysihtml5.dom.hasElementWithTagName(doc, NODE_NAME)) {\n        return false;\n      }\n\n      selectedNode = composer.selection.getSelectedNode();\n      if (!selectedNode) {\n        return false;\n      }\n\n      if (selectedNode.nodeName === NODE_NAME) {\n        // This works perfectly in IE\n        return selectedNode;\n      }\n\n      if (selectedNode.nodeType !== wysihtml5.ELEMENT_NODE) {\n        return false;\n      }\n\n      text = composer.selection.getText();\n      text = wysihtml5.lang.string(text).trim();\n      if (text) {\n        return false;\n      }\n\n      imagesInSelection = composer.selection.getNodes(wysihtml5.ELEMENT_NODE, function (node) {\n        return node.nodeName === \"IMG\";\n      });\n\n      if (imagesInSelection.length !== 1) {\n        return false;\n      }\n\n      return imagesInSelection[0];\n    },\n\n    value: function value(composer) {\n      var image = this.state(composer);\n      return image && image.src;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      LINE_BREAK = \"<br>\" + (wysihtml5.browser.needsSpaceAfterLineBreak() ? \" \" : \"\");\n\n  wysihtml5.commands.insertLineBreak = {\n    exec: function exec(composer, command) {\n      if (composer.commands.support(command)) {\n        composer.doc.execCommand(command, false, null);\n        if (!wysihtml5.browser.autoScrollsToCaret()) {\n          composer.selection.scrollIntoView();\n        }\n      } else {\n        composer.commands.exec(\"insertHTML\", LINE_BREAK);\n      }\n    },\n\n    state: function state() {\n      return false;\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.insertOrderedList = {\n    exec: function exec(composer, command) {\n      var doc = composer.doc,\n          selectedNode = composer.selection.getSelectedNode(),\n          list = wysihtml5.dom.getParentElement(selectedNode, { nodeName: \"OL\" }),\n          otherList = wysihtml5.dom.getParentElement(selectedNode, { nodeName: \"UL\" }),\n          tempClassName = \"_wysihtml5-temp-\" + new Date().getTime(),\n          isEmpty,\n          tempElement;\n\n      if (composer.commands.support(command)) {\n        doc.execCommand(command, false, null);\n        return;\n      }\n\n      if (list) {\n        // Unwrap list\n        // <ol><li>foo</li><li>bar</li></ol>\n        // becomes:\n        // foo<br>bar<br>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.resolveList(list);\n        });\n      } else if (otherList) {\n        // Turn an unordered list into an ordered list\n        // <ul><li>foo</li><li>bar</li></ul>\n        // becomes:\n        // <ol><li>foo</li><li>bar</li></ol>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.renameElement(otherList, \"ol\");\n        });\n      } else {\n        // Create list\n        composer.commands.exec(\"formatBlock\", \"div\", tempClassName);\n        tempElement = doc.querySelector(\".\" + tempClassName);\n        isEmpty = tempElement.innerHTML === \"\" || tempElement.innerHTML === wysihtml5.INVISIBLE_SPACE;\n        composer.selection.executeAndRestoreSimple(function () {\n          list = wysihtml5.dom.convertToList(tempElement, \"ol\");\n        });\n        if (isEmpty) {\n          composer.selection.selectNode(list.querySelector(\"li\"));\n        }\n      }\n    },\n\n    state: function state(composer) {\n      var selectedNode = composer.selection.getSelectedNode();\n      return wysihtml5.dom.getParentElement(selectedNode, { nodeName: \"OL\" });\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.insertUnorderedList = {\n    exec: function exec(composer, command) {\n      var doc = composer.doc,\n          selectedNode = composer.selection.getSelectedNode(),\n          list = wysihtml5.dom.getParentElement(selectedNode, { nodeName: \"UL\" }),\n          otherList = wysihtml5.dom.getParentElement(selectedNode, { nodeName: \"OL\" }),\n          tempClassName = \"_wysihtml5-temp-\" + new Date().getTime(),\n          isEmpty,\n          tempElement;\n\n      if (composer.commands.support(command)) {\n        doc.execCommand(command, false, null);\n        return;\n      }\n\n      if (list) {\n        // Unwrap list\n        // <ul><li>foo</li><li>bar</li></ul>\n        // becomes:\n        // foo<br>bar<br>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.resolveList(list);\n        });\n      } else if (otherList) {\n        // Turn an ordered list into an unordered list\n        // <ol><li>foo</li><li>bar</li></ol>\n        // becomes:\n        // <ul><li>foo</li><li>bar</li></ul>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.renameElement(otherList, \"ul\");\n        });\n      } else {\n        // Create list\n        composer.commands.exec(\"formatBlock\", \"div\", tempClassName);\n        tempElement = doc.querySelector(\".\" + tempClassName);\n        isEmpty = tempElement.innerHTML === \"\" || tempElement.innerHTML === wysihtml5.INVISIBLE_SPACE;\n        composer.selection.executeAndRestoreSimple(function () {\n          list = wysihtml5.dom.convertToList(tempElement, \"ul\");\n        });\n        if (isEmpty) {\n          composer.selection.selectNode(list.querySelector(\"li\"));\n        }\n      }\n    },\n\n    state: function state(composer) {\n      var selectedNode = composer.selection.getSelectedNode();\n      return wysihtml5.dom.getParentElement(selectedNode, { nodeName: \"UL\" });\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.italic = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatInline.exec(composer, command, \"i\");\n    },\n\n    state: function state(composer, command, color) {\n      // element.ownerDocument.queryCommandState(\"italic\") results:\n      // firefox: only <i>\n      // chrome:  <i>, <em>, <blockquote>, ...\n      // ie:      <i>, <em>\n      // opera:   only <i>\n      return wysihtml5.commands.formatInline.state(composer, command, \"i\");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      CLASS_NAME = \"wysiwyg-text-align-center\",\n      REG_EXP = /wysiwyg-text-align-[a-z]+/g;\n\n  wysihtml5.commands.justifyCenter = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatBlock.exec(composer, \"formatBlock\", null, CLASS_NAME, REG_EXP);\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatBlock.state(composer, \"formatBlock\", null, CLASS_NAME, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      CLASS_NAME = \"wysiwyg-text-align-left\",\n      REG_EXP = /wysiwyg-text-align-[a-z]+/g;\n\n  wysihtml5.commands.justifyLeft = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatBlock.exec(composer, \"formatBlock\", null, CLASS_NAME, REG_EXP);\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatBlock.state(composer, \"formatBlock\", null, CLASS_NAME, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      CLASS_NAME = \"wysiwyg-text-align-right\",\n      REG_EXP = /wysiwyg-text-align-[a-z]+/g;\n\n  wysihtml5.commands.justifyRight = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatBlock.exec(composer, \"formatBlock\", null, CLASS_NAME, REG_EXP);\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatBlock.state(composer, \"formatBlock\", null, CLASS_NAME, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n  wysihtml5.commands.underline = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatInline.exec(composer, command, \"u\");\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatInline.state(composer, command, \"u\");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5); /**\n               * Undo Manager for wysihtml5\n               * slightly inspired by http://rniwa.com/editing/undomanager.html#the-undomanager-interface\n               */\n(function (wysihtml5) {\n  var Z_KEY = 90,\n      Y_KEY = 89,\n      BACKSPACE_KEY = 8,\n      DELETE_KEY = 46,\n      MAX_HISTORY_ENTRIES = 40,\n      UNDO_HTML = '<span id=\"_wysihtml5-undo\" class=\"_wysihtml5-temp\">' + wysihtml5.INVISIBLE_SPACE + '</span>',\n      REDO_HTML = '<span id=\"_wysihtml5-redo\" class=\"_wysihtml5-temp\">' + wysihtml5.INVISIBLE_SPACE + '</span>',\n      dom = wysihtml5.dom;\n\n  function cleanTempElements(doc) {\n    var tempElement;\n    while (tempElement = doc.querySelector(\"._wysihtml5-temp\")) {\n      tempElement.parentNode.removeChild(tempElement);\n    }\n  }\n\n  wysihtml5.UndoManager = wysihtml5.lang.Dispatcher.extend(\n  /** @scope wysihtml5.UndoManager.prototype */{\n    constructor: function constructor(editor) {\n      this.editor = editor;\n      this.composer = editor.composer;\n      this.element = this.composer.element;\n      this.history = [this.composer.getValue()];\n      this.position = 1;\n\n      // Undo manager currently only supported in browsers who have the insertHTML command (not IE)\n      if (this.composer.commands.support(\"insertHTML\")) {\n        this._observe();\n      }\n    },\n\n    _observe: function _observe() {\n      var that = this,\n          doc = this.composer.sandbox.getDocument(),\n          lastKey;\n\n      // Catch CTRL+Z and CTRL+Y\n      dom.observe(this.element, \"keydown\", function (event) {\n        if (event.altKey || !event.ctrlKey && !event.metaKey) {\n          return;\n        }\n\n        var keyCode = event.keyCode,\n            isUndo = keyCode === Z_KEY && !event.shiftKey,\n            isRedo = keyCode === Z_KEY && event.shiftKey || keyCode === Y_KEY;\n\n        if (isUndo) {\n          that.undo();\n          event.preventDefault();\n        } else if (isRedo) {\n          that.redo();\n          event.preventDefault();\n        }\n      });\n\n      // Catch delete and backspace\n      dom.observe(this.element, \"keydown\", function (event) {\n        var keyCode = event.keyCode;\n        if (keyCode === lastKey) {\n          return;\n        }\n\n        lastKey = keyCode;\n\n        if (keyCode === BACKSPACE_KEY || keyCode === DELETE_KEY) {\n          that.transact();\n        }\n      });\n\n      // Now this is very hacky:\n      // These days browsers don't offer a undo/redo event which we could hook into\n      // to be notified when the user hits undo/redo in the contextmenu.\n      // Therefore we simply insert two elements as soon as the contextmenu gets opened.\n      // The last element being inserted will be immediately be removed again by a exexCommand(\"undo\")\n      //  => When the second element appears in the dom tree then we know the user clicked \"redo\" in the context menu\n      //  => When the first element disappears from the dom tree then we know the user clicked \"undo\" in the context menu\n      if (wysihtml5.browser.hasUndoInContextMenu()) {\n        var interval,\n            observed,\n            cleanUp = function cleanUp() {\n          cleanTempElements(doc);\n          clearInterval(interval);\n        };\n\n        dom.observe(this.element, \"contextmenu\", function () {\n          cleanUp();\n          that.composer.selection.executeAndRestoreSimple(function () {\n            if (that.element.lastChild) {\n              that.composer.selection.setAfter(that.element.lastChild);\n            }\n\n            // enable undo button in context menu\n            doc.execCommand(\"insertHTML\", false, UNDO_HTML);\n            // enable redo button in context menu\n            doc.execCommand(\"insertHTML\", false, REDO_HTML);\n            doc.execCommand(\"undo\", false, null);\n          });\n\n          interval = setInterval(function () {\n            if (doc.getElementById(\"_wysihtml5-redo\")) {\n              cleanUp();\n              that.redo();\n            } else if (!doc.getElementById(\"_wysihtml5-undo\")) {\n              cleanUp();\n              that.undo();\n            }\n          }, 400);\n\n          if (!observed) {\n            observed = true;\n            dom.observe(document, \"mousedown\", cleanUp);\n            dom.observe(doc, [\"mousedown\", \"paste\", \"cut\", \"copy\"], cleanUp);\n          }\n        });\n      }\n\n      this.editor.observe(\"newword:composer\", function () {\n        that.transact();\n      }).observe(\"beforecommand:composer\", function () {\n        that.transact();\n      });\n    },\n\n    transact: function transact() {\n      var previousHtml = this.history[this.position - 1],\n          currentHtml = this.composer.getValue();\n\n      if (currentHtml == previousHtml) {\n        return;\n      }\n\n      var length = this.history.length = this.position;\n      if (length > MAX_HISTORY_ENTRIES) {\n        this.history.shift();\n        this.position--;\n      }\n\n      this.position++;\n      this.history.push(currentHtml);\n    },\n\n    undo: function undo() {\n      this.transact();\n\n      if (this.position <= 1) {\n        return;\n      }\n\n      this.set(this.history[--this.position - 1]);\n      this.editor.fire(\"undo:composer\");\n    },\n\n    redo: function redo() {\n      if (this.position >= this.history.length) {\n        return;\n      }\n\n      this.set(this.history[++this.position - 1]);\n      this.editor.fire(\"redo:composer\");\n    },\n\n    set: function set(html) {\n      this.composer.setValue(html);\n      this.editor.focus(true);\n    }\n  });\n})(wysihtml5);\n/**\n * TODO: the following methods still need unit test coverage\n */\nwysihtml5.views.View = Base.extend(\n/** @scope wysihtml5.views.View.prototype */{\n  constructor: function constructor(parent, textareaElement, config) {\n    this.parent = parent;\n    this.element = textareaElement;\n    this.config = config;\n\n    this._observeViewChange();\n  },\n\n  _observeViewChange: function _observeViewChange() {\n    var that = this;\n    this.parent.observe(\"beforeload\", function () {\n      that.parent.observe(\"change_view\", function (view) {\n        if (view === that.name) {\n          that.parent.currentView = that;\n          that.show();\n          // Using tiny delay here to make sure that the placeholder is set before focusing\n          setTimeout(function () {\n            that.focus();\n          }, 0);\n        } else {\n          that.hide();\n        }\n      });\n    });\n  },\n\n  focus: function focus() {\n    if (this.element.ownerDocument.querySelector(\":focus\") === this.element) {\n      return;\n    }\n\n    try {\n      this.element.focus();\n    } catch (e) {}\n  },\n\n  hide: function hide() {\n    this.element.style.display = \"none\";\n  },\n\n  show: function show() {\n    this.element.style.display = \"\";\n  },\n\n  disable: function disable() {\n    this.element.setAttribute(\"disabled\", \"disabled\");\n  },\n\n  enable: function enable() {\n    this.element.removeAttribute(\"disabled\");\n  }\n});(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      browser = wysihtml5.browser;\n\n  wysihtml5.views.Composer = wysihtml5.views.View.extend(\n  /** @scope wysihtml5.views.Composer.prototype */{\n    name: \"composer\",\n\n    // Needed for firefox in order to display a proper caret in an empty contentEditable\n    CARET_HACK: \"<br>\",\n\n    constructor: function constructor(parent, textareaElement, config) {\n      this.base(parent, textareaElement, config);\n      this.textarea = this.parent.textarea;\n      this._initSandbox();\n    },\n\n    clear: function clear() {\n      this.element.innerHTML = browser.displaysCaretInEmptyContentEditableCorrectly() ? \"\" : this.CARET_HACK;\n    },\n\n    getValue: function getValue(parse) {\n      var value = this.isEmpty() ? \"\" : wysihtml5.quirks.getCorrectInnerHTML(this.element);\n\n      if (parse) {\n        value = this.parent.parse(value);\n      }\n\n      // Replace all \"zero width no breaking space\" chars\n      // which are used as hacks to enable some functionalities\n      // Also remove all CARET hacks that somehow got left\n      value = wysihtml5.lang.string(value).replace(wysihtml5.INVISIBLE_SPACE).by(\"\");\n\n      return value;\n    },\n\n    setValue: function setValue(html, parse) {\n      if (parse) {\n        html = this.parent.parse(html);\n      }\n      this.element.innerHTML = html;\n    },\n\n    show: function show() {\n      this.iframe.style.display = this._displayStyle || \"\";\n\n      // Firefox needs this, otherwise contentEditable becomes uneditable\n      this.disable();\n      this.enable();\n    },\n\n    hide: function hide() {\n      this._displayStyle = dom.getStyle(\"display\").from(this.iframe);\n      if (this._displayStyle === \"none\") {\n        this._displayStyle = null;\n      }\n      this.iframe.style.display = \"none\";\n    },\n\n    disable: function disable() {\n      this.element.removeAttribute(\"contentEditable\");\n      this.base();\n    },\n\n    enable: function enable() {\n      this.element.setAttribute(\"contentEditable\", \"true\");\n      this.base();\n    },\n\n    focus: function focus(setToEnd) {\n      // IE 8 fires the focus event after .focus()\n      // This is needed by our simulate_placeholder.js to work\n      // therefore we clear it ourselves this time\n      if (wysihtml5.browser.doesAsyncFocus() && this.hasPlaceholderSet()) {\n        this.clear();\n      }\n\n      this.base();\n\n      var lastChild = this.element.lastChild;\n      if (setToEnd && lastChild) {\n        if (lastChild.nodeName === \"BR\") {\n          this.selection.setBefore(this.element.lastChild);\n        } else {\n          this.selection.setAfter(this.element.lastChild);\n        }\n      }\n    },\n\n    getTextContent: function getTextContent() {\n      return dom.getTextContent(this.element);\n    },\n\n    hasPlaceholderSet: function hasPlaceholderSet() {\n      return this.getTextContent() == this.textarea.element.getAttribute(\"placeholder\");\n    },\n\n    isEmpty: function isEmpty() {\n      var innerHTML = this.element.innerHTML,\n          elementsWithVisualValue = \"blockquote, ul, ol, img, embed, object, table, iframe, svg, video, audio, button, input, select, textarea\";\n      return innerHTML === \"\" || innerHTML === this.CARET_HACK || this.hasPlaceholderSet() || this.getTextContent() === \"\" && !this.element.querySelector(elementsWithVisualValue);\n    },\n\n    _initSandbox: function _initSandbox() {\n      var that = this;\n\n      this.sandbox = new dom.Sandbox(function () {\n        that._create();\n      }, {\n        stylesheets: this.config.stylesheets\n      });\n      this.iframe = this.sandbox.getIframe();\n\n      // Create hidden field which tells the server after submit, that the user used an wysiwyg editor\n      var hiddenField = document.createElement(\"input\");\n      hiddenField.type = \"hidden\";\n      hiddenField.name = \"_wysihtml5_mode\";\n      hiddenField.value = 1;\n\n      // Store reference to current wysihtml5 instance on the textarea element\n      var textareaElement = this.textarea.element;\n      dom.insert(this.iframe).after(textareaElement);\n      dom.insert(hiddenField).after(textareaElement);\n    },\n\n    _create: function _create() {\n      var that = this;\n\n      this.doc = this.sandbox.getDocument();\n      this.element = this.doc.body;\n      this.textarea = this.parent.textarea;\n      this.element.innerHTML = this.textarea.getValue(true);\n      this.enable();\n\n      // Make sure our selection handler is ready\n      this.selection = new wysihtml5.Selection(this.parent);\n\n      // Make sure commands dispatcher is ready\n      this.commands = new wysihtml5.Commands(this.parent);\n\n      dom.copyAttributes([\"className\", \"spellcheck\", \"title\", \"lang\", \"dir\", \"accessKey\"]).from(this.textarea.element).to(this.element);\n\n      dom.addClass(this.element, this.config.composerClassName);\n\n      // Make the editor look like the original textarea, by syncing styles\n      if (this.config.style) {\n        this.style();\n      }\n\n      this.observe();\n\n      var name = this.config.name;\n      if (name) {\n        dom.addClass(this.element, name);\n        dom.addClass(this.iframe, name);\n      }\n\n      // Simulate html5 placeholder attribute on contentEditable element\n      var placeholderText = typeof this.config.placeholder === \"string\" ? this.config.placeholder : this.textarea.element.getAttribute(\"placeholder\");\n      if (placeholderText) {\n        dom.simulatePlaceholder(this.parent, this, placeholderText);\n      }\n\n      // Make sure that the browser avoids using inline styles whenever possible\n      this.commands.exec(\"styleWithCSS\", false);\n\n      this._initAutoLinking();\n      this._initObjectResizing();\n      this._initUndoManager();\n\n      // Simulate html5 autofocus on contentEditable element\n      if (this.textarea.element.hasAttribute(\"autofocus\") || document.querySelector(\":focus\") == this.textarea.element) {\n        setTimeout(function () {\n          that.focus();\n        }, 100);\n      }\n\n      wysihtml5.quirks.insertLineBreakOnReturn(this);\n\n      // IE sometimes leaves a single paragraph, which can't be removed by the user\n      if (!browser.clearsContentEditableCorrectly()) {\n        wysihtml5.quirks.ensureProperClearing(this);\n      }\n\n      if (!browser.clearsListsInContentEditableCorrectly()) {\n        wysihtml5.quirks.ensureProperClearingOfLists(this);\n      }\n\n      // Set up a sync that makes sure that textarea and editor have the same content\n      if (this.initSync && this.config.sync) {\n        this.initSync();\n      }\n\n      // Okay hide the textarea, we are ready to go\n      this.textarea.hide();\n\n      // Fire global (before-)load event\n      this.parent.fire(\"beforeload\").fire(\"load\");\n    },\n\n    _initAutoLinking: function _initAutoLinking() {\n      var that = this,\n          supportsDisablingOfAutoLinking = browser.canDisableAutoLinking(),\n          supportsAutoLinking = browser.doesAutoLinkingInContentEditable();\n      if (supportsDisablingOfAutoLinking) {\n        this.commands.exec(\"autoUrlDetect\", false);\n      }\n\n      if (!this.config.autoLink) {\n        return;\n      }\n\n      // Only do the auto linking by ourselves when the browser doesn't support auto linking\n      // OR when he supports auto linking but we were able to turn it off (IE9+)\n      if (!supportsAutoLinking || supportsAutoLinking && supportsDisablingOfAutoLinking) {\n        this.parent.observe(\"newword:composer\", function () {\n          that.selection.executeAndRestore(function (startContainer, endContainer) {\n            dom.autoLink(endContainer.parentNode);\n          });\n        });\n      }\n\n      // Assuming we have the following:\n      //  <a href=\"http://www.google.de\">http://www.google.de</a>\n      // If a user now changes the url in the innerHTML we want to make sure that\n      // it's synchronized with the href attribute (as long as the innerHTML is still a url)\n      var // Use a live NodeList to check whether there are any links in the document\n      links = this.sandbox.getDocument().getElementsByTagName(\"a\"),\n\n      // The autoLink helper method reveals a reg exp to detect correct urls\n      urlRegExp = dom.autoLink.URL_REG_EXP,\n          getTextContent = function getTextContent(element) {\n        var textContent = wysihtml5.lang.string(dom.getTextContent(element)).trim();\n        if (textContent.substr(0, 4) === \"www.\") {\n          textContent = \"http://\" + textContent;\n        }\n        return textContent;\n      };\n\n      dom.observe(this.element, \"keydown\", function (event) {\n        if (!links.length) {\n          return;\n        }\n\n        var selectedNode = that.selection.getSelectedNode(event.target.ownerDocument),\n            link = dom.getParentElement(selectedNode, { nodeName: \"A\" }, 4),\n            textContent;\n\n        if (!link) {\n          return;\n        }\n\n        textContent = getTextContent(link);\n        // keydown is fired before the actual content is changed\n        // therefore we set a timeout to change the href\n        setTimeout(function () {\n          var newTextContent = getTextContent(link);\n          if (newTextContent === textContent) {\n            return;\n          }\n\n          // Only set href when new href looks like a valid url\n          if (newTextContent.match(urlRegExp)) {\n            link.setAttribute(\"href\", newTextContent);\n          }\n        }, 0);\n      });\n    },\n\n    _initObjectResizing: function _initObjectResizing() {\n      var properties = [\"width\", \"height\"],\n          propertiesLength = properties.length,\n          element = this.element;\n\n      this.commands.exec(\"enableObjectResizing\", this.config.allowObjectResizing);\n\n      if (this.config.allowObjectResizing) {\n        // IE sets inline styles after resizing objects\n        // The following lines make sure that the width/height css properties\n        // are copied over to the width/height attributes\n        if (browser.supportsEvent(\"resizeend\")) {\n          dom.observe(element, \"resizeend\", function (event) {\n            var target = event.target || event.srcElement,\n                style = target.style,\n                i = 0,\n                property;\n            for (; i < propertiesLength; i++) {\n              property = properties[i];\n              if (style[property]) {\n                target.setAttribute(property, parseInt(style[property], 10));\n                style[property] = \"\";\n              }\n            }\n            // After resizing IE sometimes forgets to remove the old resize handles\n            wysihtml5.quirks.redraw(element);\n          });\n        }\n      } else {\n        if (browser.supportsEvent(\"resizestart\")) {\n          dom.observe(element, \"resizestart\", function (event) {\n            event.preventDefault();\n          });\n        }\n      }\n    },\n\n    _initUndoManager: function _initUndoManager() {\n      new wysihtml5.UndoManager(this.parent);\n    }\n  });\n})(wysihtml5);(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      doc = document,\n      win = window,\n      HOST_TEMPLATE = doc.createElement(\"div\"),\n\n  /**\n   * Styles to copy from textarea to the composer element\n   */\n  TEXT_FORMATTING = [\"background-color\", \"color\", \"cursor\", \"font-family\", \"font-size\", \"font-style\", \"font-variant\", \"font-weight\", \"line-height\", \"letter-spacing\", \"text-align\", \"text-decoration\", \"text-indent\", \"text-rendering\", \"word-break\", \"word-wrap\", \"word-spacing\"],\n\n  /**\n   * Styles to copy from textarea to the iframe\n   */\n  BOX_FORMATTING = [\"background-color\", \"border-collapse\", \"border-bottom-color\", \"border-bottom-style\", \"border-bottom-width\", \"border-left-color\", \"border-left-style\", \"border-left-width\", \"border-right-color\", \"border-right-style\", \"border-right-width\", \"border-top-color\", \"border-top-style\", \"border-top-width\", \"clear\", \"display\", \"float\", \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\", \"outline-color\", \"outline-offset\", \"outline-width\", \"outline-style\", \"padding-left\", \"padding-right\", \"padding-top\", \"padding-bottom\", \"position\", \"top\", \"left\", \"right\", \"bottom\", \"z-index\", \"vertical-align\", \"text-align\", \"-webkit-box-sizing\", \"-moz-box-sizing\", \"-ms-box-sizing\", \"box-sizing\", \"-webkit-box-shadow\", \"-moz-box-shadow\", \"-ms-box-shadow\", \"box-shadow\", \"-webkit-border-top-right-radius\", \"-moz-border-radius-topright\", \"border-top-right-radius\", \"-webkit-border-bottom-right-radius\", \"-moz-border-radius-bottomright\", \"border-bottom-right-radius\", \"-webkit-border-bottom-left-radius\", \"-moz-border-radius-bottomleft\", \"border-bottom-left-radius\", \"-webkit-border-top-left-radius\", \"-moz-border-radius-topleft\", \"border-top-left-radius\", \"width\", \"height\"],\n\n  /**\n   * Styles to sync while the window gets resized\n   */\n  RESIZE_STYLE = [\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\"],\n      ADDITIONAL_CSS_RULES = [\"html             { height: 100%; }\", \"body             { min-height: 100%; padding: 0; margin: 0; margin-top: -1px; padding-top: 1px; }\", \"._wysihtml5-temp { display: none; }\", wysihtml5.browser.isGecko ? \"body.placeholder { color: graytext !important; }\" : \"body.placeholder { color: #a9a9a9 !important; }\", \"body[disabled]   { background-color: #eee !important; color: #999 !important; cursor: default !important; }\",\n  // Ensure that user see's broken images and can delete them\n  \"img:-moz-broken  { -moz-force-broken-image-icon: 1; height: 24px; width: 24px; }\"];\n\n  /**\n   * With \"setActive\" IE offers a smart way of focusing elements without scrolling them into view:\n   * http://msdn.microsoft.com/en-us/library/ms536738(v=vs.85).aspx\n   *\n   * Other browsers need a more hacky way: (pssst don't tell my mama)\n   * In order to prevent the element being scrolled into view when focusing it, we simply\n   * move it out of the scrollable area, focus it, and reset it's position\n   */\n  var focusWithoutScrolling = function focusWithoutScrolling(element) {\n    if (element.setActive) {\n      // Following line could cause a js error when the textarea is invisible\n      // See https://github.com/xing/wysihtml5/issues/9\n      try {\n        element.setActive();\n      } catch (e) {}\n    } else {\n      var elementStyle = element.style,\n          originalScrollTop = doc.documentElement.scrollTop || doc.body.scrollTop,\n          originalScrollLeft = doc.documentElement.scrollLeft || doc.body.scrollLeft,\n          originalStyles = {\n        position: elementStyle.position,\n        top: elementStyle.top,\n        left: elementStyle.left,\n        WebkitUserSelect: elementStyle.WebkitUserSelect\n      };\n\n      dom.setStyles({\n        position: \"absolute\",\n        top: \"-99999px\",\n        left: \"-99999px\",\n        // Don't ask why but temporarily setting -webkit-user-select to none makes the whole thing performing smoother\n        WebkitUserSelect: \"none\"\n      }).on(element);\n\n      element.focus();\n\n      dom.setStyles(originalStyles).on(element);\n\n      if (win.scrollTo) {\n        // Some browser extensions unset this method to prevent annoyances\n        // \"Better PopUp Blocker\" for Chrome http://code.google.com/p/betterpopupblocker/source/browse/trunk/blockStart.js#100\n        // Issue: http://code.google.com/p/betterpopupblocker/issues/detail?id=1\n        win.scrollTo(originalScrollLeft, originalScrollTop);\n      }\n    }\n  };\n\n  wysihtml5.views.Composer.prototype.style = function () {\n    var that = this,\n        originalActiveElement = doc.querySelector(\":focus\"),\n        textareaElement = this.textarea.element,\n        hasPlaceholder = textareaElement.hasAttribute(\"placeholder\"),\n        originalPlaceholder = hasPlaceholder && textareaElement.getAttribute(\"placeholder\");\n    this.focusStylesHost = this.focusStylesHost || HOST_TEMPLATE.cloneNode(false);\n    this.blurStylesHost = this.blurStylesHost || HOST_TEMPLATE.cloneNode(false);\n\n    // Remove placeholder before copying (as the placeholder has an affect on the computed style)\n    if (hasPlaceholder) {\n      textareaElement.removeAttribute(\"placeholder\");\n    }\n\n    if (textareaElement === originalActiveElement) {\n      textareaElement.blur();\n    }\n\n    // --------- iframe styles (has to be set before editor styles, otherwise IE9 sets wrong fontFamily on blurStylesHost) ---------\n    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.iframe).andTo(this.blurStylesHost);\n\n    // --------- editor styles ---------\n    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.element).andTo(this.blurStylesHost);\n\n    // --------- apply standard rules ---------\n    dom.insertCSS(ADDITIONAL_CSS_RULES).into(this.element.ownerDocument);\n\n    // --------- :focus styles ---------\n    focusWithoutScrolling(textareaElement);\n    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.focusStylesHost);\n    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.focusStylesHost);\n\n    // Make sure that we don't change the display style of the iframe when copying styles oblur/onfocus\n    // this is needed for when the change_view event is fired where the iframe is hidden and then\n    // the blur event fires and re-displays it\n    var boxFormattingStyles = wysihtml5.lang.array(BOX_FORMATTING).without([\"display\"]);\n\n    // --------- restore focus ---------\n    if (originalActiveElement) {\n      originalActiveElement.focus();\n    } else {\n      textareaElement.blur();\n    }\n\n    // --------- restore placeholder ---------\n    if (hasPlaceholder) {\n      textareaElement.setAttribute(\"placeholder\", originalPlaceholder);\n    }\n\n    // When copying styles, we only get the computed style which is never returned in percent unit\n    // Therefore we've to recalculate style onresize\n    if (!wysihtml5.browser.hasCurrentStyleProperty()) {\n      var winObserver = dom.observe(win, \"resize\", function () {\n        // Remove event listener if composer doesn't exist anymore\n        if (!dom.contains(document.documentElement, that.iframe)) {\n          winObserver.stop();\n          return;\n        }\n        var originalTextareaDisplayStyle = dom.getStyle(\"display\").from(textareaElement),\n            originalComposerDisplayStyle = dom.getStyle(\"display\").from(that.iframe);\n        textareaElement.style.display = \"\";\n        that.iframe.style.display = \"none\";\n        dom.copyStyles(RESIZE_STYLE).from(textareaElement).to(that.iframe).andTo(that.focusStylesHost).andTo(that.blurStylesHost);\n        that.iframe.style.display = originalComposerDisplayStyle;\n        textareaElement.style.display = originalTextareaDisplayStyle;\n      });\n    }\n\n    // --------- Sync focus/blur styles ---------\n    this.parent.observe(\"focus:composer\", function () {\n      dom.copyStyles(boxFormattingStyles).from(that.focusStylesHost).to(that.iframe);\n      dom.copyStyles(TEXT_FORMATTING).from(that.focusStylesHost).to(that.element);\n    });\n\n    this.parent.observe(\"blur:composer\", function () {\n      dom.copyStyles(boxFormattingStyles).from(that.blurStylesHost).to(that.iframe);\n      dom.copyStyles(TEXT_FORMATTING).from(that.blurStylesHost).to(that.element);\n    });\n\n    return this;\n  };\n})(wysihtml5); /**\n               * Taking care of events\n               *  - Simulating 'change' event on contentEditable element\n               *  - Handling drag & drop logic\n               *  - Catch paste events\n               *  - Dispatch proprietary newword:composer event\n               *  - Keyboard shortcuts\n               */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      browser = wysihtml5.browser,\n\n  /**\n   * Map keyCodes to query commands\n   */\n  shortcuts = {\n    \"66\": \"bold\", // B\n    \"73\": \"italic\", // I\n    \"85\": \"underline\" // U\n  };\n\n  wysihtml5.views.Composer.prototype.observe = function () {\n    var that = this,\n        state = this.getValue(),\n        iframe = this.sandbox.getIframe(),\n        element = this.element,\n        focusBlurElement = browser.supportsEventsInIframeCorrectly() ? element : this.sandbox.getWindow(),\n\n    // Firefox < 3.5 doesn't support the drop event, instead it supports a so called \"dragdrop\" event which behaves almost the same\n    pasteEvents = browser.supportsEvent(\"drop\") ? [\"drop\", \"paste\"] : [\"dragdrop\", \"paste\"];\n\n    // --------- destroy:composer event ---------\n    dom.observe(iframe, \"DOMNodeRemoved\", function () {\n      clearInterval(domNodeRemovedInterval);\n      that.parent.fire(\"destroy:composer\");\n    });\n\n    // DOMNodeRemoved event is not supported in IE 8\n    var domNodeRemovedInterval = setInterval(function () {\n      if (!dom.contains(document.documentElement, iframe)) {\n        clearInterval(domNodeRemovedInterval);\n        that.parent.fire(\"destroy:composer\");\n      }\n    }, 250);\n\n    // --------- Focus & blur logic ---------\n    dom.observe(focusBlurElement, \"focus\", function () {\n      that.parent.fire(\"focus\").fire(\"focus:composer\");\n\n      // Delay storing of state until all focus handler are fired\n      // especially the one which resets the placeholder\n      setTimeout(function () {\n        state = that.getValue();\n      }, 0);\n    });\n\n    dom.observe(focusBlurElement, \"blur\", function () {\n      if (state !== that.getValue()) {\n        that.parent.fire(\"change\").fire(\"change:composer\");\n      }\n      that.parent.fire(\"blur\").fire(\"blur:composer\");\n    });\n\n    if (wysihtml5.browser.isIos()) {\n      // When on iPad/iPhone/IPod after clicking outside of editor, the editor loses focus\n      // but the UI still acts as if the editor has focus (blinking caret and onscreen keyboard visible)\n      // We prevent that by focusing a temporary input element which immediately loses focus\n      dom.observe(element, \"blur\", function () {\n        var input = element.ownerDocument.createElement(\"input\"),\n            originalScrollTop = document.documentElement.scrollTop || document.body.scrollTop,\n            originalScrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n        try {\n          that.selection.insertNode(input);\n        } catch (e) {\n          element.appendChild(input);\n        }\n        input.focus();\n        input.parentNode.removeChild(input);\n\n        window.scrollTo(originalScrollLeft, originalScrollTop);\n      });\n    }\n\n    // --------- Drag & Drop logic ---------\n    dom.observe(element, \"dragenter\", function () {\n      that.parent.fire(\"unset_placeholder\");\n    });\n\n    if (browser.firesOnDropOnlyWhenOnDragOverIsCancelled()) {\n      dom.observe(element, [\"dragover\", \"dragenter\"], function (event) {\n        event.preventDefault();\n      });\n    }\n\n    dom.observe(element, pasteEvents, function (event) {\n      var dataTransfer = event.dataTransfer,\n          data;\n\n      if (dataTransfer && browser.supportsDataTransfer()) {\n        data = dataTransfer.getData(\"text/html\") || dataTransfer.getData(\"text/plain\");\n      }\n      if (data) {\n        element.focus();\n        that.commands.exec(\"insertHTML\", data);\n        that.parent.fire(\"paste\").fire(\"paste:composer\");\n        event.stopPropagation();\n        event.preventDefault();\n      } else {\n        setTimeout(function () {\n          that.parent.fire(\"paste\").fire(\"paste:composer\");\n        }, 0);\n      }\n    });\n\n    // --------- neword event ---------\n    dom.observe(element, \"keyup\", function (event) {\n      var keyCode = event.keyCode;\n      if (keyCode === wysihtml5.SPACE_KEY || keyCode === wysihtml5.ENTER_KEY) {\n        that.parent.fire(\"newword:composer\");\n      }\n    });\n\n    this.parent.observe(\"paste:composer\", function () {\n      setTimeout(function () {\n        that.parent.fire(\"newword:composer\");\n      }, 0);\n    });\n\n    // --------- Make sure that images are selected when clicking on them ---------\n    if (!browser.canSelectImagesInContentEditable()) {\n      dom.observe(element, \"mousedown\", function (event) {\n        var target = event.target;\n        if (target.nodeName === \"IMG\") {\n          that.selection.selectNode(target);\n          event.preventDefault();\n        }\n      });\n    }\n\n    // --------- Shortcut logic ---------\n    dom.observe(element, \"keydown\", function (event) {\n      var keyCode = event.keyCode,\n          command = shortcuts[keyCode];\n      if ((event.ctrlKey || event.metaKey) && !event.altKey && command) {\n        that.commands.exec(command);\n        event.preventDefault();\n      }\n    });\n\n    // --------- Make sure that when pressing backspace/delete on selected images deletes the image and it's anchor ---------\n    dom.observe(element, \"keydown\", function (event) {\n      var target = that.selection.getSelectedNode(true),\n          keyCode = event.keyCode,\n          parent;\n      if (target && target.nodeName === \"IMG\" && (keyCode === wysihtml5.BACKSPACE_KEY || keyCode === wysihtml5.DELETE_KEY)) {\n        // 8 => backspace, 46 => delete\n        parent = target.parentNode;\n        // delete the <img>\n        parent.removeChild(target);\n        // and it's parent <a> too if it hasn't got any other child nodes\n        if (parent.nodeName === \"A\" && !parent.firstChild) {\n          parent.parentNode.removeChild(parent);\n        }\n\n        setTimeout(function () {\n          wysihtml5.quirks.redraw(element);\n        }, 0);\n        event.preventDefault();\n      }\n    });\n\n    // --------- Show url in tooltip when hovering links or images ---------\n    var titlePrefixes = {\n      IMG: \"Image: \",\n      A: \"Link: \"\n    };\n\n    dom.observe(element, \"mouseover\", function (event) {\n      var target = event.target,\n          nodeName = target.nodeName,\n          title;\n      if (nodeName !== \"A\" && nodeName !== \"IMG\") {\n        return;\n      }\n      var hasTitle = target.hasAttribute(\"title\");\n      if (!hasTitle) {\n        title = titlePrefixes[nodeName] + (target.getAttribute(\"href\") || target.getAttribute(\"src\"));\n        target.setAttribute(\"title\", title);\n      }\n    });\n  };\n})(wysihtml5); /**\n               * Class that takes care that the value of the composer and the textarea is always in sync\n               */\n(function (wysihtml5) {\n  var INTERVAL = 400;\n\n  wysihtml5.views.Synchronizer = Base.extend(\n  /** @scope wysihtml5.views.Synchronizer.prototype */{\n\n    constructor: function constructor(editor, textarea, composer) {\n      this.editor = editor;\n      this.textarea = textarea;\n      this.composer = composer;\n\n      this._observe();\n    },\n\n    /**\n     * Sync html from composer to textarea\n     * Takes care of placeholders\n     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the textarea\n     */\n    fromComposerToTextarea: function fromComposerToTextarea(shouldParseHtml) {\n      this.textarea.setValue(wysihtml5.lang.string(this.composer.getValue()).trim(), shouldParseHtml);\n    },\n\n    /**\n     * Sync value of textarea to composer\n     * Takes care of placeholders\n     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the composer\n     */\n    fromTextareaToComposer: function fromTextareaToComposer(shouldParseHtml) {\n      var textareaValue = this.textarea.getValue();\n      if (textareaValue) {\n        this.composer.setValue(textareaValue, shouldParseHtml);\n      } else {\n        this.composer.clear();\n        this.editor.fire(\"set_placeholder\");\n      }\n    },\n\n    /**\n     * Invoke syncing based on view state\n     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the composer/textarea\n     */\n    sync: function sync(shouldParseHtml) {\n      if (this.editor.currentView.name === \"textarea\") {\n        this.fromTextareaToComposer(shouldParseHtml);\n      } else {\n        this.fromComposerToTextarea(shouldParseHtml);\n      }\n    },\n\n    /**\n     * Initializes interval-based syncing\n     * also makes sure that on-submit the composer's content is synced with the textarea\n     * immediately when the form gets submitted\n     */\n    _observe: function _observe() {\n      var interval,\n          that = this,\n          form = this.textarea.element.form,\n          startInterval = function startInterval() {\n        interval = setInterval(function () {\n          that.fromComposerToTextarea();\n        }, INTERVAL);\n      },\n          stopInterval = function stopInterval() {\n        clearInterval(interval);\n        interval = null;\n      };\n\n      startInterval();\n\n      if (form) {\n        // If the textarea is in a form make sure that after onreset and onsubmit the composer\n        // has the correct state\n        wysihtml5.dom.observe(form, \"submit\", function () {\n          that.sync(true);\n        });\n        wysihtml5.dom.observe(form, \"reset\", function () {\n          setTimeout(function () {\n            that.fromTextareaToComposer();\n          }, 0);\n        });\n      }\n\n      this.editor.observe(\"change_view\", function (view) {\n        if (view === \"composer\" && !interval) {\n          that.fromTextareaToComposer(true);\n          startInterval();\n        } else if (view === \"textarea\") {\n          that.fromComposerToTextarea(true);\n          stopInterval();\n        }\n      });\n\n      this.editor.observe(\"destroy:composer\", stopInterval);\n    }\n  });\n})(wysihtml5);\nwysihtml5.views.Textarea = wysihtml5.views.View.extend(\n/** @scope wysihtml5.views.Textarea.prototype */{\n  name: \"textarea\",\n\n  constructor: function constructor(parent, textareaElement, config) {\n    this.base(parent, textareaElement, config);\n\n    this._observe();\n  },\n\n  clear: function clear() {\n    this.element.value = \"\";\n  },\n\n  getValue: function getValue(parse) {\n    var value = this.isEmpty() ? \"\" : this.element.value;\n    if (parse) {\n      value = this.parent.parse(value);\n    }\n    return value;\n  },\n\n  setValue: function setValue(html, parse) {\n    if (parse) {\n      html = this.parent.parse(html);\n    }\n    this.element.value = html;\n  },\n\n  hasPlaceholderSet: function hasPlaceholderSet() {\n    var supportsPlaceholder = wysihtml5.browser.supportsPlaceholderAttributeOn(this.element),\n        placeholderText = this.element.getAttribute(\"placeholder\") || null,\n        value = this.element.value,\n        isEmpty = !value;\n    return supportsPlaceholder && isEmpty || value === placeholderText;\n  },\n\n  isEmpty: function isEmpty() {\n    return !wysihtml5.lang.string(this.element.value).trim() || this.hasPlaceholderSet();\n  },\n\n  _observe: function _observe() {\n    var element = this.element,\n        parent = this.parent,\n        eventMapping = {\n      focusin: \"focus\",\n      focusout: \"blur\"\n    },\n\n    /**\n     * Calling focus() or blur() on an element doesn't synchronously trigger the attached focus/blur events\n     * This is the case for focusin and focusout, so let's use them whenever possible, kkthxbai\n     */\n    events = wysihtml5.browser.supportsEvent(\"focusin\") ? [\"focusin\", \"focusout\", \"change\"] : [\"focus\", \"blur\", \"change\"];\n\n    parent.observe(\"beforeload\", function () {\n      wysihtml5.dom.observe(element, events, function (event) {\n        var eventName = eventMapping[event.type] || event.type;\n        parent.fire(eventName).fire(eventName + \":textarea\");\n      });\n\n      wysihtml5.dom.observe(element, [\"paste\", \"drop\"], function () {\n        setTimeout(function () {\n          parent.fire(\"paste\").fire(\"paste:textarea\");\n        }, 0);\n      });\n    });\n  }\n}); /**\n    * Toolbar Dialog\n    *\n    * @param {Element} link The toolbar link which causes the dialog to show up\n    * @param {Element} container The dialog container\n    *\n    * @example\n    *    <!-- Toolbar link -->\n    *    <a data-wysihtml5-command=\"insertImage\">insert an image</a>\n    *\n    *    <!-- Dialog -->\n    *    <div data-wysihtml5-dialog=\"insertImage\" style=\"display: none;\">\n    *      <label>\n    *        URL: <input data-wysihtml5-dialog-field=\"src\" value=\"http://\">\n    *      </label>\n    *      <label>\n    *        Alternative text: <input data-wysihtml5-dialog-field=\"alt\" value=\"\">\n    *      </label>\n    *    </div>\n    *\n    *    <script>\n    *      var dialog = new wysihtml5.toolbar.Dialog(\n    *        document.querySelector(\"[data-wysihtml5-command='insertImage']\"),\n    *        document.querySelector(\"[data-wysihtml5-dialog='insertImage']\")\n    *      );\n    *      dialog.observe(\"save\", function(attributes) {\n    *        // do something\n    *      });\n    *    </script>\n    */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      CLASS_NAME_OPENED = \"wysihtml5-command-dialog-opened\",\n      SELECTOR_FORM_ELEMENTS = \"input, select, textarea\",\n      SELECTOR_FIELDS = \"[data-wysihtml5-dialog-field]\",\n      ATTRIBUTE_FIELDS = \"data-wysihtml5-dialog-field\";\n\n  wysihtml5.toolbar.Dialog = wysihtml5.lang.Dispatcher.extend(\n  /** @scope wysihtml5.toolbar.Dialog.prototype */{\n    constructor: function constructor(link, container) {\n      this.link = link;\n      this.container = container;\n    },\n\n    _observe: function _observe() {\n      if (this._observed) {\n        return;\n      }\n\n      var that = this,\n          callbackWrapper = function callbackWrapper(event) {\n        var attributes = that._serialize();\n        if (attributes == that.elementToChange) {\n          that.fire(\"edit\", attributes);\n        } else {\n          that.fire(\"save\", attributes);\n        }\n        that.hide();\n        event.preventDefault();\n        event.stopPropagation();\n      };\n\n      dom.observe(that.link, \"click\", function (event) {\n        if (dom.hasClass(that.link, CLASS_NAME_OPENED)) {\n          setTimeout(function () {\n            that.hide();\n          }, 0);\n        }\n      });\n\n      dom.observe(this.container, \"keydown\", function (event) {\n        var keyCode = event.keyCode;\n        if (keyCode === wysihtml5.ENTER_KEY) {\n          callbackWrapper(event);\n        }\n        if (keyCode === wysihtml5.ESCAPE_KEY) {\n          that.hide();\n        }\n      });\n\n      dom.delegate(this.container, \"[data-wysihtml5-dialog-action=save]\", \"click\", callbackWrapper);\n\n      dom.delegate(this.container, \"[data-wysihtml5-dialog-action=cancel]\", \"click\", function (event) {\n        that.fire(\"cancel\");\n        that.hide();\n        event.preventDefault();\n        event.stopPropagation();\n      });\n\n      var formElements = this.container.querySelectorAll(SELECTOR_FORM_ELEMENTS),\n          i = 0,\n          length = formElements.length,\n          _clearInterval = function _clearInterval() {\n        clearInterval(that.interval);\n      };\n      for (; i < length; i++) {\n        dom.observe(formElements[i], \"change\", _clearInterval);\n      }\n\n      this._observed = true;\n    },\n\n    /**\n     * Grabs all fields in the dialog and puts them in key=>value style in an object which\n     * then gets returned\n     */\n    _serialize: function _serialize() {\n      var data = this.elementToChange || {},\n          fields = this.container.querySelectorAll(SELECTOR_FIELDS),\n          length = fields.length,\n          i = 0;\n      for (; i < length; i++) {\n        data[fields[i].getAttribute(ATTRIBUTE_FIELDS)] = fields[i].value;\n      }\n      return data;\n    },\n\n    /**\n     * Takes the attributes of the \"elementToChange\"\n     * and inserts them in their corresponding dialog input fields\n     * \n     * Assume the \"elementToChange\" looks like this:\n     *    <a href=\"http://www.google.com\" target=\"_blank\">foo</a>\n     *\n     * and we have the following dialog:\n     *    <input type=\"text\" data-wysihtml5-dialog-field=\"href\" value=\"\">\n     *    <input type=\"text\" data-wysihtml5-dialog-field=\"target\" value=\"\">\n     * \n     * after calling _interpolate() the dialog will look like this\n     *    <input type=\"text\" data-wysihtml5-dialog-field=\"href\" value=\"http://www.google.com\">\n     *    <input type=\"text\" data-wysihtml5-dialog-field=\"target\" value=\"_blank\">\n     *\n     * Basically it adopted the attribute values into the corresponding input fields\n     *\n     */\n    _interpolate: function _interpolate(avoidHiddenFields) {\n      var field,\n          fieldName,\n          newValue,\n          focusedElement = document.querySelector(\":focus\"),\n          fields = this.container.querySelectorAll(SELECTOR_FIELDS),\n          length = fields.length,\n          i = 0;\n      for (; i < length; i++) {\n        field = fields[i];\n\n        // Never change elements where the user is currently typing in\n        if (field === focusedElement) {\n          continue;\n        }\n\n        // Don't update hidden fields\n        // See https://github.com/xing/wysihtml5/pull/14\n        if (avoidHiddenFields && field.type === \"hidden\") {\n          continue;\n        }\n\n        fieldName = field.getAttribute(ATTRIBUTE_FIELDS);\n        newValue = this.elementToChange ? this.elementToChange[fieldName] || \"\" : field.defaultValue;\n        field.value = newValue;\n      }\n    },\n\n    /**\n     * Show the dialog element\n     */\n    show: function show(elementToChange) {\n      var that = this,\n          firstField = this.container.querySelector(SELECTOR_FORM_ELEMENTS);\n      this.elementToChange = elementToChange;\n      this._observe();\n      this._interpolate();\n      if (elementToChange) {\n        this.interval = setInterval(function () {\n          that._interpolate(true);\n        }, 500);\n      }\n      dom.addClass(this.link, CLASS_NAME_OPENED);\n      this.container.style.display = \"\";\n      this.fire(\"show\");\n      if (firstField && !elementToChange) {\n        try {\n          firstField.focus();\n        } catch (e) {}\n      }\n    },\n\n    /**\n     * Hide the dialog element\n     */\n    hide: function hide() {\n      clearInterval(this.interval);\n      this.elementToChange = null;\n      dom.removeClass(this.link, CLASS_NAME_OPENED);\n      this.container.style.display = \"none\";\n      this.fire(\"hide\");\n    }\n  });\n})(wysihtml5);\n/**\n * Converts speech-to-text and inserts this into the editor\n * As of now (2011/03/25) this only is supported in Chrome >= 11\n *\n * Note that it sends the recorded audio to the google speech recognition api:\n * http://stackoverflow.com/questions/4361826/does-chrome-have-buil-in-speech-recognition-for-input-type-text-x-webkit-speec\n *\n * Current HTML5 draft can be found here\n * http://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Feb/att-0020/api-draft.html\n * \n * \"Accessing Google Speech API Chrome 11\"\n * http://mikepultz.com/2011/03/accessing-google-speech-api-chrome-11/\n */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom;\n\n  var linkStyles = {\n    position: \"relative\"\n  };\n\n  var wrapperStyles = {\n    left: 0,\n    margin: 0,\n    opacity: 0,\n    overflow: \"hidden\",\n    padding: 0,\n    position: \"absolute\",\n    top: 0,\n    zIndex: 1\n  };\n\n  var inputStyles = {\n    cursor: \"inherit\",\n    fontSize: \"50px\",\n    height: \"50px\",\n    marginTop: \"-25px\",\n    outline: 0,\n    padding: 0,\n    position: \"absolute\",\n    right: \"-4px\",\n    top: \"50%\"\n  };\n\n  var inputAttributes = {\n    \"x-webkit-speech\": \"\",\n    \"speech\": \"\"\n  };\n\n  wysihtml5.toolbar.Speech = function (parent, link) {\n    var input = document.createElement(\"input\");\n    if (!wysihtml5.browser.supportsSpeechApiOn(input)) {\n      link.style.display = \"none\";\n      return;\n    }\n\n    var wrapper = document.createElement(\"div\");\n\n    wysihtml5.lang.object(wrapperStyles).merge({\n      width: link.offsetWidth + \"px\",\n      height: link.offsetHeight + \"px\"\n    });\n\n    dom.insert(input).into(wrapper);\n    dom.insert(wrapper).into(link);\n\n    dom.setStyles(inputStyles).on(input);\n    dom.setAttributes(inputAttributes).on(input);\n\n    dom.setStyles(wrapperStyles).on(wrapper);\n    dom.setStyles(linkStyles).on(link);\n\n    var eventName = \"onwebkitspeechchange\" in input ? \"webkitspeechchange\" : \"speechchange\";\n    dom.observe(input, eventName, function () {\n      parent.execCommand(\"insertText\", input.value);\n      input.value = \"\";\n    });\n\n    dom.observe(input, \"click\", function (event) {\n      if (dom.hasClass(link, \"wysihtml5-command-disabled\")) {\n        event.preventDefault();\n      }\n\n      event.stopPropagation();\n    });\n  };\n})(wysihtml5); /**\n               * Toolbar\n               *\n               * @param {Object} parent Reference to instance of Editor instance\n               * @param {Element} container Reference to the toolbar container element\n               *\n               * @example\n               *    <div id=\"toolbar\">\n               *      <a data-wysihtml5-command=\"createLink\">insert link</a>\n               *      <a data-wysihtml5-command=\"formatBlock\" data-wysihtml5-command-value=\"h1\">insert h1</a>\n               *    </div>\n               *\n               *    <script>\n               *      var toolbar = new wysihtml5.toolbar.Toolbar(editor, document.getElementById(\"toolbar\"));\n               *    </script>\n               */\n(function (wysihtml5) {\n  var CLASS_NAME_COMMAND_DISABLED = \"wysihtml5-command-disabled\",\n      CLASS_NAME_COMMANDS_DISABLED = \"wysihtml5-commands-disabled\",\n      CLASS_NAME_COMMAND_ACTIVE = \"wysihtml5-command-active\",\n      CLASS_NAME_ACTION_ACTIVE = \"wysihtml5-action-active\",\n      dom = wysihtml5.dom;\n\n  wysihtml5.toolbar.Toolbar = Base.extend(\n  /** @scope wysihtml5.toolbar.Toolbar.prototype */{\n    constructor: function constructor(editor, container) {\n      this.editor = editor;\n      this.container = typeof container === \"string\" ? document.getElementById(container) : container;\n      this.composer = editor.composer;\n\n      this._getLinks(\"command\");\n      this._getLinks(\"action\");\n\n      this._observe();\n      this.show();\n\n      var speechInputLinks = this.container.querySelectorAll(\"[data-wysihtml5-command=insertSpeech]\"),\n          length = speechInputLinks.length,\n          i = 0;\n      for (; i < length; i++) {\n        new wysihtml5.toolbar.Speech(this, speechInputLinks[i]);\n      }\n    },\n\n    _getLinks: function _getLinks(type) {\n      var links = this[type + \"Links\"] = wysihtml5.lang.array(this.container.querySelectorAll(\"[data-wysihtml5-\" + type + \"]\")).get(),\n          length = links.length,\n          i = 0,\n          mapping = this[type + \"Mapping\"] = {},\n          link,\n          group,\n          name,\n          value,\n          dialog;\n      for (; i < length; i++) {\n        link = links[i];\n        name = link.getAttribute(\"data-wysihtml5-\" + type);\n        value = link.getAttribute(\"data-wysihtml5-\" + type + \"-value\");\n        group = this.container.querySelector(\"[data-wysihtml5-\" + type + \"-group='\" + name + \"']\");\n        dialog = this._getDialog(link, name);\n\n        mapping[name + \":\" + value] = {\n          link: link,\n          group: group,\n          name: name,\n          value: value,\n          dialog: dialog,\n          state: false\n        };\n      }\n    },\n\n    _getDialog: function _getDialog(link, command) {\n      var that = this,\n          dialogElement = this.container.querySelector(\"[data-wysihtml5-dialog='\" + command + \"']\"),\n          dialog,\n          caretBookmark;\n\n      if (dialogElement) {\n        dialog = new wysihtml5.toolbar.Dialog(link, dialogElement);\n\n        dialog.observe(\"show\", function () {\n          caretBookmark = that.composer.selection.getBookmark();\n\n          that.editor.fire(\"show:dialog\", { command: command, dialogContainer: dialogElement, commandLink: link });\n        });\n\n        dialog.observe(\"save\", function (attributes) {\n          if (caretBookmark) {\n            that.composer.selection.setBookmark(caretBookmark);\n          }\n          that._execCommand(command, attributes);\n\n          that.editor.fire(\"save:dialog\", { command: command, dialogContainer: dialogElement, commandLink: link });\n        });\n\n        dialog.observe(\"cancel\", function () {\n          that.editor.focus(false);\n          that.editor.fire(\"cancel:dialog\", { command: command, dialogContainer: dialogElement, commandLink: link });\n        });\n      }\n      return dialog;\n    },\n\n    /**\n     * @example\n     *    var toolbar = new wysihtml5.Toolbar();\n     *    // Insert a <blockquote> element or wrap current selection in <blockquote>\n     *    toolbar.execCommand(\"formatBlock\", \"blockquote\");\n     */\n    execCommand: function execCommand(command, commandValue) {\n      if (this.commandsDisabled) {\n        return;\n      }\n\n      var commandObj = this.commandMapping[command + \":\" + commandValue];\n\n      // Show dialog when available\n      if (commandObj && commandObj.dialog && !commandObj.state) {\n        commandObj.dialog.show();\n      } else {\n        this._execCommand(command, commandValue);\n      }\n    },\n\n    _execCommand: function _execCommand(command, commandValue) {\n      // Make sure that composer is focussed (false => don't move caret to the end)\n      this.editor.focus(false);\n\n      this.composer.commands.exec(command, commandValue);\n      this._updateLinkStates();\n    },\n\n    execAction: function execAction(action) {\n      var editor = this.editor;\n      switch (action) {\n        case \"change_view\":\n          if (editor.currentView === editor.textarea) {\n            editor.fire(\"change_view\", \"composer\");\n          } else {\n            editor.fire(\"change_view\", \"textarea\");\n          }\n          break;\n      }\n    },\n\n    _observe: function _observe() {\n      var that = this,\n          editor = this.editor,\n          container = this.container,\n          links = this.commandLinks.concat(this.actionLinks),\n          length = links.length,\n          i = 0;\n\n      for (; i < length; i++) {\n        // 'javascript:;' and unselectable=on Needed for IE, but done in all browsers to make sure that all get the same css applied\n        // (you know, a:link { ... } doesn't match anchors with missing href attribute)\n        dom.setAttributes({\n          href: \"javascript:;\",\n          unselectable: \"on\"\n        }).on(links[i]);\n      }\n\n      // Needed for opera\n      dom.delegate(container, \"[data-wysihtml5-command]\", \"mousedown\", function (event) {\n        event.preventDefault();\n      });\n\n      dom.delegate(container, \"[data-wysihtml5-command]\", \"click\", function (event) {\n        var link = this,\n            command = link.getAttribute(\"data-wysihtml5-command\"),\n            commandValue = link.getAttribute(\"data-wysihtml5-command-value\");\n        that.execCommand(command, commandValue);\n        event.preventDefault();\n      });\n\n      dom.delegate(container, \"[data-wysihtml5-action]\", \"click\", function (event) {\n        var action = this.getAttribute(\"data-wysihtml5-action\");\n        that.execAction(action);\n        event.preventDefault();\n      });\n\n      editor.observe(\"focus:composer\", function () {\n        that.bookmark = null;\n        clearInterval(that.interval);\n        that.interval = setInterval(function () {\n          that._updateLinkStates();\n        }, 500);\n      });\n\n      editor.observe(\"blur:composer\", function () {\n        clearInterval(that.interval);\n      });\n\n      editor.observe(\"destroy:composer\", function () {\n        clearInterval(that.interval);\n      });\n\n      editor.observe(\"change_view\", function (currentView) {\n        // Set timeout needed in order to let the blur event fire first\n        setTimeout(function () {\n          that.commandsDisabled = currentView !== \"composer\";\n          that._updateLinkStates();\n          if (that.commandsDisabled) {\n            dom.addClass(container, CLASS_NAME_COMMANDS_DISABLED);\n          } else {\n            dom.removeClass(container, CLASS_NAME_COMMANDS_DISABLED);\n          }\n        }, 0);\n      });\n    },\n\n    _updateLinkStates: function _updateLinkStates() {\n      var element = this.composer.element,\n          commandMapping = this.commandMapping,\n          actionMapping = this.actionMapping,\n          i,\n          state,\n          action,\n          command;\n      // every millisecond counts... this is executed quite often\n      for (i in commandMapping) {\n        command = commandMapping[i];\n        if (this.commandsDisabled) {\n          state = false;\n          dom.removeClass(command.link, CLASS_NAME_COMMAND_ACTIVE);\n          if (command.group) {\n            dom.removeClass(command.group, CLASS_NAME_COMMAND_ACTIVE);\n          }\n          if (command.dialog) {\n            command.dialog.hide();\n          }\n        } else {\n          state = this.composer.commands.state(command.name, command.value);\n          if (wysihtml5.lang.object(state).isArray()) {\n            // Grab first and only object/element in state array, otherwise convert state into boolean\n            // to avoid showing a dialog for multiple selected elements which may have different attributes\n            // eg. when two links with different href are selected, the state will be an array consisting of both link elements\n            // but the dialog interface can only update one\n            state = state.length === 1 ? state[0] : true;\n          }\n          dom.removeClass(command.link, CLASS_NAME_COMMAND_DISABLED);\n          if (command.group) {\n            dom.removeClass(command.group, CLASS_NAME_COMMAND_DISABLED);\n          }\n        }\n\n        if (command.state === state) {\n          continue;\n        }\n\n        command.state = state;\n        if (state) {\n          dom.addClass(command.link, CLASS_NAME_COMMAND_ACTIVE);\n          if (command.group) {\n            dom.addClass(command.group, CLASS_NAME_COMMAND_ACTIVE);\n          }\n          if (command.dialog) {\n            if ((typeof state === \"undefined\" ? \"undefined\" : _typeof(state)) === \"object\") {\n              command.dialog.show(state);\n            } else {\n              command.dialog.hide();\n            }\n          }\n        } else {\n          dom.removeClass(command.link, CLASS_NAME_COMMAND_ACTIVE);\n          if (command.group) {\n            dom.removeClass(command.group, CLASS_NAME_COMMAND_ACTIVE);\n          }\n          if (command.dialog) {\n            command.dialog.hide();\n          }\n        }\n      }\n\n      for (i in actionMapping) {\n        action = actionMapping[i];\n\n        if (action.name === \"change_view\") {\n          action.state = this.editor.currentView === this.editor.textarea;\n          if (action.state) {\n            dom.addClass(action.link, CLASS_NAME_ACTION_ACTIVE);\n          } else {\n            dom.removeClass(action.link, CLASS_NAME_ACTION_ACTIVE);\n          }\n        }\n      }\n    },\n\n    show: function show() {\n      this.container.style.display = \"\";\n    },\n\n    hide: function hide() {\n      this.container.style.display = \"none\";\n    }\n  });\n})(wysihtml5);\n/**\n * WYSIHTML5 Editor\n *\n * @param {Element} textareaElement Reference to the textarea which should be turned into a rich text interface\n * @param {Object} [config] See defaultConfig object below for explanation of each individual config option\n *\n * @events\n *    load\n *    beforeload (for internal use only)\n *    focus\n *    focus:composer\n *    focus:textarea\n *    blur\n *    blur:composer\n *    blur:textarea\n *    change\n *    change:composer\n *    change:textarea\n *    paste\n *    paste:composer\n *    paste:textarea\n *    newword:composer\n *    destroy:composer\n *    undo:composer\n *    redo:composer\n *    beforecommand:composer\n *    aftercommand:composer\n *    change_view\n */\n(function (wysihtml5) {\n  var undef;\n\n  var defaultConfig = {\n    // Give the editor a name, the name will also be set as class name on the iframe and on the iframe's body \n    name: undef,\n    // Whether the editor should look like the textarea (by adopting styles)\n    style: true,\n    // Id of the toolbar element, pass falsey value if you don't want any toolbar logic\n    toolbar: undef,\n    // Whether urls, entered by the user should automatically become clickable-links\n    autoLink: true,\n    // Object which includes parser rules to apply when html gets inserted via copy & paste\n    // See parser_rules/*.js for examples\n    parserRules: { tags: { br: {}, span: {}, div: {}, p: {} }, classes: {} },\n    // Parser method to use when the user inserts content via copy & paste\n    parser: wysihtml5.dom.parse,\n    // Class name which should be set on the contentEditable element in the created sandbox iframe, can be styled via the 'stylesheets' option\n    composerClassName: \"wysihtml5-editor\",\n    // Class name to add to the body when the wysihtml5 editor is supported\n    bodyClassName: \"wysihtml5-supported\",\n    // Array (or single string) of stylesheet urls to be loaded in the editor's iframe\n    stylesheets: [],\n    // Placeholder text to use, defaults to the placeholder attribute on the textarea element\n    placeholderText: undef,\n    // Whether the composer should allow the user to manually resize images, tables etc.\n    allowObjectResizing: true,\n    // Whether the rich text editor should be rendered on touch devices (wysihtml5 >= 0.3.0 comes with basic support for iOS 5)\n    supportTouchDevices: true\n  };\n  window.wysihtml5 = wysihtml5;\n  wysihtml5.Editor = wysihtml5.lang.Dispatcher.extend(\n  /** @scope wysihtml5.Editor.prototype */{\n    constructor: function constructor(textareaElement, config) {\n      this.textareaElement = typeof textareaElement === \"string\" ? document.getElementById(textareaElement) : textareaElement;\n      this.config = wysihtml5.lang.object({}).merge(defaultConfig).merge(config).get();\n      this.textarea = new wysihtml5.views.Textarea(this, this.textareaElement, this.config);\n      this.currentView = this.textarea;\n      this._isCompatible = wysihtml5.browser.supported();\n\n      // Sort out unsupported/unwanted browsers here\n      if (!this._isCompatible || !this.config.supportTouchDevices && wysihtml5.browser.isTouchDevice()) {\n        var that = this;\n        setTimeout(function () {\n          that.fire(\"beforeload\").fire(\"load\");\n        }, 0);\n        return;\n      }\n\n      // Add class name to body, to indicate that the editor is supported\n      wysihtml5.dom.addClass(document.body, this.config.bodyClassName);\n\n      this.composer = new wysihtml5.views.Composer(this, this.textareaElement, this.config);\n      this.currentView = this.composer;\n\n      if (typeof this.config.parser === \"function\") {\n        this._initParser();\n      }\n\n      this.observe(\"beforeload\", function () {\n        this.synchronizer = new wysihtml5.views.Synchronizer(this, this.textarea, this.composer);\n        if (this.config.toolbar) {\n          this.toolbar = new wysihtml5.toolbar.Toolbar(this, this.config.toolbar);\n        }\n      });\n\n      try {\n        console.log(\"Heya! This page is using wysihtml5 for rich text editing. Check out https://github.com/xing/wysihtml5\");\n      } catch (e) {}\n    },\n\n    isCompatible: function isCompatible() {\n      return this._isCompatible;\n    },\n\n    clear: function clear() {\n      this.currentView.clear();\n      return this;\n    },\n\n    getValue: function getValue(parse) {\n      return this.currentView.getValue(parse);\n    },\n\n    setValue: function setValue(html, parse) {\n      if (!html) {\n        return this.clear();\n      }\n      this.currentView.setValue(html, parse);\n      return this;\n    },\n\n    focus: function focus(setToEnd) {\n      this.currentView.focus(setToEnd);\n      return this;\n    },\n\n    /**\n     * Deactivate editor (make it readonly)\n     */\n    disable: function disable() {\n      this.currentView.disable();\n      return this;\n    },\n\n    /**\n     * Activate editor\n     */\n    enable: function enable() {\n      this.currentView.enable();\n      return this;\n    },\n\n    isEmpty: function isEmpty() {\n      return this.currentView.isEmpty();\n    },\n\n    hasPlaceholderSet: function hasPlaceholderSet() {\n      return this.currentView.hasPlaceholderSet();\n    },\n\n    parse: function parse(htmlOrElement) {\n      var returnValue = this.config.parser(htmlOrElement, this.config.parserRules, this.composer.sandbox.getDocument(), true);\n      if ((typeof htmlOrElement === \"undefined\" ? \"undefined\" : _typeof(htmlOrElement)) === \"object\") {\n        wysihtml5.quirks.redraw(htmlOrElement);\n      }\n      return returnValue;\n    },\n\n    /**\n     * Prepare html parser logic\n     *  - Observes for paste and drop\n     */\n    _initParser: function _initParser() {\n      this.observe(\"paste:composer\", function () {\n        var keepScrollPosition = true,\n            that = this;\n        that.composer.selection.executeAndRestore(function () {\n          wysihtml5.quirks.cleanPastedHTML(that.composer.element);\n          that.parse(that.composer.element);\n        }, keepScrollPosition);\n      });\n\n      this.observe(\"paste:textarea\", function () {\n        var value = this.textarea.getValue(),\n            newValue;\n        newValue = this.parse(value);\n        this.textarea.setValue(newValue);\n      });\n    }\n  });\n})(wysihtml5);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvanMvd3lzaWh0bWw1LTAuMy4wLmpzPzdlNTUiXSwibmFtZXMiOlsid3lzaWh0bWw1IiwidmVyc2lvbiIsImNvbW1hbmRzIiwiZG9tIiwicXVpcmtzIiwidG9vbGJhciIsImxhbmciLCJzZWxlY3Rpb24iLCJ2aWV3cyIsIklOVklTSUJMRV9TUEFDRSIsIkVNUFRZX0ZVTkNUSU9OIiwiRUxFTUVOVF9OT0RFIiwiVEVYVF9OT0RFIiwiQkFDS1NQQUNFX0tFWSIsIkVOVEVSX0tFWSIsIkVTQ0FQRV9LRVkiLCJTUEFDRV9LRVkiLCJERUxFVEVfS0VZIiwid2luZG93IiwiT0JKRUNUIiwiRlVOQ1RJT04iLCJVTkRFRklORUQiLCJkb21SYW5nZVByb3BlcnRpZXMiLCJkb21SYW5nZU1ldGhvZHMiLCJ0ZXh0UmFuZ2VQcm9wZXJ0aWVzIiwidGV4dFJhbmdlTWV0aG9kcyIsImlzSG9zdE1ldGhvZCIsIm8iLCJwIiwidCIsImlzSG9zdE9iamVjdCIsImlzSG9zdFByb3BlcnR5IiwiY3JlYXRlTXVsdGlwbGVQcm9wZXJ0eVRlc3QiLCJ0ZXN0RnVuYyIsInByb3BzIiwiaSIsImxlbmd0aCIsImFyZUhvc3RNZXRob2RzIiwiYXJlSG9zdE9iamVjdHMiLCJhcmVIb3N0UHJvcGVydGllcyIsImlzVGV4dFJhbmdlIiwicmFuZ2UiLCJhcGkiLCJpbml0aWFsaXplZCIsInN1cHBvcnRlZCIsInV0aWwiLCJmZWF0dXJlcyIsIm1vZHVsZXMiLCJjb25maWciLCJhbGVydE9uV2FybiIsInByZWZlclRleHRSYW5nZSIsImZhaWwiLCJyZWFzb24iLCJhbGVydCIsIndhcm4iLCJtc2ciLCJ3YXJuaW5nTWVzc2FnZSIsImNvbnNvbGUiLCJsb2ciLCJoYXNPd25Qcm9wZXJ0eSIsImV4dGVuZCIsImluaXRMaXN0ZW5lcnMiLCJtb2R1bGVJbml0aWFsaXplcnMiLCJpbml0IiwidGVzdFJhbmdlIiwiaW1wbGVtZW50c0RvbVJhbmdlIiwiaW1wbGVtZW50c1RleHRSYW5nZSIsImRvY3VtZW50IiwiY3JlYXRlUmFuZ2UiLCJkZXRhY2giLCJib2R5IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJjcmVhdGVUZXh0UmFuZ2UiLCJhbGxMaXN0ZW5lcnMiLCJjb25jYXQiLCJsZW4iLCJleCIsImFkZEluaXRMaXN0ZW5lciIsImxpc3RlbmVyIiwicHVzaCIsImNyZWF0ZU1pc3NpbmdOYXRpdmVBcGlMaXN0ZW5lcnMiLCJhZGRDcmVhdGVNaXNzaW5nTmF0aXZlQXBpTGlzdGVuZXIiLCJjcmVhdGVNaXNzaW5nTmF0aXZlQXBpIiwid2luIiwiTW9kdWxlIiwibmFtZSIsInByb3RvdHlwZSIsIkVycm9yIiwiY3JlYXRlRXJyb3IiLCJjcmVhdGVNb2R1bGUiLCJpbml0RnVuYyIsIm1vZHVsZSIsInJlcXVpcmVNb2R1bGVzIiwibW9kdWxlTmFtZSIsImRvY1JlYWR5IiwibG9hZEhhbmRsZXIiLCJlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwicmFuZ3kiLCJVTkRFRiIsImVsIiwiY3JlYXRlRWxlbWVudCIsInRleHROb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJhcnJheUNvbnRhaW5zIiwiYXJyIiwidmFsIiwiaXNIdG1sTmFtZXNwYWNlIiwibm9kZSIsIm5zIiwibmFtZXNwYWNlVVJJIiwicGFyZW50RWxlbWVudCIsInBhcmVudCIsInBhcmVudE5vZGUiLCJub2RlVHlwZSIsImdldE5vZGVJbmRleCIsInByZXZpb3VzU2libGluZyIsImdldE5vZGVMZW5ndGgiLCJjaGlsZE5vZGVzIiwiaXNDaGFyYWN0ZXJEYXRhTm9kZSIsImdldENvbW1vbkFuY2VzdG9yIiwibm9kZTEiLCJub2RlMiIsImFuY2VzdG9ycyIsIm4iLCJpc0FuY2VzdG9yT2YiLCJhbmNlc3RvciIsImRlc2NlbmRhbnQiLCJzZWxmSXNBbmNlc3RvciIsImdldENsb3Nlc3RBbmNlc3RvckluIiwiaW5zZXJ0QWZ0ZXIiLCJwcmVjZWRpbmdOb2RlIiwibmV4dE5vZGUiLCJuZXh0U2libGluZyIsImluc2VydEJlZm9yZSIsImFwcGVuZENoaWxkIiwic3BsaXREYXRhTm9kZSIsImluZGV4IiwibmV3Tm9kZSIsImNsb25lTm9kZSIsImRlbGV0ZURhdGEiLCJnZXREb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCJnZXRXaW5kb3ciLCJkb2MiLCJkZWZhdWx0VmlldyIsInBhcmVudFdpbmRvdyIsImdldElmcmFtZURvY3VtZW50IiwiaWZyYW1lRWwiLCJjb250ZW50RG9jdW1lbnQiLCJjb250ZW50V2luZG93IiwiZ2V0SWZyYW1lV2luZG93IiwiZ2V0Qm9keSIsImdldFJvb3RDb250YWluZXIiLCJjb21wYXJlUG9pbnRzIiwibm9kZUEiLCJvZmZzZXRBIiwibm9kZUIiLCJvZmZzZXRCIiwibm9kZUMiLCJyb290IiwiY2hpbGRBIiwiY2hpbGRCIiwiZmlyc3RDaGlsZCIsImZyYWdtZW50RnJvbU5vZGVDaGlsZHJlbiIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImNoaWxkIiwiaW5zcGVjdE5vZGUiLCJkYXRhIiwiaWRBdHRyIiwiaWQiLCJub2RlTmFtZSIsIk5vZGVJdGVyYXRvciIsIl9uZXh0IiwiX2N1cnJlbnQiLCJoYXNOZXh0IiwibmV4dCIsImNyZWF0ZUl0ZXJhdG9yIiwiRG9tUG9zaXRpb24iLCJvZmZzZXQiLCJlcXVhbHMiLCJwb3MiLCJpbnNwZWN0IiwiRE9NRXhjZXB0aW9uIiwiY29kZU5hbWUiLCJjb2RlIiwibWVzc2FnZSIsIklOREVYX1NJWkVfRVJSIiwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSIiwiV1JPTkdfRE9DVU1FTlRfRVJSIiwiTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSIiwiTk9UX0ZPVU5EX0VSUiIsIk5PVF9TVVBQT1JURURfRVJSIiwiSU5WQUxJRF9TVEFURV9FUlIiLCJ0b1N0cmluZyIsImlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkIiwic3RhcnRDb250YWluZXIiLCJlbmRDb250YWluZXIiLCJnZXRSYW5nZURvY3VtZW50IiwiZGlzcGF0Y2hFdmVudCIsInR5cGUiLCJhcmdzIiwibGlzdGVuZXJzIiwiX2xpc3RlbmVycyIsImNhbGwiLCJ0YXJnZXQiLCJnZXRCb3VuZGFyeUJlZm9yZU5vZGUiLCJnZXRCb3VuZGFyeUFmdGVyTm9kZSIsImluc2VydE5vZGVBdFBvc2l0aW9uIiwiZmlyc3ROb2RlSW5zZXJ0ZWQiLCJjbG9uZVN1YnRyZWUiLCJpdGVyYXRvciIsInBhcnRpYWxseVNlbGVjdGVkIiwiZnJhZyIsInN1Ykl0ZXJhdG9yIiwiaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUiLCJnZXRTdWJ0cmVlSXRlcmF0b3IiLCJpdGVyYXRlU3VidHJlZSIsInJhbmdlSXRlcmF0b3IiLCJmdW5jIiwiaXRlcmF0b3JTdGF0ZSIsIml0Iiwic3RvcCIsInN1YlJhbmdlSXRlcmF0b3IiLCJkZWxldGVTdWJ0cmVlIiwicmVtb3ZlIiwiZXh0cmFjdFN1YnRyZWUiLCJnZXROb2Rlc0luUmFuZ2UiLCJub2RlVHlwZXMiLCJmaWx0ZXIiLCJmaWx0ZXJOb2RlVHlwZXMiLCJyZWdleCIsImZpbHRlckV4aXN0cyIsIlJlZ0V4cCIsImpvaW4iLCJub2RlcyIsIlJhbmdlSXRlcmF0b3IiLCJ0ZXN0IiwiZ2V0TmFtZSIsInN0YXJ0T2Zmc2V0IiwiZW5kT2Zmc2V0IiwiY2xvbmVQYXJ0aWFsbHlTZWxlY3RlZFRleHROb2RlcyIsImNvbGxhcHNlZCIsInNjIiwic28iLCJlYyIsImVvIiwiY29tbW9uQW5jZXN0b3JDb250YWluZXIiLCJpc1NpbmdsZUNoYXJhY3RlckRhdGFOb2RlIiwiX2ZpcnN0IiwiX2xhc3QiLCJyZXNldCIsImN1cnJlbnQiLCJzdGFydCIsImVuZCIsInJlbW92ZUNoaWxkIiwic3ViUmFuZ2UiLCJjbG9uZVJhbmdlIiwiY29sbGFwc2UiLCJSYW5nZSIsInVwZGF0ZUJvdW5kYXJpZXMiLCJkZXRhY2hSYW5nZSIsIlJhbmdlRXhjZXB0aW9uIiwiQkFEX0JPVU5EQVJZUE9JTlRTX0VSUiIsIklOVkFMSURfTk9ERV9UWVBFX0VSUiIsIlJhbmdlTm9kZUl0ZXJhdG9yIiwiX3Bvc2l0aW9uIiwiYmVmb3JlQWZ0ZXJOb2RlVHlwZXMiLCJyb290Q29udGFpbmVyTm9kZVR5cGVzIiwicmVhZG9ubHlOb2RlVHlwZXMiLCJpbnNlcnRhYmxlTm9kZVR5cGVzIiwic3Vycm91bmROb2RlVHlwZXMiLCJjcmVhdGVBbmNlc3RvckZpbmRlciIsImdldERvY3VtZW50T3JGcmFnbWVudENvbnRhaW5lciIsImdldFJlYWRvbmx5QW5jZXN0b3IiLCJnZXREb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3RvciIsImFzc2VydE5vRG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3IiLCJhbGxvd1NlbGYiLCJhc3NlcnROb3REZXRhY2hlZCIsImFzc2VydFZhbGlkTm9kZVR5cGUiLCJpbnZhbGlkVHlwZXMiLCJhc3NlcnRWYWxpZE9mZnNldCIsImFzc2VydFNhbWVEb2N1bWVudE9yRnJhZ21lbnQiLCJhc3NlcnROb2RlTm90UmVhZE9ubHkiLCJhc3NlcnROb2RlIiwiaXNPcnBoYW4iLCJpc1ZhbGlkT2Zmc2V0IiwiYXNzZXJ0UmFuZ2VWYWxpZCIsInN0eWxlRWwiLCJodG1sUGFyc2luZ0NvbmZvcm1zIiwiaW5uZXJIVE1MIiwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IiwiZnJhZ21lbnRTdHIiLCJkb2N1bWVudEVsZW1lbnQiLCJyYW5nZVByb3BlcnRpZXMiLCJzMnMiLCJzMmUiLCJlMmUiLCJlMnMiLCJuX2IiLCJuX2EiLCJuX2JfYSIsIm5faSIsIlJhbmdlUHJvdG90eXBlIiwiYXR0YWNoTGlzdGVuZXIiLCJjb21wYXJlQm91bmRhcnlQb2ludHMiLCJob3ciLCJwcmVmaXhBIiwicHJlZml4QiIsImluc2VydE5vZGUiLCJzZXRTdGFydEJlZm9yZSIsImNsb25lQ29udGVudHMiLCJjbG9uZSIsInNsaWNlIiwiY2FuU3Vycm91bmRDb250ZW50cyIsImJvdW5kYXJpZXNJbnZhbGlkIiwic3Vycm91bmRDb250ZW50cyIsImNvbnRlbnQiLCJleHRyYWN0Q29udGVudHMiLCJoYXNDaGlsZE5vZGVzIiwibGFzdENoaWxkIiwic2VsZWN0Tm9kZSIsInByb3AiLCJ0ZXh0Qml0cyIsImNvbXBhcmVOb2RlIiwibm9kZUluZGV4Iiwic3RhcnRDb21wYXJpc29uIiwiY29tcGFyZVBvaW50IiwiZW5kQ29tcGFyaXNvbiIsInRvSHRtbCIsImNvbnRhaW5lciIsImludGVyc2VjdHNOb2RlIiwidG91Y2hpbmdJc0ludGVyc2VjdGluZyIsImlzUG9pbnRJblJhbmdlIiwiaW50ZXJzZWN0c1JhbmdlIiwiaW50ZXJzZWN0aW9uIiwiaW50ZXJzZWN0aW9uUmFuZ2UiLCJzZXRTdGFydCIsInNldEVuZCIsInVuaW9uIiwidW5pb25SYW5nZSIsImNvbnRhaW5zTm9kZSIsImFsbG93UGFydGlhbCIsImNvbnRhaW5zTm9kZUNvbnRlbnRzIiwiY29udGFpbnNSYW5nZSIsImNvbnRhaW5zTm9kZVRleHQiLCJub2RlUmFuZ2UiLCJ0ZXh0Tm9kZXMiLCJnZXROb2RlcyIsImxhc3RUZXh0Tm9kZSIsInBvcCIsImNvbnRhaW5zIiwiY3JlYXRlTm9kZUl0ZXJhdG9yIiwiY29sbGFwc2VCZWZvcmUiLCJzZXRFbmRCZWZvcmUiLCJjb2xsYXBzZUFmdGVyIiwic2V0U3RhcnRBZnRlciIsInJhbmdlc0VxdWFsIiwiY29weUNvbXBhcmlzb25Db25zdGFudHNUb09iamVjdCIsIm9iaiIsIlNUQVJUX1RPX1NUQVJUIiwiU1RBUlRfVE9fRU5EIiwiRU5EX1RPX0VORCIsIkVORF9UT19TVEFSVCIsIk5PREVfQkVGT1JFIiwiTk9ERV9BRlRFUiIsIk5PREVfQkVGT1JFX0FORF9BRlRFUiIsIk5PREVfSU5TSURFIiwiY29weUNvbXBhcmlzb25Db25zdGFudHMiLCJjb25zdHJ1Y3RvciIsImNyZWF0ZVJhbmdlQ29udGVudFJlbW92ZXIiLCJyZW1vdmVyIiwiYm91bmRhcnlVcGRhdGVyIiwiYm91bmRhcnkiLCJyZXR1cm5WYWx1ZSIsImNyZWF0ZVByb3RvdHlwZVJhbmdlIiwiZGV0YWNoZXIiLCJjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIiLCJpc0JlZm9yZSIsImlzU3RhcnQiLCJzZXRSYW5nZVN0YXJ0Iiwic2V0UmFuZ2VFbmQiLCJzZXRSYW5nZVN0YXJ0QW5kRW5kIiwic2V0RW5kQWZ0ZXIiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJkZWxldGVDb250ZW50cyIsInNwbGl0Qm91bmRhcmllcyIsInN0YXJ0RW5kU2FtZSIsIm5vcm1hbGl6ZUJvdW5kYXJpZXMiLCJtZXJnZUZvcndhcmQiLCJzaWJsaW5nIiwiYXBwZW5kRGF0YSIsIm1lcmdlQmFja3dhcmQiLCJub2RlTGVuZ3RoIiwiaW5zZXJ0RGF0YSIsIm5vcm1hbGl6ZVN0YXJ0IiwiZW5kTm9kZSIsInN0YXJ0Tm9kZSIsImNvbGxhcHNlVG9Qb2ludCIsInVwZGF0ZUNvbGxhcHNlZEFuZENvbW1vbkFuY2VzdG9yIiwic3RhcnRNb3ZlZCIsImVuZE1vdmVkIiwiYm91bmRhcnljaGFuZ2UiLCJyYW5nZVByb3RvdHlwZSIsInIxIiwicjIiLCJEb21SYW5nZSIsIldyYXBwZWRSYW5nZSIsImdldFRleHRSYW5nZUNvbnRhaW5lckVsZW1lbnQiLCJ0ZXh0UmFuZ2UiLCJwYXJlbnRFbCIsImR1cGxpY2F0ZSIsInN0YXJ0RWwiLCJlbmRFbCIsInN0YXJ0RW5kQ29udGFpbmVyIiwidGV4dFJhbmdlSXNDb2xsYXBzZWQiLCJjb21wYXJlRW5kUG9pbnRzIiwiZ2V0VGV4dFJhbmdlQm91bmRhcnlQb3NpdGlvbiIsIndob2xlUmFuZ2VDb250YWluZXJFbGVtZW50IiwiaXNDb2xsYXBzZWQiLCJ3b3JraW5nUmFuZ2UiLCJjb250YWluZXJFbGVtZW50IiwiY2FuSGF2ZUhUTUwiLCJ3b3JraW5nTm9kZSIsImNvbXBhcmlzb24iLCJ3b3JraW5nQ29tcGFyaXNvblR5cGUiLCJwcmV2aW91c05vZGUiLCJib3VuZGFyeVBvc2l0aW9uIiwiYm91bmRhcnlOb2RlIiwibW92ZVRvRWxlbWVudFRleHQiLCJzZXRFbmRQb2ludCIsInRlbXBSYW5nZSIsInJhbmdlTGVuZ3RoIiwidGV4dCIsInJlcGxhY2UiLCJtb3ZlU3RhcnQiLCJjcmVhdGVCb3VuZGFyeVRleHRSYW5nZSIsImJvdW5kYXJ5UGFyZW50IiwiYm91bmRhcnlPZmZzZXQiLCJub2RlSXNEYXRhTm9kZSIsInJhbmdlUHJvdG8iLCJjYW5TZXRSYW5nZVN0YXJ0QWZ0ZXJFbmQiLCJ1cGRhdGVSYW5nZVByb3BlcnRpZXMiLCJuYXRpdmVSYW5nZSIsInVwZGF0ZU5hdGl2ZVJhbmdlIiwiZGV0YWNoZWQiLCJyZWZyZXNoIiwidGVzdFRleHROb2RlIiwib3Bwb3NpdGVOYW1lIiwiZ2V0RW5kT2Zmc2V0IiwicmFuZ2UyIiwiY3JlYXRlTmF0aXZlUmFuZ2UiLCJyYW5nZUNvbnRhaW5lckVsZW1lbnQiLCJnbG9iYWxPYmoiLCJyYW5nZVRvVGV4dFJhbmdlIiwidHIiLCJzdGFydFJhbmdlIiwiZW5kUmFuZ2UiLCJjcmVhdGVSYW5neVJhbmdlIiwiY3JlYXRlSWZyYW1lUmFuZ2UiLCJjcmVhdGVJZnJhbWVSYW5neVJhbmdlIiwiY2hlY2tTZWxlY3Rpb25SYW5nZXMiLCJCT09MRUFOIiwid2luZG93UHJvcGVydHlOYW1lIiwiZ2V0U2VsZWN0aW9uIiwic2VsZWN0aW9uSXNDb2xsYXBzZWQiLCJDT05UUk9MIiwiZ2V0V2luU2VsZWN0aW9uIiwid2luUGFyYW0iLCJnZXREb2NTZWxlY3Rpb24iLCJpbXBsZW1lbnRzV2luR2V0U2VsZWN0aW9uIiwiaW1wbGVtZW50c0RvY1NlbGVjdGlvbiIsInVzZURvY3VtZW50U2VsZWN0aW9uIiwiaXNTZWxlY3Rpb25WYWxpZCIsIm5hdGl2ZVNlbCIsImdldE5hdGl2ZVNlbGVjdGlvbiIsInRlc3RTZWxlY3Rpb24iLCJzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cyIsInNlbGVjdGlvbkhhc0V4dGVuZCIsInNlbGVjdGlvbkhhc1JhbmdlQ291bnQiLCJyYW5nZUNvdW50Iiwic2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcyIsImNvbGxhcHNlZE5vbkVkaXRhYmxlU2VsZWN0aW9uc1N1cHBvcnRlZCIsImlmcmFtZSIsImlmcmFtZURvYyIsIm9wZW4iLCJ3cml0ZSIsImNsb3NlIiwic2VsIiwiZG9jRWwiLCJpZnJhbWVCb2R5IiwiYWRkUmFuZ2UiLCJyZW1vdmVBbGxSYW5nZXMiLCJpbXBsZW1lbnRzQ29udHJvbFJhbmdlIiwidGVzdENvbnRyb2xSYW5nZSIsImNyZWF0ZUNvbnRyb2xSYW5nZSIsImFuY2hvck5vZGUiLCJmb2N1c05vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c09mZnNldCIsImdldFJhbmdlQXQiLCJ1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZSIsImJhY2t3YXJkcyIsImFuY2hvclByZWZpeCIsImZvY3VzUHJlZml4IiwidXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tTmF0aXZlU2VsZWN0aW9uIiwibmF0aXZlU2VsZWN0aW9uIiwidXBkYXRlRW1wdHlTZWxlY3Rpb24iLCJfcmFuZ2VzIiwiZ2V0TmF0aXZlUmFuZ2UiLCJfc2VsZWN0aW9uTmF0aXZlUmFuZ2UiLCJyYW5nZUNvbnRhaW5zU2luZ2xlRWxlbWVudCIsInJhbmdlTm9kZXMiLCJnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlIiwidXBkYXRlRnJvbVRleHRSYW5nZSIsIndyYXBwZWRSYW5nZSIsInVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24iLCJkb2NTZWxlY3Rpb24iLCJjb250cm9sUmFuZ2UiLCJpdGVtIiwiYWRkUmFuZ2VUb0NvbnRyb2xTZWxlY3Rpb24iLCJyYW5nZUVsZW1lbnQiLCJuZXdDb250cm9sUmFuZ2UiLCJhZGQiLCJzZWxlY3QiLCJnZXRTZWxlY3Rpb25SYW5nZUF0IiwiV3JhcHBlZFNlbGVjdGlvbiIsImRvY1NlbCIsImdldElmcmFtZVNlbGVjdGlvbiIsInNlbFByb3RvIiwiY3JlYXRlQ29udHJvbFNlbGVjdGlvbiIsInJhbmdlcyIsImFkZFJhbmdlQmFja3dhcmRzIiwicHJldmlvdXNSYW5nZUNvdW50Iiwic2VsZWN0aW9uSXNCYWNrd2FyZHMiLCJzZXRSYW5nZXMiLCJlbXB0eSIsInJlZnJlc2hTZWxlY3Rpb24iLCJjaGVja0ZvckNoYW5nZXMiLCJvbGRSYW5nZXMiLCJyZW1vdmVSYW5nZU1hbnVhbGx5IiwiZ2V0QWxsUmFuZ2VzIiwicmVtb3ZlZCIsInJlbW92ZVJhbmdlIiwiaXNCYWNrd2FyZHMiLCJyYW5nZVRleHRzIiwiYXNzZXJ0Tm9kZUluU2FtZURvY3VtZW50IiwiY29sbGFwc2VUb1N0YXJ0IiwiY29sbGFwc2VUb0VuZCIsInNlbGVjdEFsbENoaWxkcmVuIiwiZGVsZXRlRnJvbURvY3VtZW50IiwiZWxlbWVudCIsInNldFNpbmdsZVJhbmdlIiwiaHRtbCIsInJhbmdlSW5zcGVjdHMiLCJhbmNob3IiLCJmb2N1cyIsIlNlbGVjdGlvbiIsInNlbGVjdGlvblByb3RvdHlwZSIsIkJhc2UiLCJfaW5zdGFuY2UiLCJfc3RhdGljIiwiX3Byb3RvdHlwaW5nIiwicHJvdG8iLCJiYXNlIiwia2xhc3MiLCJfY29uc3RydWN0aW5nIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiaW1wbGVtZW50IiwidmFsdWVPZiIsInNvdXJjZSIsInZhbHVlIiwibWV0aG9kIiwicHJldmlvdXMiLCJ0b1NvdXJjZSIsImhpZGRlbiIsImtleSIsIk9iamVjdCIsIm9iamVjdCIsImJsb2NrIiwiY29udGV4dCIsInVuZGVmaW5lZCIsIlN0cmluZyIsImJyb3dzZXIiLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJ0ZXN0RWxlbWVudCIsImlzSUUiLCJpbmRleE9mIiwiaXNHZWNrbyIsImlzV2ViS2l0IiwiaXNDaHJvbWUiLCJpc09wZXJhIiwiaW9zVmVyc2lvbiIsIm1hdGNoIiwiVVNFUl9BR0VOVCIsInRvTG93ZXJDYXNlIiwiaGFzQ29udGVudEVkaXRhYmxlU3VwcG9ydCIsImhhc0VkaXRpbmdBcGlTdXBwb3J0IiwiZXhlY0NvbW1hbmQiLCJxdWVyeUNvbW1hbmRTdXBwb3J0ZWQiLCJxdWVyeUNvbW1hbmRTdGF0ZSIsImhhc1F1ZXJ5U2VsZWN0b3JTdXBwb3J0IiwicXVlcnlTZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpc0luY29tcGF0aWJsZU1vYmlsZUJyb3dzZXIiLCJpc0lvcyIsImlzVG91Y2hEZXZpY2UiLCJzdXBwb3J0c0V2ZW50Iiwic3VwcG9ydHNTYW5kYm94ZWRJZnJhbWVzIiwidGhyb3dzTWl4ZWRDb250ZW50V2FybmluZ1doZW5JZnJhbWVTcmNJc0VtcHR5IiwiZGlzcGxheXNDYXJldEluRW1wdHlDb250ZW50RWRpdGFibGVDb3JyZWN0bHkiLCJoYXNDdXJyZW50U3R5bGVQcm9wZXJ0eSIsImluc2VydHNMaW5lQnJlYWtzT25SZXR1cm4iLCJzdXBwb3J0c1BsYWNlaG9sZGVyQXR0cmlidXRlT24iLCJldmVudE5hbWUiLCJzZXRBdHRyaWJ1dGUiLCJzdXBwb3J0c0V2ZW50c0luSWZyYW1lQ29ycmVjdGx5IiwiZmlyZXNPbkRyb3BPbmx5V2hlbk9uRHJhZ092ZXJJc0NhbmNlbGxlZCIsInN1cHBvcnRzRGF0YVRyYW5zZmVyIiwiQ2xpcGJvYXJkIiwiRGF0YVRyYW5zZmVyIiwiZ2V0RGF0YSIsInN1cHBvcnRzSFRNTDVUYWdzIiwiaHRtbDUiLCJzdXBwb3J0c0NvbW1hbmQiLCJidWdneUNvbW1hbmRzIiwiY29tbWFuZCIsImlzQnVnZ3kiLCJlMSIsInF1ZXJ5Q29tbWFuZEVuYWJsZWQiLCJlMiIsImRvZXNBdXRvTGlua2luZ0luQ29udGVudEVkaXRhYmxlIiwiY2FuRGlzYWJsZUF1dG9MaW5raW5nIiwiY2xlYXJzQ29udGVudEVkaXRhYmxlQ29ycmVjdGx5Iiwic3VwcG9ydHNHZXRBdHRyaWJ1dGVDb3JyZWN0bHkiLCJ0ZCIsImdldEF0dHJpYnV0ZSIsImNhblNlbGVjdEltYWdlc0luQ29udGVudEVkaXRhYmxlIiwiY2xlYXJzTGlzdHNJbkNvbnRlbnRFZGl0YWJsZUNvcnJlY3RseSIsImF1dG9TY3JvbGxzVG9DYXJldCIsImF1dG9DbG9zZXNVbmNsb3NlZFRhZ3MiLCJjbG9uZWRUZXN0RWxlbWVudCIsInN1cHBvcnRzTmF0aXZlR2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJzdXBwb3J0c1NlbGVjdGlvbk1vZGlmeSIsInN1cHBvcnRzQ2xhc3NMaXN0IiwibmVlZHNTcGFjZUFmdGVyTGluZUJyZWFrIiwic3VwcG9ydHNTcGVlY2hBcGlPbiIsImlucHV0IiwiY2hyb21lVmVyc2lvbiIsImNyYXNoZXNXaGVuRGVmaW5lUHJvcGVydHkiLCJwcm9wZXJ0eSIsImRvZXNBc3luY0ZvY3VzIiwiaGFzUHJvYmxlbXNTZXR0aW5nQ2FyZXRBZnRlckltZyIsImhhc1VuZG9JbkNvbnRleHRNZW51IiwiYXJyYXkiLCJuZWVkbGUiLCJ3aXRob3V0IiwiYXJyYXlUb1N1YnN0cmFjdCIsIm5ld0FyciIsImdldCIsIm5ld0FycmF5IiwiRGlzcGF0Y2hlciIsIm9ic2VydmUiLCJoYW5kbGVyIiwiZXZlbnRzIiwib24iLCJmaXJlIiwicGF5bG9hZCIsImhhbmRsZXJzIiwic3RvcE9ic2VydmluZyIsIm5ld0hhbmRsZXJzIiwibWVyZ2UiLCJvdGhlck9iaiIsIm5ld09iaiIsImlzQXJyYXkiLCJXSElURV9TUEFDRV9TVEFSVCIsIldISVRFX1NQQUNFX0VORCIsInN0cmluZyIsInN0ciIsInRyaW0iLCJpbnRlcnBvbGF0ZSIsInZhcnMiLCJieSIsInNlYXJjaCIsInNwbGl0IiwiSUdOT1JFX1VSTFNfSU4iLCJVUkxfUkVHX0VYUCIsIlRSQUlMSU5HX0NIQVJfUkVHX0VYUCIsIk1BWF9ESVNQTEFZX0xFTkdUSCIsIkJSQUNLRVRTIiwiYXV0b0xpbmsiLCJfaGFzUGFyZW50VGhhdFNob3VsZEJlSWdub3JlZCIsIl9wYXJzZU5vZGUiLCJfY29udmVydFVybHNUb0xpbmtzIiwidXJsIiwicHVuY3R1YXRpb24iLCJvcGVuaW5nIiwicmVhbFVybCIsImRpc3BsYXlVcmwiLCJzdWJzdHIiLCJfZ2V0VGVtcEVsZW1lbnQiLCJ0ZW1wRWxlbWVudCIsIl93eXNpaHRtbDVfdGVtcEVsZW1lbnQiLCJfd3JhcE1hdGNoZXNJbk5vZGUiLCJjaGlsZE5vZGVzTGVuZ3RoIiwiYWRkQ2xhc3MiLCJjbGFzc05hbWUiLCJjbGFzc0xpc3QiLCJoYXNDbGFzcyIsInJlbW92ZUNsYXNzIiwiZWxlbWVudENsYXNzTmFtZSIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiY29udmVydFRvTGlzdCIsIl9jcmVhdGVMaXN0SXRlbSIsImxpc3QiLCJsaXN0SXRlbSIsIl9jcmVhdGVMaXN0IiwibGlzdFR5cGUiLCJsaW5lQnJlYWtzIiwibGluZUJyZWFrc0xlbmd0aCIsImNoaWxkTm9kZSIsImxpbmVCcmVhayIsImlzQmxvY2tFbGVtZW50IiwiaXNMaW5lQnJlYWsiLCJjdXJyZW50TGlzdEl0ZW0iLCJnZXRTdHlsZSIsImZyb20iLCJpbnNlcnQiLCJhZnRlciIsInJlcGxhY2VDaGlsZCIsImNvcHlBdHRyaWJ1dGVzIiwiYXR0cmlidXRlc1RvQ29weSIsImVsZW1lbnRUb0NvcHlGcm9tIiwidG8iLCJlbGVtZW50VG9Db3B5VG8iLCJhdHRyaWJ1dGUiLCJhbmRUbyIsImNhbGxlZSIsIkJPWF9TSVpJTkdfUFJPUEVSVElFUyIsInNob3VsZElnbm9yZUJveFNpemluZ0JvcmRlckJveCIsImhhc0JveFNpemluZ0JvcmRlckJveCIsInBhcnNlSW50Iiwib2Zmc2V0V2lkdGgiLCJjb3B5U3R5bGVzIiwic3R5bGVzVG9Db3B5IiwiY3NzVGV4dCIsInNldFN0eWxlcyIsImRlbGVnYXRlIiwic2VsZWN0b3IiLCJldmVudCIsImdldEFzRG9tIiwiX2lubmVySFRNTFNoaXYiLCJzdHlsZSIsImRpc3BsYXkiLCJfZW5zdXJlSFRNTDVDb21wYXRpYmlsaXR5IiwiX3d5c2lodG1sNV9zdXBwb3J0c0hUTUw1VGFncyIsIkhUTUw1X0VMRU1FTlRTIiwiZ2V0UGFyZW50RWxlbWVudCIsIl9pc1NhbWVOb2RlTmFtZSIsImRlc2lyZWROb2RlTmFtZXMiLCJfaXNFbGVtZW50IiwiX2hhc0NsYXNzTmFtZSIsImNsYXNzUmVnRXhwIiwiY2xhc3NOYW1lcyIsIl9nZXRQYXJlbnRFbGVtZW50V2l0aE5vZGVOYW1lIiwibGV2ZWxzIiwiX2dldFBhcmVudEVsZW1lbnRXaXRoTm9kZU5hbWVBbmRDbGFzc05hbWUiLCJtYXRjaGluZ1NldCIsInN0eWxlUHJvcGVydHlNYXBwaW5nIiwiUkVHX0VYUF9DQU1FTElaRSIsImNhbWVsaXplIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJjYW1lbGl6ZWRQcm9wZXJ0eSIsImN1cnJlbnRTdHlsZSIsInN0eWxlVmFsdWUiLCJuZWVkc092ZXJmbG93UmVzZXQiLCJvcmlnaW5hbE92ZXJmbG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm92ZXJmbG93IiwiZ2V0UHJvcGVydHlWYWx1ZSIsImhhc0VsZW1lbnRXaXRoVGFnTmFtZSIsIkxJVkVfQ0FDSEUiLCJET0NVTUVOVF9JREVOVElGSUVSIiwiX2dldERvY3VtZW50SWRlbnRpZmllciIsIl93eXNpaHRtbDVfaWRlbnRpZmllciIsInRhZ05hbWUiLCJjYWNoZUVudHJ5IiwiaGFzRWxlbWVudFdpdGhDbGFzc05hbWUiLCJlbGVtZW50VG9JbnNlcnQiLCJiZWZvcmUiLCJpbnRvIiwiaW5zZXJ0Q1NTIiwicnVsZXMiLCJoZWFkIiwic3R5bGVFbGVtZW50Iiwic3R5bGVTaGVldCIsImV2ZW50TmFtZXMiLCJoYW5kbGVyV3JhcHBlciIsInNyY0VsZW1lbnQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImNhbmNlbEJ1YmJsZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXRhY2hFdmVudCIsInBhcnNlIiwiTk9ERV9UWVBFX01BUFBJTkciLCJfaGFuZGxlRWxlbWVudCIsIl9oYW5kbGVUZXh0IiwiREVGQVVMVF9OT0RFX05BTUUiLCJXSElURV9TUEFDRV9SRUdfRVhQIiwiZGVmYXVsdFJ1bGVzIiwidGFncyIsImNsYXNzZXMiLCJjdXJyZW50UnVsZXMiLCJlbGVtZW50T3JIdG1sIiwiY2xlYW5VcCIsImlzU3RyaW5nIiwiX2NvbnZlcnQiLCJnZXRDb3JyZWN0SW5uZXJIVE1MIiwib2xkTm9kZSIsIm9sZE5vZGVUeXBlIiwib2xkQ2hpbGRzIiwib2xkQ2hpbGRzTGVuZ3RoIiwibmV3Q2hpbGQiLCJhdHRyaWJ1dGVzIiwicnVsZSIsImVuZFRhZyIsInRhZ1J1bGVzIiwic2NvcGVOYW1lIiwiX3d5c2lodG1sNSIsIm91dGVySFRNTCIsInJlbmFtZV90YWciLCJfaGFuZGxlQXR0cmlidXRlcyIsInNldENsYXNzIiwic2V0X2NsYXNzIiwiYWRkX2NsYXNzIiwic2V0QXR0cmlidXRlcyIsInNldF9hdHRyaWJ1dGVzIiwiY2hlY2tBdHRyaWJ1dGVzIiwiY2hlY2tfYXR0cmlidXRlcyIsImFsbG93ZWRDbGFzc2VzIiwibmV3Q2xhc3NlcyIsIm5ld1VuaXF1ZUNsYXNzZXMiLCJvbGRDbGFzc2VzIiwiY2xhc3Nlc0xlbmd0aCIsIm5ld0NsYXNzZXNMZW5ndGgiLCJjdXJyZW50Q2xhc3MiLCJuZXdDbGFzcyIsImF0dHJpYnV0ZU5hbWUiLCJuZXdBdHRyaWJ1dGVWYWx1ZSIsImF0dHJpYnV0ZUNoZWNrTWV0aG9kcyIsIl9nZXRBdHRyaWJ1dGUiLCJhZGRDbGFzc01ldGhvZHMiLCJ1bnNoaWZ0Iiwic3JjIiwid2lkdGgiLCJoZWlnaHQiLCJIQVNfR0VUX0FUVFJJQlVURV9CVUciLCJfaXNMb2FkZWRJbWFnZSIsImhhc0F0dHJpYnV0ZSIsImNvbXBsZXRlIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwicmVhZHlTdGF0ZSIsIlJFR19FWFAiLCJhdHRyaWJ1dGVWYWx1ZSIsImFsdCIsIm51bWJlcnMiLCJhbGlnbl9pbWciLCJtYXBwaW5nIiwibGVmdCIsInJpZ2h0IiwiYWxpZ25fdGV4dCIsImNlbnRlciIsImp1c3RpZnkiLCJjbGVhcl9iciIsImJvdGgiLCJhbGwiLCJzaXplX2ZvbnQiLCJyZW1vdmVFbXB0eVRleHROb2RlcyIsInJlbmFtZUVsZW1lbnQiLCJuZXdOb2RlTmFtZSIsIm5ld0VsZW1lbnQiLCJyZXBsYWNlV2l0aENoaWxkTm9kZXMiLCJfaXNCbG9ja0VsZW1lbnQiLCJfaXNMaW5lQnJlYWsiLCJfYXBwZW5kTGluZUJyZWFrIiwicmVzb2x2ZUxpc3QiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwiaXNMYXN0Q2hpbGQiLCJzaG91bGRBcHBlbmRMaW5lQnJlYWsiLCJ3aW5kb3dQcm9wZXJ0aWVzIiwid2luZG93UHJvcGVydGllczIiLCJkb2N1bWVudFByb3BlcnRpZXMiLCJTYW5kYm94IiwicmVhZHlDYWxsYmFjayIsImNhbGxiYWNrIiwiX2NyZWF0ZUlmcmFtZSIsImluc2VydEludG8iLCJnZXRFbGVtZW50QnlJZCIsImdldElmcmFtZSIsIl9yZWFkeUVycm9yIiwiZGVzdHJveSIsInRoYXQiLCJvbmxvYWQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJfb25Mb2FkSWZyYW1lIiwiaWZyYW1lV2luZG93IiwiaWZyYW1lRG9jdW1lbnQiLCJjaGFyc2V0IiwiY2hhcmFjdGVyU2V0Iiwic2FuZGJveEh0bWwiLCJfZ2V0SHRtbCIsInN0eWxlc2hlZXRzIiwib25lcnJvciIsImVycm9yTWVzc2FnZSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsIl91bnNldCIsImxvYWRlZCIsInNldFRpbWVvdXQiLCJ0ZW1wbGF0ZVZhcnMiLCJzZXR0ZXIiLCJfX2RlZmluZUdldHRlcl9fIiwiX19kZWZpbmVTZXR0ZXJfXyIsInNldCIsImRlZmluZVByb3BlcnR5Iiwic3R5bGVzIiwiY3NzRmxvYXQiLCJzdHlsZUZsb2F0Iiwic2ltdWxhdGVQbGFjZWhvbGRlciIsImVkaXRvciIsInZpZXciLCJwbGFjZWhvbGRlclRleHQiLCJDTEFTU19OQU1FIiwidW5zZXQiLCJoYXNQbGFjZWhvbGRlclNldCIsImNsZWFyIiwiaXNFbXB0eSIsInNldFZhbHVlIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsImdldFRleHRDb250ZW50IiwiaW5uZXJUZXh0Iiwibm9kZVZhbHVlIiwiY2xlYW5QYXN0ZWRIVE1MIiwibWF0Y2hlcyIsIm1hdGNoZXNMZW5ndGgiLCJqIiwiZW5zdXJlUHJvcGVyQ2xlYXJpbmciLCJjbGVhcklmTmVjZXNzYXJ5IiwiY29tcG9zZXIiLCJlbnN1cmVQcm9wZXJDbGVhcmluZ09mTGlzdHMiLCJFTEVNRU5UU19USEFUX0NPTlRBSU5fTEkiLCJjb250ZW50RWRpdGFibGVFbGVtZW50IiwibGlzdElzRmlyc3RDaGlsZE9mQ29udGVudEVkaXRhYmxlIiwiaGFzT25seU9uZUxpc3RJdGVtIiwib25seUxpc3RJdGVtSXNFbXB0eSIsImtleUNvZGUiLCJnZXRTZWxlY3RlZE5vZGUiLCJUSUxERV9FU0NBUEVEIiwiZWxlbWVudHNXaXRoVGlsZGUiLCJ1cmxUb1NlYXJjaCIsImhyZWYiLCJVU0VfTkFUSVZFX0xJTkVfQlJFQUtfV0hFTl9DQVJFVF9JTlNJREVfVEFHUyIsIkxJU1RfVEFHUyIsImluc2VydExpbmVCcmVha09uUmV0dXJuIiwidW53cmFwIiwic2VsZWN0ZWROb2RlIiwiaW52aXNpYmxlU3BhY2UiLCJrZXlEb3duIiwic2hpZnRLZXkiLCJibG9ja0VsZW1lbnQiLCJkaXYiLCJleGVjIiwicmVkcmF3IiwiX2dldEN1bXVsYXRpdmVPZmZzZXRUb3AiLCJ0b3AiLCJvZmZzZXRUb3AiLCJvZmZzZXRQYXJlbnQiLCJnZXRCb29rbWFyayIsImdldFJhbmdlIiwic2V0Qm9va21hcmsiLCJib29rbWFyayIsInNldFNlbGVjdGlvbiIsInNldEJlZm9yZSIsInNldEFmdGVyIiwiaXNFbGVtZW50IiwiZGlzcGxheVN0eWxlIiwiZXhlY3V0ZUFuZFJlc3RvcmUiLCJyZXN0b3JlU2Nyb2xsUG9zaXRpb24iLCJvbGRTY3JvbGxUb3AiLCJzY3JvbGxUb3AiLCJvbGRTY3JvbGxMZWZ0Iiwic2Nyb2xsTGVmdCIsInBsYWNlaG9sZGVySFRNTCIsIm5ld1JhbmdlIiwiZTMiLCJjYXJldFBsYWNlaG9sZGVyIiwiZTQiLCJleGVjdXRlQW5kUmVzdG9yZVNpbXBsZSIsImZpcnN0Tm9kZSIsImxhc3ROb2RlIiwicmFuZ2VCYWNrdXAiLCJpbnNlcnRIVE1MIiwic3Vycm91bmQiLCJzY3JvbGxJbnRvVmlldyIsImhhc1Njcm9sbEJhcnMiLCJzY3JvbGxIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJfd3lzaWh0bWw1U2Nyb2xsSW50b1ZpZXdFbGVtZW50Iiwic2VsZWN0TGluZSIsIl9zZWxlY3RMaW5lX1czQyIsIl9zZWxlY3RMaW5lX01TSUUiLCJtb2RpZnkiLCJyYW5nZVRvcCIsImJvdW5kaW5nVG9wIiwicmFuZ2VIZWlnaHQiLCJib3VuZGluZ0hlaWdodCIsInNjcm9sbFdpZHRoIiwicmFuZ2VCb3R0b20iLCJyYW5nZUVuZCIsIm1lYXN1cmVOb2RlIiwibW92ZVRvUG9pbnQiLCJnZXRUZXh0IiwiZGVmYXVsdFRhZ05hbWUiLCJSRUdfRVhQX1dISVRFX1NQQUNFIiwiY3NzQ2xhc3MiLCJyZWdFeHAiLCJtYXRjaGluZ0NsYXNzTmFtZXMiLCJoYXNTYW1lQ2xhc3NlcyIsImVsMSIsImVsMiIsInJlcGxhY2VXaXRoT3duQ2hpbGRyZW4iLCJlbGVtZW50c0hhdmVTYW1lTm9uQ2xhc3NBdHRyaWJ1dGVzIiwiYXR0cjEiLCJhdHRyMiIsImdldE5hbWVkSXRlbSIsInNwZWNpZmllZCIsImlzU3BsaXRQb2ludCIsInNwbGl0Tm9kZUF0IiwiZGVzY2VuZGFudE5vZGUiLCJkZXNjZW5kYW50T2Zmc2V0IiwicmVtb3ZlQXR0cmlidXRlIiwiTWVyZ2UiLCJpc0VsZW1lbnRNZXJnZSIsImZpcnN0VGV4dE5vZGUiLCJkb01lcmdlIiwiZ2V0TGVuZ3RoIiwiSFRNTEFwcGxpZXIiLCJ0YWdOYW1lcyIsInNpbWlsYXJDbGFzc1JlZ0V4cCIsIm5vcm1hbGl6ZSIsImFwcGx5VG9BbnlUYWdOYW1lIiwiZ2V0QW5jZXN0b3JXaXRoQ2xhc3MiLCJjc3NDbGFzc01hdGNoIiwicG9zdEFwcGx5IiwibWVyZ2VzIiwiY3VycmVudE1lcmdlIiwicmFuZ2VTdGFydE5vZGUiLCJyYW5nZUVuZE5vZGUiLCJyYW5nZVN0YXJ0T2Zmc2V0IiwicmFuZ2VFbmRPZmZzZXQiLCJwcmVjZWRpbmdUZXh0Tm9kZSIsImdldEFkamFjZW50TWVyZ2VhYmxlVGV4dE5vZGUiLCJuZXh0VGV4dE5vZGUiLCJmb3J3YXJkIiwiaXNUZXh0Tm9kZSIsImFkamFjZW50Tm9kZSIsInByb3BOYW1lIiwiYXJlRWxlbWVudHNNZXJnZWFibGUiLCJjcmVhdGVDb250YWluZXIiLCJhcHBseVRvVGV4dE5vZGUiLCJpc1JlbW92YWJsZSIsInVuZG9Ub1RleHROb2RlIiwiYW5jZXN0b3JXaXRoQ2xhc3MiLCJhbmNlc3RvclJhbmdlIiwiYXBwbHlUb1JhbmdlIiwidW5kb1RvUmFuZ2UiLCJnZXRUZXh0U2VsZWN0ZWRCeVJhbmdlIiwiaXNBcHBsaWVkVG9SYW5nZSIsInNlbGVjdGVkVGV4dCIsInRvZ2dsZVJhbmdlIiwiQ29tbWFuZHMiLCJzdXBwb3J0IiwicmVzdWx0Iiwic3RhdGUiLCJjb21tYW5kVmFsdWUiLCJxdWVyeUNvbW1hbmRWYWx1ZSIsInVuZGVmIiwiYm9sZCIsImZvcm1hdElubGluZSIsImNvbG9yIiwiTk9ERV9OQU1FIiwiX3JlbW92ZUZvcm1hdCIsImFuY2hvcnMiLCJjb2RlRWxlbWVudCIsIl9mb3JtYXQiLCJ0ZW1wQ2xhc3MiLCJEYXRlIiwidGVtcENsYXNzUmVnRXhwIiwiaGFzRWxlbWVudENoaWxkIiwiZWxlbWVudFRvU2V0Q2FyZXRBZnRlciIsIndoaXRlU3BhY2UiLCJjcmVhdGVMaW5rIiwiZm9udFNpemUiLCJzaXplIiwiZm9yZUNvbG9yIiwiQkxPQ0tfRUxFTUVOVFNfR1JPVVAiLCJfYWRkQ2xhc3MiLCJfcmVtb3ZlQ2xhc3MiLCJfaXNCbGFua1RleHROb2RlIiwiX2dldFByZXZpb3VzU2libGluZ1RoYXRJc05vdEJsYW5rIiwiX2dldE5leHRTaWJsaW5nVGhhdElzTm90QmxhbmsiLCJfYWRkTGluZUJyZWFrQmVmb3JlQW5kQWZ0ZXIiLCJfaXNMaW5lQnJlYWtPckJsb2NrRWxlbWVudCIsIl9yZW1vdmVMaW5lQnJlYWtCZWZvcmVBbmRBZnRlciIsIl9yZW1vdmVMYXN0Q2hpbGRJZkxpbmVCcmVhayIsIl9leGVjQ29tbWFuZCIsImV2ZW50TGlzdGVuZXIiLCJfc2VsZWN0TGluZUFuZFdyYXAiLCJfaGFzQ2xhc3NlcyIsImZvcm1hdEJsb2NrIiwiaGFzQ2xhc3NlcyIsIkFMSUFTX01BUFBJTkciLCJodG1sQXBwbGllciIsIl9nZXRUYWdOYW1lcyIsImFsaWFzIiwiX2dldEFwcGxpZXIiLCJpZGVudGlmaWVyIiwiYWxpYXNUYWdOYW1lIiwiaW5zZXJ0SW1hZ2UiLCJpbWFnZSIsImltYWdlc0luU2VsZWN0aW9uIiwiTElORV9CUkVBSyIsImluc2VydExpbmVCcmVhayIsImluc2VydE9yZGVyZWRMaXN0Iiwib3RoZXJMaXN0IiwidGVtcENsYXNzTmFtZSIsImdldFRpbWUiLCJpbnNlcnRVbm9yZGVyZWRMaXN0IiwiaXRhbGljIiwianVzdGlmeUNlbnRlciIsImp1c3RpZnlMZWZ0IiwianVzdGlmeVJpZ2h0IiwidW5kZXJsaW5lIiwiWl9LRVkiLCJZX0tFWSIsIk1BWF9ISVNUT1JZX0VOVFJJRVMiLCJVTkRPX0hUTUwiLCJSRURPX0hUTUwiLCJjbGVhblRlbXBFbGVtZW50cyIsIlVuZG9NYW5hZ2VyIiwiaGlzdG9yeSIsImdldFZhbHVlIiwicG9zaXRpb24iLCJfb2JzZXJ2ZSIsInNhbmRib3giLCJsYXN0S2V5IiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJpc1VuZG8iLCJpc1JlZG8iLCJ1bmRvIiwicmVkbyIsInRyYW5zYWN0IiwiaW50ZXJ2YWwiLCJvYnNlcnZlZCIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInByZXZpb3VzSHRtbCIsImN1cnJlbnRIdG1sIiwic2hpZnQiLCJWaWV3IiwidGV4dGFyZWFFbGVtZW50IiwiX29ic2VydmVWaWV3Q2hhbmdlIiwiY3VycmVudFZpZXciLCJzaG93IiwiaGlkZSIsImRpc2FibGUiLCJlbmFibGUiLCJDb21wb3NlciIsIkNBUkVUX0hBQ0siLCJ0ZXh0YXJlYSIsIl9pbml0U2FuZGJveCIsIl9kaXNwbGF5U3R5bGUiLCJzZXRUb0VuZCIsImVsZW1lbnRzV2l0aFZpc3VhbFZhbHVlIiwiX2NyZWF0ZSIsImhpZGRlbkZpZWxkIiwiY29tcG9zZXJDbGFzc05hbWUiLCJwbGFjZWhvbGRlciIsIl9pbml0QXV0b0xpbmtpbmciLCJfaW5pdE9iamVjdFJlc2l6aW5nIiwiX2luaXRVbmRvTWFuYWdlciIsImluaXRTeW5jIiwic3luYyIsInN1cHBvcnRzRGlzYWJsaW5nT2ZBdXRvTGlua2luZyIsInN1cHBvcnRzQXV0b0xpbmtpbmciLCJsaW5rcyIsInVybFJlZ0V4cCIsImxpbmsiLCJuZXdUZXh0Q29udGVudCIsInByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzTGVuZ3RoIiwiYWxsb3dPYmplY3RSZXNpemluZyIsIkhPU1RfVEVNUExBVEUiLCJURVhUX0ZPUk1BVFRJTkciLCJCT1hfRk9STUFUVElORyIsIlJFU0laRV9TVFlMRSIsIkFERElUSU9OQUxfQ1NTX1JVTEVTIiwiZm9jdXNXaXRob3V0U2Nyb2xsaW5nIiwic2V0QWN0aXZlIiwiZWxlbWVudFN0eWxlIiwib3JpZ2luYWxTY3JvbGxUb3AiLCJvcmlnaW5hbFNjcm9sbExlZnQiLCJvcmlnaW5hbFN0eWxlcyIsIldlYmtpdFVzZXJTZWxlY3QiLCJzY3JvbGxUbyIsIm9yaWdpbmFsQWN0aXZlRWxlbWVudCIsImhhc1BsYWNlaG9sZGVyIiwib3JpZ2luYWxQbGFjZWhvbGRlciIsImZvY3VzU3R5bGVzSG9zdCIsImJsdXJTdHlsZXNIb3N0IiwiYmx1ciIsImJveEZvcm1hdHRpbmdTdHlsZXMiLCJ3aW5PYnNlcnZlciIsIm9yaWdpbmFsVGV4dGFyZWFEaXNwbGF5U3R5bGUiLCJvcmlnaW5hbENvbXBvc2VyRGlzcGxheVN0eWxlIiwic2hvcnRjdXRzIiwiZm9jdXNCbHVyRWxlbWVudCIsInBhc3RlRXZlbnRzIiwiZG9tTm9kZVJlbW92ZWRJbnRlcnZhbCIsImRhdGFUcmFuc2ZlciIsInRpdGxlUHJlZml4ZXMiLCJJTUciLCJBIiwidGl0bGUiLCJoYXNUaXRsZSIsIklOVEVSVkFMIiwiU3luY2hyb25pemVyIiwiZnJvbUNvbXBvc2VyVG9UZXh0YXJlYSIsInNob3VsZFBhcnNlSHRtbCIsImZyb21UZXh0YXJlYVRvQ29tcG9zZXIiLCJ0ZXh0YXJlYVZhbHVlIiwiZm9ybSIsInN0YXJ0SW50ZXJ2YWwiLCJzdG9wSW50ZXJ2YWwiLCJUZXh0YXJlYSIsInN1cHBvcnRzUGxhY2Vob2xkZXIiLCJldmVudE1hcHBpbmciLCJmb2N1c2luIiwiZm9jdXNvdXQiLCJDTEFTU19OQU1FX09QRU5FRCIsIlNFTEVDVE9SX0ZPUk1fRUxFTUVOVFMiLCJTRUxFQ1RPUl9GSUVMRFMiLCJBVFRSSUJVVEVfRklFTERTIiwiRGlhbG9nIiwiX29ic2VydmVkIiwiY2FsbGJhY2tXcmFwcGVyIiwiX3NlcmlhbGl6ZSIsImVsZW1lbnRUb0NoYW5nZSIsImZvcm1FbGVtZW50cyIsIl9jbGVhckludGVydmFsIiwiZmllbGRzIiwiX2ludGVycG9sYXRlIiwiYXZvaWRIaWRkZW5GaWVsZHMiLCJmaWVsZCIsImZpZWxkTmFtZSIsIm5ld1ZhbHVlIiwiZm9jdXNlZEVsZW1lbnQiLCJkZWZhdWx0VmFsdWUiLCJmaXJzdEZpZWxkIiwibGlua1N0eWxlcyIsIndyYXBwZXJTdHlsZXMiLCJtYXJnaW4iLCJvcGFjaXR5IiwicGFkZGluZyIsInpJbmRleCIsImlucHV0U3R5bGVzIiwiY3Vyc29yIiwibWFyZ2luVG9wIiwib3V0bGluZSIsImlucHV0QXR0cmlidXRlcyIsIlNwZWVjaCIsIndyYXBwZXIiLCJDTEFTU19OQU1FX0NPTU1BTkRfRElTQUJMRUQiLCJDTEFTU19OQU1FX0NPTU1BTkRTX0RJU0FCTEVEIiwiQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSIsIkNMQVNTX05BTUVfQUNUSU9OX0FDVElWRSIsIlRvb2xiYXIiLCJfZ2V0TGlua3MiLCJzcGVlY2hJbnB1dExpbmtzIiwiZ3JvdXAiLCJkaWFsb2ciLCJfZ2V0RGlhbG9nIiwiZGlhbG9nRWxlbWVudCIsImNhcmV0Qm9va21hcmsiLCJkaWFsb2dDb250YWluZXIiLCJjb21tYW5kTGluayIsImNvbW1hbmRzRGlzYWJsZWQiLCJjb21tYW5kT2JqIiwiY29tbWFuZE1hcHBpbmciLCJfdXBkYXRlTGlua1N0YXRlcyIsImV4ZWNBY3Rpb24iLCJhY3Rpb24iLCJjb21tYW5kTGlua3MiLCJhY3Rpb25MaW5rcyIsInVuc2VsZWN0YWJsZSIsImFjdGlvbk1hcHBpbmciLCJkZWZhdWx0Q29uZmlnIiwicGFyc2VyUnVsZXMiLCJiciIsInNwYW4iLCJwYXJzZXIiLCJib2R5Q2xhc3NOYW1lIiwic3VwcG9ydFRvdWNoRGV2aWNlcyIsIkVkaXRvciIsIl9pc0NvbXBhdGlibGUiLCJfaW5pdFBhcnNlciIsInN5bmNocm9uaXplciIsImlzQ29tcGF0aWJsZSIsImh0bWxPckVsZW1lbnQiLCJrZWVwU2Nyb2xsUG9zaXRpb24iXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7Ozs7QUFVQSxJQUFJQSxZQUFZO0FBQ2RDLFdBQVMsT0FESzs7QUFHZDtBQUNBQyxZQUFZLEVBSkU7QUFLZEMsT0FBWSxFQUxFO0FBTWRDLFVBQVksRUFORTtBQU9kQyxXQUFZLEVBUEU7QUFRZEMsUUFBWSxFQVJFO0FBU2RDLGFBQVksRUFURTtBQVVkQyxTQUFZLEVBVkU7O0FBWWRDLG1CQUFpQixRQVpIOztBQWNkQyxrQkFBZ0IsMEJBQVcsQ0FBRSxDQWRmOztBQWdCZEMsZ0JBQWMsQ0FoQkE7QUFpQmRDLGFBQWMsQ0FqQkE7O0FBbUJkQyxpQkFBZ0IsQ0FuQkY7QUFvQmRDLGFBQWdCLEVBcEJGO0FBcUJkQyxjQUFnQixFQXJCRjtBQXNCZEMsYUFBZ0IsRUF0QkY7QUF1QmRDLGNBQWdCO0FBdkJGLENBQWhCLEMsQ0F3QkU7Ozs7Ozs7OztBQVNGQyxPQUFPLE9BQVAsSUFBbUIsWUFBVzs7QUFHMUIsTUFBSUMsU0FBUyxRQUFiO0FBQUEsTUFBdUJDLFdBQVcsVUFBbEM7QUFBQSxNQUE4Q0MsWUFBWSxXQUExRDs7QUFFQSxNQUFJQyxxQkFBcUIsQ0FBQyxnQkFBRCxFQUFtQixhQUFuQixFQUFrQyxjQUFsQyxFQUFrRCxXQUFsRCxFQUErRCxXQUEvRCxFQUNyQix5QkFEcUIsRUFDTSxnQkFETixFQUN3QixjQUR4QixFQUN3QyxjQUR4QyxFQUN3RCxZQUR4RCxDQUF6Qjs7QUFHQSxNQUFJQyxrQkFBa0IsQ0FBQyxVQUFELEVBQWEsZ0JBQWIsRUFBK0Is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QVc7QUFDdEIsV0FBS2xwQixPQUFMLENBQWEsZ0JBQWIsRUFBK0IsWUFBVztBQUN4QyxZQUFJc3BCLHFCQUFzQixJQUExQjtBQUFBLFlBQ0lyYSxPQUFzQixJQUQxQjtBQUVBQSxhQUFLZ0QsUUFBTCxDQUFjdDdCLFNBQWQsQ0FBd0I0OUIsaUJBQXhCLENBQTBDLFlBQVc7QUFDbkRuK0Isb0JBQVVJLE1BQVYsQ0FBaUJtN0IsZUFBakIsQ0FBaUMxQyxLQUFLZ0QsUUFBTCxDQUFjcFosT0FBL0M7QUFDQW9XLGVBQUtsRyxLQUFMLENBQVdrRyxLQUFLZ0QsUUFBTCxDQUFjcFosT0FBekI7QUFDRCxTQUhELEVBR0d5d0Isa0JBSEg7QUFJRCxPQVBEOztBQVNBLFdBQUt0cEIsT0FBTCxDQUFhLGdCQUFiLEVBQStCLFlBQVc7QUFDeEMsWUFBSTdGLFFBQVUsS0FBS3VtQixRQUFMLENBQWM5QixRQUFkLEVBQWQ7QUFBQSxZQUNJb0gsUUFESjtBQUVBQSxtQkFBVyxLQUFLamQsS0FBTCxDQUFXNU8sS0FBWCxDQUFYO0FBQ0EsYUFBS3VtQixRQUFMLENBQWNyUCxRQUFkLENBQXVCMlUsUUFBdkI7QUFDRCxPQUxEO0FBTUQ7QUFuSHdDLEdBRHhCLENBQW5CO0FBc0hELENBckpELEVBcUpHNXZDLFNBckpIIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIHd5c2lodG1sNSB2MC4zLjBcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS94aW5nL3d5c2lodG1sNVxuICpcbiAqIEF1dGhvcjogQ2hyaXN0b3BoZXIgQmx1bSAoaHR0cHM6Ly9naXRodWIuY29tL3RpZmYpXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDEyIFhJTkcgQUdcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAoTUlUKVxuICpcbiAqL1xudmFyIHd5c2lodG1sNSA9IHtcbiAgdmVyc2lvbjogXCIwLjMuMFwiLFxuICBcbiAgLy8gbmFtZXNwYWNlc1xuICBjb21tYW5kczogICB7fSxcbiAgZG9tOiAgICAgICAge30sXG4gIHF1aXJrczogICAgIHt9LFxuICB0b29sYmFyOiAgICB7fSxcbiAgbGFuZzogICAgICAge30sXG4gIHNlbGVjdGlvbjogIHt9LFxuICB2aWV3czogICAgICB7fSxcbiAgXG4gIElOVklTSUJMRV9TUEFDRTogXCJcXHVGRUZGXCIsXG4gIFxuICBFTVBUWV9GVU5DVElPTjogZnVuY3Rpb24oKSB7fSxcbiAgXG4gIEVMRU1FTlRfTk9ERTogMSxcbiAgVEVYVF9OT0RFOiAgICAzLFxuICBcbiAgQkFDS1NQQUNFX0tFWTogIDgsXG4gIEVOVEVSX0tFWTogICAgICAxMyxcbiAgRVNDQVBFX0tFWTogICAgIDI3LFxuICBTUEFDRV9LRVk6ICAgICAgMzIsXG4gIERFTEVURV9LRVk6ICAgICA0NlxufTsvKipcbiAqIEBsaWNlbnNlIFJhbmd5LCBhIGNyb3NzLWJyb3dzZXIgSmF2YVNjcmlwdCByYW5nZSBhbmQgc2VsZWN0aW9uIGxpYnJhcnlcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9yYW5neS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgVGltIERvd25cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIFZlcnNpb246IDEuMi4yXG4gKiBCdWlsZCBkYXRlOiAxMyBOb3ZlbWJlciAyMDExXG4gKi9cbndpbmRvd1sncmFuZ3knXSA9IChmdW5jdGlvbigpIHtcblxuXG4gICAgdmFyIE9CSkVDVCA9IFwib2JqZWN0XCIsIEZVTkNUSU9OID0gXCJmdW5jdGlvblwiLCBVTkRFRklORUQgPSBcInVuZGVmaW5lZFwiO1xuXG4gICAgdmFyIGRvbVJhbmdlUHJvcGVydGllcyA9IFtcInN0YXJ0Q29udGFpbmVyXCIsIFwic3RhcnRPZmZzZXRcIiwgXCJlbmRDb250YWluZXJcIiwgXCJlbmRPZmZzZXRcIiwgXCJjb2xsYXBzZWRcIixcbiAgICAgICAgXCJjb21tb25BbmNlc3RvckNvbnRhaW5lclwiLCBcIlNUQVJUX1RPX1NUQVJUXCIsIFwiU1RBUlRfVE9fRU5EXCIsIFwiRU5EX1RPX1NUQVJUXCIsIFwiRU5EX1RPX0VORFwiXTtcblxuICAgIHZhciBkb21SYW5nZU1ldGhvZHMgPSBbXCJzZXRTdGFydFwiLCBcInNldFN0YXJ0QmVmb3JlXCIsIFwic2V0U3RhcnRBZnRlclwiLCBcInNldEVuZFwiLCBcInNldEVuZEJlZm9yZVwiLFxuICAgICAgICBcInNldEVuZEFmdGVyXCIsIFwiY29sbGFwc2VcIiwgXCJzZWxlY3ROb2RlXCIsIFwic2VsZWN0Tm9kZUNvbnRlbnRzXCIsIFwiY29tcGFyZUJvdW5kYXJ5UG9pbnRzXCIsIFwiZGVsZXRlQ29udGVudHNcIixcbiAgICAgICAgXCJleHRyYWN0Q29udGVudHNcIiwgXCJjbG9uZUNvbnRlbnRzXCIsIFwiaW5zZXJ0Tm9kZVwiLCBcInN1cnJvdW5kQ29udGVudHNcIiwgXCJjbG9uZVJhbmdlXCIsIFwidG9TdHJpbmdcIiwgXCJkZXRhY2hcIl07XG5cbiAgICB2YXIgdGV4dFJhbmdlUHJvcGVydGllcyA9IFtcImJvdW5kaW5nSGVpZ2h0XCIsIFwiYm91bmRpbmdMZWZ0XCIsIFwiYm91bmRpbmdUb3BcIiwgXCJib3VuZGluZ1dpZHRoXCIsIFwiaHRtbFRleHRcIiwgXCJ0ZXh0XCJdO1xuXG4gICAgLy8gU3Vic2V0IG9mIFRleHRSYW5nZSdzIGZ1bGwgc2V0IG9mIG1ldGhvZHMgdGhhdCB3ZSdyZSBpbnRlcmVzdGVkIGluXG4gICAgdmFyIHRleHRSYW5nZU1ldGhvZHMgPSBbXCJjb2xsYXBzZVwiLCBcImNvbXBhcmVFbmRQb2ludHNcIiwgXCJkdXBsaWNhdGVcIiwgXCJnZXRCb29rbWFya1wiLCBcIm1vdmVUb0Jvb2ttYXJrXCIsXG4gICAgICAgIFwibW92ZVRvRWxlbWVudFRleHRcIiwgXCJwYXJlbnRFbGVtZW50XCIsIFwicGFzdGVIVE1MXCIsIFwic2VsZWN0XCIsIFwic2V0RW5kUG9pbnRcIiwgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIl07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gVHJpbyBvZiBmdW5jdGlvbnMgdGFrZW4gZnJvbSBQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZTpcbiAgICAvLyBodHRwOi8vcGV0ZXIubWljaGF1eC5jYS9hcnRpY2xlcy9mZWF0dXJlLWRldGVjdGlvbi1zdGF0ZS1vZi10aGUtYXJ0LWJyb3dzZXItc2NyaXB0aW5nXG4gICAgZnVuY3Rpb24gaXNIb3N0TWV0aG9kKG8sIHApIHtcbiAgICAgICAgdmFyIHQgPSB0eXBlb2Ygb1twXTtcbiAgICAgICAgcmV0dXJuIHQgPT0gRlVOQ1RJT04gfHwgKCEhKHQgPT0gT0JKRUNUICYmIG9bcF0pKSB8fCB0ID09IFwidW5rbm93blwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSG9zdE9iamVjdChvLCBwKSB7XG4gICAgICAgIHJldHVybiAhISh0eXBlb2Ygb1twXSA9PSBPQkpFQ1QgJiYgb1twXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNIb3N0UHJvcGVydHkobywgcCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9bcF0gIT0gVU5ERUZJTkVEO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBzYXZlIHZlcmJvc2UgcmVwZWF0ZWQgY2FsbHMgdG8gdGVzdHMgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gY3JlYXRlTXVsdGlwbGVQcm9wZXJ0eVRlc3QodGVzdEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG8sIHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgaSA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRlc3RGdW5jKG8sIHByb3BzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTmV4dCB0cmlvIG9mIGZ1bmN0aW9ucyBhcmUgYSBjb252ZW5pZW5jZSB0byBzYXZlIHZlcmJvc2UgcmVwZWF0ZWQgY2FsbHMgdG8gcHJldmlvdXMgdHdvIGZ1bmN0aW9uc1xuICAgIHZhciBhcmVIb3N0TWV0aG9kcyA9IGNyZWF0ZU11bHRpcGxlUHJvcGVydHlUZXN0KGlzSG9zdE1ldGhvZCk7XG4gICAgdmFyIGFyZUhvc3RPYmplY3RzID0gY3JlYXRlTXVsdGlwbGVQcm9wZXJ0eVRlc3QoaXNIb3N0T2JqZWN0KTtcbiAgICB2YXIgYXJlSG9zdFByb3BlcnRpZXMgPSBjcmVhdGVNdWx0aXBsZVByb3BlcnR5VGVzdChpc0hvc3RQcm9wZXJ0eSk7XG5cbiAgICBmdW5jdGlvbiBpc1RleHRSYW5nZShyYW5nZSkge1xuICAgICAgICByZXR1cm4gcmFuZ2UgJiYgYXJlSG9zdE1ldGhvZHMocmFuZ2UsIHRleHRSYW5nZU1ldGhvZHMpICYmIGFyZUhvc3RQcm9wZXJ0aWVzKHJhbmdlLCB0ZXh0UmFuZ2VQcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICB2YXIgYXBpID0ge1xuICAgICAgICB2ZXJzaW9uOiBcIjEuMi4yXCIsXG4gICAgICAgIGluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgICAgc3VwcG9ydGVkOiB0cnVlLFxuXG4gICAgICAgIHV0aWw6IHtcbiAgICAgICAgICAgIGlzSG9zdE1ldGhvZDogaXNIb3N0TWV0aG9kLFxuICAgICAgICAgICAgaXNIb3N0T2JqZWN0OiBpc0hvc3RPYmplY3QsXG4gICAgICAgICAgICBpc0hvc3RQcm9wZXJ0eTogaXNIb3N0UHJvcGVydHksXG4gICAgICAgICAgICBhcmVIb3N0TWV0aG9kczogYXJlSG9zdE1ldGhvZHMsXG4gICAgICAgICAgICBhcmVIb3N0T2JqZWN0czogYXJlSG9zdE9iamVjdHMsXG4gICAgICAgICAgICBhcmVIb3N0UHJvcGVydGllczogYXJlSG9zdFByb3BlcnRpZXMsXG4gICAgICAgICAgICBpc1RleHRSYW5nZTogaXNUZXh0UmFuZ2VcbiAgICAgICAgfSxcblxuICAgICAgICBmZWF0dXJlczoge30sXG5cbiAgICAgICAgbW9kdWxlczoge30sXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgYWxlcnRPbldhcm46IGZhbHNlLFxuICAgICAgICAgICAgcHJlZmVyVGV4dFJhbmdlOiBmYWxzZVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGZhaWwocmVhc29uKSB7XG4gICAgICAgIHdpbmRvdy5hbGVydChcIlJhbmd5IG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyLiBSZWFzb246IFwiICsgcmVhc29uKTtcbiAgICAgICAgYXBpLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgYXBpLnN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGFwaS5mYWlsID0gZmFpbDtcblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IFwiUmFuZ3kgd2FybmluZzogXCIgKyBtc2c7XG4gICAgICAgIGlmIChhcGkuY29uZmlnLmFsZXJ0T25XYXJuKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWxlcnQod2FybmluZ01lc3NhZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cuY29uc29sZSAhPSBVTkRFRklORUQgJiYgdHlwZW9mIHdpbmRvdy5jb25zb2xlLmxvZyAhPSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhcGkud2FybiA9IHdhcm47XG5cbiAgICBpZiAoe30uaGFzT3duUHJvcGVydHkpIHtcbiAgICAgICAgYXBpLnV0aWwuZXh0ZW5kID0gZnVuY3Rpb24obywgcHJvcHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb1tpXSA9IHByb3BzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmYWlsKFwiaGFzT3duUHJvcGVydHkgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdExpc3RlbmVycyA9IFtdO1xuICAgIHZhciBtb2R1bGVJbml0aWFsaXplcnMgPSBbXTtcblxuICAgIC8vIEluaXRpYWxpemF0aW9uXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgaWYgKGFwaS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXN0UmFuZ2U7XG4gICAgICAgIHZhciBpbXBsZW1lbnRzRG9tUmFuZ2UgPSBmYWxzZSwgaW1wbGVtZW50c1RleHRSYW5nZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEZpcnN0LCBwZXJmb3JtIGJhc2ljIGZlYXR1cmUgdGVzdHNcblxuICAgICAgICBpZiAoaXNIb3N0TWV0aG9kKGRvY3VtZW50LCBcImNyZWF0ZVJhbmdlXCIpKSB7XG4gICAgICAgICAgICB0ZXN0UmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKGFyZUhvc3RNZXRob2RzKHRlc3RSYW5nZSwgZG9tUmFuZ2VNZXRob2RzKSAmJiBhcmVIb3N0UHJvcGVydGllcyh0ZXN0UmFuZ2UsIGRvbVJhbmdlUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBpbXBsZW1lbnRzRG9tUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVzdFJhbmdlLmRldGFjaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJvZHkgPSBpc0hvc3RPYmplY3QoZG9jdW1lbnQsIFwiYm9keVwiKSA/IGRvY3VtZW50LmJvZHkgOiBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJvZHlcIilbMF07XG5cbiAgICAgICAgaWYgKGJvZHkgJiYgaXNIb3N0TWV0aG9kKGJvZHksIFwiY3JlYXRlVGV4dFJhbmdlXCIpKSB7XG4gICAgICAgICAgICB0ZXN0UmFuZ2UgPSBib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKGlzVGV4dFJhbmdlKHRlc3RSYW5nZSkpIHtcbiAgICAgICAgICAgICAgICBpbXBsZW1lbnRzVGV4dFJhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW1wbGVtZW50c0RvbVJhbmdlICYmICFpbXBsZW1lbnRzVGV4dFJhbmdlKSB7XG4gICAgICAgICAgICBmYWlsKFwiTmVpdGhlciBSYW5nZSBub3IgVGV4dFJhbmdlIGFyZSBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwaS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGFwaS5mZWF0dXJlcyA9IHtcbiAgICAgICAgICAgIGltcGxlbWVudHNEb21SYW5nZTogaW1wbGVtZW50c0RvbVJhbmdlLFxuICAgICAgICAgICAgaW1wbGVtZW50c1RleHRSYW5nZTogaW1wbGVtZW50c1RleHRSYW5nZVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgbW9kdWxlcyBhbmQgY2FsbCBpbml0IGxpc3RlbmVyc1xuICAgICAgICB2YXIgYWxsTGlzdGVuZXJzID0gbW9kdWxlSW5pdGlhbGl6ZXJzLmNvbmNhdChpbml0TGlzdGVuZXJzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFsbExpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhbGxMaXN0ZW5lcnNbaV0oYXBpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSG9zdE9iamVjdCh3aW5kb3csIFwiY29uc29sZVwiKSAmJiBpc0hvc3RNZXRob2Qod2luZG93LmNvbnNvbGUsIFwibG9nXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhcIkluaXQgbGlzdGVuZXIgdGhyZXcgYW4gZXhjZXB0aW9uLiBDb250aW51aW5nLlwiLCBleCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGxvdyBleHRlcm5hbCBzY3JpcHRzIHRvIGluaXRpYWxpemUgdGhpcyBsaWJyYXJ5IGluIGNhc2UgaXQncyBsb2FkZWQgYWZ0ZXIgdGhlIGRvY3VtZW50IGhhcyBsb2FkZWRcbiAgICBhcGkuaW5pdCA9IGluaXQ7XG5cbiAgICAvLyBFeGVjdXRlIGxpc3RlbmVyIGltbWVkaWF0ZWx5IGlmIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICBhcGkuYWRkSW5pdExpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGFwaS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgbGlzdGVuZXIoYXBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluaXRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZU1pc3NpbmdOYXRpdmVBcGlMaXN0ZW5lcnMgPSBbXTtcblxuICAgIGFwaS5hZGRDcmVhdGVNaXNzaW5nTmF0aXZlQXBpTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICBjcmVhdGVNaXNzaW5nTmF0aXZlQXBpTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVNaXNzaW5nTmF0aXZlQXBpKHdpbikge1xuICAgICAgICB3aW4gPSB3aW4gfHwgd2luZG93O1xuICAgICAgICBpbml0KCk7XG5cbiAgICAgICAgLy8gTm90aWZ5IGxpc3RlbmVyc1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY3JlYXRlTWlzc2luZ05hdGl2ZUFwaUxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgY3JlYXRlTWlzc2luZ05hdGl2ZUFwaUxpc3RlbmVyc1tpXSh3aW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXBpLmNyZWF0ZU1pc3NpbmdOYXRpdmVBcGkgPSBjcmVhdGVNaXNzaW5nTmF0aXZlQXBpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gTW9kdWxlKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIE1vZHVsZS5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2R1bGUgJ1wiICsgdGhpcy5uYW1lICsgXCInIGZhaWxlZCB0byBsb2FkOiBcIiArIHJlYXNvbik7XG4gICAgfTtcblxuICAgIE1vZHVsZS5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICBhcGkud2FybihcIk1vZHVsZSBcIiArIHRoaXMubmFtZSArIFwiOiBcIiArIG1zZyk7XG4gICAgfTtcblxuICAgIE1vZHVsZS5wcm90b3R5cGUuY3JlYXRlRXJyb3IgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkVycm9yIGluIFJhbmd5IFwiICsgdGhpcy5uYW1lICsgXCIgbW9kdWxlOiBcIiArIG1zZyk7XG4gICAgfTtcblxuICAgIGFwaS5jcmVhdGVNb2R1bGUgPSBmdW5jdGlvbihuYW1lLCBpbml0RnVuYykge1xuICAgICAgICB2YXIgbW9kdWxlID0gbmV3IE1vZHVsZShuYW1lKTtcbiAgICAgICAgYXBpLm1vZHVsZXNbbmFtZV0gPSBtb2R1bGU7XG5cbiAgICAgICAgbW9kdWxlSW5pdGlhbGl6ZXJzLnB1c2goZnVuY3Rpb24oYXBpKSB7XG4gICAgICAgICAgICBpbml0RnVuYyhhcGksIG1vZHVsZSk7XG4gICAgICAgICAgICBtb2R1bGUuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbW9kdWxlLnN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhcGkucmVxdWlyZU1vZHVsZXMgPSBmdW5jdGlvbihtb2R1bGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtb2R1bGVzLmxlbmd0aCwgbW9kdWxlLCBtb2R1bGVOYW1lOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWUgPSBtb2R1bGVzW2ldO1xuICAgICAgICAgICAgbW9kdWxlID0gYXBpLm1vZHVsZXNbbW9kdWxlTmFtZV07XG4gICAgICAgICAgICBpZiAoIW1vZHVsZSB8fCAhKG1vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2R1bGUgJ1wiICsgbW9kdWxlTmFtZSArIFwiJyBub3QgZm91bmRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1vZHVsZS5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2R1bGUgJ1wiICsgbW9kdWxlTmFtZSArIFwiJyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBXYWl0IGZvciBkb2N1bWVudCB0byBsb2FkIGJlZm9yZSBydW5uaW5nIHRlc3RzXG5cbiAgICB2YXIgZG9jUmVhZHkgPSBmYWxzZTtcblxuICAgIHZhciBsb2FkSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICBpZiAoIWRvY1JlYWR5KSB7XG4gICAgICAgICAgICBkb2NSZWFkeSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWFwaS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGluaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBUZXN0IHdoZXRoZXIgd2UgaGF2ZSB3aW5kb3cgYW5kIGRvY3VtZW50IG9iamVjdHMgdGhhdCB3ZSB3aWxsIG5lZWRcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PSBVTkRFRklORUQpIHtcbiAgICAgICAgZmFpbChcIk5vIHdpbmRvdyBmb3VuZFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09IFVOREVGSU5FRCkge1xuICAgICAgICBmYWlsKFwiTm8gZG9jdW1lbnQgZm91bmRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNIb3N0TWV0aG9kKGRvY3VtZW50LCBcImFkZEV2ZW50TGlzdGVuZXJcIikpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgbG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYSBmYWxsYmFjayBpbiBjYXNlIHRoZSBET01Db250ZW50TG9hZGVkIGV2ZW50IGlzbid0IHN1cHBvcnRlZFxuICAgIGlmIChpc0hvc3RNZXRob2Qod2luZG93LCBcImFkZEV2ZW50TGlzdGVuZXJcIikpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChpc0hvc3RNZXRob2Qod2luZG93LCBcImF0dGFjaEV2ZW50XCIpKSB7XG4gICAgICAgIHdpbmRvdy5hdHRhY2hFdmVudChcIm9ubG9hZFwiLCBsb2FkSGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmFpbChcIldpbmRvdyBkb2VzIG5vdCBoYXZlIHJlcXVpcmVkIGFkZEV2ZW50TGlzdGVuZXIgb3IgYXR0YWNoRXZlbnQgbWV0aG9kXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBhcGk7XG59KSgpO1xucmFuZ3kuY3JlYXRlTW9kdWxlKFwiRG9tVXRpbFwiLCBmdW5jdGlvbihhcGksIG1vZHVsZSkge1xuXG4gICAgdmFyIFVOREVGID0gXCJ1bmRlZmluZWRcIjtcbiAgICB2YXIgdXRpbCA9IGFwaS51dGlsO1xuXG4gICAgLy8gUGVyZm9ybSBmZWF0dXJlIHRlc3RzXG4gICAgaWYgKCF1dGlsLmFyZUhvc3RNZXRob2RzKGRvY3VtZW50LCBbXCJjcmVhdGVEb2N1bWVudEZyYWdtZW50XCIsIFwiY3JlYXRlRWxlbWVudFwiLCBcImNyZWF0ZVRleHROb2RlXCJdKSkge1xuICAgICAgICBtb2R1bGUuZmFpbChcImRvY3VtZW50IG1pc3NpbmcgYSBOb2RlIGNyZWF0aW9uIG1ldGhvZFwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuaXNIb3N0TWV0aG9kKGRvY3VtZW50LCBcImdldEVsZW1lbnRzQnlUYWdOYW1lXCIpKSB7XG4gICAgICAgIG1vZHVsZS5mYWlsKFwiZG9jdW1lbnQgbWlzc2luZyBnZXRFbGVtZW50c0J5VGFnTmFtZSBtZXRob2RcIik7XG4gICAgfVxuXG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBpZiAoIXV0aWwuYXJlSG9zdE1ldGhvZHMoZWwsIFtcImluc2VydEJlZm9yZVwiLCBcImFwcGVuZENoaWxkXCIsIFwiY2xvbmVOb2RlXCJdIHx8XG4gICAgICAgICAgICAhdXRpbC5hcmVIb3N0T2JqZWN0cyhlbCwgW1wicHJldmlvdXNTaWJsaW5nXCIsIFwibmV4dFNpYmxpbmdcIiwgXCJjaGlsZE5vZGVzXCIsIFwicGFyZW50Tm9kZVwiXSkpKSB7XG4gICAgICAgIG1vZHVsZS5mYWlsKFwiSW5jb21wbGV0ZSBFbGVtZW50IGltcGxlbWVudGF0aW9uXCIpO1xuICAgIH1cblxuICAgIC8vIGlubmVySFRNTCBpcyByZXF1aXJlZCBmb3IgUmFuZ2UncyBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgbWV0aG9kXG4gICAgaWYgKCF1dGlsLmlzSG9zdFByb3BlcnR5KGVsLCBcImlubmVySFRNTFwiKSkge1xuICAgICAgICBtb2R1bGUuZmFpbChcIkVsZW1lbnQgaXMgbWlzc2luZyBpbm5lckhUTUwgcHJvcGVydHlcIik7XG4gICAgfVxuXG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ0ZXN0XCIpO1xuICAgIGlmICghdXRpbC5hcmVIb3N0TWV0aG9kcyh0ZXh0Tm9kZSwgW1wic3BsaXRUZXh0XCIsIFwiZGVsZXRlRGF0YVwiLCBcImluc2VydERhdGFcIiwgXCJhcHBlbmREYXRhXCIsIFwiY2xvbmVOb2RlXCJdIHx8XG4gICAgICAgICAgICAhdXRpbC5hcmVIb3N0T2JqZWN0cyhlbCwgW1wicHJldmlvdXNTaWJsaW5nXCIsIFwibmV4dFNpYmxpbmdcIiwgXCJjaGlsZE5vZGVzXCIsIFwicGFyZW50Tm9kZVwiXSkgfHxcbiAgICAgICAgICAgICF1dGlsLmFyZUhvc3RQcm9wZXJ0aWVzKHRleHROb2RlLCBbXCJkYXRhXCJdKSkpIHtcbiAgICAgICAgbW9kdWxlLmZhaWwoXCJJbmNvbXBsZXRlIFRleHQgTm9kZSBpbXBsZW1lbnRhdGlvblwiKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gUmVtb3ZlZCB1c2Ugb2YgaW5kZXhPZiBiZWNhdXNlIG9mIGEgYml6YXJyZSBidWcgaW4gT3BlcmEgdGhhdCBpcyB0aHJvd24gaW4gb25lIG9mIHRoZSBBY2lkMyB0ZXN0cy4gSSBoYXZlbid0IGJlZW5cbiAgICAvLyBhYmxlIHRvIHJlcGxpY2F0ZSBpdCBvdXRzaWRlIG9mIHRoZSB0ZXN0LiBUaGUgYnVnIGlzIHRoYXQgaW5kZXhPZiByZXR1cm5zIC0xIHdoZW4gY2FsbGVkIG9uIGFuIEFycmF5IHRoYXRcbiAgICAvLyBjb250YWlucyBqdXN0IHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSBlbGVtZW50IGFuZCB0aGUgdmFsdWUgc2VhcmNoZWQgZm9yIGlzIHRoZSBkb2N1bWVudC5cbiAgICB2YXIgYXJyYXlDb250YWlucyA9IC8qQXJyYXkucHJvdG90eXBlLmluZGV4T2YgP1xuICAgICAgICBmdW5jdGlvbihhcnIsIHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKHZhbCkgPiAtMTtcbiAgICAgICAgfToqL1xuXG4gICAgICAgIGZ1bmN0aW9uKGFyciwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycltpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgIC8vIE9wZXJhIDExIHB1dHMgSFRNTCBlbGVtZW50cyBpbiB0aGUgbnVsbCBuYW1lc3BhY2UsIGl0IHNlZW1zLCBhbmQgSUUgNyBoYXMgdW5kZWZpbmVkIG5hbWVzcGFjZVVSSVxuICAgIGZ1bmN0aW9uIGlzSHRtbE5hbWVzcGFjZShub2RlKSB7XG4gICAgICAgIHZhciBucztcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBub2RlLm5hbWVzcGFjZVVSSSA9PSBVTkRFRiB8fCAoKG5zID0gbm9kZS5uYW1lc3BhY2VVUkkpID09PSBudWxsIHx8IG5zID09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJlbnRFbGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgcmV0dXJuIChwYXJlbnQubm9kZVR5cGUgPT0gMSkgPyBwYXJlbnQgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE5vZGVJbmRleChub2RlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUoIChub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmcpICkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE5vZGVMZW5ndGgobm9kZSkge1xuICAgICAgICB2YXIgY2hpbGROb2RlcztcbiAgICAgICAgcmV0dXJuIGlzQ2hhcmFjdGVyRGF0YU5vZGUobm9kZSkgPyBub2RlLmxlbmd0aCA6ICgoY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcykgPyBjaGlsZE5vZGVzLmxlbmd0aCA6IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbW1vbkFuY2VzdG9yKG5vZGUxLCBub2RlMikge1xuICAgICAgICB2YXIgYW5jZXN0b3JzID0gW10sIG47XG4gICAgICAgIGZvciAobiA9IG5vZGUxOyBuOyBuID0gbi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBhbmNlc3RvcnMucHVzaChuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobiA9IG5vZGUyOyBuOyBuID0gbi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlDb250YWlucyhhbmNlc3RvcnMsIG4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FuY2VzdG9yT2YoYW5jZXN0b3IsIGRlc2NlbmRhbnQsIHNlbGZJc0FuY2VzdG9yKSB7XG4gICAgICAgIHZhciBuID0gc2VsZklzQW5jZXN0b3IgPyBkZXNjZW5kYW50IDogZGVzY2VuZGFudC5wYXJlbnROb2RlO1xuICAgICAgICB3aGlsZSAobikge1xuICAgICAgICAgICAgaWYgKG4gPT09IGFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSBuLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENsb3Nlc3RBbmNlc3RvckluKG5vZGUsIGFuY2VzdG9yLCBzZWxmSXNBbmNlc3Rvcikge1xuICAgICAgICB2YXIgcCwgbiA9IHNlbGZJc0FuY2VzdG9yID8gbm9kZSA6IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgICAgIHAgPSBuLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAocCA9PT0gYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQ2hhcmFjdGVyRGF0YU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgdCA9IG5vZGUubm9kZVR5cGU7XG4gICAgICAgIHJldHVybiB0ID09IDMgfHwgdCA9PSA0IHx8IHQgPT0gOCA7IC8vIFRleHQsIENEYXRhU2VjdGlvbiBvciBDb21tZW50XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIobm9kZSwgcHJlY2VkaW5nTm9kZSkge1xuICAgICAgICB2YXIgbmV4dE5vZGUgPSBwcmVjZWRpbmdOb2RlLm5leHRTaWJsaW5nLCBwYXJlbnQgPSBwcmVjZWRpbmdOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChuZXh0Tm9kZSkge1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBuZXh0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgLy8gTm90ZSB0aGF0IHdlIGNhbm5vdCB1c2Ugc3BsaXRUZXh0KCkgYmVjYXVzZSBpdCBpcyBidWdyaWRkZW4gaW4gSUUgOS5cbiAgICBmdW5jdGlvbiBzcGxpdERhdGFOb2RlKG5vZGUsIGluZGV4KSB7XG4gICAgICAgIHZhciBuZXdOb2RlID0gbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICBuZXdOb2RlLmRlbGV0ZURhdGEoMCwgaW5kZXgpO1xuICAgICAgICBub2RlLmRlbGV0ZURhdGEoaW5kZXgsIG5vZGUubGVuZ3RoIC0gaW5kZXgpO1xuICAgICAgICBpbnNlcnRBZnRlcihuZXdOb2RlLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSA5KSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZS5vd25lckRvY3VtZW50ICE9IFVOREVGKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlLmRvY3VtZW50ICE9IFVOREVGKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5kb2N1bWVudDtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXREb2N1bWVudChub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0RG9jdW1lbnQ6IG5vIGRvY3VtZW50IGZvdW5kIGZvciBub2RlXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgICAgICAgdmFyIGRvYyA9IGdldERvY3VtZW50KG5vZGUpO1xuICAgICAgICBpZiAodHlwZW9mIGRvYy5kZWZhdWx0VmlldyAhPSBVTkRFRikge1xuICAgICAgICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jLnBhcmVudFdpbmRvdyAhPSBVTkRFRikge1xuICAgICAgICAgICAgcmV0dXJuIGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGEgd2luZG93IG9iamVjdCBmb3Igbm9kZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElmcmFtZURvY3VtZW50KGlmcmFtZUVsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWZyYW1lRWwuY29udGVudERvY3VtZW50ICE9IFVOREVGKSB7XG4gICAgICAgICAgICByZXR1cm4gaWZyYW1lRWwuY29udGVudERvY3VtZW50O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpZnJhbWVFbC5jb250ZW50V2luZG93ICE9IFVOREVGKSB7XG4gICAgICAgICAgICByZXR1cm4gaWZyYW1lRWwuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdldElmcmFtZVdpbmRvdzogTm8gRG9jdW1lbnQgb2JqZWN0IGZvdW5kIGZvciBpZnJhbWUgZWxlbWVudFwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElmcmFtZVdpbmRvdyhpZnJhbWVFbCkge1xuICAgICAgICBpZiAodHlwZW9mIGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cgIT0gVU5ERUYpIHtcbiAgICAgICAgICAgIHJldHVybiBpZnJhbWVFbC5jb250ZW50V2luZG93O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQgIT0gVU5ERUYpIHtcbiAgICAgICAgICAgIHJldHVybiBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRJZnJhbWVXaW5kb3c6IE5vIFdpbmRvdyBvYmplY3QgZm91bmQgZm9yIGlmcmFtZSBlbGVtZW50XCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm9keShkb2MpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuaXNIb3N0T2JqZWN0KGRvYywgXCJib2R5XCIpID8gZG9jLmJvZHkgOiBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJvb3RDb250YWluZXIobm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50O1xuICAgICAgICB3aGlsZSAoIChwYXJlbnQgPSBub2RlLnBhcmVudE5vZGUpICkge1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlUG9pbnRzKG5vZGVBLCBvZmZzZXRBLCBub2RlQiwgb2Zmc2V0Qikge1xuICAgICAgICAvLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItVHJhdmVyc2FsLVJhbmdlL3Jhbmdlcy5odG1sI0xldmVsLTItUmFuZ2UtQ29tcGFyaW5nXG4gICAgICAgIHZhciBub2RlQywgcm9vdCwgY2hpbGRBLCBjaGlsZEIsIG47XG4gICAgICAgIGlmIChub2RlQSA9PSBub2RlQikge1xuXG4gICAgICAgICAgICAvLyBDYXNlIDE6IG5vZGVzIGFyZSB0aGUgc2FtZVxuICAgICAgICAgICAgcmV0dXJuIG9mZnNldEEgPT09IG9mZnNldEIgPyAwIDogKG9mZnNldEEgPCBvZmZzZXRCKSA/IC0xIDogMTtcbiAgICAgICAgfSBlbHNlIGlmICggKG5vZGVDID0gZ2V0Q2xvc2VzdEFuY2VzdG9ySW4obm9kZUIsIG5vZGVBLCB0cnVlKSkgKSB7XG5cbiAgICAgICAgICAgIC8vIENhc2UgMjogbm9kZSBDIChjb250YWluZXIgQiBvciBhbiBhbmNlc3RvcikgaXMgYSBjaGlsZCBub2RlIG9mIEFcbiAgICAgICAgICAgIHJldHVybiBvZmZzZXRBIDw9IGdldE5vZGVJbmRleChub2RlQykgPyAtMSA6IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoIChub2RlQyA9IGdldENsb3Nlc3RBbmNlc3RvckluKG5vZGVBLCBub2RlQiwgdHJ1ZSkpICkge1xuXG4gICAgICAgICAgICAvLyBDYXNlIDM6IG5vZGUgQyAoY29udGFpbmVyIEEgb3IgYW4gYW5jZXN0b3IpIGlzIGEgY2hpbGQgbm9kZSBvZiBCXG4gICAgICAgICAgICByZXR1cm4gZ2V0Tm9kZUluZGV4KG5vZGVDKSA8IG9mZnNldEIgID8gLTEgOiAxO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBDYXNlIDQ6IGNvbnRhaW5lcnMgYXJlIHNpYmxpbmdzIG9yIGRlc2NlbmRhbnRzIG9mIHNpYmxpbmdzXG4gICAgICAgICAgICByb290ID0gZ2V0Q29tbW9uQW5jZXN0b3Iobm9kZUEsIG5vZGVCKTtcbiAgICAgICAgICAgIGNoaWxkQSA9IChub2RlQSA9PT0gcm9vdCkgPyByb290IDogZ2V0Q2xvc2VzdEFuY2VzdG9ySW4obm9kZUEsIHJvb3QsIHRydWUpO1xuICAgICAgICAgICAgY2hpbGRCID0gKG5vZGVCID09PSByb290KSA/IHJvb3QgOiBnZXRDbG9zZXN0QW5jZXN0b3JJbihub2RlQiwgcm9vdCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZEEgPT09IGNoaWxkQikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGJlIHBvc3NpYmxlXG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb21wYXJlUG9pbnRzIGdvdCB0byBjYXNlIDQgYW5kIGNoaWxkQSBhbmQgY2hpbGRCIGFyZSB0aGUgc2FtZSFcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSByb290LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09IGNoaWxkQSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IGNoaWxkQikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbiA9IG4ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBub3QgYmUgaGVyZSFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcmFnbWVudEZyb21Ob2RlQ2hpbGRyZW4obm9kZSkge1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSBnZXREb2N1bWVudChub2RlKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIGNoaWxkO1xuICAgICAgICB3aGlsZSAoIChjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCkgKSB7XG4gICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3BlY3ROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJbTm8gbm9kZV1cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDaGFyYWN0ZXJEYXRhTm9kZShub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdcIicgKyBub2RlLmRhdGEgKyAnXCInO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgdmFyIGlkQXR0ciA9IG5vZGUuaWQgPyAnIGlkPVwiJyArIG5vZGUuaWQgKyAnXCInIDogXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBcIjxcIiArIG5vZGUubm9kZU5hbWUgKyBpZEF0dHIgKyBcIj5bXCIgKyBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICsgXCJdXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5ub2RlTmFtZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5vZGVJdGVyYXRvcihyb290KSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuX25leHQgPSByb290O1xuICAgIH1cblxuICAgIE5vZGVJdGVyYXRvci5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9jdXJyZW50OiBudWxsLFxuXG4gICAgICAgIGhhc05leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fbmV4dDtcbiAgICAgICAgfSxcblxuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5fY3VycmVudCA9IHRoaXMuX25leHQ7XG4gICAgICAgICAgICB2YXIgY2hpbGQsIG5leHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gbi5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgobiAhPT0gdGhpcy5yb290KSAmJiAhKG5leHQgPSBuLm5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX25leHQgPSB0aGlzLnJvb3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yKHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlSXRlcmF0b3Iocm9vdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gRG9tUG9zaXRpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cblxuICAgIERvbVBvc2l0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAgICAgZXF1YWxzOiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUgPT09IHBvcy5ub2RlICYgdGhpcy5vZmZzZXQgPT0gcG9zLm9mZnNldDtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnNwZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBcIltEb21Qb3NpdGlvbihcIiArIGluc3BlY3ROb2RlKHRoaXMubm9kZSkgKyBcIjpcIiArIHRoaXMub2Zmc2V0ICsgXCIpXVwiO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERPTUV4Y2VwdGlvbihjb2RlTmFtZSkge1xuICAgICAgICB0aGlzLmNvZGUgPSB0aGlzW2NvZGVOYW1lXTtcbiAgICAgICAgdGhpcy5jb2RlTmFtZSA9IGNvZGVOYW1lO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkRPTUV4Y2VwdGlvbjogXCIgKyB0aGlzLmNvZGVOYW1lO1xuICAgIH1cblxuICAgIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgICAgIElOREVYX1NJWkVfRVJSOiAxLFxuICAgICAgICBISUVSQVJDSFlfUkVRVUVTVF9FUlI6IDMsXG4gICAgICAgIFdST05HX0RPQ1VNRU5UX0VSUjogNCxcbiAgICAgICAgTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSOiA3LFxuICAgICAgICBOT1RfRk9VTkRfRVJSOiA4LFxuICAgICAgICBOT1RfU1VQUE9SVEVEX0VSUjogOSxcbiAgICAgICAgSU5WQUxJRF9TVEFURV9FUlI6IDExXG4gICAgfTtcblxuICAgIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICB9O1xuXG4gICAgYXBpLmRvbSA9IHtcbiAgICAgICAgYXJyYXlDb250YWluczogYXJyYXlDb250YWlucyxcbiAgICAgICAgaXNIdG1sTmFtZXNwYWNlOiBpc0h0bWxOYW1lc3BhY2UsXG4gICAgICAgIHBhcmVudEVsZW1lbnQ6IHBhcmVudEVsZW1lbnQsXG4gICAgICAgIGdldE5vZGVJbmRleDogZ2V0Tm9kZUluZGV4LFxuICAgICAgICBnZXROb2RlTGVuZ3RoOiBnZXROb2RlTGVuZ3RoLFxuICAgICAgICBnZXRDb21tb25BbmNlc3RvcjogZ2V0Q29tbW9uQW5jZXN0b3IsXG4gICAgICAgIGlzQW5jZXN0b3JPZjogaXNBbmNlc3Rvck9mLFxuICAgICAgICBnZXRDbG9zZXN0QW5jZXN0b3JJbjogZ2V0Q2xvc2VzdEFuY2VzdG9ySW4sXG4gICAgICAgIGlzQ2hhcmFjdGVyRGF0YU5vZGU6IGlzQ2hhcmFjdGVyRGF0YU5vZGUsXG4gICAgICAgIGluc2VydEFmdGVyOiBpbnNlcnRBZnRlcixcbiAgICAgICAgc3BsaXREYXRhTm9kZTogc3BsaXREYXRhTm9kZSxcbiAgICAgICAgZ2V0RG9jdW1lbnQ6IGdldERvY3VtZW50LFxuICAgICAgICBnZXRXaW5kb3c6IGdldFdpbmRvdyxcbiAgICAgICAgZ2V0SWZyYW1lV2luZG93OiBnZXRJZnJhbWVXaW5kb3csXG4gICAgICAgIGdldElmcmFtZURvY3VtZW50OiBnZXRJZnJhbWVEb2N1bWVudCxcbiAgICAgICAgZ2V0Qm9keTogZ2V0Qm9keSxcbiAgICAgICAgZ2V0Um9vdENvbnRhaW5lcjogZ2V0Um9vdENvbnRhaW5lcixcbiAgICAgICAgY29tcGFyZVBvaW50czogY29tcGFyZVBvaW50cyxcbiAgICAgICAgaW5zcGVjdE5vZGU6IGluc3BlY3ROb2RlLFxuICAgICAgICBmcmFnbWVudEZyb21Ob2RlQ2hpbGRyZW46IGZyYWdtZW50RnJvbU5vZGVDaGlsZHJlbixcbiAgICAgICAgY3JlYXRlSXRlcmF0b3I6IGNyZWF0ZUl0ZXJhdG9yLFxuICAgICAgICBEb21Qb3NpdGlvbjogRG9tUG9zaXRpb25cbiAgICB9O1xuXG4gICAgYXBpLkRPTUV4Y2VwdGlvbiA9IERPTUV4Y2VwdGlvbjtcbn0pO3Jhbmd5LmNyZWF0ZU1vZHVsZShcIkRvbVJhbmdlXCIsIGZ1bmN0aW9uKGFwaSwgbW9kdWxlKSB7XG4gICAgYXBpLnJlcXVpcmVNb2R1bGVzKCBbXCJEb21VdGlsXCJdICk7XG5cblxuICAgIHZhciBkb20gPSBhcGkuZG9tO1xuICAgIHZhciBEb21Qb3NpdGlvbiA9IGRvbS5Eb21Qb3NpdGlvbjtcbiAgICB2YXIgRE9NRXhjZXB0aW9uID0gYXBpLkRPTUV4Y2VwdGlvbjtcbiAgICBcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gVXRpbGl0eSBmdW5jdGlvbnNcblxuICAgIGZ1bmN0aW9uIGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKG5vZGUsIHJhbmdlKSB7XG4gICAgICAgIHJldHVybiAobm9kZS5ub2RlVHlwZSAhPSAzKSAmJlxuICAgICAgICAgICAgICAgKGRvbS5pc0FuY2VzdG9yT2Yobm9kZSwgcmFuZ2Uuc3RhcnRDb250YWluZXIsIHRydWUpIHx8IGRvbS5pc0FuY2VzdG9yT2Yobm9kZSwgcmFuZ2UuZW5kQ29udGFpbmVyLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmFuZ2VEb2N1bWVudChyYW5nZSkge1xuICAgICAgICByZXR1cm4gZG9tLmdldERvY3VtZW50KHJhbmdlLnN0YXJ0Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHJhbmdlLCB0eXBlLCBhcmdzKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSByYW5nZS5fbGlzdGVuZXJzW3R5cGVdO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGwocmFuZ2UsIHt0YXJnZXQ6IHJhbmdlLCBhcmdzOiBhcmdzfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb3VuZGFyeUJlZm9yZU5vZGUobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IERvbVBvc2l0aW9uKG5vZGUucGFyZW50Tm9kZSwgZG9tLmdldE5vZGVJbmRleChub2RlKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRhcnlBZnRlck5vZGUobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IERvbVBvc2l0aW9uKG5vZGUucGFyZW50Tm9kZSwgZG9tLmdldE5vZGVJbmRleChub2RlKSArIDEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc2VydE5vZGVBdFBvc2l0aW9uKG5vZGUsIG4sIG8pIHtcbiAgICAgICAgdmFyIGZpcnN0Tm9kZUluc2VydGVkID0gbm9kZS5ub2RlVHlwZSA9PSAxMSA/IG5vZGUuZmlyc3RDaGlsZCA6IG5vZGU7XG4gICAgICAgIGlmIChkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShuKSkge1xuICAgICAgICAgICAgaWYgKG8gPT0gbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIobm9kZSwgbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbyA9PSAwID8gbiA6IGRvbS5zcGxpdERhdGFOb2RlKG4sIG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvID49IG4uY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG4uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuLmluc2VydEJlZm9yZShub2RlLCBuLmNoaWxkTm9kZXNbb10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaXJzdE5vZGVJbnNlcnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZVN1YnRyZWUoaXRlcmF0b3IpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxseVNlbGVjdGVkO1xuICAgICAgICBmb3IgKHZhciBub2RlLCBmcmFnID0gZ2V0UmFuZ2VEb2N1bWVudChpdGVyYXRvci5yYW5nZSkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdWJJdGVyYXRvcjsgbm9kZSA9IGl0ZXJhdG9yLm5leHQoKTsgKSB7XG4gICAgICAgICAgICBwYXJ0aWFsbHlTZWxlY3RlZCA9IGl0ZXJhdG9yLmlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlKCk7XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNsb25lTm9kZSghcGFydGlhbGx5U2VsZWN0ZWQpO1xuICAgICAgICAgICAgaWYgKHBhcnRpYWxseVNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgc3ViSXRlcmF0b3IgPSBpdGVyYXRvci5nZXRTdWJ0cmVlSXRlcmF0b3IoKTtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNsb25lU3VidHJlZShzdWJJdGVyYXRvcikpO1xuICAgICAgICAgICAgICAgIHN1Ykl0ZXJhdG9yLmRldGFjaCh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMTApIHsgLy8gRG9jdW1lbnRUeXBlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIkhJRVJBUkNIWV9SRVFVRVNUX0VSUlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZVN1YnRyZWUocmFuZ2VJdGVyYXRvciwgZnVuYywgaXRlcmF0b3JTdGF0ZSkge1xuICAgICAgICB2YXIgaXQsIG47XG4gICAgICAgIGl0ZXJhdG9yU3RhdGUgPSBpdGVyYXRvclN0YXRlIHx8IHsgc3RvcDogZmFsc2UgfTtcbiAgICAgICAgZm9yICh2YXIgbm9kZSwgc3ViUmFuZ2VJdGVyYXRvcjsgbm9kZSA9IHJhbmdlSXRlcmF0b3IubmV4dCgpOyApIHtcbiAgICAgICAgICAgIC8vbG9nLmRlYnVnKFwiaXRlcmF0ZVN1YnRyZWUsIHBhcnRpYWxseSBzZWxlY3RlZDogXCIgKyByYW5nZUl0ZXJhdG9yLmlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlKCksIG5vZGVUb1N0cmluZyhub2RlKSk7XG4gICAgICAgICAgICBpZiAocmFuZ2VJdGVyYXRvci5pc1BhcnRpYWxseVNlbGVjdGVkU3VidHJlZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG5vZGUgaXMgcGFydGlhbGx5IHNlbGVjdGVkIGJ5IHRoZSBSYW5nZSwgc28gd2UgY2FuIHVzZSBhIG5ldyBSYW5nZUl0ZXJhdG9yIG9uIHRoZSBwb3J0aW9uIG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5vZGUgc2VsZWN0ZWQgYnkgdGhlIFJhbmdlLlxuICAgICAgICAgICAgICAgIGlmIChmdW5jKG5vZGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvclN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViUmFuZ2VJdGVyYXRvciA9IHJhbmdlSXRlcmF0b3IuZ2V0U3VidHJlZUl0ZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVTdWJ0cmVlKHN1YlJhbmdlSXRlcmF0b3IsIGZ1bmMsIGl0ZXJhdG9yU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBzdWJSYW5nZUl0ZXJhdG9yLmRldGFjaCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yU3RhdGUuc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgd2hvbGUgbm9kZSBpcyBzZWxlY3RlZCwgc28gd2UgY2FuIHVzZSBlZmZpY2llbnQgRE9NIGl0ZXJhdGlvbiB0byBpdGVyYXRlIG92ZXIgdGhlIG5vZGUgYW5kIGl0c1xuICAgICAgICAgICAgICAgIC8vIGRlc2NlbmRhbnRcbiAgICAgICAgICAgICAgICBpdCA9IGRvbS5jcmVhdGVJdGVyYXRvcihub2RlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIChuID0gaXQubmV4dCgpKSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmMobikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvclN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsZXRlU3VidHJlZShpdGVyYXRvcikge1xuICAgICAgICB2YXIgc3ViSXRlcmF0b3I7XG4gICAgICAgIHdoaWxlIChpdGVyYXRvci5uZXh0KCkpIHtcbiAgICAgICAgICAgIGlmIChpdGVyYXRvci5pc1BhcnRpYWxseVNlbGVjdGVkU3VidHJlZSgpKSB7XG4gICAgICAgICAgICAgICAgc3ViSXRlcmF0b3IgPSBpdGVyYXRvci5nZXRTdWJ0cmVlSXRlcmF0b3IoKTtcbiAgICAgICAgICAgICAgICBkZWxldGVTdWJ0cmVlKHN1Ykl0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICBzdWJJdGVyYXRvci5kZXRhY2godHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdFN1YnRyZWUoaXRlcmF0b3IpIHtcblxuICAgICAgICBmb3IgKHZhciBub2RlLCBmcmFnID0gZ2V0UmFuZ2VEb2N1bWVudChpdGVyYXRvci5yYW5nZSkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdWJJdGVyYXRvcjsgbm9kZSA9IGl0ZXJhdG9yLm5leHQoKTsgKSB7XG5cblxuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlKCkpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHN1Ykl0ZXJhdG9yID0gaXRlcmF0b3IuZ2V0U3VidHJlZUl0ZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChleHRyYWN0U3VidHJlZShzdWJJdGVyYXRvcikpO1xuICAgICAgICAgICAgICAgIHN1Ykl0ZXJhdG9yLmRldGFjaCh0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxMCkgeyAvLyBEb2N1bWVudFR5cGVcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXROb2Rlc0luUmFuZ2UocmFuZ2UsIG5vZGVUeXBlcywgZmlsdGVyKSB7XG4gICAgICAgIC8vbG9nLmluZm8oXCJnZXROb2Rlc0luUmFuZ2UsIFwiICsgbm9kZVR5cGVzLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgdmFyIGZpbHRlck5vZGVUeXBlcyA9ICEhKG5vZGVUeXBlcyAmJiBub2RlVHlwZXMubGVuZ3RoKSwgcmVnZXg7XG4gICAgICAgIHZhciBmaWx0ZXJFeGlzdHMgPSAhIWZpbHRlcjtcbiAgICAgICAgaWYgKGZpbHRlck5vZGVUeXBlcykge1xuICAgICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKFwiXihcIiArIG5vZGVUeXBlcy5qb2luKFwifFwiKSArIFwiKSRcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgaXRlcmF0ZVN1YnRyZWUobmV3IFJhbmdlSXRlcmF0b3IocmFuZ2UsIGZhbHNlKSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKCghZmlsdGVyTm9kZVR5cGVzIHx8IHJlZ2V4LnRlc3Qobm9kZS5ub2RlVHlwZSkpICYmICghZmlsdGVyRXhpc3RzIHx8IGZpbHRlcihub2RlKSkpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3BlY3QocmFuZ2UpIHtcbiAgICAgICAgdmFyIG5hbWUgPSAodHlwZW9mIHJhbmdlLmdldE5hbWUgPT0gXCJ1bmRlZmluZWRcIikgPyBcIlJhbmdlXCIgOiByYW5nZS5nZXROYW1lKCk7XG4gICAgICAgIHJldHVybiBcIltcIiArIG5hbWUgKyBcIihcIiArIGRvbS5pbnNwZWN0Tm9kZShyYW5nZS5zdGFydENvbnRhaW5lcikgKyBcIjpcIiArIHJhbmdlLnN0YXJ0T2Zmc2V0ICsgXCIsIFwiICtcbiAgICAgICAgICAgICAgICBkb20uaW5zcGVjdE5vZGUocmFuZ2UuZW5kQ29udGFpbmVyKSArIFwiOlwiICsgcmFuZ2UuZW5kT2Zmc2V0ICsgXCIpXVwiO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBSYW5nZUl0ZXJhdG9yIGNvZGUgcGFydGlhbGx5IGJvcnJvd3MgZnJvbSBJRVJhbmdlIGJ5IFRpbSBSeWFuIChodHRwOi8vZ2l0aHViLmNvbS90aW1jYW1lcm9ucnlhbi9JRVJhbmdlKVxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmFuZ2VJdGVyYXRvcihyYW5nZSwgY2xvbmVQYXJ0aWFsbHlTZWxlY3RlZFRleHROb2Rlcykge1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIHRoaXMuY2xvbmVQYXJ0aWFsbHlTZWxlY3RlZFRleHROb2RlcyA9IGNsb25lUGFydGlhbGx5U2VsZWN0ZWRUZXh0Tm9kZXM7XG5cblxuXG4gICAgICAgIGlmICghcmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICB0aGlzLnNjID0gcmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICB0aGlzLnNvID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLmVjID0gcmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgICAgICAgICAgdGhpcy5lbyA9IHJhbmdlLmVuZE9mZnNldDtcbiAgICAgICAgICAgIHZhciByb290ID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNjID09PSB0aGlzLmVjICYmIGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKHRoaXMuc2MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1NpbmdsZUNoYXJhY3RlckRhdGFOb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJzdCA9IHRoaXMuX2xhc3QgPSB0aGlzLl9uZXh0ID0gdGhpcy5zYztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSB0aGlzLl9uZXh0ID0gKHRoaXMuc2MgPT09IHJvb3QgJiYgIWRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKHRoaXMuc2MpKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2MuY2hpbGROb2Rlc1t0aGlzLnNvXSA6IGRvbS5nZXRDbG9zZXN0QW5jZXN0b3JJbih0aGlzLnNjLCByb290LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0ID0gKHRoaXMuZWMgPT09IHJvb3QgJiYgIWRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKHRoaXMuZWMpKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWMuY2hpbGROb2Rlc1t0aGlzLmVvIC0gMV0gOiBkb20uZ2V0Q2xvc2VzdEFuY2VzdG9ySW4odGhpcy5lYywgcm9vdCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIFJhbmdlSXRlcmF0b3IucHJvdG90eXBlID0ge1xuICAgICAgICBfY3VycmVudDogbnVsbCxcbiAgICAgICAgX25leHQ6IG51bGwsXG4gICAgICAgIF9maXJzdDogbnVsbCxcbiAgICAgICAgX2xhc3Q6IG51bGwsXG4gICAgICAgIGlzU2luZ2xlQ2hhcmFjdGVyRGF0YU5vZGU6IGZhbHNlLFxuXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbmV4dCA9IHRoaXMuX2ZpcnN0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc05leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fbmV4dDtcbiAgICAgICAgfSxcblxuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIE1vdmUgdG8gbmV4dCBub2RlXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9uZXh0O1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0ID0gKGN1cnJlbnQgIT09IHRoaXMuX2xhc3QpID8gY3VycmVudC5uZXh0U2libGluZyA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgcGFydGlhbGx5IHNlbGVjdGVkIHRleHQgbm9kZXNcbiAgICAgICAgICAgICAgICBpZiAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoY3VycmVudCkgJiYgdGhpcy5jbG9uZVBhcnRpYWxseVNlbGVjdGVkVGV4dE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmVjKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5jbG9uZU5vZGUodHJ1ZSkpLmRlbGV0ZURhdGEodGhpcy5lbywgY3VycmVudC5sZW5ndGggLSB0aGlzLmVvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudCA9PT0gdGhpcy5zYykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQuY2xvbmVOb2RlKHRydWUpKS5kZWxldGVEYXRhKDAsIHRoaXMuc28pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50LCBzdGFydCwgZW5kO1xuXG4gICAgICAgICAgICBpZiAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoY3VycmVudCkgJiYgKGN1cnJlbnQgPT09IHRoaXMuc2MgfHwgY3VycmVudCA9PT0gdGhpcy5lYykpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IChjdXJyZW50ID09PSB0aGlzLnNjKSA/IHRoaXMuc28gOiAwO1xuICAgICAgICAgICAgICAgIGVuZCA9IChjdXJyZW50ID09PSB0aGlzLmVjKSA/IHRoaXMuZW8gOiBjdXJyZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgIT0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuZGVsZXRlRGF0YShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGN1cnJlbnQgbm9kZSBpcyBwYXJ0aWFsbHkgc2VsZWN0ZWRcbiAgICAgICAgaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgcmV0dXJuIGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKGN1cnJlbnQsIHRoaXMucmFuZ2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFN1YnRyZWVJdGVyYXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc3ViUmFuZ2U7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NpbmdsZUNoYXJhY3RlckRhdGFOb2RlKSB7XG4gICAgICAgICAgICAgICAgc3ViUmFuZ2UgPSB0aGlzLnJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICBzdWJSYW5nZS5jb2xsYXBzZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJSYW5nZSA9IG5ldyBSYW5nZShnZXRSYW5nZURvY3VtZW50KHRoaXMucmFuZ2UpKTtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q29udGFpbmVyID0gY3VycmVudCwgc3RhcnRPZmZzZXQgPSAwLCBlbmRDb250YWluZXIgPSBjdXJyZW50LCBlbmRPZmZzZXQgPSBkb20uZ2V0Tm9kZUxlbmd0aChjdXJyZW50KTtcblxuICAgICAgICAgICAgICAgIGlmIChkb20uaXNBbmNlc3Rvck9mKGN1cnJlbnQsIHRoaXMuc2MsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gdGhpcy5zYztcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSB0aGlzLnNvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZG9tLmlzQW5jZXN0b3JPZihjdXJyZW50LCB0aGlzLmVjLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmRDb250YWluZXIgPSB0aGlzLmVjO1xuICAgICAgICAgICAgICAgICAgICBlbmRPZmZzZXQgPSB0aGlzLmVvO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHVwZGF0ZUJvdW5kYXJpZXMoc3ViUmFuZ2UsIHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZUl0ZXJhdG9yKHN1YlJhbmdlLCB0aGlzLmNsb25lUGFydGlhbGx5U2VsZWN0ZWRUZXh0Tm9kZXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRldGFjaDogZnVuY3Rpb24oZGV0YWNoUmFuZ2UpIHtcbiAgICAgICAgICAgIGlmIChkZXRhY2hSYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UuZGV0YWNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5fY3VycmVudCA9IHRoaXMuX25leHQgPSB0aGlzLl9maXJzdCA9IHRoaXMuX2xhc3QgPSB0aGlzLnNjID0gdGhpcy5zbyA9IHRoaXMuZWMgPSB0aGlzLmVvID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gRXhjZXB0aW9uc1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmFuZ2VFeGNlcHRpb24oY29kZU5hbWUpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gdGhpc1tjb2RlTmFtZV07XG4gICAgICAgIHRoaXMuY29kZU5hbWUgPSBjb2RlTmFtZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJSYW5nZUV4Y2VwdGlvbjogXCIgKyB0aGlzLmNvZGVOYW1lO1xuICAgIH1cblxuICAgIFJhbmdlRXhjZXB0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAgICAgQkFEX0JPVU5EQVJZUE9JTlRTX0VSUjogMSxcbiAgICAgICAgSU5WQUxJRF9OT0RFX1RZUEVfRVJSOiAyXG4gICAgfTtcblxuICAgIFJhbmdlRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudGx5IGl0ZXJhdGVzIHRocm91Z2ggYWxsIG5vZGVzIGluIHRoZSByYW5nZSBvbiBjcmVhdGlvbiB1bnRpbCBJIHRoaW5rIG9mIGEgZGVjZW50IHdheSB0byBkbyBpdFxuICAgICAqIFRPRE86IExvb2sgaW50byBtYWtpbmcgdGhpcyBhIHByb3BlciBpdGVyYXRvciwgbm90IHJlcXVpcmluZyBwcmVsb2FkaW5nIGV2ZXJ5dGhpbmcgZmlyc3RcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSYW5nZU5vZGVJdGVyYXRvcihyYW5nZSwgbm9kZVR5cGVzLCBmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IGdldE5vZGVzSW5SYW5nZShyYW5nZSwgbm9kZVR5cGVzLCBmaWx0ZXIpO1xuICAgICAgICB0aGlzLl9uZXh0ID0gdGhpcy5ub2Rlc1swXTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSAwO1xuICAgIH1cblxuICAgIFJhbmdlTm9kZUl0ZXJhdG9yLnByb3RvdHlwZSA9IHtcbiAgICAgICAgX2N1cnJlbnQ6IG51bGwsXG5cbiAgICAgICAgaGFzTmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLl9uZXh0O1xuICAgICAgICB9LFxuXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX25leHQ7XG4gICAgICAgICAgICB0aGlzLl9uZXh0ID0gdGhpcy5ub2Rlc1sgKyt0aGlzLl9wb3NpdGlvbiBdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9uZXh0ID0gdGhpcy5ub2RlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJlZm9yZUFmdGVyTm9kZVR5cGVzID0gWzEsIDMsIDQsIDUsIDcsIDgsIDEwXTtcbiAgICB2YXIgcm9vdENvbnRhaW5lck5vZGVUeXBlcyA9IFsyLCA5LCAxMV07XG4gICAgdmFyIHJlYWRvbmx5Tm9kZVR5cGVzID0gWzUsIDYsIDEwLCAxMl07XG4gICAgdmFyIGluc2VydGFibGVOb2RlVHlwZXMgPSBbMSwgMywgNCwgNSwgNywgOCwgMTAsIDExXTtcbiAgICB2YXIgc3Vycm91bmROb2RlVHlwZXMgPSBbMSwgMywgNCwgNSwgNywgOF07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVBbmNlc3RvckZpbmRlcihub2RlVHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUsIHNlbGZJc0FuY2VzdG9yKSB7XG4gICAgICAgICAgICB2YXIgdCwgbiA9IHNlbGZJc0FuY2VzdG9yID8gbm9kZSA6IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICAgICAgdCA9IG4ubm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGRvbS5hcnJheUNvbnRhaW5zKG5vZGVUeXBlcywgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG4gPSBuLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZ2V0Um9vdENvbnRhaW5lciA9IGRvbS5nZXRSb290Q29udGFpbmVyO1xuICAgIHZhciBnZXREb2N1bWVudE9yRnJhZ21lbnRDb250YWluZXIgPSBjcmVhdGVBbmNlc3RvckZpbmRlciggWzksIDExXSApO1xuICAgIHZhciBnZXRSZWFkb25seUFuY2VzdG9yID0gY3JlYXRlQW5jZXN0b3JGaW5kZXIocmVhZG9ubHlOb2RlVHlwZXMpO1xuICAgIHZhciBnZXREb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3RvciA9IGNyZWF0ZUFuY2VzdG9yRmluZGVyKCBbNiwgMTAsIDEyXSApO1xuXG4gICAgZnVuY3Rpb24gYXNzZXJ0Tm9Eb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3Rvcihub2RlLCBhbGxvd1NlbGYpIHtcbiAgICAgICAgaWYgKGdldERvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIGFsbG93U2VsZikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUV4Y2VwdGlvbihcIklOVkFMSURfTk9ERV9UWVBFX0VSUlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydE5vdERldGFjaGVkKHJhbmdlKSB7XG4gICAgICAgIGlmICghcmFuZ2Uuc3RhcnRDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTlZBTElEX1NUQVRFX0VSUlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydFZhbGlkTm9kZVR5cGUobm9kZSwgaW52YWxpZFR5cGVzKSB7XG4gICAgICAgIGlmICghZG9tLmFycmF5Q29udGFpbnMoaW52YWxpZFR5cGVzLCBub2RlLm5vZGVUeXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXhjZXB0aW9uKFwiSU5WQUxJRF9OT0RFX1RZUEVfRVJSXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0VmFsaWRPZmZzZXQobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IChkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShub2RlKSA/IG5vZGUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTkRFWF9TSVpFX0VSUlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydFNhbWVEb2N1bWVudE9yRnJhZ21lbnQobm9kZTEsIG5vZGUyKSB7XG4gICAgICAgIGlmIChnZXREb2N1bWVudE9yRnJhZ21lbnRDb250YWluZXIobm9kZTEsIHRydWUpICE9PSBnZXREb2N1bWVudE9yRnJhZ21lbnRDb250YWluZXIobm9kZTIsIHRydWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiV1JPTkdfRE9DVU1FTlRfRVJSXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU5vdFJlYWRPbmx5KG5vZGUpIHtcbiAgICAgICAgaWYgKGdldFJlYWRvbmx5QW5jZXN0b3Iobm9kZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlJcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnROb2RlKG5vZGUsIGNvZGVOYW1lKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihjb2RlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09ycGhhbihub2RlKSB7XG4gICAgICAgIHJldHVybiAhZG9tLmFycmF5Q29udGFpbnMocm9vdENvbnRhaW5lck5vZGVUeXBlcywgbm9kZS5ub2RlVHlwZSkgJiYgIWdldERvY3VtZW50T3JGcmFnbWVudENvbnRhaW5lcihub2RlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkT2Zmc2V0KG5vZGUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gb2Zmc2V0IDw9IChkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShub2RlKSA/IG5vZGUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNzZXJ0UmFuZ2VWYWxpZChyYW5nZSkge1xuICAgICAgICBhc3NlcnROb3REZXRhY2hlZChyYW5nZSk7XG4gICAgICAgIGlmIChpc09ycGhhbihyYW5nZS5zdGFydENvbnRhaW5lcikgfHwgaXNPcnBoYW4ocmFuZ2UuZW5kQ29udGFpbmVyKSB8fFxuICAgICAgICAgICAgICAgICFpc1ZhbGlkT2Zmc2V0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCkgfHxcbiAgICAgICAgICAgICAgICAhaXNWYWxpZE9mZnNldChyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbmdlIGVycm9yOiBSYW5nZSBpcyBubyBsb25nZXIgdmFsaWQgYWZ0ZXIgRE9NIG11dGF0aW9uIChcIiArIHJhbmdlLmluc3BlY3QoKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBUZXN0IHRoZSBicm93c2VyJ3MgaW5uZXJIVE1MIHN1cHBvcnQgdG8gZGVjaWRlIGhvdyB0byBpbXBsZW1lbnQgY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50XG4gICAgdmFyIHN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgdmFyIGh0bWxQYXJzaW5nQ29uZm9ybXMgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBzdHlsZUVsLmlubmVySFRNTCA9IFwiPGI+eDwvYj5cIjtcbiAgICAgICAgaHRtbFBhcnNpbmdDb25mb3JtcyA9IChzdHlsZUVsLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMyk7IC8vIE9wZXJhIGluY29ycmVjdGx5IGNyZWF0ZXMgYW4gZWxlbWVudCBub2RlXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJRSA2IGFuZCA3IHRocm93XG4gICAgfVxuXG4gICAgYXBpLmZlYXR1cmVzLmh0bWxQYXJzaW5nQ29uZm9ybXMgPSBodG1sUGFyc2luZ0NvbmZvcm1zO1xuXG4gICAgdmFyIGNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCA9IGh0bWxQYXJzaW5nQ29uZm9ybXMgP1xuXG4gICAgICAgIC8vIEltcGxlbWVudGF0aW9uIGFzIHBlciBIVE1MIHBhcnNpbmcgc3BlYywgdHJ1c3RpbmcgaW4gdGhlIGJyb3dzZXIncyBpbXBsZW1lbnRhdGlvbiBvZiBpbm5lckhUTUwuIFNlZVxuICAgICAgICAvLyBkaXNjdXNzaW9uIGFuZCBiYXNlIGNvZGUgZm9yIHRoaXMgaW1wbGVtZW50YXRpb24gYXQgaXNzdWUgNjcuXG4gICAgICAgIC8vIFNwZWM6IGh0dHA6Ly9odG1sNS5vcmcvc3BlY3MvZG9tLXBhcnNpbmcuaHRtbCNleHRlbnNpb25zLXRvLXRoZS1yYW5nZS1pbnRlcmZhY2VcbiAgICAgICAgLy8gVGhhbmtzIHRvIEFsZWtzIFdpbGxpYW1zLlxuICAgICAgICBmdW5jdGlvbihmcmFnbWVudFN0cikge1xuICAgICAgICAgICAgLy8gXCJMZXQgbm9kZSB0aGUgY29udGV4dCBvYmplY3QncyBzdGFydCdzIG5vZGUuXCJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgIHZhciBkb2MgPSBkb20uZ2V0RG9jdW1lbnQobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIFwiSWYgdGhlIGNvbnRleHQgb2JqZWN0J3Mgc3RhcnQncyBub2RlIGlzIG51bGwsIHJhaXNlIGFuIElOVkFMSURfU1RBVEVfRVJSXG4gICAgICAgICAgICAvLyBleGNlcHRpb24gYW5kIGFib3J0IHRoZXNlIHN0ZXBzLlwiXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSU5WQUxJRF9TVEFURV9FUlJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFwiTGV0IGVsZW1lbnQgYmUgYXMgZm9sbG93cywgZGVwZW5kaW5nIG9uIG5vZGUncyBpbnRlcmZhY2U6XCJcbiAgICAgICAgICAgIC8vIERvY3VtZW50LCBEb2N1bWVudCBGcmFnbWVudDogbnVsbFxuICAgICAgICAgICAgdmFyIGVsID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gXCJFbGVtZW50OiBub2RlXCJcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBlbCA9IG5vZGU7XG5cbiAgICAgICAgICAgIC8vIFwiVGV4dCwgQ29tbWVudDogbm9kZSdzIHBhcmVudEVsZW1lbnRcIlxuICAgICAgICAgICAgfSBlbHNlIGlmIChkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGVsID0gZG9tLnBhcmVudEVsZW1lbnQobm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFwiSWYgZWl0aGVyIGVsZW1lbnQgaXMgbnVsbCBvciBlbGVtZW50J3Mgb3duZXJEb2N1bWVudCBpcyBhbiBIVE1MIGRvY3VtZW50XG4gICAgICAgICAgICAvLyBhbmQgZWxlbWVudCdzIGxvY2FsIG5hbWUgaXMgXCJodG1sXCIgYW5kIGVsZW1lbnQncyBuYW1lc3BhY2UgaXMgdGhlIEhUTUxcbiAgICAgICAgICAgIC8vIG5hbWVzcGFjZVwiXG4gICAgICAgICAgICBpZiAoZWwgPT09IG51bGwgfHwgKFxuICAgICAgICAgICAgICAgIGVsLm5vZGVOYW1lID09IFwiSFRNTFwiXG4gICAgICAgICAgICAgICAgJiYgZG9tLmlzSHRtbE5hbWVzcGFjZShkb20uZ2V0RG9jdW1lbnQoZWwpLmRvY3VtZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICAmJiBkb20uaXNIdG1sTmFtZXNwYWNlKGVsKVxuICAgICAgICAgICAgKSkge1xuXG4gICAgICAgICAgICAvLyBcImxldCBlbGVtZW50IGJlIGEgbmV3IEVsZW1lbnQgd2l0aCBcImJvZHlcIiBhcyBpdHMgbG9jYWwgbmFtZSBhbmQgdGhlIEhUTUxcbiAgICAgICAgICAgIC8vIG5hbWVzcGFjZSBhcyBpdHMgbmFtZXNwYWNlLlwiXCJcbiAgICAgICAgICAgICAgICBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYm9keVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwgPSBlbC5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBcIklmIHRoZSBub2RlJ3MgZG9jdW1lbnQgaXMgYW4gSFRNTCBkb2N1bWVudDogSW52b2tlIHRoZSBIVE1MIGZyYWdtZW50IHBhcnNpbmcgYWxnb3JpdGhtLlwiXG4gICAgICAgICAgICAvLyBcIklmIHRoZSBub2RlJ3MgZG9jdW1lbnQgaXMgYW4gWE1MIGRvY3VtZW50OiBJbnZva2UgdGhlIFhNTCBmcmFnbWVudCBwYXJzaW5nIGFsZ29yaXRobS5cIlxuICAgICAgICAgICAgLy8gXCJJbiBlaXRoZXIgY2FzZSwgdGhlIGFsZ29yaXRobSBtdXN0IGJlIGludm9rZWQgd2l0aCBmcmFnbWVudCBhcyB0aGUgaW5wdXRcbiAgICAgICAgICAgIC8vIGFuZCBlbGVtZW50IGFzIHRoZSBjb250ZXh0IGVsZW1lbnQuXCJcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IGZyYWdtZW50U3RyO1xuXG4gICAgICAgICAgICAvLyBcIklmIHRoaXMgcmFpc2VzIGFuIGV4Y2VwdGlvbiwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy4gT3RoZXJ3aXNlLCBsZXQgbmV3XG4gICAgICAgICAgICAvLyBjaGlsZHJlbiBiZSB0aGUgbm9kZXMgcmV0dXJuZWQuXCJcblxuICAgICAgICAgICAgLy8gXCJMZXQgZnJhZ21lbnQgYmUgYSBuZXcgRG9jdW1lbnRGcmFnbWVudC5cIlxuICAgICAgICAgICAgLy8gXCJBcHBlbmQgYWxsIG5ldyBjaGlsZHJlbiB0byBmcmFnbWVudC5cIlxuICAgICAgICAgICAgLy8gXCJSZXR1cm4gZnJhZ21lbnQuXCJcbiAgICAgICAgICAgIHJldHVybiBkb20uZnJhZ21lbnRGcm9tTm9kZUNoaWxkcmVuKGVsKTtcbiAgICAgICAgfSA6XG5cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpbm5lckhUTUwgY2Fubm90IGJlIHRydXN0ZWQsIHNvIGZhbGwgYmFjayB0byBhIHNpbXBsZXIsIG5vbi1jb25mb3JtYW50IGltcGxlbWVudGF0aW9uIHRoYXRcbiAgICAgICAgLy8gcHJldmlvdXMgdmVyc2lvbnMgb2YgUmFuZ3kgdXNlZCAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIHVzaW5nIGEgYm9keSBlbGVtZW50IHJhdGhlciB0aGFuIGEgZGl2KVxuICAgICAgICBmdW5jdGlvbihmcmFnbWVudFN0cikge1xuICAgICAgICAgICAgYXNzZXJ0Tm90RGV0YWNoZWQodGhpcyk7XG4gICAgICAgICAgICB2YXIgZG9jID0gZ2V0UmFuZ2VEb2N1bWVudCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYm9keVwiKTtcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IGZyYWdtZW50U3RyO1xuXG4gICAgICAgICAgICByZXR1cm4gZG9tLmZyYWdtZW50RnJvbU5vZGVDaGlsZHJlbihlbCk7XG4gICAgICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgdmFyIHJhbmdlUHJvcGVydGllcyA9IFtcInN0YXJ0Q29udGFpbmVyXCIsIFwic3RhcnRPZmZzZXRcIiwgXCJlbmRDb250YWluZXJcIiwgXCJlbmRPZmZzZXRcIiwgXCJjb2xsYXBzZWRcIixcbiAgICAgICAgXCJjb21tb25BbmNlc3RvckNvbnRhaW5lclwiXTtcblxuICAgIHZhciBzMnMgPSAwLCBzMmUgPSAxLCBlMmUgPSAyLCBlMnMgPSAzO1xuICAgIHZhciBuX2IgPSAwLCBuX2EgPSAxLCBuX2JfYSA9IDIsIG5faSA9IDM7XG5cbiAgICBmdW5jdGlvbiBSYW5nZVByb3RvdHlwZSgpIHt9XG5cbiAgICBSYW5nZVByb3RvdHlwZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGF0dGFjaExpc3RlbmVyOiBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbXBhcmVCb3VuZGFyeVBvaW50czogZnVuY3Rpb24oaG93LCByYW5nZSkge1xuICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgICAgICAgIGFzc2VydFNhbWVEb2N1bWVudE9yRnJhZ21lbnQodGhpcy5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRDb250YWluZXIpO1xuXG4gICAgICAgICAgICB2YXIgbm9kZUEsIG9mZnNldEEsIG5vZGVCLCBvZmZzZXRCO1xuICAgICAgICAgICAgdmFyIHByZWZpeEEgPSAoaG93ID09IGUycyB8fCBob3cgPT0gczJzKSA/IFwic3RhcnRcIiA6IFwiZW5kXCI7XG4gICAgICAgICAgICB2YXIgcHJlZml4QiA9IChob3cgPT0gczJlIHx8IGhvdyA9PSBzMnMpID8gXCJzdGFydFwiIDogXCJlbmRcIjtcbiAgICAgICAgICAgIG5vZGVBID0gdGhpc1twcmVmaXhBICsgXCJDb250YWluZXJcIl07XG4gICAgICAgICAgICBvZmZzZXRBID0gdGhpc1twcmVmaXhBICsgXCJPZmZzZXRcIl07XG4gICAgICAgICAgICBub2RlQiA9IHJhbmdlW3ByZWZpeEIgKyBcIkNvbnRhaW5lclwiXTtcbiAgICAgICAgICAgIG9mZnNldEIgPSByYW5nZVtwcmVmaXhCICsgXCJPZmZzZXRcIl07XG4gICAgICAgICAgICByZXR1cm4gZG9tLmNvbXBhcmVQb2ludHMobm9kZUEsIG9mZnNldEEsIG5vZGVCLCBvZmZzZXRCKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlcnROb2RlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgYXNzZXJ0VmFsaWROb2RlVHlwZShub2RlLCBpbnNlcnRhYmxlTm9kZVR5cGVzKTtcbiAgICAgICAgICAgIGFzc2VydE5vZGVOb3RSZWFkT25seSh0aGlzLnN0YXJ0Q29udGFpbmVyKTtcblxuICAgICAgICAgICAgaWYgKGRvbS5pc0FuY2VzdG9yT2Yobm9kZSwgdGhpcy5zdGFydENvbnRhaW5lciwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBjaGVjayBmb3Igd2hldGhlciB0aGUgY29udGFpbmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgUmFuZ2UgaXMgb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWxsb3dcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuIG9mIHRoZSB0eXBlIG9mIG5vZGU6IHRoZSBicm93c2VyJ3MgRE9NIGltcGxlbWVudGF0aW9uIHNob3VsZCBkbyB0aGlzIGZvciB1cyB3aGVuIHdlIGF0dGVtcHRcbiAgICAgICAgICAgIC8vIHRvIGFkZCB0aGUgbm9kZVxuXG4gICAgICAgICAgICB2YXIgZmlyc3ROb2RlSW5zZXJ0ZWQgPSBpbnNlcnROb2RlQXRQb3NpdGlvbihub2RlLCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhcnRCZWZvcmUoZmlyc3ROb2RlSW5zZXJ0ZWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsb25lQ29udGVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIGNsb25lLCBmcmFnO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFJhbmdlRG9jdW1lbnQodGhpcykuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydENvbnRhaW5lciA9PT0gdGhpcy5lbmRDb250YWluZXIgJiYgZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUodGhpcy5zdGFydENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSB0aGlzLnN0YXJ0Q29udGFpbmVyLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmUuZGF0YSA9IGNsb25lLmRhdGEuc2xpY2UodGhpcy5zdGFydE9mZnNldCwgdGhpcy5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBmcmFnID0gZ2V0UmFuZ2VEb2N1bWVudCh0aGlzKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgUmFuZ2VJdGVyYXRvcih0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBjbG9uZVN1YnRyZWUoaXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNhblN1cnJvdW5kQ29udGVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgICAgICAgIGFzc2VydE5vZGVOb3RSZWFkT25seSh0aGlzLnN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgICAgIGFzc2VydE5vZGVOb3RSZWFkT25seSh0aGlzLmVuZENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZW50cyBjYW4gYmUgc3Vycm91bmRlZC4gU3BlY2lmaWNhbGx5LCB0aGlzIG1lYW5zIHdoZXRoZXIgdGhlIHJhbmdlIHBhcnRpYWxseSBzZWxlY3RzXG4gICAgICAgICAgICAvLyBubyBub24tdGV4dCBub2Rlcy5cbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgdmFyIGJvdW5kYXJpZXNJbnZhbGlkID0gKGl0ZXJhdG9yLl9maXJzdCAmJiAoaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQoaXRlcmF0b3IuX2ZpcnN0LCB0aGlzKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGl0ZXJhdG9yLl9sYXN0ICYmIGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKGl0ZXJhdG9yLl9sYXN0LCB0aGlzKSkpO1xuICAgICAgICAgICAgaXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICAgICAgICByZXR1cm4gIWJvdW5kYXJpZXNJbnZhbGlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN1cnJvdW5kQ29udGVudHM6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGFzc2VydFZhbGlkTm9kZVR5cGUobm9kZSwgc3Vycm91bmROb2RlVHlwZXMpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FuU3Vycm91bmRDb250ZW50cygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXhjZXB0aW9uKFwiQkFEX0JPVU5EQVJZUE9JTlRTX0VSUlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29udGVudHNcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5leHRyYWN0Q29udGVudHMoKTtcblxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGNoaWxkcmVuIG9mIHRoZSBub2RlXG4gICAgICAgICAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5ldyBub2RlIGFuZCBhZGQgdGhlIGV4dHJhY3RlZCBjb250ZW50c1xuICAgICAgICAgICAgaW5zZXJ0Tm9kZUF0UG9zaXRpb24obm9kZSwgdGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCk7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdE5vZGUobm9kZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xvbmVSYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKGdldFJhbmdlRG9jdW1lbnQodGhpcykpO1xuICAgICAgICAgICAgdmFyIGkgPSByYW5nZVByb3BlcnRpZXMubGVuZ3RoLCBwcm9wO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIHByb3AgPSByYW5nZVByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgcmFuZ2VbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICAgICAgICB2YXIgc2MgPSB0aGlzLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKHNjID09PSB0aGlzLmVuZENvbnRhaW5lciAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShzYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNjLm5vZGVUeXBlID09IDMgfHwgc2Mubm9kZVR5cGUgPT0gNCkgPyBzYy5kYXRhLnNsaWNlKHRoaXMuc3RhcnRPZmZzZXQsIHRoaXMuZW5kT2Zmc2V0KSA6IFwiXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0Qml0cyA9IFtdLCBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgaXRlcmF0ZVN1YnRyZWUoaXRlcmF0b3IsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWNjZXB0IG9ubHkgdGV4dCBvciBDREFUQSBub2Rlcywgbm90IGNvbW1lbnRzXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyB8fCBub2RlLm5vZGVUeXBlID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRCaXRzLnB1c2gobm9kZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0Qml0cy5qb2luKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRoZSBtZXRob2RzIGJlbG93IGFyZSBhbGwgbm9uLXN0YW5kYXJkLiBUaGUgZm9sbG93aW5nIGJhdGNoIHdlcmUgaW50cm9kdWNlZCBieSBNb3ppbGxhIGJ1dCBoYXZlIHNpbmNlXG4gICAgICAgIC8vIGJlZW4gcmVtb3ZlZCBmcm9tIE1vemlsbGEuXG5cbiAgICAgICAgY29tcGFyZU5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gZG9tLmdldE5vZGVJbmRleChub2RlKTtcblxuICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiTk9UX0ZPVU5EX0VSUlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0YXJ0Q29tcGFyaXNvbiA9IHRoaXMuY29tcGFyZVBvaW50KHBhcmVudCwgbm9kZUluZGV4KSxcbiAgICAgICAgICAgICAgICBlbmRDb21wYXJpc29uID0gdGhpcy5jb21wYXJlUG9pbnQocGFyZW50LCBub2RlSW5kZXggKyAxKTtcblxuICAgICAgICAgICAgaWYgKHN0YXJ0Q29tcGFyaXNvbiA8IDApIHsgLy8gTm9kZSBzdGFydHMgYmVmb3JlXG4gICAgICAgICAgICAgICAgcmV0dXJuIChlbmRDb21wYXJpc29uID4gMCkgPyBuX2JfYSA6IG5fYjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChlbmRDb21wYXJpc29uID4gMCkgPyBuX2EgOiBuX2k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tcGFyZVBvaW50OiBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICAgICAgICBhc3NlcnROb2RlKG5vZGUsIFwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSXCIpO1xuICAgICAgICAgICAgYXNzZXJ0U2FtZURvY3VtZW50T3JGcmFnbWVudChub2RlLCB0aGlzLnN0YXJ0Q29udGFpbmVyKTtcblxuICAgICAgICAgICAgaWYgKGRvbS5jb21wYXJlUG9pbnRzKG5vZGUsIG9mZnNldCwgdGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkb20uY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQ6IGNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCxcblxuICAgICAgICB0b0h0bWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBnZXRSYW5nZURvY3VtZW50KHRoaXMpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jbG9uZUNvbnRlbnRzKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gdG91Y2hpbmdJc0ludGVyc2VjdGluZyBkZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBtZXRob2QgY29uc2lkZXJzIGEgbm9kZSB0aGF0IGJvcmRlcnMgYSByYW5nZSBpbnRlcnNlY3RzXG4gICAgICAgIC8vIHdpdGggaXQgKGFzIGluIFdlYktpdCkgb3Igbm90IChhcyBpbiBHZWNrbyBwcmUtMS45LCBhbmQgdGhlIGRlZmF1bHQpXG4gICAgICAgIGludGVyc2VjdHNOb2RlOiBmdW5jdGlvbihub2RlLCB0b3VjaGluZ0lzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgYXNzZXJ0Tm9kZShub2RlLCBcIk5PVF9GT1VORF9FUlJcIik7XG4gICAgICAgICAgICBpZiAoZG9tLmdldERvY3VtZW50KG5vZGUpICE9PSBnZXRSYW5nZURvY3VtZW50KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlLCBvZmZzZXQgPSBkb20uZ2V0Tm9kZUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgYXNzZXJ0Tm9kZShwYXJlbnQsIFwiTk9UX0ZPVU5EX0VSUlwiKTtcblxuICAgICAgICAgICAgdmFyIHN0YXJ0Q29tcGFyaXNvbiA9IGRvbS5jb21wYXJlUG9pbnRzKHBhcmVudCwgb2Zmc2V0LCB0aGlzLmVuZENvbnRhaW5lciwgdGhpcy5lbmRPZmZzZXQpLFxuICAgICAgICAgICAgICAgIGVuZENvbXBhcmlzb24gPSBkb20uY29tcGFyZVBvaW50cyhwYXJlbnQsIG9mZnNldCArIDEsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpO1xuXG4gICAgICAgICAgICByZXR1cm4gdG91Y2hpbmdJc0ludGVyc2VjdGluZyA/IHN0YXJ0Q29tcGFyaXNvbiA8PSAwICYmIGVuZENvbXBhcmlzb24gPj0gMCA6IHN0YXJ0Q29tcGFyaXNvbiA8IDAgJiYgZW5kQ29tcGFyaXNvbiA+IDA7XG4gICAgICAgIH0sXG5cblxuICAgICAgICBpc1BvaW50SW5SYW5nZTogZnVuY3Rpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgYXNzZXJ0Tm9kZShub2RlLCBcIkhJRVJBUkNIWV9SRVFVRVNUX0VSUlwiKTtcbiAgICAgICAgICAgIGFzc2VydFNhbWVEb2N1bWVudE9yRnJhZ21lbnQobm9kZSwgdGhpcy5zdGFydENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHJldHVybiAoZG9tLmNvbXBhcmVQb2ludHMobm9kZSwgb2Zmc2V0LCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0KSA+PSAwKSAmJlxuICAgICAgICAgICAgICAgICAgIChkb20uY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCkgPD0gMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVGhlIG1ldGhvZHMgYmVsb3cgYXJlIG5vbi1zdGFuZGFyZCBhbmQgaW52ZW50ZWQgYnkgbWUuXG5cbiAgICAgICAgLy8gU2hhcmluZyBhIGJvdW5kYXJ5IHN0YXJ0LXRvLWVuZCBvciBlbmQtdG8tc3RhcnQgZG9lcyBub3QgY291bnQgYXMgaW50ZXJzZWN0aW9uLlxuICAgICAgICBpbnRlcnNlY3RzUmFuZ2U6IGZ1bmN0aW9uKHJhbmdlLCB0b3VjaGluZ0lzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoZ2V0UmFuZ2VEb2N1bWVudChyYW5nZSkgIT0gZ2V0UmFuZ2VEb2N1bWVudCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJXUk9OR19ET0NVTUVOVF9FUlJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdGFydENvbXBhcmlzb24gPSBkb20uY29tcGFyZVBvaW50cyh0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0LCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCksXG4gICAgICAgICAgICAgICAgZW5kQ29tcGFyaXNvbiA9IGRvbS5jb21wYXJlUG9pbnRzKHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCwgcmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRvdWNoaW5nSXNJbnRlcnNlY3RpbmcgPyBzdGFydENvbXBhcmlzb24gPD0gMCAmJiBlbmRDb21wYXJpc29uID49IDAgOiBzdGFydENvbXBhcmlzb24gPCAwICYmIGVuZENvbXBhcmlzb24gPiAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGludGVyc2VjdGlvbjogZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmludGVyc2VjdHNSYW5nZShyYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb21wYXJpc29uID0gZG9tLmNvbXBhcmVQb2ludHModGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCwgcmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29tcGFyaXNvbiA9IGRvbS5jb21wYXJlUG9pbnRzKHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCwgcmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvblJhbmdlID0gdGhpcy5jbG9uZVJhbmdlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRDb21wYXJpc29uID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblJhbmdlLnNldFN0YXJ0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbmRDb21wYXJpc29uID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvblJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5pb246IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RzUmFuZ2UocmFuZ2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVuaW9uUmFuZ2UgPSB0aGlzLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLmNvbXBhcmVQb2ludHMocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0KSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlvblJhbmdlLnNldFN0YXJ0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkb20uY29tcGFyZVBvaW50cyhyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCwgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0KSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaW9uUmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuaW9uUmFuZ2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUV4Y2VwdGlvbihcIlJhbmdlcyBkbyBub3QgaW50ZXJzZWN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRhaW5zTm9kZTogZnVuY3Rpb24obm9kZSwgYWxsb3dQYXJ0aWFsKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dQYXJ0aWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0c05vZGUobm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlTm9kZShub2RlKSA9PSBuX2k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpbnNOb2RlQ29udGVudHM6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVQb2ludChub2RlLCAwKSA+PSAwICYmIHRoaXMuY29tcGFyZVBvaW50KG5vZGUsIGRvbS5nZXROb2RlTGVuZ3RoKG5vZGUpKSA8PSAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRhaW5zUmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3Rpb24ocmFuZ2UpLmVxdWFscyhyYW5nZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpbnNOb2RlVGV4dDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGVSYW5nZSA9IHRoaXMuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgICAgbm9kZVJhbmdlLnNlbGVjdE5vZGUobm9kZSk7XG4gICAgICAgICAgICB2YXIgdGV4dE5vZGVzID0gbm9kZVJhbmdlLmdldE5vZGVzKFszXSk7XG4gICAgICAgICAgICBpZiAodGV4dE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2RlUmFuZ2Uuc2V0U3RhcnQodGV4dE5vZGVzWzBdLCAwKTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFRleHROb2RlID0gdGV4dE5vZGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIG5vZGVSYW5nZS5zZXRFbmQobGFzdFRleHROb2RlLCBsYXN0VGV4dE5vZGUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbnMgPSB0aGlzLmNvbnRhaW5zUmFuZ2Uobm9kZVJhbmdlKTtcbiAgICAgICAgICAgICAgICBub2RlUmFuZ2UuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluc05vZGVDb250ZW50cyhub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVOb2RlSXRlcmF0b3I6IGZ1bmN0aW9uKG5vZGVUeXBlcywgZmlsdGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYW5nZU5vZGVJdGVyYXRvcih0aGlzLCBub2RlVHlwZXMsIGZpbHRlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Tm9kZXM6IGZ1bmN0aW9uKG5vZGVUeXBlcywgZmlsdGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGdldE5vZGVzSW5SYW5nZSh0aGlzLCBub2RlVHlwZXMsIGZpbHRlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RG9jdW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFJhbmdlRG9jdW1lbnQodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29sbGFwc2VCZWZvcmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGFzc2VydE5vdERldGFjaGVkKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLnNldEVuZEJlZm9yZShub2RlKTtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbGxhcHNlQWZ0ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGFzc2VydE5vdERldGFjaGVkKHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXJ0QWZ0ZXIobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldE5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiRG9tUmFuZ2VcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gUmFuZ2UucmFuZ2VzRXF1YWwodGhpcywgcmFuZ2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluc3BlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3QodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY29weUNvbXBhcmlzb25Db25zdGFudHNUb09iamVjdChvYmopIHtcbiAgICAgICAgb2JqLlNUQVJUX1RPX1NUQVJUID0gczJzO1xuICAgICAgICBvYmouU1RBUlRfVE9fRU5EID0gczJlO1xuICAgICAgICBvYmouRU5EX1RPX0VORCA9IGUyZTtcbiAgICAgICAgb2JqLkVORF9UT19TVEFSVCA9IGUycztcblxuICAgICAgICBvYmouTk9ERV9CRUZPUkUgPSBuX2I7XG4gICAgICAgIG9iai5OT0RFX0FGVEVSID0gbl9hO1xuICAgICAgICBvYmouTk9ERV9CRUZPUkVfQU5EX0FGVEVSID0gbl9iX2E7XG4gICAgICAgIG9iai5OT0RFX0lOU0lERSA9IG5faTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29tcGFyaXNvbkNvbnN0YW50cyhjb25zdHJ1Y3Rvcikge1xuICAgICAgICBjb3B5Q29tcGFyaXNvbkNvbnN0YW50c1RvT2JqZWN0KGNvbnN0cnVjdG9yKTtcbiAgICAgICAgY29weUNvbXBhcmlzb25Db25zdGFudHNUb09iamVjdChjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlQ29udGVudFJlbW92ZXIocmVtb3ZlciwgYm91bmRhcnlVcGRhdGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG5cbiAgICAgICAgICAgIHZhciBzYyA9IHRoaXMuc3RhcnRDb250YWluZXIsIHNvID0gdGhpcy5zdGFydE9mZnNldCwgcm9vdCA9IHRoaXMuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuXG4gICAgICAgICAgICAvLyBXb3JrIG91dCB3aGVyZSB0byBwb3NpdGlvbiB0aGUgcmFuZ2UgYWZ0ZXIgY29udGVudCByZW1vdmFsXG4gICAgICAgICAgICB2YXIgbm9kZSwgYm91bmRhcnk7XG4gICAgICAgICAgICBpZiAoc2MgIT09IHJvb3QpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gZG9tLmdldENsb3Nlc3RBbmNlc3RvckluKHNjLCByb290LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBib3VuZGFyeSA9IGdldEJvdW5kYXJ5QWZ0ZXJOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIHNjID0gYm91bmRhcnkubm9kZTtcbiAgICAgICAgICAgICAgICBzbyA9IGJvdW5kYXJ5Lm9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgbm9uZSBvZiB0aGUgcmFuZ2UgaXMgcmVhZC1vbmx5XG4gICAgICAgICAgICBpdGVyYXRlU3VidHJlZShpdGVyYXRvciwgYXNzZXJ0Tm9kZU5vdFJlYWRPbmx5KTtcblxuICAgICAgICAgICAgaXRlcmF0b3IucmVzZXQoKTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBjb250ZW50XG4gICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSByZW1vdmVyKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmRldGFjaCgpO1xuXG4gICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXcgcG9zaXRpb25cbiAgICAgICAgICAgIGJvdW5kYXJ5VXBkYXRlcih0aGlzLCBzYywgc28sIHNjLCBzbyk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQcm90b3R5cGVSYW5nZShjb25zdHJ1Y3RvciwgYm91bmRhcnlVcGRhdGVyLCBkZXRhY2hlcikge1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoaXNCZWZvcmUsIGlzU3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Tm90RGV0YWNoZWQodGhpcyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VmFsaWROb2RlVHlwZShub2RlLCBiZWZvcmVBZnRlck5vZGVUeXBlcyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VmFsaWROb2RlVHlwZShnZXRSb290Q29udGFpbmVyKG5vZGUpLCByb290Q29udGFpbmVyTm9kZVR5cGVzKTtcblxuICAgICAgICAgICAgICAgIHZhciBib3VuZGFyeSA9IChpc0JlZm9yZSA/IGdldEJvdW5kYXJ5QmVmb3JlTm9kZSA6IGdldEJvdW5kYXJ5QWZ0ZXJOb2RlKShub2RlKTtcbiAgICAgICAgICAgICAgICAoaXNTdGFydCA/IHNldFJhbmdlU3RhcnQgOiBzZXRSYW5nZUVuZCkodGhpcywgYm91bmRhcnkubm9kZSwgYm91bmRhcnkub2Zmc2V0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRSYW5nZVN0YXJ0KHJhbmdlLCBub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBlYyA9IHJhbmdlLmVuZENvbnRhaW5lciwgZW8gPSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gcmFuZ2Uuc3RhcnRDb250YWluZXIgfHwgb2Zmc2V0ICE9PSByYW5nZS5zdGFydE9mZnNldCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSByb290IGNvbnRhaW5lcnMgb2YgdGhlIHJhbmdlIGFuZCB0aGUgbmV3IGJvdW5kYXJ5LCBhbmQgYWxzbyBjaGVjayB3aGV0aGVyIHRoZSBuZXcgYm91bmRhcnlcbiAgICAgICAgICAgICAgICAvLyBpcyBhZnRlciB0aGUgY3VycmVudCBlbmQuIEluIGVpdGhlciBjYXNlLCBjb2xsYXBzZSB0aGUgcmFuZ2UgdG8gdGhlIG5ldyBwb3NpdGlvblxuICAgICAgICAgICAgICAgIGlmIChnZXRSb290Q29udGFpbmVyKG5vZGUpICE9IGdldFJvb3RDb250YWluZXIoZWMpIHx8IGRvbS5jb21wYXJlUG9pbnRzKG5vZGUsIG9mZnNldCwgZWMsIGVvKSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGVjID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZW8gPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5VXBkYXRlcihyYW5nZSwgbm9kZSwgb2Zmc2V0LCBlYywgZW8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0UmFuZ2VFbmQocmFuZ2UsIG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIHNjID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsIHNvID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gcmFuZ2UuZW5kQ29udGFpbmVyIHx8IG9mZnNldCAhPT0gcmFuZ2UuZW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJvb3QgY29udGFpbmVycyBvZiB0aGUgcmFuZ2UgYW5kIHRoZSBuZXcgYm91bmRhcnksIGFuZCBhbHNvIGNoZWNrIHdoZXRoZXIgdGhlIG5ldyBib3VuZGFyeVxuICAgICAgICAgICAgICAgIC8vIGlzIGFmdGVyIHRoZSBjdXJyZW50IGVuZC4gSW4gZWl0aGVyIGNhc2UsIGNvbGxhcHNlIHRoZSByYW5nZSB0byB0aGUgbmV3IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGdldFJvb3RDb250YWluZXIobm9kZSkgIT0gZ2V0Um9vdENvbnRhaW5lcihzYykgfHwgZG9tLmNvbXBhcmVQb2ludHMobm9kZSwgb2Zmc2V0LCBzYywgc28pID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgc28gPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5VXBkYXRlcihyYW5nZSwgc2MsIHNvLCBub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0UmFuZ2VTdGFydEFuZEVuZChyYW5nZSwgbm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gcmFuZ2Uuc3RhcnRDb250YWluZXIgfHwgb2Zmc2V0ICE9PSByYW5nZS5zdGFydE9mZnNldCB8fCBub2RlICE9PSByYW5nZS5lbmRDb250YWluZXIgfHwgb2Zmc2V0ICE9PSByYW5nZS5lbmRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyeVVwZGF0ZXIocmFuZ2UsIG5vZGUsIG9mZnNldCwgbm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSYW5nZVByb3RvdHlwZSgpO1xuXG4gICAgICAgIGFwaS51dGlsLmV4dGVuZChjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIHNldFN0YXJ0OiBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnROb3REZXRhY2hlZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBhc3NlcnROb0RvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGFzc2VydFZhbGlkT2Zmc2V0KG5vZGUsIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICBzZXRSYW5nZVN0YXJ0KHRoaXMsIG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRFbmQ6IGZ1bmN0aW9uKG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGFzc2VydE5vdERldGFjaGVkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGFzc2VydE5vRG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3Iobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VmFsaWRPZmZzZXQobm9kZSwgb2Zmc2V0KTtcblxuICAgICAgICAgICAgICAgIHNldFJhbmdlRW5kKHRoaXMsIG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRTdGFydEJlZm9yZTogY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKHRydWUsIHRydWUpLFxuICAgICAgICAgICAgc2V0U3RhcnRBZnRlcjogY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKGZhbHNlLCB0cnVlKSxcbiAgICAgICAgICAgIHNldEVuZEJlZm9yZTogY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKHRydWUsIGZhbHNlKSxcbiAgICAgICAgICAgIHNldEVuZEFmdGVyOiBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoZmFsc2UsIGZhbHNlKSxcblxuICAgICAgICAgICAgY29sbGFwc2U6IGZ1bmN0aW9uKGlzU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChpc1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5VXBkYXRlcih0aGlzLCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0LCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0LCB0aGlzLmVuZENvbnRhaW5lciwgdGhpcy5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNlbGVjdE5vZGVDb250ZW50czogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZG9lc24ndCBzZWVtIHdlbGwgc3BlY2lmaWVkOiB0aGUgc3BlYyB0YWxrcyBvbmx5IGFib3V0IHNlbGVjdGluZyB0aGUgbm9kZSdzIGNvbnRlbnRzLCB3aGljaFxuICAgICAgICAgICAgICAgIC8vIGNvdWxkIGJlIHRha2VuIHRvIG1lYW4gb25seSBpdHMgY2hpbGRyZW4uIEhvd2V2ZXIsIGJyb3dzZXJzIGltcGxlbWVudCB0aGlzIHRoZSBzYW1lIGFzIHNlbGVjdE5vZGUgZm9yXG4gICAgICAgICAgICAgICAgLy8gdGV4dCBub2Rlcywgc28gSSBzaGFsbCBkbyBsaWtld2lzZVxuICAgICAgICAgICAgICAgIGFzc2VydE5vdERldGFjaGVkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGFzc2VydE5vRG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3Iobm9kZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgbm9kZSwgMCwgbm9kZSwgZG9tLmdldE5vZGVMZW5ndGgobm9kZSkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2VsZWN0Tm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIGFzc2VydE5vdERldGFjaGVkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGFzc2VydE5vRG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3Iobm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGFzc2VydFZhbGlkTm9kZVR5cGUobm9kZSwgYmVmb3JlQWZ0ZXJOb2RlVHlwZXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZ2V0Qm91bmRhcnlCZWZvcmVOb2RlKG5vZGUpLCBlbmQgPSBnZXRCb3VuZGFyeUFmdGVyTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgc3RhcnQubm9kZSwgc3RhcnQub2Zmc2V0LCBlbmQubm9kZSwgZW5kLm9mZnNldCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBleHRyYWN0Q29udGVudHM6IGNyZWF0ZVJhbmdlQ29udGVudFJlbW92ZXIoZXh0cmFjdFN1YnRyZWUsIGJvdW5kYXJ5VXBkYXRlciksXG5cbiAgICAgICAgICAgIGRlbGV0ZUNvbnRlbnRzOiBjcmVhdGVSYW5nZUNvbnRlbnRSZW1vdmVyKGRlbGV0ZVN1YnRyZWUsIGJvdW5kYXJ5VXBkYXRlciksXG5cbiAgICAgICAgICAgIGNhblN1cnJvdW5kQ29udGVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Tm9kZU5vdFJlYWRPbmx5KHRoaXMuc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGFzc2VydE5vZGVOb3RSZWFkT25seSh0aGlzLmVuZENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGVudHMgY2FuIGJlIHN1cnJvdW5kZWQuIFNwZWNpZmljYWxseSwgdGhpcyBtZWFucyB3aGV0aGVyIHRoZSByYW5nZSBwYXJ0aWFsbHkgc2VsZWN0c1xuICAgICAgICAgICAgICAgIC8vIG5vIG5vbi10ZXh0IG5vZGVzLlxuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZGFyaWVzSW52YWxpZCA9IChpdGVyYXRvci5fZmlyc3QgJiYgKGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKGl0ZXJhdG9yLl9maXJzdCwgdGhpcykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoaXRlcmF0b3IuX2xhc3QgJiYgaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQoaXRlcmF0b3IuX2xhc3QsIHRoaXMpKSk7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFib3VuZGFyaWVzSW52YWxpZDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRldGFjaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGV0YWNoZXIodGhpcyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzcGxpdEJvdW5kYXJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG5cblxuICAgICAgICAgICAgICAgIHZhciBzYyA9IHRoaXMuc3RhcnRDb250YWluZXIsIHNvID0gdGhpcy5zdGFydE9mZnNldCwgZWMgPSB0aGlzLmVuZENvbnRhaW5lciwgZW8gPSB0aGlzLmVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRFbmRTYW1lID0gKHNjID09PSBlYyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoZWMpICYmIGVvID4gMCAmJiBlbyA8IGVjLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkb20uc3BsaXREYXRhTm9kZShlYywgZW8pO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKHNjKSAmJiBzbyA+IDAgJiYgc28gPCBzYy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgICAgICBzYyA9IGRvbS5zcGxpdERhdGFOb2RlKHNjLCBzbyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydEVuZFNhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVvIC09IHNvO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWMgPSBzYztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlYyA9PSBzYy5wYXJlbnROb2RlICYmIGVvID49IGRvbS5nZXROb2RlSW5kZXgoc2MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNvID0gMDtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgc2MsIHNvLCBlYywgZW8pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbm9ybWFsaXplQm91bmRhcmllczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBzYyA9IHRoaXMuc3RhcnRDb250YWluZXIsIHNvID0gdGhpcy5zdGFydE9mZnNldCwgZWMgPSB0aGlzLmVuZENvbnRhaW5lciwgZW8gPSB0aGlzLmVuZE9mZnNldDtcblxuICAgICAgICAgICAgICAgIHZhciBtZXJnZUZvcndhcmQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiYgc2libGluZy5ub2RlVHlwZSA9PSBub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlYyA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbyA9IG5vZGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmREYXRhKHNpYmxpbmcuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIG1lcmdlQmFja3dhcmQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcubm9kZVR5cGUgPT0gbm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVMZW5ndGggPSBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvID0gc2libGluZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmluc2VydERhdGEoMCwgc2libGluZy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYyA9PSBlYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVvICs9IHNvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVjID0gc2M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVjID09IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSBkb20uZ2V0Tm9kZUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbyA9PSBub2RlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWMgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbyA9IG5vZGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbyA+IG5vZGVJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlby0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplU3RhcnQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKGVjKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWMubGVuZ3RoID09IGVvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUZvcndhcmQoZWMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVvID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZE5vZGUgPSBlYy5jaGlsZE5vZGVzW2VvIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kTm9kZSAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShlbmROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlRm9yd2FyZChlbmROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVTdGFydCA9ICF0aGlzLmNvbGxhcHNlZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKHNjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUJhY2t3YXJkKHNjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbyA8IHNjLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IHNjLmNoaWxkTm9kZXNbc29dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydE5vZGUgJiYgZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoc3RhcnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZUJhY2t3YXJkKHN0YXJ0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2MgPSBlYztcbiAgICAgICAgICAgICAgICAgICAgc28gPSBlbztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgc2MsIHNvLCBlYywgZW8pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY29sbGFwc2VUb1BvaW50OiBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnROb3REZXRhY2hlZCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGFzc2VydE5vRG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3Iobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VmFsaWRPZmZzZXQobm9kZSwgb2Zmc2V0KTtcblxuICAgICAgICAgICAgICAgIHNldFJhbmdlU3RhcnRBbmRFbmQodGhpcywgbm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29weUNvbXBhcmlzb25Db25zdGFudHMoY29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBVcGRhdGVzIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIGFuZCBjb2xsYXBzZWQgYWZ0ZXIgYm91bmRhcnkgY2hhbmdlXG4gICAgZnVuY3Rpb24gdXBkYXRlQ29sbGFwc2VkQW5kQ29tbW9uQW5jZXN0b3IocmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2VkID0gKHJhbmdlLnN0YXJ0Q29udGFpbmVyID09PSByYW5nZS5lbmRDb250YWluZXIgJiYgcmFuZ2Uuc3RhcnRPZmZzZXQgPT09IHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgIHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29sbGFwc2VkID9cbiAgICAgICAgICAgIHJhbmdlLnN0YXJ0Q29udGFpbmVyIDogZG9tLmdldENvbW1vbkFuY2VzdG9yKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5lbmRDb250YWluZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUJvdW5kYXJpZXMocmFuZ2UsIHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQpIHtcbiAgICAgICAgdmFyIHN0YXJ0TW92ZWQgPSAocmFuZ2Uuc3RhcnRDb250YWluZXIgIT09IHN0YXJ0Q29udGFpbmVyIHx8IHJhbmdlLnN0YXJ0T2Zmc2V0ICE9PSBzdGFydE9mZnNldCk7XG4gICAgICAgIHZhciBlbmRNb3ZlZCA9IChyYW5nZS5lbmRDb250YWluZXIgIT09IGVuZENvbnRhaW5lciB8fCByYW5nZS5lbmRPZmZzZXQgIT09IGVuZE9mZnNldCk7XG5cbiAgICAgICAgcmFuZ2Uuc3RhcnRDb250YWluZXIgPSBzdGFydENvbnRhaW5lcjtcbiAgICAgICAgcmFuZ2Uuc3RhcnRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgcmFuZ2UuZW5kQ29udGFpbmVyID0gZW5kQ29udGFpbmVyO1xuICAgICAgICByYW5nZS5lbmRPZmZzZXQgPSBlbmRPZmZzZXQ7XG5cbiAgICAgICAgdXBkYXRlQ29sbGFwc2VkQW5kQ29tbW9uQW5jZXN0b3IocmFuZ2UpO1xuICAgICAgICBkaXNwYXRjaEV2ZW50KHJhbmdlLCBcImJvdW5kYXJ5Y2hhbmdlXCIsIHtzdGFydE1vdmVkOiBzdGFydE1vdmVkLCBlbmRNb3ZlZDogZW5kTW92ZWR9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXRhY2gocmFuZ2UpIHtcbiAgICAgICAgYXNzZXJ0Tm90RGV0YWNoZWQocmFuZ2UpO1xuICAgICAgICByYW5nZS5zdGFydENvbnRhaW5lciA9IHJhbmdlLnN0YXJ0T2Zmc2V0ID0gcmFuZ2UuZW5kQ29udGFpbmVyID0gcmFuZ2UuZW5kT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2VkID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSBudWxsO1xuICAgICAgICBkaXNwYXRjaEV2ZW50KHJhbmdlLCBcImRldGFjaFwiLCBudWxsKTtcbiAgICAgICAgcmFuZ2UuX2xpc3RlbmVycyA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmFuZ2UoZG9jKSB7XG4gICAgICAgIHRoaXMuc3RhcnRDb250YWluZXIgPSBkb2M7XG4gICAgICAgIHRoaXMuc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmVuZENvbnRhaW5lciA9IGRvYztcbiAgICAgICAgdGhpcy5lbmRPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7XG4gICAgICAgICAgICBib3VuZGFyeWNoYW5nZTogW10sXG4gICAgICAgICAgICBkZXRhY2g6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHVwZGF0ZUNvbGxhcHNlZEFuZENvbW1vbkFuY2VzdG9yKHRoaXMpO1xuICAgIH1cblxuICAgIGNyZWF0ZVByb3RvdHlwZVJhbmdlKFJhbmdlLCB1cGRhdGVCb3VuZGFyaWVzLCBkZXRhY2gpO1xuXG4gICAgYXBpLnJhbmdlUHJvdG90eXBlID0gUmFuZ2VQcm90b3R5cGUucHJvdG90eXBlO1xuXG4gICAgUmFuZ2UucmFuZ2VQcm9wZXJ0aWVzID0gcmFuZ2VQcm9wZXJ0aWVzO1xuICAgIFJhbmdlLlJhbmdlSXRlcmF0b3IgPSBSYW5nZUl0ZXJhdG9yO1xuICAgIFJhbmdlLmNvcHlDb21wYXJpc29uQ29uc3RhbnRzID0gY29weUNvbXBhcmlzb25Db25zdGFudHM7XG4gICAgUmFuZ2UuY3JlYXRlUHJvdG90eXBlUmFuZ2UgPSBjcmVhdGVQcm90b3R5cGVSYW5nZTtcbiAgICBSYW5nZS5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICBSYW5nZS5nZXRSYW5nZURvY3VtZW50ID0gZ2V0UmFuZ2VEb2N1bWVudDtcbiAgICBSYW5nZS5yYW5nZXNFcXVhbCA9IGZ1bmN0aW9uKHIxLCByMikge1xuICAgICAgICByZXR1cm4gcjEuc3RhcnRDb250YWluZXIgPT09IHIyLnN0YXJ0Q29udGFpbmVyICYmXG4gICAgICAgICAgICAgICByMS5zdGFydE9mZnNldCA9PT0gcjIuc3RhcnRPZmZzZXQgJiZcbiAgICAgICAgICAgICAgIHIxLmVuZENvbnRhaW5lciA9PT0gcjIuZW5kQ29udGFpbmVyICYmXG4gICAgICAgICAgICAgICByMS5lbmRPZmZzZXQgPT09IHIyLmVuZE9mZnNldDtcbiAgICB9O1xuXG4gICAgYXBpLkRvbVJhbmdlID0gUmFuZ2U7XG4gICAgYXBpLlJhbmdlRXhjZXB0aW9uID0gUmFuZ2VFeGNlcHRpb247XG59KTtyYW5neS5jcmVhdGVNb2R1bGUoXCJXcmFwcGVkUmFuZ2VcIiwgZnVuY3Rpb24oYXBpLCBtb2R1bGUpIHtcbiAgICBhcGkucmVxdWlyZU1vZHVsZXMoIFtcIkRvbVV0aWxcIiwgXCJEb21SYW5nZVwiXSApO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFdyYXBwZWRSYW5nZTtcbiAgICB2YXIgZG9tID0gYXBpLmRvbTtcbiAgICB2YXIgRG9tUG9zaXRpb24gPSBkb20uRG9tUG9zaXRpb247XG4gICAgdmFyIERvbVJhbmdlID0gYXBpLkRvbVJhbmdlO1xuXG5cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKlxuICAgIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBhIGJ1ZyB3aGVyZSBJRSByZXR1cm5zIHRoZSB3cm9uZyBjb250YWluZXIgZWxlbWVudCBmcm9tIHRoZSBUZXh0UmFuZ2UncyBwYXJlbnRFbGVtZW50KClcbiAgICBtZXRob2QuIEZvciBleGFtcGxlLCBpbiB0aGUgZm9sbG93aW5nICh3aGVyZSBwaXBlcyBkZW5vdGUgdGhlIHNlbGVjdGlvbiBib3VuZGFyaWVzKTpcblxuICAgIDx1bCBpZD1cInVsXCI+PGxpIGlkPVwiYVwiPnwgYSA8L2xpPjxsaSBpZD1cImJcIj4gYiB8PC9saT48L3VsPlxuXG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgYWxlcnQocmFuZ2UucGFyZW50RWxlbWVudCgpLmlkKTsgLy8gU2hvdWxkIGFsZXJ0IFwidWxcIiBidXQgYWxlcnRzIFwiYlwiXG5cbiAgICBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjb21tb24gYW5jZXN0b3Igbm9kZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgIC0gdGhlIHBhcmVudEVsZW1lbnQoKSBvZiB0aGUgdGV4dFJhbmdlXG4gICAgLSB0aGUgcGFyZW50RWxlbWVudCgpIG9mIHRoZSB0ZXh0UmFuZ2UgYWZ0ZXIgY2FsbGluZyBjb2xsYXBzZSh0cnVlKVxuICAgIC0gdGhlIHBhcmVudEVsZW1lbnQoKSBvZiB0aGUgdGV4dFJhbmdlIGFmdGVyIGNhbGxpbmcgY29sbGFwc2UoZmFsc2UpXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VGV4dFJhbmdlQ29udGFpbmVyRWxlbWVudCh0ZXh0UmFuZ2UpIHtcbiAgICAgICAgdmFyIHBhcmVudEVsID0gdGV4dFJhbmdlLnBhcmVudEVsZW1lbnQoKTtcblxuICAgICAgICB2YXIgcmFuZ2UgPSB0ZXh0UmFuZ2UuZHVwbGljYXRlKCk7XG4gICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICB2YXIgc3RhcnRFbCA9IHJhbmdlLnBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgcmFuZ2UgPSB0ZXh0UmFuZ2UuZHVwbGljYXRlKCk7XG4gICAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgICAgdmFyIGVuZEVsID0gcmFuZ2UucGFyZW50RWxlbWVudCgpO1xuICAgICAgICB2YXIgc3RhcnRFbmRDb250YWluZXIgPSAoc3RhcnRFbCA9PSBlbmRFbCkgPyBzdGFydEVsIDogZG9tLmdldENvbW1vbkFuY2VzdG9yKHN0YXJ0RWwsIGVuZEVsKTtcblxuICAgICAgICByZXR1cm4gc3RhcnRFbmRDb250YWluZXIgPT0gcGFyZW50RWwgPyBzdGFydEVuZENvbnRhaW5lciA6IGRvbS5nZXRDb21tb25BbmNlc3RvcihwYXJlbnRFbCwgc3RhcnRFbmRDb250YWluZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRleHRSYW5nZUlzQ29sbGFwc2VkKHRleHRSYW5nZSkge1xuICAgICAgICByZXR1cm4gdGV4dFJhbmdlLmNvbXBhcmVFbmRQb2ludHMoXCJTdGFydFRvRW5kXCIsIHRleHRSYW5nZSkgPT0gMDtcbiAgICB9XG5cbiAgICAvLyBHZXRzIHRoZSBib3VuZGFyeSBvZiBhIFRleHRSYW5nZSBleHByZXNzZWQgYXMgYSBub2RlIGFuZCBhbiBvZmZzZXQgd2l0aGluIHRoYXQgbm9kZS4gVGhpcyBmdW5jdGlvbiBzdGFydGVkIG91dCBhc1xuICAgIC8vIGFuIGltcHJvdmVkIHZlcnNpb24gb2YgY29kZSBmb3VuZCBpbiBUaW0gQ2FtZXJvbiBSeWFuJ3MgSUVSYW5nZSAoaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2llcmFuZ2UvKSBidXQgaGFzXG4gICAgLy8gZ3Jvd24sIGZpeGluZyBwcm9ibGVtcyB3aXRoIGxpbmUgYnJlYWtzIGluIHByZWZvcm1hdHRlZCB0ZXh0LCBhZGRpbmcgd29ya2Fyb3VuZCBmb3IgSUUgVGV4dFJhbmdlIGJ1Z3MsIGhhbmRsaW5nXG4gICAgLy8gZm9yIGlucHV0cyBhbmQgaW1hZ2VzLCBwbHVzIG9wdGltaXphdGlvbnMuXG4gICAgZnVuY3Rpb24gZ2V0VGV4dFJhbmdlQm91bmRhcnlQb3NpdGlvbih0ZXh0UmFuZ2UsIHdob2xlUmFuZ2VDb250YWluZXJFbGVtZW50LCBpc1N0YXJ0LCBpc0NvbGxhcHNlZCkge1xuICAgICAgICB2YXIgd29ya2luZ1JhbmdlID0gdGV4dFJhbmdlLmR1cGxpY2F0ZSgpO1xuXG4gICAgICAgIHdvcmtpbmdSYW5nZS5jb2xsYXBzZShpc1N0YXJ0KTtcbiAgICAgICAgdmFyIGNvbnRhaW5lckVsZW1lbnQgPSB3b3JraW5nUmFuZ2UucGFyZW50RWxlbWVudCgpO1xuXG4gICAgICAgIC8vIFNvbWV0aW1lcyBjb2xsYXBzaW5nIGEgVGV4dFJhbmdlIHRoYXQncyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0IG5vZGUgY2FuIG1vdmUgaXQgaW50byB0aGUgcHJldmlvdXMgbm9kZSwgc29cbiAgICAgICAgLy8gY2hlY2sgZm9yIHRoYXRcbiAgICAgICAgLy8gVE9ETzogRmluZCBvdXQgd2hlbi4gV29ya2Fyb3VuZCBmb3Igd2hvbGVSYW5nZUNvbnRhaW5lckVsZW1lbnQgbWF5IGJyZWFrIHRoaXNcbiAgICAgICAgaWYgKCFkb20uaXNBbmNlc3Rvck9mKHdob2xlUmFuZ2VDb250YWluZXJFbGVtZW50LCBjb250YWluZXJFbGVtZW50LCB0cnVlKSkge1xuICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudCA9IHdob2xlUmFuZ2VDb250YWluZXJFbGVtZW50O1xuXG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgLy8gRGVhbCB3aXRoIG5vZGVzIHRoYXQgY2Fubm90IFwiY29udGFpbiByaWNoIEhUTUwgbWFya3VwXCIuIEluIHByYWN0aWNlLCB0aGlzIG1lYW5zIGZvcm0gaW5wdXRzLCBpbWFnZXMgYW5kXG4gICAgICAgIC8vIHNpbWlsYXIuIFNlZSBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvYWE3MDM5NTAlMjhWUy44NSUyOS5hc3B4XG4gICAgICAgIGlmICghY29udGFpbmVyRWxlbWVudC5jYW5IYXZlSFRNTCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb21Qb3NpdGlvbihjb250YWluZXJFbGVtZW50LnBhcmVudE5vZGUsIGRvbS5nZXROb2RlSW5kZXgoY29udGFpbmVyRWxlbWVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdvcmtpbmdOb2RlID0gZG9tLmdldERvY3VtZW50KGNvbnRhaW5lckVsZW1lbnQpLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB2YXIgY29tcGFyaXNvbiwgd29ya2luZ0NvbXBhcmlzb25UeXBlID0gaXNTdGFydCA/IFwiU3RhcnRUb1N0YXJ0XCIgOiBcIlN0YXJ0VG9FbmRcIjtcbiAgICAgICAgdmFyIHByZXZpb3VzTm9kZSwgbmV4dE5vZGUsIGJvdW5kYXJ5UG9zaXRpb24sIGJvdW5kYXJ5Tm9kZTtcblxuICAgICAgICAvLyBNb3ZlIHRoZSB3b3JraW5nIHJhbmdlIHRocm91Z2ggdGhlIGNvbnRhaW5lcidzIGNoaWxkcmVuLCBzdGFydGluZyBhdCB0aGUgZW5kIGFuZCB3b3JraW5nIGJhY2t3YXJkcywgdW50aWwgdGhlXG4gICAgICAgIC8vIHdvcmtpbmcgcmFuZ2UgcmVhY2hlcyBvciBnb2VzIHBhc3QgdGhlIGJvdW5kYXJ5IHdlJ3JlIGludGVyZXN0ZWQgaW5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudC5pbnNlcnRCZWZvcmUod29ya2luZ05vZGUsIHdvcmtpbmdOb2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICB3b3JraW5nUmFuZ2UubW92ZVRvRWxlbWVudFRleHQod29ya2luZ05vZGUpO1xuICAgICAgICB9IHdoaWxlICggKGNvbXBhcmlzb24gPSB3b3JraW5nUmFuZ2UuY29tcGFyZUVuZFBvaW50cyh3b3JraW5nQ29tcGFyaXNvblR5cGUsIHRleHRSYW5nZSkpID4gMCAmJlxuICAgICAgICAgICAgICAgIHdvcmtpbmdOb2RlLnByZXZpb3VzU2libGluZyk7XG5cbiAgICAgICAgLy8gV2UndmUgbm93IHJlYWNoZWQgb3IgZ29uZSBwYXN0IHRoZSBib3VuZGFyeSBvZiB0aGUgdGV4dCByYW5nZSB3ZSdyZSBpbnRlcmVzdGVkIGluXG4gICAgICAgIC8vIHNvIGhhdmUgaWRlbnRpZmllZCB0aGUgbm9kZSB3ZSB3YW50XG4gICAgICAgIGJvdW5kYXJ5Tm9kZSA9IHdvcmtpbmdOb2RlLm5leHRTaWJsaW5nO1xuXG4gICAgICAgIGlmIChjb21wYXJpc29uID09IC0xICYmIGJvdW5kYXJ5Tm9kZSAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShib3VuZGFyeU5vZGUpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgY2hhcmFjdGVyIGRhdGEgbm9kZSAodGV4dCwgY29tbWVudCwgY2RhdGEpLiBUaGUgd29ya2luZyByYW5nZSBpcyBjb2xsYXBzZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAgICAgICAgLy8gbm9kZSBjb250YWluaW5nIHRoZSB0ZXh0IHJhbmdlJ3MgYm91bmRhcnksIHNvIHdlIG1vdmUgdGhlIGVuZCBvZiB0aGUgd29ya2luZyByYW5nZSB0byB0aGUgYm91bmRhcnkgcG9pbnRcbiAgICAgICAgICAgIC8vIGFuZCBtZWFzdXJlIHRoZSBsZW5ndGggb2YgaXRzIHRleHQgdG8gZ2V0IHRoZSBib3VuZGFyeSdzIG9mZnNldCB3aXRoaW4gdGhlIG5vZGUuXG4gICAgICAgICAgICB3b3JraW5nUmFuZ2Uuc2V0RW5kUG9pbnQoaXNTdGFydCA/IFwiRW5kVG9TdGFydFwiIDogXCJFbmRUb0VuZFwiLCB0ZXh0UmFuZ2UpO1xuXG5cbiAgICAgICAgICAgIHZhciBvZmZzZXQ7XG5cbiAgICAgICAgICAgIGlmICgvW1xcclxcbl0vLnRlc3QoYm91bmRhcnlOb2RlLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBGb3IgdGhlIHBhcnRpY3VsYXIgY2FzZSBvZiBhIGJvdW5kYXJ5IHdpdGhpbiBhIHRleHQgbm9kZSBjb250YWluaW5nIGxpbmUgYnJlYWtzICh3aXRoaW4gYSA8cHJlPiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIGZvciBleGFtcGxlKSwgd2UgbmVlZCBhIHNsaWdodGx5IGNvbXBsaWNhdGVkIGFwcHJvYWNoIHRvIGdldCB0aGUgYm91bmRhcnkncyBvZmZzZXQgaW4gSUUuIFRoZSBmYWN0czpcblxuICAgICAgICAgICAgICAgIC0gRWFjaCBsaW5lIGJyZWFrIGlzIHJlcHJlc2VudGVkIGFzIFxcciBpbiB0aGUgdGV4dCBub2RlJ3MgZGF0YS9ub2RlVmFsdWUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIC0gRWFjaCBsaW5lIGJyZWFrIGlzIHJlcHJlc2VudGVkIGFzIFxcclxcbiBpbiB0aGUgVGV4dFJhbmdlJ3MgJ3RleHQnIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLSBUaGUgJ3RleHQnIHByb3BlcnR5IG9mIHRoZSBUZXh0UmFuZ2UgZG9lcyBub3QgY29udGFpbiB0cmFpbGluZyBsaW5lIGJyZWFrc1xuXG4gICAgICAgICAgICAgICAgVG8gZ2V0IHJvdW5kIHRoZSBwcm9ibGVtIHByZXNlbnRlZCBieSB0aGUgZmluYWwgZmFjdCBhYm92ZSwgd2UgY2FuIHVzZSB0aGUgZmFjdCB0aGF0IFRleHRSYW5nZSdzXG4gICAgICAgICAgICAgICAgbW92ZVN0YXJ0KCkgYW5kIG1vdmVFbmQoKSBtZXRob2RzIHJldHVybiB0aGUgYWN0dWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIG1vdmVkLCB3aGljaCBpcyBub3QgbmVjZXNzYXJpbHlcbiAgICAgICAgICAgICAgICB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaXQgd2FzIGluc3RydWN0ZWQgdG8gbW92ZS4gVGhlIHNpbXBsZXN0IGFwcHJvYWNoIGlzIHRvIHVzZSB0aGlzIHRvXG4gICAgICAgICAgICAgICAgc3RvcmUgdGhlIGNoYXJhY3RlcnMgbW92ZWQgd2hlbiBtb3ZpbmcgYm90aCB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIGJvZHkgYW5kIHN1YnRyYWN0aW5nIHRoZSBzdGFydCBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mZnNldCAodGhlIFwibW92ZS1uZWdhdGl2ZS1nYXppbGxpb25cIiBtZXRob2QpLlxuICAgICAgICAgICAgICAgIEhvd2V2ZXIsIHRoaXMgaXMgZXh0cmVtZWx5IHNsb3cgd2hlbiB0aGUgZG9jdW1lbnQgaXMgbGFyZ2UgYW5kIHRoZSByYW5nZSBpcyBuZWFyIHRoZSBlbmQgb2YgaXQuIENsZWFybHlcbiAgICAgICAgICAgICAgICBkb2luZyB0aGUgbWlycm9yIGltYWdlIChpLmUuIG1vdmluZyB0aGUgcmFuZ2UgYm91bmRhcmllcyB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCkgaGFzIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgcHJvYmxlbS5cblxuICAgICAgICAgICAgICAgIEFub3RoZXIgYXBwcm9hY2ggdGhhdCB3b3JrcyBpcyB0byB1c2UgbW92ZVN0YXJ0KCkgdG8gbW92ZSB0aGUgc3RhcnQgYm91bmRhcnkgb2YgdGhlIHJhbmdlIHVwIHRvIHRoZSBlbmRcbiAgICAgICAgICAgICAgICBib3VuZGFyeSBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZSBhbmQgaW5jcmVtZW50aW5nIGEgY291bnRlciB3aXRoIHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgbW92ZVN0YXJ0KClcbiAgICAgICAgICAgICAgICBjYWxsLiBIb3dldmVyLCB0aGUgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHN0YXJ0IGJvdW5kYXJ5IGhhcyByZWFjaGVkIHRoZSBlbmQgYm91bmRhcnkgaXMgZXhwZW5zaXZlLCBzb1xuICAgICAgICAgICAgICAgIHRoaXMgbWV0aG9kIGlzIHNsb3cgKGFsdGhvdWdoIHVubGlrZSBcIm1vdmUtbmVnYXRpdmUtZ2F6aWxsaW9uXCIgaXMgbGFyZ2VseSB1bmFmZmVjdGVkIGJ5IHRoZSBsb2NhdGlvbiBvZlxuICAgICAgICAgICAgICAgIHRoZSByYW5nZSB3aXRoaW4gdGhlIGRvY3VtZW50KS5cblxuICAgICAgICAgICAgICAgIFRoZSBtZXRob2QgYmVsb3cgaXMgYSBoeWJyaWQgb2YgdGhlIHR3byBtZXRob2RzIGFib3ZlLiBJdCB1c2VzIHRoZSBmYWN0IHRoYXQgYSBzdHJpbmcgY29udGFpbmluZyB0aGVcbiAgICAgICAgICAgICAgICBUZXh0UmFuZ2UncyAndGV4dCcgcHJvcGVydHkgd2l0aCBlYWNoIFxcclxcbiBjb252ZXJ0ZWQgdG8gYSBzaW5nbGUgXFxyIGNoYXJhY3RlciBjYW5ub3QgYmUgbG9uZ2VyIHRoYW4gdGhlXG4gICAgICAgICAgICAgICAgdGV4dCBvZiB0aGUgVGV4dFJhbmdlLCBzbyB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlIGlzIG1vdmVkIHRoYXQgbGVuZ3RoIGluaXRpYWxseSBhbmQgdGhlbiBhIGNoYXJhY3RlciBhdFxuICAgICAgICAgICAgICAgIGEgdGltZSB0byBtYWtlIHVwIGZvciBhbnkgdHJhaWxpbmcgbGluZSBicmVha3Mgbm90IGNvbnRhaW5lZCBpbiB0aGUgJ3RleHQnIHByb3BlcnR5LiBUaGlzIGhhcyBnb29kXG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UgaW4gbW9zdCBzaXR1YXRpb25zIGNvbXBhcmVkIHRvIHRoZSBwcmV2aW91cyB0d28gbWV0aG9kcy5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wUmFuZ2UgPSB3b3JraW5nUmFuZ2UuZHVwbGljYXRlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlTGVuZ3RoID0gdGVtcFJhbmdlLnRleHQucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxyXCIpLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRlbXBSYW5nZS5tb3ZlU3RhcnQoXCJjaGFyYWN0ZXJcIiwgcmFuZ2VMZW5ndGgpO1xuICAgICAgICAgICAgICAgIHdoaWxlICggKGNvbXBhcmlzb24gPSB0ZW1wUmFuZ2UuY29tcGFyZUVuZFBvaW50cyhcIlN0YXJ0VG9FbmRcIiwgdGVtcFJhbmdlKSkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBSYW5nZS5tb3ZlU3RhcnQoXCJjaGFyYWN0ZXJcIiwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB3b3JraW5nUmFuZ2UudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib3VuZGFyeVBvc2l0aW9uID0gbmV3IERvbVBvc2l0aW9uKGJvdW5kYXJ5Tm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcblxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgYm91bmRhcnkgaW1tZWRpYXRlbHkgZm9sbG93cyBhIGNoYXJhY3RlciBkYXRhIG5vZGUgYW5kIHRoaXMgaXMgdGhlIGVuZCBib3VuZGFyeSwgd2Ugc2hvdWxkIGZhdm91clxuICAgICAgICAgICAgLy8gYSBwb3NpdGlvbiB3aXRoaW4gdGhhdCwgYW5kIGxpa2V3aXNlIGZvciBhIHN0YXJ0IGJvdW5kYXJ5IHByZWNlZGluZyBhIGNoYXJhY3RlciBkYXRhIG5vZGVcbiAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IChpc0NvbGxhcHNlZCB8fCAhaXNTdGFydCkgJiYgd29ya2luZ05vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgbmV4dE5vZGUgPSAoaXNDb2xsYXBzZWQgfHwgaXNTdGFydCkgJiYgd29ya2luZ05vZGUubmV4dFNpYmxpbmc7XG5cblxuXG4gICAgICAgICAgICBpZiAobmV4dE5vZGUgJiYgZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUobmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgYm91bmRhcnlQb3NpdGlvbiA9IG5ldyBEb21Qb3NpdGlvbihuZXh0Tm9kZSwgMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzTm9kZSAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShwcmV2aW91c05vZGUpKSB7XG4gICAgICAgICAgICAgICAgYm91bmRhcnlQb3NpdGlvbiA9IG5ldyBEb21Qb3NpdGlvbihwcmV2aW91c05vZGUsIHByZXZpb3VzTm9kZS5sZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyeVBvc2l0aW9uID0gbmV3IERvbVBvc2l0aW9uKGNvbnRhaW5lckVsZW1lbnQsIGRvbS5nZXROb2RlSW5kZXgod29ya2luZ05vZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsZWFuIHVwXG4gICAgICAgIHdvcmtpbmdOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod29ya2luZ05vZGUpO1xuXG4gICAgICAgIHJldHVybiBib3VuZGFyeVBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYSBUZXh0UmFuZ2UgcmVwcmVzZW50aW5nIHRoZSBib3VuZGFyeSBvZiBhIFRleHRSYW5nZSBleHByZXNzZWQgYXMgYSBub2RlIGFuZCBhbiBvZmZzZXQgd2l0aGluIHRoYXQgbm9kZS5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHN0YXJ0ZWQgb3V0IGFzIGFuIG9wdGltaXplZCB2ZXJzaW9uIG9mIGNvZGUgZm91bmQgaW4gVGltIENhbWVyb24gUnlhbidzIElFUmFuZ2VcbiAgICAvLyAoaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2llcmFuZ2UvKVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJvdW5kYXJ5VGV4dFJhbmdlKGJvdW5kYXJ5UG9zaXRpb24sIGlzU3RhcnQpIHtcbiAgICAgICAgdmFyIGJvdW5kYXJ5Tm9kZSwgYm91bmRhcnlQYXJlbnQsIGJvdW5kYXJ5T2Zmc2V0ID0gYm91bmRhcnlQb3NpdGlvbi5vZmZzZXQ7XG4gICAgICAgIHZhciBkb2MgPSBkb20uZ2V0RG9jdW1lbnQoYm91bmRhcnlQb3NpdGlvbi5ub2RlKTtcbiAgICAgICAgdmFyIHdvcmtpbmdOb2RlLCBjaGlsZE5vZGVzLCB3b3JraW5nUmFuZ2UgPSBkb2MuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgdmFyIG5vZGVJc0RhdGFOb2RlID0gZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoYm91bmRhcnlQb3NpdGlvbi5ub2RlKTtcblxuICAgICAgICBpZiAobm9kZUlzRGF0YU5vZGUpIHtcbiAgICAgICAgICAgIGJvdW5kYXJ5Tm9kZSA9IGJvdW5kYXJ5UG9zaXRpb24ubm9kZTtcbiAgICAgICAgICAgIGJvdW5kYXJ5UGFyZW50ID0gYm91bmRhcnlOb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZE5vZGVzID0gYm91bmRhcnlQb3NpdGlvbi5ub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBib3VuZGFyeU5vZGUgPSAoYm91bmRhcnlPZmZzZXQgPCBjaGlsZE5vZGVzLmxlbmd0aCkgPyBjaGlsZE5vZGVzW2JvdW5kYXJ5T2Zmc2V0XSA6IG51bGw7XG4gICAgICAgICAgICBib3VuZGFyeVBhcmVudCA9IGJvdW5kYXJ5UG9zaXRpb24ubm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSByYW5nZSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgYm91bmRhcnlcbiAgICAgICAgd29ya2luZ05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG5cbiAgICAgICAgLy8gTWFraW5nIHRoZSB3b3JraW5nIGVsZW1lbnQgbm9uLWVtcHR5IGVsZW1lbnQgcGVyc3VhZGVzIElFIHRvIGNvbnNpZGVyIHRoZSBUZXh0UmFuZ2UgYm91bmRhcnkgdG8gYmUgd2l0aGluIHRoZVxuICAgICAgICAvLyBlbGVtZW50IHJhdGhlciB0aGFuIGltbWVkaWF0ZWx5IGJlZm9yZSBvciBhZnRlciBpdCwgd2hpY2ggaXMgd2hhdCB3ZSB3YW50XG4gICAgICAgIHdvcmtpbmdOb2RlLmlubmVySFRNTCA9IFwiJiNmZWZmO1wiO1xuXG4gICAgICAgIC8vIGluc2VydEJlZm9yZSBpcyBzdXBwb3NlZCB0byB3b3JrIGxpa2UgYXBwZW5kQ2hpbGQgaWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgbnVsbC4gSG93ZXZlciwgYSBidWcgcmVwb3J0XG4gICAgICAgIC8vIGZvciBJRVJhbmdlIHN1Z2dlc3RzIHRoYXQgaXQgY2FuIGNyYXNoIHRoZSBicm93c2VyOiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvaWVyYW5nZS9pc3N1ZXMvZGV0YWlsP2lkPTEyXG4gICAgICAgIGlmIChib3VuZGFyeU5vZGUpIHtcbiAgICAgICAgICAgIGJvdW5kYXJ5UGFyZW50Lmluc2VydEJlZm9yZSh3b3JraW5nTm9kZSwgYm91bmRhcnlOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdW5kYXJ5UGFyZW50LmFwcGVuZENoaWxkKHdvcmtpbmdOb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmtpbmdSYW5nZS5tb3ZlVG9FbGVtZW50VGV4dCh3b3JraW5nTm9kZSk7XG4gICAgICAgIHdvcmtpbmdSYW5nZS5jb2xsYXBzZSghaXNTdGFydCk7XG5cbiAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgYm91bmRhcnlQYXJlbnQucmVtb3ZlQ2hpbGQod29ya2luZ05vZGUpO1xuXG4gICAgICAgIC8vIE1vdmUgdGhlIHdvcmtpbmcgcmFuZ2UgdG8gdGhlIHRleHQgb2Zmc2V0LCBpZiByZXF1aXJlZFxuICAgICAgICBpZiAobm9kZUlzRGF0YU5vZGUpIHtcbiAgICAgICAgICAgIHdvcmtpbmdSYW5nZVtpc1N0YXJ0ID8gXCJtb3ZlU3RhcnRcIiA6IFwibW92ZUVuZFwiXShcImNoYXJhY3RlclwiLCBib3VuZGFyeU9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gd29ya2luZ1JhbmdlO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICBpZiAoYXBpLmZlYXR1cmVzLmltcGxlbWVudHNEb21SYW5nZSAmJiAoIWFwaS5mZWF0dXJlcy5pbXBsZW1lbnRzVGV4dFJhbmdlIHx8ICFhcGkuY29uZmlnLnByZWZlclRleHRSYW5nZSkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBicm93c2VyJ3MgbmF0aXZlIERPTSBSYW5nZS4gSXQgaGFzIHR3byBhaW1zOlxuICAgICAgICAvLyAtIFByb3ZpZGUgd29ya2Fyb3VuZHMgZm9yIHNwZWNpZmljIGJyb3dzZXIgYnVnc1xuICAgICAgICAvLyAtIHByb3ZpZGUgY29udmVuaWVudCBleHRlbnNpb25zLCB3aGljaCBhcmUgaW5oZXJpdGVkIGZyb20gUmFuZ3kncyBEb21SYW5nZVxuXG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByYW5nZVByb3RvO1xuICAgICAgICAgICAgdmFyIHJhbmdlUHJvcGVydGllcyA9IERvbVJhbmdlLnJhbmdlUHJvcGVydGllcztcbiAgICAgICAgICAgIHZhciBjYW5TZXRSYW5nZVN0YXJ0QWZ0ZXJFbmQ7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVJhbmdlUHJvcGVydGllcyhyYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gcmFuZ2VQcm9wZXJ0aWVzLmxlbmd0aCwgcHJvcDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3AgPSByYW5nZVByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlW3Byb3BdID0gcmFuZ2UubmF0aXZlUmFuZ2VbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVOYXRpdmVSYW5nZShyYW5nZSwgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsZW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0TW92ZWQgPSAocmFuZ2Uuc3RhcnRDb250YWluZXIgIT09IHN0YXJ0Q29udGFpbmVyIHx8IHJhbmdlLnN0YXJ0T2Zmc2V0ICE9IHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kTW92ZWQgPSAocmFuZ2UuZW5kQ29udGFpbmVyICE9PSBlbmRDb250YWluZXIgfHwgcmFuZ2UuZW5kT2Zmc2V0ICE9IGVuZE9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgc2V0IGJvdGggYm91bmRhcmllcyBmb3IgdGhlIGJlbmVmaXQgb2YgSUU5IChzZWUgaXNzdWUgMzUpXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0TW92ZWQgfHwgZW5kTW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRldGFjaChyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLm5hdGl2ZVJhbmdlLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgIHJhbmdlLmRldGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHJhbmdlUHJvcGVydGllcy5sZW5ndGgsIHByb3A7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wID0gcmFuZ2VQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICByYW5nZVtwcm9wXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyO1xuXG4gICAgICAgICAgICBXcmFwcGVkUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBEb21SYW5nZS5jcmVhdGVQcm90b3R5cGVSYW5nZShXcmFwcGVkUmFuZ2UsIHVwZGF0ZU5hdGl2ZVJhbmdlLCBkZXRhY2gpO1xuXG4gICAgICAgICAgICByYW5nZVByb3RvID0gV3JhcHBlZFJhbmdlLnByb3RvdHlwZTtcblxuICAgICAgICAgICAgcmFuZ2VQcm90by5zZWxlY3ROb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByYW5nZVByb3RvLmRlbGV0ZUNvbnRlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJhbmdlUHJvdG8uZXh0cmFjdENvbnRlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWcgPSB0aGlzLm5hdGl2ZVJhbmdlLmV4dHJhY3RDb250ZW50cygpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJhbmdlUHJvdG8uY2xvbmVDb250ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZVJhbmdlLmNsb25lQ29udGVudHMoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFVudGlsIEkgY2FuIGZpbmQgYSB3YXkgdG8gcHJvZ3JhbW1hdGljYWxseSB0cmlnZ2VyIHRoZSBGaXJlZm94IGJ1ZyAoYXBwYXJlbnRseSBsb25nLXN0YW5kaW5nLCBzdGlsbFxuICAgICAgICAgICAgLy8gcHJlc2VudCBpbiAzLjYuOCkgdGhhdCB0aHJvd3MgXCJJbmRleCBvciBzaXplIGlzIG5lZ2F0aXZlIG9yIGdyZWF0ZXIgdGhhbiB0aGUgYWxsb3dlZCBhbW91bnRcIiBmb3JcbiAgICAgICAgICAgIC8vIGluc2VydE5vZGUgaW4gc29tZSBjaXJjdW1zdGFuY2VzLCBhbGwgYnJvd3NlcnMgd2lsbCBoYXZlIHRvIHVzZSB0aGUgUmFuZ3kncyBvd24gaW1wbGVtZW50YXRpb24gb2ZcbiAgICAgICAgICAgIC8vIGluc2VydE5vZGUsIHdoaWNoIHdvcmtzIGJ1dCBpcyBhbG1vc3QgY2VydGFpbmx5IHNsb3dlciB0aGFuIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24uXG4vKlxuICAgICAgICAgICAgcmFuZ2VQcm90by5pbnNlcnROb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2UuaW5zZXJ0Tm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICB9O1xuKi9cblxuICAgICAgICAgICAgcmFuZ2VQcm90by5zdXJyb3VuZENvbnRlbnRzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc3Vycm91bmRDb250ZW50cyhub2RlKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByYW5nZVByb3RvLmNvbGxhcHNlID0gZnVuY3Rpb24oaXNTdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2UuY29sbGFwc2UoaXNTdGFydCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmFuZ2VQcm90by5jbG9uZVJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXcmFwcGVkUmFuZ2UodGhpcy5uYXRpdmVSYW5nZS5jbG9uZVJhbmdlKCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmFuZ2VQcm90by5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmFuZ2VQcm90by50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZVJhbmdlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGVzdCByYW5nZSBhbmQgbm9kZSBmb3IgZmVhdHVyZSBkZXRlY3Rpb25cblxuICAgICAgICAgICAgdmFyIHRlc3RUZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwidGVzdFwiKTtcbiAgICAgICAgICAgIGRvbS5nZXRCb2R5KGRvY3VtZW50KS5hcHBlbmRDaGlsZCh0ZXN0VGV4dE5vZGUpO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcblxuICAgICAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIEZpcmVmb3ggMiBidWcgdGhhdCBwcmV2ZW50cyBtb3ZpbmcgdGhlIHN0YXJ0IG9mIGEgUmFuZ2UgdG8gYSBwb2ludCBhZnRlciBpdHMgY3VycmVudCBlbmQgYW5kXG4gICAgICAgICAgICAvLyBjb3JyZWN0IGZvciBpdFxuXG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydCh0ZXN0VGV4dE5vZGUsIDApO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKHRlc3RUZXh0Tm9kZSwgMCk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGVzdFRleHROb2RlLCAxKTtcbiAgICAgICAgICAgICAgICBjYW5TZXRSYW5nZVN0YXJ0QWZ0ZXJFbmQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5zZXRTdGFydCA9IGZ1bmN0aW9uKG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5zZXRFbmQgPSBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlW25hbWVdKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcblxuXG4gICAgICAgICAgICAgICAgY2FuU2V0UmFuZ2VTdGFydEFmdGVyRW5kID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLnNldFN0YXJ0ID0gZnVuY3Rpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5zZXRFbmQgPSBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyID0gZnVuY3Rpb24obmFtZSwgb3Bwb3NpdGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2VbbmFtZV0obm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Vbb3Bwb3NpdGVOYW1lXShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlW25hbWVdKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJhbmdlUHJvdG8uc2V0U3RhcnRCZWZvcmUgPSBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoXCJzZXRTdGFydEJlZm9yZVwiLCBcInNldEVuZEJlZm9yZVwiKTtcbiAgICAgICAgICAgIHJhbmdlUHJvdG8uc2V0U3RhcnRBZnRlciA9IGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcihcInNldFN0YXJ0QWZ0ZXJcIiwgXCJzZXRFbmRBZnRlclwiKTtcbiAgICAgICAgICAgIHJhbmdlUHJvdG8uc2V0RW5kQmVmb3JlID0gY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKFwic2V0RW5kQmVmb3JlXCIsIFwic2V0U3RhcnRCZWZvcmVcIik7XG4gICAgICAgICAgICByYW5nZVByb3RvLnNldEVuZEFmdGVyID0gY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKFwic2V0RW5kQWZ0ZXJcIiwgXCJzZXRTdGFydEFmdGVyXCIpO1xuXG4gICAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgICAgLy8gVGVzdCBmb3IgYW5kIGNvcnJlY3QgRmlyZWZveCAyIGJlaGF2aW91ciB3aXRoIHNlbGVjdE5vZGVDb250ZW50cyBvbiB0ZXh0IG5vZGVzOiBpdCBjb2xsYXBzZXMgdGhlIHJhbmdlIHRvXG4gICAgICAgICAgICAvLyB0aGUgMHRoIGNoYXJhY3RlciBvZiB0aGUgdGV4dCBub2RlXG4gICAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHModGVzdFRleHROb2RlKTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydENvbnRhaW5lciA9PSB0ZXN0VGV4dE5vZGUgJiYgcmFuZ2UuZW5kQ29udGFpbmVyID09IHRlc3RUZXh0Tm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICByYW5nZS5zdGFydE9mZnNldCA9PSAwICYmIHJhbmdlLmVuZE9mZnNldCA9PSB0ZXN0VGV4dE5vZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5zZWxlY3ROb2RlQ29udGVudHMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VQcm90by5zZWxlY3ROb2RlQ29udGVudHMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhcnQobm9kZSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RW5kKG5vZGUsIERvbVJhbmdlLmdldEVuZE9mZnNldChub2RlKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIFdlYktpdCBidWcgdGhhdCBoYXMgdGhlIGJlYWh2aW91ciBvZiBjb21wYXJlQm91bmRhcnlQb2ludHMgcm91bmQgdGhlIHdyb25nIHdheSBmb3IgY29uc3RhbnRzXG4gICAgICAgICAgICAvLyBTVEFSVF9UT19FTkQgYW5kIEVORF9UT19TVEFSVDogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIwNzM4XG5cbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyh0ZXN0VGV4dE5vZGUpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKHRlc3RUZXh0Tm9kZSwgMyk7XG5cbiAgICAgICAgICAgIHZhciByYW5nZTIgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2UyLnNlbGVjdE5vZGVDb250ZW50cyh0ZXN0VGV4dE5vZGUpO1xuICAgICAgICAgICAgcmFuZ2UyLnNldEVuZCh0ZXN0VGV4dE5vZGUsIDQpO1xuICAgICAgICAgICAgcmFuZ2UyLnNldFN0YXJ0KHRlc3RUZXh0Tm9kZSwgMik7XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS5jb21wYXJlQm91bmRhcnlQb2ludHMocmFuZ2UuU1RBUlRfVE9fRU5ELCByYW5nZTIpID09IC0xICZcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKHJhbmdlLkVORF9UT19TVEFSVCwgcmFuZ2UyKSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgd3Jvbmcgd2F5IHJvdW5kLCBzbyBjb3JyZWN0IGZvciBpdFxuXG5cbiAgICAgICAgICAgICAgICByYW5nZVByb3RvLmNvbXBhcmVCb3VuZGFyeVBvaW50cyA9IGZ1bmN0aW9uKHR5cGUsIHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gcmFuZ2UubmF0aXZlUmFuZ2UgfHwgcmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IHJhbmdlLlNUQVJUX1RPX0VORCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHJhbmdlLkVORF9UT19TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IHJhbmdlLkVORF9UT19TVEFSVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHJhbmdlLlNUQVJUX1RPX0VORDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVSYW5nZS5jb21wYXJlQm91bmRhcnlQb2ludHModHlwZSwgcmFuZ2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlUHJvdG8uY29tcGFyZUJvdW5kYXJ5UG9pbnRzID0gZnVuY3Rpb24odHlwZSwgcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlUmFuZ2UuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKHR5cGUsIHJhbmdlLm5hdGl2ZVJhbmdlIHx8IHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgICAgLy8gVGVzdCBmb3IgZXhpc3RlbmNlIG9mIGNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCBhbmQgZGVsZWdhdGUgdG8gaXQgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBpZiAoYXBpLnV0aWwuaXNIb3N0TWV0aG9kKHJhbmdlLCBcImNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudFwiKSkge1xuICAgICAgICAgICAgICAgIHJhbmdlUHJvdG8uY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50ID0gZnVuY3Rpb24oZnJhZ21lbnRTdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlUmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KGZyYWdtZW50U3RyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgICAgIGRvbS5nZXRCb2R5KGRvY3VtZW50KS5yZW1vdmVDaGlsZCh0ZXN0VGV4dE5vZGUpO1xuICAgICAgICAgICAgcmFuZ2UuZGV0YWNoKCk7XG4gICAgICAgICAgICByYW5nZTIuZGV0YWNoKCk7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgYXBpLmNyZWF0ZU5hdGl2ZVJhbmdlID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChhcGkuZmVhdHVyZXMuaW1wbGVtZW50c1RleHRSYW5nZSkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgd3JhcHBlciBhcm91bmQgYSBUZXh0UmFuZ2UsIHByb3ZpZGluZyBmdWxsIERPTSBSYW5nZSBmdW5jdGlvbmFsaXR5IHVzaW5nIHJhbmd5J3MgRG9tUmFuZ2UgYXMgYVxuICAgICAgICAvLyBwcm90b3R5cGVcblxuICAgICAgICBXcmFwcGVkUmFuZ2UgPSBmdW5jdGlvbih0ZXh0UmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dFJhbmdlID0gdGV4dFJhbmdlO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgV3JhcHBlZFJhbmdlLnByb3RvdHlwZSA9IG5ldyBEb21SYW5nZShkb2N1bWVudCk7XG5cbiAgICAgICAgV3JhcHBlZFJhbmdlLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQsIGVuZDtcblxuICAgICAgICAgICAgLy8gVGV4dFJhbmdlJ3MgcGFyZW50RWxlbWVudCgpIG1ldGhvZCBjYW5ub3QgYmUgdHJ1c3RlZC4gZ2V0VGV4dFJhbmdlQ29udGFpbmVyRWxlbWVudCgpIHdvcmtzIGFyb3VuZCB0aGF0LlxuICAgICAgICAgICAgdmFyIHJhbmdlQ29udGFpbmVyRWxlbWVudCA9IGdldFRleHRSYW5nZUNvbnRhaW5lckVsZW1lbnQodGhpcy50ZXh0UmFuZ2UpO1xuXG4gICAgICAgICAgICBpZiAodGV4dFJhbmdlSXNDb2xsYXBzZWQodGhpcy50ZXh0UmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gc3RhcnQgPSBnZXRUZXh0UmFuZ2VCb3VuZGFyeVBvc2l0aW9uKHRoaXMudGV4dFJhbmdlLCByYW5nZUNvbnRhaW5lckVsZW1lbnQsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZ2V0VGV4dFJhbmdlQm91bmRhcnlQb3NpdGlvbih0aGlzLnRleHRSYW5nZSwgcmFuZ2VDb250YWluZXJFbGVtZW50LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZW5kID0gZ2V0VGV4dFJhbmdlQm91bmRhcnlQb3NpdGlvbih0aGlzLnRleHRSYW5nZSwgcmFuZ2VDb250YWluZXJFbGVtZW50LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXJ0KHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLnNldEVuZChlbmQubm9kZSwgZW5kLm9mZnNldCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgRG9tUmFuZ2UuY29weUNvbXBhcmlzb25Db25zdGFudHMoV3JhcHBlZFJhbmdlKTtcblxuICAgICAgICAvLyBBZGQgV3JhcHBlZFJhbmdlIGFzIHRoZSBSYW5nZSBwcm9wZXJ0eSBvZiB0aGUgZ2xvYmFsIG9iamVjdCB0byBhbGxvdyBleHByZXNzaW9uIGxpa2UgUmFuZ2UuRU5EX1RPX0VORCB0byB3b3JrXG4gICAgICAgIHZhciBnbG9iYWxPYmogPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSgpO1xuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbE9iai5SYW5nZSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBnbG9iYWxPYmouUmFuZ2UgPSBXcmFwcGVkUmFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBhcGkuY3JlYXRlTmF0aXZlUmFuZ2UgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcbiAgICAgICAgICAgIHJldHVybiBkb2MuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoYXBpLmZlYXR1cmVzLmltcGxlbWVudHNUZXh0UmFuZ2UpIHtcbiAgICAgICAgV3JhcHBlZFJhbmdlLnJhbmdlVG9UZXh0UmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IGNyZWF0ZUJvdW5kYXJ5VGV4dFJhbmdlKG5ldyBEb21Qb3NpdGlvbihyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpLCB0cnVlKTtcblxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHI7XG5cbiAgICAgICAgICAgICAgICAvL3JldHVybiBjcmVhdGVCb3VuZGFyeVRleHRSYW5nZShuZXcgRG9tUG9zaXRpb24ocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFJhbmdlID0gY3JlYXRlQm91bmRhcnlUZXh0UmFuZ2UobmV3IERvbVBvc2l0aW9uKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCksIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBlbmRSYW5nZSA9IGNyZWF0ZUJvdW5kYXJ5VGV4dFJhbmdlKG5ldyBEb21Qb3NpdGlvbihyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dFJhbmdlID0gZG9tLmdldERvY3VtZW50KHJhbmdlLnN0YXJ0Q29udGFpbmVyKS5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgICAgIHRleHRSYW5nZS5zZXRFbmRQb2ludChcIlN0YXJ0VG9TdGFydFwiLCBzdGFydFJhbmdlKTtcbiAgICAgICAgICAgICAgICB0ZXh0UmFuZ2Uuc2V0RW5kUG9pbnQoXCJFbmRUb0VuZFwiLCBlbmRSYW5nZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHRSYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBXcmFwcGVkUmFuZ2UucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFwiV3JhcHBlZFJhbmdlXCI7XG4gICAgfTtcblxuICAgIGFwaS5XcmFwcGVkUmFuZ2UgPSBXcmFwcGVkUmFuZ2U7XG5cbiAgICBhcGkuY3JlYXRlUmFuZ2UgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuICAgICAgICByZXR1cm4gbmV3IFdyYXBwZWRSYW5nZShhcGkuY3JlYXRlTmF0aXZlUmFuZ2UoZG9jKSk7XG4gICAgfTtcblxuICAgIGFwaS5jcmVhdGVSYW5neVJhbmdlID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBEb21SYW5nZShkb2MpO1xuICAgIH07XG5cbiAgICBhcGkuY3JlYXRlSWZyYW1lUmFuZ2UgPSBmdW5jdGlvbihpZnJhbWVFbCkge1xuICAgICAgICByZXR1cm4gYXBpLmNyZWF0ZVJhbmdlKGRvbS5nZXRJZnJhbWVEb2N1bWVudChpZnJhbWVFbCkpO1xuICAgIH07XG5cbiAgICBhcGkuY3JlYXRlSWZyYW1lUmFuZ3lSYW5nZSA9IGZ1bmN0aW9uKGlmcmFtZUVsKSB7XG4gICAgICAgIHJldHVybiBhcGkuY3JlYXRlUmFuZ3lSYW5nZShkb20uZ2V0SWZyYW1lRG9jdW1lbnQoaWZyYW1lRWwpKTtcbiAgICB9O1xuXG4gICAgYXBpLmFkZENyZWF0ZU1pc3NpbmdOYXRpdmVBcGlMaXN0ZW5lcihmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2MuY3JlYXRlUmFuZ2UgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZG9jLmNyZWF0ZVJhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaS5jcmVhdGVSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZG9jID0gd2luID0gbnVsbDtcbiAgICB9KTtcbn0pO3Jhbmd5LmNyZWF0ZU1vZHVsZShcIldyYXBwZWRTZWxlY3Rpb25cIiwgZnVuY3Rpb24oYXBpLCBtb2R1bGUpIHtcbiAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgc2VsZWN0aW9uIG9iamVjdCB3cmFwcGVyIHRoYXQgZm9sbG93cyB0aGUgU2VsZWN0aW9uIG9iamVjdCBmb3VuZCBpbiB0aGUgV0hBVFdHIGRyYWZ0IERPTSBSYW5nZVxuICAgIC8vIHNwZWMgKGh0dHA6Ly9odG1sNS5vcmcvc3BlY3MvZG9tLXJhbmdlLmh0bWwpXG5cbiAgICBhcGkucmVxdWlyZU1vZHVsZXMoIFtcIkRvbVV0aWxcIiwgXCJEb21SYW5nZVwiLCBcIldyYXBwZWRSYW5nZVwiXSApO1xuXG4gICAgYXBpLmNvbmZpZy5jaGVja1NlbGVjdGlvblJhbmdlcyA9IHRydWU7XG5cbiAgICB2YXIgQk9PTEVBTiA9IFwiYm9vbGVhblwiLFxuICAgICAgICB3aW5kb3dQcm9wZXJ0eU5hbWUgPSBcIl9yYW5neVNlbGVjdGlvblwiLFxuICAgICAgICBkb20gPSBhcGkuZG9tLFxuICAgICAgICB1dGlsID0gYXBpLnV0aWwsXG4gICAgICAgIERvbVJhbmdlID0gYXBpLkRvbVJhbmdlLFxuICAgICAgICBXcmFwcGVkUmFuZ2UgPSBhcGkuV3JhcHBlZFJhbmdlLFxuICAgICAgICBET01FeGNlcHRpb24gPSBhcGkuRE9NRXhjZXB0aW9uLFxuICAgICAgICBEb21Qb3NpdGlvbiA9IGRvbS5Eb21Qb3NpdGlvbixcbiAgICAgICAgZ2V0U2VsZWN0aW9uLFxuICAgICAgICBzZWxlY3Rpb25Jc0NvbGxhcHNlZCxcbiAgICAgICAgQ09OVFJPTCA9IFwiQ29udHJvbFwiO1xuXG5cblxuICAgIGZ1bmN0aW9uIGdldFdpblNlbGVjdGlvbih3aW5QYXJhbSkge1xuICAgICAgICByZXR1cm4gKHdpblBhcmFtIHx8IHdpbmRvdykuZ2V0U2VsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RG9jU2VsZWN0aW9uKHdpblBhcmFtKSB7XG4gICAgICAgIHJldHVybiAod2luUGFyYW0gfHwgd2luZG93KS5kb2N1bWVudC5zZWxlY3Rpb247XG4gICAgfVxuXG4gICAgLy8gVGVzdCBmb3IgdGhlIFJhbmdlL1RleHRSYW5nZSBhbmQgU2VsZWN0aW9uIGZlYXR1cmVzIHJlcXVpcmVkXG4gICAgLy8gVGVzdCBmb3IgYWJpbGl0eSB0byByZXRyaWV2ZSBzZWxlY3Rpb25cbiAgICB2YXIgaW1wbGVtZW50c1dpbkdldFNlbGVjdGlvbiA9IGFwaS51dGlsLmlzSG9zdE1ldGhvZCh3aW5kb3csIFwiZ2V0U2VsZWN0aW9uXCIpLFxuICAgICAgICBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uID0gYXBpLnV0aWwuaXNIb3N0T2JqZWN0KGRvY3VtZW50LCBcInNlbGVjdGlvblwiKTtcblxuICAgIHZhciB1c2VEb2N1bWVudFNlbGVjdGlvbiA9IGltcGxlbWVudHNEb2NTZWxlY3Rpb24gJiYgKCFpbXBsZW1lbnRzV2luR2V0U2VsZWN0aW9uIHx8IGFwaS5jb25maWcucHJlZmVyVGV4dFJhbmdlKTtcblxuICAgIGlmICh1c2VEb2N1bWVudFNlbGVjdGlvbikge1xuICAgICAgICBnZXRTZWxlY3Rpb24gPSBnZXREb2NTZWxlY3Rpb247XG4gICAgICAgIGFwaS5pc1NlbGVjdGlvblZhbGlkID0gZnVuY3Rpb24od2luUGFyYW0pIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSAod2luUGFyYW0gfHwgd2luZG93KS5kb2N1bWVudCwgbmF0aXZlU2VsID0gZG9jLnNlbGVjdGlvbjtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgc2VsZWN0aW9uIFRleHRSYW5nZSBpcyBhY3R1YWxseSBjb250YWluZWQgd2l0aGluIHRoZSBjb3JyZWN0IGRvY3VtZW50XG4gICAgICAgICAgICByZXR1cm4gKG5hdGl2ZVNlbC50eXBlICE9IFwiTm9uZVwiIHx8IGRvbS5nZXREb2N1bWVudChuYXRpdmVTZWwuY3JlYXRlUmFuZ2UoKS5wYXJlbnRFbGVtZW50KCkpID09IGRvYyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpbXBsZW1lbnRzV2luR2V0U2VsZWN0aW9uKSB7XG4gICAgICAgIGdldFNlbGVjdGlvbiA9IGdldFdpblNlbGVjdGlvbjtcbiAgICAgICAgYXBpLmlzU2VsZWN0aW9uVmFsaWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZHVsZS5mYWlsKFwiTmVpdGhlciBkb2N1bWVudC5zZWxlY3Rpb24gb3Igd2luZG93LmdldFNlbGVjdGlvbigpIGRldGVjdGVkLlwiKTtcbiAgICB9XG5cbiAgICBhcGkuZ2V0TmF0aXZlU2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uO1xuXG4gICAgdmFyIHRlc3RTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oKTtcbiAgICB2YXIgdGVzdFJhbmdlID0gYXBpLmNyZWF0ZU5hdGl2ZVJhbmdlKGRvY3VtZW50KTtcbiAgICB2YXIgYm9keSA9IGRvbS5nZXRCb2R5KGRvY3VtZW50KTtcblxuICAgIC8vIE9idGFpbmluZyBhIHJhbmdlIGZyb20gYSBzZWxlY3Rpb25cbiAgICB2YXIgc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMgPSB1dGlsLmFyZUhvc3RPYmplY3RzKHRlc3RTZWxlY3Rpb24sIFtcImFuY2hvck5vZGVcIiwgXCJmb2N1c05vZGVcIl0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmFyZUhvc3RQcm9wZXJ0aWVzKHRlc3RTZWxlY3Rpb24sIFtcImFuY2hvck9mZnNldFwiLCBcImZvY3VzT2Zmc2V0XCJdKSk7XG4gICAgYXBpLmZlYXR1cmVzLnNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXM7XG5cbiAgICAvLyBUZXN0IGZvciBleGlzdGVuY2Ugb2YgbmF0aXZlIHNlbGVjdGlvbiBleHRlbmQoKSBtZXRob2RcbiAgICB2YXIgc2VsZWN0aW9uSGFzRXh0ZW5kID0gdXRpbC5pc0hvc3RNZXRob2QodGVzdFNlbGVjdGlvbiwgXCJleHRlbmRcIik7XG4gICAgYXBpLmZlYXR1cmVzLnNlbGVjdGlvbkhhc0V4dGVuZCA9IHNlbGVjdGlvbkhhc0V4dGVuZDtcblxuICAgIC8vIFRlc3QgaWYgcmFuZ2VDb3VudCBleGlzdHNcbiAgICB2YXIgc2VsZWN0aW9uSGFzUmFuZ2VDb3VudCA9ICh0eXBlb2YgdGVzdFNlbGVjdGlvbi5yYW5nZUNvdW50ID09IFwibnVtYmVyXCIpO1xuICAgIGFwaS5mZWF0dXJlcy5zZWxlY3Rpb25IYXNSYW5nZUNvdW50ID0gc2VsZWN0aW9uSGFzUmFuZ2VDb3VudDtcblxuICAgIHZhciBzZWxlY3Rpb25TdXBwb3J0c011bHRpcGxlUmFuZ2VzID0gZmFsc2U7XG4gICAgdmFyIGNvbGxhcHNlZE5vbkVkaXRhYmxlU2VsZWN0aW9uc1N1cHBvcnRlZCA9IHRydWU7XG5cbiAgICBpZiAodXRpbC5hcmVIb3N0TWV0aG9kcyh0ZXN0U2VsZWN0aW9uLCBbXCJhZGRSYW5nZVwiLCBcImdldFJhbmdlQXRcIiwgXCJyZW1vdmVBbGxSYW5nZXNcIl0pICYmXG4gICAgICAgICAgICB0eXBlb2YgdGVzdFNlbGVjdGlvbi5yYW5nZUNvdW50ID09IFwibnVtYmVyXCIgJiYgYXBpLmZlYXR1cmVzLmltcGxlbWVudHNEb21SYW5nZSkge1xuXG4gICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG4gICAgICAgICAgICB2YXIgaWZyYW1lRG9jID0gZG9tLmdldElmcmFtZURvY3VtZW50KGlmcmFtZSk7XG4gICAgICAgICAgICBpZnJhbWVEb2Mub3BlbigpO1xuICAgICAgICAgICAgaWZyYW1lRG9jLndyaXRlKFwiPGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5PjEyPC9ib2R5PjwvaHRtbD5cIik7XG4gICAgICAgICAgICBpZnJhbWVEb2MuY2xvc2UoKTtcblxuICAgICAgICAgICAgdmFyIHNlbCA9IGRvbS5nZXRJZnJhbWVXaW5kb3coaWZyYW1lKS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHZhciBkb2NFbCA9IGlmcmFtZURvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgaWZyYW1lQm9keSA9IGRvY0VsLmxhc3RDaGlsZCwgdGV4dE5vZGUgPSBpZnJhbWVCb2R5LmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgIC8vIFRlc3Qgd2hldGhlciB0aGUgbmF0aXZlIHNlbGVjdGlvbiB3aWxsIGFsbG93IGEgY29sbGFwc2VkIHNlbGVjdGlvbiB3aXRoaW4gYSBub24tZWRpdGFibGUgZWxlbWVudFxuICAgICAgICAgICAgdmFyIHIxID0gaWZyYW1lRG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByMS5zZXRTdGFydCh0ZXh0Tm9kZSwgMSk7XG4gICAgICAgICAgICByMS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgIHNlbC5hZGRSYW5nZShyMSk7XG4gICAgICAgICAgICBjb2xsYXBzZWROb25FZGl0YWJsZVNlbGVjdGlvbnNTdXBwb3J0ZWQgPSAoc2VsLnJhbmdlQ291bnQgPT0gMSk7XG4gICAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICAgICAgICAgIC8vIFRlc3Qgd2hldGhlciB0aGUgbmF0aXZlIHNlbGVjdGlvbiBpcyBjYXBhYmxlIG9mIHN1cHBvcnRpbmcgbXVsdGlwbGUgcmFuZ2VzXG4gICAgICAgICAgICB2YXIgcjIgPSByMS5jbG9uZVJhbmdlKCk7XG4gICAgICAgICAgICByMS5zZXRTdGFydCh0ZXh0Tm9kZSwgMCk7XG4gICAgICAgICAgICByMi5zZXRFbmQodGV4dE5vZGUsIDIpO1xuICAgICAgICAgICAgc2VsLmFkZFJhbmdlKHIxKTtcbiAgICAgICAgICAgIHNlbC5hZGRSYW5nZShyMik7XG5cbiAgICAgICAgICAgIHNlbGVjdGlvblN1cHBvcnRzTXVsdGlwbGVSYW5nZXMgPSAoc2VsLnJhbmdlQ291bnQgPT0gMik7XG5cbiAgICAgICAgICAgIC8vIENsZWFuIHVwXG4gICAgICAgICAgICByMS5kZXRhY2goKTtcbiAgICAgICAgICAgIHIyLmRldGFjaCgpO1xuXG4gICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgYXBpLmZlYXR1cmVzLnNlbGVjdGlvblN1cHBvcnRzTXVsdGlwbGVSYW5nZXMgPSBzZWxlY3Rpb25TdXBwb3J0c011bHRpcGxlUmFuZ2VzO1xuICAgIGFwaS5mZWF0dXJlcy5jb2xsYXBzZWROb25FZGl0YWJsZVNlbGVjdGlvbnNTdXBwb3J0ZWQgPSBjb2xsYXBzZWROb25FZGl0YWJsZVNlbGVjdGlvbnNTdXBwb3J0ZWQ7XG5cbiAgICAvLyBDb250cm9sUmFuZ2VzXG4gICAgdmFyIGltcGxlbWVudHNDb250cm9sUmFuZ2UgPSBmYWxzZSwgdGVzdENvbnRyb2xSYW5nZTtcblxuICAgIGlmIChib2R5ICYmIHV0aWwuaXNIb3N0TWV0aG9kKGJvZHksIFwiY3JlYXRlQ29udHJvbFJhbmdlXCIpKSB7XG4gICAgICAgIHRlc3RDb250cm9sUmFuZ2UgPSBib2R5LmNyZWF0ZUNvbnRyb2xSYW5nZSgpO1xuICAgICAgICBpZiAodXRpbC5hcmVIb3N0UHJvcGVydGllcyh0ZXN0Q29udHJvbFJhbmdlLCBbXCJpdGVtXCIsIFwiYWRkXCJdKSkge1xuICAgICAgICAgICAgaW1wbGVtZW50c0NvbnRyb2xSYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBpLmZlYXR1cmVzLmltcGxlbWVudHNDb250cm9sUmFuZ2UgPSBpbXBsZW1lbnRzQ29udHJvbFJhbmdlO1xuXG4gICAgLy8gU2VsZWN0aW9uIGNvbGxhcHNlZG5lc3NcbiAgICBpZiAoc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMpIHtcbiAgICAgICAgc2VsZWN0aW9uSXNDb2xsYXBzZWQgPSBmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWwuYW5jaG9yTm9kZSA9PT0gc2VsLmZvY3VzTm9kZSAmJiBzZWwuYW5jaG9yT2Zmc2V0ID09PSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uSXNDb2xsYXBzZWQgPSBmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWwucmFuZ2VDb3VudCA/IHNlbC5nZXRSYW5nZUF0KHNlbC5yYW5nZUNvdW50IC0gMSkuY29sbGFwc2VkIDogZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tUmFuZ2Uoc2VsLCByYW5nZSwgYmFja3dhcmRzKSB7XG4gICAgICAgIHZhciBhbmNob3JQcmVmaXggPSBiYWNrd2FyZHMgPyBcImVuZFwiIDogXCJzdGFydFwiLCBmb2N1c1ByZWZpeCA9IGJhY2t3YXJkcyA/IFwic3RhcnRcIiA6IFwiZW5kXCI7XG4gICAgICAgIHNlbC5hbmNob3JOb2RlID0gcmFuZ2VbYW5jaG9yUHJlZml4ICsgXCJDb250YWluZXJcIl07XG4gICAgICAgIHNlbC5hbmNob3JPZmZzZXQgPSByYW5nZVthbmNob3JQcmVmaXggKyBcIk9mZnNldFwiXTtcbiAgICAgICAgc2VsLmZvY3VzTm9kZSA9IHJhbmdlW2ZvY3VzUHJlZml4ICsgXCJDb250YWluZXJcIl07XG4gICAgICAgIHNlbC5mb2N1c09mZnNldCA9IHJhbmdlW2ZvY3VzUHJlZml4ICsgXCJPZmZzZXRcIl07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tTmF0aXZlU2VsZWN0aW9uKHNlbCkge1xuICAgICAgICB2YXIgbmF0aXZlU2VsID0gc2VsLm5hdGl2ZVNlbGVjdGlvbjtcbiAgICAgICAgc2VsLmFuY2hvck5vZGUgPSBuYXRpdmVTZWwuYW5jaG9yTm9kZTtcbiAgICAgICAgc2VsLmFuY2hvck9mZnNldCA9IG5hdGl2ZVNlbC5hbmNob3JPZmZzZXQ7XG4gICAgICAgIHNlbC5mb2N1c05vZGUgPSBuYXRpdmVTZWwuZm9jdXNOb2RlO1xuICAgICAgICBzZWwuZm9jdXNPZmZzZXQgPSBuYXRpdmVTZWwuZm9jdXNPZmZzZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKSB7XG4gICAgICAgIHNlbC5hbmNob3JOb2RlID0gc2VsLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHNlbC5hbmNob3JPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQgPSAwO1xuICAgICAgICBzZWwucmFuZ2VDb3VudCA9IDA7XG4gICAgICAgIHNlbC5pc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgIHNlbC5fcmFuZ2VzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgdmFyIG5hdGl2ZVJhbmdlO1xuICAgICAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBEb21SYW5nZSkge1xuICAgICAgICAgICAgbmF0aXZlUmFuZ2UgPSByYW5nZS5fc2VsZWN0aW9uTmF0aXZlUmFuZ2U7XG4gICAgICAgICAgICBpZiAoIW5hdGl2ZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlUmFuZ2UgPSBhcGkuY3JlYXRlTmF0aXZlUmFuZ2UoZG9tLmdldERvY3VtZW50KHJhbmdlLnN0YXJ0Q29udGFpbmVyKSk7XG4gICAgICAgICAgICAgICAgbmF0aXZlUmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBuYXRpdmVSYW5nZS5zZXRTdGFydChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJhbmdlLl9zZWxlY3Rpb25OYXRpdmVSYW5nZSA9IG5hdGl2ZVJhbmdlO1xuICAgICAgICAgICAgICAgIHJhbmdlLmF0dGFjaExpc3RlbmVyKFwiZGV0YWNoXCIsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbk5hdGl2ZVJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChyYW5nZSBpbnN0YW5jZW9mIFdyYXBwZWRSYW5nZSkge1xuICAgICAgICAgICAgbmF0aXZlUmFuZ2UgPSByYW5nZS5uYXRpdmVSYW5nZTtcbiAgICAgICAgfSBlbHNlIGlmIChhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlICYmIChyYW5nZSBpbnN0YW5jZW9mIGRvbS5nZXRXaW5kb3cocmFuZ2Uuc3RhcnRDb250YWluZXIpLlJhbmdlKSkge1xuICAgICAgICAgICAgbmF0aXZlUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlUmFuZ2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmFuZ2VDb250YWluc1NpbmdsZUVsZW1lbnQocmFuZ2VOb2Rlcykge1xuICAgICAgICBpZiAoIXJhbmdlTm9kZXMubGVuZ3RoIHx8IHJhbmdlTm9kZXNbMF0ubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSByYW5nZU5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIWRvbS5pc0FuY2VzdG9yT2YocmFuZ2VOb2Rlc1swXSwgcmFuZ2VOb2Rlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2luZ2xlRWxlbWVudEZyb21SYW5nZShyYW5nZSkge1xuICAgICAgICB2YXIgbm9kZXMgPSByYW5nZS5nZXROb2RlcygpO1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNTaW5nbGVFbGVtZW50KG5vZGVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0U2luZ2xlRWxlbWVudEZyb21SYW5nZTogcmFuZ2UgXCIgKyByYW5nZS5pbnNwZWN0KCkgKyBcIiBkaWQgbm90IGNvbnNpc3Qgb2YgYSBzaW5nbGUgZWxlbWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXNbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNUZXh0UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuICEhcmFuZ2UgJiYgdHlwZW9mIHJhbmdlLnRleHQgIT0gXCJ1bmRlZmluZWRcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVGcm9tVGV4dFJhbmdlKHNlbCwgcmFuZ2UpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgUmFuZ2UgZnJvbSB0aGUgc2VsZWN0ZWQgVGV4dFJhbmdlXG4gICAgICAgIHZhciB3cmFwcGVkUmFuZ2UgPSBuZXcgV3JhcHBlZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgc2VsLl9yYW5nZXMgPSBbd3JhcHBlZFJhbmdlXTtcblxuICAgICAgICB1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZShzZWwsIHdyYXBwZWRSYW5nZSwgZmFsc2UpO1xuICAgICAgICBzZWwucmFuZ2VDb3VudCA9IDE7XG4gICAgICAgIHNlbC5pc0NvbGxhcHNlZCA9IHdyYXBwZWRSYW5nZS5jb2xsYXBzZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ29udHJvbFNlbGVjdGlvbihzZWwpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBiYXNlZCBvbiB3aGF0J3Mgbm93IGluIHRoZSBuYXRpdmUgc2VsZWN0aW9uXG4gICAgICAgIHNlbC5fcmFuZ2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmIChzZWwuZG9jU2VsZWN0aW9uLnR5cGUgPT0gXCJOb25lXCIpIHtcbiAgICAgICAgICAgIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHNlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29udHJvbFJhbmdlID0gc2VsLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKGlzVGV4dFJhbmdlKGNvbnRyb2xSYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNhc2UgKHdoZXJlIHRoZSBzZWxlY3Rpb24gdHlwZSBpcyBcIkNvbnRyb2xcIiBhbmQgY2FsbGluZyBjcmVhdGVSYW5nZSgpIG9uIHRoZSBzZWxlY3Rpb24gcmV0dXJuc1xuICAgICAgICAgICAgICAgIC8vIGEgVGV4dFJhbmdlKSBjYW4gaGFwcGVuIGluIElFIDkuIEl0IGhhcHBlbnMsIGZvciBleGFtcGxlLCB3aGVuIGFsbCBlbGVtZW50cyBpbiB0aGUgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAvLyBDb250cm9sUmFuZ2UgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgQ29udHJvbFJhbmdlIGFuZCByZW1vdmVkIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgIHVwZGF0ZUZyb21UZXh0UmFuZ2Uoc2VsLCBjb250cm9sUmFuZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWwucmFuZ2VDb3VudCA9IGNvbnRyb2xSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlLCBkb2MgPSBkb20uZ2V0RG9jdW1lbnQoY29udHJvbFJhbmdlLml0ZW0oMCkpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLnJhbmdlQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IGFwaS5jcmVhdGVSYW5nZShkb2MpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlKGNvbnRyb2xSYW5nZS5pdGVtKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsLl9yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbC5pc0NvbGxhcHNlZCA9IHNlbC5yYW5nZUNvdW50ID09IDEgJiYgc2VsLl9yYW5nZXNbMF0uY29sbGFwc2VkO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHNlbCwgc2VsLl9yYW5nZXNbc2VsLnJhbmdlQ291bnQgLSAxXSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkUmFuZ2VUb0NvbnRyb2xTZWxlY3Rpb24oc2VsLCByYW5nZSkge1xuICAgICAgICB2YXIgY29udHJvbFJhbmdlID0gc2VsLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICB2YXIgcmFuZ2VFbGVtZW50ID0gZ2V0U2luZ2xlRWxlbWVudEZyb21SYW5nZShyYW5nZSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IENvbnRyb2xSYW5nZSBjb250YWluaW5nIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNlbGVjdGVkIENvbnRyb2xSYW5nZSBwbHVzIHRoZSBlbGVtZW50XG4gICAgICAgIC8vIGNvbnRhaW5lZCBieSB0aGUgc3VwcGxpZWQgcmFuZ2VcbiAgICAgICAgdmFyIGRvYyA9IGRvbS5nZXREb2N1bWVudChjb250cm9sUmFuZ2UuaXRlbSgwKSk7XG4gICAgICAgIHZhciBuZXdDb250cm9sUmFuZ2UgPSBkb20uZ2V0Qm9keShkb2MpLmNyZWF0ZUNvbnRyb2xSYW5nZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29udHJvbFJhbmdlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBuZXdDb250cm9sUmFuZ2UuYWRkKGNvbnRyb2xSYW5nZS5pdGVtKGkpKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3Q29udHJvbFJhbmdlLmFkZChyYW5nZUVsZW1lbnQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkUmFuZ2UoKTogRWxlbWVudCB3aXRoaW4gdGhlIHNwZWNpZmllZCBSYW5nZSBjb3VsZCBub3QgYmUgYWRkZWQgdG8gY29udHJvbCBzZWxlY3Rpb24gKGRvZXMgaXQgaGF2ZSBsYXlvdXQ/KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdDb250cm9sUmFuZ2Uuc2VsZWN0KCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBiYXNlZCBvbiB3aGF0J3Mgbm93IGluIHRoZSBuYXRpdmUgc2VsZWN0aW9uXG4gICAgICAgIHVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24oc2VsKTtcbiAgICB9XG5cbiAgICB2YXIgZ2V0U2VsZWN0aW9uUmFuZ2VBdDtcblxuICAgIGlmICh1dGlsLmlzSG9zdE1ldGhvZCh0ZXN0U2VsZWN0aW9uLCAgXCJnZXRSYW5nZUF0XCIpKSB7XG4gICAgICAgIGdldFNlbGVjdGlvblJhbmdlQXQgPSBmdW5jdGlvbihzZWwsIGluZGV4KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWwuZ2V0UmFuZ2VBdChpbmRleCk7XG4gICAgICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cykge1xuICAgICAgICBnZXRTZWxlY3Rpb25SYW5nZUF0ID0gZnVuY3Rpb24oc2VsKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gZG9tLmdldERvY3VtZW50KHNlbC5hbmNob3JOb2RlKTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGFwaS5jcmVhdGVSYW5nZShkb2MpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVuIHRoZSBzZWxlY3Rpb24gd2FzIHNlbGVjdGVkIGJhY2t3YXJkcyAoZnJvbSB0aGUgZW5kIHRvIHRoZSBzdGFydCBpbiB0aGVcbiAgICAgICAgICAgIC8vIGRvY3VtZW50KVxuICAgICAgICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCAhPT0gdGhpcy5pc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdyYXBwZWRTZWxlY3Rpb24oc2VsZWN0aW9uLCBkb2NTZWxlY3Rpb24sIHdpbikge1xuICAgICAgICB0aGlzLm5hdGl2ZVNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5kb2NTZWxlY3Rpb24gPSBkb2NTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuX3JhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLndpbiA9IHdpbjtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgYXBpLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICB3aW4gPSB3aW4gfHwgd2luZG93O1xuICAgICAgICB2YXIgc2VsID0gd2luW3dpbmRvd1Byb3BlcnR5TmFtZV07XG4gICAgICAgIHZhciBuYXRpdmVTZWwgPSBnZXRTZWxlY3Rpb24od2luKSwgZG9jU2VsID0gaW1wbGVtZW50c0RvY1NlbGVjdGlvbiA/IGdldERvY1NlbGVjdGlvbih3aW4pIDogbnVsbDtcbiAgICAgICAgaWYgKHNlbCkge1xuICAgICAgICAgICAgc2VsLm5hdGl2ZVNlbGVjdGlvbiA9IG5hdGl2ZVNlbDtcbiAgICAgICAgICAgIHNlbC5kb2NTZWxlY3Rpb24gPSBkb2NTZWw7XG4gICAgICAgICAgICBzZWwucmVmcmVzaCh3aW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsID0gbmV3IFdyYXBwZWRTZWxlY3Rpb24obmF0aXZlU2VsLCBkb2NTZWwsIHdpbik7XG4gICAgICAgICAgICB3aW5bd2luZG93UHJvcGVydHlOYW1lXSA9IHNlbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsO1xuICAgIH07XG5cbiAgICBhcGkuZ2V0SWZyYW1lU2VsZWN0aW9uID0gZnVuY3Rpb24oaWZyYW1lRWwpIHtcbiAgICAgICAgcmV0dXJuIGFwaS5nZXRTZWxlY3Rpb24oZG9tLmdldElmcmFtZVdpbmRvdyhpZnJhbWVFbCkpO1xuICAgIH07XG5cbiAgICB2YXIgc2VsUHJvdG8gPSBXcmFwcGVkU2VsZWN0aW9uLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbnRyb2xTZWxlY3Rpb24oc2VsLCByYW5nZXMpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIHNlbGVjdGlvbiBiZWNvbWVzIG9mIHR5cGUgXCJDb250cm9sXCJcbiAgICAgICAgdmFyIGRvYyA9IGRvbS5nZXREb2N1bWVudChyYW5nZXNbMF0uc3RhcnRDb250YWluZXIpO1xuICAgICAgICB2YXIgY29udHJvbFJhbmdlID0gZG9tLmdldEJvZHkoZG9jKS5jcmVhdGVDb250cm9sUmFuZ2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGVsOyBpIDwgcmFuZ2VDb3VudDsgKytpKSB7XG4gICAgICAgICAgICBlbCA9IGdldFNpbmdsZUVsZW1lbnRGcm9tUmFuZ2UocmFuZ2VzW2ldKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29udHJvbFJhbmdlLmFkZChlbCk7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldFJhbmdlcygpOiBFbGVtZW50IHdpdGhpbiB0aGUgb25lIG9mIHRoZSBzcGVjaWZpZWQgUmFuZ2VzIGNvdWxkIG5vdCBiZSBhZGRlZCB0byBjb250cm9sIHNlbGVjdGlvbiAoZG9lcyBpdCBoYXZlIGxheW91dD8pXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xSYW5nZS5zZWxlY3QoKTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZWQgc2VsZWN0aW9uIGJhc2VkIG9uIHdoYXQncyBub3cgaW4gdGhlIG5hdGl2ZSBzZWxlY3Rpb25cbiAgICAgICAgdXBkYXRlQ29udHJvbFNlbGVjdGlvbihzZWwpO1xuICAgIH1cblxuICAgIC8vIFNlbGVjdGluZyBhIHJhbmdlXG4gICAgaWYgKCF1c2VEb2N1bWVudFNlbGVjdGlvbiAmJiBzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cyAmJiB1dGlsLmFyZUhvc3RNZXRob2RzKHRlc3RTZWxlY3Rpb24sIFtcInJlbW92ZUFsbFJhbmdlc1wiLCBcImFkZFJhbmdlXCJdKSkge1xuICAgICAgICBzZWxQcm90by5yZW1vdmVBbGxSYW5nZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24odGhpcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFkZFJhbmdlQmFja3dhcmRzID0gZnVuY3Rpb24oc2VsLCByYW5nZSkge1xuICAgICAgICAgICAgdmFyIGRvYyA9IERvbVJhbmdlLmdldFJhbmdlRG9jdW1lbnQocmFuZ2UpO1xuICAgICAgICAgICAgdmFyIGVuZFJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKGRvYyk7XG4gICAgICAgICAgICBlbmRSYW5nZS5jb2xsYXBzZVRvUG9pbnQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgc2VsLm5hdGl2ZVNlbGVjdGlvbi5hZGRSYW5nZShnZXROYXRpdmVSYW5nZShlbmRSYW5nZSkpO1xuICAgICAgICAgICAgc2VsLm5hdGl2ZVNlbGVjdGlvbi5leHRlbmQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIHNlbC5yZWZyZXNoKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbkhhc1JhbmdlQ291bnQpIHtcbiAgICAgICAgICAgIHNlbFByb3RvLmFkZFJhbmdlID0gZnVuY3Rpb24ocmFuZ2UsIGJhY2t3YXJkcykge1xuICAgICAgICAgICAgICAgIGlmIChpbXBsZW1lbnRzQ29udHJvbFJhbmdlICYmIGltcGxlbWVudHNEb2NTZWxlY3Rpb24gJiYgdGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFJhbmdlVG9Db250cm9sU2VsZWN0aW9uKHRoaXMsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFja3dhcmRzICYmIHNlbGVjdGlvbkhhc0V4dGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmFuZ2VCYWNrd2FyZHModGhpcywgcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzUmFuZ2VDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdXBwb3J0c011bHRpcGxlUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNSYW5nZUNvdW50ID0gdGhpcy5yYW5nZUNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUmFuZ2VDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVNlbGVjdGlvbi5hZGRSYW5nZShnZXROYXRpdmVSYW5nZShyYW5nZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIGFkZGluZyB0aGUgcmFuZ2Ugd2FzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmFuZ2VDb3VudCA9IHRoaXMubmF0aXZlU2VsZWN0aW9uLnJhbmdlQ291bnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlQ291bnQgPT0gcHJldmlvdXNSYW5nZUNvdW50ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByYW5nZSB3YXMgYWRkZWQgc3VjY2Vzc2Z1bGx5XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSByYW5nZSB0aGF0IHdlIGFkZGVkIHRvIHRoZSBzZWxlY3Rpb24gaXMgcmVmbGVjdGVkIGluIHRoZSBsYXN0IHJhbmdlIGV4dHJhY3RlZCBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcGkuY29uZmlnLmNoZWNrU2VsZWN0aW9uUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYXRpdmVSYW5nZSA9IGdldFNlbGVjdGlvblJhbmdlQXQodGhpcy5uYXRpdmVTZWxlY3Rpb24sIHRoaXMucmFuZ2VDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmF0aXZlUmFuZ2UgJiYgIURvbVJhbmdlLnJhbmdlc0VxdWFsKG5hdGl2ZVJhbmdlLCByYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhcHBlbnMgaW4gV2ViS2l0IHdpdGgsIGZvciBleGFtcGxlLCBhIHNlbGVjdGlvbiBwbGFjZWQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBXcmFwcGVkUmFuZ2UobmF0aXZlUmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jhbmdlc1t0aGlzLnJhbmdlQ291bnQgLSAxXSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHRoaXMsIHJhbmdlLCBzZWxlY3Rpb25Jc0JhY2t3YXJkcyh0aGlzLm5hdGl2ZVNlbGVjdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNDb2xsYXBzZWQgPSBzZWxlY3Rpb25Jc0NvbGxhcHNlZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJhbmdlIHdhcyBub3QgYWRkZWQgc3VjY2Vzc2Z1bGx5LiBUaGUgc2ltcGxlc3QgdGhpbmcgaXMgdG8gcmVmcmVzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbFByb3RvLmFkZFJhbmdlID0gZnVuY3Rpb24ocmFuZ2UsIGJhY2t3YXJkcykge1xuICAgICAgICAgICAgICAgIGlmIChiYWNrd2FyZHMgJiYgc2VsZWN0aW9uSGFzRXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFJhbmdlQmFja3dhcmRzKHRoaXMsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVNlbGVjdGlvbi5hZGRSYW5nZShnZXROYXRpdmVSYW5nZShyYW5nZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsUHJvdG8uc2V0UmFuZ2VzID0gZnVuY3Rpb24ocmFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoaW1wbGVtZW50c0NvbnRyb2xSYW5nZSAmJiByYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUNvbnRyb2xTZWxlY3Rpb24odGhpcywgcmFuZ2VzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUmFuZ2UocmFuZ2VzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzSG9zdE1ldGhvZCh0ZXN0U2VsZWN0aW9uLCBcImVtcHR5XCIpICYmIHV0aWwuaXNIb3N0TWV0aG9kKHRlc3RSYW5nZSwgXCJzZWxlY3RcIikgJiZcbiAgICAgICAgICAgICAgIGltcGxlbWVudHNDb250cm9sUmFuZ2UgJiYgdXNlRG9jdW1lbnRTZWxlY3Rpb24pIHtcblxuICAgICAgICBzZWxQcm90by5yZW1vdmVBbGxSYW5nZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIEFkZGVkIHRyeS9jYXRjaCBhcyBmaXggZm9yIGlzc3VlICMyMVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvY1NlbGVjdGlvbi5lbXB0eSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGVtcHR5KCkgbm90IHdvcmtpbmcgKGlzc3VlICMyNClcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb2NTZWxlY3Rpb24udHlwZSAhPSBcIk5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBmYWlsdXJlIHRvIGVtcHR5IGEgY29udHJvbCBzZWxlY3Rpb24gYnkgaW5zdGVhZCBzZWxlY3RpbmcgYSBUZXh0UmFuZ2UgYW5kIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGluZyBlbXB0eSgpXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2M7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuY2hvck5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYyA9IGRvbS5nZXREb2N1bWVudCh0aGlzLmFuY2hvck5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZG9jU2VsZWN0aW9uLnR5cGUgPT0gQ09OVFJPTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xSYW5nZSA9IHRoaXMuZG9jU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbFJhbmdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYyA9IGRvbS5nZXREb2N1bWVudChjb250cm9sUmFuZ2UuaXRlbSgwKSkuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dFJhbmdlID0gZG9jLmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1NlbGVjdGlvbi5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaChleCkge31cbiAgICAgICAgICAgIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHRoaXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbFByb3RvLmFkZFJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvY1NlbGVjdGlvbi50eXBlID09IENPTlRST0wpIHtcbiAgICAgICAgICAgICAgICBhZGRSYW5nZVRvQ29udHJvbFNlbGVjdGlvbih0aGlzLCByYW5nZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFdyYXBwZWRSYW5nZS5yYW5nZVRvVGV4dFJhbmdlKHJhbmdlKS5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYW5nZXNbMF0gPSByYW5nZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJhbmdlQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDb2xsYXBzZWQgPSB0aGlzLl9yYW5nZXNbMF0uY29sbGFwc2VkO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHRoaXMsIHJhbmdlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsUHJvdG8uc2V0UmFuZ2VzID0gZnVuY3Rpb24ocmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgdmFyIHJhbmdlQ291bnQgPSByYW5nZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHJhbmdlQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlQ29udHJvbFNlbGVjdGlvbih0aGlzLCByYW5nZXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyYW5nZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRSYW5nZShyYW5nZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZHVsZS5mYWlsKFwiTm8gbWVhbnMgb2Ygc2VsZWN0aW5nIGEgUmFuZ2Ugb3IgVGV4dFJhbmdlIHdhcyBmb3VuZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNlbFByb3RvLmdldFJhbmdlQXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMucmFuZ2VDb3VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOREVYX1NJWkVfRVJSXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jhbmdlc1tpbmRleF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlZnJlc2hTZWxlY3Rpb247XG5cbiAgICBpZiAodXNlRG9jdW1lbnRTZWxlY3Rpb24pIHtcbiAgICAgICAgcmVmcmVzaFNlbGVjdGlvbiA9IGZ1bmN0aW9uKHNlbCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlO1xuICAgICAgICAgICAgaWYgKGFwaS5pc1NlbGVjdGlvblZhbGlkKHNlbC53aW4pKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBzZWwuZG9jU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gZG9tLmdldEJvZHkoc2VsLndpbi5kb2N1bWVudCkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYgKHNlbC5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ29udHJvbFNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1RleHRSYW5nZShyYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVGcm9tVGV4dFJhbmdlKHNlbCwgcmFuZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVFbXB0eVNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodXRpbC5pc0hvc3RNZXRob2QodGVzdFNlbGVjdGlvbiwgXCJnZXRSYW5nZUF0XCIpICYmIHR5cGVvZiB0ZXN0U2VsZWN0aW9uLnJhbmdlQ291bnQgPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZWZyZXNoU2VsZWN0aW9uID0gZnVuY3Rpb24oc2VsKSB7XG4gICAgICAgICAgICBpZiAoaW1wbGVtZW50c0NvbnRyb2xSYW5nZSAmJiBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uICYmIHNlbC5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ29udHJvbFNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWwuX3Jhbmdlcy5sZW5ndGggPSBzZWwucmFuZ2VDb3VudCA9IHNlbC5uYXRpdmVTZWxlY3Rpb24ucmFuZ2VDb3VudDtcbiAgICAgICAgICAgICAgICBpZiAoc2VsLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbC5yYW5nZUNvdW50OyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5fcmFuZ2VzW2ldID0gbmV3IGFwaS5XcmFwcGVkUmFuZ2Uoc2VsLm5hdGl2ZVNlbGVjdGlvbi5nZXRSYW5nZUF0KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZShzZWwsIHNlbC5fcmFuZ2VzW3NlbC5yYW5nZUNvdW50IC0gMV0sIHNlbGVjdGlvbklzQmFja3dhcmRzKHNlbC5uYXRpdmVTZWxlY3Rpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsLmlzQ29sbGFwc2VkID0gc2VsZWN0aW9uSXNDb2xsYXBzZWQoc2VsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVFbXB0eVNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzICYmIHR5cGVvZiB0ZXN0U2VsZWN0aW9uLmlzQ29sbGFwc2VkID09IEJPT0xFQU4gJiYgdHlwZW9mIHRlc3RSYW5nZS5jb2xsYXBzZWQgPT0gQk9PTEVBTiAmJiBhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlKSB7XG4gICAgICAgIHJlZnJlc2hTZWxlY3Rpb24gPSBmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSwgbmF0aXZlU2VsID0gc2VsLm5hdGl2ZVNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmIChuYXRpdmVTZWwuYW5jaG9yTm9kZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gZ2V0U2VsZWN0aW9uUmFuZ2VBdChuYXRpdmVTZWwsIDApO1xuICAgICAgICAgICAgICAgIHNlbC5fcmFuZ2VzID0gW3JhbmdlXTtcbiAgICAgICAgICAgICAgICBzZWwucmFuZ2VDb3VudCA9IDE7XG4gICAgICAgICAgICAgICAgdXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tTmF0aXZlU2VsZWN0aW9uKHNlbCk7XG4gICAgICAgICAgICAgICAgc2VsLmlzQ29sbGFwc2VkID0gc2VsZWN0aW9uSXNDb2xsYXBzZWQoc2VsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtb2R1bGUuZmFpbChcIk5vIG1lYW5zIG9mIG9idGFpbmluZyBhIFJhbmdlIG9yIFRleHRSYW5nZSBmcm9tIHRoZSB1c2VyJ3Mgc2VsZWN0aW9uIHdhcyBmb3VuZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNlbFByb3RvLnJlZnJlc2ggPSBmdW5jdGlvbihjaGVja0ZvckNoYW5nZXMpIHtcbiAgICAgICAgdmFyIG9sZFJhbmdlcyA9IGNoZWNrRm9yQ2hhbmdlcyA/IHRoaXMuX3Jhbmdlcy5zbGljZSgwKSA6IG51bGw7XG4gICAgICAgIHJlZnJlc2hTZWxlY3Rpb24odGhpcyk7XG4gICAgICAgIGlmIChjaGVja0ZvckNoYW5nZXMpIHtcbiAgICAgICAgICAgIHZhciBpID0gb2xkUmFuZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpICE9IHRoaXMuX3Jhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFEb21SYW5nZS5yYW5nZXNFcXVhbChvbGRSYW5nZXNbaV0sIHRoaXMuX3Jhbmdlc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFJlbW92YWwgb2YgYSBzaW5nbGUgcmFuZ2VcbiAgICB2YXIgcmVtb3ZlUmFuZ2VNYW51YWxseSA9IGZ1bmN0aW9uKHNlbCwgcmFuZ2UpIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IHNlbC5nZXRBbGxSYW5nZXMoKSwgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkIHx8IHJhbmdlICE9PSByYW5nZXNbaV0pIHtcbiAgICAgICAgICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2VzW2ldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBkcmFmdCBXSEFUV0cgUmFuZ2Ugc3BlYywgdGhlIHNhbWUgcmFuZ2UgbWF5IGJlIGFkZGVkIHRvIHRoZSBzZWxlY3Rpb24gbXVsdGlwbGVcbiAgICAgICAgICAgICAgICAvLyB0aW1lcy4gcmVtb3ZlUmFuZ2Ugc2hvdWxkIG9ubHkgcmVtb3ZlIHRoZSBmaXJzdCBpbnN0YW5jZSwgc28gdGhlIGZvbGxvd2luZyBlbnN1cmVzIG9ubHkgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UgaXMgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHNlbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGltcGxlbWVudHNDb250cm9sUmFuZ2UpIHtcbiAgICAgICAgc2VsUHJvdG8ucmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9jU2VsZWN0aW9uLnR5cGUgPT0gQ09OVFJPTCkge1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sUmFuZ2UgPSB0aGlzLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZUVsZW1lbnQgPSBnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlKHJhbmdlKTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBDb250cm9sUmFuZ2UgY29udGFpbmluZyBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZWxlY3RlZCBDb250cm9sUmFuZ2UgbWludXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBjb250YWluZWQgYnkgdGhlIHN1cHBsaWVkIHJhbmdlXG4gICAgICAgICAgICAgICAgdmFyIGRvYyA9IGRvbS5nZXREb2N1bWVudChjb250cm9sUmFuZ2UuaXRlbSgwKSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NvbnRyb2xSYW5nZSA9IGRvbS5nZXRCb2R5KGRvYykuY3JlYXRlQ29udHJvbFJhbmdlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGVsLCByZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbnRyb2xSYW5nZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBlbCA9IGNvbnRyb2xSYW5nZS5pdGVtKGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwgIT09IHJhbmdlRWxlbWVudCB8fCByZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250cm9sUmFuZ2UuYWRkKGNvbnRyb2xSYW5nZS5pdGVtKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld0NvbnRyb2xSYW5nZS5zZWxlY3QoKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlZCBzZWxlY3Rpb24gYmFzZWQgb24gd2hhdCdzIG5vdyBpbiB0aGUgbmF0aXZlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZVJhbmdlTWFudWFsbHkodGhpcywgcmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbFByb3RvLnJlbW92ZVJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgICAgIHJlbW92ZVJhbmdlTWFudWFsbHkodGhpcywgcmFuZ2UpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIERldGVjdGluZyBpZiBhIHNlbGVjdGlvbiBpcyBiYWNrd2FyZHNcbiAgICB2YXIgc2VsZWN0aW9uSXNCYWNrd2FyZHM7XG4gICAgaWYgKCF1c2VEb2N1bWVudFNlbGVjdGlvbiAmJiBzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cyAmJiBhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlKSB7XG4gICAgICAgIHNlbGVjdGlvbklzQmFja3dhcmRzID0gZnVuY3Rpb24oc2VsKSB7XG4gICAgICAgICAgICB2YXIgYmFja3dhcmRzID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2VsLmFuY2hvck5vZGUpIHtcbiAgICAgICAgICAgICAgICBiYWNrd2FyZHMgPSAoZG9tLmNvbXBhcmVQb2ludHMoc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQsIHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCkgPT0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFja3dhcmRzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbFByb3RvLmlzQmFja3dhcmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uSXNCYWNrd2FyZHModGhpcyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uSXNCYWNrd2FyZHMgPSBzZWxQcm90by5pc0JhY2t3YXJkcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFNlbGVjdGlvbiB0ZXh0XG4gICAgLy8gVGhpcyBpcyBjb25mb3JtYW50IHRvIHRoZSBuZXcgV0hBVFdHIERPTSBSYW5nZSBkcmFmdCBzcGVjIGJ1dCBkaWZmZXJzIGZyb20gV2ViS2l0IGFuZCBNb3ppbGxhJ3MgaW1wbGVtZW50YXRpb25cbiAgICBzZWxQcm90by50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciByYW5nZVRleHRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnJhbmdlQ291bnQ7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgcmFuZ2VUZXh0c1tpXSA9IFwiXCIgKyB0aGlzLl9yYW5nZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlVGV4dHMuam9pbihcIlwiKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYXNzZXJ0Tm9kZUluU2FtZURvY3VtZW50KHNlbCwgbm9kZSkge1xuICAgICAgICBpZiAoc2VsLmFuY2hvck5vZGUgJiYgKGRvbS5nZXREb2N1bWVudChzZWwuYW5jaG9yTm9kZSkgIT09IGRvbS5nZXREb2N1bWVudChub2RlKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJXUk9OR19ET0NVTUVOVF9FUlJcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyBjdXJyZW50IGJyb3dzZXJzIGNvbmZvcm0gZnVsbHkgdG8gdGhlIEhUTUwgNSBkcmFmdCBzcGVjIGZvciB0aGlzIG1ldGhvZCwgc28gUmFuZ3kncyBvd24gbWV0aG9kIGlzIGFsd2F5cyB1c2VkXG4gICAgc2VsUHJvdG8uY29sbGFwc2UgPSBmdW5jdGlvbihub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgYXNzZXJ0Tm9kZUluU2FtZURvY3VtZW50KHRoaXMsIG5vZGUpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBhcGkuY3JlYXRlUmFuZ2UoZG9tLmdldERvY3VtZW50KG5vZGUpKTtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2VUb1BvaW50KG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHRoaXMuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB0aGlzLmlzQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgc2VsUHJvdG8uY29sbGFwc2VUb1N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuX3Jhbmdlc1swXTtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2UocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTlZBTElEX1NUQVRFX0VSUlwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxQcm90by5jb2xsYXBzZVRvRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHRoaXMuX3Jhbmdlc1t0aGlzLnJhbmdlQ291bnQgLSAxXTtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2UocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOVkFMSURfU1RBVEVfRVJSXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFRoZSBIVE1MIDUgc3BlYyBpcyB2ZXJ5IHNwZWNpZmljIG9uIGhvdyBzZWxlY3RBbGxDaGlsZHJlbiBzaG91bGQgYmUgaW1wbGVtZW50ZWQgc28gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpc1xuICAgIC8vIG5ldmVyIHVzZWQgYnkgUmFuZ3kuXG4gICAgc2VsUHJvdG8uc2VsZWN0QWxsQ2hpbGRyZW4gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGFzc2VydE5vZGVJblNhbWVEb2N1bWVudCh0aGlzLCBub2RlKTtcbiAgICAgICAgdmFyIHJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKGRvbS5nZXREb2N1bWVudChub2RlKSk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgdGhpcy5hZGRSYW5nZShyYW5nZSk7XG4gICAgfTtcblxuICAgIHNlbFByb3RvLmRlbGV0ZUZyb21Eb2N1bWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBTZXBjaWFsIGJlaGF2aW91ciByZXF1aXJlZCBmb3IgQ29udHJvbCBzZWxlY3Rpb25zXG4gICAgICAgIGlmIChpbXBsZW1lbnRzQ29udHJvbFJhbmdlICYmIGltcGxlbWVudHNEb2NTZWxlY3Rpb24gJiYgdGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgICAgICB2YXIgY29udHJvbFJhbmdlID0gdGhpcy5kb2NTZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50O1xuICAgICAgICAgICAgd2hpbGUgKGNvbnRyb2xSYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gY29udHJvbFJhbmdlLml0ZW0oMCk7XG4gICAgICAgICAgICAgICAgY29udHJvbFJhbmdlLnJlbW92ZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgIHZhciByYW5nZXMgPSB0aGlzLmdldEFsbFJhbmdlcygpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICByYW5nZXNbaV0uZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBIVE1MNSBzcGVjIHNheXMgbm90aGluZyBhYm91dCB3aGF0IHRoZSBzZWxlY3Rpb24gc2hvdWxkIGNvbnRhaW4gYWZ0ZXIgY2FsbGluZyBkZWxldGVDb250ZW50cyBvbiBlYWNoXG4gICAgICAgICAgICAvLyByYW5nZS4gRmlyZWZveCBtb3ZlcyB0aGUgc2VsZWN0aW9uIHRvIHdoZXJlIHRoZSBmaW5hbCBzZWxlY3RlZCByYW5nZSB3YXMsIHNvIHdlIGVtdWxhdGUgdGhhdFxuICAgICAgICAgICAgdGhpcy5hZGRSYW5nZShyYW5nZXNbbGVuIC0gMV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlIG5vbi1zdGFuZGFyZCBleHRlbnNpb25zXG4gICAgc2VsUHJvdG8uZ2V0QWxsUmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYW5nZXMuc2xpY2UoMCk7XG4gICAgfTtcblxuICAgIHNlbFByb3RvLnNldFNpbmdsZVJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgdGhpcy5zZXRSYW5nZXMoIFtyYW5nZV0gKTtcbiAgICB9O1xuXG4gICAgc2VsUHJvdG8uY29udGFpbnNOb2RlID0gZnVuY3Rpb24obm9kZSwgYWxsb3dQYXJ0aWFsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yYW5nZXNbaV0uY29udGFpbnNOb2RlKG5vZGUsIGFsbG93UGFydGlhbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHNlbFByb3RvLnRvSHRtbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBEb21SYW5nZS5nZXRSYW5nZURvY3VtZW50KHRoaXMuX3Jhbmdlc1swXSkuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9yYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcmFuZ2VzW2ldLmNsb25lQ29udGVudHMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBodG1sID0gY29udGFpbmVyLmlubmVySFRNTDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW5zcGVjdChzZWwpIHtcbiAgICAgICAgdmFyIHJhbmdlSW5zcGVjdHMgPSBbXTtcbiAgICAgICAgdmFyIGFuY2hvciA9IG5ldyBEb21Qb3NpdGlvbihzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgIHZhciBmb2N1cyA9IG5ldyBEb21Qb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgICAgICB2YXIgbmFtZSA9ICh0eXBlb2Ygc2VsLmdldE5hbWUgPT0gXCJmdW5jdGlvblwiKSA/IHNlbC5nZXROYW1lKCkgOiBcIlNlbGVjdGlvblwiO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsLnJhbmdlQ291bnQgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbC5yYW5nZUNvdW50OyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICByYW5nZUluc3BlY3RzW2ldID0gRG9tUmFuZ2UuaW5zcGVjdChzZWwuZ2V0UmFuZ2VBdChpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiW1wiICsgbmFtZSArIFwiKFJhbmdlczogXCIgKyByYW5nZUluc3BlY3RzLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgXCIpKGFuY2hvcjogXCIgKyBhbmNob3IuaW5zcGVjdCgpICsgXCIsIGZvY3VzOiBcIiArIGZvY3VzLmluc3BlY3QoKSArIFwiXVwiO1xuXG4gICAgfVxuXG4gICAgc2VsUHJvdG8uZ2V0TmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJXcmFwcGVkU2VsZWN0aW9uXCI7XG4gICAgfTtcblxuICAgIHNlbFByb3RvLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGluc3BlY3QodGhpcyk7XG4gICAgfTtcblxuICAgIHNlbFByb3RvLmRldGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLndpblt3aW5kb3dQcm9wZXJ0eU5hbWVdID0gbnVsbDtcbiAgICAgICAgdGhpcy53aW4gPSB0aGlzLmFuY2hvck5vZGUgPSB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgfTtcblxuICAgIFdyYXBwZWRTZWxlY3Rpb24uaW5zcGVjdCA9IGluc3BlY3Q7XG5cbiAgICBhcGkuU2VsZWN0aW9uID0gV3JhcHBlZFNlbGVjdGlvbjtcblxuICAgIGFwaS5zZWxlY3Rpb25Qcm90b3R5cGUgPSBzZWxQcm90bztcblxuICAgIGFwaS5hZGRDcmVhdGVNaXNzaW5nTmF0aXZlQXBpTGlzdGVuZXIoZnVuY3Rpb24od2luKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luLmdldFNlbGVjdGlvbiA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB3aW4uZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaS5nZXRTZWxlY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHdpbiA9IG51bGw7XG4gICAgfSk7XG59KTtcbi8qXG5cdEJhc2UuanMsIHZlcnNpb24gMS4xYVxuXHRDb3B5cmlnaHQgMjAwNi0yMDEwLCBEZWFuIEVkd2FyZHNcblx0TGljZW5zZTogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiovXG5cbnZhciBCYXNlID0gZnVuY3Rpb24oKSB7XG5cdC8vIGR1bW15XG59O1xuXG5CYXNlLmV4dGVuZCA9IGZ1bmN0aW9uKF9pbnN0YW5jZSwgX3N0YXRpYykgeyAvLyBzdWJjbGFzc1xuXHR2YXIgZXh0ZW5kID0gQmFzZS5wcm90b3R5cGUuZXh0ZW5kO1xuXHRcblx0Ly8gYnVpbGQgdGhlIHByb3RvdHlwZVxuXHRCYXNlLl9wcm90b3R5cGluZyA9IHRydWU7XG5cdHZhciBwcm90byA9IG5ldyB0aGlzO1xuXHRleHRlbmQuY2FsbChwcm90bywgX2luc3RhbmNlKTtcbiAgcHJvdG8uYmFzZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGNhbGwgdGhpcyBtZXRob2QgZnJvbSBhbnkgb3RoZXIgbWV0aG9kIHRvIGludm9rZSB0aGF0IG1ldGhvZCdzIGFuY2VzdG9yXG4gIH07XG5cdGRlbGV0ZSBCYXNlLl9wcm90b3R5cGluZztcblx0XG5cdC8vIGNyZWF0ZSB0aGUgd3JhcHBlciBmb3IgdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uXG5cdC8vdmFyIGNvbnN0cnVjdG9yID0gcHJvdG8uY29uc3RydWN0b3IudmFsdWVPZigpOyAvLy1kZWFuXG5cdHZhciBjb25zdHJ1Y3RvciA9IHByb3RvLmNvbnN0cnVjdG9yO1xuXHR2YXIga2xhc3MgPSBwcm90by5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghQmFzZS5fcHJvdG90eXBpbmcpIHtcblx0XHRcdGlmICh0aGlzLl9jb25zdHJ1Y3RpbmcgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBrbGFzcykgeyAvLyBpbnN0YW50aWF0aW9uXG5cdFx0XHRcdHRoaXMuX2NvbnN0cnVjdGluZyA9IHRydWU7XG5cdFx0XHRcdGNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9jb25zdHJ1Y3Rpbmc7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSAhPSBudWxsKSB7IC8vIGNhc3Rpbmdcblx0XHRcdFx0cmV0dXJuIChhcmd1bWVudHNbMF0uZXh0ZW5kIHx8IGV4dGVuZCkuY2FsbChhcmd1bWVudHNbMF0sIHByb3RvKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHQvLyBidWlsZCB0aGUgY2xhc3MgaW50ZXJmYWNlXG5cdGtsYXNzLmFuY2VzdG9yID0gdGhpcztcblx0a2xhc3MuZXh0ZW5kID0gdGhpcy5leHRlbmQ7XG5cdGtsYXNzLmZvckVhY2ggPSB0aGlzLmZvckVhY2g7XG5cdGtsYXNzLmltcGxlbWVudCA9IHRoaXMuaW1wbGVtZW50O1xuXHRrbGFzcy5wcm90b3R5cGUgPSBwcm90bztcblx0a2xhc3MudG9TdHJpbmcgPSB0aGlzLnRvU3RyaW5nO1xuXHRrbGFzcy52YWx1ZU9mID0gZnVuY3Rpb24odHlwZSkge1xuXHRcdC8vcmV0dXJuICh0eXBlID09IFwib2JqZWN0XCIpID8ga2xhc3MgOiBjb25zdHJ1Y3RvcjsgLy8tZGVhblxuXHRcdHJldHVybiAodHlwZSA9PSBcIm9iamVjdFwiKSA/IGtsYXNzIDogY29uc3RydWN0b3IudmFsdWVPZigpO1xuXHR9O1xuXHRleHRlbmQuY2FsbChrbGFzcywgX3N0YXRpYyk7XG5cdC8vIGNsYXNzIGluaXRpYWxpc2F0aW9uXG5cdGlmICh0eXBlb2Yga2xhc3MuaW5pdCA9PSBcImZ1bmN0aW9uXCIpIGtsYXNzLmluaXQoKTtcblx0cmV0dXJuIGtsYXNzO1xufTtcblxuQmFzZS5wcm90b3R5cGUgPSB7XHRcblx0ZXh0ZW5kOiBmdW5jdGlvbihzb3VyY2UsIHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7IC8vIGV4dGVuZGluZyB3aXRoIGEgbmFtZS92YWx1ZSBwYWlyXG5cdFx0XHR2YXIgYW5jZXN0b3IgPSB0aGlzW3NvdXJjZV07XG5cdFx0XHRpZiAoYW5jZXN0b3IgJiYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpICYmIC8vIG92ZXJyaWRpbmcgYSBtZXRob2Q/XG5cdFx0XHRcdC8vIHRoZSB2YWx1ZU9mKCkgY29tcGFyaXNvbiBpcyB0byBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzXG5cdFx0XHRcdCghYW5jZXN0b3IudmFsdWVPZiB8fCBhbmNlc3Rvci52YWx1ZU9mKCkgIT0gdmFsdWUudmFsdWVPZigpKSAmJlxuXHRcdFx0XHQvXFxiYmFzZVxcYi8udGVzdCh2YWx1ZSkpIHtcblx0XHRcdFx0Ly8gZ2V0IHRoZSB1bmRlcmx5aW5nIG1ldGhvZFxuXHRcdFx0XHR2YXIgbWV0aG9kID0gdmFsdWUudmFsdWVPZigpO1xuXHRcdFx0XHQvLyBvdmVycmlkZVxuXHRcdFx0XHR2YWx1ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBwcmV2aW91cyA9IHRoaXMuYmFzZSB8fCBCYXNlLnByb3RvdHlwZS5iYXNlO1xuXHRcdFx0XHRcdHRoaXMuYmFzZSA9IGFuY2VzdG9yO1xuXHRcdFx0XHRcdHZhciByZXR1cm5WYWx1ZSA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdHRoaXMuYmFzZSA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHRcdFx0fTtcblx0XHRcdFx0Ly8gcG9pbnQgdG8gdGhlIHVuZGVybHlpbmcgbWV0aG9kXG5cdFx0XHRcdHZhbHVlLnZhbHVlT2YgPSBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdFx0cmV0dXJuICh0eXBlID09IFwib2JqZWN0XCIpID8gdmFsdWUgOiBtZXRob2Q7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhbHVlLnRvU3RyaW5nID0gQmFzZS50b1N0cmluZztcblx0XHRcdH1cblx0XHRcdHRoaXNbc291cmNlXSA9IHZhbHVlO1xuXHRcdH0gZWxzZSBpZiAoc291cmNlKSB7IC8vIGV4dGVuZGluZyB3aXRoIGFuIG9iamVjdCBsaXRlcmFsXG5cdFx0XHR2YXIgZXh0ZW5kID0gQmFzZS5wcm90b3R5cGUuZXh0ZW5kO1xuXHRcdFx0Ly8gaWYgdGhpcyBvYmplY3QgaGFzIGEgY3VzdG9taXNlZCBleHRlbmQgbWV0aG9kIHRoZW4gdXNlIGl0XG5cdFx0XHRpZiAoIUJhc2UuX3Byb3RvdHlwaW5nICYmIHR5cGVvZiB0aGlzICE9IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRleHRlbmQgPSB0aGlzLmV4dGVuZCB8fCBleHRlbmQ7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcHJvdG8gPSB7dG9Tb3VyY2U6IG51bGx9O1xuXHRcdFx0Ly8gZG8gdGhlIFwidG9TdHJpbmdcIiBhbmQgb3RoZXIgbWV0aG9kcyBtYW51YWxseVxuXHRcdFx0dmFyIGhpZGRlbiA9IFtcImNvbnN0cnVjdG9yXCIsIFwidG9TdHJpbmdcIiwgXCJ2YWx1ZU9mXCJdO1xuXHRcdFx0Ly8gaWYgd2UgYXJlIHByb3RvdHlwaW5nIHRoZW4gaW5jbHVkZSB0aGUgY29uc3RydWN0b3Jcblx0XHRcdHZhciBpID0gQmFzZS5fcHJvdG90eXBpbmcgPyAwIDogMTtcblx0XHRcdHdoaWxlIChrZXkgPSBoaWRkZW5baSsrXSkge1xuXHRcdFx0XHRpZiAoc291cmNlW2tleV0gIT0gcHJvdG9ba2V5XSkge1xuXHRcdFx0XHRcdGV4dGVuZC5jYWxsKHRoaXMsIGtleSwgc291cmNlW2tleV0pO1xuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGNvcHkgZWFjaCBvZiB0aGUgc291cmNlIG9iamVjdCdzIHByb3BlcnRpZXMgdG8gdGhpcyBvYmplY3Rcblx0XHRcdGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdFx0aWYgKCFwcm90b1trZXldKSBleHRlbmQuY2FsbCh0aGlzLCBrZXksIHNvdXJjZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cbi8vIGluaXRpYWxpc2VcbkJhc2UgPSBCYXNlLmV4dGVuZCh7XG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmV4dGVuZChhcmd1bWVudHNbMF0pO1xuXHR9XG59LCB7XG5cdGFuY2VzdG9yOiBPYmplY3QsXG5cdHZlcnNpb246IFwiMS4xXCIsXG5cdFxuXHRmb3JFYWNoOiBmdW5jdGlvbihvYmplY3QsIGJsb2NrLCBjb250ZXh0KSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuXHRcdFx0aWYgKHRoaXMucHJvdG90eXBlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRibG9jay5jYWxsKGNvbnRleHQsIG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRcdFxuXHRpbXBsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0Ly8gaWYgaXQncyBhIGZ1bmN0aW9uLCBjYWxsIGl0XG5cdFx0XHRcdGFyZ3VtZW50c1tpXSh0aGlzLnByb3RvdHlwZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBhZGQgdGhlIGludGVyZmFjZSB1c2luZyB0aGUgZXh0ZW5kIG1ldGhvZFxuXHRcdFx0XHR0aGlzLnByb3RvdHlwZS5leHRlbmQoYXJndW1lbnRzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdFxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlT2YoKSk7XG5cdH1cbn0pOy8qKlxuICogRGV0ZWN0IGJyb3dzZXIgc3VwcG9ydCBmb3Igc3BlY2lmaWMgZmVhdHVyZXNcbiAqL1xud3lzaWh0bWw1LmJyb3dzZXIgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1c2VyQWdlbnQgICA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAvLyBCcm93c2VyIHNuaWZmaW5nIGlzIHVuZm9ydHVuYXRlbHkgbmVlZGVkIHNpbmNlIHNvbWUgYmVoYXZpb3JzIGFyZSBpbXBvc3NpYmxlIHRvIGZlYXR1cmUgZGV0ZWN0XG4gICAgICBpc0lFICAgICAgICA9IHVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRVwiKSAgICAgICAgICE9PSAtMSAmJiB1c2VyQWdlbnQuaW5kZXhPZihcIk9wZXJhXCIpID09PSAtMSxcbiAgICAgIGlzR2Vja28gICAgID0gdXNlckFnZW50LmluZGV4T2YoXCJHZWNrb1wiKSAgICAgICAgIT09IC0xICYmIHVzZXJBZ2VudC5pbmRleE9mKFwiS0hUTUxcIikgPT09IC0xLFxuICAgICAgaXNXZWJLaXQgICAgPSB1c2VyQWdlbnQuaW5kZXhPZihcIkFwcGxlV2ViS2l0L1wiKSAhPT0gLTEsXG4gICAgICBpc0Nocm9tZSAgICA9IHVzZXJBZ2VudC5pbmRleE9mKFwiQ2hyb21lL1wiKSAgICAgICE9PSAtMSxcbiAgICAgIGlzT3BlcmEgICAgID0gdXNlckFnZW50LmluZGV4T2YoXCJPcGVyYS9cIikgICAgICAgIT09IC0xO1xuICBcbiAgZnVuY3Rpb24gaW9zVmVyc2lvbih1c2VyQWdlbnQpIHtcbiAgICByZXR1cm4gKCgvaXBhZHxpcGhvbmV8aXBvZC8udGVzdCh1c2VyQWdlbnQpICYmIHVzZXJBZ2VudC5tYXRjaCgvIG9zIChcXGQrKS4rPyBsaWtlIG1hYyBvcyB4LykpIHx8IFssIDBdKVsxXTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICAvLyBTdGF0aWMgdmFyaWFibGUgbmVlZGVkLCBwdWJsaWNseSBhY2Nlc3NpYmxlLCB0byBiZSBhYmxlIG92ZXJyaWRlIGl0IGluIHVuaXQgdGVzdHNcbiAgICBVU0VSX0FHRU5UOiB1c2VyQWdlbnQsXG4gICAgXG4gICAgLyoqXG4gICAgICogRXhjbHVkZSBicm93c2VycyB0aGF0IGFyZSBub3QgY2FwYWJsZSBvZiBkaXNwbGF5aW5nIGFuZCBoYW5kbGluZ1xuICAgICAqIGNvbnRlbnRFZGl0YWJsZSBhcyBkZXNpcmVkOlxuICAgICAqICAgIC0gaVBob25lLCBpUGFkICh0ZXN0ZWQgaU9TIDQuMi4yKSBhbmQgQW5kcm9pZCAodGVzdGVkIDIuMikgcmVmdXNlIHRvIG1ha2UgY29udGVudEVkaXRhYmxlcyBmb2N1c2FibGVcbiAgICAgKiAgICAtIElFIDwgOCBjcmVhdGUgaW52YWxpZCBtYXJrdXAgYW5kIGNyYXNoIHJhbmRvbWx5IGZyb20gdGltZSB0byB0aW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN1cHBvcnRlZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdXNlckFnZW50ICAgICAgICAgICAgICAgICAgID0gdGhpcy5VU0VSX0FHRU5ULnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgLy8gRXNzZW50aWFsIGZvciBtYWtpbmcgaHRtbCBlbGVtZW50cyBlZGl0YWJsZVxuICAgICAgICAgIGhhc0NvbnRlbnRFZGl0YWJsZVN1cHBvcnQgICA9IFwiY29udGVudEVkaXRhYmxlXCIgaW4gdGVzdEVsZW1lbnQsXG4gICAgICAgICAgLy8gRm9sbG93aW5nIG1ldGhvZHMgYXJlIG5lZWRlZCBpbiBvcmRlciB0byBpbnRlcmFjdCB3aXRoIHRoZSBjb250ZW50RWRpdGFibGUgYXJlYVxuICAgICAgICAgIGhhc0VkaXRpbmdBcGlTdXBwb3J0ICAgICAgICA9IGRvY3VtZW50LmV4ZWNDb21tYW5kICYmIGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCAmJiBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZSxcbiAgICAgICAgICAvLyBkb2N1bWVudCBzZWxlY3RvciBhcGlzIGFyZSBvbmx5IHN1cHBvcnRlZCBieSBJRSA4KywgU2FmYXJpIDQrLCBDaHJvbWUgYW5kIEZpcmVmb3ggMy41K1xuICAgICAgICAgIGhhc1F1ZXJ5U2VsZWN0b3JTdXBwb3J0ICAgICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCxcbiAgICAgICAgICAvLyBjb250ZW50RWRpdGFibGUgaXMgdW51c2FibGUgaW4gbW9iaWxlIGJyb3dzZXJzICh0ZXN0ZWQgaU9TIDQuMi4yLCBBbmRyb2lkIDIuMiwgT3BlcmEgTW9iaWxlLCBXZWJPUyAzLjA1KVxuICAgICAgICAgIGlzSW5jb21wYXRpYmxlTW9iaWxlQnJvd3NlciA9ICh0aGlzLmlzSW9zKCkgJiYgaW9zVmVyc2lvbih1c2VyQWdlbnQpIDwgNSkgfHwgdXNlckFnZW50LmluZGV4T2YoXCJvcGVyYSBtb2JpXCIpICE9PSAtMSB8fCB1c2VyQWdlbnQuaW5kZXhPZihcImhwd29zL1wiKSAhPT0gLTE7XG4gICAgICBcbiAgICAgIHJldHVybiBoYXNDb250ZW50RWRpdGFibGVTdXBwb3J0XG4gICAgICAgICYmIGhhc0VkaXRpbmdBcGlTdXBwb3J0XG4gICAgICAgICYmIGhhc1F1ZXJ5U2VsZWN0b3JTdXBwb3J0XG4gICAgICAgICYmICFpc0luY29tcGF0aWJsZU1vYmlsZUJyb3dzZXI7XG4gICAgfSxcbiAgICBcbiAgICBpc1RvdWNoRGV2aWNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnN1cHBvcnRzRXZlbnQoXCJ0b3VjaG1vdmVcIik7XG4gICAgfSxcbiAgICBcbiAgICBpc0lvczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdXNlckFnZW50ID0gdGhpcy5VU0VSX0FHRU5ULnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gdXNlckFnZW50LmluZGV4T2YoXCJ3ZWJraXRcIikgIT09IC0xICYmIHVzZXJBZ2VudC5pbmRleE9mKFwibW9iaWxlXCIpICE9PSAtMTtcbiAgICB9LFxuICAgIFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgc2FuZGJveGVkIGlmcmFtZXNcbiAgICAgKiBDdXJyZW50bHkgb25seSBJRSA2KyBvZmZlcnMgc3VjaCBmZWF0dXJlIDxpZnJhbWUgc2VjdXJpdHk9XCJyZXN0cmljdGVkXCI+XG4gICAgICpcbiAgICAgKiBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzQ2MjIodj12cy44NSkuYXNweFxuICAgICAqIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llL2FyY2hpdmUvMjAwOC8wMS8xOC91c2luZy1mcmFtZXMtbW9yZS1zZWN1cmVseS5hc3B4XG4gICAgICpcbiAgICAgKiBIVE1MNSBzYW5kYm94ZWQgaWZyYW1lcyBhcmUgc3RpbGwgYnVnZ3kgYW5kIHRoZWlyIERPTSBpcyBub3QgcmVhY2hhYmxlIGZyb20gdGhlIG91dHNpZGUgKGV4Y2VwdCB3aGVuIHVzaW5nIHBvc3RNZXNzYWdlKVxuICAgICAqL1xuICAgIHN1cHBvcnRzU2FuZGJveGVkSWZyYW1lczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXNJRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSUU2KzcgdGhyb3cgYSBtaXhlZCBjb250ZW50IHdhcm5pbmcgd2hlbiB0aGUgc3JjIG9mIGFuIGlmcmFtZVxuICAgICAqIGlzIGVtcHR5L3Vuc2V0IG9yIGFib3V0OmJsYW5rXG4gICAgICogd2luZG93LnF1ZXJ5U2VsZWN0b3IgaXMgaW1wbGVtZW50ZWQgYXMgb2YgSUU4XG4gICAgICovXG4gICAgdGhyb3dzTWl4ZWRDb250ZW50V2FybmluZ1doZW5JZnJhbWVTcmNJc0VtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhKFwicXVlcnlTZWxlY3RvclwiIGluIGRvY3VtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2FyZXQgaXMgY29ycmVjdGx5IGRpc3BsYXllZCBpbiBjb250ZW50RWRpdGFibGUgZWxlbWVudHNcbiAgICAgKiBGaXJlZm94IHNvbWV0aW1lcyBzaG93cyBhIGh1Z2UgY2FyZXQgaW4gdGhlIGJlZ2lubmluZyBhZnRlciBmb2N1c2luZ1xuICAgICAqL1xuICAgIGRpc3BsYXlzQ2FyZXRJbkVtcHR5Q29udGVudEVkaXRhYmxlQ29ycmVjdGx5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhaXNHZWNrbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3BlcmEgYW5kIElFIGFyZSB0aGUgb25seSBicm93c2VycyB3aG8gb2ZmZXIgdGhlIGNzcyB2YWx1ZVxuICAgICAqIGluIHRoZSBvcmlnaW5hbCB1bml0LCB0aHggdG8gdGhlIGN1cnJlbnRTdHlsZSBvYmplY3RcbiAgICAgKiBBbGwgb3RoZXIgYnJvd3NlcnMgcHJvdmlkZSB0aGUgY29tcHV0ZWQgc3R5bGUgaW4gcHggdmlhIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlXG4gICAgICovXG4gICAgaGFzQ3VycmVudFN0eWxlUHJvcGVydHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiY3VycmVudFN0eWxlXCIgaW4gdGVzdEVsZW1lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgaW5zZXJ0cyBhIDxicj4gd2hlbiBwcmVzc2luZyBlbnRlciBpbiBhIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50XG4gICAgICovXG4gICAgaW5zZXJ0c0xpbmVCcmVha3NPblJldHVybjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXNHZWNrbztcbiAgICB9LFxuXG4gICAgc3VwcG9ydHNQbGFjZWhvbGRlckF0dHJpYnV0ZU9uOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICByZXR1cm4gXCJwbGFjZWhvbGRlclwiIGluIGVsZW1lbnQ7XG4gICAgfSxcblxuICAgIHN1cHBvcnRzRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgcmV0dXJuIFwib25cIiArIGV2ZW50TmFtZSBpbiB0ZXN0RWxlbWVudCB8fCAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRlc3RFbGVtZW50LnNldEF0dHJpYnV0ZShcIm9uXCIgKyBldmVudE5hbWUsIFwicmV0dXJuO1wiKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZih0ZXN0RWxlbWVudFtcIm9uXCIgKyBldmVudE5hbWVdKSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgfSkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3BlcmEgZG9lc24ndCBjb3JyZWN0bHkgZmlyZSBmb2N1cy9ibHVyIGV2ZW50cyB3aGVuIGNsaWNraW5nIGluLSBhbmQgb3V0c2lkZSBvZiBpZnJhbWVcbiAgICAgKi9cbiAgICBzdXBwb3J0c0V2ZW50c0luSWZyYW1lQ29ycmVjdGx5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhaXNPcGVyYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hyb21lICYgU2FmYXJpIG9ubHkgZmlyZSB0aGUgb25kcm9wL29uZHJhZ2VuZC8uLi4gZXZlbnRzIHdoZW4gdGhlIG9uZHJhZ292ZXIgZXZlbnQgaXMgY2FuY2VsbGVkXG4gICAgICogd2l0aCBldmVudC5wcmV2ZW50RGVmYXVsdFxuICAgICAqIEZpcmVmb3ggMy42IGZpcmVzIHRob3NlIGV2ZW50cyBhbnl3YXksIGJ1dCB0aGUgbW96aWxsYSBkb2Mgc2F5cyB0aGF0IHRoZSBkcmFnb3Zlci9kcmFnZW50ZXIgZXZlbnQgbmVlZHNcbiAgICAgKiB0byBiZSBjYW5jZWxsZWRcbiAgICAgKi9cbiAgICBmaXJlc09uRHJvcE9ubHlXaGVuT25EcmFnT3ZlcklzQ2FuY2VsbGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpc1dlYktpdCB8fCBpc0dlY2tvO1xuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgZXZlbnQuZGF0YVRyYW5zZmVyIHByb3BlcnR5IGluIGEgcHJvcGVyIHdheVxuICAgICAqL1xuICAgIHN1cHBvcnRzRGF0YVRyYW5zZmVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IGRhdGFUcmFuc2ZlciBpbiBhIHNhZmUgd2F5LCBpdCBkb2Vzbid0IHN0cmlwIHNjcmlwdCBjb2RlIGluIHRoZSBodG1sIHBheWxvYWQgKGxpa2UgQ2hyb21lIGRvZXMpXG4gICAgICAgIHJldHVybiBpc1dlYktpdCAmJiAod2luZG93LkNsaXBib2FyZCB8fCB3aW5kb3cuRGF0YVRyYW5zZmVyKS5wcm90b3R5cGUuZ2V0RGF0YTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV2ZXJ5dGhpbmcgYmVsb3cgSUU5IGRvZXNuJ3Qga25vdyBob3cgdG8gdHJlYXQgSFRNTDUgdGFnc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIGRvY3VtZW50IG9iamVjdCBvbiB3aGljaCB0byBjaGVjayBIVE1MNSBzdXBwb3J0XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzSFRNTDVUYWdzKGRvY3VtZW50KTtcbiAgICAgKi9cbiAgICBzdXBwb3J0c0hUTUw1VGFnczogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgaHRtbDUgICA9IFwiPGFydGljbGU+Zm9vPC9hcnRpY2xlPlwiO1xuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBodG1sNTtcbiAgICAgIHJldHVybiBlbGVtZW50LmlubmVySFRNTC50b0xvd2VyQ2FzZSgpID09PSBodG1sNTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSBkb2N1bWVudCBzdXBwb3J0cyBhIGNlcnRhaW4gcXVlcnlDb21tYW5kXG4gICAgICogSW4gcGFydGljdWxhciwgT3BlcmEgbmVlZHMgYSByZWZlcmVuY2UgdG8gYSBkb2N1bWVudCB0aGF0IGhhcyBhIGNvbnRlbnRFZGl0YWJsZSBpbiBpdCdzIGRvbSB0cmVlXG4gICAgICogaW4gb2RlciB0byByZXBvcnQgY29ycmVjdCByZXN1bHRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZG9jIERvY3VtZW50IG9iamVjdCBvbiB3aGljaCB0byBjaGVjayBmb3IgYSBxdWVyeSBjb21tYW5kXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbW1hbmQgVGhlIHF1ZXJ5IGNvbW1hbmQgdG8gY2hlY2sgZm9yXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNDb21tYW5kKGRvY3VtZW50LCBcImJvbGRcIik7XG4gICAgICovXG4gICAgc3VwcG9ydHNDb21tYW5kOiAoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBGb2xsb3dpbmcgY29tbWFuZHMgYXJlIHN1cHBvcnRlZCBidXQgY29udGFpbiBidWdzIGluIHNvbWUgYnJvd3NlcnNcbiAgICAgIHZhciBidWdneUNvbW1hbmRzID0ge1xuICAgICAgICAvLyBmb3JtYXRCbG9jayBmYWlscyB3aXRoIHNvbWUgdGFncyAoZWcuIDxibG9ja3F1b3RlPilcbiAgICAgICAgXCJmb3JtYXRCbG9ja1wiOiAgICAgICAgICBpc0lFLFxuICAgICAgICAgLy8gV2hlbiBpbnNlcnRpbmcgdW5vcmRlcmVkIG9yIG9yZGVyZWQgbGlzdHMgaW4gRmlyZWZveCwgQ2hyb21lIG9yIFNhZmFyaSwgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIG9yIGxpbmUgZ2V0c1xuICAgICAgICAgLy8gY29udmVydGVkIGludG8gYSBsaXN0ICg8dWw+PGxpPi4uLjwvbGk+PC91bD4sIDxvbD48bGk+Li4uPC9saT48L29sPilcbiAgICAgICAgIC8vIElFIGFuZCBPcGVyYSBhY3QgYSBiaXQgZGlmZmVyZW50IGhlcmUgYXMgdGhleSBjb252ZXJ0IHRoZSBlbnRpcmUgY29udGVudCBvZiB0aGUgY3VycmVudCBibG9jayBlbGVtZW50IGludG8gYSBsaXN0XG4gICAgICAgIFwiaW5zZXJ0VW5vcmRlcmVkTGlzdFwiOiAgaXNJRSB8fCBpc09wZXJhIHx8IGlzV2ViS2l0LFxuICAgICAgICBcImluc2VydE9yZGVyZWRMaXN0XCI6ICAgIGlzSUUgfHwgaXNPcGVyYSB8fCBpc1dlYktpdFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gRmlyZWZveCB0aHJvd3MgZXJyb3JzIGZvciBxdWVyeUNvbW1hbmRTdXBwb3J0ZWQsIHNvIHdlIGhhdmUgdG8gYnVpbGQgdXAgb3VyIG93biBvYmplY3Qgb2Ygc3VwcG9ydGVkIGNvbW1hbmRzXG4gICAgICB2YXIgc3VwcG9ydGVkID0ge1xuICAgICAgICBcImluc2VydEhUTUxcIjogaXNHZWNrb1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRvYywgY29tbWFuZCkge1xuICAgICAgICB2YXIgaXNCdWdneSA9IGJ1Z2d5Q29tbWFuZHNbY29tbWFuZF07XG4gICAgICAgIGlmICghaXNCdWdneSkge1xuICAgICAgICAgIC8vIEZpcmVmb3ggdGhyb3dzIGVycm9ycyB3aGVuIGludm9raW5nIHF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCBvciBxdWVyeUNvbW1hbmRFbmFibGVkXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBkb2MucXVlcnlDb21tYW5kU3VwcG9ydGVkKGNvbW1hbmQpO1xuICAgICAgICAgIH0gY2F0Y2goZTEpIHt9XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGRvYy5xdWVyeUNvbW1hbmRFbmFibGVkKGNvbW1hbmQpO1xuICAgICAgICAgIH0gY2F0Y2goZTIpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXN1cHBvcnRlZFtjb21tYW5kXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9KSgpLFxuXG4gICAgLyoqXG4gICAgICogSUU6IFVSTHMgc3RhcnRpbmcgd2l0aDpcbiAgICAgKiAgICB3d3cuLCBodHRwOi8vLCBodHRwczovLywgZnRwOi8vLCBnb3BoZXI6Ly8sIG1haWx0bzosIG5ldzosIHNuZXdzOiwgdGVsbmV0Oiwgd2FzaXM6LCBmaWxlOi8vLFxuICAgICAqICAgIG5udHA6Ly8sIG5ld3NyYzosIGxkYXA6Ly8sIGxkYXBzOi8vLCBvdXRsb29rOiwgbWljOi8vIGFuZCB1cmw6XG4gICAgICogd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGF1dG8tbGlua2VkIHdoZW4gZWl0aGVyIHRoZSB1c2VyIGluc2VydHMgdGhlbSB2aWEgY29weSZwYXN0ZSBvciBwcmVzc2VzIHRoZVxuICAgICAqIHNwYWNlIGJhciB3aGVuIHRoZSBjYXJldCBpcyBkaXJlY3RseSBhZnRlciBzdWNoIGFuIHVybC5cbiAgICAgKiBUaGlzIGJlaGF2aW9yIGNhbm5vdCBlYXNpbHkgYmUgYXZvaWRlZCBpbiBJRSA8IDkgc2luY2UgdGhlIGxvZ2ljIGlzIGhhcmRjb2RlZCBpbiB0aGUgbXNodG1sLmRsbFxuICAgICAqIChyZWxhdGVkIGJsb2cgcG9zdCBvbiBtc2RuXG4gICAgICogaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDA5LzA5LzE3L3ByZXZlbnQtYXV0b21hdGljLWh5cGVybGlua2luZy1pbi1jb250ZW50ZWRpdGFibGUtaHRtbC5hc3B4KS5cbiAgICAgKi9cbiAgICBkb2VzQXV0b0xpbmtpbmdJbkNvbnRlbnRFZGl0YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXNJRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXMgc3RhdGVkIGFib3ZlLCBJRSBhdXRvIGxpbmtzIHVybHMgdHlwZWQgaW50byBjb250ZW50RWRpdGFibGUgZWxlbWVudHNcbiAgICAgKiBTaW5jZSBJRTkgaXQncyBwb3NzaWJsZSB0byBwcmV2ZW50IHRoaXMgYmVoYXZpb3JcbiAgICAgKi9cbiAgICBjYW5EaXNhYmxlQXV0b0xpbmtpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3VwcG9ydHNDb21tYW5kKGRvY3VtZW50LCBcIkF1dG9VcmxEZXRlY3RcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElFIGxlYXZlcyBhbiBlbXB0eSBwYXJhZ3JhcGggaW4gdGhlIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50IGFmdGVyIGNsZWFyaW5nIGl0XG4gICAgICogQ2hyb21lL1NhZmFyaSBzb21ldGltZXMgYW4gZW1wdHkgPGRpdj5cbiAgICAgKi9cbiAgICBjbGVhcnNDb250ZW50RWRpdGFibGVDb3JyZWN0bHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzR2Vja28gfHwgaXNPcGVyYSB8fCBpc1dlYktpdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSUUgZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgZ2V0QXR0cmlidXRlXG4gICAgICovXG4gICAgc3VwcG9ydHNHZXRBdHRyaWJ1dGVDb3JyZWN0bHk6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuICAgICAgcmV0dXJuIHRkLmdldEF0dHJpYnV0ZShcInJvd3NwYW5cIikgIT0gXCIxXCI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2xpY2tpbmcgb24gaW1hZ2VzIGluIElFLCBPcGVyYSBhbmQgRmlyZWZveCwgdGhleSBhcmUgc2VsZWN0ZWQsIHdoaWNoIG1ha2VzIGl0IGVhc3kgdG8gaW50ZXJhY3Qgd2l0aCB0aGVtLlxuICAgICAqIENocm9tZSBhbmQgU2FmYXJpIGJvdGggZG9uJ3Qgc3VwcG9ydCB0aGlzXG4gICAgICovXG4gICAgY2FuU2VsZWN0SW1hZ2VzSW5Db250ZW50RWRpdGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzR2Vja28gfHwgaXNJRSB8fCBpc09wZXJhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBjYXJldCBpcyBpbiBhbiBlbXB0eSBsaXN0ICg8dWw+PGxpPnw8L2xpPjwvdWw+KSB3aGljaCBpcyB0aGUgZmlyc3QgY2hpbGQgaW4gYW4gY29udGVudEVkaXRhYmxlIGNvbnRhaW5lclxuICAgICAqIHByZXNzaW5nIGJhY2tzcGFjZSBkb2Vzbid0IHJlbW92ZSB0aGUgZW50aXJlIGxpc3QgYXMgZG9uZSBpbiBvdGhlciBicm93c2Vyc1xuICAgICAqL1xuICAgIGNsZWFyc0xpc3RzSW5Db250ZW50RWRpdGFibGVDb3JyZWN0bHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGlzR2Vja28gfHwgaXNJRSB8fCBpc1dlYktpdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWxsIGJyb3dzZXJzIGV4Y2VwdCBTYWZhcmkgYW5kIENocm9tZSBhdXRvbWF0aWNhbGx5IHNjcm9sbCB0aGUgcmFuZ2UvY2FyZXQgcG9zaXRpb24gaW50byB2aWV3XG4gICAgICovXG4gICAgYXV0b1Njcm9sbHNUb0NhcmV0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhaXNXZWJLaXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGJyb3dzZXIgYXV0b21hdGljYWxseSBjbG9zZXMgdGFncyB0aGF0IGRvbid0IG5lZWQgdG8gYmUgb3BlbmVkXG4gICAgICovXG4gICAgYXV0b0Nsb3Nlc1VuY2xvc2VkVGFnczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2xvbmVkVGVzdEVsZW1lbnQgPSB0ZXN0RWxlbWVudC5jbG9uZU5vZGUoZmFsc2UpLFxuICAgICAgICAgIHJldHVyblZhbHVlLFxuICAgICAgICAgIGlubmVySFRNTDtcblxuICAgICAgY2xvbmVkVGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gXCI8cD48ZGl2PjwvZGl2PlwiO1xuICAgICAgaW5uZXJIVE1MICAgICAgICAgICAgICAgICAgID0gY2xvbmVkVGVzdEVsZW1lbnQuaW5uZXJIVE1MLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm5WYWx1ZSAgICAgICAgICAgICAgICAgPSBpbm5lckhUTUwgPT09IFwiPHA+PC9wPjxkaXY+PC9kaXY+XCIgfHwgaW5uZXJIVE1MID09PSBcIjxwPjxkaXY+PC9kaXY+PC9wPlwiO1xuXG4gICAgICAvLyBDYWNoZSByZXN1bHQgYnkgb3ZlcndyaXRpbmcgY3VycmVudCBmdW5jdGlvblxuICAgICAgdGhpcy5hdXRvQ2xvc2VzVW5jbG9zZWRUYWdzID0gZnVuY3Rpb24oKSB7IHJldHVybiByZXR1cm5WYWx1ZTsgfTtcblxuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBuYXRpdmUgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSB3aGljaCByZXR1cm5zIGxpdmUgTm9kZUxpc3RzXG4gICAgICovXG4gICAgc3VwcG9ydHNOYXRpdmVHZXRFbGVtZW50c0J5Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSkuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcyBvZiBub3cgKDE5LjA0LjIwMTEpIG9ubHkgc3VwcG9ydGVkIGJ5IEZpcmVmb3ggNCBhbmQgQ2hyb21lXG4gICAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9TZWxlY3Rpb24vbW9kaWZ5XG4gICAgICovXG4gICAgc3VwcG9ydHNTZWxlY3Rpb25Nb2RpZnk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiZ2V0U2VsZWN0aW9uXCIgaW4gd2luZG93ICYmIFwibW9kaWZ5XCIgaW4gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgY2xhc3NMaXN0IG9iamVjdCBmb3IgZmFzdCBjbGFzc05hbWUgbWFuaXB1bGF0aW9uXG4gICAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9lbGVtZW50LmNsYXNzTGlzdFxuICAgICAqL1xuICAgIHN1cHBvcnRzQ2xhc3NMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBcImNsYXNzTGlzdFwiIGluIHRlc3RFbGVtZW50O1xuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICogT3BlcmEgbmVlZHMgYSB3aGl0ZSBzcGFjZSBhZnRlciBhIDxicj4gaW4gb3JkZXIgdG8gcG9zaXRpb24gdGhlIGNhcmV0IGNvcnJlY3RseVxuICAgICAqL1xuICAgIG5lZWRzU3BhY2VBZnRlckxpbmVCcmVhazogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXNPcGVyYTtcbiAgICB9LFxuICAgIFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIHNwZWVjaCBhcGkgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAgKiBTZWUgaHR0cDovL21pa2VwdWx0ei5jb20vMjAxMS8wMy9hY2Nlc3NpbmctZ29vZ2xlLXNwZWVjaC1hcGktY2hyb21lLTExL1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICogICAgaWYgKHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzU3BlZWNoQXBpT24oaW5wdXQpKSB7XG4gICAgICogICAgICAvLyAuLi5cbiAgICAgKiAgICB9XG4gICAgICovXG4gICAgc3VwcG9ydHNTcGVlY2hBcGlPbjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHZhciBjaHJvbWVWZXJzaW9uID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKSB8fCBbLCAwXTtcbiAgICAgIHJldHVybiBjaHJvbWVWZXJzaW9uWzFdID49IDExICYmIChcIm9ud2Via2l0c3BlZWNoY2hhbmdlXCIgaW4gaW5wdXQgfHwgXCJzcGVlY2hcIiBpbiBpbnB1dCk7XG4gICAgfSxcbiAgICBcbiAgICAvKipcbiAgICAgKiBJRTkgY3Jhc2hlcyB3aGVuIHNldHRpbmcgYSBnZXR0ZXIgdmlhIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBvbiBYTUxIdHRwUmVxdWVzdCBvciBYRG9tYWluUmVxdWVzdFxuICAgICAqIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9pZS9mZWVkYmFjay9kZXRhaWxzLzY1MDExMlxuICAgICAqIG9yIHRyeSB0aGUgUE9DIGh0dHA6Ly90aWZmdGlmZi5kZS9pZTlfY3Jhc2gvXG4gICAgICovXG4gICAgY3Jhc2hlc1doZW5EZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBpc0lFICYmIChwcm9wZXJ0eSA9PT0gXCJYTUxIdHRwUmVxdWVzdFwiIHx8IHByb3BlcnR5ID09PSBcIlhEb21haW5SZXF1ZXN0XCIpO1xuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICogSUUgaXMgdGhlIG9ubHkgYnJvd3NlciB3aG8gZmlyZXMgdGhlIFwiZm9jdXNcIiBldmVudCBub3QgaW1tZWRpYXRlbHkgd2hlbiAuZm9jdXMoKSBpcyBjYWxsZWQgb24gYW4gZWxlbWVudFxuICAgICAqL1xuICAgIGRvZXNBc3luY0ZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpc0lFO1xuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICogSW4gSUUgaXQncyBpbXBzc2libGUgZm9yIHRoZSB1c2VyIGFuZCBmb3IgdGhlIHNlbGVjdGlvbiBsaWJyYXJ5IHRvIHNldCB0aGUgY2FyZXQgYWZ0ZXIgYW4gPGltZz4gd2hlbiBpdCdzIHRoZSBsYXN0Q2hpbGQgaW4gdGhlIGRvY3VtZW50XG4gICAgICovXG4gICAgaGFzUHJvYmxlbXNTZXR0aW5nQ2FyZXRBZnRlckltZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXNJRTtcbiAgICB9LFxuICAgIFxuICAgIGhhc1VuZG9JbkNvbnRleHRNZW51OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpc0dlY2tvIHx8IGlzQ2hyb21lIHx8IGlzT3BlcmE7XG4gICAgfVxuICB9O1xufSkoKTt3eXNpaHRtbDUubGFuZy5hcnJheSA9IGZ1bmN0aW9uKGFycikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgYSBnaXZlbiBvYmplY3QgZXhpc3RzIGluIGFuIGFycmF5XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHd5c2lodG1sNS5sYW5nLmFycmF5KFsxLCAyXSkuY29udGFpbnMoMSk7XG4gICAgICogICAgLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihuZWVkbGUpIHtcbiAgICAgIGlmIChhcnIuaW5kZXhPZikge1xuICAgICAgICByZXR1cm4gYXJyLmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpPTAsIGxlbmd0aD1hcnIubGVuZ3RoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFycltpXSA9PT0gbmVlZGxlKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICogU3Vic3RyYWN0IG9uZSBhcnJheSBmcm9tIGFub3RoZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1LmxhbmcuYXJyYXkoWzEsIDIsIDMsIDRdKS53aXRob3V0KFszLCA0XSk7XG4gICAgICogICAgLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgd2l0aG91dDogZnVuY3Rpb24oYXJyYXlUb1N1YnN0cmFjdCkge1xuICAgICAgYXJyYXlUb1N1YnN0cmFjdCA9IHd5c2lodG1sNS5sYW5nLmFycmF5KGFycmF5VG9TdWJzdHJhY3QpO1xuICAgICAgdmFyIG5ld0FyciAgPSBbXSxcbiAgICAgICAgICBpICAgICAgID0gMCxcbiAgICAgICAgICBsZW5ndGggID0gYXJyLmxlbmd0aDtcbiAgICAgIGZvciAoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghYXJyYXlUb1N1YnN0cmFjdC5jb250YWlucyhhcnJbaV0pKSB7XG4gICAgICAgICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0FycjtcbiAgICB9LFxuICAgIFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGNsZWFuIG5hdGl2ZSBhcnJheVxuICAgICAqIFxuICAgICAqIEZvbGxvd2luZyB3aWxsIGNvbnZlcnQgYSBMaXZlIE5vZGVMaXN0IHRvIGEgcHJvcGVyIEFycmF5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB2YXIgY2hpbGROb2RlcyA9IHd5c2lodG1sNS5sYW5nLmFycmF5KGRvY3VtZW50LmJvZHkuY2hpbGROb2RlcykuZ2V0KCk7XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpICAgICAgICA9IDAsXG4gICAgICAgICAgbGVuZ3RoICAgPSBhcnIubGVuZ3RoLFxuICAgICAgICAgIG5ld0FycmF5ID0gW107XG4gICAgICBmb3IgKDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdBcnJheS5wdXNoKGFycltpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3QXJyYXk7XG4gICAgfVxuICB9O1xufTt3eXNpaHRtbDUubGFuZy5EaXNwYXRjaGVyID0gQmFzZS5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LmxhbmcuRGlhbG9nLnByb3RvdHlwZSAqLyB7XG4gIG9ic2VydmU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMgfHwge307XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gfHwgW107XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9uOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vYnNlcnZlLmFwcGx5KHRoaXMsIHd5c2lodG1sNS5sYW5nLmFycmF5KGFyZ3VtZW50cykuZ2V0KCkpO1xuICB9LFxuXG4gIGZpcmU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgcGF5bG9hZCkge1xuICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMgfHwge307XG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXSB8fCBbXSxcbiAgICAgICAgaSAgICAgICAgPSAwO1xuICAgIGZvciAoOyBpPGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYW5kbGVyc1tpXS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzdG9wT2JzZXJ2aW5nOiBmdW5jdGlvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLmV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IHt9O1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgaGFuZGxlcnMsXG4gICAgICAgIG5ld0hhbmRsZXJzO1xuICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgIGhhbmRsZXJzICAgID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXSB8fCBbXSxcbiAgICAgIG5ld0hhbmRsZXJzID0gW107XG4gICAgICBmb3IgKDsgaTxoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGFuZGxlcnNbaV0gIT09IGhhbmRsZXIgJiYgaGFuZGxlcikge1xuICAgICAgICAgIG5ld0hhbmRsZXJzLnB1c2goaGFuZGxlcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gbmV3SGFuZGxlcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFuIHVwIGFsbCBldmVudHNcbiAgICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTt3eXNpaHRtbDUubGFuZy5vYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHd5c2lodG1sNS5sYW5nLm9iamVjdCh7IGZvbzogMSwgYmFyOiAxIH0pLm1lcmdlKHsgYmFyOiAyLCBiYXo6IDMgfSkuZ2V0KCk7XG4gICAgICogICAgLy8gPT4geyBmb286IDEsIGJhcjogMiwgYmF6OiAzIH1cbiAgICAgKi9cbiAgICBtZXJnZTogZnVuY3Rpb24ob3RoZXJPYmopIHtcbiAgICAgIGZvciAodmFyIGkgaW4gb3RoZXJPYmopIHtcbiAgICAgICAgb2JqW2ldID0gb3RoZXJPYmpbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB3eXNpaHRtbDUubGFuZy5vYmplY3QoeyBmb286IDEgfSkuY2xvbmUoKTtcbiAgICAgKiAgICAvLyA9PiB7IGZvbzogMSB9XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5ld09iaiA9IHt9LFxuICAgICAgICAgIGk7XG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgIG5ld09ialtpXSA9IG9ialtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfSxcbiAgICBcbiAgICAvKipcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHd5c2lodG1sNS5sYW5nLm9iamVjdChbXSkuaXNBcnJheSgpO1xuICAgICAqICAgIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBpc0FycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgIH1cbiAgfTtcbn07KGZ1bmN0aW9uKCkge1xuICB2YXIgV0hJVEVfU1BBQ0VfU1RBUlQgPSAvXlxccysvLFxuICAgICAgV0hJVEVfU1BBQ0VfRU5EICAgPSAvXFxzKyQvO1xuICB3eXNpaHRtbDUubGFuZy5zdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogICAgd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKFwiICAgZm9vICAgXCIpLnRyaW0oKTtcbiAgICAgICAqICAgIC8vID0+IFwiZm9vXCJcbiAgICAgICAqL1xuICAgICAgdHJpbTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShXSElURV9TUEFDRV9TVEFSVCwgXCJcIikucmVwbGFjZShXSElURV9TUEFDRV9FTkQsIFwiXCIpO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgLyoqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogICAgd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKFwiSGVsbG8gI3tuYW1lfVwiKS5pbnRlcnBvbGF0ZSh7IG5hbWU6IFwiQ2hyaXN0b3BoZXJcIiB9KTtcbiAgICAgICAqICAgIC8vID0+IFwiSGVsbG8gQ2hyaXN0b3BoZXJcIlxuICAgICAgICovXG4gICAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24odmFycykge1xuICAgICAgICBmb3IgKHZhciBpIGluIHZhcnMpIHtcbiAgICAgICAgICBzdHIgPSB0aGlzLnJlcGxhY2UoXCIje1wiICsgaSArIFwifVwiKS5ieSh2YXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgLyoqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogICAgd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKFwiSGVsbG8gVG9tXCIpLnJlcGxhY2UoXCJUb21cIikud2l0aChcIkhhbnNcIik7XG4gICAgICAgKiAgICAvLyA9PiBcIkhlbGxvIEhhbnNcIlxuICAgICAgICovXG4gICAgICByZXBsYWNlOiBmdW5jdGlvbihzZWFyY2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBieTogZnVuY3Rpb24ocmVwbGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zcGxpdChzZWFyY2gpLmpvaW4ocmVwbGFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn0pKCk7LyoqXG4gKiBGaW5kIHVybHMgaW4gZGVzY2VuZGFudCB0ZXh0IG5vZGVzIG9mIGFuIGVsZW1lbnQgYW5kIGF1dG8tbGlua3MgdGhlbVxuICogSW5zcGlyZWQgYnkgaHR0cDovL2phbWVzLnBhZG9sc2V5LmNvbS9qYXZhc2NyaXB0L2ZpbmQtYW5kLXJlcGxhY2UtdGV4dC13aXRoLWphdmFzY3JpcHQvXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IENvbnRhaW5lciBlbGVtZW50IGluIHdoaWNoIHRvIHNlYXJjaCBmb3IgdXJsc1xuICpcbiAqIEBleGFtcGxlXG4gKiAgICA8ZGl2IGlkPVwidGV4dC1jb250YWluZXJcIj5QbGVhc2UgY2xpY2sgaGVyZTogd3d3Lmdvb2dsZS5jb208L2Rpdj5cbiAqICAgIDxzY3JpcHQ+d3lzaWh0bWw1LmRvbS5hdXRvTGluayhkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRleHQtY29udGFpbmVyXCIpKTs8L3NjcmlwdD5cbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgLyoqXG4gICAgICAgKiBEb24ndCBhdXRvLWxpbmsgdXJscyB0aGF0IGFyZSBjb250YWluZWQgaW4gdGhlIGZvbGxvd2luZyBlbGVtZW50czpcbiAgICAgICAqL1xuICAgICAgSUdOT1JFX1VSTFNfSU4gICAgICAgID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoW1wiQ09ERVwiLCBcIlBSRVwiLCBcIkFcIiwgXCJTQ1JJUFRcIiwgXCJIRUFEXCIsIFwiVElUTEVcIiwgXCJTVFlMRVwiXSksXG4gICAgICAvKipcbiAgICAgICAqIHJldmlzaW9uIDE6XG4gICAgICAgKiAgICAvKFxcUytcXC57MX1bXlxcc1xcLFxcLlxcIV0rKS9nXG4gICAgICAgKlxuICAgICAgICogcmV2aXNpb24gMjpcbiAgICAgICAqICAgIC8oXFxiKCgoaHR0cHM/fGZ0cCk6XFwvXFwvKXwod3d3XFwuKSlbLUEtWjAtOSsmQCNcXC8lPz1+X3whOiwuO1xcW1xcXV0qWy1BLVowLTkrJkAjXFwvJT1+X3xdKS9naW1cbiAgICAgICAqXG4gICAgICAgKiBwdXQgdGhpcyBpbiB0aGUgYmVnaW5uaW5nIGlmIHlvdSBkb24ndCB3YW4ndCB0byBtYXRjaCB3aXRoaW4gYSB3b3JkXG4gICAgICAgKiAgICAoXnxbXFw+XFwoXFx7XFxbXFxzXFw+XSlcbiAgICAgICAqL1xuICAgICAgVVJMX1JFR19FWFAgICAgICAgICAgID0gLygoaHR0cHM/OlxcL1xcL3x3d3dcXC4pW15cXHM8XXszLH0pL2dpLFxuICAgICAgVFJBSUxJTkdfQ0hBUl9SRUdfRVhQID0gLyhbXlxcd1xcL1xcLV0oLD8pKSQvaSxcbiAgICAgIE1BWF9ESVNQTEFZX0xFTkdUSCAgICA9IDEwMCxcbiAgICAgIEJSQUNLRVRTICAgICAgICAgICAgICA9IHsgXCIpXCI6IFwiKFwiLCBcIl1cIjogXCJbXCIsIFwifVwiOiBcIntcIiB9O1xuICBcbiAgZnVuY3Rpb24gYXV0b0xpbmsoZWxlbWVudCkge1xuICAgIGlmIChfaGFzUGFyZW50VGhhdFNob3VsZEJlSWdub3JlZChlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQgPT09IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3BhcnNlTm9kZShlbGVtZW50KTtcbiAgfVxuICBcbiAgLyoqXG4gICAqIFRoaXMgaXMgYmFzaWNhbGx5IGEgcmVidWlsZCBvZlxuICAgKiB0aGUgcmFpbHMgYXV0b19saW5rX3VybHMgdGV4dCBoZWxwZXJcbiAgICovXG4gIGZ1bmN0aW9uIF9jb252ZXJ0VXJsc1RvTGlua3Moc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKFVSTF9SRUdfRVhQLCBmdW5jdGlvbihtYXRjaCwgdXJsKSB7XG4gICAgICB2YXIgcHVuY3R1YXRpb24gPSAodXJsLm1hdGNoKFRSQUlMSU5HX0NIQVJfUkVHX0VYUCkgfHwgW10pWzFdIHx8IFwiXCIsXG4gICAgICAgICAgb3BlbmluZyAgICAgPSBCUkFDS0VUU1twdW5jdHVhdGlvbl07XG4gICAgICB1cmwgPSB1cmwucmVwbGFjZShUUkFJTElOR19DSEFSX1JFR19FWFAsIFwiXCIpO1xuXG4gICAgICBpZiAodXJsLnNwbGl0KG9wZW5pbmcpLmxlbmd0aCA+IHVybC5zcGxpdChwdW5jdHVhdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIHVybCA9IHVybCArIHB1bmN0dWF0aW9uO1xuICAgICAgICBwdW5jdHVhdGlvbiA9IFwiXCI7XG4gICAgICB9XG4gICAgICB2YXIgcmVhbFVybCAgICA9IHVybCxcbiAgICAgICAgICBkaXNwbGF5VXJsID0gdXJsO1xuICAgICAgaWYgKHVybC5sZW5ndGggPiBNQVhfRElTUExBWV9MRU5HVEgpIHtcbiAgICAgICAgZGlzcGxheVVybCA9IGRpc3BsYXlVcmwuc3Vic3RyKDAsIE1BWF9ESVNQTEFZX0xFTkdUSCkgKyBcIi4uLlwiO1xuICAgICAgfVxuICAgICAgLy8gQWRkIGh0dHAgcHJlZml4IGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHJlYWxVcmwuc3Vic3RyKDAsIDQpID09PSBcInd3dy5cIikge1xuICAgICAgICByZWFsVXJsID0gXCJodHRwOi8vXCIgKyByZWFsVXJsO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gJzxhIGhyZWY9XCInICsgcmVhbFVybCArICdcIj4nICsgZGlzcGxheVVybCArICc8L2E+JyArIHB1bmN0dWF0aW9uO1xuICAgIH0pO1xuICB9XG4gIFxuICAvKipcbiAgICogQ3JlYXRlcyBvciAoaWYgYWxyZWFkeSBjYWNoZWQpIHJldHVybnMgYSB0ZW1wIGVsZW1lbnRcbiAgICogZm9yIHRoZSBnaXZlbiBkb2N1bWVudCBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRUZW1wRWxlbWVudChjb250ZXh0KSB7XG4gICAgdmFyIHRlbXBFbGVtZW50ID0gY29udGV4dC5fd3lzaWh0bWw1X3RlbXBFbGVtZW50O1xuICAgIGlmICghdGVtcEVsZW1lbnQpIHtcbiAgICAgIHRlbXBFbGVtZW50ID0gY29udGV4dC5fd3lzaWh0bWw1X3RlbXBFbGVtZW50ID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcEVsZW1lbnQ7XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgb3JpZ2luYWwgdGV4dCBub2RlcyB3aXRoIHRoZSBuZXdseSBhdXRvLWxpbmtlZCBkb20gdHJlZVxuICAgKi9cbiAgZnVuY3Rpb24gX3dyYXBNYXRjaGVzSW5Ob2RlKHRleHROb2RlKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgID0gdGV4dE5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgdGVtcEVsZW1lbnQgPSBfZ2V0VGVtcEVsZW1lbnQocGFyZW50Tm9kZS5vd25lckRvY3VtZW50KTtcbiAgICBcbiAgICAvLyBXZSBuZWVkIHRvIGluc2VydCBhbiBlbXB0eS90ZW1wb3JhcnkgPHNwYW4gLz4gdG8gZml4IElFIHF1aXJrc1xuICAgIC8vIEVsc2V3aXNlIElFIHdvdWxkIHN0cmlwIHdoaXRlIHNwYWNlIGluIHRoZSBiZWdpbm5pbmdcbiAgICB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPSBcIjxzcGFuPjwvc3Bhbj5cIiArIF9jb252ZXJ0VXJsc1RvTGlua3ModGV4dE5vZGUuZGF0YSk7XG4gICAgdGVtcEVsZW1lbnQucmVtb3ZlQ2hpbGQodGVtcEVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgXG4gICAgd2hpbGUgKHRlbXBFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIC8vIGluc2VydHMgdGVtcEVsZW1lbnQuZmlyc3RDaGlsZCBiZWZvcmUgdGV4dE5vZGVcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRlbXBFbGVtZW50LmZpcnN0Q2hpbGQsIHRleHROb2RlKTtcbiAgICB9XG4gICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZXh0Tm9kZSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIF9oYXNQYXJlbnRUaGF0U2hvdWxkQmVJZ25vcmVkKG5vZGUpIHtcbiAgICB2YXIgbm9kZU5hbWU7XG4gICAgd2hpbGUgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZTtcbiAgICAgIGlmIChJR05PUkVfVVJMU19JTi5jb250YWlucyhub2RlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcImJvZHlcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gX3BhcnNlTm9kZShlbGVtZW50KSB7XG4gICAgaWYgKElHTk9SRV9VUkxTX0lOLmNvbnRhaW5zKGVsZW1lbnQubm9kZU5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSB3eXNpaHRtbDUuVEVYVF9OT0RFICYmIGVsZW1lbnQuZGF0YS5tYXRjaChVUkxfUkVHX0VYUCkpIHtcbiAgICAgIF93cmFwTWF0Y2hlc0luTm9kZShlbGVtZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdmFyIGNoaWxkTm9kZXMgICAgICAgID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoZWxlbWVudC5jaGlsZE5vZGVzKS5nZXQoKSxcbiAgICAgICAgY2hpbGROb2Rlc0xlbmd0aCAgPSBjaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgICAgaSAgICAgICAgICAgICAgICAgPSAwO1xuICAgIFxuICAgIGZvciAoOyBpPGNoaWxkTm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgX3BhcnNlTm9kZShjaGlsZE5vZGVzW2ldKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgXG4gIHd5c2lodG1sNS5kb20uYXV0b0xpbmsgPSBhdXRvTGluaztcbiAgXG4gIC8vIFJldmVhbCB1cmwgcmVnIGV4cCB0byB0aGUgb3V0c2lkZVxuICB3eXNpaHRtbDUuZG9tLmF1dG9MaW5rLlVSTF9SRUdfRVhQID0gVVJMX1JFR19FWFA7XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIHN1cHBvcnRzQ2xhc3NMaXN0ID0gd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNDbGFzc0xpc3QoKSxcbiAgICAgIGFwaSAgICAgICAgICAgICAgID0gd3lzaWh0bWw1LmRvbTtcbiAgXG4gIGFwaS5hZGRDbGFzcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChzdXBwb3J0c0NsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgIH1cbiAgICBpZiAoYXBpLmhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlbWVudC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gIH07XG4gIFxuICBhcGkucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBpZiAoc3VwcG9ydHNDbGFzc0xpc3QpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgXG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoXnxcXFxccyspXCIgKyBjbGFzc05hbWUgKyBcIihcXFxccyt8JClcIiksIFwiIFwiKTtcbiAgfTtcbiAgXG4gIGFwaS5oYXNDbGFzcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChzdXBwb3J0c0NsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIFxuICAgIHZhciBlbGVtZW50Q2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWU7XG4gICAgcmV0dXJuIChlbGVtZW50Q2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgKGVsZW1lbnRDbGFzc05hbWUgPT0gY2xhc3NOYW1lIHx8IG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGNsYXNzTmFtZSArIFwiKFxcXFxzfCQpXCIpLnRlc3QoZWxlbWVudENsYXNzTmFtZSkpKTtcbiAgfTtcbn0pKHd5c2lodG1sNSk7XG53eXNpaHRtbDUuZG9tLmNvbnRhaW5zID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBpZiAoZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRhaW5lciwgZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IHd5c2lodG1sNS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXIgIT09IGVsZW1lbnQgJiYgY29udGFpbmVyLmNvbnRhaW5zKGVsZW1lbnQpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRhaW5lciwgZWxlbWVudCkge1xuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL05vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb25cbiAgICAgIHJldHVybiAhIShjb250YWluZXIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudCkgJiAxNik7XG4gICAgfTtcbiAgfVxufSkoKTsvKipcbiAqIENvbnZlcnRzIGFuIEhUTUwgZnJhZ21lbnQvZWxlbWVudCBpbnRvIGEgdW5vcmRlcmVkL29yZGVyZWQgbGlzdFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3aGljaCBzaG91bGQgYmUgdHVybmVkIGludG8gYSBsaXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gbGlzdFR5cGUgVGhlIGxpc3QgdHlwZSBpbiB3aGljaCB0byBjb252ZXJ0IHRoZSB0cmVlIChlaXRoZXIgXCJ1bFwiIG9yIFwib2xcIilcbiAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSBjcmVhdGVkIGxpc3RcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgPCEtLSBBc3N1bWUgdGhlIGZvbGxvd2luZyBkb206IC0tPlxuICogICAgPHNwYW4gaWQ9XCJwc2V1ZG8tbGlzdFwiPlxuICogICAgICBlbWluZW08YnI+XG4gKiAgICAgIGRyLiBkcmVcbiAqICAgICAgPGRpdj41MCBDZW50PC9kaXY+XG4gKiAgICA8L3NwYW4+XG4gKlxuICogICAgPHNjcmlwdD5cbiAqICAgICAgd3lzaWh0bWw1LmRvbS5jb252ZXJ0VG9MaXN0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHNldWRvLWxpc3RcIiksIFwidWxcIik7XG4gKiAgICA8L3NjcmlwdD5cbiAqXG4gKiAgICA8IS0tIFdpbGwgcmVzdWx0IGluOiAtLT5cbiAqICAgIDx1bD5cbiAqICAgICAgPGxpPmVtaW5lbTwvbGk+XG4gKiAgICAgIDxsaT5kci4gZHJlPC9saT5cbiAqICAgICAgPGxpPjUwIENlbnQ8L2xpPlxuICogICAgPC91bD5cbiAqL1xud3lzaWh0bWw1LmRvbS5jb252ZXJ0VG9MaXN0ID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBfY3JlYXRlTGlzdEl0ZW0oZG9jLCBsaXN0KSB7XG4gICAgdmFyIGxpc3RJdGVtID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICBsaXN0LmFwcGVuZENoaWxkKGxpc3RJdGVtKTtcbiAgICByZXR1cm4gbGlzdEl0ZW07XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIF9jcmVhdGVMaXN0KGRvYywgdHlwZSkge1xuICAgIHJldHVybiBkb2MuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gY29udmVydFRvTGlzdChlbGVtZW50LCBsaXN0VHlwZSkge1xuICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSBcIlVMXCIgfHwgZWxlbWVudC5ub2RlTmFtZSA9PT0gXCJPTFwiIHx8IGVsZW1lbnQubm9kZU5hbWUgPT09IFwiTUVOVVwiKSB7XG4gICAgICAvLyBBbHJlYWR5IGEgbGlzdFxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIFxuICAgIHZhciBkb2MgICAgICAgICAgICAgICA9IGVsZW1lbnQub3duZXJEb2N1bWVudCxcbiAgICAgICAgbGlzdCAgICAgICAgICAgICAgPSBfY3JlYXRlTGlzdChkb2MsIGxpc3RUeXBlKSxcbiAgICAgICAgbGluZUJyZWFrcyAgICAgICAgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJiclwiKSxcbiAgICAgICAgbGluZUJyZWFrc0xlbmd0aCAgPSBsaW5lQnJlYWtzLmxlbmd0aCxcbiAgICAgICAgY2hpbGROb2RlcyxcbiAgICAgICAgY2hpbGROb2Rlc0xlbmd0aCxcbiAgICAgICAgY2hpbGROb2RlLFxuICAgICAgICBsaW5lQnJlYWssXG4gICAgICAgIHBhcmVudE5vZGUsXG4gICAgICAgIGlzQmxvY2tFbGVtZW50LFxuICAgICAgICBpc0xpbmVCcmVhayxcbiAgICAgICAgY3VycmVudExpc3RJdGVtLFxuICAgICAgICBpO1xuICAgIFxuICAgIC8vIEZpcnN0IGZpbmQgPGJyPiBhdCB0aGUgZW5kIG9mIGlubGluZSBlbGVtZW50cyBhbmQgbW92ZSB0aGVtIGJlaGluZCB0aGVtXG4gICAgZm9yIChpPTA7IGk8bGluZUJyZWFrc0xlbmd0aDsgaSsrKSB7XG4gICAgICBsaW5lQnJlYWsgPSBsaW5lQnJlYWtzW2ldO1xuICAgICAgd2hpbGUgKChwYXJlbnROb2RlID0gbGluZUJyZWFrLnBhcmVudE5vZGUpICYmIHBhcmVudE5vZGUgIT09IGVsZW1lbnQgJiYgcGFyZW50Tm9kZS5sYXN0Q2hpbGQgPT09IGxpbmVCcmVhaykge1xuICAgICAgICBpZiAod3lzaWh0bWw1LmRvbS5nZXRTdHlsZShcImRpc3BsYXlcIikuZnJvbShwYXJlbnROb2RlKSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5lQnJlYWspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHd5c2lodG1sNS5kb20uaW5zZXJ0KGxpbmVCcmVhaykuYWZ0ZXIobGluZUJyZWFrLnBhcmVudE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjaGlsZE5vZGVzICAgICAgICA9IHd5c2lodG1sNS5sYW5nLmFycmF5KGVsZW1lbnQuY2hpbGROb2RlcykuZ2V0KCk7XG4gICAgY2hpbGROb2Rlc0xlbmd0aCAgPSBjaGlsZE5vZGVzLmxlbmd0aDtcbiAgICBcbiAgICBmb3IgKGk9MDsgaTxjaGlsZE5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1cnJlbnRMaXN0SXRlbSAgID0gY3VycmVudExpc3RJdGVtIHx8IF9jcmVhdGVMaXN0SXRlbShkb2MsIGxpc3QpO1xuICAgICAgY2hpbGROb2RlICAgICAgICAgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgaXNCbG9ja0VsZW1lbnQgICAgPSB3eXNpaHRtbDUuZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKGNoaWxkTm9kZSkgPT09IFwiYmxvY2tcIjtcbiAgICAgIGlzTGluZUJyZWFrICAgICAgID0gY2hpbGROb2RlLm5vZGVOYW1lID09PSBcIkJSXCI7XG4gICAgICBcbiAgICAgIGlmIChpc0Jsb2NrRWxlbWVudCkge1xuICAgICAgICAvLyBBcHBlbmQgYmxvY2tFbGVtZW50IHRvIGN1cnJlbnQgPGxpPiBpZiBlbXB0eSwgb3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgY3VycmVudExpc3RJdGVtID0gY3VycmVudExpc3RJdGVtLmZpcnN0Q2hpbGQgPyBfY3JlYXRlTGlzdEl0ZW0oZG9jLCBsaXN0KSA6IGN1cnJlbnRMaXN0SXRlbTtcbiAgICAgICAgY3VycmVudExpc3RJdGVtLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgICAgIGN1cnJlbnRMaXN0SXRlbSA9IG51bGw7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoaXNMaW5lQnJlYWspIHtcbiAgICAgICAgLy8gT25seSBjcmVhdGUgYSBuZXcgbGlzdCBpdGVtIGluIHRoZSBuZXh0IGl0ZXJhdGlvbiB3aGVuIHRoZSBjdXJyZW50IG9uZSBoYXMgYWxyZWFkeSBjb250ZW50XG4gICAgICAgIGN1cnJlbnRMaXN0SXRlbSA9IGN1cnJlbnRMaXN0SXRlbS5maXJzdENoaWxkID8gbnVsbCA6IGN1cnJlbnRMaXN0SXRlbTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGN1cnJlbnRMaXN0SXRlbS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgIH1cbiAgICBcbiAgICBlbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGxpc3QsIGVsZW1lbnQpO1xuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIFxuICByZXR1cm4gY29udmVydFRvTGlzdDtcbn0pKCk7LyoqXG4gKiBDb3B5IGEgc2V0IG9mIGF0dHJpYnV0ZXMgZnJvbSBvbmUgZWxlbWVudCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXR0cmlidXRlc1RvQ29weSBMaXN0IG9mIGF0dHJpYnV0ZXMgd2hpY2ggc2hvdWxkIGJlIGNvcGllZFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aGljaCBvZmZlcnMgdGhlIFwiZnJvbVwiIG1ldGhvZCB3aGljaCBjYW4gYmUgaW52b2tlZCB3aXRoIHRoZSBlbGVtZW50IHdoZXJlIHRvXG4gKiAgICBjb3B5IHRoZSBhdHRyaWJ1dGVzIGZyb20uLCB0aGlzIGFnYWluIHJldHVybnMgYW4gb2JqZWN0IHdoaWNoIHByb3ZpZGVzIGEgbWV0aG9kIG5hbWVkIFwidG9cIiB3aGljaCBjYW4gYmUgaW52b2tlZCBcbiAqICAgIHdpdGggdGhlIGVsZW1lbnQgd2hlcmUgdG8gY29weSB0aGUgYXR0cmlidXRlcyB0byAoc2VlIGV4YW1wbGUpXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIHZhciB0ZXh0YXJlYSAgICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0YXJlYVwiKSxcbiAqICAgICAgICBkaXYgICAgICAgICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJkaXZbY29udGVudGVkaXRhYmxlPXRydWVdXCIpLFxuICogICAgICAgIGFub3RoZXJEaXYgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImRpdi5wcmV2aWV3XCIpO1xuICogICAgd3lzaWh0bWw1LmRvbS5jb3B5QXR0cmlidXRlcyhbXCJzcGVsbGNoZWNrXCIsIFwidmFsdWVcIiwgXCJwbGFjZWhvbGRlclwiXSkuZnJvbSh0ZXh0YXJlYSkudG8oZGl2KS5hbmRUbyhhbm90aGVyRGl2KTtcbiAqXG4gKi9cbnd5c2lodG1sNS5kb20uY29weUF0dHJpYnV0ZXMgPSBmdW5jdGlvbihhdHRyaWJ1dGVzVG9Db3B5KSB7XG4gIHJldHVybiB7XG4gICAgZnJvbTogZnVuY3Rpb24oZWxlbWVudFRvQ29weUZyb20pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvOiBmdW5jdGlvbihlbGVtZW50VG9Db3B5VG8pIHtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlLFxuICAgICAgICAgICAgICBpICAgICAgICAgPSAwLFxuICAgICAgICAgICAgICBsZW5ndGggICAgPSBhdHRyaWJ1dGVzVG9Db3B5Lmxlbmd0aDtcbiAgICAgICAgICBmb3IgKDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1RvQ29weVtpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoZWxlbWVudFRvQ29weUZyb21bYXR0cmlidXRlXSkgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbWVudFRvQ29weUZyb21bYXR0cmlidXRlXSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICBlbGVtZW50VG9Db3B5VG9bYXR0cmlidXRlXSA9IGVsZW1lbnRUb0NvcHlGcm9tW2F0dHJpYnV0ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IGFuZFRvOiBhcmd1bWVudHMuY2FsbGVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTsvKipcbiAqIENvcHkgYSBzZXQgb2Ygc3R5bGVzIGZyb20gb25lIGVsZW1lbnQgdG8gYW5vdGhlclxuICogUGxlYXNlIG5vdGUgdGhhdCB0aGlzIG9ubHkgd29ya3MgcHJvcGVybHkgYWNyb3NzIGJyb3dzZXJzIHdoZW4gdGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBjb3B5IHRoZSBzdHlsZXNcbiAqIGlzIGluIHRoZSBkb21cbiAqXG4gKiBJbnRlcmVzdGluZyBhcnRpY2xlIG9uIGhvdyB0byBjb3B5IHN0eWxlc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHN0eWxlc1RvQ29weSBMaXN0IG9mIHN0eWxlcyB3aGljaCBzaG91bGQgYmUgY29waWVkXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIG9mZmVycyB0aGUgXCJmcm9tXCIgbWV0aG9kIHdoaWNoIGNhbiBiZSBpbnZva2VkIHdpdGggdGhlIGVsZW1lbnQgd2hlcmUgdG9cbiAqICAgIGNvcHkgdGhlIHN0eWxlcyBmcm9tLiwgdGhpcyBhZ2FpbiByZXR1cm5zIGFuIG9iamVjdCB3aGljaCBwcm92aWRlcyBhIG1ldGhvZCBuYW1lZCBcInRvXCIgd2hpY2ggY2FuIGJlIGludm9rZWQgXG4gKiAgICB3aXRoIHRoZSBlbGVtZW50IHdoZXJlIHRvIGNvcHkgdGhlIHN0eWxlcyB0byAoc2VlIGV4YW1wbGUpXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIHZhciB0ZXh0YXJlYSAgICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0YXJlYVwiKSxcbiAqICAgICAgICBkaXYgICAgICAgICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJkaXZbY29udGVudGVkaXRhYmxlPXRydWVdXCIpLFxuICogICAgICAgIGFub3RoZXJEaXYgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImRpdi5wcmV2aWV3XCIpO1xuICogICAgd3lzaWh0bWw1LmRvbS5jb3B5U3R5bGVzKFtcIm92ZXJmbG93LXlcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXSkuZnJvbSh0ZXh0YXJlYSkudG8oZGl2KS5hbmRUbyhhbm90aGVyRGl2KTtcbiAqXG4gKi9cbihmdW5jdGlvbihkb20pIHtcbiAgXG4gIC8qKlxuICAgKiBNb3ppbGxhLCBXZWJLaXQgYW5kIE9wZXJhIHJlY2FsY3VsYXRlIHRoZSBjb21wdXRlZCB3aWR0aCB3aGVuIGJveC1zaXppbmc6IGJvZGVyLWJveDsgaXMgc2V0XG4gICAqIFNvIGlmIGFuIGVsZW1lbnQgaGFzIFwid2lkdGg6IDIwMHB4OyAtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7IGJvcmRlcjogMXB4O1wiIHRoZW4gXG4gICAqIGl0cyBjb21wdXRlZCBjc3Mgd2lkdGggd2lsbCBiZSAxOThweFxuICAgKi9cbiAgdmFyIEJPWF9TSVpJTkdfUFJPUEVSVElFUyA9IFtcIi13ZWJraXQtYm94LXNpemluZ1wiLCBcIi1tb3otYm94LXNpemluZ1wiLCBcIi1tcy1ib3gtc2l6aW5nXCIsIFwiYm94LXNpemluZ1wiXTtcbiAgXG4gIHZhciBzaG91bGRJZ25vcmVCb3hTaXppbmdCb3JkZXJCb3ggPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKGhhc0JveFNpemluZ0JvcmRlckJveChlbGVtZW50KSkge1xuICAgICAgIHJldHVybiBwYXJzZUludChkb20uZ2V0U3R5bGUoXCJ3aWR0aFwiKS5mcm9tKGVsZW1lbnQpLCAxMCkgPCBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIFxuICB2YXIgaGFzQm94U2l6aW5nQm9yZGVyQm94ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHZhciBpICAgICAgID0gMCxcbiAgICAgICAgbGVuZ3RoICA9IEJPWF9TSVpJTkdfUFJPUEVSVElFUy5sZW5ndGg7XG4gICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChkb20uZ2V0U3R5bGUoQk9YX1NJWklOR19QUk9QRVJUSUVTW2ldKS5mcm9tKGVsZW1lbnQpID09PSBcImJvcmRlci1ib3hcIikge1xuICAgICAgICByZXR1cm4gQk9YX1NJWklOR19QUk9QRVJUSUVTW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgXG4gIGRvbS5jb3B5U3R5bGVzID0gZnVuY3Rpb24oc3R5bGVzVG9Db3B5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb206IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUJveFNpemluZ0JvcmRlckJveChlbGVtZW50KSkge1xuICAgICAgICAgIHN0eWxlc1RvQ29weSA9IHd5c2lodG1sNS5sYW5nLmFycmF5KHN0eWxlc1RvQ29weSkud2l0aG91dChCT1hfU0laSU5HX1BST1BFUlRJRVMpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgY3NzVGV4dCA9IFwiXCIsXG4gICAgICAgICAgICBsZW5ndGggID0gc3R5bGVzVG9Db3B5Lmxlbmd0aCxcbiAgICAgICAgICAgIGkgICAgICAgPSAwLFxuICAgICAgICAgICAgcHJvcGVydHk7XG4gICAgICAgIGZvciAoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBzdHlsZXNUb0NvcHlbaV07XG4gICAgICAgICAgY3NzVGV4dCArPSBwcm9wZXJ0eSArIFwiOlwiICsgZG9tLmdldFN0eWxlKHByb3BlcnR5KS5mcm9tKGVsZW1lbnQpICsgXCI7XCI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG86IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZXMoY3NzVGV4dCkub24oZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4geyBhbmRUbzogYXJndW1lbnRzLmNhbGxlZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufSkod3lzaWh0bWw1LmRvbSk7LyoqXG4gKiBFdmVudCBEZWxlZ2F0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIHd5c2lodG1sNS5kb20uZGVsZWdhdGUoZG9jdW1lbnQuYm9keSwgXCJhXCIsIFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gKiAgICAgIC8vIGZvb1xuICogICAgfSk7XG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgXG4gIHd5c2lodG1sNS5kb20uZGVsZWdhdGUgPSBmdW5jdGlvbihjb250YWluZXIsIHNlbGVjdG9yLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gd3lzaWh0bWw1LmRvbS5vYnNlcnZlKGNvbnRhaW5lciwgZXZlbnROYW1lLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIHRhcmdldCAgICA9IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICBtYXRjaCAgICAgPSB3eXNpaHRtbDUubGFuZy5hcnJheShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgICAgXG4gICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChtYXRjaC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBcbn0pKHd5c2lodG1sNSk7LyoqXG4gKiBSZXR1cm5zIHRoZSBnaXZlbiBodG1sIHdyYXBwZWQgaW4gYSBkaXYgZWxlbWVudFxuICpcbiAqIEZpeGluZyBJRSdzIGluYWJpbGl0eSB0byB0cmVhdCB1bmtub3duIGVsZW1lbnRzIChIVE1MNSBzZWN0aW9uLCBhcnRpY2xlLCAuLi4pIGNvcnJlY3RseVxuICogd2hlbiBpbnNlcnRlZCB2aWEgaW5uZXJIVE1MXG4gKiBcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIFRoZSBodG1sIHdoaWNoIHNob3VsZCBiZSB3cmFwcGVkIGluIGEgZG9tIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JlamN0fSBbY29udGV4dF0gRG9jdW1lbnQgb2JqZWN0IG9mIHRoZSBjb250ZXh0IHRoZSBodG1sIGJlbG9uZ3MgdG9cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgd3lzaWh0bWw1LmRvbS5nZXRBc0RvbShcIjxhcnRpY2xlPmZvbzwvYXJ0aWNsZT5cIik7XG4gKi9cbnd5c2lodG1sNS5kb20uZ2V0QXNEb20gPSAoZnVuY3Rpb24oKSB7XG4gIFxuICB2YXIgX2lubmVySFRNTFNoaXYgPSBmdW5jdGlvbihodG1sLCBjb250ZXh0KSB7XG4gICAgdmFyIHRlbXBFbGVtZW50ID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRlbXBFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBjb250ZXh0LmJvZHkuYXBwZW5kQ2hpbGQodGVtcEVsZW1lbnQpO1xuICAgIC8vIElFIHRocm93cyBhbiBleGNlcHRpb24gd2hlbiB0cnlpbmcgdG8gaW5zZXJ0IDxmcmFtZXNldD48L2ZyYW1lc2V0PiB2aWEgaW5uZXJIVE1MXG4gICAgdHJ5IHsgdGVtcEVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDsgfSBjYXRjaChlKSB7fVxuICAgIGNvbnRleHQuYm9keS5yZW1vdmVDaGlsZCh0ZW1wRWxlbWVudCk7XG4gICAgcmV0dXJuIHRlbXBFbGVtZW50O1xuICB9O1xuICBcbiAgLyoqXG4gICAqIE1ha2Ugc3VyZSBJRSBzdXBwb3J0cyBIVE1MNSB0YWdzLCB3aGljaCBpcyBhY2NvbXBsaXNoZWQgYnkgc2ltcGx5IGNyZWF0aW5nIG9uZSBpbnN0YW5jZSBvZiBlYWNoIGVsZW1lbnRcbiAgICovXG4gIHZhciBfZW5zdXJlSFRNTDVDb21wYXRpYmlsaXR5ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0Ll93eXNpaHRtbDVfc3VwcG9ydHNIVE1MNVRhZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaT0wLCBsZW5ndGg9SFRNTDVfRUxFTUVOVFMubGVuZ3RoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoSFRNTDVfRUxFTUVOVFNbaV0pO1xuICAgIH1cbiAgICBjb250ZXh0Ll93eXNpaHRtbDVfc3VwcG9ydHNIVE1MNVRhZ3MgPSB0cnVlO1xuICB9O1xuICBcbiAgXG4gIC8qKlxuICAgKiBMaXN0IG9mIGh0bWw1IHRhZ3NcbiAgICogdGFrZW4gZnJvbSBodHRwOi8vc2ltb24uaHRtbDUub3JnL2h0bWw1LWVsZW1lbnRzXG4gICAqL1xuICB2YXIgSFRNTDVfRUxFTUVOVFMgPSBbXG4gICAgXCJhYmJyXCIsIFwiYXJ0aWNsZVwiLCBcImFzaWRlXCIsIFwiYXVkaW9cIiwgXCJiZGlcIiwgXCJjYW52YXNcIiwgXCJjb21tYW5kXCIsIFwiZGF0YWxpc3RcIiwgXCJkZXRhaWxzXCIsIFwiZmlnY2FwdGlvblwiLFxuICAgIFwiZmlndXJlXCIsIFwiZm9vdGVyXCIsIFwiaGVhZGVyXCIsIFwiaGdyb3VwXCIsIFwia2V5Z2VuXCIsIFwibWFya1wiLCBcIm1ldGVyXCIsIFwibmF2XCIsIFwib3V0cHV0XCIsIFwicHJvZ3Jlc3NcIixcbiAgICBcInJwXCIsIFwicnRcIiwgXCJydWJ5XCIsIFwic3ZnXCIsIFwic2VjdGlvblwiLCBcInNvdXJjZVwiLCBcInN1bW1hcnlcIiwgXCJ0aW1lXCIsIFwidHJhY2tcIiwgXCJ2aWRlb1wiLCBcIndiclwiXG4gIF07XG4gIFxuICByZXR1cm4gZnVuY3Rpb24oaHRtbCwgY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuICAgIHZhciB0ZW1wRWxlbWVudDtcbiAgICBpZiAodHlwZW9mKGh0bWwpID09PSBcIm9iamVjdFwiICYmIGh0bWwubm9kZVR5cGUpIHtcbiAgICAgIHRlbXBFbGVtZW50ID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGVtcEVsZW1lbnQuYXBwZW5kQ2hpbGQoaHRtbCk7XG4gICAgfSBlbHNlIGlmICh3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c0hUTUw1VGFncyhjb250ZXh0KSkge1xuICAgICAgdGVtcEVsZW1lbnQgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0gZWxzZSB7XG4gICAgICBfZW5zdXJlSFRNTDVDb21wYXRpYmlsaXR5KGNvbnRleHQpO1xuICAgICAgdGVtcEVsZW1lbnQgPSBfaW5uZXJIVE1MU2hpdihodG1sLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBFbGVtZW50O1xuICB9O1xufSkoKTsvKipcbiAqIFdhbGtzIHRoZSBkb20gdHJlZSBmcm9tIHRoZSBnaXZlbiBub2RlIHVwIHVudGlsIGl0IGZpbmRzIGEgbWF0Y2hcbiAqIERlc2lnbmVkIGZvciBvcHRpbWFsIHBlcmZvcm1hbmNlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBUaGUgZnJvbSB3aGljaCB0byBjaGVjayB0aGUgcGFyZW50IG5vZGVzXG4gKiBAcGFyYW0ge09iamVjdH0gbWF0Y2hpbmdTZXQgT2JqZWN0IHRvIG1hdGNoIGFnYWluc3QgKHBvc3NpYmxlIHByb3BlcnRpZXM6IG5vZGVOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKVxuICogQHBhcmFtIHtOdW1iZXJ9IFtsZXZlbHNdIEhvdyBtYW55IHBhcmVudHMgc2hvdWxkIHRoZSBmdW5jdGlvbiBjaGVjayB1cCBmcm9tIHRoZSBjdXJyZW50IG5vZGUgKGRlZmF1bHRzIHRvIDUwKVxuICogQHJldHVybiB7bnVsbHxFbGVtZW50fSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWF0Y2hlZCB0aGUgZGVzaXJlZE5vZGVOYW1lKHMpXG4gKiBAZXhhbXBsZVxuICogICAgdmFyIGxpc3RFbGVtZW50ID0gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJsaVwiKSwgeyBub2RlTmFtZTogW1wiTUVOVVwiLCBcIlVMXCIsIFwiT0xcIl0gfSk7XG4gKiAgICAvLyAuLi4gb3IgLi4uXG4gKiAgICB2YXIgdW5vcmRlcmVkTGlzdEVsZW1lbnQgPSB3eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImxpXCIpLCB7IG5vZGVOYW1lOiBcIlVMXCIgfSk7XG4gKiAgICAvLyAuLi4gb3IgLi4uXG4gKiAgICB2YXIgY29sb3JlZEVsZW1lbnQgPSB3eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQobXlUZXh0Tm9kZSwgeyBub2RlTmFtZTogXCJTUEFOXCIsIGNsYXNzTmFtZTogXCJ3eXNpd3lnLWNvbG9yLXJlZFwiLCBjbGFzc1JlZ0V4cDogL3d5c2l3eWctY29sb3ItW2Etel0vZyB9KTtcbiAqL1xud3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50ID0gKGZ1bmN0aW9uKCkge1xuICBcbiAgZnVuY3Rpb24gX2lzU2FtZU5vZGVOYW1lKG5vZGVOYW1lLCBkZXNpcmVkTm9kZU5hbWVzKSB7XG4gICAgaWYgKCFkZXNpcmVkTm9kZU5hbWVzIHx8ICFkZXNpcmVkTm9kZU5hbWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh0eXBlb2YoZGVzaXJlZE5vZGVOYW1lcykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBub2RlTmFtZSA9PT0gZGVzaXJlZE5vZGVOYW1lcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5sYW5nLmFycmF5KGRlc2lyZWROb2RlTmFtZXMpLmNvbnRhaW5zKG5vZGVOYW1lKTtcbiAgICB9XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIF9pc0VsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSB3eXNpaHRtbDUuRUxFTUVOVF9OT0RFO1xuICB9XG4gIFxuICBmdW5jdGlvbiBfaGFzQ2xhc3NOYW1lKGVsZW1lbnQsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IChlbGVtZW50LmNsYXNzTmFtZSB8fCBcIlwiKS5tYXRjaChjbGFzc1JlZ0V4cCkgfHwgW107XG4gICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiAhIWNsYXNzTmFtZXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lc1tjbGFzc05hbWVzLmxlbmd0aCAtIDFdID09PSBjbGFzc05hbWU7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIF9nZXRQYXJlbnRFbGVtZW50V2l0aE5vZGVOYW1lKG5vZGUsIG5vZGVOYW1lLCBsZXZlbHMpIHtcbiAgICB3aGlsZSAobGV2ZWxzLS0gJiYgbm9kZSAmJiBub2RlLm5vZGVOYW1lICE9PSBcIkJPRFlcIikge1xuICAgICAgaWYgKF9pc1NhbWVOb2RlTmFtZShub2RlLm5vZGVOYW1lLCBub2RlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBcbiAgZnVuY3Rpb24gX2dldFBhcmVudEVsZW1lbnRXaXRoTm9kZU5hbWVBbmRDbGFzc05hbWUobm9kZSwgbm9kZU5hbWUsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHAsIGxldmVscykge1xuICAgIHdoaWxlIChsZXZlbHMtLSAmJiBub2RlICYmIG5vZGUubm9kZU5hbWUgIT09IFwiQk9EWVwiKSB7XG4gICAgICBpZiAoX2lzRWxlbWVudChub2RlKSAmJlxuICAgICAgICAgIF9pc1NhbWVOb2RlTmFtZShub2RlLm5vZGVOYW1lLCBub2RlTmFtZSkgJiZcbiAgICAgICAgICBfaGFzQ2xhc3NOYW1lKG5vZGUsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgXG4gIHJldHVybiBmdW5jdGlvbihub2RlLCBtYXRjaGluZ1NldCwgbGV2ZWxzKSB7XG4gICAgbGV2ZWxzID0gbGV2ZWxzIHx8IDUwOyAvLyBHbyBtYXggNTAgbm9kZXMgdXB3YXJkcyBmcm9tIGN1cnJlbnQgbm9kZVxuICAgIGlmIChtYXRjaGluZ1NldC5jbGFzc05hbWUgfHwgbWF0Y2hpbmdTZXQuY2xhc3NSZWdFeHApIHtcbiAgICAgIHJldHVybiBfZ2V0UGFyZW50RWxlbWVudFdpdGhOb2RlTmFtZUFuZENsYXNzTmFtZShcbiAgICAgICAgbm9kZSwgbWF0Y2hpbmdTZXQubm9kZU5hbWUsIG1hdGNoaW5nU2V0LmNsYXNzTmFtZSwgbWF0Y2hpbmdTZXQuY2xhc3NSZWdFeHAsIGxldmVsc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9nZXRQYXJlbnRFbGVtZW50V2l0aE5vZGVOYW1lKFxuICAgICAgICBub2RlLCBtYXRjaGluZ1NldC5ub2RlTmFtZSwgbGV2ZWxzXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn0pKCk7XG4vKipcbiAqIEdldCBlbGVtZW50J3Mgc3R5bGUgZm9yIGEgc3BlY2lmaWMgY3NzIHByb3BlcnR5XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IG9uIHdoaWNoIHRvIHJldHJpZXZlIHRoZSBzdHlsZVxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFRoZSBDU1MgcHJvcGVydHkgdG8gcmV0cmlldmUgKFwiZmxvYXRcIiwgXCJkaXNwbGF5XCIsIFwidGV4dC1hbGlnblwiLCAuLi4pXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIHd5c2lodG1sNS5kb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20oZG9jdW1lbnQuYm9keSk7XG4gKiAgICAvLyA9PiBcImJsb2NrXCJcbiAqL1xud3lzaWh0bWw1LmRvbS5nZXRTdHlsZSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlUHJvcGVydHlNYXBwaW5nID0ge1xuICAgICAgICBcImZsb2F0XCI6IChcInN0eWxlRmxvYXRcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlKSA/IFwic3R5bGVGbG9hdFwiIDogXCJjc3NGbG9hdFwiXG4gICAgICB9LFxuICAgICAgUkVHX0VYUF9DQU1FTElaRSA9IC9cXC1bYS16XS9nO1xuICBcbiAgZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFR19FWFBfQ0FNRUxJWkUsIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2guY2hhckF0KDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cbiAgXG4gIHJldHVybiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSB3eXNpaHRtbDUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgZG9jICAgICAgICAgICAgICAgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICBjYW1lbGl6ZWRQcm9wZXJ0eSA9IHN0eWxlUHJvcGVydHlNYXBwaW5nW3Byb3BlcnR5XSB8fCBjYW1lbGl6ZShwcm9wZXJ0eSksXG4gICAgICAgICAgICBzdHlsZSAgICAgICAgICAgICA9IGVsZW1lbnQuc3R5bGUsXG4gICAgICAgICAgICBjdXJyZW50U3R5bGUgICAgICA9IGVsZW1lbnQuY3VycmVudFN0eWxlLFxuICAgICAgICAgICAgc3R5bGVWYWx1ZSAgICAgICAgPSBzdHlsZVtjYW1lbGl6ZWRQcm9wZXJ0eV07XG4gICAgICAgIGlmIChzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGN1cnJlbnRTdHlsZSBpcyBubyBzdGFuZGFyZCBhbmQgb25seSBzdXBwb3J0ZWQgYnkgT3BlcmEgYW5kIElFIGJ1dCBpdCBoYXMgb25lIGltcG9ydGFudCBhZHZhbnRhZ2Ugb3ZlciB0aGUgc3RhbmRhcmQtY29tcGxpYW50XG4gICAgICAgIC8vIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlLCBzaW5jZSBpdCByZXR1cm5zIGNzcyBwcm9wZXJ0eSB2YWx1ZXMgaW4gdGhlaXIgb3JpZ2luYWwgdW5pdDpcbiAgICAgICAgLy8gSWYgeW91IHNldCBhbiBlbGVtZW50cyB3aWR0aCB0byBcIjUwJVwiLCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSB3aWxsIGdpdmUgeW91IGl0J3MgY3VycmVudCB3aWR0aCBpbiBweCB3aGlsZSBjdXJyZW50U3R5bGVcbiAgICAgICAgLy8gZ2l2ZXMgeW91IHRoZSBvcmlnaW5hbCBcIjUwJVwiLlxuICAgICAgICAvLyBPcGVyYSBzdXBwb3J0cyBib3RoLCBjdXJyZW50U3R5bGUgYW5kIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlLCB0aGF0J3Mgd2h5IGNoZWNraW5nIGZvciBjdXJyZW50U3R5bGUgc2hvdWxkIGhhdmUgaGlnaGVyIHByaW9cbiAgICAgICAgaWYgKGN1cnJlbnRTdHlsZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTdHlsZVtjYW1lbGl6ZWRQcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvL2llIHdpbGwgb2NjYXNpb25hbGx5IGZhaWwgZm9yIHVua25vd24gcmVhc29ucy4gc3dhbGxvd2luZyBleGNlcHRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2luICAgICAgICAgICAgICAgICA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93LFxuICAgICAgICAgICAgbmVlZHNPdmVyZmxvd1Jlc2V0ICA9IChwcm9wZXJ0eSA9PT0gXCJoZWlnaHRcIiB8fCBwcm9wZXJ0eSA9PT0gXCJ3aWR0aFwiKSAmJiBlbGVtZW50Lm5vZGVOYW1lID09PSBcIlRFWFRBUkVBXCIsXG4gICAgICAgICAgICBvcmlnaW5hbE92ZXJmbG93LFxuICAgICAgICAgICAgcmV0dXJuVmFsdWU7XG5cbiAgICAgICAgaWYgKHdpbi5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgICAgLy8gQ2hyb21lIGFuZCBTYWZhcmkgYm90aCBjYWxjdWxhdGUgYSB3cm9uZyB3aWR0aCBhbmQgaGVpZ2h0IGZvciB0ZXh0YXJlYXMgd2hlbiB0aGV5IGhhdmUgc2Nyb2xsIGJhcnNcbiAgICAgICAgICAvLyB0aGVyZm9yZSB3ZSByZW1vdmUgYW5kIHJlc3RvcmUgdGhlIHNjcm9sbGJhciBhbmQgY2FsY3VsYXRlIHRoZSB2YWx1ZSBpbiBiZXR3ZWVuXG4gICAgICAgICAgaWYgKG5lZWRzT3ZlcmZsb3dSZXNldCkge1xuICAgICAgICAgICAgb3JpZ2luYWxPdmVyZmxvdyA9IHN0eWxlLm92ZXJmbG93O1xuICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IHdpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuICAgICAgICAgIGlmIChuZWVkc092ZXJmbG93UmVzZXQpIHtcbiAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ID0gb3JpZ2luYWxPdmVyZmxvdyB8fCBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xufSkoKTsvKipcbiAqIEhpZ2ggcGVyZm9ybWFudCB3YXkgdG8gY2hlY2sgd2hldGhlciBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpYyB0YWcgbmFtZSBpcyBpbiB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAqIE9wdGltaXplZCBmb3IgYmVpbmcgaGVhdmlseSBleGVjdXRlZFxuICogVW5sZWFzaGVzIHRoZSBwb3dlciBvZiBsaXZlIG5vZGUgbGlzdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIFRoZSBkb2N1bWVudCBvYmplY3Qgb2YgdGhlIGNvbnRleHQgd2hlcmUgdG8gY2hlY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YWdOYW1lIFVwcGVyIGNhc2VkIHRhZyBuYW1lXG4gKiBAZXhhbXBsZVxuICogICAgd3lzaWh0bWw1LmRvbS5oYXNFbGVtZW50V2l0aFRhZ05hbWUoZG9jdW1lbnQsIFwiSU1HXCIpO1xuICovXG53eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoVGFnTmFtZSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIExJVkVfQ0FDSEUgICAgICAgICAgPSB7fSxcbiAgICAgIERPQ1VNRU5UX0lERU5USUZJRVIgPSAxO1xuICBcbiAgZnVuY3Rpb24gX2dldERvY3VtZW50SWRlbnRpZmllcihkb2MpIHtcbiAgICByZXR1cm4gZG9jLl93eXNpaHRtbDVfaWRlbnRpZmllciB8fCAoZG9jLl93eXNpaHRtbDVfaWRlbnRpZmllciA9IERPQ1VNRU5UX0lERU5USUZJRVIrKyk7XG4gIH1cbiAgXG4gIHJldHVybiBmdW5jdGlvbihkb2MsIHRhZ05hbWUpIHtcbiAgICB2YXIga2V5ICAgICAgICAgPSBfZ2V0RG9jdW1lbnRJZGVudGlmaWVyKGRvYykgKyBcIjpcIiArIHRhZ05hbWUsXG4gICAgICAgIGNhY2hlRW50cnkgID0gTElWRV9DQUNIRVtrZXldO1xuICAgIGlmICghY2FjaGVFbnRyeSkge1xuICAgICAgY2FjaGVFbnRyeSA9IExJVkVfQ0FDSEVba2V5XSA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNhY2hlRW50cnkubGVuZ3RoID4gMDtcbiAgfTtcbn0pKCk7LyoqXG4gKiBIaWdoIHBlcmZvcm1hbnQgd2F5IHRvIGNoZWNrIHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIGEgc3BlY2lmaWMgY2xhc3MgbmFtZSBpcyBpbiB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAqIE9wdGltaXplZCBmb3IgYmVpbmcgaGVhdmlseSBleGVjdXRlZFxuICogVW5sZWFzaGVzIHRoZSBwb3dlciBvZiBsaXZlIG5vZGUgbGlzdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIFRoZSBkb2N1bWVudCBvYmplY3Qgb2YgdGhlIGNvbnRleHQgd2hlcmUgdG8gY2hlY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSB0YWdOYW1lIFVwcGVyIGNhc2VkIHRhZyBuYW1lXG4gKiBAZXhhbXBsZVxuICogICAgd3lzaWh0bWw1LmRvbS5oYXNFbGVtZW50V2l0aENsYXNzTmFtZShkb2N1bWVudCwgXCJmb29iYXJcIik7XG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIExJVkVfQ0FDSEUgICAgICAgICAgPSB7fSxcbiAgICAgIERPQ1VNRU5UX0lERU5USUZJRVIgPSAxO1xuXG4gIGZ1bmN0aW9uIF9nZXREb2N1bWVudElkZW50aWZpZXIoZG9jKSB7XG4gICAgcmV0dXJuIGRvYy5fd3lzaWh0bWw1X2lkZW50aWZpZXIgfHwgKGRvYy5fd3lzaWh0bWw1X2lkZW50aWZpZXIgPSBET0NVTUVOVF9JREVOVElGSUVSKyspO1xuICB9XG4gIFxuICB3eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoQ2xhc3NOYW1lID0gZnVuY3Rpb24oZG9jLCBjbGFzc05hbWUpIHtcbiAgICAvLyBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUU8OVxuICAgIC8vIGJ1dCBpcyBzb21ldGltZXMgbW9ja2VkIHZpYSBsaWJyYXJ5IGNvZGUgKHdoaWNoIHRoZW4gZG9lc24ndCByZXR1cm4gbGl2ZSBub2RlIGxpc3RzKVxuICAgIGlmICghd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNOYXRpdmVHZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCkpIHtcbiAgICAgIHJldHVybiAhIWRvYy5xdWVyeVNlbGVjdG9yKFwiLlwiICsgY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICB2YXIga2V5ICAgICAgICAgPSBfZ2V0RG9jdW1lbnRJZGVudGlmaWVyKGRvYykgKyBcIjpcIiArIGNsYXNzTmFtZSxcbiAgICAgICAgY2FjaGVFbnRyeSAgPSBMSVZFX0NBQ0hFW2tleV07XG4gICAgaWYgKCFjYWNoZUVudHJ5KSB7XG4gICAgICBjYWNoZUVudHJ5ID0gTElWRV9DQUNIRVtrZXldID0gZG9jLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVFbnRyeS5sZW5ndGggPiAwO1xuICB9O1xufSkod3lzaWh0bWw1KTtcbnd5c2lodG1sNS5kb20uaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudFRvSW5zZXJ0KSB7XG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudFRvSW5zZXJ0LCBlbGVtZW50Lm5leHRTaWJsaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIGJlZm9yZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50VG9JbnNlcnQsIGVsZW1lbnQpO1xuICAgIH0sXG4gICAgXG4gICAgaW50bzogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50VG9JbnNlcnQpO1xuICAgIH1cbiAgfTtcbn07d3lzaWh0bWw1LmRvbS5pbnNlcnRDU1MgPSBmdW5jdGlvbihydWxlcykge1xuICBydWxlcyA9IHJ1bGVzLmpvaW4oXCJcXG5cIik7XG4gIFxuICByZXR1cm4ge1xuICAgIGludG86IGZ1bmN0aW9uKGRvYykge1xuICAgICAgdmFyIGhlYWQgICAgICAgICA9IGRvYy5oZWFkIHx8IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0sXG4gICAgICAgICAgc3R5bGVFbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuICAgICAgc3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XG5cbiAgICAgIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcnVsZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHJ1bGVzKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWFkKSB7XG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59Oy8qKlxuICogTWV0aG9kIHRvIHNldCBkb20gZXZlbnRzXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIHd5c2lodG1sNS5kb20ub2JzZXJ2ZShpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5ib2R5LCBbXCJmb2N1c1wiLCBcImJsdXJcIl0sIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gKi9cbnd5c2lodG1sNS5kb20ub2JzZXJ2ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50TmFtZXMsIGhhbmRsZXIpIHtcbiAgZXZlbnROYW1lcyA9IHR5cGVvZihldmVudE5hbWVzKSA9PT0gXCJzdHJpbmdcIiA/IFtldmVudE5hbWVzXSA6IGV2ZW50TmFtZXM7XG4gIFxuICB2YXIgaGFuZGxlcldyYXBwZXIsXG4gICAgICBldmVudE5hbWUsXG4gICAgICBpICAgICAgID0gMCxcbiAgICAgIGxlbmd0aCAgPSBldmVudE5hbWVzLmxlbmd0aDtcbiAgXG4gIGZvciAoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgZXZlbnROYW1lID0gZXZlbnROYW1lc1tpXTtcbiAgICBpZiAoZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXJXcmFwcGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCEoXCJ0YXJnZXRcIiBpbiBldmVudCkpIHtcbiAgICAgICAgICBldmVudC50YXJnZXQgPSBldmVudC5zcmNFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gZXZlbnQucHJldmVudERlZmF1bHQgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBldmVudC5zdG9wUHJvcGFnYXRpb24gfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBoYW5kbGVyLmNhbGwoZWxlbWVudCwgZXZlbnQpO1xuICAgICAgfTtcbiAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoXCJvblwiICsgZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcik7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV2ZW50TmFtZSxcbiAgICAgICAgICBpICAgICAgID0gMCxcbiAgICAgICAgICBsZW5ndGggID0gZXZlbnROYW1lcy5sZW5ndGg7XG4gICAgICBmb3IgKDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWVzW2ldO1xuICAgICAgICBpZiAoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoXCJvblwiICsgZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuLyoqXG4gKiBIVE1MIFNhbml0aXplclxuICogUmV3cml0ZXMgdGhlIEhUTUwgYmFzZWQgb24gZ2l2ZW4gcnVsZXNcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBlbGVtZW50T3JIdG1sIEhUTUwgU3RyaW5nIHRvIGJlIHNhbml0aXplZCBPUiBlbGVtZW50IHdob3NlIGNvbnRlbnQgc2hvdWxkIGJlIHNhbml0aXplZFxuICogQHBhcmFtIHtPYmplY3R9IFtydWxlc10gTGlzdCBvZiBydWxlcyBmb3IgcmV3cml0aW5nIHRoZSBIVE1MLCBpZiB0aGVyZSdzIG5vIHJ1bGUgZm9yIGFuIGVsZW1lbnQgaXQgd2lsbFxuICogICAgYmUgY29udmVydGVkIHRvIGEgXCJzcGFuXCIuIEVhY2ggcnVsZSBpcyBhIGtleS92YWx1ZSBwYWlyIHdoZXJlIGtleSBpcyB0aGUgdGFnIHRvIGNvbnZlcnQsIGFuZCB2YWx1ZSB0aGVcbiAqICAgIGRlc2lyZWQgc3Vic3RpdHV0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgRG9jdW1lbnQgb2JqZWN0IGluIHdoaWNoIHRvIHBhcnNlIHRoZSBodG1sLCBuZWVkZWQgdG8gc2FuZGJveCB0aGUgcGFyc2luZ1xuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR8U3RyaW5nfSBEZXBlbmRzIG9uIHRoZSBlbGVtZW50T3JIdG1sIHBhcmFtZXRlci4gV2hlbiBodG1sIHRoZW4gdGhlIHNhbml0aXplZCBodG1sIGFzIHN0cmluZyBlbHNld2lzZSB0aGUgZWxlbWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgdmFyIHVzZXJIVE1MID0gJzxkaXYgaWQ9XCJmb29cIiBvbmNsaWNrPVwiYWxlcnQoMSk7XCI+PHA+PGZvbnQgY29sb3I9XCJyZWRcIj5mb288L2ZvbnQ+PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD48L3A+PC9kaXY+JztcbiAqICAgIHd5c2lodG1sNS5kb20ucGFyc2UodXNlckhUTUwsIHtcbiAqICAgICAgdGFncyB7XG4gKiAgICAgICAgcDogICAgICBcImRpdlwiLCAgICAgIC8vIFJlbmFtZSBwIHRhZ3MgdG8gZGl2IHRhZ3NcbiAqICAgICAgICBmb250OiAgIFwic3BhblwiICAgICAgLy8gUmVuYW1lIGZvbnQgdGFncyB0byBzcGFuIHRhZ3NcbiAqICAgICAgICBkaXY6ICAgIHRydWUsICAgICAgIC8vIEtlZXAgdGhlbSwgYWxzbyBwb3NzaWJsZSAoc2FtZSByZXN1bHQgd2hlbiBwYXNzaW5nOiBcImRpdlwiIG9yIHRydWUpXG4gKiAgICAgICAgc2NyaXB0OiB1bmRlZmluZWQgICAvLyBSZW1vdmUgc2NyaXB0IGVsZW1lbnRzXG4gKiAgICAgIH1cbiAqICAgIH0pO1xuICogICAgLy8gPT4gPGRpdj48ZGl2PjxzcGFuPmZvbyBiYXI8L3NwYW4+PC9kaXY+PC9kaXY+XG4gKlxuICogICAgdmFyIHVzZXJIVE1MID0gJzx0YWJsZT48dGJvZHk+PHRyPjx0ZD5JJ20gYSB0YWJsZSE8L3RkPjwvdHI+PC90Ym9keT48L3RhYmxlPic7XG4gKiAgICB3eXNpaHRtbDUuZG9tLnBhcnNlKHVzZXJIVE1MKTtcbiAqICAgIC8vID0+ICc8c3Bhbj48c3Bhbj48c3Bhbj48c3Bhbj5JJ20gYSB0YWJsZSE8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+J1xuICpcbiAqICAgIHZhciB1c2VySFRNTCA9ICc8ZGl2PmZvb2Jhcjxicj5mb29iYXI8L2Rpdj4nO1xuICogICAgd3lzaWh0bWw1LmRvbS5wYXJzZSh1c2VySFRNTCwge1xuICogICAgICB0YWdzOiB7XG4gKiAgICAgICAgZGl2OiB1bmRlZmluZWQsXG4gKiAgICAgICAgYnI6ICB0cnVlXG4gKiAgICAgIH1cbiAqICAgIH0pO1xuICogICAgLy8gPT4gJydcbiAqXG4gKiAgICB2YXIgdXNlckhUTUwgPSAnPGRpdiBjbGFzcz1cInJlZFwiPmZvbzwvZGl2PjxkaXYgY2xhc3M9XCJwaW5rXCI+YmFyPC9kaXY+JztcbiAqICAgIHd5c2lodG1sNS5kb20ucGFyc2UodXNlckhUTUwsIHtcbiAqICAgICAgY2xhc3Nlczoge1xuICogICAgICAgIHJlZDogICAgMSxcbiAqICAgICAgICBncmVlbjogIDFcbiAqICAgICAgfSxcbiAqICAgICAgdGFnczoge1xuICogICAgICAgIGRpdjoge1xuICogICAgICAgICAgcmVuYW1lX3RhZzogICAgIFwicFwiXG4gKiAgICAgICAgfVxuICogICAgICB9XG4gKiAgICB9KTtcbiAqICAgIC8vID0+ICc8cCBjbGFzcz1cInJlZFwiPmZvbzwvcD48cD5iYXI8L3A+J1xuICovXG53eXNpaHRtbDUuZG9tLnBhcnNlID0gKGZ1bmN0aW9uKCkge1xuICBcbiAgLyoqXG4gICAqIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBhIFhNTFBhcnNlci9ET01QYXJzZXIgYXMgSFRNTDUgaXMgbm90IGFsd2F5cyB3ZWxsLWZvcm1lZCBYTUxcbiAgICogbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZygnPGltZyBzcmM9XCJmb28uZ2lmXCI+Jykgd2lsbCBjYXVzZSBhIHBhcnNlRXJyb3Igc2luY2UgdGhlXG4gICAqIG5vZGUgaXNuJ3QgY2xvc2VkXG4gICAqXG4gICAqIFRoZXJlZm9yZSB3ZSd2ZSB0byB1c2UgdGhlIGJyb3dzZXIncyBvcmRpbmFyeSBIVE1MIHBhcnNlciBpbnZva2VkIGJ5IHNldHRpbmcgaW5uZXJIVE1MLlxuICAgKi9cbiAgdmFyIE5PREVfVFlQRV9NQVBQSU5HID0ge1xuICAgICAgICBcIjFcIjogX2hhbmRsZUVsZW1lbnQsXG4gICAgICAgIFwiM1wiOiBfaGFuZGxlVGV4dFxuICAgICAgfSxcbiAgICAgIC8vIFJlbmFtZSB1bmtub3duIHRhZ3MgdG8gdGhpc1xuICAgICAgREVGQVVMVF9OT0RFX05BTUUgICA9IFwic3BhblwiLFxuICAgICAgV0hJVEVfU1BBQ0VfUkVHX0VYUCA9IC9cXHMrLyxcbiAgICAgIGRlZmF1bHRSdWxlcyAgICAgICAgPSB7IHRhZ3M6IHt9LCBjbGFzc2VzOiB7fSB9LFxuICAgICAgY3VycmVudFJ1bGVzICAgICAgICA9IHt9O1xuICBcbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgYWxsIGNoaWxkcyBvZiB0aGUgZWxlbWVudCwgcmVjcmVhdGVzIHRoZW0sIGFwcGVuZHMgdGhlbSBpbnRvIGEgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICogd2hpY2ggbGF0ZXIgcmVwbGFjZXMgdGhlIGVudGlyZSBib2R5IGNvbnRlbnRcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlKGVsZW1lbnRPckh0bWwsIHJ1bGVzLCBjb250ZXh0LCBjbGVhblVwKSB7XG4gICAgd3lzaWh0bWw1Lmxhbmcub2JqZWN0KGN1cnJlbnRSdWxlcykubWVyZ2UoZGVmYXVsdFJ1bGVzKS5tZXJnZShydWxlcykuZ2V0KCk7XG4gICAgXG4gICAgY29udGV4dCAgICAgICAgICAgPSBjb250ZXh0IHx8IGVsZW1lbnRPckh0bWwub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICB2YXIgZnJhZ21lbnQgICAgICA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICBpc1N0cmluZyAgICAgID0gdHlwZW9mKGVsZW1lbnRPckh0bWwpID09PSBcInN0cmluZ1wiLFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICBuZXdOb2RlLFxuICAgICAgICBmaXJzdENoaWxkO1xuICAgIFxuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgZWxlbWVudCA9IHd5c2lodG1sNS5kb20uZ2V0QXNEb20oZWxlbWVudE9ySHRtbCwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50T3JIdG1sO1xuICAgIH1cbiAgICBcbiAgICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBmaXJzdENoaWxkICA9IGVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgICBuZXdOb2RlID0gX2NvbnZlcnQoZmlyc3RDaGlsZCwgY2xlYW5VcCk7XG4gICAgICBpZiAobmV3Tm9kZSkge1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChuZXdOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYXIgZWxlbWVudCBjb250ZW50c1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBcbiAgICAvLyBJbnNlcnQgbmV3IERPTSB0cmVlXG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgXG4gICAgcmV0dXJuIGlzU3RyaW5nID8gd3lzaWh0bWw1LnF1aXJrcy5nZXRDb3JyZWN0SW5uZXJIVE1MKGVsZW1lbnQpIDogZWxlbWVudDtcbiAgfVxuICBcbiAgZnVuY3Rpb24gX2NvbnZlcnQob2xkTm9kZSwgY2xlYW5VcCkge1xuICAgIHZhciBvbGROb2RlVHlwZSAgICAgPSBvbGROb2RlLm5vZGVUeXBlLFxuICAgICAgICBvbGRDaGlsZHMgICAgICAgPSBvbGROb2RlLmNoaWxkTm9kZXMsXG4gICAgICAgIG9sZENoaWxkc0xlbmd0aCA9IG9sZENoaWxkcy5sZW5ndGgsXG4gICAgICAgIG5ld05vZGUsXG4gICAgICAgIG1ldGhvZCAgICAgICAgICA9IE5PREVfVFlQRV9NQVBQSU5HW29sZE5vZGVUeXBlXSxcbiAgICAgICAgaSAgICAgICAgICAgICAgID0gMDtcbiAgICBcbiAgICBuZXdOb2RlID0gbWV0aG9kICYmIG1ldGhvZChvbGROb2RlKTtcbiAgICBcbiAgICBpZiAoIW5ld05vZGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICBmb3IgKGk9MDsgaTxvbGRDaGlsZHNMZW5ndGg7IGkrKykge1xuICAgICAgbmV3Q2hpbGQgPSBfY29udmVydChvbGRDaGlsZHNbaV0sIGNsZWFuVXApO1xuICAgICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICAgIG5ld05vZGUuYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbnVwIHNlbnNlbGVzcyA8c3Bhbj4gZWxlbWVudHNcbiAgICBpZiAoY2xlYW5VcCAmJlxuICAgICAgICBuZXdOb2RlLmNoaWxkTm9kZXMubGVuZ3RoIDw9IDEgJiZcbiAgICAgICAgbmV3Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBERUZBVUxUX05PREVfTkFNRSAmJlxuICAgICAgICAhbmV3Tm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ld05vZGUuZmlyc3RDaGlsZDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIF9oYW5kbGVFbGVtZW50KG9sZE5vZGUpIHtcbiAgICB2YXIgcnVsZSxcbiAgICAgICAgbmV3Tm9kZSxcbiAgICAgICAgZW5kVGFnLFxuICAgICAgICB0YWdSdWxlcyAgICA9IGN1cnJlbnRSdWxlcy50YWdzLFxuICAgICAgICBub2RlTmFtZSAgICA9IG9sZE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgc2NvcGVOYW1lICAgPSBvbGROb2RlLnNjb3BlTmFtZTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBXZSBhbHJlYWR5IHBhcnNlZCB0aGF0IGVsZW1lbnRcbiAgICAgKiBpZ25vcmUgaXQhICh5ZXMsIHRoaXMgc29tZXRpbWVzIGhhcHBlbnMgaW4gSUU4IHdoZW4gdGhlIGh0bWwgaXMgaW52YWxpZClcbiAgICAgKi9cbiAgICBpZiAob2xkTm9kZS5fd3lzaWh0bWw1KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgb2xkTm9kZS5fd3lzaWh0bWw1ID0gMTtcbiAgICBcbiAgICBpZiAob2xkTm9kZS5jbGFzc05hbWUgPT09IFwid3lzaWh0bWw1LXRlbXBcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIElFIGlzIHRoZSBvbmx5IGJyb3dzZXIgd2hvIGRvZXNuJ3QgaW5jbHVkZSB0aGUgbmFtZXNwYWNlIGluIHRoZVxuICAgICAqIG5vZGVOYW1lLCB0aGF0J3Mgd2h5IHdlIGhhdmUgdG8gcHJlcGVuZCBpdCBieSBvdXJzZWx2ZXNcbiAgICAgKiBzY29wZU5hbWUgaXMgYSBwcm9wcmlldGFyeSBJRSBmZWF0dXJlXG4gICAgICogcmVhZCBtb3JlIGhlcmUgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM0Mzg4KHY9dnMuODUpLmFzcHhcbiAgICAgKi9cbiAgICBpZiAoc2NvcGVOYW1lICYmIHNjb3BlTmFtZSAhPSBcIkhUTUxcIikge1xuICAgICAgbm9kZU5hbWUgPSBzY29wZU5hbWUgKyBcIjpcIiArIG5vZGVOYW1lO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXBhaXIgbm9kZVxuICAgICAqIElFIGlzIGEgYml0IGJpdGNoeSB3aGVuIGl0IGNvbWVzIHRvIGludmFsaWQgbmVzdGVkIG1hcmt1cCB3aGljaCBpbmNsdWRlcyB1bmNsb3NlZCB0YWdzXG4gICAgICogQSA8cD4gZG9lc24ndCBuZWVkIHRvIGJlIGNsb3NlZCBhY2NvcmRpbmcgSFRNTDQtNSBzcGVjLCB3ZSBzaW1wbHkgcmVwbGFjZSBpdCB3aXRoIGEgPGRpdj4gdG8gcHJlc2VydmUgaXRzIGNvbnRlbnQgYW5kIGxheW91dFxuICAgICAqL1xuICAgIGlmIChcIm91dGVySFRNTFwiIGluIG9sZE5vZGUpIHtcbiAgICAgIGlmICghd3lzaWh0bWw1LmJyb3dzZXIuYXV0b0Nsb3Nlc1VuY2xvc2VkVGFncygpICYmXG4gICAgICAgICAgb2xkTm9kZS5ub2RlTmFtZSA9PT0gXCJQXCIgJiZcbiAgICAgICAgICBvbGROb2RlLm91dGVySFRNTC5zbGljZSgtNCkudG9Mb3dlckNhc2UoKSAhPT0gXCI8L3A+XCIpIHtcbiAgICAgICAgbm9kZU5hbWUgPSBcImRpdlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAobm9kZU5hbWUgaW4gdGFnUnVsZXMpIHtcbiAgICAgIHJ1bGUgPSB0YWdSdWxlc1tub2RlTmFtZV07XG4gICAgICBpZiAoIXJ1bGUgfHwgcnVsZS5yZW1vdmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJ1bGUgPSB0eXBlb2YocnVsZSkgPT09IFwic3RyaW5nXCIgPyB7IHJlbmFtZV90YWc6IHJ1bGUgfSA6IHJ1bGU7XG4gICAgfSBlbHNlIGlmIChvbGROb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHJ1bGUgPSB7IHJlbmFtZV90YWc6IERFRkFVTFRfTk9ERV9OQU1FIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBlbXB0eSB1bmtub3duIGVsZW1lbnRzXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgbmV3Tm9kZSA9IG9sZE5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHJ1bGUucmVuYW1lX3RhZyB8fCBub2RlTmFtZSk7XG4gICAgX2hhbmRsZUF0dHJpYnV0ZXMob2xkTm9kZSwgbmV3Tm9kZSwgcnVsZSk7XG4gICAgXG4gICAgb2xkTm9kZSA9IG51bGw7XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIF9oYW5kbGVBdHRyaWJ1dGVzKG9sZE5vZGUsIG5ld05vZGUsIHJ1bGUpIHtcbiAgICB2YXIgYXR0cmlidXRlcyAgICAgICAgICA9IHt9LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcmVzaCBuZXcgc2V0IG9mIGF0dHJpYnV0ZXMgdG8gc2V0IG9uIG5ld05vZGVcbiAgICAgICAgc2V0Q2xhc3MgICAgICAgICAgICA9IHJ1bGUuc2V0X2NsYXNzLCAgICAgICAgICAgICAvLyBjbGFzc2VzIHRvIHNldFxuICAgICAgICBhZGRDbGFzcyAgICAgICAgICAgID0gcnVsZS5hZGRfY2xhc3MsICAgICAgICAgICAgIC8vIGFkZCBjbGFzc2VzIGJhc2VkIG9uIGV4aXN0aW5nIGF0dHJpYnV0ZXNcbiAgICAgICAgc2V0QXR0cmlidXRlcyAgICAgICA9IHJ1bGUuc2V0X2F0dHJpYnV0ZXMsICAgICAgICAvLyBhdHRyaWJ1dGVzIHRvIHNldCBvbiB0aGUgY3VycmVudCBub2RlXG4gICAgICAgIGNoZWNrQXR0cmlidXRlcyAgICAgPSBydWxlLmNoZWNrX2F0dHJpYnV0ZXMsICAgICAgLy8gY2hlY2svY29udmVydCB2YWx1ZXMgb2YgYXR0cmlidXRlc1xuICAgICAgICBhbGxvd2VkQ2xhc3NlcyAgICAgID0gY3VycmVudFJ1bGVzLmNsYXNzZXMsXG4gICAgICAgIGkgICAgICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICBjbGFzc2VzICAgICAgICAgICAgID0gW10sXG4gICAgICAgIG5ld0NsYXNzZXMgICAgICAgICAgPSBbXSxcbiAgICAgICAgbmV3VW5pcXVlQ2xhc3NlcyAgICA9IFtdLFxuICAgICAgICBvbGRDbGFzc2VzICAgICAgICAgID0gW10sXG4gICAgICAgIGNsYXNzZXNMZW5ndGgsXG4gICAgICAgIG5ld0NsYXNzZXNMZW5ndGgsXG4gICAgICAgIGN1cnJlbnRDbGFzcyxcbiAgICAgICAgbmV3Q2xhc3MsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWUsXG4gICAgICAgIG5ld0F0dHJpYnV0ZVZhbHVlLFxuICAgICAgICBtZXRob2Q7XG4gICAgXG4gICAgaWYgKHNldEF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSB3eXNpaHRtbDUubGFuZy5vYmplY3Qoc2V0QXR0cmlidXRlcykuY2xvbmUoKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGNoZWNrQXR0cmlidXRlcykge1xuICAgICAgZm9yIChhdHRyaWJ1dGVOYW1lIGluIGNoZWNrQXR0cmlidXRlcykge1xuICAgICAgICBtZXRob2QgPSBhdHRyaWJ1dGVDaGVja01ldGhvZHNbY2hlY2tBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdXTtcbiAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuZXdBdHRyaWJ1dGVWYWx1ZSA9IG1ldGhvZChfZ2V0QXR0cmlidXRlKG9sZE5vZGUsIGF0dHJpYnV0ZU5hbWUpKTtcbiAgICAgICAgaWYgKHR5cGVvZihuZXdBdHRyaWJ1dGVWYWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3QXR0cmlidXRlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHNldENsYXNzKSB7XG4gICAgICBjbGFzc2VzLnB1c2goc2V0Q2xhc3MpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYWRkQ2xhc3MpIHtcbiAgICAgIGZvciAoYXR0cmlidXRlTmFtZSBpbiBhZGRDbGFzcykge1xuICAgICAgICBtZXRob2QgPSBhZGRDbGFzc01ldGhvZHNbYWRkQ2xhc3NbYXR0cmlidXRlTmFtZV1dO1xuICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5ld0NsYXNzID0gbWV0aG9kKF9nZXRBdHRyaWJ1dGUob2xkTm9kZSwgYXR0cmlidXRlTmFtZSkpO1xuICAgICAgICBpZiAodHlwZW9mKG5ld0NsYXNzKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNsYXNzZXMucHVzaChuZXdDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgd3lzaWh0bWw1IHRlbXAgY2xhc3MgZG9lc24ndCBnZXQgc3RyaXBwZWQgb3V0XG4gICAgYWxsb3dlZENsYXNzZXNbXCJfd3lzaWh0bWw1LXRlbXAtcGxhY2Vob2xkZXJcIl0gPSAxO1xuICAgIFxuICAgIC8vIGFkZCBvbGQgY2xhc3NlcyBsYXN0XG4gICAgb2xkQ2xhc3NlcyA9IG9sZE5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgaWYgKG9sZENsYXNzZXMpIHtcbiAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLmNvbmNhdChvbGRDbGFzc2VzLnNwbGl0KFdISVRFX1NQQUNFX1JFR19FWFApKTtcbiAgICB9XG4gICAgY2xhc3Nlc0xlbmd0aCA9IGNsYXNzZXMubGVuZ3RoO1xuICAgIGZvciAoOyBpPGNsYXNzZXNMZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudENsYXNzID0gY2xhc3Nlc1tpXTtcbiAgICAgIGlmIChhbGxvd2VkQ2xhc3Nlc1tjdXJyZW50Q2xhc3NdKSB7XG4gICAgICAgIG5ld0NsYXNzZXMucHVzaChjdXJyZW50Q2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyByZW1vdmUgZHVwbGljYXRlIGVudHJpZXMgYW5kIHByZXNlcnZlIGNsYXNzIHNwZWNpZmljaXR5XG4gICAgbmV3Q2xhc3Nlc0xlbmd0aCA9IG5ld0NsYXNzZXMubGVuZ3RoO1xuICAgIHdoaWxlIChuZXdDbGFzc2VzTGVuZ3RoLS0pIHtcbiAgICAgIGN1cnJlbnRDbGFzcyA9IG5ld0NsYXNzZXNbbmV3Q2xhc3Nlc0xlbmd0aF07XG4gICAgICBpZiAoIXd5c2lodG1sNS5sYW5nLmFycmF5KG5ld1VuaXF1ZUNsYXNzZXMpLmNvbnRhaW5zKGN1cnJlbnRDbGFzcykpIHtcbiAgICAgICAgbmV3VW5pcXVlQ2xhc3Nlcy51bnNoaWZ0KGN1cnJlbnRDbGFzcyk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChuZXdVbmlxdWVDbGFzc2VzLmxlbmd0aCkge1xuICAgICAgYXR0cmlidXRlc1tcImNsYXNzXCJdID0gbmV3VW5pcXVlQ2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgXG4gICAgLy8gc2V0IGF0dHJpYnV0ZXMgb24gbmV3Tm9kZVxuICAgIGZvciAoYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAvLyBTZXR0aW5nIGF0dHJpYnV0ZXMgY2FuIGNhdXNlIGEganMgZXJyb3IgaW4gSUUgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzXG4gICAgICAvLyBlZy4gb24gYSA8aW1nPiB1bmRlciBodHRwcyB3aGVuIGl0J3MgbmV3IGF0dHJpYnV0ZSB2YWx1ZSBpcyBub24taHR0cHNcbiAgICAgIC8vIFRPRE86IEludmVzdGlnYXRlIHRoaXMgZnVydGhlciBhbmQgY2hlY2sgZm9yIHNtYXJ0ZXIgaGFuZGxpbmdcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ld05vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0pO1xuICAgICAgfSBjYXRjaChlKSB7fVxuICAgIH1cbiAgICBcbiAgICAvLyBJRTggc29tZXRpbWVzIGxvc2VzIHRoZSB3aWR0aC9oZWlnaHQgYXR0cmlidXRlcyB3aGVuIHRob3NlIGFyZSBzZXQgYmVmb3JlIHRoZSBcInNyY1wiXG4gICAgLy8gc28gd2UgbWFrZSBzdXJlIHRvIHNldCB0aGVtIGFnYWluXG4gICAgaWYgKGF0dHJpYnV0ZXMuc3JjKSB7XG4gICAgICBpZiAodHlwZW9mKGF0dHJpYnV0ZXMud2lkdGgpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG5ld05vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgYXR0cmlidXRlcy53aWR0aCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mKGF0dHJpYnV0ZXMuaGVpZ2h0KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBuZXdOb2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBhdHRyaWJ1dGVzLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogSUUgZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgaGFzQXR0cmlidXRlL2dldEF0dHJpYnV0ZSwgZm9yIGV4YW1wbGU6XG4gICAqICAgIHZhciB0ZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiKTtcbiAgICogICAgdGQuZ2V0QXR0cmlidXRlKFwicm93c3BhblwiKTsgLy8gPT4gXCIxXCIgaW4gSUVcbiAgICpcbiAgICogVGhlcmVmb3JlIHdlIGhhdmUgdG8gY2hlY2sgdGhlIGVsZW1lbnQncyBvdXRlckhUTUwgZm9yIHRoZSBhdHRyaWJ1dGVcbiAgICovXG4gIHZhciBIQVNfR0VUX0FUVFJJQlVURV9CVUcgPSAhd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNHZXRBdHRyaWJ1dGVDb3JyZWN0bHkoKTtcbiAgZnVuY3Rpb24gX2dldEF0dHJpYnV0ZShub2RlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lO1xuICAgIGlmIChub2RlTmFtZSA9PSBcIklNR1wiICYmIGF0dHJpYnV0ZU5hbWUgPT0gXCJzcmNcIiAmJiBfaXNMb2FkZWRJbWFnZShub2RlKSA9PT0gdHJ1ZSkge1xuICAgICAgLy8gR2V0ICdzcmMnIGF0dHJpYnV0ZSB2YWx1ZSB2aWEgb2JqZWN0IHByb3BlcnR5IHNpbmNlIHRoaXMgd2lsbCBhbHdheXMgY29udGFpbiB0aGVcbiAgICAgIC8vIGZ1bGwgYWJzb2x1dGUgdXJsIChodHRwOi8vLi4uKVxuICAgICAgLy8gdGhpcyBmaXhlcyBhIHZlcnkgYW5ub3lpbmcgYnVnIGluIGZpcmVmb3ggKHZlciAzLjYgJiA0KSBhbmQgSUUgOCB3aGVyZSBpbWFnZXMgY29waWVkIGZyb20gdGhlIHNhbWUgaG9zdFxuICAgICAgLy8gd2lsbCBoYXZlIHJlbGF0aXZlIHBhdGhzLCB3aGljaCB0aGUgc2FuaXRpemVyIHN0cmlwcyBvdXQgKHNlZSBhdHRyaWJ1dGVDaGVja01ldGhvZHMudXJsKVxuICAgICAgcmV0dXJuIG5vZGUuc3JjO1xuICAgIH0gZWxzZSBpZiAoSEFTX0dFVF9BVFRSSUJVVEVfQlVHICYmIFwib3V0ZXJIVE1MXCIgaW4gbm9kZSkge1xuICAgICAgLy8gRG9uJ3QgdHJ1c3QgZ2V0QXR0cmlidXRlL2hhc0F0dHJpYnV0ZSBpbiBJRSA2LTgsIGluc3RlYWQgY2hlY2sgdGhlIGVsZW1lbnQncyBvdXRlckhUTUxcbiAgICAgIHZhciBvdXRlckhUTUwgICAgICA9IG5vZGUub3V0ZXJIVE1MLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgLy8gVE9ETzogVGhpcyBtaWdodCBub3Qgd29yayBmb3IgYXR0cmlidXRlcyB3aXRob3V0IHZhbHVlOiA8aW5wdXQgZGlzYWJsZWQ+XG4gICAgICAgICAgaGFzQXR0cmlidXRlICAgPSBvdXRlckhUTUwuaW5kZXhPZihcIiBcIiArIGF0dHJpYnV0ZU5hbWUgKyAgXCI9XCIpICE9IC0xO1xuICAgICAgXG4gICAgICByZXR1cm4gaGFzQXR0cmlidXRlID8gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkgOiBudWxsO1xuICAgIH0gZWxzZXtcbiAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIGlzIGEgcHJvcGVyIGxvYWRlZCBpbWFnZVxuICAgKiBGSVhNRTogUmV0dXJucyB1bmRlZmluZWQgd2hlbiB1bmtub3duIChDaHJvbWUsIFNhZmFyaSlcbiAgICovXG4gIGZ1bmN0aW9uIF9pc0xvYWRlZEltYWdlKG5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5vZGUuY29tcGxldGUgJiYgIW5vZGUubW96TWF0Y2hlc1NlbGVjdG9yKFwiOi1tb3otYnJva2VuXCIpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgaWYgKG5vZGUuY29tcGxldGUgJiYgbm9kZS5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBmdW5jdGlvbiBfaGFuZGxlVGV4dChvbGROb2RlKSB7XG4gICAgcmV0dXJuIG9sZE5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShvbGROb2RlLmRhdGEpO1xuICB9XG4gIFxuICBcbiAgLy8gLS0tLS0tLS0tLS0tIGF0dHJpYnV0ZSBjaGVja3MgLS0tLS0tLS0tLS0tIFxcXFxcbiAgdmFyIGF0dHJpYnV0ZUNoZWNrTWV0aG9kcyA9IHtcbiAgICB1cmw6IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBSRUdfRVhQID0gL15odHRwcz86XFwvXFwvL2k7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCAhYXR0cmlidXRlVmFsdWUubWF0Y2goUkVHX0VYUCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWUucmVwbGFjZShSRUdfRVhQLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSkoKSxcbiAgICBcbiAgICBhbHQ6IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBSRUdfRVhQID0gL1teIGEtejAtOV9cXC1dL2dpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIGlmICghYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWUucmVwbGFjZShSRUdfRVhQLCBcIlwiKTtcbiAgICAgIH07XG4gICAgfSkoKSxcbiAgICBcbiAgICBudW1iZXJzOiAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgUkVHX0VYUCA9IC9cXEQvZztcbiAgICAgIHJldHVybiBmdW5jdGlvbihhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9IChhdHRyaWJ1dGVWYWx1ZSB8fCBcIlwiKS5yZXBsYWNlKFJFR19FWFAsIFwiXCIpO1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWUgfHwgbnVsbDtcbiAgICAgIH07XG4gICAgfSkoKVxuICB9O1xuICBcbiAgLy8gLS0tLS0tLS0tLS0tIGNsYXNzIGNvbnZlcnRlciAoY29udmVydHMgYW4gaHRtbCBhdHRyaWJ1dGUgdG8gYSBjbGFzcyBuYW1lKSAtLS0tLS0tLS0tLS0gXFxcXFxuICB2YXIgYWRkQ2xhc3NNZXRob2RzID0ge1xuICAgIGFsaWduX2ltZzogKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgIGxlZnQ6ICAgXCJ3eXNpd3lnLWZsb2F0LWxlZnRcIixcbiAgICAgICAgcmlnaHQ6ICBcInd5c2l3eWctZmxvYXQtcmlnaHRcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWFwcGluZ1tTdHJpbmcoYXR0cmlidXRlVmFsdWUpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgfTtcbiAgICB9KSgpLFxuICAgIFxuICAgIGFsaWduX3RleHQ6IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICBsZWZ0OiAgICAgXCJ3eXNpd3lnLXRleHQtYWxpZ24tbGVmdFwiLFxuICAgICAgICByaWdodDogICAgXCJ3eXNpd3lnLXRleHQtYWxpZ24tcmlnaHRcIixcbiAgICAgICAgY2VudGVyOiAgIFwid3lzaXd5Zy10ZXh0LWFsaWduLWNlbnRlclwiLFxuICAgICAgICBqdXN0aWZ5OiAgXCJ3eXNpd3lnLXRleHQtYWxpZ24tanVzdGlmeVwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtYXBwaW5nW1N0cmluZyhhdHRyaWJ1dGVWYWx1ZSkudG9Mb3dlckNhc2UoKV07XG4gICAgICB9O1xuICAgIH0pKCksXG4gICAgXG4gICAgY2xlYXJfYnI6IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICBsZWZ0OiAgIFwid3lzaXd5Zy1jbGVhci1sZWZ0XCIsXG4gICAgICAgIHJpZ2h0OiAgXCJ3eXNpd3lnLWNsZWFyLXJpZ2h0XCIsXG4gICAgICAgIGJvdGg6ICAgXCJ3eXNpd3lnLWNsZWFyLWJvdGhcIixcbiAgICAgICAgYWxsOiAgICBcInd5c2l3eWctY2xlYXItYm90aFwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtYXBwaW5nW1N0cmluZyhhdHRyaWJ1dGVWYWx1ZSkudG9Mb3dlckNhc2UoKV07XG4gICAgICB9O1xuICAgIH0pKCksXG4gICAgXG4gICAgc2l6ZV9mb250OiAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgXCIxXCI6IFwid3lzaXd5Zy1mb250LXNpemUteHgtc21hbGxcIixcbiAgICAgICAgXCIyXCI6IFwid3lzaXd5Zy1mb250LXNpemUtc21hbGxcIixcbiAgICAgICAgXCIzXCI6IFwid3lzaXd5Zy1mb250LXNpemUtbWVkaXVtXCIsXG4gICAgICAgIFwiNFwiOiBcInd5c2l3eWctZm9udC1zaXplLWxhcmdlXCIsXG4gICAgICAgIFwiNVwiOiBcInd5c2l3eWctZm9udC1zaXplLXgtbGFyZ2VcIixcbiAgICAgICAgXCI2XCI6IFwid3lzaXd5Zy1mb250LXNpemUteHgtbGFyZ2VcIixcbiAgICAgICAgXCI3XCI6IFwid3lzaXd5Zy1mb250LXNpemUteHgtbGFyZ2VcIixcbiAgICAgICAgXCItXCI6IFwid3lzaXd5Zy1mb250LXNpemUtc21hbGxlclwiLFxuICAgICAgICBcIitcIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS1sYXJnZXJcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWFwcGluZ1tTdHJpbmcoYXR0cmlidXRlVmFsdWUpLmNoYXJBdCgwKV07XG4gICAgICB9O1xuICAgIH0pKClcbiAgfTtcbiAgXG4gIHJldHVybiBwYXJzZTtcbn0pKCk7LyoqXG4gKiBDaGVja3MgZm9yIGVtcHR5IHRleHQgbm9kZSBjaGlsZHMgYW5kIHJlbW92ZXMgdGhlbVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBUaGUgZWxlbWVudCBpbiB3aGljaCB0byBjbGVhbnVwXG4gKiBAZXhhbXBsZVxuICogICAgd3lzaWh0bWw1LmRvbS5yZW1vdmVFbXB0eVRleHROb2RlcyhlbGVtZW50KTtcbiAqL1xud3lzaWh0bWw1LmRvbS5yZW1vdmVFbXB0eVRleHROb2RlcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIGNoaWxkTm9kZSxcbiAgICAgIGNoaWxkTm9kZXMgICAgICAgID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkobm9kZS5jaGlsZE5vZGVzKS5nZXQoKSxcbiAgICAgIGNoaWxkTm9kZXNMZW5ndGggID0gY2hpbGROb2Rlcy5sZW5ndGgsXG4gICAgICBpICAgICAgICAgICAgICAgICA9IDA7XG4gIGZvciAoOyBpPGNoaWxkTm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gd3lzaWh0bWw1LlRFWFRfTk9ERSAmJiBjaGlsZE5vZGUuZGF0YSA9PT0gXCJcIikge1xuICAgICAgY2hpbGROb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGROb2RlKTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIFJlbmFtZXMgYW4gZWxlbWVudCAoZWcuIGEgPGRpdj4gdG8gYSA8cD4pIGFuZCBrZWVwcyBpdHMgY2hpbGRzXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBsaXN0IGVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmFtZWRcbiAqIEBwYXJhbSB7RWxlbWVudH0gbmV3Tm9kZU5hbWUgVGhlIGRlc2lyZWQgdGFnIG5hbWVcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgPCEtLSBBc3N1bWUgdGhlIGZvbGxvd2luZyBkb206IC0tPlxuICogICAgPHVsIGlkPVwibGlzdFwiPlxuICogICAgICA8bGk+ZW1pbmVtPC9saT5cbiAqICAgICAgPGxpPmRyLiBkcmU8L2xpPlxuICogICAgICA8bGk+NTAgQ2VudDwvbGk+XG4gKiAgICA8L3VsPlxuICpcbiAqICAgIDxzY3JpcHQ+XG4gKiAgICAgIHd5c2lodG1sNS5kb20ucmVuYW1lRWxlbWVudChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxpc3RcIiksIFwib2xcIik7XG4gKiAgICA8L3NjcmlwdD5cbiAqXG4gKiAgICA8IS0tIFdpbGwgcmVzdWx0IGluOiAtLT5cbiAqICAgIDxvbD5cbiAqICAgICAgPGxpPmVtaW5lbTwvbGk+XG4gKiAgICAgIDxsaT5kci4gZHJlPC9saT5cbiAqICAgICAgPGxpPjUwIENlbnQ8L2xpPlxuICogICAgPC9vbD5cbiAqL1xud3lzaWh0bWw1LmRvbS5yZW5hbWVFbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgbmV3Tm9kZU5hbWUpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChuZXdOb2RlTmFtZSksXG4gICAgICBmaXJzdENoaWxkO1xuICB3aGlsZSAoZmlyc3RDaGlsZCA9IGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgIG5ld0VsZW1lbnQuYXBwZW5kQ2hpbGQoZmlyc3RDaGlsZCk7XG4gIH1cbiAgd3lzaWh0bWw1LmRvbS5jb3B5QXR0cmlidXRlcyhbXCJhbGlnblwiLCBcImNsYXNzTmFtZVwiXSkuZnJvbShlbGVtZW50KS50byhuZXdFbGVtZW50KTtcbiAgZWxlbWVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdFbGVtZW50LCBlbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59Oy8qKlxuICogVGFrZXMgYW4gZWxlbWVudCwgcmVtb3ZlcyBpdCBhbmQgcmVwbGFjZXMgaXQgd2l0aCBpdCdzIGNoaWxkc1xuICogXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSBUaGUgbm9kZSB3aGljaCB0byByZXBsYWNlIHdpdGggaXQncyBjaGlsZCBub2Rlc1xuICogQGV4YW1wbGVcbiAqICAgIDxkaXYgaWQ9XCJmb29cIj5cbiAqICAgICAgPHNwYW4+aGVsbG88L3NwYW4+XG4gKiAgICA8L2Rpdj5cbiAqICAgIDxzY3JpcHQ+XG4gKiAgICAgIC8vIFJlbW92ZSAjZm9vIGFuZCByZXBsYWNlIHdpdGggaXQncyBjaGlsZHJlblxuICogICAgICB3eXNpaHRtbDUuZG9tLnJlcGxhY2VXaXRoQ2hpbGROb2Rlcyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZvb1wiKSk7XG4gKiAgICA8L3NjcmlwdD5cbiAqL1xud3lzaWh0bWw1LmRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXMgPSBmdW5jdGlvbihub2RlKSB7XG4gIGlmICghbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICBpZiAoIW5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgXG4gIHZhciBmcmFnbWVudCA9IG5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICB9XG4gIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZnJhZ21lbnQsIG5vZGUpO1xuICBub2RlID0gZnJhZ21lbnQgPSBudWxsO1xufTtcbi8qKlxuICogVW53cmFwcyBhbiB1bm9yZGVyZWQvb3JkZXJlZCBsaXN0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBsaXN0IGVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlIHVud3JhcHBlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAgICA8IS0tIEFzc3VtZSB0aGUgZm9sbG93aW5nIGRvbTogLS0+XG4gKiAgICA8dWwgaWQ9XCJsaXN0XCI+XG4gKiAgICAgIDxsaT5lbWluZW08L2xpPlxuICogICAgICA8bGk+ZHIuIGRyZTwvbGk+XG4gKiAgICAgIDxsaT41MCBDZW50PC9saT5cbiAqICAgIDwvdWw+XG4gKlxuICogICAgPHNjcmlwdD5cbiAqICAgICAgd3lzaWh0bWw1LmRvbS5yZXNvbHZlTGlzdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxpc3RcIikpO1xuICogICAgPC9zY3JpcHQ+XG4gKlxuICogICAgPCEtLSBXaWxsIHJlc3VsdCBpbjogLS0+XG4gKiAgICBlbWluZW08YnI+XG4gKiAgICBkci4gZHJlPGJyPlxuICogICAgNTAgQ2VudDxicj5cbiAqL1xuKGZ1bmN0aW9uKGRvbSkge1xuICBmdW5jdGlvbiBfaXNCbG9ja0VsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBkb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20obm9kZSkgPT09IFwiYmxvY2tcIjtcbiAgfVxuICBcbiAgZnVuY3Rpb24gX2lzTGluZUJyZWFrKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlTmFtZSA9PT0gXCJCUlwiO1xuICB9XG4gIFxuICBmdW5jdGlvbiBfYXBwZW5kTGluZUJyZWFrKGVsZW1lbnQpIHtcbiAgICB2YXIgbGluZUJyZWFrID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGxpbmVCcmVhayk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHJlc29sdmVMaXN0KGxpc3QpIHtcbiAgICBpZiAobGlzdC5ub2RlTmFtZSAhPT0gXCJNRU5VXCIgJiYgbGlzdC5ub2RlTmFtZSAhPT0gXCJVTFwiICYmIGxpc3Qubm9kZU5hbWUgIT09IFwiT0xcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB2YXIgZG9jICAgICAgICAgICAgID0gbGlzdC5vd25lckRvY3VtZW50LFxuICAgICAgICBmcmFnbWVudCAgICAgICAgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICBwcmV2aW91c1NpYmxpbmcgPSBsaXN0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgfHwgbGlzdC5wcmV2aW91c1NpYmxpbmcsXG4gICAgICAgIGZpcnN0Q2hpbGQsXG4gICAgICAgIGxhc3RDaGlsZCxcbiAgICAgICAgaXNMYXN0Q2hpbGQsXG4gICAgICAgIHNob3VsZEFwcGVuZExpbmVCcmVhayxcbiAgICAgICAgbGlzdEl0ZW07XG4gICAgXG4gICAgaWYgKHByZXZpb3VzU2libGluZyAmJiAhX2lzQmxvY2tFbGVtZW50KHByZXZpb3VzU2libGluZykpIHtcbiAgICAgIF9hcHBlbmRMaW5lQnJlYWsoZnJhZ21lbnQpO1xuICAgIH1cbiAgICBcbiAgICB3aGlsZSAobGlzdEl0ZW0gPSBsaXN0LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGxhc3RDaGlsZCA9IGxpc3RJdGVtLmxhc3RDaGlsZDtcbiAgICAgIHdoaWxlIChmaXJzdENoaWxkID0gbGlzdEl0ZW0uZmlyc3RDaGlsZCkge1xuICAgICAgICBpc0xhc3RDaGlsZCAgICAgICAgICAgPSBmaXJzdENoaWxkID09PSBsYXN0Q2hpbGQ7XG4gICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSBiZWZvcmUgYXBwZW5kaW5nIGl0IHRvIHRoZSBmcmFnbWVudCwgYXMgaXQgb3RoZXJ3aXNlIHdpbGwgbG9vc2Ugc3R5bGUgaW5mb3JtYXRpb25cbiAgICAgICAgc2hvdWxkQXBwZW5kTGluZUJyZWFrID0gaXNMYXN0Q2hpbGQgJiYgIV9pc0Jsb2NrRWxlbWVudChmaXJzdENoaWxkKSAmJiAhX2lzTGluZUJyZWFrKGZpcnN0Q2hpbGQpO1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChmaXJzdENoaWxkKTtcbiAgICAgICAgaWYgKHNob3VsZEFwcGVuZExpbmVCcmVhaykge1xuICAgICAgICAgIF9hcHBlbmRMaW5lQnJlYWsoZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGxpc3RJdGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGlzdEl0ZW0pO1xuICAgIH1cbiAgICBsaXN0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGZyYWdtZW50LCBsaXN0KTtcbiAgfVxuICBcbiAgZG9tLnJlc29sdmVMaXN0ID0gcmVzb2x2ZUxpc3Q7XG59KSh3eXNpaHRtbDUuZG9tKTsvKipcbiAqIFNhbmRib3ggZm9yIGV4ZWN1dGluZyBqYXZhc2NyaXB0LCBwYXJzaW5nIGNzcyBzdHlsZXMgYW5kIGRvaW5nIGRvbSBvcGVyYXRpb25zIGluIGEgc2VjdXJlIHdheVxuICpcbiAqIEJyb3dzZXIgQ29tcGF0aWJpbGl0eTpcbiAqICAtIFNlY3VyZSBpbiBNU0lFIDYrLCBidXQgb25seSB3aGVuIHRoZSB1c2VyIGhhc24ndCBtYWRlIGNoYW5nZXMgdG8gaGlzIHNlY3VyaXR5IGxldmVsIFwicmVzdHJpY3RlZFwiXG4gKiAgLSBQYXJ0aWFsbHkgc2VjdXJlIGluIG90aGVyIGJyb3dzZXJzIChGaXJlZm94LCBPcGVyYSwgU2FmYXJpLCBDaHJvbWUsIC4uLilcbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgY2xhc3MgY2FuJ3QgYmVuZWZpdCBmcm9tIHRoZSBIVE1MNSBzYW5kYm94IGF0dHJpYnV0ZSBmb3IgdGhlIGZvbGxvd2luZyByZWFzb25zOlxuICogICAgLSBzYW5kYm94aW5nIGRvZXNuJ3Qgd29yayBjb3JyZWN0bHkgd2l0aCBpbmxpbmVkIGNvbnRlbnQgKHNyYz1cImphdmFzY3JpcHQ6JzxodG1sPi4uLjwvaHRtbD4nXCIpXG4gKiAgICAtIHNhbmRib3hpbmcgb2YgcGh5c2ljYWwgZG9jdW1lbnRzIGNhdXNlcyB0aGF0IHRoZSBkb20gaXNuJ3QgYWNjZXNzaWJsZSBhbnltb3JlIGZyb20gdGhlIG91dHNpZGUgKGlmcmFtZS5jb250ZW50V2luZG93LCAuLi4pXG4gKiAgICAtIHNldHRpbmcgdGhlIFwiYWxsb3ctc2FtZS1vcmlnaW5cIiBmbGFnIHdvdWxkIGZpeCB0aGF0LCBidXQgdGhlbiBzdGlsbCBqYXZhc2NyaXB0IGFuZCBkb20gZXZlbnRzIHJlZnVzZSB0byBmaXJlXG4gKiAgICAtIHRoZXJlZm9yZSB0aGUgXCJhbGxvdy1zY3JpcHRzXCIgZmxhZyBpcyBuZWVkZWQsIHdoaWNoIHRoZW4gd291bGQgZGVhY3RpdmF0ZSBhbnkgc2VjdXJpdHksIGFzIHRoZSBqcyBleGVjdXRlZCBpbnNpZGUgdGhlIGlmcmFtZVxuICogICAgICBjYW4gZG8gYW55dGhpbmcgYXMgaWYgdGhlIHNhbmRib3ggYXR0cmlidXRlIHdhc24ndCBzZXRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVhZHlDYWxsYmFja10gTWV0aG9kIHRoYXQgZ2V0cyBpbnZva2VkIHdoZW4gdGhlIHNhbmRib3ggaXMgcmVhZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIG5ldyB3eXNpaHRtbDUuZG9tLlNhbmRib3goZnVuY3Rpb24oc2FuZGJveCkge1xuICogICAgICBzYW5kYm94LmdldFdpbmRvdygpLmRvY3VtZW50LmJvZHkuaW5uZXJIVE1MID0gJzxpbWcgc3JjPWZvby5naWYgb25lcnJvcj1cImFsZXJ0KGRvY3VtZW50LmNvb2tpZSlcIj4nO1xuICogICAgfSk7XG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIC8qKlxuICAgICAgICogRGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAgICAgKi9cbiAgICAgIGRvYyAgICAgICAgICAgICAgICAgPSBkb2N1bWVudCxcbiAgICAgIC8qKlxuICAgICAgICogUHJvcGVydGllcyB0byB1bnNldC9wcm90ZWN0IG9uIHRoZSB3aW5kb3cgb2JqZWN0XG4gICAgICAgKi9cbiAgICAgIHdpbmRvd1Byb3BlcnRpZXMgICAgPSBbXG4gICAgICAgIFwicGFyZW50XCIsIFwidG9wXCIsIFwib3BlbmVyXCIsIFwiZnJhbWVFbGVtZW50XCIsIFwiZnJhbWVzXCIsXG4gICAgICAgIFwibG9jYWxTdG9yYWdlXCIsIFwiZ2xvYmFsU3RvcmFnZVwiLCBcInNlc3Npb25TdG9yYWdlXCIsIFwiaW5kZXhlZERCXCJcbiAgICAgIF0sXG4gICAgICAvKipcbiAgICAgICAqIFByb3BlcnRpZXMgb24gdGhlIHdpbmRvdyBvYmplY3Qgd2hpY2ggYXJlIHNldCB0byBhbiBlbXB0eSBmdW5jdGlvblxuICAgICAgICovXG4gICAgICB3aW5kb3dQcm9wZXJ0aWVzMiAgID0gW1xuICAgICAgICBcIm9wZW5cIiwgXCJjbG9zZVwiLCBcIm9wZW5EaWFsb2dcIiwgXCJzaG93TW9kYWxEaWFsb2dcIixcbiAgICAgICAgXCJhbGVydFwiLCBcImNvbmZpcm1cIiwgXCJwcm9tcHRcIixcbiAgICAgICAgXCJvcGVuRGF0YWJhc2VcIiwgXCJwb3N0TWVzc2FnZVwiLFxuICAgICAgICBcIlhNTEh0dHBSZXF1ZXN0XCIsIFwiWERvbWFpblJlcXVlc3RcIlxuICAgICAgXSxcbiAgICAgIC8qKlxuICAgICAgICogUHJvcGVydGllcyB0byB1bnNldC9wcm90ZWN0IG9uIHRoZSBkb2N1bWVudCBvYmplY3RcbiAgICAgICAqL1xuICAgICAgZG9jdW1lbnRQcm9wZXJ0aWVzICA9IFtcbiAgICAgICAgXCJyZWZlcnJlclwiLFxuICAgICAgICBcIndyaXRlXCIsIFwib3BlblwiLCBcImNsb3NlXCJcbiAgICAgIF07XG4gIFxuICB3eXNpaHRtbDUuZG9tLlNhbmRib3ggPSBCYXNlLmV4dGVuZChcbiAgICAvKiogQHNjb3BlIHd5c2lodG1sNS5kb20uU2FuZGJveC5wcm90b3R5cGUgKi8ge1xuXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKHJlYWR5Q2FsbGJhY2ssIGNvbmZpZykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IHJlYWR5Q2FsbGJhY2sgfHwgd3lzaWh0bWw1LkVNUFRZX0ZVTkNUSU9OO1xuICAgICAgdGhpcy5jb25maWcgICA9IHd5c2lodG1sNS5sYW5nLm9iamVjdCh7fSkubWVyZ2UoY29uZmlnKS5nZXQoKTtcbiAgICAgIHRoaXMuaWZyYW1lICAgPSB0aGlzLl9jcmVhdGVJZnJhbWUoKTtcbiAgICB9LFxuICAgIFxuICAgIGluc2VydEludG86IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YoZWxlbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZWxlbWVudCA9IGRvYy5nZXRFbGVtZW50QnlJZChlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlmcmFtZSk7XG4gICAgfSxcblxuICAgIGdldElmcmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pZnJhbWU7XG4gICAgfSxcblxuICAgIGdldFdpbmRvdzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9yZWFkeUVycm9yKCk7XG4gICAgfSxcblxuICAgIGdldERvY3VtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3JlYWR5RXJyb3IoKTtcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaWZyYW1lID0gdGhpcy5nZXRJZnJhbWUoKTtcbiAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSxcblxuICAgIF9yZWFkeUVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInd5c2lodG1sNS5TYW5kYm94OiBTYW5kYm94IGlmcmFtZSBpc24ndCBsb2FkZWQgeWV0XCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBzYW5kYm94IGlmcmFtZVxuICAgICAqXG4gICAgICogU29tZSBpbXBvcnRhbnQgbm90ZXM6XG4gICAgICogIC0gV2UgY2FuJ3QgdXNlIEhUTUw1IHNhbmRib3ggZm9yIG5vdzpcbiAgICAgKiAgICBzZXR0aW5nIGl0IGNhdXNlcyB0aGF0IHRoZSBpZnJhbWUncyBkb20gY2FuJ3QgYmUgYWNjZXNzZWQgZnJvbSB0aGUgb3V0c2lkZVxuICAgICAqICAgIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHNldCB0aGUgXCJhbGxvdy1zYW1lLW9yaWdpblwiIGZsYWcgd2hpY2ggZW5hYmxlcyBhY2Nlc3NpbmcgdGhlIGlmcmFtZSdzIGRvbVxuICAgICAqICAgIEJ1dCB0aGVuIHRoZXJlJ3MgYW5vdGhlciBwcm9ibGVtLCBET00gZXZlbnRzIChmb2N1cywgYmx1ciwgY2hhbmdlLCBrZXlwcmVzcywgLi4uKSBhcmVuJ3QgZmlyZWQuXG4gICAgICogICAgSW4gb3JkZXIgdG8gbWFrZSB0aGlzIGhhcHBlbiB3ZSBuZWVkIHRvIHNldCB0aGUgXCJhbGxvdy1zY3JpcHRzXCIgZmxhZy5cbiAgICAgKiAgICBBIGNvbWJpbmF0aW9uIG9mIGFsbG93LXNjcmlwdHMgYW5kIGFsbG93LXNhbWUtb3JpZ2luIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyBzZXR0aW5nIG5vIHNhbmRib3ggYXR0cmlidXRlIGF0IGFsbC5cbiAgICAgKiAgLSBDaHJvbWUgJiBTYWZhcmksIGRvZXNuJ3Qgc2VlbSB0byBzdXBwb3J0IHNhbmRib3hpbmcgY29ycmVjdGx5IHdoZW4gdGhlIGlmcmFtZSdzIGh0bWwgaXMgaW5saW5lZCAobm8gcGh5c2ljYWwgZG9jdW1lbnQpXG4gICAgICogIC0gSUUgbmVlZHMgdG8gaGF2ZSB0aGUgc2VjdXJpdHk9XCJyZXN0cmljdGVkXCIgYXR0cmlidXRlIHNldCBiZWZvcmUgdGhlIGlmcmFtZSBpcyBcbiAgICAgKiAgICBpbnNlcnRlZCBpbnRvIHRoZSBkb20gdHJlZVxuICAgICAqICAtIEJlbGlldmUgaXQgb3Igbm90IGJ1dCBpbiBJRSBcInNlY3VyaXR5XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKSBpcyBmYWxzZSwgZXZlblxuICAgICAqICAgIHRob3VnaCBpdCBzdXBwb3J0cyBpdFxuICAgICAqICAtIFdoZW4gYW4gaWZyYW1lIGhhcyBzZWN1cml0eT1cInJlc3RyaWN0ZWRcIiwgaW4gSUUgZXZhbCgpICYgZXhlY1NjcmlwdCgpIGRvbid0IHdvcmsgYW55bW9yZVxuICAgICAqICAtIElFIGRvZXNuJ3QgZmlyZSB0aGUgb25sb2FkIGV2ZW50IHdoZW4gdGhlIGNvbnRlbnQgaXMgaW5saW5lZCBpbiB0aGUgc3JjIGF0dHJpYnV0ZSwgdGhlcmVmb3JlIHdlIHJlbHlcbiAgICAgKiAgICBvbiB0aGUgb25yZWFkeXN0YXRlY2hhbmdlIGV2ZW50XG4gICAgICovXG4gICAgX2NyZWF0ZUlmcmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhhdCAgID0gdGhpcyxcbiAgICAgICAgICBpZnJhbWUgPSBkb2MuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgIGlmcmFtZS5jbGFzc05hbWUgPSBcInd5c2lodG1sNS1zYW5kYm94XCI7XG4gICAgICB3eXNpaHRtbDUuZG9tLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICBcInNlY3VyaXR5XCI6ICAgICAgICAgICBcInJlc3RyaWN0ZWRcIixcbiAgICAgICAgXCJhbGxvd3RyYW5zcGFyZW5jeVwiOiAgXCJ0cnVlXCIsXG4gICAgICAgIFwiZnJhbWVib3JkZXJcIjogICAgICAgIDAsXG4gICAgICAgIFwid2lkdGhcIjogICAgICAgICAgICAgIDAsXG4gICAgICAgIFwiaGVpZ2h0XCI6ICAgICAgICAgICAgIDAsXG4gICAgICAgIFwibWFyZ2lud2lkdGhcIjogICAgICAgIDAsXG4gICAgICAgIFwibWFyZ2luaGVpZ2h0XCI6ICAgICAgIDBcbiAgICAgIH0pLm9uKGlmcmFtZSk7XG5cbiAgICAgIC8vIFNldHRpbmcgdGhlIHNyYyBsaWtlIHRoaXMgcHJldmVudHMgc3NsIHdhcm5pbmdzIGluIElFNlxuICAgICAgaWYgKHd5c2lodG1sNS5icm93c2VyLnRocm93c01peGVkQ29udGVudFdhcm5pbmdXaGVuSWZyYW1lU3JjSXNFbXB0eSgpKSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSBcImphdmFzY3JpcHQ6JzxodG1sPjwvaHRtbD4nXCI7XG4gICAgICB9XG5cbiAgICAgIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICB0aGF0Ll9vbkxvYWRJZnJhbWUoaWZyYW1lKTtcbiAgICAgIH07XG5cbiAgICAgIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC9sb2FkZWR8Y29tcGxldGUvLnRlc3QoaWZyYW1lLnJlYWR5U3RhdGUpKSB7XG4gICAgICAgICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgIHRoYXQuX29uTG9hZElmcmFtZShpZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gaWZyYW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBmb3Igd2hlbiB0aGUgaWZyYW1lIGhhcyBmaW5pc2hlZCBsb2FkaW5nXG4gICAgICovXG4gICAgX29uTG9hZElmcmFtZTogZnVuY3Rpb24oaWZyYW1lKSB7XG4gICAgICAvLyBkb24ndCByZXN1bWUgd2hlbiB0aGUgaWZyYW1lIGdvdCB1bmxvYWRlZCAoZWcuIGJ5IHJlbW92aW5nIGl0IGZyb20gdGhlIGRvbSlcbiAgICAgIGlmICghd3lzaWh0bWw1LmRvbS5jb250YWlucyhkb2MuZG9jdW1lbnRFbGVtZW50LCBpZnJhbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRoYXQgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICBpZnJhbWVXaW5kb3cgICA9IGlmcmFtZS5jb250ZW50V2luZG93LFxuICAgICAgICAgIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQsXG4gICAgICAgICAgY2hhcnNldCAgICAgICAgPSBkb2MuY2hhcmFjdGVyU2V0IHx8IGRvYy5jaGFyc2V0IHx8IFwidXRmLThcIixcbiAgICAgICAgICBzYW5kYm94SHRtbCAgICA9IHRoaXMuX2dldEh0bWwoe1xuICAgICAgICAgICAgY2hhcnNldDogICAgICBjaGFyc2V0LFxuICAgICAgICAgICAgc3R5bGVzaGVldHM6ICB0aGlzLmNvbmZpZy5zdHlsZXNoZWV0c1xuICAgICAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIGJhc2ljIGRvbSB0cmVlIGluY2x1ZGluZyBwcm9wZXIgRE9DVFlQRSBhbmQgY2hhcnNldFxuICAgICAgaWZyYW1lRG9jdW1lbnQub3BlbihcInRleHQvaHRtbFwiLCBcInJlcGxhY2VcIik7XG4gICAgICBpZnJhbWVEb2N1bWVudC53cml0ZShzYW5kYm94SHRtbCk7XG4gICAgICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuXG4gICAgICB0aGlzLmdldFdpbmRvdyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gaWZyYW1lLmNvbnRlbnRXaW5kb3c7IH07XG4gICAgICB0aGlzLmdldERvY3VtZW50ID0gZnVuY3Rpb24oKSB7IHJldHVybiBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDsgfTtcblxuICAgICAgLy8gQ2F0Y2gganMgZXJyb3JzIGFuZCBwYXNzIHRoZW0gdG8gdGhlIHBhcmVudCdzIG9uZXJyb3IgZXZlbnRcbiAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiKSBkb2Vzbid0IHdvcmsgcHJvcGVybHkgaW4gc29tZSBicm93c2Vyc1xuICAgICAgLy8gVE9ETzogYXBwYXJlbnRseSB0aGlzIGRvZXNuJ3Qgd29yayBpbiBJRTkhXG4gICAgICBpZnJhbWVXaW5kb3cub25lcnJvciA9IGZ1bmN0aW9uKGVycm9yTWVzc2FnZSwgZmlsZU5hbWUsIGxpbmVOdW1iZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid3lzaWh0bWw1LlNhbmRib3g6IFwiICsgZXJyb3JNZXNzYWdlLCBmaWxlTmFtZSwgbGluZU51bWJlcik7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIXd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzU2FuZGJveGVkSWZyYW1lcygpKSB7XG4gICAgICAgIC8vIFVuc2V0IGEgYnVuY2ggb2Ygc2Vuc2l0aXZlIHZhcmlhYmxlc1xuICAgICAgICAvLyBQbGVhc2Ugbm90ZTogVGhpcyBpc24ndCBoYWNrIHNhZmUhICBcbiAgICAgICAgLy8gSXQgbW9yZSBvciBsZXNzIGp1c3QgdGFrZXMgY2FyZSBvZiBiYXNpYyBhdHRhY2tzIGFuZCBwcmV2ZW50cyBhY2NpZGVudGFsIHRoZWZ0IG9mIHNlbnNpdGl2ZSBpbmZvcm1hdGlvblxuICAgICAgICAvLyBJRSBpcyBzZWN1cmUgdGhvdWdoLCB3aGljaCBpcyB0aGUgbW9zdCBpbXBvcnRhbnQgdGhpbmcsIHNpbmNlIElFIGlzIHRoZSBvbmx5IGJyb3dzZXIsIHdob1xuICAgICAgICAvLyB0YWtlcyBvdmVyIHNjcmlwdHMgJiBzdHlsZXMgaW50byBjb250ZW50RWRpdGFibGUgZWxlbWVudHMgd2hlbiBjb3BpZWQgZnJvbSBleHRlcm5hbCB3ZWJzaXRlc1xuICAgICAgICAvLyBvciBhcHBsaWNhdGlvbnMgKE1pY3Jvc29mdCBXb3JkLCAuLi4pXG4gICAgICAgIHZhciBpLCBsZW5ndGg7XG4gICAgICAgIGZvciAoaT0wLCBsZW5ndGg9d2luZG93UHJvcGVydGllcy5sZW5ndGg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl91bnNldChpZnJhbWVXaW5kb3csIHdpbmRvd1Byb3BlcnRpZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaT0wLCBsZW5ndGg9d2luZG93UHJvcGVydGllczIubGVuZ3RoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5fdW5zZXQoaWZyYW1lV2luZG93LCB3aW5kb3dQcm9wZXJ0aWVzMltpXSwgd3lzaWh0bWw1LkVNUFRZX0ZVTkNUSU9OKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGk9MCwgbGVuZ3RoPWRvY3VtZW50UHJvcGVydGllcy5sZW5ndGg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl91bnNldChpZnJhbWVEb2N1bWVudCwgZG9jdW1lbnRQcm9wZXJ0aWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGRvZXNuJ3Qgd29yayBpbiBTYWZhcmkgNSBcbiAgICAgICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTkyNDYxL2lzLWl0LXBvc3NpYmxlLXRvLW92ZXJyaWRlLWRvY3VtZW50LWNvb2tpZS1pbi13ZWJraXRcbiAgICAgICAgdGhpcy5fdW5zZXQoaWZyYW1lRG9jdW1lbnQsIFwiY29va2llXCIsIFwiXCIsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG5cbiAgICAgIC8vIFRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0aGF0LmNhbGxiYWNrKHRoYXQpOyB9LCAwKTtcbiAgICB9LFxuXG4gICAgX2dldEh0bWw6IGZ1bmN0aW9uKHRlbXBsYXRlVmFycykge1xuICAgICAgdmFyIHN0eWxlc2hlZXRzID0gdGVtcGxhdGVWYXJzLnN0eWxlc2hlZXRzLFxuICAgICAgICAgIGh0bWwgICAgICAgID0gXCJcIixcbiAgICAgICAgICBpICAgICAgICAgICA9IDAsXG4gICAgICAgICAgbGVuZ3RoO1xuICAgICAgc3R5bGVzaGVldHMgPSB0eXBlb2Yoc3R5bGVzaGVldHMpID09PSBcInN0cmluZ1wiID8gW3N0eWxlc2hlZXRzXSA6IHN0eWxlc2hlZXRzO1xuICAgICAgaWYgKHN0eWxlc2hlZXRzKSB7XG4gICAgICAgIGxlbmd0aCA9IHN0eWxlc2hlZXRzLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBodG1sICs9ICc8bGluayByZWw9XCJzdHlsZXNoZWV0XCIgaHJlZj1cIicgKyBzdHlsZXNoZWV0c1tpXSArICdcIj4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wbGF0ZVZhcnMuc3R5bGVzaGVldHMgPSBodG1sO1xuXG4gICAgICByZXR1cm4gd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKFxuICAgICAgICAnPCFET0NUWVBFIGh0bWw+PGh0bWw+PGhlYWQ+J1xuICAgICAgICArICc8bWV0YSBjaGFyc2V0PVwiI3tjaGFyc2V0fVwiPiN7c3R5bGVzaGVldHN9PC9oZWFkPidcbiAgICAgICAgKyAnPGJvZHk+PC9ib2R5PjwvaHRtbD4nXG4gICAgICApLmludGVycG9sYXRlKHRlbXBsYXRlVmFycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byB1bnNldC9vdmVycmlkZSBleGlzdGluZyB2YXJpYWJsZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIC8vIE1ha2UgY29va2llIHVucmVhZGFibGUgYW5kIHVud3JpdGFibGVcbiAgICAgKiAgICB0aGlzLl91bnNldChkb2N1bWVudCwgXCJjb29raWVcIiwgXCJcIiwgdHJ1ZSk7XG4gICAgICovXG4gICAgX3Vuc2V0OiBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgc2V0dGVyKSB7XG4gICAgICB0cnkgeyBvYmplY3RbcHJvcGVydHldID0gdmFsdWU7IH0gY2F0Y2goZSkge31cblxuICAgICAgdHJ5IHsgb2JqZWN0Ll9fZGVmaW5lR2V0dGVyX18ocHJvcGVydHksIGZ1bmN0aW9uKCkgeyByZXR1cm4gdmFsdWU7IH0pOyB9IGNhdGNoKGUpIHt9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHRyeSB7IG9iamVjdC5fX2RlZmluZVNldHRlcl9fKHByb3BlcnR5LCBmdW5jdGlvbigpIHt9KTsgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuXG4gICAgICBpZiAoIXd5c2lodG1sNS5icm93c2VyLmNyYXNoZXNXaGVuRGVmaW5lUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB2YWx1ZTsgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICAgICAgY29uZmlnLnNldCA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBjb25maWcpO1xuICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pKHd5c2lodG1sNSk7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBtYXBwaW5nID0ge1xuICAgIFwiY2xhc3NOYW1lXCI6IFwiY2xhc3NcIlxuICB9O1xuICB3eXNpaHRtbDUuZG9tLnNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG1hcHBpbmdbaV0gfHwgaSwgYXR0cmlidXRlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59KSgpO3d5c2lodG1sNS5kb20uc2V0U3R5bGVzID0gZnVuY3Rpb24oc3R5bGVzKSB7XG4gIHJldHVybiB7XG4gICAgb246IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgICBpZiAodHlwZW9mKHN0eWxlcykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3R5bGUuY3NzVGV4dCArPSBcIjtcIiArIHN0eWxlcztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSBpbiBzdHlsZXMpIHtcbiAgICAgICAgaWYgKGkgPT09IFwiZmxvYXRcIikge1xuICAgICAgICAgIHN0eWxlLmNzc0Zsb2F0ID0gc3R5bGVzW2ldO1xuICAgICAgICAgIHN0eWxlLnN0eWxlRmxvYXQgPSBzdHlsZXNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVbaV0gPSBzdHlsZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59Oy8qKlxuICogU2ltdWxhdGUgSFRNTDUgcGxhY2Vob2xkZXIgYXR0cmlidXRlXG4gKlxuICogTmVlZGVkIHNpbmNlXG4gKiAgICAtIGRpdltjb250ZW50RWRpdGFibGVdIGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaXRcbiAqICAgIC0gb2xkZXIgYnJvd3NlcnMgKHN1Y2ggYXMgSUU4IGFuZCBGaXJlZm94IDMuNikgZG9uJ3Qgc3VwcG9ydCBpdCBhdCBhbGxcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IEluc3RhbmNlIG9mIG1haW4gd3lzaWh0bWw1LkVkaXRvciBjbGFzc1xuICogQHBhcmFtIHtFbGVtZW50fSB2aWV3IEluc3RhbmNlIG9mIHd5c2lodG1sNS52aWV3cy4qIGNsYXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2Vob2xkZXJUZXh0XG4gKlxuICogQGV4YW1wbGVcbiAqICAgIHd5c2lodG1sLmRvbS5zaW11bGF0ZVBsYWNlaG9sZGVyKHRoaXMsIGNvbXBvc2VyLCBcIkZvb2JhclwiKTtcbiAqL1xuKGZ1bmN0aW9uKGRvbSkge1xuICBkb20uc2ltdWxhdGVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uKGVkaXRvciwgdmlldywgcGxhY2Vob2xkZXJUZXh0KSB7XG4gICAgdmFyIENMQVNTX05BTUUgPSBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIHVuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHZpZXcuaGFzUGxhY2Vob2xkZXJTZXQoKSkge1xuICAgICAgICAgICAgdmlldy5jbGVhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3Modmlldy5lbGVtZW50LCBDTEFTU19OQU1FKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHZpZXcuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB2aWV3LnNldFZhbHVlKHBsYWNlaG9sZGVyVGV4dCk7XG4gICAgICAgICAgICBkb20uYWRkQ2xhc3Modmlldy5lbGVtZW50LCBDTEFTU19OQU1FKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICBlZGl0b3JcbiAgICAgIC5vYnNlcnZlKFwic2V0X3BsYWNlaG9sZGVyXCIsIHNldClcbiAgICAgIC5vYnNlcnZlKFwidW5zZXRfcGxhY2Vob2xkZXJcIiwgdW5zZXQpXG4gICAgICAub2JzZXJ2ZShcImZvY3VzOmNvbXBvc2VyXCIsIHVuc2V0KVxuICAgICAgLm9ic2VydmUoXCJwYXN0ZTpjb21wb3NlclwiLCB1bnNldClcbiAgICAgIC5vYnNlcnZlKFwiYmx1cjpjb21wb3NlclwiLCBzZXQpO1xuXG4gICAgc2V0KCk7XG4gIH07XG59KSh3eXNpaHRtbDUuZG9tKTtcbihmdW5jdGlvbihkb20pIHtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgaWYgKFwidGV4dENvbnRlbnRcIiBpbiBkb2N1bWVudEVsZW1lbnQpIHtcbiAgICBkb20uc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbihlbGVtZW50LCB0ZXh0KSB7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICB9O1xuXG4gICAgZG9tLmdldFRleHRDb250ZW50ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChcImlubmVyVGV4dFwiIGluIGRvY3VtZW50RWxlbWVudCkge1xuICAgIGRvbS5zZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHRleHQpIHtcbiAgICAgIGVsZW1lbnQuaW5uZXJUZXh0ID0gdGV4dDtcbiAgICB9O1xuXG4gICAgZG9tLmdldFRleHRDb250ZW50ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuaW5uZXJUZXh0O1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZG9tLnNldFRleHRDb250ZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgdGV4dCkge1xuICAgICAgZWxlbWVudC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgIH07XG5cbiAgICBkb20uZ2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5ub2RlVmFsdWU7XG4gICAgfTtcbiAgfVxufSkod3lzaWh0bWw1LmRvbSk7XG5cbi8qKlxuICogRml4IG1vc3QgY29tbW9uIGh0bWwgZm9ybWF0dGluZyBtaXNiZWhhdmlvcnMgb2YgYnJvd3NlcnMgaW1wbGVtZW50YXRpb24gd2hlbiBpbnNlcnRpbmdcbiAqIGNvbnRlbnQgdmlhIGNvcHkgJiBwYXN0ZSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBAYXV0aG9yIENocmlzdG9waGVyIEJsdW1cbiAqL1xud3lzaWh0bWw1LnF1aXJrcy5jbGVhblBhc3RlZEhUTUwgPSAoZnVuY3Rpb24oKSB7XG4gIC8vIFRPRE86IFdlIHByb2JhYmx5IG5lZWQgbW9yZSBydWxlcyBoZXJlXG4gIHZhciBkZWZhdWx0UnVsZXMgPSB7XG4gICAgLy8gV2hlbiBwYXN0aW5nIHVuZGVybGluZWQgbGlua3MgPGE+IGludG8gYSBjb250ZW50RWRpdGFibGUsIElFIHRoaW5rcywgaXQgaGFzIHRvIGluc2VydCA8dT4gdG8ga2VlcCB0aGUgc3R5bGluZ1xuICAgIFwiYSB1XCI6IHd5c2lodG1sNS5kb20ucmVwbGFjZVdpdGhDaGlsZE5vZGVzXG4gIH07XG4gIFxuICBmdW5jdGlvbiBjbGVhblBhc3RlZEhUTUwoZWxlbWVudE9ySHRtbCwgcnVsZXMsIGNvbnRleHQpIHtcbiAgICBydWxlcyAgID0gcnVsZXMgfHwgZGVmYXVsdFJ1bGVzO1xuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGVsZW1lbnRPckh0bWwub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICBcbiAgICB2YXIgZWxlbWVudCxcbiAgICAgICAgaXNTdHJpbmcgPSB0eXBlb2YoZWxlbWVudE9ySHRtbCkgPT09IFwic3RyaW5nXCIsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbWF0Y2hlc0xlbmd0aCxcbiAgICAgICAgaSxcbiAgICAgICAgaiA9IDA7XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICBlbGVtZW50ID0gd3lzaWh0bWw1LmRvbS5nZXRBc0RvbShlbGVtZW50T3JIdG1sLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnRPckh0bWw7XG4gICAgfVxuICAgIFxuICAgIGZvciAoaSBpbiBydWxlcykge1xuICAgICAgbWF0Y2hlcyAgICAgICA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChpKTtcbiAgICAgIG1ldGhvZCAgICAgICAgPSBydWxlc1tpXTtcbiAgICAgIG1hdGNoZXNMZW5ndGggPSBtYXRjaGVzLmxlbmd0aDtcbiAgICAgIGZvciAoOyBqPG1hdGNoZXNMZW5ndGg7IGorKykge1xuICAgICAgICBtZXRob2QobWF0Y2hlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIG1hdGNoZXMgPSBlbGVtZW50T3JIdG1sID0gcnVsZXMgPSBudWxsO1xuICAgIFxuICAgIHJldHVybiBpc1N0cmluZyA/IGVsZW1lbnQuaW5uZXJIVE1MIDogZWxlbWVudDtcbiAgfVxuICBcbiAgcmV0dXJuIGNsZWFuUGFzdGVkSFRNTDtcbn0pKCk7LyoqXG4gKiBJRSBhbmQgT3BlcmEgbGVhdmUgYW4gZW1wdHkgcGFyYWdyYXBoIGluIHRoZSBjb250ZW50RWRpdGFibGUgZWxlbWVudCBhZnRlciBjbGVhcmluZyBpdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZW50RWRpdGFibGVFbGVtZW50IFRoZSBjb250ZW50RWRpdGFibGUgZWxlbWVudCB0byBvYnNlcnZlIGZvciBjbGVhcmluZyBldmVudHNcbiAqIEBleGFwbGVcbiAqICAgIHd5c2lodG1sNS5xdWlya3MuZW5zdXJlUHJvcGVyQ2xlYXJpbmcobXlDb250ZW50RWRpdGFibGVFbGVtZW50KTtcbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgZG9tID0gd3lzaWh0bWw1LmRvbTtcbiAgXG4gIHd5c2lodG1sNS5xdWlya3MuZW5zdXJlUHJvcGVyQ2xlYXJpbmcgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNsZWFySWZOZWNlc3NhcnkgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlubmVySFRNTCA9IGVsZW1lbnQuaW5uZXJIVE1MLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChpbm5lckhUTUwgPT0gXCI8cD4mbmJzcDs8L3A+XCIgfHxcbiAgICAgICAgICAgIGlubmVySFRNTCA9PSBcIjxwPiZuYnNwOzwvcD48cD4mbmJzcDs8L3A+XCIpIHtcbiAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oY29tcG9zZXIpIHtcbiAgICAgIGRvbS5vYnNlcnZlKGNvbXBvc2VyLmVsZW1lbnQsIFtcImN1dFwiLCBcImtleWRvd25cIl0sIGNsZWFySWZOZWNlc3NhcnkpO1xuICAgIH07XG4gIH0pKCk7XG5cblxuXG4gIC8qKlxuICAgKiBJbiBPcGVyYSB3aGVuIHRoZSBjYXJldCBpcyBpbiB0aGUgZmlyc3QgYW5kIG9ubHkgaXRlbSBvZiBhIGxpc3QgKDx1bD48bGk+fDwvbGk+PC91bD4pIGFuZCB0aGUgbGlzdCBpcyB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50LCBpdCdzIGltcG9zc2libGUgdG8gZGVsZXRlIHRoZSBsaXN0IGJ5IGhpdHRpbmcgYmFja3NwYWNlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZW50RWRpdGFibGVFbGVtZW50IFRoZSBjb250ZW50RWRpdGFibGUgZWxlbWVudCB0byBvYnNlcnZlIGZvciBjbGVhcmluZyBldmVudHNcbiAgICogQGV4YXBsZVxuICAgKiAgICB3eXNpaHRtbDUucXVpcmtzLmVuc3VyZVByb3BlckNsZWFyaW5nKG15Q29udGVudEVkaXRhYmxlRWxlbWVudCk7XG4gICAqL1xuICB3eXNpaHRtbDUucXVpcmtzLmVuc3VyZVByb3BlckNsZWFyaW5nT2ZMaXN0cyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgRUxFTUVOVFNfVEhBVF9DT05UQUlOX0xJID0gW1wiT0xcIiwgXCJVTFwiLCBcIk1FTlVcIl07XG5cbiAgICB2YXIgY2xlYXJJZk5lY2Vzc2FyeSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNvbnRlbnRFZGl0YWJsZUVsZW1lbnQpIHtcbiAgICAgIGlmICghY29udGVudEVkaXRhYmxlRWxlbWVudC5maXJzdENoaWxkIHx8ICF3eXNpaHRtbDUubGFuZy5hcnJheShFTEVNRU5UU19USEFUX0NPTlRBSU5fTEkpLmNvbnRhaW5zKGNvbnRlbnRFZGl0YWJsZUVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGlzdCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGVsZW1lbnQsIHsgbm9kZU5hbWU6IEVMRU1FTlRTX1RIQVRfQ09OVEFJTl9MSSB9KTtcbiAgICAgIGlmICghbGlzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBsaXN0SXNGaXJzdENoaWxkT2ZDb250ZW50RWRpdGFibGUgPSBsaXN0ID09IGNvbnRlbnRFZGl0YWJsZUVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgIGlmICghbGlzdElzRmlyc3RDaGlsZE9mQ29udGVudEVkaXRhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc09ubHlPbmVMaXN0SXRlbSA9IGxpc3QuY2hpbGROb2Rlcy5sZW5ndGggPD0gMTtcbiAgICAgIGlmICghaGFzT25seU9uZUxpc3RJdGVtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9ubHlMaXN0SXRlbUlzRW1wdHkgPSBsaXN0LmZpcnN0Q2hpbGQgPyBsaXN0LmZpcnN0Q2hpbGQuaW5uZXJIVE1MID09PSBcIlwiIDogdHJ1ZTtcbiAgICAgIGlmICghb25seUxpc3RJdGVtSXNFbXB0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxpc3QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaXN0KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNvbXBvc2VyKSB7XG4gICAgICBkb20ub2JzZXJ2ZShjb21wb3Nlci5lbGVtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgIT09IHd5c2lodG1sNS5CQUNLU1BBQ0VfS0VZKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICAgIGNsZWFySWZOZWNlc3NhcnkoZWxlbWVudCwgY29tcG9zZXIuZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9KSgpO1xuXG59KSh3eXNpaHRtbDUpO1xuLy8gU2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY2NDM5OFxuLy9cbi8vIEluIEZpcmVmb3ggdGhpczpcbi8vICAgICAgdmFyIGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuLy8gICAgICBkLmlubmVySFRNTCA9JzxhIGhyZWY9XCJ+XCI+PC9hPic7XG4vLyAgICAgIGQuaW5uZXJIVE1MO1xuLy8gd2lsbCByZXN1bHQgaW46XG4vLyAgICAgIDxhIGhyZWY9XCIlN0VcIj48L2E+XG4vLyB3aGljaCBpcyB3cm9uZ1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgVElMREVfRVNDQVBFRCA9IFwiJTdFXCI7XG4gIHd5c2lodG1sNS5xdWlya3MuZ2V0Q29ycmVjdElubmVySFRNTCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICB2YXIgaW5uZXJIVE1MID0gZWxlbWVudC5pbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTC5pbmRleE9mKFRJTERFX0VTQ0FQRUQpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGlubmVySFRNTDtcbiAgICB9XG4gICAgXG4gICAgdmFyIGVsZW1lbnRzV2l0aFRpbGRlID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2hyZWYqPSd+J10sIFtzcmMqPSd+J11cIiksXG4gICAgICAgIHVybCxcbiAgICAgICAgdXJsVG9TZWFyY2gsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgaTtcbiAgICBmb3IgKGk9MCwgbGVuZ3RoPWVsZW1lbnRzV2l0aFRpbGRlLmxlbmd0aDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgdXJsICAgICAgICAgPSBlbGVtZW50c1dpdGhUaWxkZVtpXS5ocmVmIHx8IGVsZW1lbnRzV2l0aFRpbGRlW2ldLnNyYztcbiAgICAgIHVybFRvU2VhcmNoID0gd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKHVybCkucmVwbGFjZShcIn5cIikuYnkoVElMREVfRVNDQVBFRCk7XG4gICAgICBpbm5lckhUTUwgICA9IHd5c2lodG1sNS5sYW5nLnN0cmluZyhpbm5lckhUTUwpLnJlcGxhY2UodXJsVG9TZWFyY2gpLmJ5KHVybCk7XG4gICAgfVxuICAgIHJldHVybiBpbm5lckhUTUw7XG4gIH07XG59KSh3eXNpaHRtbDUpOy8qKlxuICogU29tZSBicm93c2VycyBkb24ndCBpbnNlcnQgbGluZSBicmVha3Mgd2hlbiBoaXR0aW5nIHJldHVybiBpbiBhIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50XG4gKiAgICAtIE9wZXJhICYgSUUgaW5zZXJ0IG5ldyA8cD4gb24gcmV0dXJuXG4gKiAgICAtIENocm9tZSAmIFNhZmFyaSBpbnNlcnQgbmV3IDxkaXY+IG9uIHJldHVyblxuICogICAgLSBGaXJlZm94IGluc2VydHMgPGJyPiBvbiByZXR1cm4gKHlpcHBpZSEpXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKlxuICogQGV4YW1wbGVcbiAqICAgIHd5c2lodG1sNS5xdWlya3MuaW5zZXJ0TGluZUJyZWFrT25SZXR1cm4oZWxlbWVudCk7XG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIGRvbSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IHd5c2lodG1sNS5kb20sXG4gICAgICBVU0VfTkFUSVZFX0xJTkVfQlJFQUtfV0hFTl9DQVJFVF9JTlNJREVfVEFHUyAgPSBbXCJMSVwiLCBcIlBcIiwgXCJIMVwiLCBcIkgyXCIsIFwiSDNcIiwgXCJINFwiLCBcIkg1XCIsIFwiSDZcIl0sXG4gICAgICBMSVNUX1RBR1MgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBbXCJVTFwiLCBcIk9MXCIsIFwiTUVOVVwiXTtcbiAgXG4gIHd5c2lodG1sNS5xdWlya3MuaW5zZXJ0TGluZUJyZWFrT25SZXR1cm4gPSBmdW5jdGlvbihjb21wb3Nlcikge1xuICAgIGZ1bmN0aW9uIHVud3JhcChzZWxlY3RlZE5vZGUpIHtcbiAgICAgIHZhciBwYXJlbnRFbGVtZW50ID0gZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBbXCJQXCIsIFwiRElWXCJdIH0sIDIpO1xuICAgICAgaWYgKCFwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGludmlzaWJsZVNwYWNlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUod3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRSk7XG4gICAgICBkb20uaW5zZXJ0KGludmlzaWJsZVNwYWNlKS5iZWZvcmUocGFyZW50RWxlbWVudCk7XG4gICAgICBkb20ucmVwbGFjZVdpdGhDaGlsZE5vZGVzKHBhcmVudEVsZW1lbnQpO1xuICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNlbGVjdE5vZGUoaW52aXNpYmxlU3BhY2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleURvd24oZXZlbnQpIHtcbiAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgIGlmIChldmVudC5zaGlmdEtleSB8fCAoa2V5Q29kZSAhPT0gd3lzaWh0bWw1LkVOVEVSX0tFWSAmJiBrZXlDb2RlICE9PSB3eXNpaHRtbDUuQkFDS1NQQUNFX0tFWSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCAgICAgICAgID0gZXZlbnQudGFyZ2V0LFxuICAgICAgICAgIHNlbGVjdGVkTm9kZSAgICA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKSxcbiAgICAgICAgICBibG9ja0VsZW1lbnQgICAgPSBkb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHsgbm9kZU5hbWU6IFVTRV9OQVRJVkVfTElORV9CUkVBS19XSEVOX0NBUkVUX0lOU0lERV9UQUdTIH0sIDQpO1xuICAgICAgaWYgKGJsb2NrRWxlbWVudCkge1xuICAgICAgICAvLyBTb21lIGJyb3dzZXJzIGNyZWF0ZSA8cD4gZWxlbWVudHMgYWZ0ZXIgbGVhdmluZyBhIGxpc3RcbiAgICAgICAgLy8gY2hlY2sgYWZ0ZXIga2V5ZG93biBvZiBiYWNrc3BhY2UgYW5kIHJldHVybiB3aGV0aGVyIGEgPHA+IGdvdCBpbnNlcnRlZCBhbmQgdW53cmFwIGl0XG4gICAgICAgIGlmIChibG9ja0VsZW1lbnQubm9kZU5hbWUgPT09IFwiTElcIiAmJiAoa2V5Q29kZSA9PT0gd3lzaWh0bWw1LkVOVEVSX0tFWSB8fCBrZXlDb2RlID09PSB3eXNpaHRtbDUuQkFDS1NQQUNFX0tFWSkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKSxcbiAgICAgICAgICAgICAgICBsaXN0LFxuICAgICAgICAgICAgICAgIGRpdjtcbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWROb2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGlzdCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwge1xuICAgICAgICAgICAgICBub2RlTmFtZTogTElTVF9UQUdTXG4gICAgICAgICAgICB9LCAyKTtcblxuICAgICAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1bndyYXAoc2VsZWN0ZWROb2RlKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChibG9ja0VsZW1lbnQubm9kZU5hbWUubWF0Y2goL0hbMS02XS8pICYmIGtleUNvZGUgPT09IHd5c2lodG1sNS5FTlRFUl9LRVkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdW53cmFwKGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKSk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0gXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleUNvZGUgPT09IHd5c2lodG1sNS5FTlRFUl9LRVkgJiYgIXd5c2lodG1sNS5icm93c2VyLmluc2VydHNMaW5lQnJlYWtzT25SZXR1cm4oKSkge1xuICAgICAgICBjb21wb3Nlci5jb21tYW5kcy5leGVjKFwiaW5zZXJ0TGluZUJyZWFrXCIpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBrZXlwcmVzcyBkb2Vzbid0IGZpcmUgd2hlbiB5b3UgaGl0IGJhY2tzcGFjZVxuICAgIGRvbS5vYnNlcnZlKGNvbXBvc2VyLmVsZW1lbnQub3duZXJEb2N1bWVudCwgXCJrZXlkb3duXCIsIGtleURvd24pO1xuICB9O1xufSkod3lzaWh0bWw1KTsvKipcbiAqIEZvcmNlIHJlcmVuZGVyaW5nIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICogTmVlZGVkIHRvIGZpeCBkaXNwbGF5IG1pc2JlaGF2aW9ycyBvZiBJRVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBvYmplY3Qgd2hpY2ggbmVlZHMgdG8gYmUgcmVyZW5kZXJlZFxuICogQGV4YW1wbGVcbiAqICAgIHd5c2lodG1sNS5xdWlya3MucmVkcmF3KGRvY3VtZW50LmJvZHkpO1xuICovXG4oZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciBDTEFTU19OQU1FID0gXCJ3eXNpaHRtbDUtcXVpcmtzLXJlZHJhd1wiO1xuICBcbiAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgd3lzaWh0bWw1LmRvbS5hZGRDbGFzcyhlbGVtZW50LCBDTEFTU19OQU1FKTtcbiAgICB3eXNpaHRtbDUuZG9tLnJlbW92ZUNsYXNzKGVsZW1lbnQsIENMQVNTX05BTUUpO1xuICAgIFxuICAgIC8vIEZvbGxvd2luZyBoYWNrIGlzIG5lZWRlZCBmb3IgZmlyZWZveCB0byBtYWtlIHN1cmUgdGhhdCBpbWFnZSByZXNpemUgaGFuZGxlcyBhcmUgcHJvcGVybHkgcmVtb3ZlZFxuICAgIHRyeSB7XG4gICAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgICAgZG9jLmV4ZWNDb21tYW5kKFwiaXRhbGljXCIsIGZhbHNlLCBudWxsKTtcbiAgICAgIGRvYy5leGVjQ29tbWFuZChcIml0YWxpY1wiLCBmYWxzZSwgbnVsbCk7XG4gICAgfSBjYXRjaChlKSB7fVxuICB9O1xufSkod3lzaWh0bWw1KTsvKipcbiAqIFNlbGVjdGlvbiBBUElcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgdmFyIHNlbGVjdGlvbiA9IG5ldyB3eXNpaHRtbDUuU2VsZWN0aW9uKGVkaXRvcik7XG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIGRvbSA9IHd5c2lodG1sNS5kb207XG4gIFxuICBmdW5jdGlvbiBfZ2V0Q3VtdWxhdGl2ZU9mZnNldFRvcChlbGVtZW50KSB7XG4gICAgdmFyIHRvcCA9IDA7XG4gICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgZG8ge1xuICAgICAgICB0b3AgKz0gZWxlbWVudC5vZmZzZXRUb3AgfHwgMDtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgICAgfSB3aGlsZSAoZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0b3A7XG4gIH1cbiAgXG4gIHd5c2lodG1sNS5TZWxlY3Rpb24gPSBCYXNlLmV4dGVuZChcbiAgICAvKiogQHNjb3BlIHd5c2lodG1sNS5TZWxlY3Rpb24ucHJvdG90eXBlICovIHtcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCBvdXIgZXh0ZXJuYWwgcmFuZ2UgbGlicmFyeSBpcyBpbml0aWFsaXplZFxuICAgICAgd2luZG93LnJhbmd5LmluaXQoKTtcbiAgICAgIFxuICAgICAgdGhpcy5lZGl0b3IgICA9IGVkaXRvcjtcbiAgICAgIHRoaXMuY29tcG9zZXIgPSBlZGl0b3IuY29tcG9zZXI7XG4gICAgICB0aGlzLmRvYyAgICAgID0gdGhpcy5jb21wb3Nlci5kb2M7XG4gICAgfSxcbiAgICBcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGFzIGEgYm9va21hcmsgdG8gYmUgYWJsZSB0byBsYXRlciByZXN0b3JlIGl0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICovXG4gICAgZ2V0Qm9va21hcms6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpO1xuICAgICAgcmV0dXJuIHJhbmdlICYmIHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZSBhIHNlbGVjdGlvbiByZXRyaWV2ZWQgdmlhIHd5c2lodG1sNS5TZWxlY3Rpb24ucHJvdG90eXBlLmdldEJvb2ttYXJrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYm9va21hcmsgQW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICBzZXRCb29rbWFyazogZnVuY3Rpb24oYm9va21hcmspIHtcbiAgICAgIGlmICghYm9va21hcmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFNlbGVjdGlvbihib29rbWFyayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY2FyZXQgaW4gZnJvbnQgb2YgdGhlIGdpdmVuIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIFRoZSBlbGVtZW50IG9yIHRleHQgbm9kZSB3aGVyZSB0byBwb3NpdGlvbiB0aGUgY2FyZXQgaW4gZnJvbnQgb2ZcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHNlbGVjdGlvbi5zZXRCZWZvcmUobXlFbGVtZW50KTtcbiAgICAgKi9cbiAgICBzZXRCZWZvcmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciByYW5nZSA9IHJhbmd5LmNyZWF0ZVJhbmdlKHRoaXMuZG9jKTtcbiAgICAgIHJhbmdlLnNldFN0YXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgcmFuZ2Uuc2V0RW5kQmVmb3JlKG5vZGUpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0U2VsZWN0aW9uKHJhbmdlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjYXJldCBhZnRlciB0aGUgZ2l2ZW4gbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgVGhlIGVsZW1lbnQgb3IgdGV4dCBub2RlIHdoZXJlIHRvIHBvc2l0aW9uIHRoZSBjYXJldCBpbiBmcm9udCBvZlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgc2VsZWN0aW9uLnNldEJlZm9yZShteUVsZW1lbnQpO1xuICAgICAqL1xuICAgIHNldEFmdGVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmFuZ2UgPSByYW5neS5jcmVhdGVSYW5nZSh0aGlzLmRvYyk7XG4gICAgICByYW5nZS5zZXRTdGFydEFmdGVyKG5vZGUpO1xuICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIobm9kZSk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRTZWxlY3Rpb24ocmFuZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBYmlsaXR5IHRvIHNlbGVjdC9tYXJrIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgVGhlIG5vZGUvZWxlbWVudCB0byBzZWxlY3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHNlbGVjdGlvbi5zZWxlY3ROb2RlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXktaW1hZ2VcIikpO1xuICAgICAqL1xuICAgIHNlbGVjdE5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciByYW5nZSAgICAgICAgICAgPSByYW5neS5jcmVhdGVSYW5nZSh0aGlzLmRvYyksXG4gICAgICAgICAgaXNFbGVtZW50ICAgICAgID0gbm9kZS5ub2RlVHlwZSA9PT0gd3lzaWh0bWw1LkVMRU1FTlRfTk9ERSxcbiAgICAgICAgICBjYW5IYXZlSFRNTCAgICAgPSBcImNhbkhhdmVIVE1MXCIgaW4gbm9kZSA/IG5vZGUuY2FuSGF2ZUhUTUwgOiAobm9kZS5ub2RlTmFtZSAhPT0gXCJJTUdcIiksXG4gICAgICAgICAgY29udGVudCAgICAgICAgID0gaXNFbGVtZW50ID8gbm9kZS5pbm5lckhUTUwgOiBub2RlLmRhdGEsXG4gICAgICAgICAgaXNFbXB0eSAgICAgICAgID0gKGNvbnRlbnQgPT09IFwiXCIgfHwgY29udGVudCA9PT0gd3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRSksXG4gICAgICAgICAgZGlzcGxheVN0eWxlICAgID0gZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKG5vZGUpLFxuICAgICAgICAgIGlzQmxvY2tFbGVtZW50ICA9IChkaXNwbGF5U3R5bGUgPT09IFwiYmxvY2tcIiB8fCBkaXNwbGF5U3R5bGUgPT09IFwibGlzdC1pdGVtXCIpO1xuXG4gICAgICBpZiAoaXNFbXB0eSAmJiBpc0VsZW1lbnQgJiYgY2FuSGF2ZUhUTUwpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgY2FyZXQgaXMgdmlzaWJsZSBpbiBub2RlIGJ5IGluc2VydGluZyBhIHplcm8gd2lkdGggbm8gYnJlYWtpbmcgc3BhY2VcbiAgICAgICAgdHJ5IHsgbm9kZS5pbm5lckhUTUwgPSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFOyB9IGNhdGNoKGUpIHt9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5IYXZlSFRNTCkge1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuSGF2ZUhUTUwgJiYgaXNFbXB0eSAmJiBpc0VsZW1lbnQpIHtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2UoaXNCbG9ja0VsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChjYW5IYXZlSFRNTCAmJiBpc0VtcHR5KSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIobm9kZSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFNlbGVjdGlvbihyYW5nZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbm9kZSB3aGljaCBjb250YWlucyB0aGUgc2VsZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb250cm9sUmFuZ2VdIChvbmx5IElFKSBXaGV0aGVyIGl0IHNob3VsZCByZXR1cm4gdGhlIHNlbGVjdGVkIENvbnRyb2xSYW5nZSBlbGVtZW50IHdoZW4gdGhlIHNlbGVjdGlvbiB0eXBlIGlzIGEgXCJDb250cm9sUmFuZ2VcIlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5vZGUgdGhhdCBjb250YWlucyB0aGUgY2FyZXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHZhciBub2RlVGhhdENvbnRhaW5zQ2FyZXQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWROb2RlOiBmdW5jdGlvbihjb250cm9sUmFuZ2UpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24sXG4gICAgICAgICAgcmFuZ2U7XG5cbiAgICAgIGlmIChjb250cm9sUmFuZ2UgJiYgdGhpcy5kb2Muc2VsZWN0aW9uICYmIHRoaXMuZG9jLnNlbGVjdGlvbi50eXBlID09PSBcIkNvbnRyb2xcIikge1xuICAgICAgICByYW5nZSA9IHRoaXMuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICBpZiAocmFuZ2UgJiYgcmFuZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlLml0ZW0oMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24odGhpcy5kb2MpO1xuICAgICAgaWYgKHNlbGVjdGlvbi5mb2N1c05vZGUgPT09IHNlbGVjdGlvbi5hbmNob3JOb2RlKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb24uZm9jdXNOb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKHRoaXMuZG9jKTtcbiAgICAgICAgcmV0dXJuIHJhbmdlID8gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIgOiB0aGlzLmRvYy5ib2R5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBleGVjdXRlQW5kUmVzdG9yZTogZnVuY3Rpb24obWV0aG9kLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgIHZhciBib2R5ICAgICAgICAgICAgICAgICAgPSB0aGlzLmRvYy5ib2R5LFxuICAgICAgICAgIG9sZFNjcm9sbFRvcCAgICAgICAgICA9IHJlc3RvcmVTY3JvbGxQb3NpdGlvbiAmJiBib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICBvbGRTY3JvbGxMZWZ0ICAgICAgICAgPSByZXN0b3JlU2Nyb2xsUG9zaXRpb24gJiYgYm9keS5zY3JvbGxMZWZ0LFxuICAgICAgICAgIGNsYXNzTmFtZSAgICAgICAgICAgICA9IFwiX3d5c2lodG1sNS10ZW1wLXBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgcGxhY2Vob2xkZXJIVE1MICAgICAgID0gJzxzcGFuIGNsYXNzPVwiJyArIGNsYXNzTmFtZSArICdcIj4nICsgd3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRSArICc8L3NwYW4+JyxcbiAgICAgICAgICByYW5nZSAgICAgICAgICAgICAgICAgPSB0aGlzLmdldFJhbmdlKHRoaXMuZG9jKSxcbiAgICAgICAgICBuZXdSYW5nZTtcbiAgICAgIFxuICAgICAgLy8gTm90aGluZyBzZWxlY3RlZCwgZXhlY3V0ZSBhbmQgc2F5IGdvb2RieWVcbiAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgbWV0aG9kKGJvZHksIGJvZHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBub2RlID0gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHBsYWNlaG9sZGVySFRNTCk7XG4gICAgICByYW5nZS5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCBhIHBvdGVudGlhbCBlcnJvciBkb2Vzbid0IGNhdXNlIG91ciBwbGFjZWhvbGRlciBlbGVtZW50IHRvIGJlIGxlZnQgYXMgYSBwbGFjZWhvbGRlclxuICAgICAgdHJ5IHtcbiAgICAgICAgbWV0aG9kKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5lbmRDb250YWluZXIpO1xuICAgICAgfSBjYXRjaChlMykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0aHJvdyBlMzsgfSwgMCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNhcmV0UGxhY2Vob2xkZXIgPSB0aGlzLmRvYy5xdWVyeVNlbGVjdG9yKFwiLlwiICsgY2xhc3NOYW1lKTtcbiAgICAgIGlmIChjYXJldFBsYWNlaG9sZGVyKSB7XG4gICAgICAgIG5ld1JhbmdlID0gcmFuZ3kuY3JlYXRlUmFuZ2UodGhpcy5kb2MpO1xuICAgICAgICBuZXdSYW5nZS5zZWxlY3ROb2RlKGNhcmV0UGxhY2Vob2xkZXIpO1xuICAgICAgICBuZXdSYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihuZXdSYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmYWxsYmFjayBmb3Igd2hlbiBhbGwgaGVsbCBicmVha3MgbG9vc2VcbiAgICAgICAgYm9keS5mb2N1cygpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdG9yZVNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICAgIGJvZHkuc2Nyb2xsVG9wICA9IG9sZFNjcm9sbFRvcDtcbiAgICAgICAgYm9keS5zY3JvbGxMZWZ0ID0gb2xkU2Nyb2xsTGVmdDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGl0IGFnYWluLCBqdXN0IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBwbGFjZWhvbGRlciBpcyBkZWZpbml0ZWx5IG91dCBvZiB0aGUgZG9tIHRyZWVcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhcmV0UGxhY2Vob2xkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjYXJldFBsYWNlaG9sZGVyKTtcbiAgICAgIH0gY2F0Y2goZTQpIHt9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpZmZlcmVudCBhcHByb2FjaCBvZiBwcmVzZXJ2aW5nIHRoZSBzZWxlY3Rpb24gKGRvZXNuJ3QgbW9kaWZ5IHRoZSBkb20pXG4gICAgICogVGFrZXMgYWxsIHRleHQgbm9kZXMgaW4gdGhlIHNlbGVjdGlvbiBhbmQgc2F2ZXMgdGhlIHNlbGVjdGlvbiBwb3NpdGlvbiBpbiB0aGUgZmlyc3QgYW5kIGxhc3Qgb25lXG4gICAgICovXG4gICAgZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGU6IGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpLFxuICAgICAgICAgIGJvZHkgID0gdGhpcy5kb2MuYm9keSxcbiAgICAgICAgICBuZXdSYW5nZSxcbiAgICAgICAgICBmaXJzdE5vZGUsXG4gICAgICAgICAgbGFzdE5vZGUsXG4gICAgICAgICAgdGV4dE5vZGVzLFxuICAgICAgICAgIHJhbmdlQmFja3VwO1xuXG4gICAgICAvLyBOb3RoaW5nIHNlbGVjdGVkLCBleGVjdXRlIGFuZCBzYXkgZ29vZGJ5ZVxuICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICBtZXRob2QoYm9keSwgYm9keSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGV4dE5vZGVzID0gcmFuZ2UuZ2V0Tm9kZXMoWzNdKTtcbiAgICAgIGZpcnN0Tm9kZSA9IHRleHROb2Rlc1swXSB8fCByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgIGxhc3ROb2RlICA9IHRleHROb2Rlc1t0ZXh0Tm9kZXMubGVuZ3RoIC0gMV0gfHwgcmFuZ2UuZW5kQ29udGFpbmVyO1xuXG4gICAgICByYW5nZUJhY2t1cCA9IHtcbiAgICAgICAgY29sbGFwc2VkOiAgICAgIHJhbmdlLmNvbGxhcHNlZCxcbiAgICAgICAgc3RhcnRDb250YWluZXI6IGZpcnN0Tm9kZSxcbiAgICAgICAgc3RhcnRPZmZzZXQ6ICAgIGZpcnN0Tm9kZSA9PT0gcmFuZ2Uuc3RhcnRDb250YWluZXIgPyByYW5nZS5zdGFydE9mZnNldCA6IDAsXG4gICAgICAgIGVuZENvbnRhaW5lcjogICBsYXN0Tm9kZSxcbiAgICAgICAgZW5kT2Zmc2V0OiAgICAgIGxhc3ROb2RlID09PSByYW5nZS5lbmRDb250YWluZXIgPyByYW5nZS5lbmRPZmZzZXQgOiBsYXN0Tm9kZS5sZW5ndGhcbiAgICAgIH07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG1ldGhvZChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2UuZW5kQ29udGFpbmVyKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0aHJvdyBlOyB9LCAwKTtcbiAgICAgIH1cblxuICAgICAgbmV3UmFuZ2UgPSByYW5neS5jcmVhdGVSYW5nZSh0aGlzLmRvYyk7XG4gICAgICB0cnkgeyBuZXdSYW5nZS5zZXRTdGFydChyYW5nZUJhY2t1cC5zdGFydENvbnRhaW5lciwgcmFuZ2VCYWNrdXAuc3RhcnRPZmZzZXQpOyB9IGNhdGNoKGUxKSB7fVxuICAgICAgdHJ5IHsgbmV3UmFuZ2Uuc2V0RW5kKHJhbmdlQmFja3VwLmVuZENvbnRhaW5lciwgcmFuZ2VCYWNrdXAuZW5kT2Zmc2V0KTsgfSBjYXRjaChlMikge31cbiAgICAgIHRyeSB7IHRoaXMuc2V0U2VsZWN0aW9uKG5ld1JhbmdlKTsgfSBjYXRjaChlMykge31cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGh0bWwgYXQgdGhlIGNhcmV0IHBvc2l0aW9uIGFuZCBtb3ZlIHRoZSBjdXJzb3IgYWZ0ZXIgdGhlIGluc2VydGVkIGh0bWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIEhUTUwgc3RyaW5nIHRvIGluc2VydFxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgc2VsZWN0aW9uLmluc2VydEhUTUwoXCI8cD5mb29iYXI8L3A+XCIpO1xuICAgICAqL1xuICAgIGluc2VydEhUTUw6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgIHZhciByYW5nZSAgICAgPSByYW5neS5jcmVhdGVSYW5nZSh0aGlzLmRvYyksXG4gICAgICAgICAgbm9kZSAgICAgID0gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KGh0bWwpLFxuICAgICAgICAgIGxhc3RDaGlsZCA9IG5vZGUubGFzdENoaWxkO1xuICAgICAgdGhpcy5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgaWYgKGxhc3RDaGlsZCkge1xuICAgICAgICB0aGlzLnNldEFmdGVyKGxhc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5vZGUgYXQgdGhlIGNhcmV0IHBvc2l0aW9uIGFuZCBtb3ZlIHRoZSBjdXJzb3IgYmVoaW5kIGl0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBIVE1MIHN0cmluZyB0byBpbnNlcnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHNlbGVjdGlvbi5pbnNlcnROb2RlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiZm9vYmFyXCIpKTtcbiAgICAgKi9cbiAgICBpbnNlcnROb2RlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKCk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShub2RlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgY3VycmVudCBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgVGhlIG5vZGUgdG8gc3Vycm91bmQgdGhlIHNlbGVjdGVkIGVsZW1lbnRzIHdpdGhcbiAgICAgKi9cbiAgICBzdXJyb3VuZDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpO1xuICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgb25seSB3b3JrcyB3aGVuIHRoZSByYW5nZSBib3VuZGFyaWVzIGFyZSBub3Qgb3ZlcmxhcHBpbmcgb3RoZXIgZWxlbWVudHNcbiAgICAgICAgcmFuZ2Uuc3Vycm91bmRDb250ZW50cyhub2RlKTtcbiAgICAgICAgdGhpcy5zZWxlY3ROb2RlKG5vZGUpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIC8vIGZhbGxiYWNrXG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQocmFuZ2UuZXh0cmFjdENvbnRlbnRzKCkpO1xuICAgICAgICByYW5nZS5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGwgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24gaW50byB0aGUgdmlld1xuICAgICAqIEZJWE1FOiBUaGlzIGlzIGEgYml0IGhhY2t5LCB0aGVyZSBtaWdodCBiZSBhIHNtYXJ0ZXIgd2F5IG9mIGRvaW5nIHRoaXNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgc2VsZWN0aW9uLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICovXG4gICAgc2Nyb2xsSW50b1ZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRvYyAgICAgICAgICAgPSB0aGlzLmRvYyxcbiAgICAgICAgICBoYXNTY3JvbGxCYXJzID0gZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2MuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCxcbiAgICAgICAgICB0ZW1wRWxlbWVudCAgID0gZG9jLl93eXNpaHRtbDVTY3JvbGxJbnRvVmlld0VsZW1lbnQgPSBkb2MuX3d5c2lodG1sNVNjcm9sbEludG9WaWV3RWxlbWVudCB8fCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IG5lZWRzIGNvbnRlbnQgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgaXQncyBwb3NpdGlvbiBwcm9wZXJseVxuICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgfSkoKSxcbiAgICAgICAgICBvZmZzZXRUb3A7XG5cbiAgICAgIGlmIChoYXNTY3JvbGxCYXJzKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0Tm9kZSh0ZW1wRWxlbWVudCk7XG4gICAgICAgIG9mZnNldFRvcCA9IF9nZXRDdW11bGF0aXZlT2Zmc2V0VG9wKHRlbXBFbGVtZW50KTtcbiAgICAgICAgdGVtcEVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZW1wRWxlbWVudCk7XG4gICAgICAgIGlmIChvZmZzZXRUb3AgPiBkb2MuYm9keS5zY3JvbGxUb3ApIHtcbiAgICAgICAgICBkb2MuYm9keS5zY3JvbGxUb3AgPSBvZmZzZXRUb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGxpbmUgd2hlcmUgdGhlIGNhcmV0IGlzIGluXG4gICAgICovXG4gICAgc2VsZWN0TGluZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAod3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNTZWxlY3Rpb25Nb2RpZnkoKSkge1xuICAgICAgICB0aGlzLl9zZWxlY3RMaW5lX1czQygpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRvYy5zZWxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0TGluZV9NU0lFKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vU2VsZWN0aW9uL21vZGlmeVxuICAgICAqL1xuICAgIF9zZWxlY3RMaW5lX1czQzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgd2luICAgICAgID0gdGhpcy5kb2MuZGVmYXVsdFZpZXcsXG4gICAgICAgICAgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbigpO1xuICAgICAgc2VsZWN0aW9uLm1vZGlmeShcImV4dGVuZFwiLCBcImxlZnRcIiwgXCJsaW5lYm91bmRhcnlcIik7XG4gICAgICBzZWxlY3Rpb24ubW9kaWZ5KFwiZXh0ZW5kXCIsIFwicmlnaHRcIiwgXCJsaW5lYm91bmRhcnlcIik7XG4gICAgfSxcblxuICAgIF9zZWxlY3RMaW5lX01TSUU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJhbmdlICAgICAgID0gdGhpcy5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCksXG4gICAgICAgICAgcmFuZ2VUb3AgICAgPSByYW5nZS5ib3VuZGluZ1RvcCxcbiAgICAgICAgICByYW5nZUhlaWdodCA9IHJhbmdlLmJvdW5kaW5nSGVpZ2h0LFxuICAgICAgICAgIHNjcm9sbFdpZHRoID0gdGhpcy5kb2MuYm9keS5zY3JvbGxXaWR0aCxcbiAgICAgICAgICByYW5nZUJvdHRvbSxcbiAgICAgICAgICByYW5nZUVuZCxcbiAgICAgICAgICBtZWFzdXJlTm9kZSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGo7XG5cbiAgICAgIGlmICghcmFuZ2UubW92ZVRvUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocmFuZ2VUb3AgPT09IDApIHtcbiAgICAgICAgLy8gRG9uJ3Qga25vdyB3aHksIGJ1dCB3aGVuIHRoZSBzZWxlY3Rpb24gZW5kcyBhdCB0aGUgZW5kIG9mIGEgbGluZVxuICAgICAgICAvLyByYW5nZS5ib3VuZGluZ1RvcCBpcyAwXG4gICAgICAgIG1lYXN1cmVOb2RlID0gdGhpcy5kb2MuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHRoaXMuaW5zZXJ0Tm9kZShtZWFzdXJlTm9kZSk7XG4gICAgICAgIHJhbmdlVG9wID0gbWVhc3VyZU5vZGUub2Zmc2V0VG9wO1xuICAgICAgICBtZWFzdXJlTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG1lYXN1cmVOb2RlKTtcbiAgICAgIH1cblxuICAgICAgcmFuZ2VUb3AgKz0gMTtcblxuICAgICAgZm9yIChpPS0xMDsgaTxzY3JvbGxXaWR0aDsgaSs9Mikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJhbmdlLm1vdmVUb1BvaW50KGksIHJhbmdlVG9wKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBjYXRjaChlMSkge31cbiAgICAgIH1cblxuICAgICAgLy8gSW52ZXN0aWdhdGUgdGhlIGZvbGxvd2luZyBpbiBvcmRlciB0byBoYW5kbGUgbXVsdGkgbGluZSBzZWxlY3Rpb25zXG4gICAgICAvLyByYW5nZUJvdHRvbSA9IHJhbmdlVG9wICsgKHJhbmdlSGVpZ2h0ID8gKHJhbmdlSGVpZ2h0IC0gMSkgOiAwKTtcbiAgICAgIHJhbmdlQm90dG9tID0gcmFuZ2VUb3A7XG4gICAgICByYW5nZUVuZCA9IHRoaXMuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgZm9yIChqPXNjcm9sbFdpZHRoOyBqPj0wOyBqLS0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByYW5nZUVuZC5tb3ZlVG9Qb2ludChqLCByYW5nZUJvdHRvbSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gY2F0Y2goZTIpIHt9XG4gICAgICB9XG5cbiAgICAgIHJhbmdlLnNldEVuZFBvaW50KFwiRW5kVG9FbmRcIiwgcmFuZ2VFbmQpO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfSxcblxuICAgIGdldFRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uID8gc2VsZWN0aW9uLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgIH0sXG5cbiAgICBnZXROb2RlczogZnVuY3Rpb24obm9kZVR5cGUsIGZpbHRlcikge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZS5nZXROb2Rlcyhbbm9kZVR5cGVdLCBmaWx0ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgZ2V0UmFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5yYW5nZUNvdW50ICYmIHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmd5LmdldFNlbGVjdGlvbih0aGlzLmRvYy5kZWZhdWx0VmlldyB8fCB0aGlzLmRvYy5wYXJlbnRXaW5kb3cpO1xuICAgIH0sXG5cbiAgICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICB2YXIgd2luICAgICAgID0gdGhpcy5kb2MuZGVmYXVsdFZpZXcgfHwgdGhpcy5kb2MucGFyZW50V2luZG93LFxuICAgICAgICAgIHNlbGVjdGlvbiA9IHJhbmd5LmdldFNlbGVjdGlvbih3aW4pO1xuICAgICAgcmV0dXJuIHNlbGVjdGlvbi5zZXRTaW5nbGVSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9KTtcbiAgXG59KSh3eXNpaHRtbDUpO1xuLyoqXG4gKiBJbnNwaXJlZCBieSB0aGUgcmFuZ3kgQ1NTIEFwcGxpZXIgbW9kdWxlIHdyaXR0ZW4gYnkgVGltIERvd24gYW5kIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9yYW5neS9cbiAqXG4gKiBjaGFuZ2VkIGluIG9yZGVyIHRvIGJlIGFibGUgLi4uXG4gKiAgICAtIHRvIHVzZSBjdXN0b20gdGFnc1xuICogICAgLSB0byBkZXRlY3QgYW5kIHJlcGxhY2Ugc2ltaWxhciBjc3MgY2xhc3NlcyB2aWEgcmVnIGV4cFxuICovXG4oZnVuY3Rpb24od3lzaWh0bWw1LCByYW5neSkge1xuICB2YXIgZGVmYXVsdFRhZ05hbWUgPSBcInNwYW5cIjtcbiAgXG4gIHZhciBSRUdfRVhQX1dISVRFX1NQQUNFID0gL1xccysvZztcbiAgXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBjc3NDbGFzcywgcmVnRXhwKSB7XG4gICAgaWYgKCFlbC5jbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgdmFyIG1hdGNoaW5nQ2xhc3NOYW1lcyA9IGVsLmNsYXNzTmFtZS5tYXRjaChyZWdFeHApIHx8IFtdO1xuICAgIHJldHVybiBtYXRjaGluZ0NsYXNzTmFtZXNbbWF0Y2hpbmdDbGFzc05hbWVzLmxlbmd0aCAtIDFdID09PSBjc3NDbGFzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjc3NDbGFzcywgcmVnRXhwKSB7XG4gICAgaWYgKGVsLmNsYXNzTmFtZSkge1xuICAgICAgcmVtb3ZlQ2xhc3MoZWwsIHJlZ0V4cCk7XG4gICAgICBlbC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjc3NDbGFzcztcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NOYW1lID0gY3NzQ2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIHJlZ0V4cCkge1xuICAgIGlmIChlbC5jbGFzc05hbWUpIHtcbiAgICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKHJlZ0V4cCwgXCJcIik7XG4gICAgfVxuICB9XG4gIFxuICBmdW5jdGlvbiBoYXNTYW1lQ2xhc3NlcyhlbDEsIGVsMikge1xuICAgIHJldHVybiBlbDEuY2xhc3NOYW1lLnJlcGxhY2UoUkVHX0VYUF9XSElURV9TUEFDRSwgXCIgXCIpID09IGVsMi5jbGFzc05hbWUucmVwbGFjZShSRUdfRVhQX1dISVRFX1NQQUNFLCBcIiBcIik7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlV2l0aE93bkNoaWxkcmVuKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWwuZmlyc3RDaGlsZCwgZWwpO1xuICAgIH1cbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZWxlbWVudHNIYXZlU2FtZU5vbkNsYXNzQXR0cmlidXRlcyhlbDEsIGVsMikge1xuICAgIGlmIChlbDEuYXR0cmlidXRlcy5sZW5ndGggIT0gZWwyLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbDEuYXR0cmlidXRlcy5sZW5ndGgsIGF0dHIxLCBhdHRyMiwgbmFtZTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhdHRyMSA9IGVsMS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgbmFtZSA9IGF0dHIxLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBcImNsYXNzXCIpIHtcbiAgICAgICAgYXR0cjIgPSBlbDIuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0obmFtZSk7XG4gICAgICAgIGlmIChhdHRyMS5zcGVjaWZpZWQgIT0gYXR0cjIuc3BlY2lmaWVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyMS5zcGVjaWZpZWQgJiYgYXR0cjEubm9kZVZhbHVlICE9PSBhdHRyMi5ub2RlVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NwbGl0UG9pbnQobm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKHJhbmd5LmRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpKSB7XG4gICAgICBpZiAob2Zmc2V0ID09IDApIHtcbiAgICAgICAgcmV0dXJuICEhbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCA9PSBub2RlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gISFub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCA+IDAgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGl0Tm9kZUF0KG5vZGUsIGRlc2NlbmRhbnROb2RlLCBkZXNjZW5kYW50T2Zmc2V0KSB7XG4gICAgdmFyIG5ld05vZGU7XG4gICAgaWYgKHJhbmd5LmRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKGRlc2NlbmRhbnROb2RlKSkge1xuICAgICAgaWYgKGRlc2NlbmRhbnRPZmZzZXQgPT0gMCkge1xuICAgICAgICBkZXNjZW5kYW50T2Zmc2V0ID0gcmFuZ3kuZG9tLmdldE5vZGVJbmRleChkZXNjZW5kYW50Tm9kZSk7XG4gICAgICAgIGRlc2NlbmRhbnROb2RlID0gZGVzY2VuZGFudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVzY2VuZGFudE9mZnNldCA9PSBkZXNjZW5kYW50Tm9kZS5sZW5ndGgpIHtcbiAgICAgICAgZGVzY2VuZGFudE9mZnNldCA9IHJhbmd5LmRvbS5nZXROb2RlSW5kZXgoZGVzY2VuZGFudE5vZGUpICsgMTtcbiAgICAgICAgZGVzY2VuZGFudE5vZGUgPSBkZXNjZW5kYW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3Tm9kZSA9IHJhbmd5LmRvbS5zcGxpdERhdGFOb2RlKGRlc2NlbmRhbnROb2RlLCBkZXNjZW5kYW50T2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFuZXdOb2RlKSB7XG4gICAgICBuZXdOb2RlID0gZGVzY2VuZGFudE5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgIGlmIChuZXdOb2RlLmlkKSB7XG4gICAgICAgIG5ld05vZGUucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICB3aGlsZSAoKGNoaWxkID0gZGVzY2VuZGFudE5vZGUuY2hpbGROb2Rlc1tkZXNjZW5kYW50T2Zmc2V0XSkpIHtcbiAgICAgICAgbmV3Tm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgICByYW5neS5kb20uaW5zZXJ0QWZ0ZXIobmV3Tm9kZSwgZGVzY2VuZGFudE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gKGRlc2NlbmRhbnROb2RlID09IG5vZGUpID8gbmV3Tm9kZSA6IHNwbGl0Tm9kZUF0KG5vZGUsIG5ld05vZGUucGFyZW50Tm9kZSwgcmFuZ3kuZG9tLmdldE5vZGVJbmRleChuZXdOb2RlKSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIE1lcmdlKGZpcnN0Tm9kZSkge1xuICAgIHRoaXMuaXNFbGVtZW50TWVyZ2UgPSAoZmlyc3ROb2RlLm5vZGVUeXBlID09IHd5c2lodG1sNS5FTEVNRU5UX05PREUpO1xuICAgIHRoaXMuZmlyc3RUZXh0Tm9kZSA9IHRoaXMuaXNFbGVtZW50TWVyZ2UgPyBmaXJzdE5vZGUubGFzdENoaWxkIDogZmlyc3ROb2RlO1xuICAgIHRoaXMudGV4dE5vZGVzID0gW3RoaXMuZmlyc3RUZXh0Tm9kZV07XG4gIH1cblxuICBNZXJnZS5wcm90b3R5cGUgPSB7XG4gICAgZG9NZXJnZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGV4dEJpdHMgPSBbXSwgdGV4dE5vZGUsIHBhcmVudCwgdGV4dDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnRleHROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB0ZXh0Tm9kZSA9IHRoaXMudGV4dE5vZGVzW2ldO1xuICAgICAgICBwYXJlbnQgPSB0ZXh0Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB0ZXh0Qml0c1tpXSA9IHRleHROb2RlLmRhdGE7XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgICBpZiAoIXBhcmVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmZpcnN0VGV4dE5vZGUuZGF0YSA9IHRleHQgPSB0ZXh0Qml0cy5qb2luKFwiXCIpO1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSxcblxuICAgIGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IHRoaXMudGV4dE5vZGVzLmxlbmd0aCwgbGVuID0gMDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgbGVuICs9IHRoaXMudGV4dE5vZGVzW2ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW47XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0ZXh0Qml0cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMudGV4dE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHRleHRCaXRzW2ldID0gXCInXCIgKyB0aGlzLnRleHROb2Rlc1tpXS5kYXRhICsgXCInXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJbTWVyZ2UoXCIgKyB0ZXh0Qml0cy5qb2luKFwiLFwiKSArIFwiKV1cIjtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSFRNTEFwcGxpZXIodGFnTmFtZXMsIGNzc0NsYXNzLCBzaW1pbGFyQ2xhc3NSZWdFeHAsIG5vcm1hbGl6ZSkge1xuICAgIHRoaXMudGFnTmFtZXMgPSB0YWdOYW1lcyB8fCBbZGVmYXVsdFRhZ05hbWVdO1xuICAgIHRoaXMuY3NzQ2xhc3MgPSBjc3NDbGFzcyB8fCBcIlwiO1xuICAgIHRoaXMuc2ltaWxhckNsYXNzUmVnRXhwID0gc2ltaWxhckNsYXNzUmVnRXhwO1xuICAgIHRoaXMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuICAgIHRoaXMuYXBwbHlUb0FueVRhZ05hbWUgPSBmYWxzZTtcbiAgfVxuXG4gIEhUTUxBcHBsaWVyLnByb3RvdHlwZSA9IHtcbiAgICBnZXRBbmNlc3RvcldpdGhDbGFzczogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGNzc0NsYXNzTWF0Y2g7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBjc3NDbGFzc01hdGNoID0gdGhpcy5jc3NDbGFzcyA/IGhhc0NsYXNzKG5vZGUsIHRoaXMuY3NzQ2xhc3MsIHRoaXMuc2ltaWxhckNsYXNzUmVnRXhwKSA6IHRydWU7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IHd5c2lodG1sNS5FTEVNRU5UX05PREUgJiYgcmFuZ3kuZG9tLmFycmF5Q29udGFpbnModGhpcy50YWdOYW1lcywgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmIGNzc0NsYXNzTWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBOb3JtYWxpemVzIG5vZGVzIGFmdGVyIGFwcGx5aW5nIGEgQ1NTIGNsYXNzIHRvIGEgUmFuZ2UuXG4gICAgcG9zdEFwcGx5OiBmdW5jdGlvbih0ZXh0Tm9kZXMsIHJhbmdlKSB7XG4gICAgICB2YXIgZmlyc3ROb2RlID0gdGV4dE5vZGVzWzBdLCBsYXN0Tm9kZSA9IHRleHROb2Rlc1t0ZXh0Tm9kZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgIHZhciBtZXJnZXMgPSBbXSwgY3VycmVudE1lcmdlO1xuXG4gICAgICB2YXIgcmFuZ2VTdGFydE5vZGUgPSBmaXJzdE5vZGUsIHJhbmdlRW5kTm9kZSA9IGxhc3ROb2RlO1xuICAgICAgdmFyIHJhbmdlU3RhcnRPZmZzZXQgPSAwLCByYW5nZUVuZE9mZnNldCA9IGxhc3ROb2RlLmxlbmd0aDtcblxuICAgICAgdmFyIHRleHROb2RlLCBwcmVjZWRpbmdUZXh0Tm9kZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB0ZXh0Tm9kZSA9IHRleHROb2Rlc1tpXTtcbiAgICAgICAgcHJlY2VkaW5nVGV4dE5vZGUgPSB0aGlzLmdldEFkamFjZW50TWVyZ2VhYmxlVGV4dE5vZGUodGV4dE5vZGUucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICBpZiAocHJlY2VkaW5nVGV4dE5vZGUpIHtcbiAgICAgICAgICBpZiAoIWN1cnJlbnRNZXJnZSkge1xuICAgICAgICAgICAgY3VycmVudE1lcmdlID0gbmV3IE1lcmdlKHByZWNlZGluZ1RleHROb2RlKTtcbiAgICAgICAgICAgIG1lcmdlcy5wdXNoKGN1cnJlbnRNZXJnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRNZXJnZS50ZXh0Tm9kZXMucHVzaCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgaWYgKHRleHROb2RlID09PSBmaXJzdE5vZGUpIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnROb2RlID0gY3VycmVudE1lcmdlLmZpcnN0VGV4dE5vZGU7XG4gICAgICAgICAgICByYW5nZVN0YXJ0T2Zmc2V0ID0gcmFuZ2VTdGFydE5vZGUubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGV4dE5vZGUgPT09IGxhc3ROb2RlKSB7XG4gICAgICAgICAgICByYW5nZUVuZE5vZGUgPSBjdXJyZW50TWVyZ2UuZmlyc3RUZXh0Tm9kZTtcbiAgICAgICAgICAgIHJhbmdlRW5kT2Zmc2V0ID0gY3VycmVudE1lcmdlLmdldExlbmd0aCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50TWVyZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRlc3Qgd2hldGhlciB0aGUgZmlyc3Qgbm9kZSBhZnRlciB0aGUgcmFuZ2UgbmVlZHMgbWVyZ2luZ1xuICAgICAgdmFyIG5leHRUZXh0Tm9kZSA9IHRoaXMuZ2V0QWRqYWNlbnRNZXJnZWFibGVUZXh0Tm9kZShsYXN0Tm9kZS5wYXJlbnROb2RlLCB0cnVlKTtcbiAgICAgIGlmIChuZXh0VGV4dE5vZGUpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50TWVyZ2UpIHtcbiAgICAgICAgICBjdXJyZW50TWVyZ2UgPSBuZXcgTWVyZ2UobGFzdE5vZGUpO1xuICAgICAgICAgIG1lcmdlcy5wdXNoKGN1cnJlbnRNZXJnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudE1lcmdlLnRleHROb2Rlcy5wdXNoKG5leHRUZXh0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERvIHRoZSBtZXJnZXNcbiAgICAgIGlmIChtZXJnZXMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG1lcmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIG1lcmdlc1tpXS5kb01lcmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSByYW5nZSBib3VuZGFyaWVzXG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KHJhbmdlU3RhcnROb2RlLCByYW5nZVN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKHJhbmdlRW5kTm9kZSwgcmFuZ2VFbmRPZmZzZXQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgZ2V0QWRqYWNlbnRNZXJnZWFibGVUZXh0Tm9kZTogZnVuY3Rpb24obm9kZSwgZm9yd2FyZCkge1xuICAgICAgICB2YXIgaXNUZXh0Tm9kZSA9IChub2RlLm5vZGVUeXBlID09IHd5c2lodG1sNS5URVhUX05PREUpO1xuICAgICAgICB2YXIgZWwgPSBpc1RleHROb2RlID8gbm9kZS5wYXJlbnROb2RlIDogbm9kZTtcbiAgICAgICAgdmFyIGFkamFjZW50Tm9kZTtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCI7XG4gICAgICAgIGlmIChpc1RleHROb2RlKSB7XG4gICAgICAgICAgLy8gQ2FuIG1lcmdlIGlmIHRoZSBub2RlJ3MgcHJldmlvdXMvbmV4dCBzaWJsaW5nIGlzIGEgdGV4dCBub2RlXG4gICAgICAgICAgYWRqYWNlbnROb2RlID0gbm9kZVtwcm9wTmFtZV07XG4gICAgICAgICAgaWYgKGFkamFjZW50Tm9kZSAmJiBhZGphY2VudE5vZGUubm9kZVR5cGUgPT0gd3lzaWh0bWw1LlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuIGFkamFjZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ29tcGFyZSBlbGVtZW50IHdpdGggaXRzIHNpYmxpbmdcbiAgICAgICAgICBhZGphY2VudE5vZGUgPSBlbFtwcm9wTmFtZV07XG4gICAgICAgICAgaWYgKGFkamFjZW50Tm9kZSAmJiB0aGlzLmFyZUVsZW1lbnRzTWVyZ2VhYmxlKG5vZGUsIGFkamFjZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGphY2VudE5vZGVbZm9yd2FyZCA/IFwiZmlyc3RDaGlsZFwiIDogXCJsYXN0Q2hpbGRcIl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgXG4gICAgYXJlRWxlbWVudHNNZXJnZWFibGU6IGZ1bmN0aW9uKGVsMSwgZWwyKSB7XG4gICAgICByZXR1cm4gcmFuZ3kuZG9tLmFycmF5Q29udGFpbnModGhpcy50YWdOYW1lcywgKGVsMS50YWdOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICYmIHJhbmd5LmRvbS5hcnJheUNvbnRhaW5zKHRoaXMudGFnTmFtZXMsIChlbDIudGFnTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAmJiBoYXNTYW1lQ2xhc3NlcyhlbDEsIGVsMilcbiAgICAgICAgJiYgZWxlbWVudHNIYXZlU2FtZU5vbkNsYXNzQXR0cmlidXRlcyhlbDEsIGVsMik7XG4gICAgfSxcblxuICAgIGNyZWF0ZUNvbnRhaW5lcjogZnVuY3Rpb24oZG9jKSB7XG4gICAgICB2YXIgZWwgPSBkb2MuY3JlYXRlRWxlbWVudCh0aGlzLnRhZ05hbWVzWzBdKTtcbiAgICAgIGlmICh0aGlzLmNzc0NsYXNzKSB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IHRoaXMuY3NzQ2xhc3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIGFwcGx5VG9UZXh0Tm9kZTogZnVuY3Rpb24odGV4dE5vZGUpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0ZXh0Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIHJhbmd5LmRvbS5hcnJheUNvbnRhaW5zKHRoaXMudGFnTmFtZXMsIHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGlmICh0aGlzLmNzc0NsYXNzKSB7XG4gICAgICAgICAgYWRkQ2xhc3MocGFyZW50LCB0aGlzLmNzc0NsYXNzLCB0aGlzLnNpbWlsYXJDbGFzc1JlZ0V4cCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuY3JlYXRlQ29udGFpbmVyKHJhbmd5LmRvbS5nZXREb2N1bWVudCh0ZXh0Tm9kZSkpO1xuICAgICAgICB0ZXh0Tm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgdGV4dE5vZGUpO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzUmVtb3ZhYmxlOiBmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIHJhbmd5LmRvbS5hcnJheUNvbnRhaW5zKHRoaXMudGFnTmFtZXMsIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgJiYgd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKGVsLmNsYXNzTmFtZSkudHJpbSgpID09IHRoaXMuY3NzQ2xhc3M7XG4gICAgfSxcblxuICAgIHVuZG9Ub1RleHROb2RlOiBmdW5jdGlvbih0ZXh0Tm9kZSwgcmFuZ2UsIGFuY2VzdG9yV2l0aENsYXNzKSB7XG4gICAgICBpZiAoIXJhbmdlLmNvbnRhaW5zTm9kZShhbmNlc3RvcldpdGhDbGFzcykpIHtcbiAgICAgICAgLy8gU3BsaXQgb3V0IHRoZSBwb3J0aW9uIG9mIHRoZSBhbmNlc3RvciBmcm9tIHdoaWNoIHdlIGNhbiByZW1vdmUgdGhlIENTUyBjbGFzc1xuICAgICAgICB2YXIgYW5jZXN0b3JSYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgYW5jZXN0b3JSYW5nZS5zZWxlY3ROb2RlKGFuY2VzdG9yV2l0aENsYXNzKTtcblxuICAgICAgICBpZiAoYW5jZXN0b3JSYW5nZS5pc1BvaW50SW5SYW5nZShyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCkgJiYgaXNTcGxpdFBvaW50KHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KSkge1xuICAgICAgICAgIHNwbGl0Tm9kZUF0KGFuY2VzdG9yV2l0aENsYXNzLCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIoYW5jZXN0b3JXaXRoQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmNlc3RvclJhbmdlLmlzUG9pbnRJblJhbmdlKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCkgJiYgaXNTcGxpdFBvaW50KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCkpIHtcbiAgICAgICAgICBhbmNlc3RvcldpdGhDbGFzcyA9IHNwbGl0Tm9kZUF0KGFuY2VzdG9yV2l0aENsYXNzLCByYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0aGlzLnNpbWlsYXJDbGFzc1JlZ0V4cCkge1xuICAgICAgICByZW1vdmVDbGFzcyhhbmNlc3RvcldpdGhDbGFzcywgdGhpcy5zaW1pbGFyQ2xhc3NSZWdFeHApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNSZW1vdmFibGUoYW5jZXN0b3JXaXRoQ2xhc3MpKSB7XG4gICAgICAgIHJlcGxhY2VXaXRoT3duQ2hpbGRyZW4oYW5jZXN0b3JXaXRoQ2xhc3MpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhcHBseVRvUmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIHZhciB0ZXh0Tm9kZXMgPSByYW5nZS5nZXROb2Rlcyhbd3lzaWh0bWw1LlRFWFRfTk9ERV0pO1xuICAgICAgICBpZiAoIXRleHROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUNvbnRhaW5lcihyYW5nZS5lbmRDb250YWluZXIub3duZXJEb2N1bWVudCk7XG4gICAgICAgICAgICByYW5nZS5zdXJyb3VuZENvbnRlbnRzKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3ROb2RlKHJhbmdlLCBub2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJhbmdlLnNwbGl0Qm91bmRhcmllcygpO1xuICAgICAgICB0ZXh0Tm9kZXMgPSByYW5nZS5nZXROb2Rlcyhbd3lzaWh0bWw1LlRFWFRfTk9ERV0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKHRleHROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdGV4dE5vZGU7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGV4dE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICB0ZXh0Tm9kZSA9IHRleHROb2Rlc1tpXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRBbmNlc3RvcldpdGhDbGFzcyh0ZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBseVRvVGV4dE5vZGUodGV4dE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByYW5nZS5zZXRTdGFydCh0ZXh0Tm9kZXNbMF0sIDApO1xuICAgICAgICAgIHRleHROb2RlID0gdGV4dE5vZGVzW3RleHROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICByYW5nZS5zZXRFbmQodGV4dE5vZGUsIHRleHROb2RlLmxlbmd0aCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHRoaXMubm9ybWFsaXplKSB7XG4gICAgICAgICAgICB0aGlzLnBvc3RBcHBseSh0ZXh0Tm9kZXMsIHJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5kb1RvUmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICB2YXIgdGV4dE5vZGVzID0gcmFuZ2UuZ2V0Tm9kZXMoW3d5c2lodG1sNS5URVhUX05PREVdKSwgdGV4dE5vZGUsIGFuY2VzdG9yV2l0aENsYXNzO1xuICAgICAgaWYgKHRleHROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgcmFuZ2Uuc3BsaXRCb3VuZGFyaWVzKCk7XG4gICAgICAgIHRleHROb2RlcyA9IHJhbmdlLmdldE5vZGVzKFt3eXNpaHRtbDUuVEVYVF9OT0RFXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZG9jID0gcmFuZ2UuZW5kQ29udGFpbmVyLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICBub2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UpO1xuICAgICAgICByYW5nZS5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlKG5vZGUpO1xuICAgICAgICB0ZXh0Tm9kZXMgPSBbbm9kZV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0Tm9kZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdGV4dE5vZGUgPSB0ZXh0Tm9kZXNbaV07XG4gICAgICAgIGFuY2VzdG9yV2l0aENsYXNzID0gdGhpcy5nZXRBbmNlc3RvcldpdGhDbGFzcyh0ZXh0Tm9kZSk7XG4gICAgICAgIGlmIChhbmNlc3RvcldpdGhDbGFzcykge1xuICAgICAgICAgIHRoaXMudW5kb1RvVGV4dE5vZGUodGV4dE5vZGUsIHJhbmdlLCBhbmNlc3RvcldpdGhDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGxlbiA9PSAxKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0Tm9kZShyYW5nZSwgdGV4dE5vZGVzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KHRleHROb2Rlc1swXSwgMCk7XG4gICAgICAgIHRleHROb2RlID0gdGV4dE5vZGVzW3RleHROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKHRleHROb2RlLCB0ZXh0Tm9kZS5sZW5ndGgpO1xuXG4gICAgICAgIGlmICh0aGlzLm5vcm1hbGl6ZSkge1xuICAgICAgICAgIHRoaXMucG9zdEFwcGx5KHRleHROb2RlcywgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzZWxlY3ROb2RlOiBmdW5jdGlvbihyYW5nZSwgbm9kZSkge1xuICAgICAgdmFyIGlzRWxlbWVudCAgICAgICA9IG5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5FTEVNRU5UX05PREUsXG4gICAgICAgICAgY2FuSGF2ZUhUTUwgICAgID0gXCJjYW5IYXZlSFRNTFwiIGluIG5vZGUgPyBub2RlLmNhbkhhdmVIVE1MIDogdHJ1ZSxcbiAgICAgICAgICBjb250ZW50ICAgICAgICAgPSBpc0VsZW1lbnQgPyBub2RlLmlubmVySFRNTCA6IG5vZGUuZGF0YSxcbiAgICAgICAgICBpc0VtcHR5ICAgICAgICAgPSAoY29udGVudCA9PT0gXCJcIiB8fCBjb250ZW50ID09PSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFKTtcblxuICAgICAgaWYgKGlzRW1wdHkgJiYgaXNFbGVtZW50ICYmIGNhbkhhdmVIVE1MKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGNhcmV0IGlzIHZpc2libGUgaW4gbm9kZSBieSBpbnNlcnRpbmcgYSB6ZXJvIHdpZHRoIG5vIGJyZWFraW5nIHNwYWNlXG4gICAgICAgIHRyeSB7IG5vZGUuaW5uZXJIVE1MID0gd3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRTsgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgaWYgKGlzRW1wdHkgJiYgaXNFbGVtZW50KSB7XG4gICAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNFbXB0eSkge1xuICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKG5vZGUpO1xuICAgICAgICByYW5nZS5zZXRFbmRBZnRlcihub2RlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGdldFRleHRTZWxlY3RlZEJ5UmFuZ2U6IGZ1bmN0aW9uKHRleHROb2RlLCByYW5nZSkge1xuICAgICAgdmFyIHRleHRSYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgIHRleHRSYW5nZS5zZWxlY3ROb2RlQ29udGVudHModGV4dE5vZGUpO1xuXG4gICAgICB2YXIgaW50ZXJzZWN0aW9uUmFuZ2UgPSB0ZXh0UmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlKTtcbiAgICAgIHZhciB0ZXh0ID0gaW50ZXJzZWN0aW9uUmFuZ2UgPyBpbnRlcnNlY3Rpb25SYW5nZS50b1N0cmluZygpIDogXCJcIjtcbiAgICAgIHRleHRSYW5nZS5kZXRhY2goKTtcblxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSxcblxuICAgIGlzQXBwbGllZFRvUmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICB2YXIgYW5jZXN0b3JzID0gW10sXG4gICAgICAgICAgYW5jZXN0b3IsXG4gICAgICAgICAgdGV4dE5vZGVzID0gcmFuZ2UuZ2V0Tm9kZXMoW3d5c2lodG1sNS5URVhUX05PREVdKTtcbiAgICAgIGlmICghdGV4dE5vZGVzLmxlbmd0aCkge1xuICAgICAgICBhbmNlc3RvciA9IHRoaXMuZ2V0QW5jZXN0b3JXaXRoQ2xhc3MocmFuZ2Uuc3RhcnRDb250YWluZXIpO1xuICAgICAgICByZXR1cm4gYW5jZXN0b3IgPyBbYW5jZXN0b3JdIDogZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0Tm9kZXMubGVuZ3RoLCBzZWxlY3RlZFRleHQ7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBzZWxlY3RlZFRleHQgPSB0aGlzLmdldFRleHRTZWxlY3RlZEJ5UmFuZ2UodGV4dE5vZGVzW2ldLCByYW5nZSk7XG4gICAgICAgIGFuY2VzdG9yID0gdGhpcy5nZXRBbmNlc3RvcldpdGhDbGFzcyh0ZXh0Tm9kZXNbaV0pO1xuICAgICAgICBpZiAoc2VsZWN0ZWRUZXh0ICE9IFwiXCIgJiYgIWFuY2VzdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgICB9LFxuXG4gICAgdG9nZ2xlUmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICBpZiAodGhpcy5pc0FwcGxpZWRUb1JhbmdlKHJhbmdlKSkge1xuICAgICAgICB0aGlzLnVuZG9Ub1JhbmdlKHJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwbHlUb1JhbmdlKHJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd3lzaWh0bWw1LnNlbGVjdGlvbi5IVE1MQXBwbGllciA9IEhUTUxBcHBsaWVyO1xuICBcbn0pKHd5c2lodG1sNSwgcmFuZ3kpOy8qKlxuICogUmljaCBUZXh0IFF1ZXJ5L0Zvcm1hdHRpbmcgQ29tbWFuZHNcbiAqIFxuICogQGV4YW1wbGVcbiAqICAgIHZhciBjb21tYW5kcyA9IG5ldyB3eXNpaHRtbDUuQ29tbWFuZHMoZWRpdG9yKTtcbiAqL1xud3lzaWh0bWw1LkNvbW1hbmRzID0gQmFzZS5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LkNvbW1hbmRzLnByb3RvdHlwZSAqLyB7XG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICB0aGlzLmVkaXRvciAgID0gZWRpdG9yO1xuICAgIHRoaXMuY29tcG9zZXIgPSBlZGl0b3IuY29tcG9zZXI7XG4gICAgdGhpcy5kb2MgICAgICA9IHRoaXMuY29tcG9zZXIuZG9jO1xuICB9LFxuICBcbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGdpdmVuIGNvbW1hbmRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbW1hbmQgVGhlIGNvbW1hbmQgc3RyaW5nIHdoaWNoIHRvIGNoZWNrIChlZy4gXCJib2xkXCIsIFwiaXRhbGljXCIsIFwiaW5zZXJ0VW5vcmRlcmVkTGlzdFwiKVxuICAgKiBAZXhhbXBsZVxuICAgKiAgICBjb21tYW5kcy5zdXBwb3J0cyhcImNyZWF0ZUxpbmtcIik7XG4gICAqL1xuICBzdXBwb3J0OiBmdW5jdGlvbihjb21tYW5kKSB7XG4gICAgcmV0dXJuIHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzQ29tbWFuZCh0aGlzLmRvYywgY29tbWFuZCk7XG4gIH0sXG4gIFxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgZ2l2ZW4gY29tbWFuZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29tbWFuZCBUaGUgY29tbWFuZCBzdHJpbmcgd2hpY2ggdG8gZXhlY3V0ZSAoZWcuIFwiYm9sZFwiLCBcIml0YWxpY1wiLCBcImluc2VydFVub3JkZXJlZExpc3RcIilcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt2YWx1ZV0gVGhlIGNvbW1hbmQgdmFsdWUgcGFyYW1ldGVyLCBuZWVkZWQgZm9yIHNvbWUgY29tbWFuZHMgKFwiY3JlYXRlTGlua1wiLCBcImluc2VydEltYWdlXCIsIC4uLiksIG9wdGlvbmFsIGZvciBjb21tYW5kcyB0aGF0IGRvbid0IHJlcXVpcmUgb25lIChcImJvbGRcIiwgXCJ1bmRlcmxpbmVcIiwgLi4uKVxuICAgKiBAZXhhbXBsZVxuICAgKiAgICBjb21tYW5kcy5leGVjKFwiaW5zZXJ0SW1hZ2VcIiwgXCJodHRwOi8vYTEudHdpbWcuY29tL3Byb2ZpbGVfaW1hZ2VzLzExMzg2ODY1NS9zY2hyZWlfdHdpdHRlcl9yZWFzb25hYmx5X3NtYWxsLmpwZ1wiKTtcbiAgICovXG4gIGV4ZWM6IGZ1bmN0aW9uKGNvbW1hbmQsIHZhbHVlKSB7XG4gICAgdmFyIG9iaiAgICAgPSB3eXNpaHRtbDUuY29tbWFuZHNbY29tbWFuZF0sXG4gICAgICAgIGFyZ3MgICAgPSB3eXNpaHRtbDUubGFuZy5hcnJheShhcmd1bWVudHMpLmdldCgpLFxuICAgICAgICBtZXRob2QgID0gb2JqICYmIG9iai5leGVjLFxuICAgICAgICByZXN1bHQgID0gbnVsbDtcbiAgICBcbiAgICB0aGlzLmVkaXRvci5maXJlKFwiYmVmb3JlY29tbWFuZDpjb21wb3NlclwiKTtcbiAgICBcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5jb21wb3Nlcik7XG4gICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkob2JqLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdHJ5L2NhdGNoIGZvciBidWdneSBmaXJlZm94XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZG9jLmV4ZWNDb21tYW5kKGNvbW1hbmQsIGZhbHNlLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGUpIHt9XG4gICAgfVxuICAgIFxuICAgIHRoaXMuZWRpdG9yLmZpcmUoXCJhZnRlcmNvbW1hbmQ6Y29tcG9zZXJcIik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBjdXJyZW50IGNvbW1hbmQgaXMgYWN0aXZlXG4gICAqIElmIHRoZSBjYXJldCBpcyB3aXRoaW4gYSBib2xkIHRleHQsIHRoZW4gY2FsbGluZyB0aGlzIHdpdGggY29tbWFuZCBcImJvbGRcIiBzaG91bGQgcmV0dXJuIHRydWVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbW1hbmQgVGhlIGNvbW1hbmQgc3RyaW5nIHdoaWNoIHRvIGNoZWNrIChlZy4gXCJib2xkXCIsIFwiaXRhbGljXCIsIFwiaW5zZXJ0VW5vcmRlcmVkTGlzdFwiKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbW1hbmRWYWx1ZV0gVGhlIGNvbW1hbmQgdmFsdWUgcGFyYW1ldGVyIChlZy4gZm9yIFwiaW5zZXJ0SW1hZ2VcIiB0aGUgaW1hZ2Ugc3JjKVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBjb21tYW5kIGlzIGFjdGl2ZVxuICAgKiBAZXhhbXBsZVxuICAgKiAgICB2YXIgaXNDdXJyZW50U2VsZWN0aW9uQm9sZCA9IGNvbW1hbmRzLnN0YXRlKFwiYm9sZFwiKTtcbiAgICovXG4gIHN0YXRlOiBmdW5jdGlvbihjb21tYW5kLCBjb21tYW5kVmFsdWUpIHtcbiAgICB2YXIgb2JqICAgICA9IHd5c2lodG1sNS5jb21tYW5kc1tjb21tYW5kXSxcbiAgICAgICAgYXJncyAgICA9IHd5c2lodG1sNS5sYW5nLmFycmF5KGFyZ3VtZW50cykuZ2V0KCksXG4gICAgICAgIG1ldGhvZCAgPSBvYmogJiYgb2JqLnN0YXRlO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLmNvbXBvc2VyKTtcbiAgICAgIHJldHVybiBtZXRob2QuYXBwbHkob2JqLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdHJ5L2NhdGNoIGZvciBidWdneSBmaXJlZm94XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5xdWVyeUNvbW1hbmRTdGF0ZShjb21tYW5kKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBjb21tYW5kJ3MgdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbW1hbmQgVGhlIGNvbW1hbmQgc3RyaW5nIHdoaWNoIHRvIGNoZWNrIChlZy4gXCJmb3JtYXRCbG9ja1wiKVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjb21tYW5kIHZhbHVlXG4gICAqIEBleGFtcGxlXG4gICAqICAgIHZhciBjdXJyZW50QmxvY2tFbGVtZW50ID0gY29tbWFuZHMudmFsdWUoXCJmb3JtYXRCbG9ja1wiKTtcbiAgICovXG4gIHZhbHVlOiBmdW5jdGlvbihjb21tYW5kKSB7XG4gICAgdmFyIG9iaiAgICAgPSB3eXNpaHRtbDUuY29tbWFuZHNbY29tbWFuZF0sXG4gICAgICAgIG1ldGhvZCAgPSBvYmogJiYgb2JqLnZhbHVlO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHJldHVybiBtZXRob2QuY2FsbChvYmosIHRoaXMuY29tcG9zZXIsIGNvbW1hbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyB0cnkvY2F0Y2ggZm9yIGJ1Z2d5IGZpcmVmb3hcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnF1ZXJ5Q29tbWFuZFZhbHVlKGNvbW1hbmQpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG4oZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZjtcbiAgXG4gIHd5c2lodG1sNS5jb21tYW5kcy5ib2xkID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5leGVjKGNvbXBvc2VyLCBjb21tYW5kLCBcImJcIik7XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCwgY29sb3IpIHtcbiAgICAgIC8vIGVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZShcImJvbGRcIikgcmVzdWx0czpcbiAgICAgIC8vIGZpcmVmb3g6IG9ubHkgPGI+XG4gICAgICAvLyBjaHJvbWU6ICA8Yj4sIDxzdHJvbmc+LCA8aDE+LCA8aDI+LCAuLi5cbiAgICAgIC8vIGllOiAgICAgIDxiPiwgPHN0cm9uZz5cbiAgICAgIC8vIG9wZXJhOiAgIDxiPiwgPHN0cm9uZz5cbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBcImJcIik7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuXG4oZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZixcbiAgICAgIE5PREVfTkFNRSA9IFwiQVwiLFxuICAgICAgZG9tICAgICAgID0gd3lzaWh0bWw1LmRvbTtcbiAgXG4gIGZ1bmN0aW9uIF9yZW1vdmVGb3JtYXQoY29tcG9zZXIsIGFuY2hvcnMpIHtcbiAgICB2YXIgbGVuZ3RoICA9IGFuY2hvcnMubGVuZ3RoLFxuICAgICAgICBpICAgICAgID0gMCxcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBjb2RlRWxlbWVudCxcbiAgICAgICAgdGV4dENvbnRlbnQ7XG4gICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgIGFuY2hvciAgICAgID0gYW5jaG9yc1tpXTtcbiAgICAgIGNvZGVFbGVtZW50ID0gZG9tLmdldFBhcmVudEVsZW1lbnQoYW5jaG9yLCB7IG5vZGVOYW1lOiBcImNvZGVcIiB9KTtcbiAgICAgIHRleHRDb250ZW50ID0gZG9tLmdldFRleHRDb250ZW50KGFuY2hvcik7XG5cbiAgICAgIC8vIGlmIDxhPiBjb250YWlucyB1cmwtbGlrZSB0ZXh0IGNvbnRlbnQsIHJlbmFtZSBpdCB0byA8Y29kZT4gdG8gcHJldmVudCByZS1hdXRvbGlua2luZ1xuICAgICAgLy8gZWxzZSByZXBsYWNlIDxhPiB3aXRoIGl0cyBjaGlsZE5vZGVzXG4gICAgICBpZiAodGV4dENvbnRlbnQubWF0Y2goZG9tLmF1dG9MaW5rLlVSTF9SRUdfRVhQKSAmJiAhY29kZUVsZW1lbnQpIHtcbiAgICAgICAgLy8gPGNvZGU+IGVsZW1lbnQgaXMgdXNlZCB0byBwcmV2ZW50IGxhdGVyIGF1dG8tbGlua2luZyBvZiB0aGUgY29udGVudFxuICAgICAgICBjb2RlRWxlbWVudCA9IGRvbS5yZW5hbWVFbGVtZW50KGFuY2hvciwgXCJjb2RlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tLnJlcGxhY2VXaXRoQ2hpbGROb2RlcyhhbmNob3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9mb3JtYXQoY29tcG9zZXIsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgZG9jICAgICAgICAgICAgID0gY29tcG9zZXIuZG9jLFxuICAgICAgICB0ZW1wQ2xhc3MgICAgICAgPSBcIl93eXNpaHRtbDUtdGVtcC1cIiArICgrbmV3IERhdGUoKSksXG4gICAgICAgIHRlbXBDbGFzc1JlZ0V4cCA9IC9ub24tbWF0Y2hpbmctY2xhc3MvZyxcbiAgICAgICAgaSAgICAgICAgICAgICAgID0gMCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBhbmNob3JzLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGhhc0VsZW1lbnRDaGlsZCxcbiAgICAgICAgaXNFbXB0eSxcbiAgICAgICAgZWxlbWVudFRvU2V0Q2FyZXRBZnRlcixcbiAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgIHdoaXRlU3BhY2UsXG4gICAgICAgIGo7XG4gICAgd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5leGVjKGNvbXBvc2VyLCB1bmRlZiwgTk9ERV9OQU1FLCB0ZW1wQ2xhc3MsIHRlbXBDbGFzc1JlZ0V4cCk7XG4gICAgYW5jaG9ycyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKE5PREVfTkFNRSArIFwiLlwiICsgdGVtcENsYXNzKTtcbiAgICBsZW5ndGggID0gYW5jaG9ycy5sZW5ndGg7XG4gICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgIGFuY2hvciA9IGFuY2hvcnNbaV07XG4gICAgICBhbmNob3IucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgICBmb3IgKGogaW4gYXR0cmlidXRlcykge1xuICAgICAgICBhbmNob3Iuc2V0QXR0cmlidXRlKGosIGF0dHJpYnV0ZXNbal0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnRUb1NldENhcmV0QWZ0ZXIgPSBhbmNob3I7XG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgdGV4dENvbnRlbnQgPSBkb20uZ2V0VGV4dENvbnRlbnQoYW5jaG9yKTtcbiAgICAgIGhhc0VsZW1lbnRDaGlsZCA9ICEhYW5jaG9yLnF1ZXJ5U2VsZWN0b3IoXCIqXCIpO1xuICAgICAgaXNFbXB0eSA9IHRleHRDb250ZW50ID09PSBcIlwiIHx8IHRleHRDb250ZW50ID09PSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFO1xuICAgICAgaWYgKCFoYXNFbGVtZW50Q2hpbGQgJiYgaXNFbXB0eSkge1xuICAgICAgICBkb20uc2V0VGV4dENvbnRlbnQoYW5jaG9yLCBhdHRyaWJ1dGVzLnRleHQgfHwgYW5jaG9yLmhyZWYpO1xuICAgICAgICB3aGl0ZVNwYWNlID0gZG9jLmNyZWF0ZVRleHROb2RlKFwiIFwiKTtcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNldEFmdGVyKGFuY2hvcik7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5pbnNlcnROb2RlKHdoaXRlU3BhY2UpO1xuICAgICAgICBlbGVtZW50VG9TZXRDYXJldEFmdGVyID0gd2hpdGVTcGFjZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29tcG9zZXIuc2VsZWN0aW9uLnNldEFmdGVyKGVsZW1lbnRUb1NldENhcmV0QWZ0ZXIpO1xuICB9XG4gIFxuICB3eXNpaHRtbDUuY29tbWFuZHMuY3JlYXRlTGluayA9IHtcbiAgICAvKipcbiAgICAgKiBUT0RPOiBVc2UgSFRNTEFwcGxpZXIgb3IgZm9ybWF0SW5saW5lIGhlcmVcbiAgICAgKlxuICAgICAqIFR1cm5zIHNlbGVjdGlvbiBpbnRvIGEgbGlua1xuICAgICAqIElmIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGEgbGluaywgaXQgcmVtb3ZlcyB0aGUgbGluayBhbmQgd3JhcHMgaXQgd2l0aCBhIDxjb2RlPiBlbGVtZW50XG4gICAgICogVGhlIDxjb2RlPiBlbGVtZW50IGlzIG5lZWRlZCB0byBhdm9pZCBhdXRvIGxpbmtpbmdcbiAgICAgKiBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIC8vIGVpdGhlciAuLi5cbiAgICAgKiAgICB3eXNpaHRtbDUuY29tbWFuZHMuY3JlYXRlTGluay5leGVjKGNvbXBvc2VyLCBcImNyZWF0ZUxpbmtcIiwgXCJodHRwOi8vd3d3Lmdvb2dsZS5kZVwiKTtcbiAgICAgKiAgICAvLyAuLi4gb3IgLi4uXG4gICAgICogICAgd3lzaWh0bWw1LmNvbW1hbmRzLmNyZWF0ZUxpbmsuZXhlYyhjb21wb3NlciwgXCJjcmVhdGVMaW5rXCIsIHsgaHJlZjogXCJodHRwOi8vd3d3Lmdvb2dsZS5kZVwiLCB0YXJnZXQ6IFwiX2JsYW5rXCIgfSk7XG4gICAgICovXG4gICAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIHZhbHVlKSB7XG4gICAgICB2YXIgYW5jaG9ycyA9IHRoaXMuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQpO1xuICAgICAgaWYgKGFuY2hvcnMpIHtcbiAgICAgICAgLy8gU2VsZWN0aW9uIGNvbnRhaW5zIGxpbmtzXG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBfcmVtb3ZlRm9ybWF0KGNvbXBvc2VyLCBhbmNob3JzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgbGlua3NcbiAgICAgICAgdmFsdWUgPSB0eXBlb2YodmFsdWUpID09PSBcIm9iamVjdFwiID8gdmFsdWUgOiB7IGhyZWY6IHZhbHVlIH07XG4gICAgICAgIF9mb3JtYXQoY29tcG9zZXIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJBXCIpO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsvKipcbiAqIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiZm9udFNpemVcIikgd2lsbCBjcmVhdGUgZWl0aGVyIGlubGluZSBzdHlsZXMgKGZpcmVmb3gsIGNocm9tZSkgb3IgdXNlIGZvbnQgdGFnc1xuICogd2hpY2ggd2UgZG9uJ3Qgd2FudFxuICogSW5zdGVhZCB3ZSBzZXQgYSBjc3MgY2xhc3NcbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWYsXG4gICAgICBSRUdfRVhQID0gL3d5c2l3eWctZm9udC1zaXplLVthLXpcXC1dKy9nO1xuICBcbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmZvbnRTaXplID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCBzaXplKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5leGVjKGNvbXBvc2VyLCBjb21tYW5kLCBcInNwYW5cIiwgXCJ3eXNpd3lnLWZvbnQtc2l6ZS1cIiArIHNpemUsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIHNpemUpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBcInNwYW5cIiwgXCJ3eXNpd3lnLWZvbnQtc2l6ZS1cIiArIHNpemUsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTtcbi8qKlxuICogZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJmb3JlQ29sb3JcIikgd2lsbCBjcmVhdGUgZWl0aGVyIGlubGluZSBzdHlsZXMgKGZpcmVmb3gsIGNocm9tZSkgb3IgdXNlIGZvbnQgdGFnc1xuICogd2hpY2ggd2UgZG9uJ3Qgd2FudFxuICogSW5zdGVhZCB3ZSBzZXQgYSBjc3MgY2xhc3NcbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWYsXG4gICAgICBSRUdfRVhQID0gL3d5c2l3eWctY29sb3ItW2Etel0rL2c7XG4gIFxuICB3eXNpaHRtbDUuY29tbWFuZHMuZm9yZUNvbG9yID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCBjb2xvcikge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuZXhlYyhjb21wb3NlciwgY29tbWFuZCwgXCJzcGFuXCIsIFwid3lzaXd5Zy1jb2xvci1cIiArIGNvbG9yLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCBjb2xvcikge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIFwic3BhblwiLCBcInd5c2l3eWctY29sb3ItXCIgKyBjb2xvciwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmLFxuICAgICAgZG9tICAgICAgICAgICAgICAgICAgICAgPSB3eXNpaHRtbDUuZG9tLFxuICAgICAgREVGQVVMVF9OT0RFX05BTUUgICAgICAgPSBcIkRJVlwiLFxuICAgICAgLy8gRm9sbG93aW5nIGVsZW1lbnRzIGFyZSBncm91cGVkXG4gICAgICAvLyB3aGVuIHRoZSBjYXJldCBpcyB3aXRoaW4gYSBIMSBhbmQgdGhlIEg0IGlzIGludm9rZWQsIHRoZSBIMSBzaG91bGQgdHVybiBpbnRvIEg0XG4gICAgICAvLyBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgSDQgd2l0aGluIGEgSDEgd2hpY2ggd291bGQgcmVzdWx0IGluIHNlbWFudGljYWxseSBpbnZhbGlkIGh0bWxcbiAgICAgIEJMT0NLX0VMRU1FTlRTX0dST1VQICAgID0gW1wiSDFcIiwgXCJIMlwiLCBcIkgzXCIsIFwiSDRcIiwgXCJINVwiLCBcIkg2XCIsIFwiUFwiLCBcIkJMT0NLUVVPVEVcIiwgREVGQVVMVF9OT0RFX05BTUVdO1xuICBcbiAgLyoqXG4gICAqIFJlbW92ZSBzaW1pbGlhciBjbGFzc2VzIChiYXNlZCBvbiBjbGFzc1JlZ0V4cClcbiAgICogYW5kIGFkZCB0aGUgZGVzaXJlZCBjbGFzcyBuYW1lXG4gICAqL1xuICBmdW5jdGlvbiBfYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkge1xuICAgIGlmIChlbGVtZW50LmNsYXNzTmFtZSkge1xuICAgICAgX3JlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzUmVnRXhwKTtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NSZWdFeHApIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoY2xhc3NSZWdFeHAsIFwiXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgZ2l2ZW4gbm9kZSBpcyBhIHRleHQgbm9kZSBhbmQgd2hldGhlciBpdCdzIGVtcHR5XG4gICAqL1xuICBmdW5jdGlvbiBfaXNCbGFua1RleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gd3lzaWh0bWw1LlRFWFRfTk9ERSAmJiAhd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKG5vZGUuZGF0YSkudHJpbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcHJldmlvdXMgc2libGluZyBub2RlIHRoYXQgaXMgbm90IGEgYmxhbmsgdGV4dCBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0UHJldmlvdXNTaWJsaW5nVGhhdElzTm90Qmxhbmsobm9kZSkge1xuICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICB3aGlsZSAocHJldmlvdXNTaWJsaW5nICYmIF9pc0JsYW5rVGV4dE5vZGUocHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgcHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXNTaWJsaW5nLnByZXZpb3VzU2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIHByZXZpb3VzU2libGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5leHQgc2libGluZyBub2RlIHRoYXQgaXMgbm90IGEgYmxhbmsgdGV4dCBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0TmV4dFNpYmxpbmdUaGF0SXNOb3RCbGFuayhub2RlKSB7XG4gICAgdmFyIG5leHRTaWJsaW5nID0gbm9kZS5uZXh0U2libGluZztcbiAgICB3aGlsZSAobmV4dFNpYmxpbmcgJiYgX2lzQmxhbmtUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBuZXh0U2libGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGxpbmUgYnJlYWtzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGdpdmVuIG5vZGUgaWYgdGhlIHByZXZpb3VzIGFuZCBuZXh0IHNpYmxpbmdzXG4gICAqIGFyZW4ndCBhbHJlYWR5IGNhdXNpbmcgYSB2aXN1YWwgbGluZSBicmVhayAoYmxvY2sgZWxlbWVudCBvciA8YnI+KVxuICAgKi9cbiAgZnVuY3Rpb24gX2FkZExpbmVCcmVha0JlZm9yZUFuZEFmdGVyKG5vZGUpIHtcbiAgICB2YXIgZG9jICAgICAgICAgICAgID0gbm9kZS5vd25lckRvY3VtZW50LFxuICAgICAgICBuZXh0U2libGluZyAgICAgPSBfZ2V0TmV4dFNpYmxpbmdUaGF0SXNOb3RCbGFuayhub2RlKSxcbiAgICAgICAgcHJldmlvdXNTaWJsaW5nID0gX2dldFByZXZpb3VzU2libGluZ1RoYXRJc05vdEJsYW5rKG5vZGUpO1xuXG4gICAgaWYgKG5leHRTaWJsaW5nICYmICFfaXNMaW5lQnJlYWtPckJsb2NrRWxlbWVudChuZXh0U2libGluZykpIHtcbiAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9jLmNyZWF0ZUVsZW1lbnQoXCJiclwiKSwgbmV4dFNpYmxpbmcpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXNTaWJsaW5nICYmICFfaXNMaW5lQnJlYWtPckJsb2NrRWxlbWVudChwcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRvYy5jcmVhdGVFbGVtZW50KFwiYnJcIiksIG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGxpbmUgYnJlYWtzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGdpdmVuIG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIF9yZW1vdmVMaW5lQnJlYWtCZWZvcmVBbmRBZnRlcihub2RlKSB7XG4gICAgdmFyIG5leHRTaWJsaW5nICAgICA9IF9nZXROZXh0U2libGluZ1RoYXRJc05vdEJsYW5rKG5vZGUpLFxuICAgICAgICBwcmV2aW91c1NpYmxpbmcgPSBfZ2V0UHJldmlvdXNTaWJsaW5nVGhhdElzTm90Qmxhbmsobm9kZSk7XG5cbiAgICBpZiAobmV4dFNpYmxpbmcgJiYgX2lzTGluZUJyZWFrKG5leHRTaWJsaW5nKSkge1xuICAgICAgbmV4dFNpYmxpbmcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuZXh0U2libGluZyk7XG4gICAgfVxuICAgIGlmIChwcmV2aW91c1NpYmxpbmcgJiYgX2lzTGluZUJyZWFrKHByZXZpb3VzU2libGluZykpIHtcbiAgICAgIHByZXZpb3VzU2libGluZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpb3VzU2libGluZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX3JlbW92ZUxhc3RDaGlsZElmTGluZUJyZWFrKG5vZGUpIHtcbiAgICB2YXIgbGFzdENoaWxkID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgaWYgKGxhc3RDaGlsZCAmJiBfaXNMaW5lQnJlYWsobGFzdENoaWxkKSkge1xuICAgICAgbGFzdENoaWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGFzdENoaWxkKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfaXNMaW5lQnJlYWsobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVOYW1lID09PSBcIkJSXCI7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGVsbWVudCBjYXVzZXMgYSB2aXN1YWwgbGluZSBicmVha1xuICAgKiAoPGJyPiBvciBibG9jayBlbGVtZW50cylcbiAgICovXG4gIGZ1bmN0aW9uIF9pc0xpbmVCcmVha09yQmxvY2tFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoX2lzTGluZUJyZWFrKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKGVsZW1lbnQpID09PSBcImJsb2NrXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIG5hdGl2ZSBxdWVyeSBjb21tYW5kXG4gICAqIGFuZCBpZiBuZWNlc3NhcnkgbW9kaWZ5IHRoZSBpbnNlcnRlZCBub2RlJ3MgY2xhc3NOYW1lXG4gICAqL1xuICBmdW5jdGlvbiBfZXhlY0NvbW1hbmQoZG9jLCBjb21tYW5kLCBub2RlTmFtZSwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgdmFyIGV2ZW50TGlzdGVuZXIgPSBkb20ub2JzZXJ2ZShkb2MsIFwiRE9NTm9kZUluc2VydGVkXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQsXG4gICAgICAgICAgICBkaXNwbGF5U3R5bGU7XG4gICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgIT09IHd5c2lodG1sNS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGxheVN0eWxlID0gZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKHRhcmdldCk7XG4gICAgICAgIGlmIChkaXNwbGF5U3R5bGUuc3Vic3RyKDAsIDYpICE9PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgb25seSBibG9jayBlbGVtZW50cyByZWNlaXZlIHRoZSBnaXZlbiBjbGFzc1xuICAgICAgICAgIHRhcmdldC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBkb2MuZXhlY0NvbW1hbmQoY29tbWFuZCwgZmFsc2UsIG5vZGVOYW1lKTtcbiAgICBpZiAoZXZlbnRMaXN0ZW5lcikge1xuICAgICAgZXZlbnRMaXN0ZW5lci5zdG9wKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX3NlbGVjdExpbmVBbmRXcmFwKGNvbXBvc2VyLCBlbGVtZW50KSB7XG4gICAgY29tcG9zZXIuc2VsZWN0aW9uLnNlbGVjdExpbmUoKTtcbiAgICBjb21wb3Nlci5zZWxlY3Rpb24uc3Vycm91bmQoZWxlbWVudCk7XG4gICAgX3JlbW92ZUxpbmVCcmVha0JlZm9yZUFuZEFmdGVyKGVsZW1lbnQpO1xuICAgIF9yZW1vdmVMYXN0Q2hpbGRJZkxpbmVCcmVhayhlbGVtZW50KTtcbiAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2VsZWN0Tm9kZShlbGVtZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9oYXNDbGFzc2VzKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gISF3eXNpaHRtbDUubGFuZy5zdHJpbmcoZWxlbWVudC5jbGFzc05hbWUpLnRyaW0oKTtcbiAgfVxuICBcbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCBub2RlTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkge1xuICAgICAgdmFyIGRvYyAgICAgICAgICA9IGNvbXBvc2VyLmRvYyxcbiAgICAgICAgICBibG9ja0VsZW1lbnQgPSB0aGlzLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBub2RlTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCksXG4gICAgICAgICAgc2VsZWN0ZWROb2RlO1xuXG4gICAgICBub2RlTmFtZSA9IHR5cGVvZihub2RlTmFtZSkgPT09IFwic3RyaW5nXCIgPyBub2RlTmFtZS50b1VwcGVyQ2FzZSgpIDogbm9kZU5hbWU7XG5cbiAgICAgIGlmIChibG9ja0VsZW1lbnQpIHtcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlU2ltcGxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChjbGFzc1JlZ0V4cCkge1xuICAgICAgICAgICAgX3JlbW92ZUNsYXNzKGJsb2NrRWxlbWVudCwgY2xhc3NSZWdFeHApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaGFzQ2xhc3NlcyA9IF9oYXNDbGFzc2VzKGJsb2NrRWxlbWVudCk7XG4gICAgICAgICAgaWYgKCFoYXNDbGFzc2VzICYmIGJsb2NrRWxlbWVudC5ub2RlTmFtZSA9PT0gKG5vZGVOYW1lIHx8IERFRkFVTFRfTk9ERV9OQU1FKSkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IGEgbGluZSBicmVhayBhZnRlcndhcmRzIGFuZCBiZWZvcmV3YXJkcyB3aGVuIHRoZXJlIGFyZSBzaWJsaW5nc1xuICAgICAgICAgICAgLy8gdGhhdCBhcmUgbm90IG9mIHR5cGUgbGluZSBicmVhayBvciBibG9jayBlbGVtZW50XG4gICAgICAgICAgICBfYWRkTGluZUJyZWFrQmVmb3JlQW5kQWZ0ZXIoYmxvY2tFbGVtZW50KTtcbiAgICAgICAgICAgIGRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXMoYmxvY2tFbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NsYXNzZXMpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHN0eWxpbmcgaXMga2VwdCBieSByZW5hbWluZyB0aGUgZWxlbWVudCB0byA8ZGl2PiBhbmQgY29weWluZyBvdmVyIHRoZSBjbGFzcyBuYW1lXG4gICAgICAgICAgICBkb20ucmVuYW1lRWxlbWVudChibG9ja0VsZW1lbnQsIERFRkFVTFRfTk9ERV9OQU1FKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgc2ltaWxpYXIgYmxvY2sgZWxlbWVudCBhbmQgcmVuYW1lIGl0ICg8aDIgY2xhc3M9XCJmb29cIj48L2gyPiAgPT4gIDxoMSBjbGFzcz1cImZvb1wiPjwvaDE+KVxuICAgICAgaWYgKG5vZGVOYW1lID09PSBudWxsIHx8IHd5c2lodG1sNS5sYW5nLmFycmF5KEJMT0NLX0VMRU1FTlRTX0dST1VQKS5jb250YWlucyhub2RlTmFtZSkpIHtcbiAgICAgICAgc2VsZWN0ZWROb2RlID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSgpO1xuICAgICAgICBibG9ja0VsZW1lbnQgPSBkb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHtcbiAgICAgICAgICBub2RlTmFtZTogQkxPQ0tfRUxFTUVOVFNfR1JPVVBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGJsb2NrRWxlbWVudCkge1xuICAgICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFJlbmFtZSBjdXJyZW50IGJsb2NrIGVsZW1lbnQgdG8gbmV3IGJsb2NrIGVsZW1lbnQgYW5kIGFkZCBjbGFzc1xuICAgICAgICAgICAgaWYgKG5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgIGJsb2NrRWxlbWVudCA9IGRvbS5yZW5hbWVFbGVtZW50KGJsb2NrRWxlbWVudCwgbm9kZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICBfYWRkQ2xhc3MoYmxvY2tFbGVtZW50LCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvc2VyLmNvbW1hbmRzLnN1cHBvcnQoY29tbWFuZCkpIHtcbiAgICAgICAgX2V4ZWNDb21tYW5kKGRvYywgY29tbWFuZCwgbm9kZU5hbWUgfHwgREVGQVVMVF9OT0RFX05BTUUsIGNsYXNzTmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYmxvY2tFbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUgfHwgREVGQVVMVF9OT0RFX05BTUUpO1xuICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBibG9ja0VsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgfVxuICAgICAgX3NlbGVjdExpbmVBbmRXcmFwKGNvbXBvc2VyLCBibG9ja0VsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQsIG5vZGVOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSB7XG4gICAgICBub2RlTmFtZSA9IHR5cGVvZihub2RlTmFtZSkgPT09IFwic3RyaW5nXCIgPyBub2RlTmFtZS50b1VwcGVyQ2FzZSgpIDogbm9kZU5hbWU7XG4gICAgICB2YXIgc2VsZWN0ZWROb2RlID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSgpO1xuICAgICAgcmV0dXJuIGRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwge1xuICAgICAgICBub2RlTmFtZTogICAgIG5vZGVOYW1lLFxuICAgICAgICBjbGFzc05hbWU6ICAgIGNsYXNzTmFtZSxcbiAgICAgICAgY2xhc3NSZWdFeHA6ICBjbGFzc1JlZ0V4cFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOy8qKlxuICogZm9ybWF0SW5saW5lIHNjZW5hcmlvcyBmb3IgdGFnIFwiQlwiICh8ID0gY2FyZXQsIHxmb298ID0gc2VsZWN0ZWQgdGV4dClcbiAqXG4gKiAgICMxIGNhcmV0IGluIHVuZm9ybWF0dGVkIHRleHQ6XG4gKiAgICAgIGFiY2RlZmd8XG4gKiAgIG91dHB1dDpcbiAqICAgICAgYWJjZGVmZzxiPnw8L2I+XG4gKiAgIFxuICogICAjMiB1bmZvcm1hdHRlZCB0ZXh0IHNlbGVjdGVkOlxuICogICAgICBhYmN8ZGVnfGhcbiAqICAgb3V0cHV0OlxuICogICAgICBhYmM8Yj58ZGVnfDwvYj5oXG4gKiAgIFxuICogICAjMyB1bmZvcm1hdHRlZCB0ZXh0IHNlbGVjdGVkIGFjcm9zcyBib3VuZGFyaWVzOlxuICogICAgICBhYnxjIDxzcGFuPmRlZmd8aDwvc3Bhbj5cbiAqICAgb3V0cHV0OlxuICogICAgICBhYjxiPnxjIDwvYj48c3Bhbj48Yj5kZWZnPC9iPnxoPC9zcGFuPlxuICpcbiAqICAgIzQgZm9ybWF0dGVkIHRleHQgZW50aXJlbHkgc2VsZWN0ZWRcbiAqICAgICAgPGI+fGFiY3w8L2I+XG4gKiAgIG91dHB1dDpcbiAqICAgICAgfGFiY3xcbiAqXG4gKiAgICM1IGZvcm1hdHRlZCB0ZXh0IHBhcnRpYWxseSBzZWxlY3RlZFxuICogICAgICA8Yj5hYnxjfDwvYj5cbiAqICAgb3V0cHV0OlxuICogICAgICA8Yj5hYjwvYj58Y3xcbiAqXG4gKiAgICM2IGZvcm1hdHRlZCB0ZXh0IHNlbGVjdGVkIGFjcm9zcyBib3VuZGFyaWVzXG4gKiAgICAgIDxzcGFuPmFifGM8L3NwYW4+IDxiPmRlfGZnaDwvYj5cbiAqICAgb3V0cHV0OlxuICogICAgICA8c3Bhbj5hYnxjPC9zcGFuPiBkZXw8Yj5mZ2g8L2I+XG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmLFxuICAgICAgLy8gVHJlYXQgPGI+IGFzIDxzdHJvbmc+IGFuZCB2aWNlIHZlcnNhXG4gICAgICBBTElBU19NQVBQSU5HID0ge1xuICAgICAgICBcInN0cm9uZ1wiOiBcImJcIixcbiAgICAgICAgXCJlbVwiOiAgICAgXCJpXCIsXG4gICAgICAgIFwiYlwiOiAgICAgIFwic3Ryb25nXCIsXG4gICAgICAgIFwiaVwiOiAgICAgIFwiZW1cIlxuICAgICAgfSxcbiAgICAgIGh0bWxBcHBsaWVyID0ge307XG4gIFxuICBmdW5jdGlvbiBfZ2V0VGFnTmFtZXModGFnTmFtZSkge1xuICAgIHZhciBhbGlhcyA9IEFMSUFTX01BUFBJTkdbdGFnTmFtZV07XG4gICAgcmV0dXJuIGFsaWFzID8gW3RhZ05hbWUudG9Mb3dlckNhc2UoKSwgYWxpYXMudG9Mb3dlckNhc2UoKV0gOiBbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gX2dldEFwcGxpZXIodGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkge1xuICAgIHZhciBpZGVudGlmaWVyID0gdGFnTmFtZSArIFwiOlwiICsgY2xhc3NOYW1lO1xuICAgIGlmICghaHRtbEFwcGxpZXJbaWRlbnRpZmllcl0pIHtcbiAgICAgIGh0bWxBcHBsaWVyW2lkZW50aWZpZXJdID0gbmV3IHd5c2lodG1sNS5zZWxlY3Rpb24uSFRNTEFwcGxpZXIoX2dldFRhZ05hbWVzKHRhZ05hbWUpLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWxBcHBsaWVyW2lkZW50aWZpZXJdO1xuICB9XG4gIFxuICB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCB0YWdOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgX2dldEFwcGxpZXIodGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkudG9nZ2xlUmFuZ2UocmFuZ2UpO1xuICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNldFNlbGVjdGlvbihyYW5nZSk7XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCwgdGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkge1xuICAgICAgdmFyIGRvYyAgICAgICAgICAgPSBjb21wb3Nlci5kb2MsXG4gICAgICAgICAgYWxpYXNUYWdOYW1lICA9IEFMSUFTX01BUFBJTkdbdGFnTmFtZV0gfHwgdGFnTmFtZSxcbiAgICAgICAgICByYW5nZTtcblxuICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZG9jdW1lbnQgY29udGFpbnMgYSBub2RlIHdpdGggdGhlIGRlc2lyZWQgdGFnTmFtZVxuICAgICAgaWYgKCF3eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoVGFnTmFtZShkb2MsIHRhZ05hbWUpICYmXG4gICAgICAgICAgIXd5c2lodG1sNS5kb20uaGFzRWxlbWVudFdpdGhUYWdOYW1lKGRvYywgYWxpYXNUYWdOYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkb2N1bWVudCBjb250YWlucyBhIG5vZGUgd2l0aCB0aGUgZGVzaXJlZCBjbGFzc05hbWVcbiAgICAgIGlmIChjbGFzc05hbWUgJiYgIXd5c2lodG1sNS5kb20uaGFzRWxlbWVudFdpdGhDbGFzc05hbWUoZG9jLCBjbGFzc05hbWUpKSB7XG4gICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJhbmdlID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9nZXRBcHBsaWVyKHRhZ05hbWUsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApLmlzQXBwbGllZFRvUmFuZ2UocmFuZ2UpO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZjtcbiAgXG4gIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRIVE1MID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCBodG1sKSB7XG4gICAgICBpZiAoY29tcG9zZXIuY29tbWFuZHMuc3VwcG9ydChjb21tYW5kKSkge1xuICAgICAgICBjb21wb3Nlci5kb2MuZXhlY0NvbW1hbmQoY29tbWFuZCwgZmFsc2UsIGh0bWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmluc2VydEhUTUwoaHRtbCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgTk9ERV9OQU1FID0gXCJJTUdcIjtcbiAgXG4gIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRJbWFnZSA9IHtcbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIDxpbWc+XG4gICAgICogSWYgc2VsZWN0aW9uIGlzIGFscmVhZHkgYW4gaW1hZ2UgbGluaywgaXQgcmVtb3ZlcyBpdFxuICAgICAqIFxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgLy8gZWl0aGVyIC4uLlxuICAgICAqICAgIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRJbWFnZS5leGVjKGNvbXBvc2VyLCBcImluc2VydEltYWdlXCIsIFwiaHR0cDovL3d3dy5nb29nbGUuZGUvbG9nby5qcGdcIik7XG4gICAgICogICAgLy8gLi4uIG9yIC4uLlxuICAgICAqICAgIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRJbWFnZS5leGVjKGNvbXBvc2VyLCBcImluc2VydEltYWdlXCIsIHsgc3JjOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmRlL2xvZ28uanBnXCIsIHRpdGxlOiBcImZvb1wiIH0pO1xuICAgICAqL1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCB2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB0eXBlb2YodmFsdWUpID09PSBcIm9iamVjdFwiID8gdmFsdWUgOiB7IHNyYzogdmFsdWUgfTtcblxuICAgICAgdmFyIGRvYyAgICAgPSBjb21wb3Nlci5kb2MsXG4gICAgICAgICAgaW1hZ2UgICA9IHRoaXMuc3RhdGUoY29tcG9zZXIpLFxuICAgICAgICAgIHRleHROb2RlLFxuICAgICAgICAgIGksXG4gICAgICAgICAgcGFyZW50O1xuXG4gICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgLy8gSW1hZ2UgYWxyZWFkeSBzZWxlY3RlZCwgc2V0IHRoZSBjYXJldCBiZWZvcmUgaXQgYW5kIGRlbGV0ZSBpdFxuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2V0QmVmb3JlKGltYWdlKTtcbiAgICAgICAgcGFyZW50ID0gaW1hZ2UucGFyZW50Tm9kZTtcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGltYWdlKTtcblxuICAgICAgICAvLyBhbmQgaXQncyBwYXJlbnQgPGE+IHRvbyBpZiBpdCBoYXNuJ3QgZ290IGFueSBvdGhlciByZWxldmFudCBjaGlsZCBub2Rlc1xuICAgICAgICB3eXNpaHRtbDUuZG9tLnJlbW92ZUVtcHR5VGV4dE5vZGVzKHBhcmVudCk7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZU5hbWUgPT09IFwiQVwiICYmICFwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZXRBZnRlcihwYXJlbnQpO1xuICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBhcmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJlZm94IGFuZCBpZSBzb21ldGltZXMgZG9uJ3QgcmVtb3ZlIHRoZSBpbWFnZSBoYW5kbGVzLCBldmVuIHRob3VnaCB0aGUgaW1hZ2UgZ290IHJlbW92ZWRcbiAgICAgICAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcoY29tcG9zZXIuZWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW1hZ2UgPSBkb2MuY3JlYXRlRWxlbWVudChOT0RFX05BTUUpO1xuXG4gICAgICBmb3IgKGkgaW4gdmFsdWUpIHtcbiAgICAgICAgaW1hZ2VbaV0gPSB2YWx1ZVtpXTtcbiAgICAgIH1cblxuICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmluc2VydE5vZGUoaW1hZ2UpO1xuICAgICAgaWYgKHd5c2lodG1sNS5icm93c2VyLmhhc1Byb2JsZW1zU2V0dGluZ0NhcmV0QWZ0ZXJJbWcoKSkge1xuICAgICAgICB0ZXh0Tm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZSh3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFKTtcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmluc2VydE5vZGUodGV4dE5vZGUpO1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2V0QWZ0ZXIodGV4dE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNldEFmdGVyKGltYWdlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyKSB7XG4gICAgICB2YXIgZG9jID0gY29tcG9zZXIuZG9jLFxuICAgICAgICAgIHNlbGVjdGVkTm9kZSxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIGltYWdlc0luU2VsZWN0aW9uO1xuXG4gICAgICBpZiAoIXd5c2lodG1sNS5kb20uaGFzRWxlbWVudFdpdGhUYWdOYW1lKGRvYywgTk9ERV9OQU1FKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdGVkTm9kZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKTtcbiAgICAgIGlmICghc2VsZWN0ZWROb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGVkTm9kZS5ub2RlTmFtZSA9PT0gTk9ERV9OQU1FKSB7XG4gICAgICAgIC8vIFRoaXMgd29ya3MgcGVyZmVjdGx5IGluIElFXG4gICAgICAgIHJldHVybiBzZWxlY3RlZE5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZE5vZGUubm9kZVR5cGUgIT09IHd5c2lodG1sNS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0ZXh0ID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldFRleHQoKTtcbiAgICAgIHRleHQgPSB3eXNpaHRtbDUubGFuZy5zdHJpbmcodGV4dCkudHJpbSgpO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpbWFnZXNJblNlbGVjdGlvbiA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXROb2Rlcyh3eXNpaHRtbDUuRUxFTUVOVF9OT0RFLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLm5vZGVOYW1lID09PSBcIklNR1wiO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbWFnZXNJblNlbGVjdGlvbi5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW1hZ2VzSW5TZWxlY3Rpb25bMF07XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbihjb21wb3Nlcikge1xuICAgICAgdmFyIGltYWdlID0gdGhpcy5zdGF0ZShjb21wb3Nlcik7XG4gICAgICByZXR1cm4gaW1hZ2UgJiYgaW1hZ2Uuc3JjO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWYsXG4gICAgICBMSU5FX0JSRUFLID0gXCI8YnI+XCIgKyAod3lzaWh0bWw1LmJyb3dzZXIubmVlZHNTcGFjZUFmdGVyTGluZUJyZWFrKCkgPyBcIiBcIiA6IFwiXCIpO1xuICBcbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmluc2VydExpbmVCcmVhayA9IHtcbiAgICBleGVjOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgaWYgKGNvbXBvc2VyLmNvbW1hbmRzLnN1cHBvcnQoY29tbWFuZCkpIHtcbiAgICAgICAgY29tcG9zZXIuZG9jLmV4ZWNDb21tYW5kKGNvbW1hbmQsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5hdXRvU2Nyb2xsc1RvQ2FyZXQoKSkge1xuICAgICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb3Nlci5jb21tYW5kcy5leGVjKFwiaW5zZXJ0SFRNTFwiLCBMSU5FX0JSRUFLKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZjtcbiAgXG4gIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRPcmRlcmVkTGlzdCA9IHtcbiAgICBleGVjOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgdmFyIGRvYyAgICAgICAgICAgPSBjb21wb3Nlci5kb2MsXG4gICAgICAgICAgc2VsZWN0ZWROb2RlICA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKSxcbiAgICAgICAgICBsaXN0ICAgICAgICAgID0gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwgeyBub2RlTmFtZTogXCJPTFwiIH0pLFxuICAgICAgICAgIG90aGVyTGlzdCAgICAgPSB3eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBcIlVMXCIgfSksXG4gICAgICAgICAgdGVtcENsYXNzTmFtZSA9ICBcIl93eXNpaHRtbDUtdGVtcC1cIiArIG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICAgIGlzRW1wdHksXG4gICAgICAgICAgdGVtcEVsZW1lbnQ7XG4gICAgICBcbiAgICAgIGlmIChjb21wb3Nlci5jb21tYW5kcy5zdXBwb3J0KGNvbW1hbmQpKSB7XG4gICAgICAgIGRvYy5leGVjQ29tbWFuZChjb21tYW5kLCBmYWxzZSwgbnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgLy8gVW53cmFwIGxpc3RcbiAgICAgICAgLy8gPG9sPjxsaT5mb288L2xpPjxsaT5iYXI8L2xpPjwvb2w+XG4gICAgICAgIC8vIGJlY29tZXM6XG4gICAgICAgIC8vIGZvbzxicj5iYXI8YnI+XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICB3eXNpaHRtbDUuZG9tLnJlc29sdmVMaXN0KGxpc3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3RoZXJMaXN0KSB7XG4gICAgICAgIC8vIFR1cm4gYW4gdW5vcmRlcmVkIGxpc3QgaW50byBhbiBvcmRlcmVkIGxpc3RcbiAgICAgICAgLy8gPHVsPjxsaT5mb288L2xpPjxsaT5iYXI8L2xpPjwvdWw+XG4gICAgICAgIC8vIGJlY29tZXM6XG4gICAgICAgIC8vIDxvbD48bGk+Zm9vPC9saT48bGk+YmFyPC9saT48L29sPlxuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgd3lzaWh0bWw1LmRvbS5yZW5hbWVFbGVtZW50KG90aGVyTGlzdCwgXCJvbFwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgbGlzdFxuICAgICAgICBjb21wb3Nlci5jb21tYW5kcy5leGVjKFwiZm9ybWF0QmxvY2tcIiwgXCJkaXZcIiwgdGVtcENsYXNzTmFtZSk7XG4gICAgICAgIHRlbXBFbGVtZW50ID0gZG9jLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyB0ZW1wQ2xhc3NOYW1lKTtcbiAgICAgICAgaXNFbXB0eSA9IHRlbXBFbGVtZW50LmlubmVySFRNTCA9PT0gXCJcIiB8fCB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPT09IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0U7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBsaXN0ID0gd3lzaWh0bWw1LmRvbS5jb252ZXJ0VG9MaXN0KHRlbXBFbGVtZW50LCBcIm9sXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2VsZWN0Tm9kZShsaXN0LnF1ZXJ5U2VsZWN0b3IoXCJsaVwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHN0YXRlOiBmdW5jdGlvbihjb21wb3Nlcikge1xuICAgICAgdmFyIHNlbGVjdGVkTm9kZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKTtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBcIk9MXCIgfSk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmO1xuICBcbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmluc2VydFVub3JkZXJlZExpc3QgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHZhciBkb2MgICAgICAgICAgID0gY29tcG9zZXIuZG9jLFxuICAgICAgICAgIHNlbGVjdGVkTm9kZSAgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCksXG4gICAgICAgICAgbGlzdCAgICAgICAgICA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHsgbm9kZU5hbWU6IFwiVUxcIiB9KSxcbiAgICAgICAgICBvdGhlckxpc3QgICAgID0gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwgeyBub2RlTmFtZTogXCJPTFwiIH0pLFxuICAgICAgICAgIHRlbXBDbGFzc05hbWUgPSAgXCJfd3lzaWh0bWw1LXRlbXAtXCIgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICBpc0VtcHR5LFxuICAgICAgICAgIHRlbXBFbGVtZW50O1xuICAgICAgXG4gICAgICBpZiAoY29tcG9zZXIuY29tbWFuZHMuc3VwcG9ydChjb21tYW5kKSkge1xuICAgICAgICBkb2MuZXhlY0NvbW1hbmQoY29tbWFuZCwgZmFsc2UsIG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgIC8vIFVud3JhcCBsaXN0XG4gICAgICAgIC8vIDx1bD48bGk+Zm9vPC9saT48bGk+YmFyPC9saT48L3VsPlxuICAgICAgICAvLyBiZWNvbWVzOlxuICAgICAgICAvLyBmb288YnI+YmFyPGJyPlxuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgd3lzaWh0bWw1LmRvbS5yZXNvbHZlTGlzdChsaXN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG90aGVyTGlzdCkge1xuICAgICAgICAvLyBUdXJuIGFuIG9yZGVyZWQgbGlzdCBpbnRvIGFuIHVub3JkZXJlZCBsaXN0XG4gICAgICAgIC8vIDxvbD48bGk+Zm9vPC9saT48bGk+YmFyPC9saT48L29sPlxuICAgICAgICAvLyBiZWNvbWVzOlxuICAgICAgICAvLyA8dWw+PGxpPmZvbzwvbGk+PGxpPmJhcjwvbGk+PC91bD5cbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlU2ltcGxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHd5c2lodG1sNS5kb20ucmVuYW1lRWxlbWVudChvdGhlckxpc3QsIFwidWxcIik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3JlYXRlIGxpc3RcbiAgICAgICAgY29tcG9zZXIuY29tbWFuZHMuZXhlYyhcImZvcm1hdEJsb2NrXCIsIFwiZGl2XCIsIHRlbXBDbGFzc05hbWUpO1xuICAgICAgICB0ZW1wRWxlbWVudCA9IGRvYy5xdWVyeVNlbGVjdG9yKFwiLlwiICsgdGVtcENsYXNzTmFtZSk7XG4gICAgICAgIGlzRW1wdHkgPSB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPT09IFwiXCIgfHwgdGVtcEVsZW1lbnQuaW5uZXJIVE1MID09PSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFO1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGlzdCA9IHd5c2lodG1sNS5kb20uY29udmVydFRvTGlzdCh0ZW1wRWxlbWVudCwgXCJ1bFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNlbGVjdE5vZGUobGlzdC5xdWVyeVNlbGVjdG9yKFwibGlcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzdGF0ZTogZnVuY3Rpb24oY29tcG9zZXIpIHtcbiAgICAgIHZhciBzZWxlY3RlZE5vZGUgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwgeyBub2RlTmFtZTogXCJVTFwiIH0pO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZjtcbiAgXG4gIHd5c2lodG1sNS5jb21tYW5kcy5pdGFsaWMgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIFwiaVwiKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kLCBjb2xvcikge1xuICAgICAgLy8gZWxlbWVudC5vd25lckRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN0YXRlKFwiaXRhbGljXCIpIHJlc3VsdHM6XG4gICAgICAvLyBmaXJlZm94OiBvbmx5IDxpPlxuICAgICAgLy8gY2hyb21lOiAgPGk+LCA8ZW0+LCA8YmxvY2txdW90ZT4sIC4uLlxuICAgICAgLy8gaWU6ICAgICAgPGk+LCA8ZW0+XG4gICAgICAvLyBvcGVyYTogICBvbmx5IDxpPlxuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIFwiaVwiKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWYsXG4gICAgICBDTEFTU19OQU1FICA9IFwid3lzaXd5Zy10ZXh0LWFsaWduLWNlbnRlclwiLFxuICAgICAgUkVHX0VYUCAgICAgPSAvd3lzaXd5Zy10ZXh0LWFsaWduLVthLXpdKy9nO1xuICBcbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmp1c3RpZnlDZW50ZXIgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0QmxvY2suZXhlYyhjb21wb3NlciwgXCJmb3JtYXRCbG9ja1wiLCBudWxsLCBDTEFTU19OQU1FLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrLnN0YXRlKGNvbXBvc2VyLCBcImZvcm1hdEJsb2NrXCIsIG51bGwsIENMQVNTX05BTUUsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZixcbiAgICAgIENMQVNTX05BTUUgID0gXCJ3eXNpd3lnLXRleHQtYWxpZ24tbGVmdFwiLFxuICAgICAgUkVHX0VYUCAgICAgPSAvd3lzaXd5Zy10ZXh0LWFsaWduLVthLXpdKy9nO1xuICBcbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmp1c3RpZnlMZWZ0ID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrLmV4ZWMoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgQ0xBU1NfTkFNRSwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRCbG9jay5zdGF0ZShjb21wb3NlciwgXCJmb3JtYXRCbG9ja1wiLCBudWxsLCBDTEFTU19OQU1FLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWYsXG4gICAgICBDTEFTU19OQU1FICA9IFwid3lzaXd5Zy10ZXh0LWFsaWduLXJpZ2h0XCIsXG4gICAgICBSRUdfRVhQICAgICA9IC93eXNpd3lnLXRleHQtYWxpZ24tW2Etel0rL2c7XG4gIFxuICB3eXNpaHRtbDUuY29tbWFuZHMuanVzdGlmeVJpZ2h0ID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrLmV4ZWMoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgQ0xBU1NfTkFNRSwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbihjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRCbG9jay5zdGF0ZShjb21wb3NlciwgXCJmb3JtYXRCbG9ja1wiLCBudWxsLCBDTEFTU19OQU1FLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWY7XG4gIHd5c2lodG1sNS5jb21tYW5kcy51bmRlcmxpbmUgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24oY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIFwidVwiKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJ1XCIpO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsvKipcbiAqIFVuZG8gTWFuYWdlciBmb3Igd3lzaWh0bWw1XG4gKiBzbGlnaHRseSBpbnNwaXJlZCBieSBodHRwOi8vcm5pd2EuY29tL2VkaXRpbmcvdW5kb21hbmFnZXIuaHRtbCN0aGUtdW5kb21hbmFnZXItaW50ZXJmYWNlXG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIFpfS0VZICAgICAgICAgICAgICAgPSA5MCxcbiAgICAgIFlfS0VZICAgICAgICAgICAgICAgPSA4OSxcbiAgICAgIEJBQ0tTUEFDRV9LRVkgICAgICAgPSA4LFxuICAgICAgREVMRVRFX0tFWSAgICAgICAgICA9IDQ2LFxuICAgICAgTUFYX0hJU1RPUllfRU5UUklFUyA9IDQwLFxuICAgICAgVU5ET19IVE1MICAgICAgICAgICA9ICc8c3BhbiBpZD1cIl93eXNpaHRtbDUtdW5kb1wiIGNsYXNzPVwiX3d5c2lodG1sNS10ZW1wXCI+JyArIHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UgKyAnPC9zcGFuPicsXG4gICAgICBSRURPX0hUTUwgICAgICAgICAgID0gJzxzcGFuIGlkPVwiX3d5c2lodG1sNS1yZWRvXCIgY2xhc3M9XCJfd3lzaWh0bWw1LXRlbXBcIj4nICsgd3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRSArICc8L3NwYW4+JyxcbiAgICAgIGRvbSAgICAgICAgICAgICAgICAgPSB3eXNpaHRtbDUuZG9tO1xuICBcbiAgZnVuY3Rpb24gY2xlYW5UZW1wRWxlbWVudHMoZG9jKSB7XG4gICAgdmFyIHRlbXBFbGVtZW50O1xuICAgIHdoaWxlICh0ZW1wRWxlbWVudCA9IGRvYy5xdWVyeVNlbGVjdG9yKFwiLl93eXNpaHRtbDUtdGVtcFwiKSkge1xuICAgICAgdGVtcEVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZW1wRWxlbWVudCk7XG4gICAgfVxuICB9XG4gIFxuICB3eXNpaHRtbDUuVW5kb01hbmFnZXIgPSB3eXNpaHRtbDUubGFuZy5EaXNwYXRjaGVyLmV4dGVuZChcbiAgICAvKiogQHNjb3BlIHd5c2lodG1sNS5VbmRvTWFuYWdlci5wcm90b3R5cGUgKi8ge1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgdGhpcy5jb21wb3NlciA9IGVkaXRvci5jb21wb3NlcjtcbiAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuY29tcG9zZXIuZWxlbWVudDtcbiAgICAgIHRoaXMuaGlzdG9yeSA9IFt0aGlzLmNvbXBvc2VyLmdldFZhbHVlKCldO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IDE7XG4gICAgICBcbiAgICAgIC8vIFVuZG8gbWFuYWdlciBjdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcnMgd2hvIGhhdmUgdGhlIGluc2VydEhUTUwgY29tbWFuZCAobm90IElFKVxuICAgICAgaWYgKHRoaXMuY29tcG9zZXIuY29tbWFuZHMuc3VwcG9ydChcImluc2VydEhUTUxcIikpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgX29ic2VydmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoYXQgICAgICA9IHRoaXMsXG4gICAgICAgICAgZG9jICAgICAgID0gdGhpcy5jb21wb3Nlci5zYW5kYm94LmdldERvY3VtZW50KCksXG4gICAgICAgICAgbGFzdEtleTtcbiAgICAgICAgICBcbiAgICAgIC8vIENhdGNoIENUUkwrWiBhbmQgQ1RSTCtZXG4gICAgICBkb20ub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuYWx0S2V5IHx8ICghZXZlbnQuY3RybEtleSAmJiAhZXZlbnQubWV0YUtleSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZSxcbiAgICAgICAgICAgIGlzVW5kbyA9IGtleUNvZGUgPT09IFpfS0VZICYmICFldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgIGlzUmVkbyA9IChrZXlDb2RlID09PSBaX0tFWSAmJiBldmVudC5zaGlmdEtleSkgfHwgKGtleUNvZGUgPT09IFlfS0VZKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc1VuZG8pIHtcbiAgICAgICAgICB0aGF0LnVuZG8oKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmVkbykge1xuICAgICAgICAgIHRoYXQucmVkbygpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBDYXRjaCBkZWxldGUgYW5kIGJhY2tzcGFjZVxuICAgICAgZG9tLm9ic2VydmUodGhpcy5lbGVtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gbGFzdEtleSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGFzdEtleSA9IGtleUNvZGU7XG4gICAgICAgIFxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gQkFDS1NQQUNFX0tFWSB8fCBrZXlDb2RlID09PSBERUxFVEVfS0VZKSB7XG4gICAgICAgICAgdGhhdC50cmFuc2FjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTm93IHRoaXMgaXMgdmVyeSBoYWNreTpcbiAgICAgIC8vIFRoZXNlIGRheXMgYnJvd3NlcnMgZG9uJ3Qgb2ZmZXIgYSB1bmRvL3JlZG8gZXZlbnQgd2hpY2ggd2UgY291bGQgaG9vayBpbnRvXG4gICAgICAvLyB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB1c2VyIGhpdHMgdW5kby9yZWRvIGluIHRoZSBjb250ZXh0bWVudS5cbiAgICAgIC8vIFRoZXJlZm9yZSB3ZSBzaW1wbHkgaW5zZXJ0IHR3byBlbGVtZW50cyBhcyBzb29uIGFzIHRoZSBjb250ZXh0bWVudSBnZXRzIG9wZW5lZC5cbiAgICAgIC8vIFRoZSBsYXN0IGVsZW1lbnQgYmVpbmcgaW5zZXJ0ZWQgd2lsbCBiZSBpbW1lZGlhdGVseSBiZSByZW1vdmVkIGFnYWluIGJ5IGEgZXhleENvbW1hbmQoXCJ1bmRvXCIpXG4gICAgICAvLyAgPT4gV2hlbiB0aGUgc2Vjb25kIGVsZW1lbnQgYXBwZWFycyBpbiB0aGUgZG9tIHRyZWUgdGhlbiB3ZSBrbm93IHRoZSB1c2VyIGNsaWNrZWQgXCJyZWRvXCIgaW4gdGhlIGNvbnRleHQgbWVudVxuICAgICAgLy8gID0+IFdoZW4gdGhlIGZpcnN0IGVsZW1lbnQgZGlzYXBwZWFycyBmcm9tIHRoZSBkb20gdHJlZSB0aGVuIHdlIGtub3cgdGhlIHVzZXIgY2xpY2tlZCBcInVuZG9cIiBpbiB0aGUgY29udGV4dCBtZW51XG4gICAgICBpZiAod3lzaWh0bWw1LmJyb3dzZXIuaGFzVW5kb0luQ29udGV4dE1lbnUoKSkge1xuICAgICAgICB2YXIgaW50ZXJ2YWwsIG9ic2VydmVkLCBjbGVhblVwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xlYW5UZW1wRWxlbWVudHMoZG9jKTtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGRvbS5vYnNlcnZlKHRoaXMuZWxlbWVudCwgXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGVhblVwKCk7XG4gICAgICAgICAgdGhhdC5jb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhhdC5lbGVtZW50Lmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICB0aGF0LmNvbXBvc2VyLnNlbGVjdGlvbi5zZXRBZnRlcih0aGF0LmVsZW1lbnQubGFzdENoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZW5hYmxlIHVuZG8gYnV0dG9uIGluIGNvbnRleHQgbWVudVxuICAgICAgICAgICAgZG9jLmV4ZWNDb21tYW5kKFwiaW5zZXJ0SFRNTFwiLCBmYWxzZSwgVU5ET19IVE1MKTtcbiAgICAgICAgICAgIC8vIGVuYWJsZSByZWRvIGJ1dHRvbiBpbiBjb250ZXh0IG1lbnVcbiAgICAgICAgICAgIGRvYy5leGVjQ29tbWFuZChcImluc2VydEhUTUxcIiwgZmFsc2UsIFJFRE9fSFRNTCk7XG4gICAgICAgICAgICBkb2MuZXhlY0NvbW1hbmQoXCJ1bmRvXCIsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZG9jLmdldEVsZW1lbnRCeUlkKFwiX3d5c2lodG1sNS1yZWRvXCIpKSB7XG4gICAgICAgICAgICAgIGNsZWFuVXAoKTtcbiAgICAgICAgICAgICAgdGhhdC5yZWRvKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFkb2MuZ2V0RWxlbWVudEJ5SWQoXCJfd3lzaWh0bWw1LXVuZG9cIikpIHtcbiAgICAgICAgICAgICAgY2xlYW5VcCgpO1xuICAgICAgICAgICAgICB0aGF0LnVuZG8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCA0MDApO1xuXG4gICAgICAgICAgaWYgKCFvYnNlcnZlZCkge1xuICAgICAgICAgICAgb2JzZXJ2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZG9tLm9ic2VydmUoZG9jdW1lbnQsIFwibW91c2Vkb3duXCIsIGNsZWFuVXApO1xuICAgICAgICAgICAgZG9tLm9ic2VydmUoZG9jLCBbXCJtb3VzZWRvd25cIiwgXCJwYXN0ZVwiLCBcImN1dFwiLCBcImNvcHlcIl0sIGNsZWFuVXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRoaXMuZWRpdG9yXG4gICAgICAgIC5vYnNlcnZlKFwibmV3d29yZDpjb21wb3NlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGF0LnRyYW5zYWN0KCk7XG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICAub2JzZXJ2ZShcImJlZm9yZWNvbW1hbmQ6Y29tcG9zZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhhdC50cmFuc2FjdCgpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFxuICAgIHRyYW5zYWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwcmV2aW91c0h0bWwgID0gdGhpcy5oaXN0b3J5W3RoaXMucG9zaXRpb24gLSAxXSxcbiAgICAgICAgICBjdXJyZW50SHRtbCAgID0gdGhpcy5jb21wb3Nlci5nZXRWYWx1ZSgpO1xuICAgICAgXG4gICAgICBpZiAoY3VycmVudEh0bWwgPT0gcHJldmlvdXNIdG1sKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuaGlzdG9yeS5sZW5ndGggPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgaWYgKGxlbmd0aCA+IE1BWF9ISVNUT1JZX0VOVFJJRVMpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5LnNoaWZ0KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24tLTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgdGhpcy5oaXN0b3J5LnB1c2goY3VycmVudEh0bWwpO1xuICAgIH0sXG4gICAgXG4gICAgdW5kbzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRyYW5zYWN0KCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLnNldCh0aGlzLmhpc3RvcnlbLS10aGlzLnBvc2l0aW9uIC0gMV0pO1xuICAgICAgdGhpcy5lZGl0b3IuZmlyZShcInVuZG86Y29tcG9zZXJcIik7XG4gICAgfSxcbiAgICBcbiAgICByZWRvOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uID49IHRoaXMuaGlzdG9yeS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLnNldCh0aGlzLmhpc3RvcnlbKyt0aGlzLnBvc2l0aW9uIC0gMV0pO1xuICAgICAgdGhpcy5lZGl0b3IuZmlyZShcInJlZG86Y29tcG9zZXJcIik7XG4gICAgfSxcbiAgICBcbiAgICBzZXQ6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgIHRoaXMuY29tcG9zZXIuc2V0VmFsdWUoaHRtbCk7XG4gICAgICB0aGlzLmVkaXRvci5mb2N1cyh0cnVlKTtcbiAgICB9XG4gIH0pO1xufSkod3lzaWh0bWw1KTtcbi8qKlxuICogVE9ETzogdGhlIGZvbGxvd2luZyBtZXRob2RzIHN0aWxsIG5lZWQgdW5pdCB0ZXN0IGNvdmVyYWdlXG4gKi9cbnd5c2lodG1sNS52aWV3cy5WaWV3ID0gQmFzZS5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LnZpZXdzLlZpZXcucHJvdG90eXBlICovIHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKHBhcmVudCwgdGV4dGFyZWFFbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLnBhcmVudCAgID0gcGFyZW50O1xuICAgIHRoaXMuZWxlbWVudCAgPSB0ZXh0YXJlYUVsZW1lbnQ7XG4gICAgdGhpcy5jb25maWcgICA9IGNvbmZpZztcbiAgICBcbiAgICB0aGlzLl9vYnNlcnZlVmlld0NoYW5nZSgpO1xuICB9LFxuICBcbiAgX29ic2VydmVWaWV3Q2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy5wYXJlbnQub2JzZXJ2ZShcImJlZm9yZWxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICB0aGF0LnBhcmVudC5vYnNlcnZlKFwiY2hhbmdlX3ZpZXdcIiwgZnVuY3Rpb24odmlldykge1xuICAgICAgICBpZiAodmlldyA9PT0gdGhhdC5uYW1lKSB7XG4gICAgICAgICAgdGhhdC5wYXJlbnQuY3VycmVudFZpZXcgPSB0aGF0O1xuICAgICAgICAgIHRoYXQuc2hvdygpO1xuICAgICAgICAgIC8vIFVzaW5nIHRpbnkgZGVsYXkgaGVyZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgcGxhY2Vob2xkZXIgaXMgc2V0IGJlZm9yZSBmb2N1c2luZ1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRoYXQuZm9jdXMoKTsgfSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhhdC5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBcbiAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiOmZvY3VzXCIpID09PSB0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHsgdGhpcy5lbGVtZW50LmZvY3VzKCk7IH0gY2F0Y2goZSkge31cbiAgfSxcbiAgXG4gIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIH0sXG4gIFxuICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gIH0sXG4gIFxuICBkaXNhYmxlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgfSxcbiAgXG4gIGVuYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpO1xuICB9XG59KTsoZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciBkb20gICAgICAgPSB3eXNpaHRtbDUuZG9tLFxuICAgICAgYnJvd3NlciAgID0gd3lzaWh0bWw1LmJyb3dzZXI7XG4gIFxuICB3eXNpaHRtbDUudmlld3MuQ29tcG9zZXIgPSB3eXNpaHRtbDUudmlld3MuVmlldy5leHRlbmQoXG4gICAgLyoqIEBzY29wZSB3eXNpaHRtbDUudmlld3MuQ29tcG9zZXIucHJvdG90eXBlICovIHtcbiAgICBuYW1lOiBcImNvbXBvc2VyXCIsXG5cbiAgICAvLyBOZWVkZWQgZm9yIGZpcmVmb3ggaW4gb3JkZXIgdG8gZGlzcGxheSBhIHByb3BlciBjYXJldCBpbiBhbiBlbXB0eSBjb250ZW50RWRpdGFibGVcbiAgICBDQVJFVF9IQUNLOiBcIjxicj5cIixcblxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihwYXJlbnQsIHRleHRhcmVhRWxlbWVudCwgY29uZmlnKSB7XG4gICAgICB0aGlzLmJhc2UocGFyZW50LCB0ZXh0YXJlYUVsZW1lbnQsIGNvbmZpZyk7XG4gICAgICB0aGlzLnRleHRhcmVhID0gdGhpcy5wYXJlbnQudGV4dGFyZWE7XG4gICAgICB0aGlzLl9pbml0U2FuZGJveCgpO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gYnJvd3Nlci5kaXNwbGF5c0NhcmV0SW5FbXB0eUNvbnRlbnRFZGl0YWJsZUNvcnJlY3RseSgpID8gXCJcIiA6IHRoaXMuQ0FSRVRfSEFDSztcbiAgICB9LFxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHBhcnNlKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLmlzRW1wdHkoKSA/IFwiXCIgOiB3eXNpaHRtbDUucXVpcmtzLmdldENvcnJlY3RJbm5lckhUTUwodGhpcy5lbGVtZW50KTtcbiAgICAgIFxuICAgICAgaWYgKHBhcnNlKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5wYXJlbnQucGFyc2UodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXBsYWNlIGFsbCBcInplcm8gd2lkdGggbm8gYnJlYWtpbmcgc3BhY2VcIiBjaGFyc1xuICAgICAgLy8gd2hpY2ggYXJlIHVzZWQgYXMgaGFja3MgdG8gZW5hYmxlIHNvbWUgZnVuY3Rpb25hbGl0aWVzXG4gICAgICAvLyBBbHNvIHJlbW92ZSBhbGwgQ0FSRVQgaGFja3MgdGhhdCBzb21laG93IGdvdCBsZWZ0XG4gICAgICB2YWx1ZSA9IHd5c2lodG1sNS5sYW5nLnN0cmluZyh2YWx1ZSkucmVwbGFjZSh3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFKS5ieShcIlwiKTtcblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oaHRtbCwgcGFyc2UpIHtcbiAgICAgIGlmIChwYXJzZSkge1xuICAgICAgICBodG1sID0gdGhpcy5wYXJlbnQucGFyc2UoaHRtbCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gdGhpcy5fZGlzcGxheVN0eWxlIHx8IFwiXCI7XG5cbiAgICAgIC8vIEZpcmVmb3ggbmVlZHMgdGhpcywgb3RoZXJ3aXNlIGNvbnRlbnRFZGl0YWJsZSBiZWNvbWVzIHVuZWRpdGFibGVcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICB9LFxuXG4gICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9kaXNwbGF5U3R5bGUgPSBkb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20odGhpcy5pZnJhbWUpO1xuICAgICAgaWYgKHRoaXMuX2Rpc3BsYXlTdHlsZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgdGhpcy5fZGlzcGxheVN0eWxlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9LFxuXG4gICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpO1xuICAgICAgdGhpcy5iYXNlKCk7XG4gICAgfSxcblxuICAgIGVuYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIsIFwidHJ1ZVwiKTtcbiAgICAgIHRoaXMuYmFzZSgpO1xuICAgIH0sXG5cbiAgICBmb2N1czogZnVuY3Rpb24oc2V0VG9FbmQpIHtcbiAgICAgIC8vIElFIDggZmlyZXMgdGhlIGZvY3VzIGV2ZW50IGFmdGVyIC5mb2N1cygpXG4gICAgICAvLyBUaGlzIGlzIG5lZWRlZCBieSBvdXIgc2ltdWxhdGVfcGxhY2Vob2xkZXIuanMgdG8gd29ya1xuICAgICAgLy8gdGhlcmVmb3JlIHdlIGNsZWFyIGl0IG91cnNlbHZlcyB0aGlzIHRpbWVcbiAgICAgIGlmICh3eXNpaHRtbDUuYnJvd3Nlci5kb2VzQXN5bmNGb2N1cygpICYmIHRoaXMuaGFzUGxhY2Vob2xkZXJTZXQoKSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRoaXMuYmFzZSgpO1xuICAgICAgXG4gICAgICB2YXIgbGFzdENoaWxkID0gdGhpcy5lbGVtZW50Lmxhc3RDaGlsZDtcbiAgICAgIGlmIChzZXRUb0VuZCAmJiBsYXN0Q2hpbGQpIHtcbiAgICAgICAgaWYgKGxhc3RDaGlsZC5ub2RlTmFtZSA9PT0gXCJCUlwiKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0QmVmb3JlKHRoaXMuZWxlbWVudC5sYXN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldEFmdGVyKHRoaXMuZWxlbWVudC5sYXN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldFRleHRDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkb20uZ2V0VGV4dENvbnRlbnQodGhpcy5lbGVtZW50KTtcbiAgICB9LFxuXG4gICAgaGFzUGxhY2Vob2xkZXJTZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dENvbnRlbnQoKSA9PSB0aGlzLnRleHRhcmVhLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIik7XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlubmVySFRNTCAgICAgICAgICAgICAgID0gdGhpcy5lbGVtZW50LmlubmVySFRNTCxcbiAgICAgICAgICBlbGVtZW50c1dpdGhWaXN1YWxWYWx1ZSA9IFwiYmxvY2txdW90ZSwgdWwsIG9sLCBpbWcsIGVtYmVkLCBvYmplY3QsIHRhYmxlLCBpZnJhbWUsIHN2ZywgdmlkZW8sIGF1ZGlvLCBidXR0b24sIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhXCI7XG4gICAgICByZXR1cm4gaW5uZXJIVE1MID09PSBcIlwiICAgICAgICAgICAgICB8fCBcbiAgICAgICAgICAgICBpbm5lckhUTUwgPT09IHRoaXMuQ0FSRVRfSEFDSyB8fFxuICAgICAgICAgICAgIHRoaXMuaGFzUGxhY2Vob2xkZXJTZXQoKSAgICAgIHx8XG4gICAgICAgICAgICAgKHRoaXMuZ2V0VGV4dENvbnRlbnQoKSA9PT0gXCJcIiAmJiAhdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudHNXaXRoVmlzdWFsVmFsdWUpKTtcbiAgICB9LFxuXG4gICAgX2luaXRTYW5kYm94OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIFxuICAgICAgdGhpcy5zYW5kYm94ID0gbmV3IGRvbS5TYW5kYm94KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0Ll9jcmVhdGUoKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc3R5bGVzaGVldHM6ICB0aGlzLmNvbmZpZy5zdHlsZXNoZWV0c1xuICAgICAgfSk7XG4gICAgICB0aGlzLmlmcmFtZSAgPSB0aGlzLnNhbmRib3guZ2V0SWZyYW1lKCk7XG5cbiAgICAgIC8vIENyZWF0ZSBoaWRkZW4gZmllbGQgd2hpY2ggdGVsbHMgdGhlIHNlcnZlciBhZnRlciBzdWJtaXQsIHRoYXQgdGhlIHVzZXIgdXNlZCBhbiB3eXNpd3lnIGVkaXRvclxuICAgICAgdmFyIGhpZGRlbkZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgaGlkZGVuRmllbGQudHlwZSAgID0gXCJoaWRkZW5cIjtcbiAgICAgIGhpZGRlbkZpZWxkLm5hbWUgICA9IFwiX3d5c2lodG1sNV9tb2RlXCI7XG4gICAgICBoaWRkZW5GaWVsZC52YWx1ZSAgPSAxO1xuXG4gICAgICAvLyBTdG9yZSByZWZlcmVuY2UgdG8gY3VycmVudCB3eXNpaHRtbDUgaW5zdGFuY2Ugb24gdGhlIHRleHRhcmVhIGVsZW1lbnRcbiAgICAgIHZhciB0ZXh0YXJlYUVsZW1lbnQgPSB0aGlzLnRleHRhcmVhLmVsZW1lbnQ7XG4gICAgICBkb20uaW5zZXJ0KHRoaXMuaWZyYW1lKS5hZnRlcih0ZXh0YXJlYUVsZW1lbnQpO1xuICAgICAgZG9tLmluc2VydChoaWRkZW5GaWVsZCkuYWZ0ZXIodGV4dGFyZWFFbGVtZW50KTtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICBcbiAgICAgIHRoaXMuZG9jICAgICAgICAgICAgICAgID0gdGhpcy5zYW5kYm94LmdldERvY3VtZW50KCk7XG4gICAgICB0aGlzLmVsZW1lbnQgICAgICAgICAgICA9IHRoaXMuZG9jLmJvZHk7XG4gICAgICB0aGlzLnRleHRhcmVhICAgICAgICAgICA9IHRoaXMucGFyZW50LnRleHRhcmVhO1xuICAgICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCAgPSB0aGlzLnRleHRhcmVhLmdldFZhbHVlKHRydWUpO1xuICAgICAgdGhpcy5lbmFibGUoKTtcbiAgICAgIFxuICAgICAgLy8gTWFrZSBzdXJlIG91ciBzZWxlY3Rpb24gaGFuZGxlciBpcyByZWFkeVxuICAgICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgd3lzaWh0bWw1LlNlbGVjdGlvbih0aGlzLnBhcmVudCk7XG4gICAgICBcbiAgICAgIC8vIE1ha2Ugc3VyZSBjb21tYW5kcyBkaXNwYXRjaGVyIGlzIHJlYWR5XG4gICAgICB0aGlzLmNvbW1hbmRzICA9IG5ldyB3eXNpaHRtbDUuQ29tbWFuZHModGhpcy5wYXJlbnQpO1xuXG4gICAgICBkb20uY29weUF0dHJpYnV0ZXMoW1xuICAgICAgICBcImNsYXNzTmFtZVwiLCBcInNwZWxsY2hlY2tcIiwgXCJ0aXRsZVwiLCBcImxhbmdcIiwgXCJkaXJcIiwgXCJhY2Nlc3NLZXlcIlxuICAgICAgXSkuZnJvbSh0aGlzLnRleHRhcmVhLmVsZW1lbnQpLnRvKHRoaXMuZWxlbWVudCk7XG4gICAgICBcbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmVsZW1lbnQsIHRoaXMuY29uZmlnLmNvbXBvc2VyQ2xhc3NOYW1lKTtcblxuICAgICAgLy8gTWFrZSB0aGUgZWRpdG9yIGxvb2sgbGlrZSB0aGUgb3JpZ2luYWwgdGV4dGFyZWEsIGJ5IHN5bmNpbmcgc3R5bGVzXG4gICAgICBpZiAodGhpcy5jb25maWcuc3R5bGUpIHtcbiAgICAgICAgdGhpcy5zdHlsZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9ic2VydmUoKTtcblxuICAgICAgdmFyIG5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZWxlbWVudCwgbmFtZSk7XG4gICAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmlmcmFtZSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNpbXVsYXRlIGh0bWw1IHBsYWNlaG9sZGVyIGF0dHJpYnV0ZSBvbiBjb250ZW50RWRpdGFibGUgZWxlbWVudFxuICAgICAgdmFyIHBsYWNlaG9sZGVyVGV4dCA9IHR5cGVvZih0aGlzLmNvbmZpZy5wbGFjZWhvbGRlcikgPT09IFwic3RyaW5nXCJcbiAgICAgICAgPyB0aGlzLmNvbmZpZy5wbGFjZWhvbGRlclxuICAgICAgICA6IHRoaXMudGV4dGFyZWEuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKTtcbiAgICAgIGlmIChwbGFjZWhvbGRlclRleHQpIHtcbiAgICAgICAgZG9tLnNpbXVsYXRlUGxhY2Vob2xkZXIodGhpcy5wYXJlbnQsIHRoaXMsIHBsYWNlaG9sZGVyVGV4dCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBicm93c2VyIGF2b2lkcyB1c2luZyBpbmxpbmUgc3R5bGVzIHdoZW5ldmVyIHBvc3NpYmxlXG4gICAgICB0aGlzLmNvbW1hbmRzLmV4ZWMoXCJzdHlsZVdpdGhDU1NcIiwgZmFsc2UpO1xuXG4gICAgICB0aGlzLl9pbml0QXV0b0xpbmtpbmcoKTtcbiAgICAgIHRoaXMuX2luaXRPYmplY3RSZXNpemluZygpO1xuICAgICAgdGhpcy5faW5pdFVuZG9NYW5hZ2VyKCk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIGh0bWw1IGF1dG9mb2N1cyBvbiBjb250ZW50RWRpdGFibGUgZWxlbWVudFxuICAgICAgaWYgKHRoaXMudGV4dGFyZWEuZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJhdXRvZm9jdXNcIikgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIjpmb2N1c1wiKSA9PSB0aGlzLnRleHRhcmVhLmVsZW1lbnQpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhhdC5mb2N1cygpOyB9LCAxMDApO1xuICAgICAgfVxuXG4gICAgICB3eXNpaHRtbDUucXVpcmtzLmluc2VydExpbmVCcmVha09uUmV0dXJuKHRoaXMpO1xuXG4gICAgICAvLyBJRSBzb21ldGltZXMgbGVhdmVzIGEgc2luZ2xlIHBhcmFncmFwaCwgd2hpY2ggY2FuJ3QgYmUgcmVtb3ZlZCBieSB0aGUgdXNlclxuICAgICAgaWYgKCFicm93c2VyLmNsZWFyc0NvbnRlbnRFZGl0YWJsZUNvcnJlY3RseSgpKSB7XG4gICAgICAgIHd5c2lodG1sNS5xdWlya3MuZW5zdXJlUHJvcGVyQ2xlYXJpbmcodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYnJvd3Nlci5jbGVhcnNMaXN0c0luQ29udGVudEVkaXRhYmxlQ29ycmVjdGx5KCkpIHtcbiAgICAgICAgd3lzaWh0bWw1LnF1aXJrcy5lbnN1cmVQcm9wZXJDbGVhcmluZ09mTGlzdHModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBhIHN5bmMgdGhhdCBtYWtlcyBzdXJlIHRoYXQgdGV4dGFyZWEgYW5kIGVkaXRvciBoYXZlIHRoZSBzYW1lIGNvbnRlbnRcbiAgICAgIGlmICh0aGlzLmluaXRTeW5jICYmIHRoaXMuY29uZmlnLnN5bmMpIHtcbiAgICAgICAgdGhpcy5pbml0U3luYygpO1xuICAgICAgfVxuXG4gICAgICAvLyBPa2F5IGhpZGUgdGhlIHRleHRhcmVhLCB3ZSBhcmUgcmVhZHkgdG8gZ29cbiAgICAgIHRoaXMudGV4dGFyZWEuaGlkZSgpO1xuXG4gICAgICAvLyBGaXJlIGdsb2JhbCAoYmVmb3JlLSlsb2FkIGV2ZW50XG4gICAgICB0aGlzLnBhcmVudC5maXJlKFwiYmVmb3JlbG9hZFwiKS5maXJlKFwibG9hZFwiKTtcbiAgICB9LFxuXG4gICAgX2luaXRBdXRvTGlua2luZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhhdCAgICAgICAgICAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICBzdXBwb3J0c0Rpc2FibGluZ09mQXV0b0xpbmtpbmcgPSBicm93c2VyLmNhbkRpc2FibGVBdXRvTGlua2luZygpLFxuICAgICAgICAgIHN1cHBvcnRzQXV0b0xpbmtpbmcgICAgICAgICAgICA9IGJyb3dzZXIuZG9lc0F1dG9MaW5raW5nSW5Db250ZW50RWRpdGFibGUoKTtcbiAgICAgIGlmIChzdXBwb3J0c0Rpc2FibGluZ09mQXV0b0xpbmtpbmcpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5leGVjKFwiYXV0b1VybERldGVjdFwiLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jb25maWcuYXV0b0xpbmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IGRvIHRoZSBhdXRvIGxpbmtpbmcgYnkgb3Vyc2VsdmVzIHdoZW4gdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGF1dG8gbGlua2luZ1xuICAgICAgLy8gT1Igd2hlbiBoZSBzdXBwb3J0cyBhdXRvIGxpbmtpbmcgYnV0IHdlIHdlcmUgYWJsZSB0byB0dXJuIGl0IG9mZiAoSUU5KylcbiAgICAgIGlmICghc3VwcG9ydHNBdXRvTGlua2luZyB8fCAoc3VwcG9ydHNBdXRvTGlua2luZyAmJiBzdXBwb3J0c0Rpc2FibGluZ09mQXV0b0xpbmtpbmcpKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm9ic2VydmUoXCJuZXd3b3JkOmNvbXBvc2VyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoYXQuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlKGZ1bmN0aW9uKHN0YXJ0Q29udGFpbmVyLCBlbmRDb250YWluZXIpIHtcbiAgICAgICAgICAgIGRvbS5hdXRvTGluayhlbmRDb250YWluZXIucGFyZW50Tm9kZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBBc3N1bWluZyB3ZSBoYXZlIHRoZSBmb2xsb3dpbmc6XG4gICAgICAvLyAgPGEgaHJlZj1cImh0dHA6Ly93d3cuZ29vZ2xlLmRlXCI+aHR0cDovL3d3dy5nb29nbGUuZGU8L2E+XG4gICAgICAvLyBJZiBhIHVzZXIgbm93IGNoYW5nZXMgdGhlIHVybCBpbiB0aGUgaW5uZXJIVE1MIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXRcbiAgICAgIC8vIGl0J3Mgc3luY2hyb25pemVkIHdpdGggdGhlIGhyZWYgYXR0cmlidXRlIChhcyBsb25nIGFzIHRoZSBpbm5lckhUTUwgaXMgc3RpbGwgYSB1cmwpXG4gICAgICB2YXIgLy8gVXNlIGEgbGl2ZSBOb2RlTGlzdCB0byBjaGVjayB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgbGlua3MgaW4gdGhlIGRvY3VtZW50XG4gICAgICAgICAgbGlua3MgICAgICAgICAgID0gdGhpcy5zYW5kYm94LmdldERvY3VtZW50KCkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhXCIpLFxuICAgICAgICAgIC8vIFRoZSBhdXRvTGluayBoZWxwZXIgbWV0aG9kIHJldmVhbHMgYSByZWcgZXhwIHRvIGRldGVjdCBjb3JyZWN0IHVybHNcbiAgICAgICAgICB1cmxSZWdFeHAgICAgICAgPSBkb20uYXV0b0xpbmsuVVJMX1JFR19FWFAsXG4gICAgICAgICAgZ2V0VGV4dENvbnRlbnQgID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRleHRDb250ZW50ID0gd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKGRvbS5nZXRUZXh0Q29udGVudChlbGVtZW50KSkudHJpbSgpO1xuICAgICAgICAgICAgaWYgKHRleHRDb250ZW50LnN1YnN0cigwLCA0KSA9PT0gXCJ3d3cuXCIpIHtcbiAgICAgICAgICAgICAgdGV4dENvbnRlbnQgPSBcImh0dHA6Ly9cIiArIHRleHRDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRleHRDb250ZW50O1xuICAgICAgICAgIH07XG5cbiAgICAgIGRvbS5vYnNlcnZlKHRoaXMuZWxlbWVudCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghbGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGVjdGVkTm9kZSA9IHRoYXQuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZShldmVudC50YXJnZXQub3duZXJEb2N1bWVudCksXG4gICAgICAgICAgICBsaW5rICAgICAgICAgPSBkb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHsgbm9kZU5hbWU6IFwiQVwiIH0sIDQpLFxuICAgICAgICAgICAgdGV4dENvbnRlbnQ7XG5cbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dENvbnRlbnQgPSBnZXRUZXh0Q29udGVudChsaW5rKTtcbiAgICAgICAgLy8ga2V5ZG93biBpcyBmaXJlZCBiZWZvcmUgdGhlIGFjdHVhbCBjb250ZW50IGlzIGNoYW5nZWRcbiAgICAgICAgLy8gdGhlcmVmb3JlIHdlIHNldCBhIHRpbWVvdXQgdG8gY2hhbmdlIHRoZSBocmVmXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIG5ld1RleHRDb250ZW50ID0gZ2V0VGV4dENvbnRlbnQobGluayk7XG4gICAgICAgICAgaWYgKG5ld1RleHRDb250ZW50ID09PSB0ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE9ubHkgc2V0IGhyZWYgd2hlbiBuZXcgaHJlZiBsb29rcyBsaWtlIGEgdmFsaWQgdXJsXG4gICAgICAgICAgaWYgKG5ld1RleHRDb250ZW50Lm1hdGNoKHVybFJlZ0V4cCkpIHtcbiAgICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBuZXdUZXh0Q29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfaW5pdE9iamVjdFJlc2l6aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzICAgICAgICA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLFxuICAgICAgICAgIHByb3BlcnRpZXNMZW5ndGggID0gcHJvcGVydGllcy5sZW5ndGgsXG4gICAgICAgICAgZWxlbWVudCAgICAgICAgICAgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICBcbiAgICAgIHRoaXMuY29tbWFuZHMuZXhlYyhcImVuYWJsZU9iamVjdFJlc2l6aW5nXCIsIHRoaXMuY29uZmlnLmFsbG93T2JqZWN0UmVzaXppbmcpO1xuICAgICAgXG4gICAgICBpZiAodGhpcy5jb25maWcuYWxsb3dPYmplY3RSZXNpemluZykge1xuICAgICAgICAgLy8gSUUgc2V0cyBpbmxpbmUgc3R5bGVzIGFmdGVyIHJlc2l6aW5nIG9iamVjdHNcbiAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbGluZXMgbWFrZSBzdXJlIHRoYXQgdGhlIHdpZHRoL2hlaWdodCBjc3MgcHJvcGVydGllc1xuICAgICAgICAgLy8gYXJlIGNvcGllZCBvdmVyIHRvIHRoZSB3aWR0aC9oZWlnaHQgYXR0cmlidXRlc1xuICAgICAgICBpZiAoYnJvd3Nlci5zdXBwb3J0c0V2ZW50KFwicmVzaXplZW5kXCIpKSB7XG4gICAgICAgICAgZG9tLm9ic2VydmUoZWxlbWVudCwgXCJyZXNpemVlbmRcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudCxcbiAgICAgICAgICAgICAgICBzdHlsZSAgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgICAgICAgICAgaSAgICAgID0gMCxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvcig7IGk8cHJvcGVydGllc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgaWYgKHN0eWxlW3Byb3BlcnR5XSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUocHJvcGVydHksIHBhcnNlSW50KHN0eWxlW3Byb3BlcnR5XSwgMTApKTtcbiAgICAgICAgICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSBcIlwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZnRlciByZXNpemluZyBJRSBzb21ldGltZXMgZm9yZ2V0cyB0byByZW1vdmUgdGhlIG9sZCByZXNpemUgaGFuZGxlc1xuICAgICAgICAgICAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcoZWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChicm93c2VyLnN1cHBvcnRzRXZlbnQoXCJyZXNpemVzdGFydFwiKSkge1xuICAgICAgICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwicmVzaXplc3RhcnRcIiwgZnVuY3Rpb24oZXZlbnQpIHsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIF9pbml0VW5kb01hbmFnZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgbmV3IHd5c2lodG1sNS5VbmRvTWFuYWdlcih0aGlzLnBhcmVudCk7XG4gICAgfVxuICB9KTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgZG9tICAgICAgICAgICAgID0gd3lzaWh0bWw1LmRvbSxcbiAgICAgIGRvYyAgICAgICAgICAgICA9IGRvY3VtZW50LFxuICAgICAgd2luICAgICAgICAgICAgID0gd2luZG93LFxuICAgICAgSE9TVF9URU1QTEFURSAgID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAvKipcbiAgICAgICAqIFN0eWxlcyB0byBjb3B5IGZyb20gdGV4dGFyZWEgdG8gdGhlIGNvbXBvc2VyIGVsZW1lbnRcbiAgICAgICAqL1xuICAgICAgVEVYVF9GT1JNQVRUSU5HID0gW1xuICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIixcbiAgICAgICAgXCJjb2xvclwiLCBcImN1cnNvclwiLFxuICAgICAgICBcImZvbnQtZmFtaWx5XCIsIFwiZm9udC1zaXplXCIsIFwiZm9udC1zdHlsZVwiLCBcImZvbnQtdmFyaWFudFwiLCBcImZvbnQtd2VpZ2h0XCIsXG4gICAgICAgIFwibGluZS1oZWlnaHRcIiwgXCJsZXR0ZXItc3BhY2luZ1wiLFxuICAgICAgICBcInRleHQtYWxpZ25cIiwgXCJ0ZXh0LWRlY29yYXRpb25cIiwgXCJ0ZXh0LWluZGVudFwiLCBcInRleHQtcmVuZGVyaW5nXCIsXG4gICAgICAgIFwid29yZC1icmVha1wiLCBcIndvcmQtd3JhcFwiLCBcIndvcmQtc3BhY2luZ1wiXG4gICAgICBdLFxuICAgICAgLyoqXG4gICAgICAgKiBTdHlsZXMgdG8gY29weSBmcm9tIHRleHRhcmVhIHRvIHRoZSBpZnJhbWVcbiAgICAgICAqL1xuICAgICAgQk9YX0ZPUk1BVFRJTkcgPSBbXG4gICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiLFxuICAgICAgICBcImJvcmRlci1jb2xsYXBzZVwiLFxuICAgICAgICBcImJvcmRlci1ib3R0b20tY29sb3JcIiwgXCJib3JkZXItYm90dG9tLXN0eWxlXCIsIFwiYm9yZGVyLWJvdHRvbS13aWR0aFwiLFxuICAgICAgICBcImJvcmRlci1sZWZ0LWNvbG9yXCIsIFwiYm9yZGVyLWxlZnQtc3R5bGVcIiwgXCJib3JkZXItbGVmdC13aWR0aFwiLFxuICAgICAgICBcImJvcmRlci1yaWdodC1jb2xvclwiLCBcImJvcmRlci1yaWdodC1zdHlsZVwiLCBcImJvcmRlci1yaWdodC13aWR0aFwiLFxuICAgICAgICBcImJvcmRlci10b3AtY29sb3JcIiwgXCJib3JkZXItdG9wLXN0eWxlXCIsIFwiYm9yZGVyLXRvcC13aWR0aFwiLFxuICAgICAgICBcImNsZWFyXCIsIFwiZGlzcGxheVwiLCBcImZsb2F0XCIsXG4gICAgICAgIFwibWFyZ2luLWJvdHRvbVwiLCBcIm1hcmdpbi1sZWZ0XCIsIFwibWFyZ2luLXJpZ2h0XCIsIFwibWFyZ2luLXRvcFwiLFxuICAgICAgICBcIm91dGxpbmUtY29sb3JcIiwgXCJvdXRsaW5lLW9mZnNldFwiLCBcIm91dGxpbmUtd2lkdGhcIiwgXCJvdXRsaW5lLXN0eWxlXCIsXG4gICAgICAgIFwicGFkZGluZy1sZWZ0XCIsIFwicGFkZGluZy1yaWdodFwiLCBcInBhZGRpbmctdG9wXCIsIFwicGFkZGluZy1ib3R0b21cIixcbiAgICAgICAgXCJwb3NpdGlvblwiLCBcInRvcFwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcInotaW5kZXhcIixcbiAgICAgICAgXCJ2ZXJ0aWNhbC1hbGlnblwiLCBcInRleHQtYWxpZ25cIixcbiAgICAgICAgXCItd2Via2l0LWJveC1zaXppbmdcIiwgXCItbW96LWJveC1zaXppbmdcIiwgXCItbXMtYm94LXNpemluZ1wiLCBcImJveC1zaXppbmdcIixcbiAgICAgICAgXCItd2Via2l0LWJveC1zaGFkb3dcIiwgXCItbW96LWJveC1zaGFkb3dcIiwgXCItbXMtYm94LXNoYWRvd1wiLFwiYm94LXNoYWRvd1wiLFxuICAgICAgICBcIi13ZWJraXQtYm9yZGVyLXRvcC1yaWdodC1yYWRpdXNcIiwgXCItbW96LWJvcmRlci1yYWRpdXMtdG9wcmlnaHRcIiwgXCJib3JkZXItdG9wLXJpZ2h0LXJhZGl1c1wiLFxuICAgICAgICBcIi13ZWJraXQtYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXNcIiwgXCItbW96LWJvcmRlci1yYWRpdXMtYm90dG9tcmlnaHRcIiwgXCJib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1c1wiLFxuICAgICAgICBcIi13ZWJraXQtYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1c1wiLCBcIi1tb3otYm9yZGVyLXJhZGl1cy1ib3R0b21sZWZ0XCIsIFwiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1c1wiLFxuICAgICAgICBcIi13ZWJraXQtYm9yZGVyLXRvcC1sZWZ0LXJhZGl1c1wiLCBcIi1tb3otYm9yZGVyLXJhZGl1cy10b3BsZWZ0XCIsIFwiYm9yZGVyLXRvcC1sZWZ0LXJhZGl1c1wiLFxuICAgICAgICBcIndpZHRoXCIsIFwiaGVpZ2h0XCJcbiAgICAgIF0sXG4gICAgICAvKipcbiAgICAgICAqIFN0eWxlcyB0byBzeW5jIHdoaWxlIHRoZSB3aW5kb3cgZ2V0cyByZXNpemVkXG4gICAgICAgKi9cbiAgICAgIFJFU0laRV9TVFlMRSA9IFtcbiAgICAgICAgXCJ3aWR0aFwiLCBcImhlaWdodFwiLFxuICAgICAgICBcInRvcFwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiXG4gICAgICBdLFxuICAgICAgQURESVRJT05BTF9DU1NfUlVMRVMgPSBbXG4gICAgICAgIFwiaHRtbCAgICAgICAgICAgICB7IGhlaWdodDogMTAwJTsgfVwiLFxuICAgICAgICBcImJvZHkgICAgICAgICAgICAgeyBtaW4taGVpZ2h0OiAxMDAlOyBwYWRkaW5nOiAwOyBtYXJnaW46IDA7IG1hcmdpbi10b3A6IC0xcHg7IHBhZGRpbmctdG9wOiAxcHg7IH1cIixcbiAgICAgICAgXCIuX3d5c2lodG1sNS10ZW1wIHsgZGlzcGxheTogbm9uZTsgfVwiLFxuICAgICAgICB3eXNpaHRtbDUuYnJvd3Nlci5pc0dlY2tvID9cbiAgICAgICAgICBcImJvZHkucGxhY2Vob2xkZXIgeyBjb2xvcjogZ3JheXRleHQgIWltcG9ydGFudDsgfVwiIDogXG4gICAgICAgICAgXCJib2R5LnBsYWNlaG9sZGVyIHsgY29sb3I6ICNhOWE5YTkgIWltcG9ydGFudDsgfVwiLFxuICAgICAgICBcImJvZHlbZGlzYWJsZWRdICAgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlICFpbXBvcnRhbnQ7IGNvbG9yOiAjOTk5ICFpbXBvcnRhbnQ7IGN1cnNvcjogZGVmYXVsdCAhaW1wb3J0YW50OyB9XCIsXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHVzZXIgc2VlJ3MgYnJva2VuIGltYWdlcyBhbmQgY2FuIGRlbGV0ZSB0aGVtXG4gICAgICAgIFwiaW1nOi1tb3otYnJva2VuICB7IC1tb3otZm9yY2UtYnJva2VuLWltYWdlLWljb246IDE7IGhlaWdodDogMjRweDsgd2lkdGg6IDI0cHg7IH1cIlxuICAgICAgXTtcbiAgXG4gIC8qKlxuICAgKiBXaXRoIFwic2V0QWN0aXZlXCIgSUUgb2ZmZXJzIGEgc21hcnQgd2F5IG9mIGZvY3VzaW5nIGVsZW1lbnRzIHdpdGhvdXQgc2Nyb2xsaW5nIHRoZW0gaW50byB2aWV3OlxuICAgKiBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY3Mzgodj12cy44NSkuYXNweFxuICAgKlxuICAgKiBPdGhlciBicm93c2VycyBuZWVkIGEgbW9yZSBoYWNreSB3YXk6IChwc3NzdCBkb24ndCB0ZWxsIG15IG1hbWEpXG4gICAqIEluIG9yZGVyIHRvIHByZXZlbnQgdGhlIGVsZW1lbnQgYmVpbmcgc2Nyb2xsZWQgaW50byB2aWV3IHdoZW4gZm9jdXNpbmcgaXQsIHdlIHNpbXBseVxuICAgKiBtb3ZlIGl0IG91dCBvZiB0aGUgc2Nyb2xsYWJsZSBhcmVhLCBmb2N1cyBpdCwgYW5kIHJlc2V0IGl0J3MgcG9zaXRpb25cbiAgICovXG4gIHZhciBmb2N1c1dpdGhvdXRTY3JvbGxpbmcgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuc2V0QWN0aXZlKSB7XG4gICAgICAvLyBGb2xsb3dpbmcgbGluZSBjb3VsZCBjYXVzZSBhIGpzIGVycm9yIHdoZW4gdGhlIHRleHRhcmVhIGlzIGludmlzaWJsZVxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS94aW5nL3d5c2lodG1sNS9pc3N1ZXMvOVxuICAgICAgdHJ5IHsgZWxlbWVudC5zZXRBY3RpdmUoKTsgfSBjYXRjaChlKSB7fVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWxlbWVudFN0eWxlID0gZWxlbWVudC5zdHlsZSxcbiAgICAgICAgICBvcmlnaW5hbFNjcm9sbFRvcCA9IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvYy5ib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICBvcmlnaW5hbFNjcm9sbExlZnQgPSBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jLmJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgICBvcmlnaW5hbFN0eWxlcyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAgICAgICAgIGVsZW1lbnRTdHlsZS5wb3NpdGlvbixcbiAgICAgICAgICAgIHRvcDogICAgICAgICAgICAgIGVsZW1lbnRTdHlsZS50b3AsXG4gICAgICAgICAgICBsZWZ0OiAgICAgICAgICAgICBlbGVtZW50U3R5bGUubGVmdCxcbiAgICAgICAgICAgIFdlYmtpdFVzZXJTZWxlY3Q6IGVsZW1lbnRTdHlsZS5XZWJraXRVc2VyU2VsZWN0XG4gICAgICAgICAgfTtcbiAgICAgIFxuICAgICAgZG9tLnNldFN0eWxlcyh7XG4gICAgICAgIHBvc2l0aW9uOiAgICAgICAgIFwiYWJzb2x1dGVcIixcbiAgICAgICAgdG9wOiAgICAgICAgICAgICAgXCItOTk5OTlweFwiLFxuICAgICAgICBsZWZ0OiAgICAgICAgICAgICBcIi05OTk5OXB4XCIsXG4gICAgICAgIC8vIERvbid0IGFzayB3aHkgYnV0IHRlbXBvcmFyaWx5IHNldHRpbmcgLXdlYmtpdC11c2VyLXNlbGVjdCB0byBub25lIG1ha2VzIHRoZSB3aG9sZSB0aGluZyBwZXJmb3JtaW5nIHNtb290aGVyXG4gICAgICAgIFdlYmtpdFVzZXJTZWxlY3Q6IFwibm9uZVwiXG4gICAgICB9KS5vbihlbGVtZW50KTtcbiAgICAgIFxuICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgXG4gICAgICBkb20uc2V0U3R5bGVzKG9yaWdpbmFsU3R5bGVzKS5vbihlbGVtZW50KTtcbiAgICAgIFxuICAgICAgaWYgKHdpbi5zY3JvbGxUbykge1xuICAgICAgICAvLyBTb21lIGJyb3dzZXIgZXh0ZW5zaW9ucyB1bnNldCB0aGlzIG1ldGhvZCB0byBwcmV2ZW50IGFubm95YW5jZXNcbiAgICAgICAgLy8gXCJCZXR0ZXIgUG9wVXAgQmxvY2tlclwiIGZvciBDaHJvbWUgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2JldHRlcnBvcHVwYmxvY2tlci9zb3VyY2UvYnJvd3NlL3RydW5rL2Jsb2NrU3RhcnQuanMjMTAwXG4gICAgICAgIC8vIElzc3VlOiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYmV0dGVycG9wdXBibG9ja2VyL2lzc3Vlcy9kZXRhaWw/aWQ9MVxuICAgICAgICB3aW4uc2Nyb2xsVG8ob3JpZ2luYWxTY3JvbGxMZWZ0LCBvcmlnaW5hbFNjcm9sbFRvcCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBcbiAgXG4gIHd5c2lodG1sNS52aWV3cy5Db21wb3Nlci5wcm90b3R5cGUuc3R5bGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCAgICAgICAgICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgb3JpZ2luYWxBY3RpdmVFbGVtZW50ID0gZG9jLnF1ZXJ5U2VsZWN0b3IoXCI6Zm9jdXNcIiksXG4gICAgICAgIHRleHRhcmVhRWxlbWVudCAgICAgICA9IHRoaXMudGV4dGFyZWEuZWxlbWVudCxcbiAgICAgICAgaGFzUGxhY2Vob2xkZXIgICAgICAgID0gdGV4dGFyZWFFbGVtZW50Lmhhc0F0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpLFxuICAgICAgICBvcmlnaW5hbFBsYWNlaG9sZGVyICAgPSBoYXNQbGFjZWhvbGRlciAmJiB0ZXh0YXJlYUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIik7XG4gICAgdGhpcy5mb2N1c1N0eWxlc0hvc3QgICAgICA9IHRoaXMuZm9jdXNTdHlsZXNIb3N0ICB8fCBIT1NUX1RFTVBMQVRFLmNsb25lTm9kZShmYWxzZSk7XG4gICAgdGhpcy5ibHVyU3R5bGVzSG9zdCAgICAgICA9IHRoaXMuYmx1clN0eWxlc0hvc3QgICB8fCBIT1NUX1RFTVBMQVRFLmNsb25lTm9kZShmYWxzZSk7XG4gIFxuICAgIC8vIFJlbW92ZSBwbGFjZWhvbGRlciBiZWZvcmUgY29weWluZyAoYXMgdGhlIHBsYWNlaG9sZGVyIGhhcyBhbiBhZmZlY3Qgb24gdGhlIGNvbXB1dGVkIHN0eWxlKVxuICAgIGlmIChoYXNQbGFjZWhvbGRlcikge1xuICAgICAgdGV4dGFyZWFFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpO1xuICAgIH1cbiAgXG4gICAgaWYgKHRleHRhcmVhRWxlbWVudCA9PT0gb3JpZ2luYWxBY3RpdmVFbGVtZW50KSB7XG4gICAgICB0ZXh0YXJlYUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgXG4gICAgLy8gLS0tLS0tLS0tIGlmcmFtZSBzdHlsZXMgKGhhcyB0byBiZSBzZXQgYmVmb3JlIGVkaXRvciBzdHlsZXMsIG90aGVyd2lzZSBJRTkgc2V0cyB3cm9uZyBmb250RmFtaWx5IG9uIGJsdXJTdHlsZXNIb3N0KSAtLS0tLS0tLS1cbiAgICBkb20uY29weVN0eWxlcyhCT1hfRk9STUFUVElORykuZnJvbSh0ZXh0YXJlYUVsZW1lbnQpLnRvKHRoaXMuaWZyYW1lKS5hbmRUbyh0aGlzLmJsdXJTdHlsZXNIb3N0KTtcbiAgXG4gICAgLy8gLS0tLS0tLS0tIGVkaXRvciBzdHlsZXMgLS0tLS0tLS0tXG4gICAgZG9tLmNvcHlTdHlsZXMoVEVYVF9GT1JNQVRUSU5HKS5mcm9tKHRleHRhcmVhRWxlbWVudCkudG8odGhpcy5lbGVtZW50KS5hbmRUbyh0aGlzLmJsdXJTdHlsZXNIb3N0KTtcbiAgXG4gICAgLy8gLS0tLS0tLS0tIGFwcGx5IHN0YW5kYXJkIHJ1bGVzIC0tLS0tLS0tLVxuICAgIGRvbS5pbnNlcnRDU1MoQURESVRJT05BTF9DU1NfUlVMRVMpLmludG8odGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQpO1xuICBcbiAgICAvLyAtLS0tLS0tLS0gOmZvY3VzIHN0eWxlcyAtLS0tLS0tLS1cbiAgICBmb2N1c1dpdGhvdXRTY3JvbGxpbmcodGV4dGFyZWFFbGVtZW50KTtcbiAgICBkb20uY29weVN0eWxlcyhCT1hfRk9STUFUVElORykuZnJvbSh0ZXh0YXJlYUVsZW1lbnQpLnRvKHRoaXMuZm9jdXNTdHlsZXNIb3N0KTtcbiAgICBkb20uY29weVN0eWxlcyhURVhUX0ZPUk1BVFRJTkcpLmZyb20odGV4dGFyZWFFbGVtZW50KS50byh0aGlzLmZvY3VzU3R5bGVzSG9zdCk7XG4gIFxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IGNoYW5nZSB0aGUgZGlzcGxheSBzdHlsZSBvZiB0aGUgaWZyYW1lIHdoZW4gY29weWluZyBzdHlsZXMgb2JsdXIvb25mb2N1c1xuICAgIC8vIHRoaXMgaXMgbmVlZGVkIGZvciB3aGVuIHRoZSBjaGFuZ2VfdmlldyBldmVudCBpcyBmaXJlZCB3aGVyZSB0aGUgaWZyYW1lIGlzIGhpZGRlbiBhbmQgdGhlblxuICAgIC8vIHRoZSBibHVyIGV2ZW50IGZpcmVzIGFuZCByZS1kaXNwbGF5cyBpdFxuICAgIHZhciBib3hGb3JtYXR0aW5nU3R5bGVzID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoQk9YX0ZPUk1BVFRJTkcpLndpdGhvdXQoW1wiZGlzcGxheVwiXSk7XG4gIFxuICAgIC8vIC0tLS0tLS0tLSByZXN0b3JlIGZvY3VzIC0tLS0tLS0tLVxuICAgIGlmIChvcmlnaW5hbEFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIG9yaWdpbmFsQWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0YXJlYUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgXG4gICAgLy8gLS0tLS0tLS0tIHJlc3RvcmUgcGxhY2Vob2xkZXIgLS0tLS0tLS0tXG4gICAgaWYgKGhhc1BsYWNlaG9sZGVyKSB7XG4gICAgICB0ZXh0YXJlYUVsZW1lbnQuc2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIiwgb3JpZ2luYWxQbGFjZWhvbGRlcik7XG4gICAgfVxuICBcbiAgICAvLyBXaGVuIGNvcHlpbmcgc3R5bGVzLCB3ZSBvbmx5IGdldCB0aGUgY29tcHV0ZWQgc3R5bGUgd2hpY2ggaXMgbmV2ZXIgcmV0dXJuZWQgaW4gcGVyY2VudCB1bml0XG4gICAgLy8gVGhlcmVmb3JlIHdlJ3ZlIHRvIHJlY2FsY3VsYXRlIHN0eWxlIG9ucmVzaXplXG4gICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5oYXNDdXJyZW50U3R5bGVQcm9wZXJ0eSgpKSB7XG4gICAgICB2YXIgd2luT2JzZXJ2ZXIgPSBkb20ub2JzZXJ2ZSh3aW4sIFwicmVzaXplXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBSZW1vdmUgZXZlbnQgbGlzdGVuZXIgaWYgY29tcG9zZXIgZG9lc24ndCBleGlzdCBhbnltb3JlXG4gICAgICAgIGlmICghZG9tLmNvbnRhaW5zKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhhdC5pZnJhbWUpKSB7XG4gICAgICAgICAgd2luT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JpZ2luYWxUZXh0YXJlYURpc3BsYXlTdHlsZSA9IGRvbS5nZXRTdHlsZShcImRpc3BsYXlcIikuZnJvbSh0ZXh0YXJlYUVsZW1lbnQpLFxuICAgICAgICAgICAgb3JpZ2luYWxDb21wb3NlckRpc3BsYXlTdHlsZSA9IGRvbS5nZXRTdHlsZShcImRpc3BsYXlcIikuZnJvbSh0aGF0LmlmcmFtZSk7XG4gICAgICAgIHRleHRhcmVhRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgdGhhdC5pZnJhbWUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBkb20uY29weVN0eWxlcyhSRVNJWkVfU1RZTEUpXG4gICAgICAgICAgLmZyb20odGV4dGFyZWFFbGVtZW50KVxuICAgICAgICAgIC50byh0aGF0LmlmcmFtZSlcbiAgICAgICAgICAuYW5kVG8odGhhdC5mb2N1c1N0eWxlc0hvc3QpXG4gICAgICAgICAgLmFuZFRvKHRoYXQuYmx1clN0eWxlc0hvc3QpO1xuICAgICAgICB0aGF0LmlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxDb21wb3NlckRpc3BsYXlTdHlsZTtcbiAgICAgICAgdGV4dGFyZWFFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbFRleHRhcmVhRGlzcGxheVN0eWxlO1xuICAgICAgfSk7XG4gICAgfVxuICBcbiAgICAvLyAtLS0tLS0tLS0gU3luYyBmb2N1cy9ibHVyIHN0eWxlcyAtLS0tLS0tLS1cbiAgICB0aGlzLnBhcmVudC5vYnNlcnZlKFwiZm9jdXM6Y29tcG9zZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBkb20uY29weVN0eWxlcyhib3hGb3JtYXR0aW5nU3R5bGVzKSAuZnJvbSh0aGF0LmZvY3VzU3R5bGVzSG9zdCkudG8odGhhdC5pZnJhbWUpO1xuICAgICAgZG9tLmNvcHlTdHlsZXMoVEVYVF9GT1JNQVRUSU5HKSAgICAgLmZyb20odGhhdC5mb2N1c1N0eWxlc0hvc3QpLnRvKHRoYXQuZWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnBhcmVudC5vYnNlcnZlKFwiYmx1cjpjb21wb3NlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGRvbS5jb3B5U3R5bGVzKGJveEZvcm1hdHRpbmdTdHlsZXMpIC5mcm9tKHRoYXQuYmx1clN0eWxlc0hvc3QpLnRvKHRoYXQuaWZyYW1lKTtcbiAgICAgIGRvbS5jb3B5U3R5bGVzKFRFWFRfRk9STUFUVElORykgICAgIC5mcm9tKHRoYXQuYmx1clN0eWxlc0hvc3QpLnRvKHRoYXQuZWxlbWVudCk7XG4gICAgfSk7XG4gIFxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSkod3lzaWh0bWw1KTsvKipcbiAqIFRha2luZyBjYXJlIG9mIGV2ZW50c1xuICogIC0gU2ltdWxhdGluZyAnY2hhbmdlJyBldmVudCBvbiBjb250ZW50RWRpdGFibGUgZWxlbWVudFxuICogIC0gSGFuZGxpbmcgZHJhZyAmIGRyb3AgbG9naWNcbiAqICAtIENhdGNoIHBhc3RlIGV2ZW50c1xuICogIC0gRGlzcGF0Y2ggcHJvcHJpZXRhcnkgbmV3d29yZDpjb21wb3NlciBldmVudFxuICogIC0gS2V5Ym9hcmQgc2hvcnRjdXRzXG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIGRvbSAgICAgICA9IHd5c2lodG1sNS5kb20sXG4gICAgICBicm93c2VyICAgPSB3eXNpaHRtbDUuYnJvd3NlcixcbiAgICAgIC8qKlxuICAgICAgICogTWFwIGtleUNvZGVzIHRvIHF1ZXJ5IGNvbW1hbmRzXG4gICAgICAgKi9cbiAgICAgIHNob3J0Y3V0cyA9IHtcbiAgICAgICAgXCI2NlwiOiBcImJvbGRcIiwgICAgIC8vIEJcbiAgICAgICAgXCI3M1wiOiBcIml0YWxpY1wiLCAgIC8vIElcbiAgICAgICAgXCI4NVwiOiBcInVuZGVybGluZVwiIC8vIFVcbiAgICAgIH07XG4gIFxuICB3eXNpaHRtbDUudmlld3MuQ29tcG9zZXIucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCAgICAgICAgICAgICAgICA9IHRoaXMsXG4gICAgICAgIHN0YXRlICAgICAgICAgICAgICAgPSB0aGlzLmdldFZhbHVlKCksXG4gICAgICAgIGlmcmFtZSAgICAgICAgICAgICAgPSB0aGlzLnNhbmRib3guZ2V0SWZyYW1lKCksXG4gICAgICAgIGVsZW1lbnQgICAgICAgICAgICAgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgIGZvY3VzQmx1ckVsZW1lbnQgICAgPSBicm93c2VyLnN1cHBvcnRzRXZlbnRzSW5JZnJhbWVDb3JyZWN0bHkoKSA/IGVsZW1lbnQgOiB0aGlzLnNhbmRib3guZ2V0V2luZG93KCksXG4gICAgICAgIC8vIEZpcmVmb3ggPCAzLjUgZG9lc24ndCBzdXBwb3J0IHRoZSBkcm9wIGV2ZW50LCBpbnN0ZWFkIGl0IHN1cHBvcnRzIGEgc28gY2FsbGVkIFwiZHJhZ2Ryb3BcIiBldmVudCB3aGljaCBiZWhhdmVzIGFsbW9zdCB0aGUgc2FtZVxuICAgICAgICBwYXN0ZUV2ZW50cyAgICAgICAgID0gYnJvd3Nlci5zdXBwb3J0c0V2ZW50KFwiZHJvcFwiKSA/IFtcImRyb3BcIiwgXCJwYXN0ZVwiXSA6IFtcImRyYWdkcm9wXCIsIFwicGFzdGVcIl07XG5cbiAgICAvLyAtLS0tLS0tLS0gZGVzdHJveTpjb21wb3NlciBldmVudCAtLS0tLS0tLS1cbiAgICBkb20ub2JzZXJ2ZShpZnJhbWUsIFwiRE9NTm9kZVJlbW92ZWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhckludGVydmFsKGRvbU5vZGVSZW1vdmVkSW50ZXJ2YWwpO1xuICAgICAgdGhhdC5wYXJlbnQuZmlyZShcImRlc3Ryb3k6Y29tcG9zZXJcIik7XG4gICAgfSk7XG5cbiAgICAvLyBET01Ob2RlUmVtb3ZlZCBldmVudCBpcyBub3Qgc3VwcG9ydGVkIGluIElFIDhcbiAgICB2YXIgZG9tTm9kZVJlbW92ZWRJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFkb20uY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBpZnJhbWUpKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoZG9tTm9kZVJlbW92ZWRJbnRlcnZhbCk7XG4gICAgICAgIHRoYXQucGFyZW50LmZpcmUoXCJkZXN0cm95OmNvbXBvc2VyXCIpO1xuICAgICAgfVxuICAgIH0sIDI1MCk7XG5cblxuICAgIC8vIC0tLS0tLS0tLSBGb2N1cyAmIGJsdXIgbG9naWMgLS0tLS0tLS0tXG4gICAgZG9tLm9ic2VydmUoZm9jdXNCbHVyRWxlbWVudCwgXCJmb2N1c1wiLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoYXQucGFyZW50LmZpcmUoXCJmb2N1c1wiKS5maXJlKFwiZm9jdXM6Y29tcG9zZXJcIik7XG5cbiAgICAgIC8vIERlbGF5IHN0b3Jpbmcgb2Ygc3RhdGUgdW50aWwgYWxsIGZvY3VzIGhhbmRsZXIgYXJlIGZpcmVkXG4gICAgICAvLyBlc3BlY2lhbGx5IHRoZSBvbmUgd2hpY2ggcmVzZXRzIHRoZSBwbGFjZWhvbGRlclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgc3RhdGUgPSB0aGF0LmdldFZhbHVlKCk7IH0sIDApO1xuICAgIH0pO1xuXG4gICAgZG9tLm9ic2VydmUoZm9jdXNCbHVyRWxlbWVudCwgXCJibHVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHN0YXRlICE9PSB0aGF0LmdldFZhbHVlKCkpIHtcbiAgICAgICAgdGhhdC5wYXJlbnQuZmlyZShcImNoYW5nZVwiKS5maXJlKFwiY2hhbmdlOmNvbXBvc2VyXCIpO1xuICAgICAgfVxuICAgICAgdGhhdC5wYXJlbnQuZmlyZShcImJsdXJcIikuZmlyZShcImJsdXI6Y29tcG9zZXJcIik7XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKHd5c2lodG1sNS5icm93c2VyLmlzSW9zKCkpIHtcbiAgICAgIC8vIFdoZW4gb24gaVBhZC9pUGhvbmUvSVBvZCBhZnRlciBjbGlja2luZyBvdXRzaWRlIG9mIGVkaXRvciwgdGhlIGVkaXRvciBsb3NlcyBmb2N1c1xuICAgICAgLy8gYnV0IHRoZSBVSSBzdGlsbCBhY3RzIGFzIGlmIHRoZSBlZGl0b3IgaGFzIGZvY3VzIChibGlua2luZyBjYXJldCBhbmQgb25zY3JlZW4ga2V5Ym9hcmQgdmlzaWJsZSlcbiAgICAgIC8vIFdlIHByZXZlbnQgdGhhdCBieSBmb2N1c2luZyBhIHRlbXBvcmFyeSBpbnB1dCBlbGVtZW50IHdoaWNoIGltbWVkaWF0ZWx5IGxvc2VzIGZvY3VzXG4gICAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBcImJsdXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksXG4gICAgICAgICAgICBvcmlnaW5hbFNjcm9sbFRvcCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgICAgICBvcmlnaW5hbFNjcm9sbExlZnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhhdC5zZWxlY3Rpb24uaW5zZXJ0Tm9kZShpbnB1dCk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgIGlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW5wdXQpO1xuICAgICAgICBcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKG9yaWdpbmFsU2Nyb2xsTGVmdCwgb3JpZ2luYWxTY3JvbGxUb3ApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tIERyYWcgJiBEcm9wIGxvZ2ljIC0tLS0tLS0tLVxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwiZHJhZ2VudGVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhhdC5wYXJlbnQuZmlyZShcInVuc2V0X3BsYWNlaG9sZGVyXCIpO1xuICAgIH0pO1xuXG4gICAgaWYgKGJyb3dzZXIuZmlyZXNPbkRyb3BPbmx5V2hlbk9uRHJhZ092ZXJJc0NhbmNlbGxlZCgpKSB7XG4gICAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBbXCJkcmFnb3ZlclwiLCBcImRyYWdlbnRlclwiXSwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIHBhc3RlRXZlbnRzLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IGV2ZW50LmRhdGFUcmFuc2ZlcixcbiAgICAgICAgICBkYXRhO1xuXG4gICAgICBpZiAoZGF0YVRyYW5zZmVyICYmIGJyb3dzZXIuc3VwcG9ydHNEYXRhVHJhbnNmZXIoKSkge1xuICAgICAgICBkYXRhID0gZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0L2h0bWxcIikgfHwgZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgICB0aGF0LmNvbW1hbmRzLmV4ZWMoXCJpbnNlcnRIVE1MXCIsIGRhdGEpO1xuICAgICAgICB0aGF0LnBhcmVudC5maXJlKFwicGFzdGVcIikuZmlyZShcInBhc3RlOmNvbXBvc2VyXCIpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhhdC5wYXJlbnQuZmlyZShcInBhc3RlXCIpLmZpcmUoXCJwYXN0ZTpjb21wb3NlclwiKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyAtLS0tLS0tLS0gbmV3b3JkIGV2ZW50IC0tLS0tLS0tLVxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwia2V5dXBcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgIGlmIChrZXlDb2RlID09PSB3eXNpaHRtbDUuU1BBQ0VfS0VZIHx8IGtleUNvZGUgPT09IHd5c2lodG1sNS5FTlRFUl9LRVkpIHtcbiAgICAgICAgdGhhdC5wYXJlbnQuZmlyZShcIm5ld3dvcmQ6Y29tcG9zZXJcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnBhcmVudC5vYnNlcnZlKFwicGFzdGU6Y29tcG9zZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0aGF0LnBhcmVudC5maXJlKFwibmV3d29yZDpjb21wb3NlclwiKTsgfSwgMCk7XG4gICAgfSk7XG5cbiAgICAvLyAtLS0tLS0tLS0gTWFrZSBzdXJlIHRoYXQgaW1hZ2VzIGFyZSBzZWxlY3RlZCB3aGVuIGNsaWNraW5nIG9uIHRoZW0gLS0tLS0tLS0tXG4gICAgaWYgKCFicm93c2VyLmNhblNlbGVjdEltYWdlc0luQ29udGVudEVkaXRhYmxlKCkpIHtcbiAgICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09IFwiSU1HXCIpIHtcbiAgICAgICAgICB0aGF0LnNlbGVjdGlvbi5zZWxlY3ROb2RlKHRhcmdldCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIC0tLS0tLS0tLSBTaG9ydGN1dCBsb2dpYyAtLS0tLS0tLS1cbiAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBrZXlDb2RlICA9IGV2ZW50LmtleUNvZGUsXG4gICAgICAgICAgY29tbWFuZCAgPSBzaG9ydGN1dHNba2V5Q29kZV07XG4gICAgICBpZiAoKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkgJiYgIWV2ZW50LmFsdEtleSAmJiBjb21tYW5kKSB7XG4gICAgICAgIHRoYXQuY29tbWFuZHMuZXhlYyhjb21tYW5kKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIC0tLS0tLS0tLSBNYWtlIHN1cmUgdGhhdCB3aGVuIHByZXNzaW5nIGJhY2tzcGFjZS9kZWxldGUgb24gc2VsZWN0ZWQgaW1hZ2VzIGRlbGV0ZXMgdGhlIGltYWdlIGFuZCBpdCdzIGFuY2hvciAtLS0tLS0tLS1cbiAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciB0YXJnZXQgID0gdGhhdC5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKHRydWUpLFxuICAgICAgICAgIGtleUNvZGUgPSBldmVudC5rZXlDb2RlLFxuICAgICAgICAgIHBhcmVudDtcbiAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0Lm5vZGVOYW1lID09PSBcIklNR1wiICYmIChrZXlDb2RlID09PSB3eXNpaHRtbDUuQkFDS1NQQUNFX0tFWSB8fCBrZXlDb2RlID09PSB3eXNpaHRtbDUuREVMRVRFX0tFWSkpIHsgLy8gOCA9PiBiYWNrc3BhY2UsIDQ2ID0+IGRlbGV0ZVxuICAgICAgICBwYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgLy8gZGVsZXRlIHRoZSA8aW1nPlxuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgICAgLy8gYW5kIGl0J3MgcGFyZW50IDxhPiB0b28gaWYgaXQgaGFzbid0IGdvdCBhbnkgb3RoZXIgY2hpbGQgbm9kZXNcbiAgICAgICAgaWYgKHBhcmVudC5ub2RlTmFtZSA9PT0gXCJBXCIgJiYgIXBhcmVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgcGFyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocGFyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHd5c2lodG1sNS5xdWlya3MucmVkcmF3KGVsZW1lbnQpOyB9LCAwKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIC0tLS0tLS0tLSBTaG93IHVybCBpbiB0b29sdGlwIHdoZW4gaG92ZXJpbmcgbGlua3Mgb3IgaW1hZ2VzIC0tLS0tLS0tLVxuICAgIHZhciB0aXRsZVByZWZpeGVzID0ge1xuICAgICAgSU1HOiBcIkltYWdlOiBcIixcbiAgICAgIEE6ICAgXCJMaW5rOiBcIlxuICAgIH07XG4gICAgXG4gICAgZG9tLm9ic2VydmUoZWxlbWVudCwgXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciB0YXJnZXQgICA9IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICBub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZSxcbiAgICAgICAgICB0aXRsZTtcbiAgICAgIGlmIChub2RlTmFtZSAhPT0gXCJBXCIgJiYgbm9kZU5hbWUgIT09IFwiSU1HXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhhc1RpdGxlID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZShcInRpdGxlXCIpO1xuICAgICAgaWYoIWhhc1RpdGxlKXtcbiAgICAgICAgdGl0bGUgPSB0aXRsZVByZWZpeGVzW25vZGVOYW1lXSArICh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKFwic3JjXCIpKTtcbiAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIHRpdGxlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0pKHd5c2lodG1sNSk7LyoqXG4gKiBDbGFzcyB0aGF0IHRha2VzIGNhcmUgdGhhdCB0aGUgdmFsdWUgb2YgdGhlIGNvbXBvc2VyIGFuZCB0aGUgdGV4dGFyZWEgaXMgYWx3YXlzIGluIHN5bmNcbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgSU5URVJWQUwgPSA0MDA7XG4gIFxuICB3eXNpaHRtbDUudmlld3MuU3luY2hyb25pemVyID0gQmFzZS5leHRlbmQoXG4gICAgLyoqIEBzY29wZSB3eXNpaHRtbDUudmlld3MuU3luY2hyb25pemVyLnByb3RvdHlwZSAqLyB7XG5cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oZWRpdG9yLCB0ZXh0YXJlYSwgY29tcG9zZXIpIHtcbiAgICAgIHRoaXMuZWRpdG9yICAgPSBlZGl0b3I7XG4gICAgICB0aGlzLnRleHRhcmVhID0gdGV4dGFyZWE7XG4gICAgICB0aGlzLmNvbXBvc2VyID0gY29tcG9zZXI7XG5cbiAgICAgIHRoaXMuX29ic2VydmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3luYyBodG1sIGZyb20gY29tcG9zZXIgdG8gdGV4dGFyZWFcbiAgICAgKiBUYWtlcyBjYXJlIG9mIHBsYWNlaG9sZGVyc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdWxkUGFyc2VIdG1sIFdoZXRoZXIgdGhlIGh0bWwgc2hvdWxkIGJlIHNhbml0aXplZCBiZWZvcmUgaW5zZXJ0aW5nIGl0IGludG8gdGhlIHRleHRhcmVhXG4gICAgICovXG4gICAgZnJvbUNvbXBvc2VyVG9UZXh0YXJlYTogZnVuY3Rpb24oc2hvdWxkUGFyc2VIdG1sKSB7XG4gICAgICB0aGlzLnRleHRhcmVhLnNldFZhbHVlKHd5c2lodG1sNS5sYW5nLnN0cmluZyh0aGlzLmNvbXBvc2VyLmdldFZhbHVlKCkpLnRyaW0oKSwgc2hvdWxkUGFyc2VIdG1sKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3luYyB2YWx1ZSBvZiB0ZXh0YXJlYSB0byBjb21wb3NlclxuICAgICAqIFRha2VzIGNhcmUgb2YgcGxhY2Vob2xkZXJzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaG91bGRQYXJzZUh0bWwgV2hldGhlciB0aGUgaHRtbCBzaG91bGQgYmUgc2FuaXRpemVkIGJlZm9yZSBpbnNlcnRpbmcgaXQgaW50byB0aGUgY29tcG9zZXJcbiAgICAgKi9cbiAgICBmcm9tVGV4dGFyZWFUb0NvbXBvc2VyOiBmdW5jdGlvbihzaG91bGRQYXJzZUh0bWwpIHtcbiAgICAgIHZhciB0ZXh0YXJlYVZhbHVlID0gdGhpcy50ZXh0YXJlYS5nZXRWYWx1ZSgpO1xuICAgICAgaWYgKHRleHRhcmVhVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb21wb3Nlci5zZXRWYWx1ZSh0ZXh0YXJlYVZhbHVlLCBzaG91bGRQYXJzZUh0bWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wb3Nlci5jbGVhcigpO1xuICAgICAgICB0aGlzLmVkaXRvci5maXJlKFwic2V0X3BsYWNlaG9sZGVyXCIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2Ugc3luY2luZyBiYXNlZCBvbiB2aWV3IHN0YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaG91bGRQYXJzZUh0bWwgV2hldGhlciB0aGUgaHRtbCBzaG91bGQgYmUgc2FuaXRpemVkIGJlZm9yZSBpbnNlcnRpbmcgaXQgaW50byB0aGUgY29tcG9zZXIvdGV4dGFyZWFcbiAgICAgKi9cbiAgICBzeW5jOiBmdW5jdGlvbihzaG91bGRQYXJzZUh0bWwpIHtcbiAgICAgIGlmICh0aGlzLmVkaXRvci5jdXJyZW50Vmlldy5uYW1lID09PSBcInRleHRhcmVhXCIpIHtcbiAgICAgICAgdGhpcy5mcm9tVGV4dGFyZWFUb0NvbXBvc2VyKHNob3VsZFBhcnNlSHRtbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZyb21Db21wb3NlclRvVGV4dGFyZWEoc2hvdWxkUGFyc2VIdG1sKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgaW50ZXJ2YWwtYmFzZWQgc3luY2luZ1xuICAgICAqIGFsc28gbWFrZXMgc3VyZSB0aGF0IG9uLXN1Ym1pdCB0aGUgY29tcG9zZXIncyBjb250ZW50IGlzIHN5bmNlZCB3aXRoIHRoZSB0ZXh0YXJlYVxuICAgICAqIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGZvcm0gZ2V0cyBzdWJtaXR0ZWRcbiAgICAgKi9cbiAgICBfb2JzZXJ2ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW50ZXJ2YWwsXG4gICAgICAgICAgdGhhdCAgICAgICAgICA9IHRoaXMsXG4gICAgICAgICAgZm9ybSAgICAgICAgICA9IHRoaXMudGV4dGFyZWEuZWxlbWVudC5mb3JtLFxuICAgICAgICAgIHN0YXJ0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7IHRoYXQuZnJvbUNvbXBvc2VyVG9UZXh0YXJlYSgpOyB9LCBJTlRFUlZBTCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdG9wSW50ZXJ2YWwgID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgIGludGVydmFsID0gbnVsbDtcbiAgICAgICAgICB9O1xuXG4gICAgICBzdGFydEludGVydmFsKCk7XG5cbiAgICAgIGlmIChmb3JtKSB7XG4gICAgICAgIC8vIElmIHRoZSB0ZXh0YXJlYSBpcyBpbiBhIGZvcm0gbWFrZSBzdXJlIHRoYXQgYWZ0ZXIgb25yZXNldCBhbmQgb25zdWJtaXQgdGhlIGNvbXBvc2VyXG4gICAgICAgIC8vIGhhcyB0aGUgY29ycmVjdCBzdGF0ZVxuICAgICAgICB3eXNpaHRtbDUuZG9tLm9ic2VydmUoZm9ybSwgXCJzdWJtaXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhhdC5zeW5jKHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgd3lzaWh0bWw1LmRvbS5vYnNlcnZlKGZvcm0sIFwicmVzZXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhhdC5mcm9tVGV4dGFyZWFUb0NvbXBvc2VyKCk7IH0sIDApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lZGl0b3Iub2JzZXJ2ZShcImNoYW5nZV92aWV3XCIsIGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgaWYgKHZpZXcgPT09IFwiY29tcG9zZXJcIiAmJiAhaW50ZXJ2YWwpIHtcbiAgICAgICAgICB0aGF0LmZyb21UZXh0YXJlYVRvQ29tcG9zZXIodHJ1ZSk7XG4gICAgICAgICAgc3RhcnRJbnRlcnZhbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHZpZXcgPT09IFwidGV4dGFyZWFcIikge1xuICAgICAgICAgIHRoYXQuZnJvbUNvbXBvc2VyVG9UZXh0YXJlYSh0cnVlKTtcbiAgICAgICAgICBzdG9wSW50ZXJ2YWwoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZWRpdG9yLm9ic2VydmUoXCJkZXN0cm95OmNvbXBvc2VyXCIsIHN0b3BJbnRlcnZhbCk7XG4gICAgfVxuICB9KTtcbn0pKHd5c2lodG1sNSk7XG53eXNpaHRtbDUudmlld3MuVGV4dGFyZWEgPSB3eXNpaHRtbDUudmlld3MuVmlldy5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LnZpZXdzLlRleHRhcmVhLnByb3RvdHlwZSAqLyB7XG4gIG5hbWU6IFwidGV4dGFyZWFcIixcbiAgXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihwYXJlbnQsIHRleHRhcmVhRWxlbWVudCwgY29uZmlnKSB7XG4gICAgdGhpcy5iYXNlKHBhcmVudCwgdGV4dGFyZWFFbGVtZW50LCBjb25maWcpO1xuICAgIFxuICAgIHRoaXMuX29ic2VydmUoKTtcbiAgfSxcbiAgXG4gIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSBcIlwiO1xuICB9LFxuICBcbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHBhcnNlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5pc0VtcHR5KCkgPyBcIlwiIDogdGhpcy5lbGVtZW50LnZhbHVlO1xuICAgIGlmIChwYXJzZSkge1xuICAgICAgdmFsdWUgPSB0aGlzLnBhcmVudC5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgXG4gIHNldFZhbHVlOiBmdW5jdGlvbihodG1sLCBwYXJzZSkge1xuICAgIGlmIChwYXJzZSkge1xuICAgICAgaHRtbCA9IHRoaXMucGFyZW50LnBhcnNlKGh0bWwpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSBodG1sO1xuICB9LFxuICBcbiAgaGFzUGxhY2Vob2xkZXJTZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdXBwb3J0c1BsYWNlaG9sZGVyID0gd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNQbGFjZWhvbGRlckF0dHJpYnV0ZU9uKHRoaXMuZWxlbWVudCksXG4gICAgICAgIHBsYWNlaG9sZGVyVGV4dCAgICAgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIikgfHwgbnVsbCxcbiAgICAgICAgdmFsdWUgICAgICAgICAgICAgICA9IHRoaXMuZWxlbWVudC52YWx1ZSxcbiAgICAgICAgaXNFbXB0eSAgICAgICAgICAgICA9ICF2YWx1ZTtcbiAgICByZXR1cm4gKHN1cHBvcnRzUGxhY2Vob2xkZXIgJiYgaXNFbXB0eSkgfHwgKHZhbHVlID09PSBwbGFjZWhvbGRlclRleHQpO1xuICB9LFxuICBcbiAgaXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF3eXNpaHRtbDUubGFuZy5zdHJpbmcodGhpcy5lbGVtZW50LnZhbHVlKS50cmltKCkgfHwgdGhpcy5oYXNQbGFjZWhvbGRlclNldCgpO1xuICB9LFxuICBcbiAgX29ic2VydmU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICBwYXJlbnQgID0gdGhpcy5wYXJlbnQsXG4gICAgICAgIGV2ZW50TWFwcGluZyA9IHtcbiAgICAgICAgICBmb2N1c2luOiAgXCJmb2N1c1wiLFxuICAgICAgICAgIGZvY3Vzb3V0OiBcImJsdXJcIlxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGluZyBmb2N1cygpIG9yIGJsdXIoKSBvbiBhbiBlbGVtZW50IGRvZXNuJ3Qgc3luY2hyb25vdXNseSB0cmlnZ2VyIHRoZSBhdHRhY2hlZCBmb2N1cy9ibHVyIGV2ZW50c1xuICAgICAgICAgKiBUaGlzIGlzIHRoZSBjYXNlIGZvciBmb2N1c2luIGFuZCBmb2N1c291dCwgc28gbGV0J3MgdXNlIHRoZW0gd2hlbmV2ZXIgcG9zc2libGUsIGtrdGh4YmFpXG4gICAgICAgICAqL1xuICAgICAgICBldmVudHMgPSB3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c0V2ZW50KFwiZm9jdXNpblwiKSA/IFtcImZvY3VzaW5cIiwgXCJmb2N1c291dFwiLCBcImNoYW5nZVwiXSA6IFtcImZvY3VzXCIsIFwiYmx1clwiLCBcImNoYW5nZVwiXTtcbiAgICBcbiAgICBwYXJlbnQub2JzZXJ2ZShcImJlZm9yZWxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICB3eXNpaHRtbDUuZG9tLm9ic2VydmUoZWxlbWVudCwgZXZlbnRzLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnRNYXBwaW5nW2V2ZW50LnR5cGVdIHx8IGV2ZW50LnR5cGU7XG4gICAgICAgIHBhcmVudC5maXJlKGV2ZW50TmFtZSkuZmlyZShldmVudE5hbWUgKyBcIjp0ZXh0YXJlYVwiKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB3eXNpaHRtbDUuZG9tLm9ic2VydmUoZWxlbWVudCwgW1wicGFzdGVcIiwgXCJkcm9wXCJdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgcGFyZW50LmZpcmUoXCJwYXN0ZVwiKS5maXJlKFwicGFzdGU6dGV4dGFyZWFcIik7IH0sIDApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pOy8qKlxuICogVG9vbGJhciBEaWFsb2dcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGxpbmsgVGhlIHRvb2xiYXIgbGluayB3aGljaCBjYXVzZXMgdGhlIGRpYWxvZyB0byBzaG93IHVwXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciBUaGUgZGlhbG9nIGNvbnRhaW5lclxuICpcbiAqIEBleGFtcGxlXG4gKiAgICA8IS0tIFRvb2xiYXIgbGluayAtLT5cbiAqICAgIDxhIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XCJpbnNlcnRJbWFnZVwiPmluc2VydCBhbiBpbWFnZTwvYT5cbiAqXG4gKiAgICA8IS0tIERpYWxvZyAtLT5cbiAqICAgIDxkaXYgZGF0YS13eXNpaHRtbDUtZGlhbG9nPVwiaW5zZXJ0SW1hZ2VcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+XG4gKiAgICAgIDxsYWJlbD5cbiAqICAgICAgICBVUkw6IDxpbnB1dCBkYXRhLXd5c2lodG1sNS1kaWFsb2ctZmllbGQ9XCJzcmNcIiB2YWx1ZT1cImh0dHA6Ly9cIj5cbiAqICAgICAgPC9sYWJlbD5cbiAqICAgICAgPGxhYmVsPlxuICogICAgICAgIEFsdGVybmF0aXZlIHRleHQ6IDxpbnB1dCBkYXRhLXd5c2lodG1sNS1kaWFsb2ctZmllbGQ9XCJhbHRcIiB2YWx1ZT1cIlwiPlxuICogICAgICA8L2xhYmVsPlxuICogICAgPC9kaXY+XG4gKlxuICogICAgPHNjcmlwdD5cbiAqICAgICAgdmFyIGRpYWxvZyA9IG5ldyB3eXNpaHRtbDUudG9vbGJhci5EaWFsb2coXG4gKiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdpbnNlcnRJbWFnZSddXCIpLFxuICogICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS13eXNpaHRtbDUtZGlhbG9nPSdpbnNlcnRJbWFnZSddXCIpXG4gKiAgICAgICk7XG4gKiAgICAgIGRpYWxvZy5vYnNlcnZlKFwic2F2ZVwiLCBmdW5jdGlvbihhdHRyaWJ1dGVzKSB7XG4gKiAgICAgICAgLy8gZG8gc29tZXRoaW5nXG4gKiAgICAgIH0pO1xuICogICAgPC9zY3JpcHQ+XG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIGRvbSAgICAgICAgICAgICAgICAgICAgID0gd3lzaWh0bWw1LmRvbSxcbiAgICAgIENMQVNTX05BTUVfT1BFTkVEICAgICAgID0gXCJ3eXNpaHRtbDUtY29tbWFuZC1kaWFsb2ctb3BlbmVkXCIsXG4gICAgICBTRUxFQ1RPUl9GT1JNX0VMRU1FTlRTICA9IFwiaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWFcIixcbiAgICAgIFNFTEVDVE9SX0ZJRUxEUyAgICAgICAgID0gXCJbZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkXVwiLFxuICAgICAgQVRUUklCVVRFX0ZJRUxEUyAgICAgICAgPSBcImRhdGEtd3lzaWh0bWw1LWRpYWxvZy1maWVsZFwiO1xuICAgICAgXG4gIFxuICB3eXNpaHRtbDUudG9vbGJhci5EaWFsb2cgPSB3eXNpaHRtbDUubGFuZy5EaXNwYXRjaGVyLmV4dGVuZChcbiAgICAvKiogQHNjb3BlIHd5c2lodG1sNS50b29sYmFyLkRpYWxvZy5wcm90b3R5cGUgKi8ge1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihsaW5rLCBjb250YWluZXIpIHtcbiAgICAgIHRoaXMubGluayAgICAgICA9IGxpbms7XG4gICAgICB0aGlzLmNvbnRhaW5lciAgPSBjb250YWluZXI7XG4gICAgfSxcblxuICAgIF9vYnNlcnZlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9vYnNlcnZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBjYWxsYmFja1dyYXBwZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGF0Ll9zZXJpYWxpemUoKTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzID09IHRoYXQuZWxlbWVudFRvQ2hhbmdlKSB7XG4gICAgICAgICAgICAgIHRoYXQuZmlyZShcImVkaXRcIiwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGF0LmZpcmUoXCJzYXZlXCIsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhhdC5oaWRlKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfTtcblxuICAgICAgZG9tLm9ic2VydmUodGhhdC5saW5rLCBcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChkb20uaGFzQ2xhc3ModGhhdC5saW5rLCBDTEFTU19OQU1FX09QRU5FRCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0aGF0LmhpZGUoKTsgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBkb20ub2JzZXJ2ZSh0aGlzLmNvbnRhaW5lciwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IHd5c2lodG1sNS5FTlRFUl9LRVkpIHtcbiAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlDb2RlID09PSB3eXNpaHRtbDUuRVNDQVBFX0tFWSkge1xuICAgICAgICAgIHRoYXQuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZG9tLmRlbGVnYXRlKHRoaXMuY29udGFpbmVyLCBcIltkYXRhLXd5c2lodG1sNS1kaWFsb2ctYWN0aW9uPXNhdmVdXCIsIFwiY2xpY2tcIiwgY2FsbGJhY2tXcmFwcGVyKTtcblxuICAgICAgZG9tLmRlbGVnYXRlKHRoaXMuY29udGFpbmVyLCBcIltkYXRhLXd5c2lodG1sNS1kaWFsb2ctYWN0aW9uPWNhbmNlbF1cIiwgXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGF0LmZpcmUoXCJjYW5jZWxcIik7XG4gICAgICAgIHRoYXQuaGlkZSgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZm9ybUVsZW1lbnRzICA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfRk9STV9FTEVNRU5UUyksXG4gICAgICAgICAgaSAgICAgICAgICAgICA9IDAsXG4gICAgICAgICAgbGVuZ3RoICAgICAgICA9IGZvcm1FbGVtZW50cy5sZW5ndGgsXG4gICAgICAgICAgX2NsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbigpIHsgY2xlYXJJbnRlcnZhbCh0aGF0LmludGVydmFsKTsgfTtcbiAgICAgIGZvciAoOyBpPGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRvbS5vYnNlcnZlKGZvcm1FbGVtZW50c1tpXSwgXCJjaGFuZ2VcIiwgX2NsZWFySW50ZXJ2YWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vYnNlcnZlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyYWJzIGFsbCBmaWVsZHMgaW4gdGhlIGRpYWxvZyBhbmQgcHV0cyB0aGVtIGluIGtleT0+dmFsdWUgc3R5bGUgaW4gYW4gb2JqZWN0IHdoaWNoXG4gICAgICogdGhlbiBnZXRzIHJldHVybmVkXG4gICAgICovXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGF0YSAgICA9IHRoaXMuZWxlbWVudFRvQ2hhbmdlIHx8IHt9LFxuICAgICAgICAgIGZpZWxkcyAgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0ZJRUxEUyksXG4gICAgICAgICAgbGVuZ3RoICA9IGZpZWxkcy5sZW5ndGgsXG4gICAgICAgICAgaSAgICAgICA9IDA7XG4gICAgICBmb3IgKDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhW2ZpZWxkc1tpXS5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0ZJRUxEUyldID0gZmllbGRzW2ldLnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRha2VzIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBcImVsZW1lbnRUb0NoYW5nZVwiXG4gICAgICogYW5kIGluc2VydHMgdGhlbSBpbiB0aGVpciBjb3JyZXNwb25kaW5nIGRpYWxvZyBpbnB1dCBmaWVsZHNcbiAgICAgKiBcbiAgICAgKiBBc3N1bWUgdGhlIFwiZWxlbWVudFRvQ2hhbmdlXCIgbG9va3MgbGlrZSB0aGlzOlxuICAgICAqICAgIDxhIGhyZWY9XCJodHRwOi8vd3d3Lmdvb2dsZS5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIj5mb288L2E+XG4gICAgICpcbiAgICAgKiBhbmQgd2UgaGF2ZSB0aGUgZm9sbG93aW5nIGRpYWxvZzpcbiAgICAgKiAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBkYXRhLXd5c2lodG1sNS1kaWFsb2ctZmllbGQ9XCJocmVmXCIgdmFsdWU9XCJcIj5cbiAgICAgKiAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBkYXRhLXd5c2lodG1sNS1kaWFsb2ctZmllbGQ9XCJ0YXJnZXRcIiB2YWx1ZT1cIlwiPlxuICAgICAqIFxuICAgICAqIGFmdGVyIGNhbGxpbmcgX2ludGVycG9sYXRlKCkgdGhlIGRpYWxvZyB3aWxsIGxvb2sgbGlrZSB0aGlzXG4gICAgICogICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVwiaHJlZlwiIHZhbHVlPVwiaHR0cDovL3d3dy5nb29nbGUuY29tXCI+XG4gICAgICogICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVwidGFyZ2V0XCIgdmFsdWU9XCJfYmxhbmtcIj5cbiAgICAgKlxuICAgICAqIEJhc2ljYWxseSBpdCBhZG9wdGVkIHRoZSBhdHRyaWJ1dGUgdmFsdWVzIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgaW5wdXQgZmllbGRzXG4gICAgICpcbiAgICAgKi9cbiAgICBfaW50ZXJwb2xhdGU6IGZ1bmN0aW9uKGF2b2lkSGlkZGVuRmllbGRzKSB7XG4gICAgICB2YXIgZmllbGQsXG4gICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIGZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIjpmb2N1c1wiKSxcbiAgICAgICAgICBmaWVsZHMgICAgICAgICA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfRklFTERTKSxcbiAgICAgICAgICBsZW5ndGggICAgICAgICA9IGZpZWxkcy5sZW5ndGgsXG4gICAgICAgICAgaSAgICAgICAgICAgICAgPSAwO1xuICAgICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgIFxuICAgICAgICAvLyBOZXZlciBjaGFuZ2UgZWxlbWVudHMgd2hlcmUgdGhlIHVzZXIgaXMgY3VycmVudGx5IHR5cGluZyBpblxuICAgICAgICBpZiAoZmllbGQgPT09IGZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIERvbid0IHVwZGF0ZSBoaWRkZW4gZmllbGRzXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20veGluZy93eXNpaHRtbDUvcHVsbC8xNFxuICAgICAgICBpZiAoYXZvaWRIaWRkZW5GaWVsZHMgJiYgZmllbGQudHlwZSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmaWVsZE5hbWUgPSBmaWVsZC5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0ZJRUxEUyk7XG4gICAgICAgIG5ld1ZhbHVlICA9IHRoaXMuZWxlbWVudFRvQ2hhbmdlID8gKHRoaXMuZWxlbWVudFRvQ2hhbmdlW2ZpZWxkTmFtZV0gfHwgXCJcIikgOiBmaWVsZC5kZWZhdWx0VmFsdWU7XG4gICAgICAgIGZpZWxkLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIGRpYWxvZyBlbGVtZW50XG4gICAgICovXG4gICAgc2hvdzogZnVuY3Rpb24oZWxlbWVudFRvQ2hhbmdlKSB7XG4gICAgICB2YXIgdGhhdCAgICAgICAgPSB0aGlzLFxuICAgICAgICAgIGZpcnN0RmllbGQgID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9GT1JNX0VMRU1FTlRTKTtcbiAgICAgIHRoaXMuZWxlbWVudFRvQ2hhbmdlID0gZWxlbWVudFRvQ2hhbmdlO1xuICAgICAgdGhpcy5fb2JzZXJ2ZSgpO1xuICAgICAgdGhpcy5faW50ZXJwb2xhdGUoKTtcbiAgICAgIGlmIChlbGVtZW50VG9DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkgeyB0aGF0Ll9pbnRlcnBvbGF0ZSh0cnVlKTsgfSwgNTAwKTtcbiAgICAgIH1cbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmxpbmssIENMQVNTX05BTUVfT1BFTkVEKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgdGhpcy5maXJlKFwic2hvd1wiKTtcbiAgICAgIGlmIChmaXJzdEZpZWxkICYmICFlbGVtZW50VG9DaGFuZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmaXJzdEZpZWxkLmZvY3VzKCk7XG4gICAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgZGlhbG9nIGVsZW1lbnRcbiAgICAgKi9cbiAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICB0aGlzLmVsZW1lbnRUb0NoYW5nZSA9IG51bGw7XG4gICAgICBkb20ucmVtb3ZlQ2xhc3ModGhpcy5saW5rLCBDTEFTU19OQU1FX09QRU5FRCk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICB0aGlzLmZpcmUoXCJoaWRlXCIpO1xuICAgIH1cbiAgfSk7XG59KSh3eXNpaHRtbDUpO1xuLyoqXG4gKiBDb252ZXJ0cyBzcGVlY2gtdG8tdGV4dCBhbmQgaW5zZXJ0cyB0aGlzIGludG8gdGhlIGVkaXRvclxuICogQXMgb2Ygbm93ICgyMDExLzAzLzI1KSB0aGlzIG9ubHkgaXMgc3VwcG9ydGVkIGluIENocm9tZSA+PSAxMVxuICpcbiAqIE5vdGUgdGhhdCBpdCBzZW5kcyB0aGUgcmVjb3JkZWQgYXVkaW8gdG8gdGhlIGdvb2dsZSBzcGVlY2ggcmVjb2duaXRpb24gYXBpOlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MzYxODI2L2RvZXMtY2hyb21lLWhhdmUtYnVpbC1pbi1zcGVlY2gtcmVjb2duaXRpb24tZm9yLWlucHV0LXR5cGUtdGV4dC14LXdlYmtpdC1zcGVlY1xuICpcbiAqIEN1cnJlbnQgSFRNTDUgZHJhZnQgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHA6Ly9saXN0cy53My5vcmcvQXJjaGl2ZXMvUHVibGljL3B1YmxpYy14Zy1odG1sc3BlZWNoLzIwMTFGZWIvYXR0LTAwMjAvYXBpLWRyYWZ0Lmh0bWxcbiAqIFxuICogXCJBY2Nlc3NpbmcgR29vZ2xlIFNwZWVjaCBBUEkgQ2hyb21lIDExXCJcbiAqIGh0dHA6Ly9taWtlcHVsdHouY29tLzIwMTEvMDMvYWNjZXNzaW5nLWdvb2dsZS1zcGVlY2gtYXBpLWNocm9tZS0xMS9cbiAqL1xuKGZ1bmN0aW9uKHd5c2lodG1sNSkge1xuICB2YXIgZG9tID0gd3lzaWh0bWw1LmRvbTtcbiAgXG4gIHZhciBsaW5rU3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCJcbiAgfTtcbiAgXG4gIHZhciB3cmFwcGVyU3R5bGVzID0ge1xuICAgIGxlZnQ6ICAgICAwLFxuICAgIG1hcmdpbjogICAwLFxuICAgIG9wYWNpdHk6ICAwLFxuICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgIHBhZGRpbmc6ICAwLFxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgdG9wOiAgICAgIDAsXG4gICAgekluZGV4OiAgIDFcbiAgfTtcbiAgXG4gIHZhciBpbnB1dFN0eWxlcyA9IHtcbiAgICBjdXJzb3I6ICAgICBcImluaGVyaXRcIixcbiAgICBmb250U2l6ZTogICBcIjUwcHhcIixcbiAgICBoZWlnaHQ6ICAgICBcIjUwcHhcIixcbiAgICBtYXJnaW5Ub3A6ICBcIi0yNXB4XCIsXG4gICAgb3V0bGluZTogICAgMCxcbiAgICBwYWRkaW5nOiAgICAwLFxuICAgIHBvc2l0aW9uOiAgIFwiYWJzb2x1dGVcIixcbiAgICByaWdodDogICAgICBcIi00cHhcIixcbiAgICB0b3A6ICAgICAgICBcIjUwJVwiXG4gIH07XG4gIFxuICB2YXIgaW5wdXRBdHRyaWJ1dGVzID0ge1xuICAgIFwieC13ZWJraXQtc3BlZWNoXCI6IFwiXCIsXG4gICAgXCJzcGVlY2hcIjogICAgICAgICAgXCJcIlxuICB9O1xuICBcbiAgd3lzaWh0bWw1LnRvb2xiYXIuU3BlZWNoID0gZnVuY3Rpb24ocGFyZW50LCBsaW5rKSB7XG4gICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlmICghd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNTcGVlY2hBcGlPbihpbnB1dCkpIHtcbiAgICAgIGxpbmsuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgXG4gICAgd3lzaWh0bWw1Lmxhbmcub2JqZWN0KHdyYXBwZXJTdHlsZXMpLm1lcmdlKHtcbiAgICAgIHdpZHRoOiAgbGluay5vZmZzZXRXaWR0aCAgKyBcInB4XCIsXG4gICAgICBoZWlnaHQ6IGxpbmsub2Zmc2V0SGVpZ2h0ICsgXCJweFwiXG4gICAgfSk7XG4gICAgXG4gICAgZG9tLmluc2VydChpbnB1dCkuaW50byh3cmFwcGVyKTtcbiAgICBkb20uaW5zZXJ0KHdyYXBwZXIpLmludG8obGluayk7XG4gICAgXG4gICAgZG9tLnNldFN0eWxlcyhpbnB1dFN0eWxlcykub24oaW5wdXQpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGVzKGlucHV0QXR0cmlidXRlcykub24oaW5wdXQpXG4gICAgXG4gICAgZG9tLnNldFN0eWxlcyh3cmFwcGVyU3R5bGVzKS5vbih3cmFwcGVyKTtcbiAgICBkb20uc2V0U3R5bGVzKGxpbmtTdHlsZXMpLm9uKGxpbmspO1xuICAgIFxuICAgIHZhciBldmVudE5hbWUgPSBcIm9ud2Via2l0c3BlZWNoY2hhbmdlXCIgaW4gaW5wdXQgPyBcIndlYmtpdHNwZWVjaGNoYW5nZVwiIDogXCJzcGVlY2hjaGFuZ2VcIjtcbiAgICBkb20ub2JzZXJ2ZShpbnB1dCwgZXZlbnROYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgIHBhcmVudC5leGVjQ29tbWFuZChcImluc2VydFRleHRcIiwgaW5wdXQudmFsdWUpO1xuICAgICAgaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgIH0pO1xuICAgIFxuICAgIGRvbS5vYnNlcnZlKGlucHV0LCBcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoZG9tLmhhc0NsYXNzKGxpbmssIFwid3lzaWh0bWw1LWNvbW1hbmQtZGlzYWJsZWRcIikpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH07XG59KSh3eXNpaHRtbDUpOy8qKlxuICogVG9vbGJhclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgUmVmZXJlbmNlIHRvIGluc3RhbmNlIG9mIEVkaXRvciBpbnN0YW5jZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgUmVmZXJlbmNlIHRvIHRoZSB0b29sYmFyIGNvbnRhaW5lciBlbGVtZW50XG4gKlxuICogQGV4YW1wbGVcbiAqICAgIDxkaXYgaWQ9XCJ0b29sYmFyXCI+XG4gKiAgICAgIDxhIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XCJjcmVhdGVMaW5rXCI+aW5zZXJ0IGxpbms8L2E+XG4gKiAgICAgIDxhIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XCJmb3JtYXRCbG9ja1wiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XCJoMVwiPmluc2VydCBoMTwvYT5cbiAqICAgIDwvZGl2PlxuICpcbiAqICAgIDxzY3JpcHQ+XG4gKiAgICAgIHZhciB0b29sYmFyID0gbmV3IHd5c2lodG1sNS50b29sYmFyLlRvb2xiYXIoZWRpdG9yLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRvb2xiYXJcIikpO1xuICogICAgPC9zY3JpcHQ+XG4gKi9cbihmdW5jdGlvbih3eXNpaHRtbDUpIHtcbiAgdmFyIENMQVNTX05BTUVfQ09NTUFORF9ESVNBQkxFRCAgID0gXCJ3eXNpaHRtbDUtY29tbWFuZC1kaXNhYmxlZFwiLFxuICAgICAgQ0xBU1NfTkFNRV9DT01NQU5EU19ESVNBQkxFRCAgPSBcInd5c2lodG1sNS1jb21tYW5kcy1kaXNhYmxlZFwiLFxuICAgICAgQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSAgICAgPSBcInd5c2lodG1sNS1jb21tYW5kLWFjdGl2ZVwiLFxuICAgICAgQ0xBU1NfTkFNRV9BQ1RJT05fQUNUSVZFICAgICAgPSBcInd5c2lodG1sNS1hY3Rpb24tYWN0aXZlXCIsXG4gICAgICBkb20gICAgICAgICAgICAgICAgICAgICAgICAgICA9IHd5c2lodG1sNS5kb207XG4gIFxuICB3eXNpaHRtbDUudG9vbGJhci5Ub29sYmFyID0gQmFzZS5leHRlbmQoXG4gICAgLyoqIEBzY29wZSB3eXNpaHRtbDUudG9vbGJhci5Ub29sYmFyLnByb3RvdHlwZSAqLyB7XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKGVkaXRvciwgY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmVkaXRvciAgICAgPSBlZGl0b3I7XG4gICAgICB0aGlzLmNvbnRhaW5lciAgPSB0eXBlb2YoY29udGFpbmVyKSA9PT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRhaW5lcikgOiBjb250YWluZXI7XG4gICAgICB0aGlzLmNvbXBvc2VyICAgPSBlZGl0b3IuY29tcG9zZXI7XG5cbiAgICAgIHRoaXMuX2dldExpbmtzKFwiY29tbWFuZFwiKTtcbiAgICAgIHRoaXMuX2dldExpbmtzKFwiYWN0aW9uXCIpO1xuXG4gICAgICB0aGlzLl9vYnNlcnZlKCk7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICAgIFxuICAgICAgdmFyIHNwZWVjaElucHV0TGlua3MgID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLXd5c2lodG1sNS1jb21tYW5kPWluc2VydFNwZWVjaF1cIiksXG4gICAgICAgICAgbGVuZ3RoICAgICAgICAgICAgPSBzcGVlY2hJbnB1dExpbmtzLmxlbmd0aCxcbiAgICAgICAgICBpICAgICAgICAgICAgICAgICA9IDA7XG4gICAgICBmb3IgKDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICBuZXcgd3lzaWh0bWw1LnRvb2xiYXIuU3BlZWNoKHRoaXMsIHNwZWVjaElucHV0TGlua3NbaV0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0TGlua3M6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBsaW5rcyAgID0gdGhpc1t0eXBlICsgXCJMaW5rc1wiXSA9IHd5c2lodG1sNS5sYW5nLmFycmF5KHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS13eXNpaHRtbDUtXCIgKyB0eXBlICsgXCJdXCIpKS5nZXQoKSxcbiAgICAgICAgICBsZW5ndGggID0gbGlua3MubGVuZ3RoLFxuICAgICAgICAgIGkgICAgICAgPSAwLFxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzW3R5cGUgKyBcIk1hcHBpbmdcIl0gPSB7fSxcbiAgICAgICAgICBsaW5rLFxuICAgICAgICAgIGdyb3VwLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZGlhbG9nO1xuICAgICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGluayAgICA9IGxpbmtzW2ldO1xuICAgICAgICBuYW1lICAgID0gbGluay5nZXRBdHRyaWJ1dGUoXCJkYXRhLXd5c2lodG1sNS1cIiArIHR5cGUpO1xuICAgICAgICB2YWx1ZSAgID0gbGluay5nZXRBdHRyaWJ1dGUoXCJkYXRhLXd5c2lodG1sNS1cIiArIHR5cGUgKyBcIi12YWx1ZVwiKTtcbiAgICAgICAgZ3JvdXAgICA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS13eXNpaHRtbDUtXCIgKyB0eXBlICsgXCItZ3JvdXA9J1wiICsgbmFtZSArIFwiJ11cIik7XG4gICAgICAgIGRpYWxvZyAgPSB0aGlzLl9nZXREaWFsb2cobGluaywgbmFtZSk7XG4gICAgICAgIFxuICAgICAgICBtYXBwaW5nW25hbWUgKyBcIjpcIiArIHZhbHVlXSA9IHtcbiAgICAgICAgICBsaW5rOiAgIGxpbmssXG4gICAgICAgICAgZ3JvdXA6ICBncm91cCxcbiAgICAgICAgICBuYW1lOiAgIG5hbWUsXG4gICAgICAgICAgdmFsdWU6ICB2YWx1ZSxcbiAgICAgICAgICBkaWFsb2c6IGRpYWxvZyxcbiAgICAgICAgICBzdGF0ZTogIGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9nZXREaWFsb2c6IGZ1bmN0aW9uKGxpbmssIGNvbW1hbmQpIHtcbiAgICAgIHZhciB0aGF0ICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICBkaWFsb2dFbGVtZW50ID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIltkYXRhLXd5c2lodG1sNS1kaWFsb2c9J1wiICsgY29tbWFuZCArIFwiJ11cIiksXG4gICAgICAgICAgZGlhbG9nLFxuICAgICAgICAgIGNhcmV0Qm9va21hcms7XG4gICAgICBcbiAgICAgIGlmIChkaWFsb2dFbGVtZW50KSB7XG4gICAgICAgIGRpYWxvZyA9IG5ldyB3eXNpaHRtbDUudG9vbGJhci5EaWFsb2cobGluaywgZGlhbG9nRWxlbWVudCk7XG5cbiAgICAgICAgZGlhbG9nLm9ic2VydmUoXCJzaG93XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNhcmV0Qm9va21hcmsgPSB0aGF0LmNvbXBvc2VyLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuXG4gICAgICAgICAgdGhhdC5lZGl0b3IuZmlyZShcInNob3c6ZGlhbG9nXCIsIHsgY29tbWFuZDogY29tbWFuZCwgZGlhbG9nQ29udGFpbmVyOiBkaWFsb2dFbGVtZW50LCBjb21tYW5kTGluazogbGluayB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGlhbG9nLm9ic2VydmUoXCJzYXZlXCIsIGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBpZiAoY2FyZXRCb29rbWFyaykge1xuICAgICAgICAgICAgdGhhdC5jb21wb3Nlci5zZWxlY3Rpb24uc2V0Qm9va21hcmsoY2FyZXRCb29rbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoYXQuX2V4ZWNDb21tYW5kKGNvbW1hbmQsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgIFxuICAgICAgICAgIHRoYXQuZWRpdG9yLmZpcmUoXCJzYXZlOmRpYWxvZ1wiLCB7IGNvbW1hbmQ6IGNvbW1hbmQsIGRpYWxvZ0NvbnRhaW5lcjogZGlhbG9nRWxlbWVudCwgY29tbWFuZExpbms6IGxpbmsgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRpYWxvZy5vYnNlcnZlKFwiY2FuY2VsXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoYXQuZWRpdG9yLmZvY3VzKGZhbHNlKTtcbiAgICAgICAgICB0aGF0LmVkaXRvci5maXJlKFwiY2FuY2VsOmRpYWxvZ1wiLCB7IGNvbW1hbmQ6IGNvbW1hbmQsIGRpYWxvZ0NvbnRhaW5lcjogZGlhbG9nRWxlbWVudCwgY29tbWFuZExpbms6IGxpbmsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpYWxvZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB2YXIgdG9vbGJhciA9IG5ldyB3eXNpaHRtbDUuVG9vbGJhcigpO1xuICAgICAqICAgIC8vIEluc2VydCBhIDxibG9ja3F1b3RlPiBlbGVtZW50IG9yIHdyYXAgY3VycmVudCBzZWxlY3Rpb24gaW4gPGJsb2NrcXVvdGU+XG4gICAgICogICAgdG9vbGJhci5leGVjQ29tbWFuZChcImZvcm1hdEJsb2NrXCIsIFwiYmxvY2txdW90ZVwiKTtcbiAgICAgKi9cbiAgICBleGVjQ29tbWFuZDogZnVuY3Rpb24oY29tbWFuZCwgY29tbWFuZFZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5jb21tYW5kc0Rpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbW1hbmRPYmogPSB0aGlzLmNvbW1hbmRNYXBwaW5nW2NvbW1hbmQgKyBcIjpcIiArIGNvbW1hbmRWYWx1ZV07XG5cbiAgICAgIC8vIFNob3cgZGlhbG9nIHdoZW4gYXZhaWxhYmxlXG4gICAgICBpZiAoY29tbWFuZE9iaiAmJiBjb21tYW5kT2JqLmRpYWxvZyAmJiAhY29tbWFuZE9iai5zdGF0ZSkge1xuICAgICAgICBjb21tYW5kT2JqLmRpYWxvZy5zaG93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9leGVjQ29tbWFuZChjb21tYW5kLCBjb21tYW5kVmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZXhlY0NvbW1hbmQ6IGZ1bmN0aW9uKGNvbW1hbmQsIGNvbW1hbmRWYWx1ZSkge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgY29tcG9zZXIgaXMgZm9jdXNzZWQgKGZhbHNlID0+IGRvbid0IG1vdmUgY2FyZXQgdG8gdGhlIGVuZClcbiAgICAgIHRoaXMuZWRpdG9yLmZvY3VzKGZhbHNlKTtcblxuICAgICAgdGhpcy5jb21wb3Nlci5jb21tYW5kcy5leGVjKGNvbW1hbmQsIGNvbW1hbmRWYWx1ZSk7XG4gICAgICB0aGlzLl91cGRhdGVMaW5rU3RhdGVzKCk7XG4gICAgfSxcblxuICAgIGV4ZWNBY3Rpb246IGZ1bmN0aW9uKGFjdGlvbikge1xuICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgc3dpdGNoKGFjdGlvbikge1xuICAgICAgICBjYXNlIFwiY2hhbmdlX3ZpZXdcIjpcbiAgICAgICAgICBpZiAoZWRpdG9yLmN1cnJlbnRWaWV3ID09PSBlZGl0b3IudGV4dGFyZWEpIHtcbiAgICAgICAgICAgIGVkaXRvci5maXJlKFwiY2hhbmdlX3ZpZXdcIiwgXCJjb21wb3NlclwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWRpdG9yLmZpcmUoXCJjaGFuZ2Vfdmlld1wiLCBcInRleHRhcmVhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX29ic2VydmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoYXQgICAgICA9IHRoaXMsXG4gICAgICAgICAgZWRpdG9yICAgID0gdGhpcy5lZGl0b3IsXG4gICAgICAgICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgbGlua3MgICAgID0gdGhpcy5jb21tYW5kTGlua3MuY29uY2F0KHRoaXMuYWN0aW9uTGlua3MpLFxuICAgICAgICAgIGxlbmd0aCAgICA9IGxpbmtzLmxlbmd0aCxcbiAgICAgICAgICBpICAgICAgICAgPSAwO1xuICAgICAgXG4gICAgICBmb3IgKDsgaTxsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyAnamF2YXNjcmlwdDo7JyBhbmQgdW5zZWxlY3RhYmxlPW9uIE5lZWRlZCBmb3IgSUUsIGJ1dCBkb25lIGluIGFsbCBicm93c2VycyB0byBtYWtlIHN1cmUgdGhhdCBhbGwgZ2V0IHRoZSBzYW1lIGNzcyBhcHBsaWVkXG4gICAgICAgIC8vICh5b3Uga25vdywgYTpsaW5rIHsgLi4uIH0gZG9lc24ndCBtYXRjaCBhbmNob3JzIHdpdGggbWlzc2luZyBocmVmIGF0dHJpYnV0ZSlcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgIGhyZWY6ICAgICAgICAgXCJqYXZhc2NyaXB0OjtcIixcbiAgICAgICAgICB1bnNlbGVjdGFibGU6IFwib25cIlxuICAgICAgICB9KS5vbihsaW5rc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5lZWRlZCBmb3Igb3BlcmFcbiAgICAgIGRvbS5kZWxlZ2F0ZShjb250YWluZXIsIFwiW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmRdXCIsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKGV2ZW50KSB7IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IH0pO1xuICAgICAgXG4gICAgICBkb20uZGVsZWdhdGUoY29udGFpbmVyLCBcIltkYXRhLXd5c2lodG1sNS1jb21tYW5kXVwiLCBcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBsaW5rICAgICAgICAgID0gdGhpcyxcbiAgICAgICAgICAgIGNvbW1hbmQgICAgICAgPSBsaW5rLmdldEF0dHJpYnV0ZShcImRhdGEtd3lzaWh0bWw1LWNvbW1hbmRcIiksXG4gICAgICAgICAgICBjb21tYW5kVmFsdWUgID0gbGluay5nZXRBdHRyaWJ1dGUoXCJkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlXCIpO1xuICAgICAgICB0aGF0LmV4ZWNDb21tYW5kKGNvbW1hbmQsIGNvbW1hbmRWYWx1ZSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcblxuICAgICAgZG9tLmRlbGVnYXRlKGNvbnRhaW5lciwgXCJbZGF0YS13eXNpaHRtbDUtYWN0aW9uXVwiLCBcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtd3lzaWh0bWw1LWFjdGlvblwiKTtcbiAgICAgICAgdGhhdC5leGVjQWN0aW9uKGFjdGlvbik7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcblxuICAgICAgZWRpdG9yLm9ic2VydmUoXCJmb2N1czpjb21wb3NlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5ib29rbWFyayA9IG51bGw7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhhdC5pbnRlcnZhbCk7XG4gICAgICAgIHRoYXQuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHsgdGhhdC5fdXBkYXRlTGlua1N0YXRlcygpOyB9LCA1MDApO1xuICAgICAgfSk7XG5cbiAgICAgIGVkaXRvci5vYnNlcnZlKFwiYmx1cjpjb21wb3NlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGF0LmludGVydmFsKTtcbiAgICAgIH0pO1xuXG4gICAgICBlZGl0b3Iub2JzZXJ2ZShcImRlc3Ryb3k6Y29tcG9zZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhhdC5pbnRlcnZhbCk7XG4gICAgICB9KTtcblxuICAgICAgZWRpdG9yLm9ic2VydmUoXCJjaGFuZ2Vfdmlld1wiLCBmdW5jdGlvbihjdXJyZW50Vmlldykge1xuICAgICAgICAvLyBTZXQgdGltZW91dCBuZWVkZWQgaW4gb3JkZXIgdG8gbGV0IHRoZSBibHVyIGV2ZW50IGZpcmUgZmlyc3RcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGF0LmNvbW1hbmRzRGlzYWJsZWQgPSAoY3VycmVudFZpZXcgIT09IFwiY29tcG9zZXJcIik7XG4gICAgICAgICAgdGhhdC5fdXBkYXRlTGlua1N0YXRlcygpO1xuICAgICAgICAgIGlmICh0aGF0LmNvbW1hbmRzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhjb250YWluZXIsIENMQVNTX05BTUVfQ09NTUFORFNfRElTQUJMRUQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBDTEFTU19OQU1FX0NPTU1BTkRTX0RJU0FCTEVEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF91cGRhdGVMaW5rU3RhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbGVtZW50ICAgICAgICAgICA9IHRoaXMuY29tcG9zZXIuZWxlbWVudCxcbiAgICAgICAgICBjb21tYW5kTWFwcGluZyAgICA9IHRoaXMuY29tbWFuZE1hcHBpbmcsXG4gICAgICAgICAgYWN0aW9uTWFwcGluZyAgICAgPSB0aGlzLmFjdGlvbk1hcHBpbmcsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgY29tbWFuZDtcbiAgICAgIC8vIGV2ZXJ5IG1pbGxpc2Vjb25kIGNvdW50cy4uLiB0aGlzIGlzIGV4ZWN1dGVkIHF1aXRlIG9mdGVuXG4gICAgICBmb3IgKGkgaW4gY29tbWFuZE1hcHBpbmcpIHtcbiAgICAgICAgY29tbWFuZCA9IGNvbW1hbmRNYXBwaW5nW2ldO1xuICAgICAgICBpZiAodGhpcy5jb21tYW5kc0Rpc2FibGVkKSB7XG4gICAgICAgICAgc3RhdGUgPSBmYWxzZTtcbiAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29tbWFuZC5saW5rLCBDTEFTU19OQU1FX0NPTU1BTkRfQUNUSVZFKTtcbiAgICAgICAgICBpZiAoY29tbWFuZC5ncm91cCkge1xuICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbW1hbmQuZ3JvdXAsIENMQVNTX05BTUVfQ09NTUFORF9BQ1RJVkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWFuZC5kaWFsb2cpIHtcbiAgICAgICAgICAgIGNvbW1hbmQuZGlhbG9nLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUgPSB0aGlzLmNvbXBvc2VyLmNvbW1hbmRzLnN0YXRlKGNvbW1hbmQubmFtZSwgY29tbWFuZC52YWx1ZSk7XG4gICAgICAgICAgaWYgKHd5c2lodG1sNS5sYW5nLm9iamVjdChzdGF0ZSkuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICAvLyBHcmFiIGZpcnN0IGFuZCBvbmx5IG9iamVjdC9lbGVtZW50IGluIHN0YXRlIGFycmF5LCBvdGhlcndpc2UgY29udmVydCBzdGF0ZSBpbnRvIGJvb2xlYW5cbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIHNob3dpbmcgYSBkaWFsb2cgZm9yIG11bHRpcGxlIHNlbGVjdGVkIGVsZW1lbnRzIHdoaWNoIG1heSBoYXZlIGRpZmZlcmVudCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyBlZy4gd2hlbiB0d28gbGlua3Mgd2l0aCBkaWZmZXJlbnQgaHJlZiBhcmUgc2VsZWN0ZWQsIHRoZSBzdGF0ZSB3aWxsIGJlIGFuIGFycmF5IGNvbnNpc3Rpbmcgb2YgYm90aCBsaW5rIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBidXQgdGhlIGRpYWxvZyBpbnRlcmZhY2UgY2FuIG9ubHkgdXBkYXRlIG9uZVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5sZW5ndGggPT09IDEgPyBzdGF0ZVswXSA6IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb21tYW5kLmxpbmssIENMQVNTX05BTUVfQ09NTUFORF9ESVNBQkxFRCk7XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZ3JvdXApIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb21tYW5kLmdyb3VwLCBDTEFTU19OQU1FX0NPTU1BTkRfRElTQUJMRUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tYW5kLnN0YXRlID09PSBzdGF0ZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tbWFuZC5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MoY29tbWFuZC5saW5rLCBDTEFTU19OQU1FX0NPTU1BTkRfQUNUSVZFKTtcbiAgICAgICAgICBpZiAoY29tbWFuZC5ncm91cCkge1xuICAgICAgICAgICAgZG9tLmFkZENsYXNzKGNvbW1hbmQuZ3JvdXAsIENMQVNTX05BTUVfQ09NTUFORF9BQ1RJVkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWFuZC5kaWFsb2cpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yoc3RhdGUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIGNvbW1hbmQuZGlhbG9nLnNob3coc3RhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29tbWFuZC5kaWFsb2cuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29tbWFuZC5saW5rLCBDTEFTU19OQU1FX0NPTU1BTkRfQUNUSVZFKTtcbiAgICAgICAgICBpZiAoY29tbWFuZC5ncm91cCkge1xuICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbW1hbmQuZ3JvdXAsIENMQVNTX05BTUVfQ09NTUFORF9BQ1RJVkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWFuZC5kaWFsb2cpIHtcbiAgICAgICAgICAgIGNvbW1hbmQuZGlhbG9nLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgZm9yIChpIGluIGFjdGlvbk1hcHBpbmcpIHtcbiAgICAgICAgYWN0aW9uID0gYWN0aW9uTWFwcGluZ1tpXTtcbiAgICAgICAgXG4gICAgICAgIGlmIChhY3Rpb24ubmFtZSA9PT0gXCJjaGFuZ2Vfdmlld1wiKSB7XG4gICAgICAgICAgYWN0aW9uLnN0YXRlID0gdGhpcy5lZGl0b3IuY3VycmVudFZpZXcgPT09IHRoaXMuZWRpdG9yLnRleHRhcmVhO1xuICAgICAgICAgIGlmIChhY3Rpb24uc3RhdGUpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhhY3Rpb24ubGluaywgQ0xBU1NfTkFNRV9BQ1RJT05fQUNUSVZFKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGFjdGlvbi5saW5rLCBDTEFTU19OQU1FX0FDVElPTl9BQ1RJVkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgIH0sXG5cbiAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG4gIH0pO1xuICBcbn0pKHd5c2lodG1sNSk7XG4vKipcbiAqIFdZU0lIVE1MNSBFZGl0b3JcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRleHRhcmVhRWxlbWVudCBSZWZlcmVuY2UgdG8gdGhlIHRleHRhcmVhIHdoaWNoIHNob3VsZCBiZSB0dXJuZWQgaW50byBhIHJpY2ggdGV4dCBpbnRlcmZhY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBTZWUgZGVmYXVsdENvbmZpZyBvYmplY3QgYmVsb3cgZm9yIGV4cGxhbmF0aW9uIG9mIGVhY2ggaW5kaXZpZHVhbCBjb25maWcgb3B0aW9uXG4gKlxuICogQGV2ZW50c1xuICogICAgbG9hZFxuICogICAgYmVmb3JlbG9hZCAoZm9yIGludGVybmFsIHVzZSBvbmx5KVxuICogICAgZm9jdXNcbiAqICAgIGZvY3VzOmNvbXBvc2VyXG4gKiAgICBmb2N1czp0ZXh0YXJlYVxuICogICAgYmx1clxuICogICAgYmx1cjpjb21wb3NlclxuICogICAgYmx1cjp0ZXh0YXJlYVxuICogICAgY2hhbmdlXG4gKiAgICBjaGFuZ2U6Y29tcG9zZXJcbiAqICAgIGNoYW5nZTp0ZXh0YXJlYVxuICogICAgcGFzdGVcbiAqICAgIHBhc3RlOmNvbXBvc2VyXG4gKiAgICBwYXN0ZTp0ZXh0YXJlYVxuICogICAgbmV3d29yZDpjb21wb3NlclxuICogICAgZGVzdHJveTpjb21wb3NlclxuICogICAgdW5kbzpjb21wb3NlclxuICogICAgcmVkbzpjb21wb3NlclxuICogICAgYmVmb3JlY29tbWFuZDpjb21wb3NlclxuICogICAgYWZ0ZXJjb21tYW5kOmNvbXBvc2VyXG4gKiAgICBjaGFuZ2Vfdmlld1xuICovXG4oZnVuY3Rpb24od3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZjtcbiAgXG4gIHZhciBkZWZhdWx0Q29uZmlnID0ge1xuICAgIC8vIEdpdmUgdGhlIGVkaXRvciBhIG5hbWUsIHRoZSBuYW1lIHdpbGwgYWxzbyBiZSBzZXQgYXMgY2xhc3MgbmFtZSBvbiB0aGUgaWZyYW1lIGFuZCBvbiB0aGUgaWZyYW1lJ3MgYm9keSBcbiAgICBuYW1lOiAgICAgICAgICAgICAgICAgdW5kZWYsXG4gICAgLy8gV2hldGhlciB0aGUgZWRpdG9yIHNob3VsZCBsb29rIGxpa2UgdGhlIHRleHRhcmVhIChieSBhZG9wdGluZyBzdHlsZXMpXG4gICAgc3R5bGU6ICAgICAgICAgICAgICAgIHRydWUsXG4gICAgLy8gSWQgb2YgdGhlIHRvb2xiYXIgZWxlbWVudCwgcGFzcyBmYWxzZXkgdmFsdWUgaWYgeW91IGRvbid0IHdhbnQgYW55IHRvb2xiYXIgbG9naWNcbiAgICB0b29sYmFyOiAgICAgICAgICAgICAgdW5kZWYsXG4gICAgLy8gV2hldGhlciB1cmxzLCBlbnRlcmVkIGJ5IHRoZSB1c2VyIHNob3VsZCBhdXRvbWF0aWNhbGx5IGJlY29tZSBjbGlja2FibGUtbGlua3NcbiAgICBhdXRvTGluazogICAgICAgICAgICAgdHJ1ZSxcbiAgICAvLyBPYmplY3Qgd2hpY2ggaW5jbHVkZXMgcGFyc2VyIHJ1bGVzIHRvIGFwcGx5IHdoZW4gaHRtbCBnZXRzIGluc2VydGVkIHZpYSBjb3B5ICYgcGFzdGVcbiAgICAvLyBTZWUgcGFyc2VyX3J1bGVzLyouanMgZm9yIGV4YW1wbGVzXG4gICAgcGFyc2VyUnVsZXM6ICAgICAgICAgIHsgdGFnczogeyBicjoge30sIHNwYW46IHt9LCBkaXY6IHt9LCBwOiB7fSB9LCBjbGFzc2VzOiB7fSB9LFxuICAgIC8vIFBhcnNlciBtZXRob2QgdG8gdXNlIHdoZW4gdGhlIHVzZXIgaW5zZXJ0cyBjb250ZW50IHZpYSBjb3B5ICYgcGFzdGVcbiAgICBwYXJzZXI6ICAgICAgICAgICAgICAgd3lzaWh0bWw1LmRvbS5wYXJzZSxcbiAgICAvLyBDbGFzcyBuYW1lIHdoaWNoIHNob3VsZCBiZSBzZXQgb24gdGhlIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50IGluIHRoZSBjcmVhdGVkIHNhbmRib3ggaWZyYW1lLCBjYW4gYmUgc3R5bGVkIHZpYSB0aGUgJ3N0eWxlc2hlZXRzJyBvcHRpb25cbiAgICBjb21wb3NlckNsYXNzTmFtZTogICAgXCJ3eXNpaHRtbDUtZWRpdG9yXCIsXG4gICAgLy8gQ2xhc3MgbmFtZSB0byBhZGQgdG8gdGhlIGJvZHkgd2hlbiB0aGUgd3lzaWh0bWw1IGVkaXRvciBpcyBzdXBwb3J0ZWRcbiAgICBib2R5Q2xhc3NOYW1lOiAgICAgICAgXCJ3eXNpaHRtbDUtc3VwcG9ydGVkXCIsXG4gICAgLy8gQXJyYXkgKG9yIHNpbmdsZSBzdHJpbmcpIG9mIHN0eWxlc2hlZXQgdXJscyB0byBiZSBsb2FkZWQgaW4gdGhlIGVkaXRvcidzIGlmcmFtZVxuICAgIHN0eWxlc2hlZXRzOiAgICAgICAgICBbXSxcbiAgICAvLyBQbGFjZWhvbGRlciB0ZXh0IHRvIHVzZSwgZGVmYXVsdHMgdG8gdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZSBvbiB0aGUgdGV4dGFyZWEgZWxlbWVudFxuICAgIHBsYWNlaG9sZGVyVGV4dDogICAgICB1bmRlZixcbiAgICAvLyBXaGV0aGVyIHRoZSBjb21wb3NlciBzaG91bGQgYWxsb3cgdGhlIHVzZXIgdG8gbWFudWFsbHkgcmVzaXplIGltYWdlcywgdGFibGVzIGV0Yy5cbiAgICBhbGxvd09iamVjdFJlc2l6aW5nOiAgdHJ1ZSxcbiAgICAvLyBXaGV0aGVyIHRoZSByaWNoIHRleHQgZWRpdG9yIHNob3VsZCBiZSByZW5kZXJlZCBvbiB0b3VjaCBkZXZpY2VzICh3eXNpaHRtbDUgPj0gMC4zLjAgY29tZXMgd2l0aCBiYXNpYyBzdXBwb3J0IGZvciBpT1MgNSlcbiAgICBzdXBwb3J0VG91Y2hEZXZpY2VzOiAgdHJ1ZVxuICB9O1xuICAgICAgd2luZG93Lnd5c2lodG1sNSA9IHd5c2lodG1sNVxuICB3eXNpaHRtbDUuRWRpdG9yID0gd3lzaWh0bWw1LmxhbmcuRGlzcGF0Y2hlci5leHRlbmQoXG4gICAgLyoqIEBzY29wZSB3eXNpaHRtbDUuRWRpdG9yLnByb3RvdHlwZSAqLyB7XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKHRleHRhcmVhRWxlbWVudCwgY29uZmlnKSB7XG4gICAgICB0aGlzLnRleHRhcmVhRWxlbWVudCAgPSB0eXBlb2YodGV4dGFyZWFFbGVtZW50KSA9PT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRleHRhcmVhRWxlbWVudCkgOiB0ZXh0YXJlYUVsZW1lbnQ7XG4gICAgICB0aGlzLmNvbmZpZyAgICAgICAgICAgPSB3eXNpaHRtbDUubGFuZy5vYmplY3Qoe30pLm1lcmdlKGRlZmF1bHRDb25maWcpLm1lcmdlKGNvbmZpZykuZ2V0KCk7XG4gICAgICB0aGlzLnRleHRhcmVhICAgICAgICAgPSBuZXcgd3lzaWh0bWw1LnZpZXdzLlRleHRhcmVhKHRoaXMsIHRoaXMudGV4dGFyZWFFbGVtZW50LCB0aGlzLmNvbmZpZyk7XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3ICAgICAgPSB0aGlzLnRleHRhcmVhO1xuICAgICAgdGhpcy5faXNDb21wYXRpYmxlICAgID0gd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydGVkKCk7XG4gICAgICBcbiAgICAgIC8vIFNvcnQgb3V0IHVuc3VwcG9ydGVkL3Vud2FudGVkIGJyb3dzZXJzIGhlcmVcbiAgICAgIGlmICghdGhpcy5faXNDb21wYXRpYmxlIHx8ICghdGhpcy5jb25maWcuc3VwcG9ydFRvdWNoRGV2aWNlcyAmJiB3eXNpaHRtbDUuYnJvd3Nlci5pc1RvdWNoRGV2aWNlKCkpKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhhdC5maXJlKFwiYmVmb3JlbG9hZFwiKS5maXJlKFwibG9hZFwiKTsgfSwgMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWRkIGNsYXNzIG5hbWUgdG8gYm9keSwgdG8gaW5kaWNhdGUgdGhhdCB0aGUgZWRpdG9yIGlzIHN1cHBvcnRlZFxuICAgICAgd3lzaWh0bWw1LmRvbS5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCB0aGlzLmNvbmZpZy5ib2R5Q2xhc3NOYW1lKTtcbiAgICAgIFxuICAgICAgdGhpcy5jb21wb3NlciA9IG5ldyB3eXNpaHRtbDUudmlld3MuQ29tcG9zZXIodGhpcywgdGhpcy50ZXh0YXJlYUVsZW1lbnQsIHRoaXMuY29uZmlnKTtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcgPSB0aGlzLmNvbXBvc2VyO1xuICAgICAgXG4gICAgICBpZiAodHlwZW9mKHRoaXMuY29uZmlnLnBhcnNlcikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLl9pbml0UGFyc2VyKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRoaXMub2JzZXJ2ZShcImJlZm9yZWxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVyID0gbmV3IHd5c2lodG1sNS52aWV3cy5TeW5jaHJvbml6ZXIodGhpcywgdGhpcy50ZXh0YXJlYSwgdGhpcy5jb21wb3Nlcik7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy50b29sYmFyKSB7XG4gICAgICAgICAgdGhpcy50b29sYmFyID0gbmV3IHd5c2lodG1sNS50b29sYmFyLlRvb2xiYXIodGhpcywgdGhpcy5jb25maWcudG9vbGJhcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkhleWEhIFRoaXMgcGFnZSBpcyB1c2luZyB3eXNpaHRtbDUgZm9yIHJpY2ggdGV4dCBlZGl0aW5nLiBDaGVjayBvdXQgaHR0cHM6Ly9naXRodWIuY29tL3hpbmcvd3lzaWh0bWw1XCIpO1xuICAgICAgfSBjYXRjaChlKSB7fVxuICAgIH0sXG4gICAgXG4gICAgaXNDb21wYXRpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc0NvbXBhdGlibGU7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcuY2xlYXIoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24ocGFyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWaWV3LmdldFZhbHVlKHBhcnNlKTtcbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKGh0bWwsIHBhcnNlKSB7XG4gICAgICBpZiAoIWh0bWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudFZpZXcuc2V0VmFsdWUoaHRtbCwgcGFyc2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZvY3VzOiBmdW5jdGlvbihzZXRUb0VuZCkge1xuICAgICAgdGhpcy5jdXJyZW50Vmlldy5mb2N1cyhzZXRUb0VuZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVhY3RpdmF0ZSBlZGl0b3IgKG1ha2UgaXQgcmVhZG9ubHkpXG4gICAgICovXG4gICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3LmRpc2FibGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGUgZWRpdG9yXG4gICAgICovXG4gICAgZW5hYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcuZW5hYmxlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIFxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFZpZXcuaXNFbXB0eSgpO1xuICAgIH0sXG4gICAgXG4gICAgaGFzUGxhY2Vob2xkZXJTZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFZpZXcuaGFzUGxhY2Vob2xkZXJTZXQoKTtcbiAgICB9LFxuICAgIFxuICAgIHBhcnNlOiBmdW5jdGlvbihodG1sT3JFbGVtZW50KSB7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSB0aGlzLmNvbmZpZy5wYXJzZXIoaHRtbE9yRWxlbWVudCwgdGhpcy5jb25maWcucGFyc2VyUnVsZXMsIHRoaXMuY29tcG9zZXIuc2FuZGJveC5nZXREb2N1bWVudCgpLCB0cnVlKTtcbiAgICAgIGlmICh0eXBlb2YoaHRtbE9yRWxlbWVudCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcoaHRtbE9yRWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSxcbiAgICBcbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIGh0bWwgcGFyc2VyIGxvZ2ljXG4gICAgICogIC0gT2JzZXJ2ZXMgZm9yIHBhc3RlIGFuZCBkcm9wXG4gICAgICovXG4gICAgX2luaXRQYXJzZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5vYnNlcnZlKFwicGFzdGU6Y29tcG9zZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrZWVwU2Nyb2xsUG9zaXRpb24gID0gdHJ1ZSxcbiAgICAgICAgICAgIHRoYXQgICAgICAgICAgICAgICAgPSB0aGlzO1xuICAgICAgICB0aGF0LmNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZShmdW5jdGlvbigpIHtcbiAgICAgICAgICB3eXNpaHRtbDUucXVpcmtzLmNsZWFuUGFzdGVkSFRNTCh0aGF0LmNvbXBvc2VyLmVsZW1lbnQpO1xuICAgICAgICAgIHRoYXQucGFyc2UodGhhdC5jb21wb3Nlci5lbGVtZW50KTtcbiAgICAgICAgfSwga2VlcFNjcm9sbFBvc2l0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB0aGlzLm9ic2VydmUoXCJwYXN0ZTp0ZXh0YXJlYVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlICAgPSB0aGlzLnRleHRhcmVhLmdldFZhbHVlKCksXG4gICAgICAgICAgICBuZXdWYWx1ZTtcbiAgICAgICAgbmV3VmFsdWUgPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5zZXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufSkod3lzaWh0bWw1KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWRpdGFibGUvanMvd3lzaWh0bWw1LTAuMy4wLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

eval("/**\nBootstrap wysihtml5 editor. Based on [bootstrap-wysihtml5](https://github.com/jhollingworth/bootstrap-wysihtml5).  \nYou should include **manually** distributives of `wysihtml5` and `bootstrap-wysihtml5`:\n\n    <link href=\"js/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/bootstrap-wysihtml5-0.0.2.css\" rel=\"stylesheet\" type=\"text/css\"></link>  \n    <script src=\"js/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/wysihtml5-0.3.0.min.js\"></script>  \n    <script src=\"js/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/bootstrap-wysihtml5-0.0.2.min.js\"></script>\n    \nAnd also include `wysihtml5.js` from `inputs-ext` directory of x-editable:\n      \n    <script src=\"js/inputs-ext/wysihtml5/wysihtml5.js\"></script>  \n\n**Note:** It's better to use fresh bootstrap-wysihtml5 from it's [master branch](https://github.com/jhollingworth/bootstrap-wysihtml5/tree/master/src) as there is update for correct image insertion.    \n    \n@class wysihtml5\n@extends abstractinput\n@final\n@since 1.4.0\n@example\n<div id=\"comments\" data-type=\"wysihtml5\" data-pk=\"1\"><h2>awesome</h2> comment!</div>\n<script>\n$(function(){\n    $('#comments').editable({\n        url: '/post',\n        title: 'Enter comments'\n    });\n});\n</script>\n**/\n(function ($) {\n    \"use strict\";\n\n    var Wysihtml5 = function Wysihtml5(options) {\n        this.init('wysihtml5', options, Wysihtml5.defaults);\n\n        //extend wysihtml5 manually as $.extend not recursive \n        this.options.wysihtml5 = $.extend({}, Wysihtml5.defaults.wysihtml5, options.wysihtml5);\n    };\n\n    $.fn.editableutils.inherit(Wysihtml5, $.fn.editabletypes.abstractinput);\n\n    $.extend(Wysihtml5.prototype, {\n        render: function render() {\n            var deferred = $.Deferred(),\n                msieOld;\n\n            //generate unique id as it required for wysihtml5\n            this.$input.attr('id', 'textarea_' + new Date().getTime());\n\n            this.setClass();\n            this.setAttr('placeholder');\n\n            //resolve deffered when widget loaded\n            $.extend(this.options.wysihtml5, {\n                events: {\n                    load: function load() {\n                        deferred.resolve();\n                    }\n                }\n            });\n\n            this.$input.wysihtml5(this.options.wysihtml5);\n\n            /*\n             In IE8 wysihtml5 iframe stays on the same line with buttons toolbar (inside popover).\n             The only solution I found is to add <br>. If you fine better way, please send PR.   \n            */\n            msieOld = /msie\\s*(8|7|6)/.test(navigator.userAgent.toLowerCase());\n            if (msieOld) {\n                this.$input.before('<br><br>');\n            }\n\n            return deferred.promise();\n        },\n\n        value2html: function value2html(value, element) {\n            $(element).html(value);\n        },\n\n        html2value: function html2value(html) {\n            return html;\n        },\n\n        value2input: function value2input(value) {\n            this.$input.data(\"wysihtml5\").editor.setValue(value, true);\n        },\n\n        activate: function activate() {\n            this.$input.data(\"wysihtml5\").editor.focus();\n        },\n\n        isEmpty: function isEmpty($element) {\n            if ($.trim($element.html()) === '') {\n                return true;\n            } else if ($.trim($element.text()) !== '') {\n                return false;\n            } else {\n                //e.g. '<img>', '<br>', '<p></p>'\n                return !$element.height() || !$element.width();\n            }\n        }\n    });\n\n    Wysihtml5.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl\n        @default <textarea></textarea>\n        **/\n        tpl: '<textarea></textarea>',\n        /**\n        @property inputclass\n        @default editable-wysihtml5\n        **/\n        inputclass: 'editable-wysihtml5',\n        /**\n        Placeholder attribute of input. Shown when input is empty.\n         @property placeholder\n        @type string\n        @default null\n        **/\n        placeholder: null,\n        /**\n        Wysihtml5 default options.  \n        See https://github.com/jhollingworth/bootstrap-wysihtml5#options\n         @property wysihtml5\n        @type object\n        @default {stylesheets: false}\n        **/\n        wysihtml5: {\n            stylesheets: false //see https://github.com/jhollingworth/bootstrap-wysihtml5/issues/183\n        }\n    });\n\n    $.fn.editabletypes.wysihtml5 = Wysihtml5;\n})(window.jQuery);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvanMvd3lzaWh0bWw1LmpzPzJiYjYiXSwibmFtZXMiOlsiJCIsIld5c2lodG1sNSIsIm9wdGlvbnMiLCJpbml0IiwiZGVmYXVsdHMiLCJ3eXNpaHRtbDUiLCJleHRlbmQiLCJmbiIsImVkaXRhYmxldXRpbHMiLCJpbmhlcml0IiwiZWRpdGFibGV0eXBlcyIsImFic3RyYWN0aW5wdXQiLCJwcm90b3R5cGUiLCJyZW5kZXIiLCJkZWZlcnJlZCIsIkRlZmVycmVkIiwibXNpZU9sZCIsIiRpbnB1dCIsImF0dHIiLCJEYXRlIiwiZ2V0VGltZSIsInNldENsYXNzIiwic2V0QXR0ciIsImV2ZW50cyIsImxvYWQiLCJyZXNvbHZlIiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRvTG93ZXJDYXNlIiwiYmVmb3JlIiwicHJvbWlzZSIsInZhbHVlMmh0bWwiLCJ2YWx1ZSIsImVsZW1lbnQiLCJodG1sIiwiaHRtbDJ2YWx1ZSIsInZhbHVlMmlucHV0IiwiZGF0YSIsImVkaXRvciIsInNldFZhbHVlIiwiYWN0aXZhdGUiLCJmb2N1cyIsImlzRW1wdHkiLCIkZWxlbWVudCIsInRyaW0iLCJ0ZXh0IiwiaGVpZ2h0Iiwid2lkdGgiLCJ0cGwiLCJpbnB1dGNsYXNzIiwicGxhY2Vob2xkZXIiLCJzdHlsZXNoZWV0cyIsIndpbmRvdyIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJDLFdBQVVBLENBQVYsRUFBYTtBQUNWOztBQUVBLFFBQUlDLFlBQVksU0FBWkEsU0FBWSxDQUFVQyxPQUFWLEVBQW1CO0FBQy9CLGFBQUtDLElBQUwsQ0FBVSxXQUFWLEVBQXVCRCxPQUF2QixFQUFnQ0QsVUFBVUcsUUFBMUM7O0FBRUE7QUFDQSxhQUFLRixPQUFMLENBQWFHLFNBQWIsR0FBeUJMLEVBQUVNLE1BQUYsQ0FBUyxFQUFULEVBQWFMLFVBQVVHLFFBQVYsQ0FBbUJDLFNB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QUFFSCxDQTVHQSxFQTRHQ29ELE9BQU9DLE1BNUdSLENBQUQiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuQm9vdHN0cmFwIHd5c2lodG1sNSBlZGl0b3IuIEJhc2VkIG9uIFtib290c3RyYXAtd3lzaWh0bWw1XShodHRwczovL2dpdGh1Yi5jb20vamhvbGxpbmd3b3J0aC9ib290c3RyYXAtd3lzaWh0bWw1KS4gIFxuWW91IHNob3VsZCBpbmNsdWRlICoqbWFudWFsbHkqKiBkaXN0cmlidXRpdmVzIG9mIGB3eXNpaHRtbDVgIGFuZCBgYm9vdHN0cmFwLXd5c2lodG1sNWA6XG5cbiAgICA8bGluayBocmVmPVwianMvaW5wdXRzLWV4dC93eXNpaHRtbDUvYm9vdHN0cmFwLXd5c2lodG1sNS0wLjAuMi9ib290c3RyYXAtd3lzaWh0bWw1LTAuMC4yLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIiB0eXBlPVwidGV4dC9jc3NcIj48L2xpbms+ICBcbiAgICA8c2NyaXB0IHNyYz1cImpzL2lucHV0cy1leHQvd3lzaWh0bWw1L2Jvb3RzdHJhcC13eXNpaHRtbDUtMC4wLjIvd3lzaWh0bWw1LTAuMy4wLm1pbi5qc1wiPjwvc2NyaXB0PiAgXG4gICAgPHNjcmlwdCBzcmM9XCJqcy9pbnB1dHMtZXh0L3d5c2lodG1sNS9ib290c3RyYXAtd3lzaWh0bWw1LTAuMC4yL2Jvb3RzdHJhcC13eXNpaHRtbDUtMC4wLjIubWluLmpzXCI+PC9zY3JpcHQ+XG4gICAgXG5BbmQgYWxzbyBpbmNsdWRlIGB3eXNpaHRtbDUuanNgIGZyb20gYGlucHV0cy1leHRgIGRpcmVjdG9yeSBvZiB4LWVkaXRhYmxlOlxuICAgICAgXG4gICAgPHNjcmlwdCBzcmM9XCJqcy9pbnB1dHMtZXh0L3d5c2lodG1sNS93eXNpaHRtbDUuanNcIj48L3NjcmlwdD4gIFxuXG4qKk5vdGU6KiogSXQncyBiZXR0ZXIgdG8gdXNlIGZyZXNoIGJvb3RzdHJhcC13eXNpaHRtbDUgZnJvbSBpdCdzIFttYXN0ZXIgYnJhbmNoXShodHRwczovL2dpdGh1Yi5jb20vamhvbGxpbmd3b3J0aC9ib290c3RyYXAtd3lzaWh0bWw1L3RyZWUvbWFzdGVyL3NyYykgYXMgdGhlcmUgaXMgdXBkYXRlIGZvciBjb3JyZWN0IGltYWdlIGluc2VydGlvbi4gICAgXG4gICAgXG5AY2xhc3Mgd3lzaWh0bWw1XG5AZXh0ZW5kcyBhYnN0cmFjdGlucHV0XG5AZmluYWxcbkBzaW5jZSAxLjQuMFxuQGV4YW1wbGVcbjxkaXYgaWQ9XCJjb21tZW50c1wiIGRhdGEtdHlwZT1cInd5c2lodG1sNVwiIGRhdGEtcGs9XCIxXCI+PGgyPmF3ZXNvbWU8L2gyPiBjb21tZW50ITwvZGl2PlxuPHNjcmlwdD5cbiQoZnVuY3Rpb24oKXtcbiAgICAkKCcjY29tbWVudHMnKS5lZGl0YWJsZSh7XG4gICAgICAgIHVybDogJy9wb3N0JyxcbiAgICAgICAgdGl0bGU6ICdFbnRlciBjb21tZW50cydcbiAgICB9KTtcbn0pO1xuPC9zY3JpcHQ+XG4qKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIFxuICAgIHZhciBXeXNpaHRtbDUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ3d5c2lodG1sNScsIG9wdGlvbnMsIFd5c2lodG1sNS5kZWZhdWx0cyk7XG4gICAgICAgIFxuICAgICAgICAvL2V4dGVuZCB3eXNpaHRtbDUgbWFudWFsbHkgYXMgJC5leHRlbmQgbm90IHJlY3Vyc2l2ZSBcbiAgICAgICAgdGhpcy5vcHRpb25zLnd5c2lodG1sNSA9ICQuZXh0ZW5kKHt9LCBXeXNpaHRtbDUuZGVmYXVsdHMud3lzaWh0bWw1LCBvcHRpb25zLnd5c2lodG1sNSk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KFd5c2lodG1sNSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpO1xuXG4gICAgJC5leHRlbmQoV3lzaWh0bWw1LnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKSxcbiAgICAgICAgICAgIG1zaWVPbGQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZ2VuZXJhdGUgdW5pcXVlIGlkIGFzIGl0IHJlcXVpcmVkIGZvciB3eXNpaHRtbDVcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmF0dHIoJ2lkJywgJ3RleHRhcmVhXycrKG5ldyBEYXRlKCkpLmdldFRpbWUoKSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cigncGxhY2Vob2xkZXInKTsgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9yZXNvbHZlIGRlZmZlcmVkIHdoZW4gd2lkZ2V0IGxvYWRlZFxuICAgICAgICAgICAgJC5leHRlbmQodGhpcy5vcHRpb25zLnd5c2lodG1sNSwge1xuICAgICAgICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgICAgICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgfSAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGlucHV0Lnd5c2lodG1sNSh0aGlzLm9wdGlvbnMud3lzaWh0bWw1KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICBJbiBJRTggd3lzaWh0bWw1IGlmcmFtZSBzdGF5cyBvbiB0aGUgc2FtZSBsaW5lIHdpdGggYnV0dG9ucyB0b29sYmFyIChpbnNpZGUgcG9wb3ZlcikuXG4gICAgICAgICAgICAgVGhlIG9ubHkgc29sdXRpb24gSSBmb3VuZCBpcyB0byBhZGQgPGJyPi4gSWYgeW91IGZpbmUgYmV0dGVyIHdheSwgcGxlYXNlIHNlbmQgUFIuICAgXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgbXNpZU9sZCA9IC9tc2llXFxzKig4fDd8NikvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIGlmKG1zaWVPbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5iZWZvcmUoJzxicj48YnI+Jyk7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgICB9LFxuICAgICAgIFxuICAgICAgICB2YWx1ZTJodG1sOiBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgJChlbGVtZW50KS5odG1sKHZhbHVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBodG1sMnZhbHVlOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuZGF0YShcInd5c2lodG1sNVwiKS5lZGl0b3Iuc2V0VmFsdWUodmFsdWUsIHRydWUpO1xuICAgICAgICB9LCBcblxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5kYXRhKFwid3lzaWh0bWw1XCIpLmVkaXRvci5mb2N1cygpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24oJGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmKCQudHJpbSgkZWxlbWVudC5odG1sKCkpID09PSAnJykgeyBcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZigkLnRyaW0oJGVsZW1lbnQudGV4dCgpKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vZS5nLiAnPGltZz4nLCAnPGJyPicsICc8cD48L3A+J1xuICAgICAgICAgICAgICAgIHJldHVybiAhJGVsZW1lbnQuaGVpZ2h0KCkgfHwgISRlbGVtZW50LndpZHRoKCk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBXeXNpaHRtbDUuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGxcbiAgICAgICAgQGRlZmF1bHQgPHRleHRhcmVhPjwvdGV4dGFyZWE+XG4gICAgICAgICoqL1xuICAgICAgICB0cGw6Jzx0ZXh0YXJlYT48L3RleHRhcmVhPicsXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgaW5wdXRjbGFzc1xuICAgICAgICBAZGVmYXVsdCBlZGl0YWJsZS13eXNpaHRtbDVcbiAgICAgICAgKiovXG4gICAgICAgIGlucHV0Y2xhc3M6ICdlZGl0YWJsZS13eXNpaHRtbDUnLFxuICAgICAgICAvKipcbiAgICAgICAgUGxhY2Vob2xkZXIgYXR0cmlidXRlIG9mIGlucHV0LiBTaG93biB3aGVuIGlucHV0IGlzIGVtcHR5LlxuXG4gICAgICAgIEBwcm9wZXJ0eSBwbGFjZWhvbGRlclxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi9cbiAgICAgICAgcGxhY2Vob2xkZXI6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBXeXNpaHRtbDUgZGVmYXVsdCBvcHRpb25zLiAgXG4gICAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamhvbGxpbmd3b3J0aC9ib290c3RyYXAtd3lzaWh0bWw1I29wdGlvbnNcblxuICAgICAgICBAcHJvcGVydHkgd3lzaWh0bWw1XG4gICAgICAgIEB0eXBlIG9iamVjdFxuICAgICAgICBAZGVmYXVsdCB7c3R5bGVzaGVldHM6IGZhbHNlfVxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICB3eXNpaHRtbDU6IHtcbiAgICAgICAgICAgIHN0eWxlc2hlZXRzOiBmYWxzZSAvL3NlZSBodHRwczovL2dpdGh1Yi5jb20vamhvbGxpbmd3b3J0aC9ib290c3RyYXAtd3lzaWh0bWw1L2lzc3Vlcy8xODNcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnd5c2lodG1sNSA9IFd5c2lodG1sNTtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWRpdGFibGUvanMvd3lzaWh0bWw1LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(7);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(9)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!./bootstrap-wysihtml5-0.0.2.css\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!./bootstrap-wysihtml5-0.0.2.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC13eXNpaHRtbDUtMC4wLjIuY3NzPzcxMjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYm9vdHN0cmFwLXd5c2lodG1sNS0wLjAuMi5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYm9vdHN0cmFwLXd5c2lodG1sNS0wLjAuMi5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYm9vdHN0cmFwLXd5c2lodG1sNS0wLjAuMi5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2VkaXRhYmxlL2Nzcy9ib290c3RyYXAtd3lzaWh0bWw1LTAuMC4yLmNzc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(11)(\n  /* script */\n  __webpack_require__(5),\n  /* template */\n  __webpack_require__(12),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"/Users/madao/dev/vue-editable/src/Editable.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] Editable.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-409b4816\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-409b4816\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRWRpdGFibGUudnVlP2EwZjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUFvSDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0VkaXRhYmxlLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNDA5YjQ4MTZcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vRWRpdGFibGUudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgbnVsbCxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCIvVXNlcnMvbWFkYW8vZGV2L3Z1ZS1lZGl0YWJsZS9zcmMvRWRpdGFibGUudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBFZGl0YWJsZS52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNDA5YjQ4MTZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi00MDliNDgxNlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL0VkaXRhYmxlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  props: {\n    contentEditable: {\n      type: Boolean,\n      default: true\n    },\n    type: {\n      type: String,\n      default: 'text'\n    },\n    value: {\n      type: String,\n      default: ''\n    },\n    ajaxOptions: {\n      type: Object,\n      default: function _default() {\n        return {\n          type: 'put',\n          dataType: 'json'\n        };\n      }\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    emptytext: {\n      type: String,\n      default: '无'\n    },\n    placeholder: {\n      type: String,\n      default: ''\n    },\n    display: {\n      type: Boolean,\n      default: true\n    },\n    shown: {\n      type: Function,\n      default: function _default() {}\n    },\n    hidden: {\n      type: Function,\n      default: function _default() {}\n    },\n    option: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    }\n  },\n  watch: {\n    display: function display(value) {\n      var input_el = $(this.$el);\n      var action = value ? 'show' : 'hide';\n      input_el.editable(action);\n    }\n  },\n  data: function data() {\n    return {};\n  },\n  created: function created() {},\n  mounted: function mounted() {\n    this.create_editable_el();\n  },\n\n  methods: {\n    display_value: function display_value() {\n      if (this.type == 'select' && this.option.source && this.option.source.length) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.option.source[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var item = _step.value;\n\n            if (item.value == this.value) {\n              return item.text;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n      return this.value;\n    },\n    create_editable_el: function create_editable_el() {\n      var self = this;\n      var el = $(this.$el);\n      if (el.data('editable')) el.data().editable.destroy();\n      var defaultOption = {\n        mode: 'inline',\n        onblur: 'submit',\n        showbuttons: false,\n        clear: false\n      };\n      if (this.type == 'wysihtml5') {\n        defaultOption.escape = false;\n        defaultOption.wysihtml5 = {\n          'font-styles': false,\n          color: true,\n          emphasis: true,\n          html: false,\n          image: false,\n          link: false,\n          blockquote: false,\n          fa: true,\n          lists: true,\n          stylesheets: [\"https://images.cdn.uniqueway.com/wysiwyg-color.css\"],\n          events: {},\n          supportTouchDevices: true,\n          parserRules: {\n            classes: {\n              'wysiwyg-color-clear': 1,\n              'wysiwyg-color-first': 1,\n              'wysiwyg-color-second': 1,\n              'wysiwyg-color-three': 1\n            },\n            tags: {\n              strong: {},\n              b: {},\n              i: {},\n              br: {},\n              em: {},\n              p: {},\n              span: {},\n              ul: {},\n              ol: {},\n              li: {},\n              div: \"span\",\n              h1: \"span\",\n              h2: \"span\",\n              h3: \"span\",\n              h4: \"span\",\n              h5: \"span\",\n              a: \"span\",\n              img: {\n                remove: 1\n              }\n            }\n          },\n          locale: 'en'\n        };\n      }\n      defaultOption.emptytext = this.emptytext;\n      var option = Object.assign(defaultOption, { ajaxOptions: this.ajaxOptions }, this.option);\n      option.value = this.value;\n      el.data('savable', false);\n      el.editable(option).on('shown', function (e, editble) {\n        self.shown();\n        el.data('savable', false);\n        setTimeout(function () {\n          el.data('savable', true);\n        }, 500);\n      }).on('hidden', function (e, reason) {\n        self.hidden();\n        setTimeout(function () {\n          el.data('savable', false);\n        }, 100);\n      }).on('save', function (e, params) {\n        if (!el.data('savable')) {\n          setTimeout(function () {\n            el.editable('setValue', self.value);\n          }, 100);\n          return;\n        }\n        if (params.newValue == self.value) return;\n        self.handleChange(params.newValue);\n      });\n    },\n    handleChange: function handleChange(value) {\n\n      var self = this;\n      this.value = value;\n      self.$emit('input', self.value);\n      self.$emit('change', self.value);\n      setTimeout(function () {\n        $(self.$el).editable('setValue', self.value);\n      }, 101);\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vRWRpdGFibGUudnVlP2FjNDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFPQTs7O1lBSUE7ZUFFQTtBQUhBOztZQUtBO2VBRUE7QUFIQTs7WUFLQTtlQUVBO0FBSEE7O1lBS0E7bUNBQ0E7O2dCQUVBO29CQUVBO0FBSEE7QUFLQTtBQVJBOztZQVVBO2VBRUE7QUFIQTs7WUFLQTtlQUVBO0FBSEE7O1lBS0E7ZUFFQTtBQUhBOztZQUtBO2VBRUE7QUFIQTs7WUFLQTtvQ0FFQTtBQUhBOztZQUtBO29DQUVBO0FBSEE7O1lBS0E7OztBQUdBO0FBSkE7QUE5Q0E7O3FDQW9EQTs0QkFDQTtvQ0FDQTt3QkFDQTtBQUVBO0FBTkE7d0JBT0E7V0FDQTtBQUNBOzhCQUNBLENBQ0E7OEJBQ0E7U0FDQTtBQUNBOzs7NENBRUE7dUJBQ0Esd0JBQ0E7QUFDQTs7Ozs7O0FBQ0E7OzBDQUNBOzBCQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7a0JBQ0E7QUFDQTtzREFDQTtpQkFDQTtzQkFDQTtrREFDQTs7Y0FFQTtnQkFDQTtxQkFDQTtlQUVBO0FBTEE7b0NBTUE7K0JBQ0E7O3lCQUVBO2lCQUNBO29CQUNBO2dCQUNBO2lCQUNBO2dCQUNBO3NCQUNBO2NBQ0E7aUJBQ0E7d0JBQ0E7a0JBQ0E7K0JBQ0E7OztxQ0FHQTtxQ0FDQTtzQ0FDQTtxQ0FFQTtBQUxBOztzQkFPQTtpQkFDQTtpQkFDQTtrQkFDQTtrQkFDQTtpQkFDQTtvQkFDQTtrQkFDQTtrQkFDQTtrQkFDQTttQkFDQTtrQkFDQTtrQkFDQTtrQkFDQTtrQkFDQTtrQkFDQTtpQkFDQTs7d0JBS0E7QUFKQTtBQWxCQTtBQVBBO2tCQStCQTtBQTVDQTtBQTZDQTtxQ0FDQTt3RkFDQTswQkFDQTt5QkFDQTs0REFDQTthQUNBOzJCQUNBOytCQUNBOzZCQUNBO1dBQ0E7MkNBQ0E7YUFDQTsrQkFDQTs2QkFDQTtXQUNBO3lDQUNBO2lDQUNBO2lDQUNBO3lDQUNBO2FBQ0E7QUFDQTtBQUNBOzJDQUNBO2lDQUNBO0FBQ0E7QUFDQTsrQ0FFQTs7aUJBQ0E7bUJBQ0E7K0JBQ0E7Z0NBQ0E7NkJBQ0E7OENBQ0E7U0FDQTtBQUVBO0FBM0dBO0FBbkVBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxhIGhyZWY9XCJqYXZhc2NyaXB0OjtcIlxuICAgICA6ZGF0YS10eXBlPVwidHlwZVwiXG4gICAgIDpkaXNhYmxlZD0nZGlzYWJsZWQnXG4gICAgIDplbXB0eXRleHQ9J2VtcHR5dGV4dCcgdi1odG1sPSdkaXNwbGF5X3ZhbHVlKCknPjwvYT5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6e1xuICAgICAgY29udGVudEVkaXRhYmxlOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH0sXG4gICAgICB0eXBlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3RleHQnXG4gICAgICB9LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSxcbiAgICAgIGFqYXhPcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdwdXQnLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZW1wdHl0ZXh0OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ+aXoCdcbiAgICAgIH0sXG4gICAgICBwbGFjZWhvbGRlcjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9LFxuICAgICAgZGlzcGxheToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9LFxuICAgICAgc2hvd246IHtcbiAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge31cbiAgICAgIH0sXG4gICAgICBoaWRkZW46IHtcbiAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge31cbiAgICAgIH0sXG4gICAgICBvcHRpb246IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHsgfSB9XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgZGlzcGxheTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGxldCBpbnB1dF9lbCA9ICQodGhpcy4kZWwpXG4gICAgICAgIGxldCBhY3Rpb24gPSB2YWx1ZSA/ICdzaG93JyA6ICdoaWRlJ1xuICAgICAgICBpbnB1dF9lbC5lZGl0YWJsZShhY3Rpb24pXG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHt9XG4gICAgfSxcbiAgICBjcmVhdGVkKCkge1xuICAgIH0sXG4gICAgbW91bnRlZCgpe1xuICAgICAgdGhpcy5jcmVhdGVfZWRpdGFibGVfZWwoKTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGRpc3BsYXlfdmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT0gJ3NlbGVjdCdcbiAgICAgICAgICAgICYmIHRoaXMub3B0aW9uLnNvdXJjZVxuICAgICAgICAgICAgJiYgdGhpcy5vcHRpb24uc291cmNlLmxlbmd0aCkge1xuICAgICAgICAgIGZvcihsZXQgaXRlbSBvZiB0aGlzLm9wdGlvbi5zb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnZhbHVlID09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udGV4dFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVxuICAgICAgfSxcbiAgICAgIGNyZWF0ZV9lZGl0YWJsZV9lbCgpIHtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgZWwgPSAkKHRoaXMuJGVsKVxuICAgICAgICBpZiAoZWwuZGF0YSgnZWRpdGFibGUnKSkgZWwuZGF0YSgpLmVkaXRhYmxlLmRlc3Ryb3koKVxuICAgICAgICBsZXQgZGVmYXVsdE9wdGlvbiA9IHtcbiAgICAgICAgICBtb2RlOiAnaW5saW5lJyxcbiAgICAgICAgICBvbmJsdXI6ICdzdWJtaXQnLFxuICAgICAgICAgIHNob3didXR0b25zOiBmYWxzZSxcbiAgICAgICAgICBjbGVhcjogZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50eXBlID09ICd3eXNpaHRtbDUnKSB7XG4gICAgICAgICAgZGVmYXVsdE9wdGlvbi5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICBkZWZhdWx0T3B0aW9uLnd5c2lodG1sNSA9IHtcbiAgICAgICAgICAgICdmb250LXN0eWxlcyc6IGZhbHNlLFxuICAgICAgICAgICAgY29sb3I6IHRydWUsXG4gICAgICAgICAgICBlbXBoYXNpczogdHJ1ZSxcbiAgICAgICAgICAgIGh0bWw6IGZhbHNlLFxuICAgICAgICAgICAgaW1hZ2U6IGZhbHNlLFxuICAgICAgICAgICAgbGluazogZmFsc2UsXG4gICAgICAgICAgICBibG9ja3F1b3RlOiBmYWxzZSxcbiAgICAgICAgICAgIGZhOiB0cnVlLFxuICAgICAgICAgICAgbGlzdHM6IHRydWUsXG4gICAgICAgICAgICBzdHlsZXNoZWV0czogW1wiaHR0cHM6Ly9pbWFnZXMuY2RuLnVuaXF1ZXdheS5jb20vd3lzaXd5Zy1jb2xvci5jc3NcIl0sXG4gICAgICAgICAgICBldmVudHM6IHt9LFxuICAgICAgICAgICAgc3VwcG9ydFRvdWNoRGV2aWNlczogdHJ1ZSxcbiAgICAgICAgICAgIHBhcnNlclJ1bGVzOiB7XG4gICAgICAgICAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgICAgICAgICAnd3lzaXd5Zy1jb2xvci1jbGVhcic6IDEsXG4gICAgICAgICAgICAgICAgJ3d5c2l3eWctY29sb3ItZmlyc3QnOiAxLFxuICAgICAgICAgICAgICAgICd3eXNpd3lnLWNvbG9yLXNlY29uZCc6IDEsXG4gICAgICAgICAgICAgICAgJ3d5c2l3eWctY29sb3ItdGhyZWUnOiAxXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRhZ3M6IHtcbiAgICAgICAgICAgICAgICBzdHJvbmc6IHt9LFxuICAgICAgICAgICAgICAgIGI6ICAgICAge30sXG4gICAgICAgICAgICAgICAgaTogICAgICB7fSxcbiAgICAgICAgICAgICAgICBicjogICAgIHt9LFxuICAgICAgICAgICAgICAgIGVtOiAgICAge30sXG4gICAgICAgICAgICAgICAgcDogICAgICB7fSxcbiAgICAgICAgICAgICAgICBzcGFuOiAgIHt9LFxuICAgICAgICAgICAgICAgIHVsOiAgICAge30sXG4gICAgICAgICAgICAgICAgb2w6ICAgICB7fSxcbiAgICAgICAgICAgICAgICBsaTogICAgIHt9LFxuICAgICAgICAgICAgICAgIGRpdjogIFwic3BhblwiLFxuICAgICAgICAgICAgICAgIGgxOiAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgaDI6ICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICBoMzogIFwic3BhblwiLFxuICAgICAgICAgICAgICAgIGg0OiAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgaDU6ICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICBhOiAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgIGltZzoge1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlOiAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9jYWxlOiAnZW4nXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRPcHRpb24uZW1wdHl0ZXh0ID0gdGhpcy5lbXB0eXRleHRcbiAgICAgICAgbGV0IG9wdGlvbiA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbiwge2FqYXhPcHRpb25zOiB0aGlzLmFqYXhPcHRpb25zfSwgdGhpcy5vcHRpb24pXG4gICAgICAgIG9wdGlvbi52YWx1ZSA9IHRoaXMudmFsdWVcbiAgICAgICAgZWwuZGF0YSgnc2F2YWJsZScsIGZhbHNlKVxuICAgICAgICBlbC5lZGl0YWJsZShvcHRpb24pLm9uKCdzaG93bicsIGZ1bmN0aW9uKGUsZWRpdGJsZSkge1xuICAgICAgICAgIHNlbGYuc2hvd24oKTtcbiAgICAgICAgICBlbC5kYXRhKCdzYXZhYmxlJywgZmFsc2UpXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgZWwuZGF0YSgnc2F2YWJsZScsIHRydWUpXG4gICAgICAgICAgfSwgNTAwKVxuICAgICAgICB9KS5vbignaGlkZGVuJywgZnVuY3Rpb24oZSwgcmVhc29uKSB7XG4gICAgICAgICAgc2VsZi5oaWRkZW4oKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBlbC5kYXRhKCdzYXZhYmxlJywgZmFsc2UpXG4gICAgICAgICAgfSwgMTAwKVxuICAgICAgICB9KS5vbignc2F2ZScsIGZ1bmN0aW9uKGUsIHBhcmFtcykge1xuICAgICAgICAgIGlmICghZWwuZGF0YSgnc2F2YWJsZScpKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGVsLmVkaXRhYmxlKCdzZXRWYWx1ZScsIHNlbGYudmFsdWUpO1xuICAgICAgICAgICAgfSwgMTAwKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJhbXMubmV3VmFsdWUgPT0gc2VsZi52YWx1ZSkgcmV0dXJuXG4gICAgICAgICAgc2VsZi5oYW5kbGVDaGFuZ2UocGFyYW1zLm5ld1ZhbHVlKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFuZ2UodmFsdWUpIHtcblxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgc2VsZi4kZW1pdCgnaW5wdXQnLCBzZWxmLnZhbHVlKTtcbiAgICAgICAgc2VsZi4kZW1pdCgnY2hhbmdlJywgc2VsZi52YWx1ZSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAkKHNlbGYuJGVsKS5lZGl0YWJsZSgnc2V0VmFsdWUnLCBzZWxmLnZhbHVlKVxuICAgICAgICB9LCAxMDEpXG4gICAgICB9XG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBFZGl0YWJsZS52dWU/NTQ0MzU4OTgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editable_js_wysihtml5_0_3_0_js__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editable_js_wysihtml5_0_3_0_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__editable_js_wysihtml5_0_3_0_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__editable_js_bootstrap_wysihtml5_0_0_2_js__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__editable_js_bootstrap_wysihtml5_0_0_2_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__editable_js_bootstrap_wysihtml5_0_0_2_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__editable_js_wysihtml5_js__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__editable_js_wysihtml5_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__editable_js_wysihtml5_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__editable_css_bootstrap_wysihtml5_0_0_2_css__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__editable_css_bootstrap_wysihtml5_0_0_2_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__editable_css_bootstrap_wysihtml5_0_0_2_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Editable_vue__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Editable_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__Editable_vue__);\n\n\n\n\n\n\n\n\nVue.component('editable', __WEBPACK_IMPORTED_MODULE_4__Editable_vue___default.a);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbIlZ1ZSIsImNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUFBLElBQUlDLFNBQUosQ0FBYyxVQUFkLEVBQTBCLHFEQUExQiIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuL2VkaXRhYmxlL2pzL3d5c2lodG1sNS0wLjMuMC5qcydcbmltcG9ydCAnLi9lZGl0YWJsZS9qcy9ib290c3RyYXAtd3lzaWh0bWw1LTAuMC4yLmpzJ1xuaW1wb3J0ICcuL2VkaXRhYmxlL2pzL3d5c2lodG1sNS5qcydcblxuaW1wb3J0ICcuL2VkaXRhYmxlL2Nzcy9ib290c3RyYXAtd3lzaWh0bWw1LTAuMC4yLmNzcydcblxuaW1wb3J0IEVkaXRhYmxlIGZyb20gJy4vRWRpdGFibGUudnVlJ1xuXG5WdWUuY29tcG9uZW50KCdlZGl0YWJsZScsIEVkaXRhYmxlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYWluLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(8)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, \"ul.wysihtml5-toolbar {\\n\\tmargin: 0;\\n\\tpadding: 0;\\n\\tdisplay: block;\\n}\\n\\nul.wysihtml5-toolbar::after {\\n\\tclear: both;\\n\\tdisplay: table;\\n\\tcontent: \\\"\\\";\\n}\\n\\nul.wysihtml5-toolbar > li {\\n\\tfloat: left;\\n\\tdisplay: list-item;\\n\\tlist-style: none;\\n\\tmargin: 0 5px 10px 0;\\n}\\n\\nul.wysihtml5-toolbar a[data-wysihtml5-command=bold] {\\n\\tfont-weight: bold;\\n}\\n\\nul.wysihtml5-toolbar a[data-wysihtml5-command=italic] {\\n\\tfont-style: italic;\\n}\\n\\nul.wysihtml5-toolbar a[data-wysihtml5-command=underline] {\\n\\ttext-decoration: underline;\\n}\\n\\nul.wysihtml5-toolbar a.btn.wysihtml5-command-active {\\n\\tbackground-image: none;\\n\\t-webkit-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15),0 1px 2px rgba(0, 0, 0, 0.05);\\n\\t-moz-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15),0 1px 2px rgba(0, 0, 0, 0.05);\\n\\tbox-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15),0 1px 2px rgba(0, 0, 0, 0.05);\\n\\tbackground-color: #E6E6E6;\\n\\tbackground-color: #D9D9D9;\\n\\toutline: 0;\\n}\\n\\nul.wysihtml5-commands-disabled .dropdown-menu {\\n\\tdisplay: none !important;\\n}\\n\\nul.wysihtml5-toolbar div.wysihtml5-colors {\\n  display:block;\\n  width: 50px;\\n  height: 20px;\\n  margin-top: 2px;\\n  margin-left: 5px;\\n  position: absolute;\\n  pointer-events: none;\\n}\\n\\nul.wysihtml5-toolbar a.wysihtml5-colors-title {\\n  padding-left: 70px;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"black\\\"] {\\n  background: black !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"silver\\\"] {\\n  background: silver !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"gray\\\"] {\\n  background: gray !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"maroon\\\"] {\\n  background: maroon !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"red\\\"] {\\n  background: red !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"purple\\\"] {\\n  background: purple !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"green\\\"] {\\n  background: green !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"olive\\\"] {\\n  background: olive !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"navy\\\"] {\\n  background: navy !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"blue\\\"] {\\n  background: blue !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"orange\\\"] {\\n  background: orange !important;\\n}\\n\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC13eXNpaHRtbDUtMC4wLjIuY3NzPzVkZDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSwrQ0FBZ0QsY0FBYyxlQUFlLG1CQUFtQixHQUFHLGlDQUFpQyxnQkFBZ0IsbUJBQW1CLGtCQUFrQixHQUFHLCtCQUErQixnQkFBZ0IsdUJBQXVCLHFCQUFxQix5QkFBeUIsR0FBRyx5REFBeUQsc0JBQXNCLEdBQUcsMkRBQTJELHVCQUF1QixHQUFHLDhEQUE4RCwrQkFBK0IsR0FBRyx5REFBeUQsMkJBQTJCLDBGQUEwRix1RkFBdUYsa0ZBQWtGLDhCQUE4Qiw4QkFBOEIsZUFBZSxHQUFHLG1EQUFtRCw2QkFBNkIsR0FBRywrQ0FBK0Msa0JBQWtCLGdCQUFnQixpQkFBaUIsb0JBQW9CLHFCQUFxQix1QkFBdUIseUJBQXlCLEdBQUcsbURBQW1ELHVCQUF1QixHQUFHLHNFQUFzRSxpQ0FBaUMsR0FBRyx1RUFBdUUsa0NBQWtDLEdBQUcscUVBQXFFLGdDQUFnQyxHQUFHLHVFQUF1RSxrQ0FBa0MsR0FBRyxvRUFBb0UsK0JBQStCLEdBQUcsdUVBQXVFLGtDQUFrQyxHQUFHLHNFQUFzRSxpQ0FBaUMsR0FBRyxzRUFBc0UsaUNBQWlDLEdBQUcscUVBQXFFLGdDQUFnQyxHQUFHLHFFQUFxRSxnQ0FBZ0MsR0FBRyx1RUFBdUUsa0NBQWtDLEdBQUc7O0FBRXo4RSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwidWwud3lzaWh0bWw1LXRvb2xiYXIge1xcblxcdG1hcmdpbjogMDtcXG5cXHRwYWRkaW5nOiAwO1xcblxcdGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhcjo6YWZ0ZXIge1xcblxcdGNsZWFyOiBib3RoO1xcblxcdGRpc3BsYXk6IHRhYmxlO1xcblxcdGNvbnRlbnQ6IFxcXCJcXFwiO1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciA+IGxpIHtcXG5cXHRmbG9hdDogbGVmdDtcXG5cXHRkaXNwbGF5OiBsaXN0LWl0ZW07XFxuXFx0bGlzdC1zdHlsZTogbm9uZTtcXG5cXHRtYXJnaW46IDAgNXB4IDEwcHggMDtcXG59XFxuXFxudWwud3lzaWh0bWw1LXRvb2xiYXIgYVtkYXRhLXd5c2lodG1sNS1jb21tYW5kPWJvbGRdIHtcXG5cXHRmb250LXdlaWdodDogYm9sZDtcXG59XFxuXFxudWwud3lzaWh0bWw1LXRvb2xiYXIgYVtkYXRhLXd5c2lodG1sNS1jb21tYW5kPWl0YWxpY10ge1xcblxcdGZvbnQtc3R5bGU6IGl0YWxpYztcXG59XFxuXFxudWwud3lzaWh0bWw1LXRvb2xiYXIgYVtkYXRhLXd5c2lodG1sNS1jb21tYW5kPXVuZGVybGluZV0ge1xcblxcdHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBhLmJ0bi53eXNpaHRtbDUtY29tbWFuZC1hY3RpdmUge1xcblxcdGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7XFxuXFx0LXdlYmtpdC1ib3gtc2hhZG93OiBpbnNldCAwIDJweCA0cHggcmdiYSgwLCAwLCAwLCAwLjE1KSwwIDFweCAycHggcmdiYSgwLCAwLCAwLCAwLjA1KTtcXG5cXHQtbW96LWJveC1zaGFkb3c6IGluc2V0IDAgMnB4IDRweCByZ2JhKDAsIDAsIDAsIDAuMTUpLDAgMXB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMDUpO1xcblxcdGJveC1zaGFkb3c6IGluc2V0IDAgMnB4IDRweCByZ2JhKDAsIDAsIDAsIDAuMTUpLDAgMXB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMDUpO1xcblxcdGJhY2tncm91bmQtY29sb3I6ICNFNkU2RTY7XFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI0Q5RDlEOTtcXG5cXHRvdXRsaW5lOiAwO1xcbn1cXG5cXG51bC53eXNpaHRtbDUtY29tbWFuZHMtZGlzYWJsZWQgLmRyb3Bkb3duLW1lbnUge1xcblxcdGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuXFxudWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2Lnd5c2lodG1sNS1jb2xvcnMge1xcbiAgZGlzcGxheTpibG9jaztcXG4gIHdpZHRoOiA1MHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgbWFyZ2luLXRvcDogMnB4O1xcbiAgbWFyZ2luLWxlZnQ6IDVweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBhLnd5c2lodG1sNS1jb2xvcnMtdGl0bGUge1xcbiAgcGFkZGluZy1sZWZ0OiA3MHB4O1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwiYmxhY2tcXFwiXSB7XFxuICBiYWNrZ3JvdW5kOiBibGFjayAhaW1wb3J0YW50O1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwic2lsdmVyXFxcIl0ge1xcbiAgYmFja2dyb3VuZDogc2lsdmVyICFpbXBvcnRhbnQ7XFxufVxcblxcbnVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJncmF5XFxcIl0ge1xcbiAgYmFja2dyb3VuZDogZ3JheSAhaW1wb3J0YW50O1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwibWFyb29uXFxcIl0ge1xcbiAgYmFja2dyb3VuZDogbWFyb29uICFpbXBvcnRhbnQ7XFxufVxcblxcbnVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJyZWRcXFwiXSB7XFxuICBiYWNrZ3JvdW5kOiByZWQgIWltcG9ydGFudDtcXG59XFxuXFxudWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcInB1cnBsZVxcXCJdIHtcXG4gIGJhY2tncm91bmQ6IHB1cnBsZSAhaW1wb3J0YW50O1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwiZ3JlZW5cXFwiXSB7XFxuICBiYWNrZ3JvdW5kOiBncmVlbiAhaW1wb3J0YW50O1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwib2xpdmVcXFwiXSB7XFxuICBiYWNrZ3JvdW5kOiBvbGl2ZSAhaW1wb3J0YW50O1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwibmF2eVxcXCJdIHtcXG4gIGJhY2tncm91bmQ6IG5hdnkgIWltcG9ydGFudDtcXG59XFxuXFxudWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcImJsdWVcXFwiXSB7XFxuICBiYWNrZ3JvdW5kOiBibHVlICFpbXBvcnRhbnQ7XFxufVxcblxcbnVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJvcmFuZ2VcXFwiXSB7XFxuICBiYWNrZ3JvdW5kOiBvcmFuZ2UgIWltcG9ydGFudDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC13eXNpaHRtbDUtMC4wLjIuY3NzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzP2RhMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYzs7QUFFbEU7QUFDQSIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t}\n\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(10);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzP2I3ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0EsbUJBQW1CLDJCQUEyQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTs7QUFFQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdG1lbW9bc2VsZWN0b3JdID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9saWIvdXJscy5qcz85YzMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxFQUFFO0FBQ3JELHdDQUF3QyxXQUFXLEVBQUU7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDO0FBQ3RDLEdBQUc7QUFDSDtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

eval("/* globals __VUE_SSR_CONTEXT__ */\n\n// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzP2Q0ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gdGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICB2YXIgZnVuY3Rpb25hbCA9IG9wdGlvbnMuZnVuY3Rpb25hbFxuICAgIHZhciBleGlzdGluZyA9IGZ1bmN0aW9uYWxcbiAgICAgID8gb3B0aW9ucy5yZW5kZXJcbiAgICAgIDogb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICBpZiAoIWZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBleGlzdGluZyhoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('a', {\n    attrs: {\n      \"href\": \"javascript:;\",\n      \"data-type\": _vm.type,\n      \"disabled\": _vm.disabled,\n      \"emptytext\": _vm.emptytext\n    },\n    domProps: {\n      \"innerHTML\": _vm._s(_vm.display_value())\n    }\n  })\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-409b4816\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRWRpdGFibGUudnVlP2ZiNzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdhJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImhyZWZcIjogXCJqYXZhc2NyaXB0OjtcIixcbiAgICAgIFwiZGF0YS10eXBlXCI6IF92bS50eXBlLFxuICAgICAgXCJkaXNhYmxlZFwiOiBfdm0uZGlzYWJsZWQsXG4gICAgICBcImVtcHR5dGV4dFwiOiBfdm0uZW1wdHl0ZXh0XG4gICAgfSxcbiAgICBkb21Qcm9wczoge1xuICAgICAgXCJpbm5lckhUTUxcIjogX3ZtLl9zKF92bS5kaXNwbGF5X3ZhbHVlKCkpXG4gICAgfVxuICB9KVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi00MDliNDgxNlwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTQwOWI0ODE2XCIsXCJoYXNTY29wZWRcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9FZGl0YWJsZS52dWVcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ })
/******/ ]);