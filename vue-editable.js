!function(t){function Q(B){if(F[B])return F[B].exports;var n=F[B]={i:B,l:!1,exports:{}};return t[B].call(n.exports,n,n.exports,Q),n.l=!0,n.exports}var F={};Q.m=t,Q.c=F,Q.i=function(t){return t},Q.d=function(t,F,B){Q.o(t,F)||Object.defineProperty(t,F,{configurable:!1,enumerable:!0,get:B})},Q.n=function(t){var F=t&&t.__esModule?function(){return t.default}:function(){return t};return Q.d(F,"a",F),F},Q.o=function(t,Q){return Object.prototype.hasOwnProperty.call(t,Q)},Q.p="/dist/",Q(Q.s=7)}([function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn "@media " + item[2] + "{" + content + "}";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join("");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === "string")\n\t\t\tmodules = [[null, modules, ""]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === "number")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || \'\';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === \'function\') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn \'/*# sourceURL=\' + cssMapping.sourceRoot + source + \' */\'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n\t}\n\n\treturn [content].join(\'\\n\');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = \'sourceMappingURL=data:application/json;charset=utf-8;base64,\' + base64;\n\n\treturn \'/*# \' + data + \' */\';\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzP2RhMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYzs7QUFFbEU7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === "undefined") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === "undefined") {\n\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t}\n\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(17);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== "undefined" && DEBUG) {\n\t\tif (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === "object" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = "head";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = "bottom";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error("Couldn\'t find a style target. This probably means that the value for the \'insertInto\' parameter is invalid.");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === "top") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === "bottom") {\n\t\ttarget.appendChild(style);\n\t} else {\n\t\tthrow new Error("Invalid value for parameter \'insertAt\'. Must be \'top\' or \'bottom\'.");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement("style");\n\n\toptions.attrs.type = "text/css";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement("link");\n\n\toptions.attrs.type = "text/css";\n\toptions.attrs.rel = "stylesheet";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don\'t add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === "function" &&\n\t\ttypeof URL.createObjectURL === "function" &&\n\t\ttypeof URL.revokeObjectURL === "function" &&\n\t\ttypeof Blob === "function" &&\n\t\ttypeof btoa === "function"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join(\'\\n\');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? "" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute("media", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn\'t defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\n\t}\n\n\tvar blob = new Blob([css], { type: "text/css" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzP2I3ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0EsbUJBQW1CLDJCQUEyQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTs7QUFFQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdG1lbW9bc2VsZWN0b3JdID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},function(module,exports,__webpack_require__){eval("var Component = __webpack_require__(18)(\n  /* script */\n  __webpack_require__(3),\n  /* template */\n  __webpack_require__(19),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRWRpdGFibGUudnVlP2EwZjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBb0g7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0VkaXRhYmxlLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNDA5YjQ4MTZcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vRWRpdGFibGUudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgbnVsbCxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9FZGl0YWJsZS52dWVcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editable_css_bootstrap_min_css__ = __webpack_require__(16);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editable_css_bootstrap_min_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__editable_css_bootstrap_min_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__editable_css_bootstrap_editable_css__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__editable_css_bootstrap_editable_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__editable_css_bootstrap_editable_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__editable_css_bootstrap_wysihtml5_css__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__editable_css_bootstrap_wysihtml5_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__editable_css_bootstrap_wysihtml5_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__editable_js_bootstrap_min_js__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__editable_js_bootstrap_min_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__editable_js_bootstrap_min_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__editable_js_bootstrap_editable_js__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__editable_js_bootstrap_editable_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__editable_js_bootstrap_editable_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__editable_js_wysihtml5_js__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__editable_js_wysihtml5_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__editable_js_wysihtml5_js__);\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n$.fn.editable.defaults.mode = 'inline';\n$.fn.editable.defaults.onblur = 'submit';\n$.fn.editable.defaults.showbuttons = false;\n$.fn.editable.defaults.clear = false;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  props: {\n    type: {\n      type: String,\n      default: 'text'\n    },\n    value: {\n      type: String,\n      default: ''\n    },\n    ajaxOptions: {\n      type: Object,\n      default: function _default() {\n        return {\n          type: 'put',\n          dataType: 'json'\n        };\n      }\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    emptytext: {\n      type: String,\n      default: '无'\n    },\n    placeholder: {\n      type: String,\n      default: ''\n    },\n    display: {\n      type: Boolean,\n      default: true\n    },\n    shown: {\n      type: Function,\n      default: function _default() {}\n    },\n    hidden: {\n      type: Function,\n      default: function _default() {}\n    },\n    option: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    }\n  },\n  watch: {\n    'display': function display(value) {\n      var input_el = $(this.$el);\n      var action = value ? 'show' : 'hide';\n      input_el.editable(action);\n    }\n  },\n  data: function data() {},\n  created: function created() {},\n  mounted: function mounted() {\n    var self = this;\n    var el = $(this.$el);\n    if (el.data('editable')) {\n      el.editable().destroy();\n    }\n    var option = Object.assign(this.ajaxOptions, this.option);\n    el.editable(option).on('shown', function (e, editble) {\n      self.shown();\n    }).on('hidden', function (e, reason) {\n      self.hidden();\n    }).on('save', function (e, params) {\n      if (params.newValue == self.value) return;\n      self.handleChange(params.newValue);\n    });\n  },\n\n  methods: {\n    handleChange: function handleChange(value) {\n      this.value = value;\n      this.$emit('change', this.value);\n      this.$emit('input', this.value);\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vRWRpdGFibGUudnVlPzI5NzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7WUFJQTtlQUVBO0FBSEE7O1lBS0E7ZUFFQTtBQUhBOztZQUtBO21DQUNBOztnQkFFQTtvQkFFQTtBQUhBO0FBS0E7QUFSQTs7WUFVQTtlQUVBO0FBSEE7O1lBS0E7ZUFFQTtBQUhBOztZQUtBO2VBRUE7QUFIQTs7WUFLQTtlQUVBO0FBSEE7O1lBS0E7b0NBRUE7QUFIQTs7WUFLQTtvQ0FFQTtBQUhBOztZQUtBOzs7QUFHQTtBQUpBO0FBMUNBOzt1Q0FnREE7NEJBQ0E7b0NBQ0E7d0JBQ0E7QUFFQTtBQU5BO3dCQVFBLENBQ0E7OEJBQ0EsQ0FDQTs4QkFDQTtlQUNBO29CQUNBOzZCQUNBO29CQUNBO0FBQ0E7c0RBQ0E7MERBQ0E7V0FDQTt5Q0FDQTtXQUNBO3VDQUNBO3lDQUNBOytCQUNBO0FBQ0E7QUFDQTs7OytDQUVBO21CQUNBO2dDQUNBOytCQUNBO0FBRUE7QUFOQTtBQTVFQSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8YSBocmVmPVwiamF2YXNjcmlwdDo7XCJcbiAgICAgOmRhdGEtdHlwZT1cInR5cGVcIlxuICAgICA6ZGlzYWJsZWQ9J2Rpc2FibGVkJ1xuICAgICA6ZW1wdHl0ZXh0PSdlbXB0eXRleHQnPnt7dmFsdWV9fTwvYT5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuICBpbXBvcnQgJy4vZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC5taW4uY3NzJ1xuICBpbXBvcnQgJy4vZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC1lZGl0YWJsZS5jc3MnXG4gIGltcG9ydCAnLi9lZGl0YWJsZS9jc3MvYm9vdHN0cmFwLXd5c2lodG1sNS5jc3MnXG5cbiAgaW1wb3J0ICcuL2VkaXRhYmxlL2pzL2Jvb3RzdHJhcC5taW4uanMnXG4gIGltcG9ydCAnLi9lZGl0YWJsZS9qcy9ib290c3RyYXAtZWRpdGFibGUuanMnXG4gIGltcG9ydCAnLi9lZGl0YWJsZS9qcy93eXNpaHRtbDUuanMnXG5cbiAgJC5mbi5lZGl0YWJsZS5kZWZhdWx0cy5tb2RlID0gJ2lubGluZSc7XG4gICQuZm4uZWRpdGFibGUuZGVmYXVsdHMub25ibHVyID0gJ3N1Ym1pdCc7XG4gICQuZm4uZWRpdGFibGUuZGVmYXVsdHMuc2hvd2J1dHRvbnMgPSBmYWxzZTtcbiAgJC5mbi5lZGl0YWJsZS5kZWZhdWx0cy5jbGVhciA9IGZhbHNlO1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczp7XG4gICAgICB0eXBlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3RleHQnXG4gICAgICB9LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSxcbiAgICAgIGFqYXhPcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdwdXQnLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZW1wdHl0ZXh0OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ+aXoCdcbiAgICAgIH0sXG4gICAgICBwbGFjZWhvbGRlcjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9LFxuICAgICAgZGlzcGxheToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9LFxuICAgICAgc2hvd246IHtcbiAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge31cbiAgICAgIH0sXG4gICAgICBoaWRkZW46IHtcbiAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge31cbiAgICAgIH0sXG4gICAgICBvcHRpb246IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHsgfSB9XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgJ2Rpc3BsYXknOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgbGV0IGlucHV0X2VsID0gJCh0aGlzLiRlbClcbiAgICAgICAgbGV0IGFjdGlvbiA9IHZhbHVlID8gJ3Nob3cnIDogJ2hpZGUnXG4gICAgICAgIGlucHV0X2VsLmVkaXRhYmxlKGFjdGlvbilcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGEoKSB7XG5cbiAgICB9LFxuICAgIGNyZWF0ZWQoKSB7XG4gICAgfSxcbiAgICBtb3VudGVkKCl7XG4gICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICBsZXQgZWwgPSAkKHRoaXMuJGVsKVxuICAgICAgaWYgKGVsLmRhdGEoJ2VkaXRhYmxlJykpIHtcbiAgICAgICAgZWwuZWRpdGFibGUoKS5kZXN0cm95KClcbiAgICAgIH1cbiAgICAgIGxldCBvcHRpb24gPSBPYmplY3QuYXNzaWduKHRoaXMuYWpheE9wdGlvbnMsIHRoaXMub3B0aW9uKVxuICAgICAgZWwuZWRpdGFibGUob3B0aW9uKS5vbignc2hvd24nLCBmdW5jdGlvbihlLGVkaXRibGUpe1xuICAgICAgICBzZWxmLnNob3duKCk7XG4gICAgICB9KS5vbignaGlkZGVuJywgZnVuY3Rpb24oZSwgcmVhc29uKXtcbiAgICAgICAgc2VsZi5oaWRkZW4oKTtcbiAgICAgIH0pLm9uKCdzYXZlJywgZnVuY3Rpb24oZSwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMubmV3VmFsdWUgPT0gc2VsZi52YWx1ZSkgcmV0dXJuXG4gICAgICAgIHNlbGYuaGFuZGxlQ2hhbmdlKHBhcmFtcy5uZXdWYWx1ZSlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgaGFuZGxlQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdGhpcy52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBFZGl0YWJsZS52dWU/MjZhNWZiYTgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")},function(module,exports){eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! X-editable - v1.5.1 \n* In-place editing with Twitter Bootstrap, jQuery UI or pure jQuery\n* http://github.com/vitalets/x-editable\n* Copyright (c) 2013 Vitaliy Potapov; Licensed MIT */\n/**\nForm with single input element, two buttons and two states: normal/loading.\nApplied as jQuery method to DIV tag (not to form tag!). This is because form can be in loading state when spinner shown.\nEditableform is linked with one of input types, e.g. 'text', 'select' etc.\n\n@class editableform\n@uses text\n@uses textarea\n**/\n(function ($) {\n\n    var EditableForm = function EditableForm(div, options) {\n        this.options = $.extend({}, $.fn.editableform.defaults, options);\n        this.$div = $(div); //div, containing form. Not form tag. Not editable-element.\n        if (!this.options.scope) {\n            this.options.scope = this;\n        }\n        //nothing shown after init\n    };\n\n    EditableForm.prototype = {\n        constructor: EditableForm,\n        initInput: function initInput() {\n            //called once\n            //take input from options (as it is created in editable-element)\n            this.input = this.options.input;\n\n            //set initial value\n            //todo: may be add check: typeof str === 'string' ? \n            this.value = this.input.str2value(this.options.value);\n\n            //prerender: get input.$input\n            this.input.prerender();\n        },\n        initTemplate: function initTemplate() {\n            this.$form = $($.fn.editableform.template);\n        },\n        initButtons: function initButtons() {\n            var $btn = this.$form.find('.editable-buttons');\n            $btn.append($.fn.editableform.buttons);\n            if (this.options.showbuttons === 'bottom') {\n                $btn.addClass('editable-buttons-bottom');\n            }\n        },\n        /**\n        Renders editableform\n         @method render\n        **/\n        render: function render() {\n            //init loader\n            this.$loading = $($.fn.editableform.loading);\n            this.$div.empty().append(this.$loading);\n\n            //init form template and buttons\n            this.initTemplate();\n            if (this.options.showbuttons) {\n                this.initButtons();\n            } else {\n                this.$form.find('.editable-buttons').remove();\n            }\n\n            //show loading state\n            this.showLoading();\n\n            //flag showing is form now saving value to server. \n            //It is needed to wait when closing form.\n            this.isSaving = false;\n\n            /**        \n            Fired when rendering starts\n            @event rendering \n            @param {Object} event event object\n            **/\n            this.$div.triggerHandler('rendering');\n\n            //init input\n            this.initInput();\n\n            //append input to form\n            this.$form.find('div.editable-input').append(this.input.$tpl);\n\n            //append form to container\n            this.$div.append(this.$form);\n\n            //render input\n            $.when(this.input.render()).then($.proxy(function () {\n                //setup input to submit automatically when no buttons shown\n                if (!this.options.showbuttons) {\n                    this.input.autosubmit();\n                }\n\n                //attach 'cancel' handler\n                this.$form.find('.editable-cancel').click($.proxy(this.cancel, this));\n\n                if (this.input.error) {\n                    this.error(this.input.error);\n                    this.$form.find('.editable-submit').attr('disabled', true);\n                    this.input.$input.attr('disabled', true);\n                    //prevent form from submitting\n                    this.$form.submit(function (e) {\n                        e.preventDefault();\n                    });\n                } else {\n                    this.error(false);\n                    this.input.$input.removeAttr('disabled');\n                    this.$form.find('.editable-submit').removeAttr('disabled');\n                    var value = this.value === null || this.value === undefined || this.value === '' ? this.options.defaultValue : this.value;\n                    this.input.value2input(value);\n                    //attach submit handler\n                    this.$form.submit($.proxy(this.submit, this));\n                }\n\n                /**        \n                Fired when form is rendered\n                @event rendered\n                @param {Object} event event object\n                **/\n                this.$div.triggerHandler('rendered');\n\n                this.showForm();\n\n                //call postrender method to perform actions required visibility of form\n                if (this.input.postrender) {\n                    this.input.postrender();\n                }\n            }, this));\n        },\n        cancel: function cancel() {\n            /**        \n            Fired when form was cancelled by user\n            @event cancel \n            @param {Object} event event object\n            **/\n            this.$div.triggerHandler('cancel');\n        },\n        showLoading: function showLoading() {\n            var w, h;\n            if (this.$form) {\n                //set loading size equal to form\n                w = this.$form.outerWidth();\n                h = this.$form.outerHeight();\n                if (w) {\n                    this.$loading.width(w);\n                }\n                if (h) {\n                    this.$loading.height(h);\n                }\n                this.$form.hide();\n            } else {\n                //stretch loading to fill container width\n                w = this.$loading.parent().width();\n                if (w) {\n                    this.$loading.width(w);\n                }\n            }\n            this.$loading.show();\n        },\n\n        showForm: function showForm(activate) {\n            this.$loading.hide();\n            this.$form.show();\n            if (activate !== false) {\n                this.input.activate();\n            }\n            /**        \n            Fired when form is shown\n            @event show \n            @param {Object} event event object\n            **/\n            this.$div.triggerHandler('show');\n        },\n\n        error: function error(msg) {\n            var $group = this.$form.find('.control-group'),\n                $block = this.$form.find('.editable-error-block'),\n                lines;\n\n            if (msg === false) {\n                $group.removeClass($.fn.editableform.errorGroupClass);\n                $block.removeClass($.fn.editableform.errorBlockClass).empty().hide();\n            } else {\n                //convert newline to <br> for more pretty error display\n                if (msg) {\n                    lines = ('' + msg).split('\\n');\n                    for (var i = 0; i < lines.length; i++) {\n                        lines[i] = $('<div>').text(lines[i]).html();\n                    }\n                    msg = lines.join('<br>');\n                }\n                $group.addClass($.fn.editableform.errorGroupClass);\n                $block.addClass($.fn.editableform.errorBlockClass).html(msg).show();\n            }\n        },\n\n        submit: function submit(e) {\n            e.stopPropagation();\n            e.preventDefault();\n\n            //get new value from input\n            var newValue = this.input.input2value();\n\n            //validation: if validate returns string or truthy value - means error\n            //if returns object like {newValue: '...'} => submitted value is reassigned to it\n            var error = this.validate(newValue);\n            if ($.type(error) === 'object' && error.newValue !== undefined) {\n                newValue = error.newValue;\n                this.input.value2input(newValue);\n                if (typeof error.msg === 'string') {\n                    this.error(error.msg);\n                    this.showForm();\n                    return;\n                }\n            } else if (error) {\n                this.error(error);\n                this.showForm();\n                return;\n            }\n\n            //if value not changed --\x3e trigger 'nochange' event and return\n            /*jslint eqeq: true*/\n            if (!this.options.savenochange && this.input.value2str(newValue) == this.input.value2str(this.value)) {\n                /*jslint eqeq: false*/\n                /**        \n                Fired when value not changed but form is submitted. Requires savenochange = false.\n                @event nochange \n                @param {Object} event event object\n                **/\n                this.$div.triggerHandler('nochange');\n                return;\n            }\n\n            //convert value for submitting to server\n            var submitValue = this.input.value2submit(newValue);\n\n            this.isSaving = true;\n\n            //sending data to server\n            $.when(this.save(submitValue)).done($.proxy(function (response) {\n                this.isSaving = false;\n\n                //run success callback\n                var res = typeof this.options.success === 'function' ? this.options.success.call(this.options.scope, response, newValue) : null;\n\n                //if success callback returns false --\x3e keep form open and do not activate input\n                if (res === false) {\n                    this.error(false);\n                    this.showForm(false);\n                    return;\n                }\n\n                //if success callback returns string --\x3e  keep form open, show error and activate input               \n                if (typeof res === 'string') {\n                    this.error(res);\n                    this.showForm();\n                    return;\n                }\n\n                //if success callback returns object like {newValue: <something>} --\x3e use that value instead of submitted\n                //it is usefull if you want to chnage value in url-function\n                if (res && (typeof res === 'undefined' ? 'undefined' : _typeof(res)) === 'object' && res.hasOwnProperty('newValue')) {\n                    newValue = res.newValue;\n                }\n\n                //clear error message\n                this.error(false);\n                this.value = newValue;\n                /**        \n                Fired when form is submitted\n                @event save \n                @param {Object} event event object\n                @param {Object} params additional params\n                @param {mixed} params.newValue raw new value\n                @param {mixed} params.submitValue submitted value as string\n                @param {Object} params.response ajax response\n                 @example\n                $('#form-div').on('save'), function(e, params){\n                    if(params.newValue === 'username') {...}\n                });\n                **/\n                this.$div.triggerHandler('save', { newValue: newValue, submitValue: submitValue, response: response });\n            }, this)).fail($.proxy(function (xhr) {\n                this.isSaving = false;\n\n                var msg;\n                if (typeof this.options.error === 'function') {\n                    msg = this.options.error.call(this.options.scope, xhr, newValue);\n                } else {\n                    msg = typeof xhr === 'string' ? xhr : xhr.responseText || xhr.statusText || 'Unknown error!';\n                }\n\n                this.error(msg);\n                this.showForm();\n            }, this));\n        },\n\n        save: function save(submitValue) {\n            //try parse composite pk defined as json string in data-pk \n            this.options.pk = $.fn.editableutils.tryParseJson(this.options.pk, true);\n\n            var pk = typeof this.options.pk === 'function' ? this.options.pk.call(this.options.scope) : this.options.pk,\n\n            /*\n              send on server in following cases:\n              1. url is function\n              2. url is string AND (pk defined OR send option = always) \n            */\n            send = !!(typeof this.options.url === 'function' || this.options.url && (this.options.send === 'always' || this.options.send === 'auto' && pk !== null && pk !== undefined)),\n                params;\n\n            if (send) {\n                //send to server\n                this.showLoading();\n\n                //standard params\n                params = {\n                    name: this.options.name || '',\n                    value: submitValue,\n                    pk: pk\n                };\n\n                //additional params\n                if (typeof this.options.params === 'function') {\n                    params = this.options.params.call(this.options.scope, params);\n                } else {\n                    //try parse json in single quotes (from data-params attribute)\n                    this.options.params = $.fn.editableutils.tryParseJson(this.options.params, true);\n                    $.extend(params, this.options.params);\n                }\n\n                if (typeof this.options.url === 'function') {\n                    //user's function\n                    return this.options.url.call(this.options.scope, params);\n                } else {\n                    //send ajax to server and return deferred object\n                    return $.ajax($.extend({\n                        url: this.options.url,\n                        data: params,\n                        type: 'POST'\n                    }, this.options.ajaxOptions));\n                }\n            }\n        },\n\n        validate: function validate(value) {\n            if (value === undefined) {\n                value = this.value;\n            }\n            if (typeof this.options.validate === 'function') {\n                return this.options.validate.call(this.options.scope, value);\n            }\n        },\n\n        option: function option(key, value) {\n            if (key in this.options) {\n                this.options[key] = value;\n            }\n\n            if (key === 'value') {\n                this.setValue(value);\n            }\n\n            //do not pass option to input as it is passed in editable-element\n        },\n\n        setValue: function setValue(value, convertStr) {\n            if (convertStr) {\n                this.value = this.input.str2value(value);\n            } else {\n                this.value = value;\n            }\n\n            //if form is visible, update input\n            if (this.$form && this.$form.is(':visible')) {\n                this.input.value2input(this.value);\n            }\n        }\n    };\n\n    /*\n    Initialize editableform. Applied to jQuery object.\n     @method $().editableform(options)\n    @params {Object} options\n    @example\n    var $form = $('&lt;div&gt;').editableform({\n        type: 'text',\n        name: 'username',\n        url: '/post',\n        value: 'vitaliy'\n    });\n     //to display form you should call 'render' method\n    $form.editableform('render');     \n    */\n    $.fn.editableform = function (option) {\n        var args = arguments;\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data('editableform'),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) === 'object' && option;\n            if (!data) {\n                $this.data('editableform', data = new EditableForm(this, options));\n            }\n\n            if (typeof option === 'string') {\n                //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            }\n        });\n    };\n\n    //keep link to constructor to allow inheritance\n    $.fn.editableform.Constructor = EditableForm;\n\n    //defaults\n    $.fn.editableform.defaults = {\n        /* see also defaults for input */\n\n        /**\n        Type of input. Can be <code>text|textarea|select|date|checklist</code>\n         @property type \n        @type string\n        @default 'text'\n        **/\n        type: 'text',\n        /**\n        Url for submit, e.g. <code>'/post'</code>  \n        If function - it will be called instead of ajax. Function should return deferred object to run fail/done callbacks.\n         @property url \n        @type string|function\n        @default null\n        @example\n        url: function(params) {\n            var d = new $.Deferred;\n            if(params.value === 'abc') {\n                return d.reject('error message'); //returning error via deferred object\n            } else {\n                //async saving data in js model\n                someModel.asyncSaveMethod({\n                   ..., \n                   success: function(){\n                      d.resolve();\n                   }\n                }); \n                return d.promise();\n            }\n        } \n        **/\n        url: null,\n        /**\n        Additional params for submit. If defined as <code>object</code> - it is **appended** to original ajax data (pk, name and value).  \n        If defined as <code>function</code> - returned object **overwrites** original ajax data.\n        @example\n        params: function(params) {\n            //originally params contain pk, name and value\n            params.a = 1;\n            return params;\n        }\n         @property params \n        @type object|function\n        @default null\n        **/\n        params: null,\n        /**\n        Name of field. Will be submitted on server. Can be taken from <code>id</code> attribute\n         @property name \n        @type string\n        @default null\n        **/\n        name: null,\n        /**\n        Primary key of editable object (e.g. record id in database). For composite keys use object, e.g. <code>{id: 1, lang: 'en'}</code>.\n        Can be calculated dynamically via function.\n         @property pk \n        @type string|object|function\n        @default null\n        **/\n        pk: null,\n        /**\n        Initial value. If not defined - will be taken from element's content.\n        For __select__ type should be defined (as it is ID of shown text).\n         @property value \n        @type string|object\n        @default null\n        **/\n        value: null,\n        /**\n        Value that will be displayed in input if original field value is empty (`null|undefined|''`).\n         @property defaultValue \n        @type string|object\n        @default null\n        @since 1.4.6\n        **/\n        defaultValue: null,\n        /**\n        Strategy for sending data on server. Can be `auto|always|never`.\n        When 'auto' data will be sent on server **only if pk and url defined**, otherwise new value will be stored locally.\n         @property send \n        @type string\n        @default 'auto'\n        **/\n        send: 'auto',\n        /**\n        Function for client-side validation. If returns string - means validation not passed and string showed as error.\n        Since 1.5.1 you can modify submitted value by returning object from `validate`: \n        `{newValue: '...'}` or `{newValue: '...', msg: '...'}`\n         @property validate \n        @type function\n        @default null\n        @example\n        validate: function(value) {\n            if($.trim(value) == '') {\n                return 'This field is required';\n            }\n        }\n        **/\n        validate: null,\n        /**\n        Success callback. Called when value successfully sent on server and **response status = 200**.  \n        Usefull to work with json response. For example, if your backend response can be <code>{success: true}</code>\n        or <code>{success: false, msg: \"server error\"}</code> you can check it inside this callback.  \n        If it returns **string** - means error occured and string is shown as error message.  \n        If it returns **object like** <code>{newValue: &lt;something&gt;}</code> - it overwrites value, submitted by user.  \n        Otherwise newValue simply rendered into element.\n        \n        @property success \n        @type function\n        @default null\n        @example\n        success: function(response, newValue) {\n            if(!response.success) return response.msg;\n        }\n        **/\n        success: null,\n        /**\n        Error callback. Called when request failed (response status != 200).  \n        Usefull when you want to parse error response and display a custom message.\n        Must return **string** - the message to be displayed in the error block.\n                \n        @property error \n        @type function\n        @default null\n        @since 1.4.4\n        @example\n        error: function(response, newValue) {\n            if(response.status === 500) {\n                return 'Service unavailable. Please try later.';\n            } else {\n                return response.responseText;\n            }\n        }\n        **/\n        error: null,\n        /**\n        Additional options for submit ajax request.\n        List of values: http://api.jquery.com/jQuery.ajax\n        \n        @property ajaxOptions \n        @type object\n        @default null\n        @since 1.1.1        \n        @example \n        ajaxOptions: {\n            type: 'put',\n            dataType: 'json'\n        }        \n        **/\n        ajaxOptions: null,\n        /**\n        Where to show buttons: left(true)|bottom|false  \n        Form without buttons is auto-submitted.\n         @property showbuttons \n        @type boolean|string\n        @default true\n        @since 1.1.1\n        **/\n        showbuttons: true,\n        /**\n        Scope for callback methods (success, validate).  \n        If <code>null</code> means editableform instance itself. \n         @property scope \n        @type DOMElement|object\n        @default null\n        @since 1.2.0\n        @private\n        **/\n        scope: null,\n        /**\n        Whether to save or cancel value when it was not changed but form was submitted\n         @property savenochange \n        @type boolean\n        @default false\n        @since 1.2.0\n        **/\n        savenochange: false\n    };\n\n    /*\n    Note: following params could redefined in engine: bootstrap or jqueryui:\n    Classes 'control-group' and 'editable-error-block' must always present!\n    */\n    $.fn.editableform.template = '<form class=\"form-inline editableform\">' + '<div class=\"control-group\">' + '<div><div class=\"editable-input\"></div><div class=\"editable-buttons\"></div></div>' + '<div class=\"editable-error-block\"></div>' + '</div>' + '</form>';\n\n    //loading div\n    $.fn.editableform.loading = '<div class=\"editableform-loading\"></div>';\n\n    //buttons\n    $.fn.editableform.buttons = '<button type=\"submit\" class=\"editable-submit\">ok</button>' + '<button type=\"button\" class=\"editable-cancel\">cancel</button>';\n\n    //error class attached to control-group\n    $.fn.editableform.errorGroupClass = null;\n\n    //error class attached to editable-error-block\n    $.fn.editableform.errorBlockClass = 'editable-error';\n\n    //engine\n    $.fn.editableform.engine = 'jquery';\n})(window.jQuery);\n\n/**\n* EditableForm utilites\n*/\n(function ($) {\n\n    //utils\n    $.fn.editableutils = {\n        /**\n        * classic JS inheritance function\n        */\n        inherit: function inherit(Child, Parent) {\n            var F = function F() {};\n            F.prototype = Parent.prototype;\n            Child.prototype = new F();\n            Child.prototype.constructor = Child;\n            Child.superclass = Parent.prototype;\n        },\n\n        /**\n        * set caret position in input\n        * see http://stackoverflow.com/questions/499126/jquery-set-cursor-position-in-text-area\n        */\n        setCursorPosition: function setCursorPosition(elem, pos) {\n            if (elem.setSelectionRange) {\n                elem.setSelectionRange(pos, pos);\n            } else if (elem.createTextRange) {\n                var range = elem.createTextRange();\n                range.collapse(true);\n                range.moveEnd('character', pos);\n                range.moveStart('character', pos);\n                range.select();\n            }\n        },\n\n        /**\n        * function to parse JSON in *single* quotes. (jquery automatically parse only double quotes)\n        * That allows such code as: <a data-source=\"{'a': 'b', 'c': 'd'}\">\n        * safe = true --\x3e means no exception will be thrown\n        * for details see http://stackoverflow.com/questions/7410348/how-to-set-json-format-to-html5-data-attributes-in-the-jquery\n        */\n        tryParseJson: function tryParseJson(s, safe) {\n            if (typeof s === 'string' && s.length && s.match(/^[\\{\\[].*[\\}\\]]$/)) {\n                if (safe) {\n                    try {\n                        /*jslint evil: true*/\n                        s = new Function('return ' + s)();\n                        /*jslint evil: false*/\n                    } catch (e) {} finally {\n                        return s;\n                    }\n                } else {\n                    /*jslint evil: true*/\n                    s = new Function('return ' + s)();\n                    /*jslint evil: false*/\n                }\n            }\n            return s;\n        },\n\n        /**\n        * slice object by specified keys\n        */\n        sliceObj: function sliceObj(obj, keys, caseSensitive /* default: false */) {\n            var key,\n                keyLower,\n                newObj = {};\n\n            if (!$.isArray(keys) || !keys.length) {\n                return newObj;\n            }\n\n            for (var i = 0; i < keys.length; i++) {\n                key = keys[i];\n                if (obj.hasOwnProperty(key)) {\n                    newObj[key] = obj[key];\n                }\n\n                if (caseSensitive === true) {\n                    continue;\n                }\n\n                //when getting data-* attributes via $.data() it's converted to lowercase.\n                //details: http://stackoverflow.com/questions/7602565/using-data-attributes-with-jquery\n                //workaround is code below.\n                keyLower = key.toLowerCase();\n                if (obj.hasOwnProperty(keyLower)) {\n                    newObj[key] = obj[keyLower];\n                }\n            }\n\n            return newObj;\n        },\n\n        /*\n        exclude complex objects from $.data() before pass to config\n        */\n        getConfigData: function getConfigData($element) {\n            var data = {};\n            $.each($element.data(), function (k, v) {\n                if ((typeof v === 'undefined' ? 'undefined' : _typeof(v)) !== 'object' || v && (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' && (v.constructor === Object || v.constructor === Array)) {\n                    data[k] = v;\n                }\n            });\n            return data;\n        },\n\n        /*\n         returns keys of object\n        */\n        objectKeys: function objectKeys(o) {\n            if (Object.keys) {\n                return Object.keys(o);\n            } else {\n                if (o !== Object(o)) {\n                    throw new TypeError('Object.keys called on a non-object');\n                }\n                var k = [],\n                    p;\n                for (p in o) {\n                    if (Object.prototype.hasOwnProperty.call(o, p)) {\n                        k.push(p);\n                    }\n                }\n                return k;\n            }\n        },\n\n        /**\n         method to escape html.\n        **/\n        escape: function escape(str) {\n            return $('<div>').text(str).html();\n        },\n\n        /*\n         returns array items from sourceData having value property equal or inArray of 'value'\n        */\n        itemsByValue: function itemsByValue(value, sourceData, valueProp) {\n            if (!sourceData || value === null) {\n                return [];\n            }\n\n            if (typeof valueProp !== \"function\") {\n                var idKey = valueProp || 'value';\n                valueProp = function valueProp(e) {\n                    return e[idKey];\n                };\n            }\n\n            var isValArray = $.isArray(value),\n                result = [],\n                that = this;\n\n            $.each(sourceData, function (i, o) {\n                if (o.children) {\n                    result = result.concat(that.itemsByValue(value, o.children, valueProp));\n                } else {\n                    /*jslint eqeq: true*/\n                    if (isValArray) {\n                        if ($.grep(value, function (v) {\n                            return v == (o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' ? valueProp(o) : o);\n                        }).length) {\n                            result.push(o);\n                        }\n                    } else {\n                        var itemValue = o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' ? valueProp(o) : o;\n                        if (value == itemValue) {\n                            result.push(o);\n                        }\n                    }\n                    /*jslint eqeq: false*/\n                }\n            });\n\n            return result;\n        },\n\n        /*\n        Returns input by options: type, mode. \n        */\n        createInput: function createInput(options) {\n            var TypeConstructor,\n                typeOptions,\n                input,\n                type = options.type;\n\n            //`date` is some kind of virtual type that is transformed to one of exact types\n            //depending on mode and core lib\n            if (type === 'date') {\n                //inline\n                if (options.mode === 'inline') {\n                    if ($.fn.editabletypes.datefield) {\n                        type = 'datefield';\n                    } else if ($.fn.editabletypes.dateuifield) {\n                        type = 'dateuifield';\n                    }\n                    //popup\n                } else {\n                    if ($.fn.editabletypes.date) {\n                        type = 'date';\n                    } else if ($.fn.editabletypes.dateui) {\n                        type = 'dateui';\n                    }\n                }\n\n                //if type still `date` and not exist in types, replace with `combodate` that is base input\n                if (type === 'date' && !$.fn.editabletypes.date) {\n                    type = 'combodate';\n                }\n            }\n\n            //`datetime` should be datetimefield in 'inline' mode\n            if (type === 'datetime' && options.mode === 'inline') {\n                type = 'datetimefield';\n            }\n\n            //change wysihtml5 to textarea for jquery UI and plain versions\n            if (type === 'wysihtml5' && !$.fn.editabletypes[type]) {\n                type = 'textarea';\n            }\n\n            //create input of specified type. Input will be used for converting value, not in form\n            if (typeof $.fn.editabletypes[type] === 'function') {\n                TypeConstructor = $.fn.editabletypes[type];\n                typeOptions = this.sliceObj(options, this.objectKeys(TypeConstructor.defaults));\n                input = new TypeConstructor(typeOptions);\n                return input;\n            } else {\n                $.error('Unknown type: ' + type);\n                return false;\n            }\n        },\n\n        //see http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr\n        supportsTransitions: function supportsTransitions() {\n            var b = document.body || document.documentElement,\n                s = b.style,\n                p = 'transition',\n                v = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];\n\n            if (typeof s[p] === 'string') {\n                return true;\n            }\n\n            // Tests for vendor specific prop\n            p = p.charAt(0).toUpperCase() + p.substr(1);\n            for (var i = 0; i < v.length; i++) {\n                if (typeof s[v[i] + p] === 'string') {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    };\n})(window.jQuery);\n\n/**\nAttaches stand-alone container with editable-form to HTML element. Element is used only for positioning, value is not stored anywhere.<br>\nThis method applied internally in <code>$().editable()</code>. You should subscribe on it's events (save / cancel) to get profit of it.<br>\nFinal realization can be different: bootstrap-popover, jqueryui-tooltip, poshytip, inline-div. It depends on which js file you include.<br>\nApplied as jQuery method.\n\n@class editableContainer\n@uses editableform\n**/\n(function ($) {\n\n    var Popup = function Popup(element, options) {\n        this.init(element, options);\n    };\n\n    var Inline = function Inline(element, options) {\n        this.init(element, options);\n    };\n\n    //methods\n    Popup.prototype = {\n        containerName: null, //method to call container on element\n        containerDataName: null, //object name in element's .data()\n        innerCss: null, //tbd in child class\n        containerClass: 'editable-container editable-popup', //css class applied to container element\n        defaults: {}, //container itself defaults\n\n        init: function init(element, options) {\n            this.$element = $(element);\n            //since 1.4.1 container do not use data-* directly as they already merged into options.\n            this.options = $.extend({}, $.fn.editableContainer.defaults, options);\n            this.splitOptions();\n\n            //set scope of form callbacks to element\n            this.formOptions.scope = this.$element[0];\n\n            this.initContainer();\n\n            //flag to hide container, when saving value will finish\n            this.delayedHide = false;\n\n            //bind 'destroyed' listener to destroy container when element is removed from dom\n            this.$element.on('destroyed', $.proxy(function () {\n                this.destroy();\n            }, this));\n\n            //attach document handler to close containers on click / escape\n            if (!$(document).data('editable-handlers-attached')) {\n                //close all on escape\n                $(document).on('keyup.editable', function (e) {\n                    if (e.which === 27) {\n                        $('.editable-open').editableContainer('hide');\n                        //todo: return focus on element \n                    }\n                });\n\n                //close containers when click outside \n                //(mousedown could be better than click, it closes everything also on drag drop)\n                $(document).on('click.editable', function (e) {\n                    var $target = $(e.target),\n                        i,\n                        exclude_classes = ['.editable-container', '.ui-datepicker-header', '.datepicker', //in inline mode datepicker is rendered into body\n                    '.modal-backdrop', '.bootstrap-wysihtml5-insert-image-modal', '.bootstrap-wysihtml5-insert-link-modal'];\n\n                    //check if element is detached. It occurs when clicking in bootstrap datepicker\n                    if (!$.contains(document.documentElement, e.target)) {\n                        return;\n                    }\n\n                    //for some reason FF 20 generates extra event (click) in select2 widget with e.target = document\n                    //we need to filter it via construction below. See https://github.com/vitalets/x-editable/issues/199\n                    //Possibly related to http://stackoverflow.com/questions/10119793/why-does-firefox-react-differently-from-webkit-and-ie-to-click-event-on-selec\n                    if ($target.is(document)) {\n                        return;\n                    }\n\n                    //if click inside one of exclude classes --\x3e no nothing\n                    for (i = 0; i < exclude_classes.length; i++) {\n                        if ($target.is(exclude_classes[i]) || $target.parents(exclude_classes[i]).length) {\n                            return;\n                        }\n                    }\n\n                    //close all open containers (except one - target)\n                    Popup.prototype.closeOthers(e.target);\n                });\n\n                $(document).data('editable-handlers-attached', true);\n            }\n        },\n\n        //split options on containerOptions and formOptions\n        splitOptions: function splitOptions() {\n            this.containerOptions = {};\n            this.formOptions = {};\n\n            if (!$.fn[this.containerName]) {\n                throw new Error(this.containerName + ' not found. Have you included corresponding js file?');\n            }\n\n            //keys defined in container defaults go to container, others go to form\n            for (var k in this.options) {\n                if (k in this.defaults) {\n                    this.containerOptions[k] = this.options[k];\n                } else {\n                    this.formOptions[k] = this.options[k];\n                }\n            }\n        },\n\n        /*\n        Returns jquery object of container\n        @method tip()\n        */\n        tip: function tip() {\n            return this.container() ? this.container().$tip : null;\n        },\n\n        /* returns container object */\n        container: function container() {\n            var container;\n            //first, try get it by `containerDataName`\n            if (this.containerDataName) {\n                if (container = this.$element.data(this.containerDataName)) {\n                    return container;\n                }\n            }\n            //second, try `containerName`\n            container = this.$element.data(this.containerName);\n            return container;\n        },\n\n        /* call native method of underlying container, e.g. this.$element.popover('method') */\n        call: function call() {\n            this.$element[this.containerName].apply(this.$element, arguments);\n        },\n\n        initContainer: function initContainer() {\n            this.call(this.containerOptions);\n        },\n\n        renderForm: function renderForm() {\n            this.$form.editableform(this.formOptions).on({\n                save: $.proxy(this.save, this), //click on submit button (value changed)\n                nochange: $.proxy(function () {\n                    this.hide('nochange');\n                }, this), //click on submit button (value NOT changed)                \n                cancel: $.proxy(function () {\n                    this.hide('cancel');\n                }, this), //click on calcel button\n                show: $.proxy(function () {\n                    if (this.delayedHide) {\n                        this.hide(this.delayedHide.reason);\n                        this.delayedHide = false;\n                    } else {\n                        this.setPosition();\n                    }\n                }, this), //re-position container every time form is shown (occurs each time after loading state)\n                rendering: $.proxy(this.setPosition, this), //this allows to place container correctly when loading shown\n                resize: $.proxy(this.setPosition, this), //this allows to re-position container when form size is changed \n                rendered: $.proxy(function () {\n                    /**        \n                    Fired when container is shown and form is rendered (for select will wait for loading dropdown options).  \n                    **Note:** Bootstrap popover has own `shown` event that now cannot be separated from x-editable's one.\n                    The workaround is to check `arguments.length` that is always `2` for x-editable.                     \n                    \n                    @event shown \n                    @param {Object} event event object\n                    @example\n                    $('#username').on('shown', function(e, editable) {\n                        editable.input.$input.val('overwriting value of input..');\n                    });                     \n                    **/\n                    /*\n                     TODO: added second param mainly to distinguish from bootstrap's shown event. It's a hotfix that will be solved in future versions via namespaced events.  \n                    */\n                    this.$element.triggerHandler('shown', $(this.options.scope).data('editable'));\n                }, this)\n            }).editableform('render');\n        },\n\n        /**\n        Shows container with form\n        @method show()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/\n        /* Note: poshytip owerwrites this method totally! */\n        show: function show(closeAll) {\n            this.$element.addClass('editable-open');\n            if (closeAll !== false) {\n                //close all open containers (except this)\n                this.closeOthers(this.$element[0]);\n            }\n\n            //show container itself\n            this.innerShow();\n            this.tip().addClass(this.containerClass);\n\n            /*\n            Currently, form is re-rendered on every show. \n            The main reason is that we dont know, what will container do with content when closed:\n            remove(), detach() or just hide() - it depends on container.\n            \n            Detaching form itself before hide and re-insert before show is good solution, \n            but visually it looks ugly --\x3e container changes size before hide.  \n            */\n\n            //if form already exist - delete previous data \n            if (this.$form) {\n                //todo: destroy prev data!\n                //this.$form.destroy();\n            }\n\n            this.$form = $('<div>');\n\n            //insert form into container body\n            if (this.tip().is(this.innerCss)) {\n                //for inline container\n                this.tip().append(this.$form);\n            } else {\n                this.tip().find(this.innerCss).append(this.$form);\n            }\n\n            //render form\n            this.renderForm();\n        },\n\n        /**\n        Hides container with form\n        @method hide()\n        @param {string} reason Reason caused hiding. Can be <code>save|cancel|onblur|nochange|undefined (=manual)</code>\n        **/\n        hide: function hide(reason) {\n            if (!this.tip() || !this.tip().is(':visible') || !this.$element.hasClass('editable-open')) {\n                return;\n            }\n\n            //if form is saving value, schedule hide\n            if (this.$form.data('editableform').isSaving) {\n                this.delayedHide = { reason: reason };\n                return;\n            } else {\n                this.delayedHide = false;\n            }\n\n            this.$element.removeClass('editable-open');\n            this.innerHide();\n\n            /**\n            Fired when container was hidden. It occurs on both save or cancel.  \n            **Note:** Bootstrap popover has own `hidden` event that now cannot be separated from x-editable's one.\n            The workaround is to check `arguments.length` that is always `2` for x-editable. \n             @event hidden \n            @param {object} event event object\n            @param {string} reason Reason caused hiding. Can be <code>save|cancel|onblur|nochange|manual</code>\n            @example\n            $('#username').on('hidden', function(e, reason) {\n                if(reason === 'save' || reason === 'cancel') {\n                    //auto-open next editable\n                    $(this).closest('tr').next().find('.editable').editable('show');\n                } \n            });\n            **/\n            this.$element.triggerHandler('hidden', reason || 'manual');\n        },\n\n        /* internal show method. To be overwritten in child classes */\n        innerShow: function innerShow() {},\n\n        /* internal hide method. To be overwritten in child classes */\n        innerHide: function innerHide() {},\n\n        /**\n        Toggles container visibility (show / hide)\n        @method toggle()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/\n        toggle: function toggle(closeAll) {\n            if (this.container() && this.tip() && this.tip().is(':visible')) {\n                this.hide();\n            } else {\n                this.show(closeAll);\n            }\n        },\n\n        /*\n        Updates the position of container when content changed.\n        @method setPosition()\n        */\n        setPosition: function setPosition() {\n            //tbd in child class\n        },\n\n        save: function save(e, params) {\n            /**        \n            Fired when new value was submitted. You can use <code>$(this).data('editableContainer')</code> inside handler to access to editableContainer instance\n            \n            @event save \n            @param {Object} event event object\n            @param {Object} params additional params\n            @param {mixed} params.newValue submitted value\n            @param {Object} params.response ajax response\n            @example\n            $('#username').on('save', function(e, params) {\n                //assuming server response: '{success: true}'\n                var pk = $(this).data('editableContainer').options.pk;\n                if(params.response && params.response.success) {\n                    alert('value: ' + params.newValue + ' with pk: ' + pk + ' saved!');\n                } else {\n                    alert('error!'); \n                } \n            });\n            **/\n            this.$element.triggerHandler('save', params);\n\n            //hide must be after trigger, as saving value may require methods of plugin, applied to input\n            this.hide('save');\n        },\n\n        /**\n        Sets new option\n        \n        @method option(key, value)\n        @param {string} key \n        @param {mixed} value \n        **/\n        option: function option(key, value) {\n            this.options[key] = value;\n            if (key in this.containerOptions) {\n                this.containerOptions[key] = value;\n                this.setContainerOption(key, value);\n            } else {\n                this.formOptions[key] = value;\n                if (this.$form) {\n                    this.$form.editableform('option', key, value);\n                }\n            }\n        },\n\n        setContainerOption: function setContainerOption(key, value) {\n            this.call('option', key, value);\n        },\n\n        /**\n        Destroys the container instance\n        @method destroy()\n        **/\n        destroy: function destroy() {\n            this.hide();\n            this.innerDestroy();\n            this.$element.off('destroyed');\n            this.$element.removeData('editableContainer');\n        },\n\n        /* to be overwritten in child classes */\n        innerDestroy: function innerDestroy() {},\n\n        /*\n        Closes other containers except one related to passed element. \n        Other containers can be cancelled or submitted (depends on onblur option)\n        */\n        closeOthers: function closeOthers(element) {\n            $('.editable-open').each(function (i, el) {\n                //do nothing with passed element and it's children\n                if (el === element || $(el).find(element).length) {\n                    return;\n                }\n\n                //otherwise cancel or submit all open containers \n                var $el = $(el),\n                    ec = $el.data('editableContainer');\n\n                if (!ec) {\n                    return;\n                }\n\n                if (ec.options.onblur === 'cancel') {\n                    $el.data('editableContainer').hide('onblur');\n                } else if (ec.options.onblur === 'submit') {\n                    $el.data('editableContainer').tip().find('form').submit();\n                }\n            });\n        },\n\n        /**\n        Activates input of visible container (e.g. set focus)\n        @method activate()\n        **/\n        activate: function activate() {\n            if (this.tip && this.tip().is(':visible') && this.$form) {\n                this.$form.data('editableform').input.activate();\n            }\n        }\n\n    };\n\n    /**\n    jQuery method to initialize editableContainer.\n    \n    @method $().editableContainer(options)\n    @params {Object} options\n    @example\n    $('#edit').editableContainer({\n        type: 'text',\n        url: '/post',\n        pk: 1,\n        value: 'hello'\n    });\n    **/\n    $.fn.editableContainer = function (option) {\n        var args = arguments;\n        return this.each(function () {\n            var $this = $(this),\n                dataKey = 'editableContainer',\n                data = $this.data(dataKey),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) === 'object' && option,\n                Constructor = options.mode === 'inline' ? Inline : Popup;\n\n            if (!data) {\n                $this.data(dataKey, data = new Constructor(this, options));\n            }\n\n            if (typeof option === 'string') {\n                //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            }\n        });\n    };\n\n    //store constructors\n    $.fn.editableContainer.Popup = Popup;\n    $.fn.editableContainer.Inline = Inline;\n\n    //defaults\n    $.fn.editableContainer.defaults = {\n        /**\n        Initial value of form input\n         @property value \n        @type mixed\n        @default null\n        @private\n        **/\n        value: null,\n        /**\n        Placement of container relative to element. Can be <code>top|right|bottom|left</code>. Not used for inline container.\n         @property placement \n        @type string\n        @default 'top'\n        **/\n        placement: 'top',\n        /**\n        Whether to hide container on save/cancel.\n         @property autohide \n        @type boolean\n        @default true\n        @private \n        **/\n        autohide: true,\n        /**\n        Action when user clicks outside the container. Can be <code>cancel|submit|ignore</code>.  \n        Setting <code>ignore</code> allows to have several containers open. \n         @property onblur \n        @type string\n        @default 'cancel'\n        @since 1.1.1\n        **/\n        onblur: 'cancel',\n\n        /**\n        Animation speed (inline mode only)\n        @property anim \n        @type string\n        @default false\n        **/\n        anim: false,\n\n        /**\n        Mode of editable, can be `popup` or `inline` \n        \n        @property mode \n        @type string         \n        @default 'popup'\n        @since 1.4.0        \n        **/\n        mode: 'popup'\n    };\n\n    /* \n    * workaround to have 'destroyed' event to destroy popover when element is destroyed\n    * see http://stackoverflow.com/questions/2200494/jquery-trigger-event-when-an-element-is-removed-from-the-dom\n    */\n    jQuery.event.special.destroyed = {\n        remove: function remove(o) {\n            if (o.handler) {\n                o.handler();\n            }\n        }\n    };\n})(window.jQuery);\n\n/**\n* Editable Inline \n* ---------------------\n*/\n(function ($) {\n\n    //copy prototype from EditableContainer\n    //extend methods\n    $.extend($.fn.editableContainer.Inline.prototype, $.fn.editableContainer.Popup.prototype, {\n        containerName: 'editableform',\n        innerCss: '.editable-inline',\n        containerClass: 'editable-container editable-inline', //css class applied to container element\n\n        initContainer: function initContainer() {\n            //container is <span> element\n            this.$tip = $('<span></span>');\n\n            //convert anim to miliseconds (int)\n            if (!this.options.anim) {\n                this.options.anim = 0;\n            }\n        },\n\n        splitOptions: function splitOptions() {\n            //all options are passed to form\n            this.containerOptions = {};\n            this.formOptions = this.options;\n        },\n\n        tip: function tip() {\n            return this.$tip;\n        },\n\n        innerShow: function innerShow() {\n            this.$element.hide();\n            this.tip().insertAfter(this.$element).show();\n        },\n\n        innerHide: function innerHide() {\n            this.$tip.hide(this.options.anim, $.proxy(function () {\n                this.$element.show();\n                this.innerDestroy();\n            }, this));\n        },\n\n        innerDestroy: function innerDestroy() {\n            if (this.tip()) {\n                this.tip().empty().remove();\n            }\n        }\n    });\n})(window.jQuery);\n/**\nMakes editable any HTML element on the page. Applied as jQuery method.\n\n@class editable\n@uses editableContainer\n**/\n(function ($) {\n\n    var Editable = function Editable(element, options) {\n        this.$element = $(element);\n        //data-* has more priority over js options: because dynamically created elements may change data-* \n        this.options = $.extend({}, $.fn.editable.defaults, options, $.fn.editableutils.getConfigData(this.$element));\n        if (this.options.selector) {\n            this.initLive();\n        } else {\n            this.init();\n        }\n\n        //check for transition support\n        if (this.options.highlight && !$.fn.editableutils.supportsTransitions()) {\n            this.options.highlight = false;\n        }\n    };\n\n    Editable.prototype = {\n        constructor: Editable,\n        init: function init() {\n            var isValueByText = false,\n                doAutotext,\n                finalize;\n\n            //name\n            this.options.name = this.options.name || this.$element.attr('id');\n\n            //create input of specified type. Input needed already here to convert value for initial display (e.g. show text by id for select)\n            //also we set scope option to have access to element inside input specific callbacks (e. g. source as function)\n            this.options.scope = this.$element[0];\n            this.input = $.fn.editableutils.createInput(this.options);\n            if (!this.input) {\n                return;\n            }\n\n            //set value from settings or by element's text\n            if (this.options.value === undefined || this.options.value === null) {\n                this.value = this.input.html2value($.trim(this.$element.html()));\n                isValueByText = true;\n            } else {\n                /*\n                  value can be string when received from 'data-value' attribute\n                  for complext objects value can be set as json string in data-value attribute, \n                  e.g. data-value=\"{city: 'Moscow', street: 'Lenina'}\"\n                */\n                this.options.value = $.fn.editableutils.tryParseJson(this.options.value, true);\n                if (typeof this.options.value === 'string') {\n                    this.value = this.input.str2value(this.options.value);\n                } else {\n                    this.value = this.options.value;\n                }\n            }\n\n            //add 'editable' class to every editable element\n            this.$element.addClass('editable');\n\n            //specifically for \"textarea\" add class .editable-pre-wrapped to keep linebreaks\n            if (this.input.type === 'textarea') {\n                this.$element.addClass('editable-pre-wrapped');\n            }\n\n            //attach handler activating editable. In disabled mode it just prevent default action (useful for links)\n            if (this.options.toggle !== 'manual') {\n                this.$element.addClass('editable-click');\n                this.$element.on(this.options.toggle + '.editable', $.proxy(function (e) {\n                    //prevent following link if editable enabled\n                    if (!this.options.disabled) {\n                        e.preventDefault();\n                    }\n\n                    //stop propagation not required because in document click handler it checks event target\n                    //e.stopPropagation();\n\n                    if (this.options.toggle === 'mouseenter') {\n                        //for hover only show container\n                        this.show();\n                    } else {\n                        //when toggle='click' we should not close all other containers as they will be closed automatically in document click listener\n                        var closeAll = this.options.toggle !== 'click';\n                        this.toggle(closeAll);\n                    }\n                }, this));\n            } else {\n                this.$element.attr('tabindex', -1); //do not stop focus on element when toggled manually\n            }\n\n            //if display is function it's far more convinient to have autotext = always to render correctly on init\n            //see https://github.com/vitalets/x-editable-yii/issues/34\n            if (typeof this.options.display === 'function') {\n                this.options.autotext = 'always';\n            }\n\n            //check conditions for autotext:\n            switch (this.options.autotext) {\n                case 'always':\n                    doAutotext = true;\n                    break;\n                case 'auto':\n                    //if element text is empty and value is defined and value not generated by text --\x3e run autotext\n                    doAutotext = !$.trim(this.$element.text()).length && this.value !== null && this.value !== undefined && !isValueByText;\n                    break;\n                default:\n                    doAutotext = false;\n            }\n\n            //depending on autotext run render() or just finilize init\n            $.when(doAutotext ? this.render() : true).then($.proxy(function () {\n                if (this.options.disabled) {\n                    this.disable();\n                } else {\n                    this.enable();\n                }\n                /**        \n                Fired when element was initialized by `$().editable()` method. \n                Please note that you should setup `init` handler **before** applying `editable`. \n                               \n                @event init \n                @param {Object} event event object\n                @param {Object} editable editable instance (as here it cannot accessed via data('editable'))\n                @since 1.2.0\n                @example\n                $('#username').on('init', function(e, editable) {\n                    alert('initialized ' + editable.options.name);\n                });\n                $('#username').editable();\n                **/\n                this.$element.triggerHandler('init', this);\n            }, this));\n        },\n\n        /*\n         Initializes parent element for live editables \n        */\n        initLive: function initLive() {\n            //store selector \n            var selector = this.options.selector;\n            //modify options for child elements\n            this.options.selector = false;\n            this.options.autotext = 'never';\n            //listen toggle events\n            this.$element.on(this.options.toggle + '.editable', selector, $.proxy(function (e) {\n                var $target = $(e.target);\n                if (!$target.data('editable')) {\n                    //if delegated element initially empty, we need to clear it's text (that was manually set to `empty` by user)\n                    //see https://github.com/vitalets/x-editable/issues/137 \n                    if ($target.hasClass(this.options.emptyclass)) {\n                        $target.empty();\n                    }\n                    $target.editable(this.options).trigger(e);\n                }\n            }, this));\n        },\n\n        /*\n        Renders value into element's text.\n        Can call custom display method from options.\n        Can return deferred object.\n        @method render()\n        @param {mixed} response server response (if exist) to pass into display function\n        */\n        render: function render(response) {\n            //do not display anything\n            if (this.options.display === false) {\n                return;\n            }\n\n            //if input has `value2htmlFinal` method, we pass callback in third param to be called when source is loaded\n            if (this.input.value2htmlFinal) {\n                return this.input.value2html(this.value, this.$element[0], this.options.display, response);\n                //if display method defined --\x3e use it    \n            } else if (typeof this.options.display === 'function') {\n                return this.options.display.call(this.$element[0], this.value, response);\n                //else use input's original value2html() method    \n            } else {\n                return this.input.value2html(this.value, this.$element[0]);\n            }\n        },\n\n        /**\n        Enables editable\n        @method enable()\n        **/\n        enable: function enable() {\n            this.options.disabled = false;\n            this.$element.removeClass('editable-disabled');\n            this.handleEmpty(this.isEmpty);\n            if (this.options.toggle !== 'manual') {\n                if (this.$element.attr('tabindex') === '-1') {\n                    this.$element.removeAttr('tabindex');\n                }\n            }\n        },\n\n        /**\n        Disables editable\n        @method disable()\n        **/\n        disable: function disable() {\n            this.options.disabled = true;\n            this.hide();\n            this.$element.addClass('editable-disabled');\n            this.handleEmpty(this.isEmpty);\n            //do not stop focus on this element\n            this.$element.attr('tabindex', -1);\n        },\n\n        /**\n        Toggles enabled / disabled state of editable element\n        @method toggleDisabled()\n        **/\n        toggleDisabled: function toggleDisabled() {\n            if (this.options.disabled) {\n                this.enable();\n            } else {\n                this.disable();\n            }\n        },\n\n        /**\n        Sets new option\n        \n        @method option(key, value)\n        @param {string|object} key option name or object with several options\n        @param {mixed} value option new value\n        @example\n        $('.editable').editable('option', 'pk', 2);\n        **/\n        option: function option(key, value) {\n            //set option(s) by object\n            if (key && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {\n                $.each(key, $.proxy(function (k, v) {\n                    this.option($.trim(k), v);\n                }, this));\n                return;\n            }\n\n            //set option by string             \n            this.options[key] = value;\n\n            //disabled\n            if (key === 'disabled') {\n                return value ? this.disable() : this.enable();\n            }\n\n            //value\n            if (key === 'value') {\n                this.setValue(value);\n            }\n\n            //transfer new option to container! \n            if (this.container) {\n                this.container.option(key, value);\n            }\n\n            //pass option to input directly (as it points to the same in form)\n            if (this.input.option) {\n                this.input.option(key, value);\n            }\n        },\n\n        /*\n        * set emptytext if element is empty\n        */\n        handleEmpty: function handleEmpty(isEmpty) {\n            //do not handle empty if we do not display anything\n            if (this.options.display === false) {\n                return;\n            }\n\n            /* \n            isEmpty may be set directly as param of method.\n            It is required when we enable/disable field and can't rely on content \n            as node content is text: \"Empty\" that is not empty %)\n            */\n            if (isEmpty !== undefined) {\n                this.isEmpty = isEmpty;\n            } else {\n                //detect empty\n                //for some inputs we need more smart check\n                //e.g. wysihtml5 may have <br>, <p></p>, <img>\n                if (typeof this.input.isEmpty === 'function') {\n                    this.isEmpty = this.input.isEmpty(this.$element);\n                } else {\n                    this.isEmpty = $.trim(this.$element.html()) === '';\n                }\n            }\n\n            //emptytext shown only for enabled\n            if (!this.options.disabled) {\n                if (this.isEmpty) {\n                    this.$element.html(this.options.emptytext);\n                    if (this.options.emptyclass) {\n                        this.$element.addClass(this.options.emptyclass);\n                    }\n                } else if (this.options.emptyclass) {\n                    this.$element.removeClass(this.options.emptyclass);\n                }\n            } else {\n                //below required if element disable property was changed\n                if (this.isEmpty) {\n                    this.$element.empty();\n                    if (this.options.emptyclass) {\n                        this.$element.removeClass(this.options.emptyclass);\n                    }\n                }\n            }\n        },\n\n        /**\n        Shows container with form\n        @method show()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/\n        show: function show(closeAll) {\n            if (this.options.disabled) {\n                return;\n            }\n\n            //init editableContainer: popover, tooltip, inline, etc..\n            if (!this.container) {\n                var containerOptions = $.extend({}, this.options, {\n                    value: this.value,\n                    input: this.input //pass input to form (as it is already created)\n                });\n                this.$element.editableContainer(containerOptions);\n                //listen `save` event \n                this.$element.on(\"save.internal\", $.proxy(this.save, this));\n                this.container = this.$element.data('editableContainer');\n            } else if (this.container.tip().is(':visible')) {\n                return;\n            }\n\n            //show container\n            this.container.show(closeAll);\n        },\n\n        /**\n        Hides container with form\n        @method hide()\n        **/\n        hide: function hide() {\n            if (this.container) {\n                this.container.hide();\n            }\n        },\n\n        /**\n        Toggles container visibility (show / hide)\n        @method toggle()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/\n        toggle: function toggle(closeAll) {\n            if (this.container && this.container.tip().is(':visible')) {\n                this.hide();\n            } else {\n                this.show(closeAll);\n            }\n        },\n\n        /*\n        * called when form was submitted\n        */\n        save: function save(e, params) {\n            //mark element with unsaved class if needed\n            if (this.options.unsavedclass) {\n                /*\n                 Add unsaved css to element if:\n                  - url is not user's function \n                  - value was not sent to server\n                  - params.response === undefined, that means data was not sent\n                  - value changed \n                */\n                var sent = false;\n                sent = sent || typeof this.options.url === 'function';\n                sent = sent || this.options.display === false;\n                sent = sent || params.response !== undefined;\n                sent = sent || this.input.value2str(this.value) !== this.input.value2str(params.newValue);\n\n                if (sent) {\n                    this.$element.removeClass(this.options.unsavedclass);\n                } else {\n                    this.$element.addClass(this.options.unsavedclass);\n                }\n            }\n\n            //highlight when saving\n            if (this.options.highlight) {\n                var $e = this.$element,\n                    bgColor = $e.css('background-color');\n\n                $e.css('background-color', this.options.highlight);\n                setTimeout(function () {\n                    if (bgColor === 'transparent') {\n                        bgColor = '';\n                    }\n                    $e.css('background-color', bgColor);\n                    $e.addClass('editable-bg-transition');\n                    setTimeout(function () {\n                        $e.removeClass('editable-bg-transition');\n                    }, 1700);\n                }, 10);\n            }\n\n            //set new value\n            this.setValue(params.newValue, false, params.response);\n\n            /**        \n            Fired when new value was submitted. You can use <code>$(this).data('editable')</code> to access to editable instance\n            \n            @event save \n            @param {Object} event event object\n            @param {Object} params additional params\n            @param {mixed} params.newValue submitted value\n            @param {Object} params.response ajax response\n            @example\n            $('#username').on('save', function(e, params) {\n                alert('Saved value: ' + params.newValue);\n            });\n            **/\n            //event itself is triggered by editableContainer. Description here is only for documentation              \n        },\n\n        validate: function validate() {\n            if (typeof this.options.validate === 'function') {\n                return this.options.validate.call(this, this.value);\n            }\n        },\n\n        /**\n        Sets new value of editable\n        @method setValue(value, convertStr)\n        @param {mixed} value new value \n        @param {boolean} convertStr whether to convert value from string to internal format\n        **/\n        setValue: function setValue(value, convertStr, response) {\n            if (convertStr) {\n                this.value = this.input.str2value(value);\n            } else {\n                this.value = value;\n            }\n            if (this.container) {\n                this.container.option('value', this.value);\n            }\n            $.when(this.render(response)).then($.proxy(function () {\n                this.handleEmpty();\n            }, this));\n        },\n\n        /**\n        Activates input of visible container (e.g. set focus)\n        @method activate()\n        **/\n        activate: function activate() {\n            if (this.container) {\n                this.container.activate();\n            }\n        },\n\n        /**\n        Removes editable feature from element\n        @method destroy()\n        **/\n        destroy: function destroy() {\n            this.disable();\n\n            if (this.container) {\n                this.container.destroy();\n            }\n\n            this.input.destroy();\n\n            if (this.options.toggle !== 'manual') {\n                this.$element.removeClass('editable-click');\n                this.$element.off(this.options.toggle + '.editable');\n            }\n\n            this.$element.off(\"save.internal\");\n\n            this.$element.removeClass('editable editable-open editable-disabled');\n            this.$element.removeData('editable');\n        }\n    };\n\n    /* EDITABLE PLUGIN DEFINITION\n    * ======================= */\n\n    /**\n    jQuery method to initialize editable element.\n    \n    @method $().editable(options)\n    @params {Object} options\n    @example\n    $('#username').editable({\n        type: 'text',\n        url: '/post',\n        pk: 1\n    });\n    **/\n    $.fn.editable = function (option) {\n        //special API methods returning non-jquery object\n        var result = {},\n            args = arguments,\n            datakey = 'editable';\n        switch (option) {\n            /**\n            Runs client-side validation for all matched editables\n            \n            @method validate()\n            @returns {Object} validation errors map\n            @example\n            $('#username, #fullname').editable('validate');\n            // possible result:\n            {\n              username: \"username is required\",\n              fullname: \"fullname should be minimum 3 letters length\"\n            }\n            **/\n            case 'validate':\n                this.each(function () {\n                    var $this = $(this),\n                        data = $this.data(datakey),\n                        error;\n                    if (data && (error = data.validate())) {\n                        result[data.options.name] = error;\n                    }\n                });\n                return result;\n\n            /**\n            Returns current values of editable elements.   \n            Note that it returns an **object** with name-value pairs, not a value itself. It allows to get data from several elements.    \n            If value of some editable is `null` or `undefined` it is excluded from result object.\n            When param `isSingle` is set to **true** - it is supposed you have single element and will return value of editable instead of object.   \n             \n            @method getValue()\n            @param {bool} isSingle whether to return just value of single element\n            @returns {Object} object of element names and values\n            @example\n            $('#username, #fullname').editable('getValue');\n            //result:\n            {\n            username: \"superuser\",\n            fullname: \"John\"\n            }\n            //isSingle = true\n            $('#username').editable('getValue', true);\n            //result \"superuser\" \n            **/\n            case 'getValue':\n                if (arguments.length === 2 && arguments[1] === true) {\n                    //isSingle = true\n                    result = this.eq(0).data(datakey).value;\n                } else {\n                    this.each(function () {\n                        var $this = $(this),\n                            data = $this.data(datakey);\n                        if (data && data.value !== undefined && data.value !== null) {\n                            result[data.options.name] = data.input.value2submit(data.value);\n                        }\n                    });\n                }\n                return result;\n\n            /**\n            This method collects values from several editable elements and submit them all to server.   \n            Internally it runs client-side validation for all fields and submits only in case of success.  \n            See <a href=\"#newrecord\">creating new records</a> for details.  \n            Since 1.5.1 `submit` can be applied to single element to send data programmatically. In that case\n            `url`, `success` and `error` is taken from initial options and you can just call `$('#username').editable('submit')`. \n            \n            @method submit(options)\n            @param {object} options \n            @param {object} options.url url to submit data \n            @param {object} options.data additional data to submit\n            @param {object} options.ajaxOptions additional ajax options\n            @param {function} options.error(obj) error handler \n            @param {function} options.success(obj,config) success handler\n            @returns {Object} jQuery object\n            **/\n            case 'submit':\n                //collects value, validate and submit to server for creating new record\n                var config = arguments[1] || {},\n                    $elems = this,\n                    errors = this.editable('validate');\n\n                // validation ok\n                if ($.isEmptyObject(errors)) {\n                    var ajaxOptions = {};\n\n                    // for single element use url, success etc from options\n                    if ($elems.length === 1) {\n                        var editable = $elems.data('editable');\n                        //standard params\n                        var params = {\n                            name: editable.options.name || '',\n                            value: editable.input.value2submit(editable.value),\n                            pk: typeof editable.options.pk === 'function' ? editable.options.pk.call(editable.options.scope) : editable.options.pk\n                        };\n\n                        //additional params\n                        if (typeof editable.options.params === 'function') {\n                            params = editable.options.params.call(editable.options.scope, params);\n                        } else {\n                            //try parse json in single quotes (from data-params attribute)\n                            editable.options.params = $.fn.editableutils.tryParseJson(editable.options.params, true);\n                            $.extend(params, editable.options.params);\n                        }\n\n                        ajaxOptions = {\n                            url: editable.options.url,\n                            data: params,\n                            type: 'POST'\n                        };\n\n                        // use success / error from options \n                        config.success = config.success || editable.options.success;\n                        config.error = config.error || editable.options.error;\n\n                        // multiple elements\n                    } else {\n                        var values = this.editable('getValue');\n\n                        ajaxOptions = {\n                            url: config.url,\n                            data: values,\n                            type: 'POST'\n                        };\n                    }\n\n                    // ajax success callabck (response 200 OK)\n                    ajaxOptions.success = typeof config.success === 'function' ? function (response) {\n                        config.success.call($elems, response, config);\n                    } : $.noop;\n\n                    // ajax error callabck\n                    ajaxOptions.error = typeof config.error === 'function' ? function () {\n                        config.error.apply($elems, arguments);\n                    } : $.noop;\n\n                    // extend ajaxOptions    \n                    if (config.ajaxOptions) {\n                        $.extend(ajaxOptions, config.ajaxOptions);\n                    }\n\n                    // extra data \n                    if (config.data) {\n                        $.extend(ajaxOptions.data, config.data);\n                    }\n\n                    // perform ajax request\n                    $.ajax(ajaxOptions);\n                } else {\n                    //client-side validation error\n                    if (typeof config.error === 'function') {\n                        config.error.call($elems, errors);\n                    }\n                }\n                return this;\n        }\n\n        //return jquery object\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data(datakey),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) === 'object' && option;\n\n            //for delegated targets do not store `editable` object for element\n            //it's allows several different selectors.\n            //see: https://github.com/vitalets/x-editable/issues/312    \n            if (options && options.selector) {\n                data = new Editable(this, options);\n                return;\n            }\n\n            if (!data) {\n                $this.data(datakey, data = new Editable(this, options));\n            }\n\n            if (typeof option === 'string') {\n                //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            }\n        });\n    };\n\n    $.fn.editable.defaults = {\n        /**\n        Type of input. Can be <code>text|textarea|select|date|checklist</code> and more\n         @property type \n        @type string\n        @default 'text'\n        **/\n        type: 'text',\n        /**\n        Sets disabled state of editable\n         @property disabled \n        @type boolean\n        @default false\n        **/\n        disabled: false,\n        /**\n        How to toggle editable. Can be <code>click|dblclick|mouseenter|manual</code>.   \n        When set to <code>manual</code> you should manually call <code>show/hide</code> methods of editable.    \n        **Note**: if you call <code>show</code> or <code>toggle</code> inside **click** handler of some DOM element, \n        you need to apply <code>e.stopPropagation()</code> because containers are being closed on any click on document.\n        \n        @example\n        $('#edit-button').click(function(e) {\n            e.stopPropagation();\n            $('#username').editable('toggle');\n        });\n         @property toggle \n        @type string\n        @default 'click'\n        **/\n        toggle: 'click',\n        /**\n        Text shown when element is empty.\n         @property emptytext \n        @type string\n        @default 'Empty'\n        **/\n        emptytext: 'Empty',\n        /**\n        Allows to automatically set element's text based on it's value. Can be <code>auto|always|never</code>. Useful for select and date.\n        For example, if dropdown list is <code>{1: 'a', 2: 'b'}</code> and element's value set to <code>1</code>, it's html will be automatically set to <code>'a'</code>.  \n        <code>auto</code> - text will be automatically set only if element is empty.  \n        <code>always|never</code> - always(never) try to set element's text.\n         @property autotext \n        @type string\n        @default 'auto'\n        **/\n        autotext: 'auto',\n        /**\n        Initial value of input. If not set, taken from element's text.  \n        Note, that if element's text is empty - text is automatically generated from value and can be customized (see `autotext` option).  \n        For example, to display currency sign:\n        @example\n        <a id=\"price\" data-type=\"text\" data-value=\"100\"></a>\n        <script>\n        $('#price').editable({\n            ...\n            display: function(value) {\n              $(this).text(value + '$');\n            } \n        }) \n        <\/script>\n                \n        @property value \n        @type mixed\n        @default element's text\n        **/\n        value: null,\n        /**\n        Callback to perform custom displaying of value in element's text.  \n        If `null`, default input's display used.  \n        If `false`, no displaying methods will be called, element's text will never change.  \n        Runs under element's scope.  \n        _**Parameters:**_  \n        \n        * `value` current value to be displayed\n        * `response` server response (if display called after ajax submit), since 1.4.0\n         \n        For _inputs with source_ (select, checklist) parameters are different:  \n          \n        * `value` current value to be displayed\n        * `sourceData` array of items for current input (e.g. dropdown items) \n        * `response` server response (if display called after ajax submit), since 1.4.0\n                  \n        To get currently selected items use `$.fn.editableutils.itemsByValue(value, sourceData)`.\n        \n        @property display \n        @type function|boolean\n        @default null\n        @since 1.2.0\n        @example\n        display: function(value, sourceData) {\n           //display checklist as comma-separated values\n           var html = [],\n               checked = $.fn.editableutils.itemsByValue(value, sourceData);\n               \n           if(checked.length) {\n               $.each(checked, function(i, v) { html.push($.fn.editableutils.escape(v.text)); });\n               $(this).html(html.join(', '));\n           } else {\n               $(this).empty(); \n           }\n        }\n        **/\n        display: null,\n        /**\n        Css class applied when editable text is empty.\n         @property emptyclass \n        @type string\n        @since 1.4.1        \n        @default editable-empty\n        **/\n        emptyclass: 'editable-empty',\n        /**\n        Css class applied when value was stored but not sent to server (`pk` is empty or `send = 'never'`).  \n        You may set it to `null` if you work with editables locally and submit them together.  \n         @property unsavedclass \n        @type string\n        @since 1.4.1        \n        @default editable-unsaved\n        **/\n        unsavedclass: 'editable-unsaved',\n        /**\n        If selector is provided, editable will be delegated to the specified targets.  \n        Usefull for dynamically generated DOM elements.  \n        **Please note**, that delegated targets can't be initialized with `emptytext` and `autotext` options, \n        as they actually become editable only after first click.  \n        You should manually set class `editable-click` to these elements.  \n        Also, if element originally empty you should add class `editable-empty`, set `data-value=\"\"` and write emptytext into element:\n         @property selector \n        @type string\n        @since 1.4.1        \n        @default null\n        @example\n        <div id=\"user\">\n          \x3c!-- empty --\x3e\n          <a href=\"#\" data-name=\"username\" data-type=\"text\" class=\"editable-click editable-empty\" data-value=\"\" title=\"Username\">Empty</a>\n          \x3c!-- non-empty --\x3e\n          <a href=\"#\" data-name=\"group\" data-type=\"select\" data-source=\"/groups\" data-value=\"1\" class=\"editable-click\" title=\"Group\">Operator</a>\n        </div>     \n        \n        <script>\n        $('#user').editable({\n            selector: 'a',\n            url: '/post',\n            pk: 1\n        });\n        <\/script>\n        **/\n        selector: null,\n        /**\n        Color used to highlight element after update. Implemented via CSS3 transition, works in modern browsers.\n        \n        @property highlight \n        @type string|boolean\n        @since 1.4.5        \n        @default #FFFF80 \n        **/\n        highlight: '#FFFF80'\n    };\n})(window.jQuery);\n\n/**\nAbstractInput - base class for all editable inputs.\nIt defines interface to be implemented by any input type.\nTo create your own input you can inherit from this class.\n\n@class abstractinput\n**/\n(function ($) {\n\n    //types\n    $.fn.editabletypes = {};\n\n    var AbstractInput = function AbstractInput() {};\n\n    AbstractInput.prototype = {\n        /**\n         Initializes input\n          @method init() \n         **/\n        init: function init(type, options, defaults) {\n            this.type = type;\n            this.options = $.extend({}, defaults, options);\n        },\n\n        /*\n        this method called before render to init $tpl that is inserted in DOM\n        */\n        prerender: function prerender() {\n            this.$tpl = $(this.options.tpl); //whole tpl as jquery object    \n            this.$input = this.$tpl; //control itself, can be changed in render method\n            this.$clear = null; //clear button\n            this.error = null; //error message, if input cannot be rendered           \n        },\n\n        /**\n         Renders input from tpl. Can return jQuery deferred object.\n         Can be overwritten in child objects\n          @method render()\n        **/\n        render: function render() {},\n\n        /**\n         Sets element's html by value. \n          @method value2html(value, element)\n         @param {mixed} value\n         @param {DOMElement} element\n        **/\n        value2html: function value2html(value, element) {\n            $(element)[this.options.escape ? 'text' : 'html']($.trim(value));\n        },\n\n        /**\n         Converts element's html to value\n          @method html2value(html)\n         @param {string} html\n         @returns {mixed}\n        **/\n        html2value: function html2value(html) {\n            return $('<div>').html(html).text();\n        },\n\n        /**\n         Converts value to string (for internal compare). For submitting to server used value2submit().\n          @method value2str(value) \n         @param {mixed} value\n         @returns {string}\n        **/\n        value2str: function value2str(value) {\n            return value;\n        },\n\n        /**\n         Converts string received from server into value. Usually from `data-value` attribute.\n          @method str2value(str)\n         @param {string} str\n         @returns {mixed}\n        **/\n        str2value: function str2value(str) {\n            return str;\n        },\n\n        /**\n         Converts value for submitting to server. Result can be string or object.\n          @method value2submit(value) \n         @param {mixed} value\n         @returns {mixed}\n        **/\n        value2submit: function value2submit(value) {\n            return value;\n        },\n\n        /**\n         Sets value of input.\n          @method value2input(value) \n         @param {mixed} value\n        **/\n        value2input: function value2input(value) {\n            this.$input.val(value);\n        },\n\n        /**\n         Returns value of input. Value can be object (e.g. datepicker)\n          @method input2value() \n        **/\n        input2value: function input2value() {\n            return this.$input.val();\n        },\n\n        /**\n         Activates input. For text it sets focus.\n          @method activate() \n        **/\n        activate: function activate() {\n            if (this.$input.is(':visible')) {\n                this.$input.focus();\n            }\n        },\n\n        /**\n         Creates input.\n          @method clear() \n        **/\n        clear: function clear() {\n            this.$input.val(null);\n        },\n\n        /**\n         method to escape html.\n        **/\n        escape: function escape(str) {\n            return $('<div>').text(str).html();\n        },\n\n        /**\n         attach handler to automatically submit form when value changed (useful when buttons not shown)\n        **/\n        autosubmit: function autosubmit() {},\n\n        /**\n        Additional actions when destroying element \n        **/\n        destroy: function destroy() {},\n\n        // -------- helper functions --------\n        setClass: function setClass() {\n            if (this.options.inputclass) {\n                this.$input.addClass(this.options.inputclass);\n            }\n        },\n\n        setAttr: function setAttr(attr) {\n            if (this.options[attr] !== undefined && this.options[attr] !== null) {\n                this.$input.attr(attr, this.options[attr]);\n            }\n        },\n\n        option: function option(key, value) {\n            this.options[key] = value;\n        }\n\n    };\n\n    AbstractInput.defaults = {\n        /**\n        HTML template of input. Normally you should not change it.\n         @property tpl \n        @type string\n        @default ''\n        **/\n        tpl: '',\n        /**\n        CSS class automatically applied to input\n        \n        @property inputclass \n        @type string\n        @default null\n        **/\n        inputclass: null,\n\n        /**\n        If `true` - html will be escaped in content of element via $.text() method.  \n        If `false` - html will not be escaped, $.html() used.  \n        When you use own `display` function, this option obviosly has no effect.\n        \n        @property escape \n        @type boolean\n        @since 1.5.0\n        @default true\n        **/\n        escape: true,\n\n        //scope for external methods (e.g. source defined as function)\n        //for internal use only\n        scope: null,\n\n        //need to re-declare showbuttons here to get it's value from common config (passed only options existing in defaults)\n        showbuttons: true\n    };\n\n    $.extend($.fn.editabletypes, { abstractinput: AbstractInput });\n})(window.jQuery);\n\n/**\nList - abstract class for inputs that have source option loaded from js array or via ajax\n\n@class list\n@extends abstractinput\n**/\n(function ($) {\n\n    var List = function List(options) {};\n\n    $.fn.editableutils.inherit(List, $.fn.editabletypes.abstractinput);\n\n    $.extend(List.prototype, {\n        render: function render() {\n            var deferred = $.Deferred();\n\n            this.error = null;\n            this.onSourceReady(function () {\n                this.renderList();\n                deferred.resolve();\n            }, function () {\n                this.error = this.options.sourceError;\n                deferred.resolve();\n            });\n\n            return deferred.promise();\n        },\n\n        html2value: function html2value(html) {\n            return null; //can't set value by text\n        },\n\n        value2html: function value2html(value, element, display, response) {\n            var deferred = $.Deferred(),\n                success = function success() {\n                if (typeof display === 'function') {\n                    //custom display method\n                    display.call(element, value, this.sourceData, response);\n                } else {\n                    this.value2htmlFinal(value, element);\n                }\n                deferred.resolve();\n            };\n\n            //for null value just call success without loading source\n            if (value === null) {\n                success.call(this);\n            } else {\n                this.onSourceReady(success, function () {\n                    deferred.resolve();\n                });\n            }\n\n            return deferred.promise();\n        },\n\n        // ------------- additional functions ------------\n\n        onSourceReady: function onSourceReady(success, error) {\n            //run source if it function\n            var source;\n            if ($.isFunction(this.options.source)) {\n                source = this.options.source.call(this.options.scope);\n                this.sourceData = null;\n                //note: if function returns the same source as URL - sourceData will be taken from cahce and no extra request performed\n            } else {\n                source = this.options.source;\n            }\n\n            //if allready loaded just call success\n            if (this.options.sourceCache && $.isArray(this.sourceData)) {\n                success.call(this);\n                return;\n            }\n\n            //try parse json in single quotes (for double quotes jquery does automatically)\n            try {\n                source = $.fn.editableutils.tryParseJson(source, false);\n            } catch (e) {\n                error.call(this);\n                return;\n            }\n\n            //loading from url\n            if (typeof source === 'string') {\n                //try to get sourceData from cache\n                if (this.options.sourceCache) {\n                    var cacheID = source,\n                        cache;\n\n                    if (!$(document).data(cacheID)) {\n                        $(document).data(cacheID, {});\n                    }\n                    cache = $(document).data(cacheID);\n\n                    //check for cached data\n                    if (cache.loading === false && cache.sourceData) {\n                        //take source from cache\n                        this.sourceData = cache.sourceData;\n                        this.doPrepend();\n                        success.call(this);\n                        return;\n                    } else if (cache.loading === true) {\n                        //cache is loading, put callback in stack to be called later\n                        cache.callbacks.push($.proxy(function () {\n                            this.sourceData = cache.sourceData;\n                            this.doPrepend();\n                            success.call(this);\n                        }, this));\n\n                        //also collecting error callbacks\n                        cache.err_callbacks.push($.proxy(error, this));\n                        return;\n                    } else {\n                        //no cache yet, activate it\n                        cache.loading = true;\n                        cache.callbacks = [];\n                        cache.err_callbacks = [];\n                    }\n                }\n\n                //ajaxOptions for source. Can be overwritten bt options.sourceOptions\n                var ajaxOptions = $.extend({\n                    url: source,\n                    type: 'get',\n                    cache: false,\n                    dataType: 'json',\n                    success: $.proxy(function (data) {\n                        if (cache) {\n                            cache.loading = false;\n                        }\n                        this.sourceData = this.makeArray(data);\n                        if ($.isArray(this.sourceData)) {\n                            if (cache) {\n                                //store result in cache\n                                cache.sourceData = this.sourceData;\n                                //run success callbacks for other fields waiting for this source\n                                $.each(cache.callbacks, function () {\n                                    this.call();\n                                });\n                            }\n                            this.doPrepend();\n                            success.call(this);\n                        } else {\n                            error.call(this);\n                            if (cache) {\n                                //run error callbacks for other fields waiting for this source\n                                $.each(cache.err_callbacks, function () {\n                                    this.call();\n                                });\n                            }\n                        }\n                    }, this),\n                    error: $.proxy(function () {\n                        error.call(this);\n                        if (cache) {\n                            cache.loading = false;\n                            //run error callbacks for other fields\n                            $.each(cache.err_callbacks, function () {\n                                this.call();\n                            });\n                        }\n                    }, this)\n                }, this.options.sourceOptions);\n\n                //loading sourceData from server\n                $.ajax(ajaxOptions);\n            } else {\n                //options as json/array\n                this.sourceData = this.makeArray(source);\n\n                if ($.isArray(this.sourceData)) {\n                    this.doPrepend();\n                    success.call(this);\n                } else {\n                    error.call(this);\n                }\n            }\n        },\n\n        doPrepend: function doPrepend() {\n            if (this.options.prepend === null || this.options.prepend === undefined) {\n                return;\n            }\n\n            if (!$.isArray(this.prependData)) {\n                //run prepend if it is function (once)\n                if ($.isFunction(this.options.prepend)) {\n                    this.options.prepend = this.options.prepend.call(this.options.scope);\n                }\n\n                //try parse json in single quotes\n                this.options.prepend = $.fn.editableutils.tryParseJson(this.options.prepend, true);\n\n                //convert prepend from string to object\n                if (typeof this.options.prepend === 'string') {\n                    this.options.prepend = { '': this.options.prepend };\n                }\n\n                this.prependData = this.makeArray(this.options.prepend);\n            }\n\n            if ($.isArray(this.prependData) && $.isArray(this.sourceData)) {\n                this.sourceData = this.prependData.concat(this.sourceData);\n            }\n        },\n\n        /*\n         renders input list\n        */\n        renderList: function renderList() {\n            // this method should be overwritten in child class\n        },\n\n        /*\n        set element's html by value\n        */\n        value2htmlFinal: function value2htmlFinal(value, element) {\n            // this method should be overwritten in child class\n        },\n\n        /**\n        * convert data to array suitable for sourceData, e.g. [{value: 1, text: 'abc'}, {...}]\n        */\n        makeArray: function makeArray(data) {\n            var count,\n                obj,\n                result = [],\n                item,\n                iterateItem;\n            if (!data || typeof data === 'string') {\n                return null;\n            }\n\n            if ($.isArray(data)) {\n                //array\n                /* \n                   function to iterate inside item of array if item is object.\n                   Caclulates count of keys in item and store in obj. \n                */\n                iterateItem = function iterateItem(k, v) {\n                    obj = { value: k, text: v };\n                    if (count++ >= 2) {\n                        return false; // exit from `each` if item has more than one key.\n                    }\n                };\n\n                for (var i = 0; i < data.length; i++) {\n                    item = data[i];\n                    if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {\n                        count = 0; //count of keys inside item\n                        $.each(item, iterateItem);\n                        //case: [{val1: 'text1'}, {val2: 'text2} ...]\n                        if (count === 1) {\n                            result.push(obj);\n                            //case: [{value: 1, text: 'text1'}, {value: 2, text: 'text2'}, ...]\n                        } else if (count > 1) {\n                            //removed check of existance: item.hasOwnProperty('value') && item.hasOwnProperty('text')\n                            if (item.children) {\n                                item.children = this.makeArray(item.children);\n                            }\n                            result.push(item);\n                        }\n                    } else {\n                        //case: ['text1', 'text2' ...]\n                        result.push({ value: item, text: item });\n                    }\n                }\n            } else {\n                //case: {val1: 'text1', val2: 'text2, ...}\n                $.each(data, function (k, v) {\n                    result.push({ value: k, text: v });\n                });\n            }\n            return result;\n        },\n\n        option: function option(key, value) {\n            this.options[key] = value;\n            if (key === 'source') {\n                this.sourceData = null;\n            }\n            if (key === 'prepend') {\n                this.prependData = null;\n            }\n        }\n\n    });\n\n    List.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        Source data for list.  \n        If **array** - it should be in format: `[{value: 1, text: \"text1\"}, {value: 2, text: \"text2\"}, ...]`  \n        For compability, object format is also supported: `{\"1\": \"text1\", \"2\": \"text2\" ...}` but it does not guarantee elements order.\n        \n        If **string** - considered ajax url to load items. In that case results will be cached for fields with the same source and name. See also `sourceCache` option.\n          \n        If **function**, it should return data in format above (since 1.4.0).\n        \n        Since 1.4.1 key `children` supported to render OPTGROUP (for **select** input only).  \n        `[{text: \"group1\", children: [{value: 1, text: \"text1\"}, {value: 2, text: \"text2\"}]}, ...]` \n            @property source \n        @type string | array | object | function\n        @default null\n        **/\n        source: null,\n        /**\n        Data automatically prepended to the beginning of dropdown list.\n        \n        @property prepend \n        @type string | array | object | function\n        @default false\n        **/\n        prepend: false,\n        /**\n        Error message when list cannot be loaded (e.g. ajax error)\n        \n        @property sourceError \n        @type string\n        @default Error when loading list\n        **/\n        sourceError: 'Error when loading list',\n        /**\n        if <code>true</code> and source is **string url** - results will be cached for fields with the same source.    \n        Usefull for editable column in grid to prevent extra requests.\n        \n        @property sourceCache \n        @type boolean\n        @default true\n        @since 1.2.0\n        **/\n        sourceCache: true,\n        /**\n        Additional ajax options to be used in $.ajax() when loading list from server.\n        Useful to send extra parameters (`data` key) or change request method (`type` key).\n        \n        @property sourceOptions \n        @type object|function\n        @default null\n        @since 1.5.0\n        **/\n        sourceOptions: null\n    });\n\n    $.fn.editabletypes.list = List;\n})(window.jQuery);\n\n/**\nText input\n\n@class text\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"username\" data-type=\"text\" data-pk=\"1\">awesome</a>\n<script>\n$(function(){\n    $('#username').editable({\n        url: '/post',\n        title: 'Enter username'\n    });\n});\n<\/script>\n**/\n(function ($) {\n\n    var Text = function Text(options) {\n        this.init('text', options, Text.defaults);\n    };\n\n    $.fn.editableutils.inherit(Text, $.fn.editabletypes.abstractinput);\n\n    $.extend(Text.prototype, {\n        render: function render() {\n            this.renderClear();\n            this.setClass();\n            this.setAttr('placeholder');\n        },\n\n        activate: function activate() {\n            if (this.$input.is(':visible')) {\n                this.$input.focus();\n                $.fn.editableutils.setCursorPosition(this.$input.get(0), this.$input.val().length);\n                if (this.toggleClear) {\n                    this.toggleClear();\n                }\n            }\n        },\n\n        //render clear button\n        renderClear: function renderClear() {\n            if (this.options.clear) {\n                this.$clear = $('<span class=\"editable-clear-x\"></span>');\n                this.$input.after(this.$clear).css('padding-right', 24).keyup($.proxy(function (e) {\n                    //arrows, enter, tab, etc\n                    if (~$.inArray(e.keyCode, [40, 38, 9, 13, 27])) {\n                        return;\n                    }\n\n                    clearTimeout(this.t);\n                    var that = this;\n                    this.t = setTimeout(function () {\n                        that.toggleClear(e);\n                    }, 100);\n                }, this)).parent().css('position', 'relative');\n\n                this.$clear.click($.proxy(this.clear, this));\n            }\n        },\n\n        postrender: function postrender() {\n            /*\n            //now `clear` is positioned via css\n            if(this.$clear) {\n                //can position clear button only here, when form is shown and height can be calculated\n            //                var h = this.$input.outerHeight(true) || 20,\n                var h = this.$clear.parent().height(),\n                    delta = (h - this.$clear.height()) / 2;\n                    \n                //this.$clear.css({bottom: delta, right: delta});\n            }\n            */\n        },\n\n        //show / hide clear button\n        toggleClear: function toggleClear(e) {\n            if (!this.$clear) {\n                return;\n            }\n\n            var len = this.$input.val().length,\n                visible = this.$clear.is(':visible');\n\n            if (len && !visible) {\n                this.$clear.show();\n            }\n\n            if (!len && visible) {\n                this.$clear.hide();\n            }\n        },\n\n        clear: function clear() {\n            this.$clear.hide();\n            this.$input.val('').focus();\n        }\n    });\n\n    Text.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"text\">\n        **/\n        tpl: '<input type=\"text\">',\n        /**\n        Placeholder attribute of input. Shown when input is empty.\n         @property placeholder \n        @type string\n        @default null\n        **/\n        placeholder: null,\n\n        /**\n        Whether to show `clear` button \n        \n        @property clear \n        @type boolean\n        @default true        \n        **/\n        clear: true\n    });\n\n    $.fn.editabletypes.text = Text;\n})(window.jQuery);\n\n/**\nTextarea input\n\n@class textarea\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"comments\" data-type=\"textarea\" data-pk=\"1\">awesome comment!</a>\n<script>\n$(function(){\n    $('#comments').editable({\n        url: '/post',\n        title: 'Enter comments',\n        rows: 10\n    });\n});\n<\/script>\n**/\n(function ($) {\n\n    var Textarea = function Textarea(options) {\n        this.init('textarea', options, Textarea.defaults);\n    };\n\n    $.fn.editableutils.inherit(Textarea, $.fn.editabletypes.abstractinput);\n\n    $.extend(Textarea.prototype, {\n        render: function render() {\n            this.setClass();\n            this.setAttr('placeholder');\n            this.setAttr('rows');\n\n            //ctrl + enter\n            this.$input.keydown(function (e) {\n                if (e.ctrlKey && e.which === 13) {\n                    $(this).closest('form').submit();\n                }\n            });\n        },\n\n        //using `white-space: pre-wrap` solves \\n  <--\x3e BR conversion very elegant!\n        /* \n        value2html: function(value, element) {\n             var html = '', lines;\n             if(value) {\n                 lines = value.split(\"\\n\");\n                 for (var i = 0; i < lines.length; i++) {\n                     lines[i] = $('<div>').text(lines[i]).html();\n                 }\n                 html = lines.join('<br>');\n             }\n             $(element).html(html);\n         },\n        \n         html2value: function(html) {\n             if(!html) {\n                 return '';\n             }\n              var regex = new RegExp(String.fromCharCode(10), 'g');\n             var lines = html.split(/<br\\s*\\/?>/i);\n             for (var i = 0; i < lines.length; i++) {\n                 var text = $('<div>').html(lines[i]).text();\n                  // Remove newline characters (\\n) to avoid them being converted by value2html() method\n                 // thus adding extra <br> tags\n                 text = text.replace(regex, '');\n                  lines[i] = text;\n             }\n             return lines.join(\"\\n\");\n         },\n          */\n        activate: function activate() {\n            $.fn.editabletypes.text.prototype.activate.call(this);\n        }\n    });\n\n    Textarea.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl\n        @default <textarea></textarea>\n        **/\n        tpl: '<textarea></textarea>',\n        /**\n        @property inputclass\n        @default input-large\n        **/\n        inputclass: 'input-large',\n        /**\n        Placeholder attribute of input. Shown when input is empty.\n         @property placeholder\n        @type string\n        @default null\n        **/\n        placeholder: null,\n        /**\n        Number of rows in textarea\n         @property rows\n        @type integer\n        @default 7\n        **/\n        rows: 7\n    });\n\n    $.fn.editabletypes.textarea = Textarea;\n})(window.jQuery);\n\n/**\nSelect (dropdown)\n\n@class select\n@extends list\n@final\n@example\n<a href=\"#\" id=\"status\" data-type=\"select\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select status\"></a>\n<script>\n$(function(){\n    $('#status').editable({\n        value: 2,    \n        source: [\n              {value: 1, text: 'Active'},\n              {value: 2, text: 'Blocked'},\n              {value: 3, text: 'Deleted'}\n           ]\n    });\n});\n<\/script>\n**/\n(function ($) {\n    ;\n\n    var Select = function Select(options) {\n        this.init('select', options, Select.defaults);\n    };\n\n    $.fn.editableutils.inherit(Select, $.fn.editabletypes.list);\n\n    $.extend(Select.prototype, {\n        renderList: function renderList() {\n            this.$input.empty();\n\n            var fillItems = function fillItems($el, data) {\n                var attr;\n                if ($.isArray(data)) {\n                    for (var i = 0; i < data.length; i++) {\n                        attr = {};\n                        if (data[i].children) {\n                            attr.label = data[i].text;\n                            $el.append(fillItems($('<optgroup>', attr), data[i].children));\n                        } else {\n                            attr.value = data[i].value;\n                            if (data[i].disabled) {\n                                attr.disabled = true;\n                            }\n                            $el.append($('<option>', attr).text(data[i].text));\n                        }\n                    }\n                }\n                return $el;\n            };\n\n            fillItems(this.$input, this.sourceData);\n\n            this.setClass();\n\n            //enter submit\n            this.$input.on('keydown.editable', function (e) {\n                if (e.which === 13) {\n                    $(this).closest('form').submit();\n                }\n            });\n        },\n\n        value2htmlFinal: function value2htmlFinal(value, element) {\n            var text = '',\n                items = $.fn.editableutils.itemsByValue(value, this.sourceData);\n\n            if (items.length) {\n                text = items[0].text;\n            }\n\n            //$(element).text(text);\n            $.fn.editabletypes.abstractinput.prototype.value2html.call(this, text, element);\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.off('keydown.editable').on('change.editable', function () {\n                $(this).closest('form').submit();\n            });\n        }\n    });\n\n    Select.defaults = $.extend({}, $.fn.editabletypes.list.defaults, {\n        /**\n        @property tpl \n        @default <select></select>\n        **/\n        tpl: '<select></select>'\n    });\n\n    $.fn.editabletypes.select = Select;\n})(window.jQuery);\n\n/**\nList of checkboxes. \nInternally value stored as javascript array of values.\n\n@class checklist\n@extends list\n@final\n@example\n<a href=\"#\" id=\"options\" data-type=\"checklist\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select options\"></a>\n<script>\n$(function(){\n    $('#options').editable({\n        value: [2, 3],    \n        source: [\n              {value: 1, text: 'option1'},\n              {value: 2, text: 'option2'},\n              {value: 3, text: 'option3'}\n           ]\n    });\n});\n<\/script>\n**/\n(function ($) {\n    ;\n\n    var Checklist = function Checklist(options) {\n        this.init('checklist', options, Checklist.defaults);\n    };\n\n    $.fn.editableutils.inherit(Checklist, $.fn.editabletypes.list);\n\n    $.extend(Checklist.prototype, {\n        renderList: function renderList() {\n            var $label, $div;\n\n            this.$tpl.empty();\n\n            if (!$.isArray(this.sourceData)) {\n                return;\n            }\n\n            for (var i = 0; i < this.sourceData.length; i++) {\n                $label = $('<label>').append($('<input>', {\n                    type: 'checkbox',\n                    value: this.sourceData[i].value\n                })).append($('<span>').text(' ' + this.sourceData[i].text));\n\n                $('<div>').append($label).appendTo(this.$tpl);\n            }\n\n            this.$input = this.$tpl.find('input[type=\"checkbox\"]');\n            this.setClass();\n        },\n\n        value2str: function value2str(value) {\n            return $.isArray(value) ? value.sort().join($.trim(this.options.separator)) : '';\n        },\n\n        //parse separated string\n        str2value: function str2value(str) {\n            var reg,\n                value = null;\n            if (typeof str === 'string' && str.length) {\n                reg = new RegExp('\\\\s*' + $.trim(this.options.separator) + '\\\\s*');\n                value = str.split(reg);\n            } else if ($.isArray(str)) {\n                value = str;\n            } else {\n                value = [str];\n            }\n            return value;\n        },\n\n        //set checked on required checkboxes\n        value2input: function value2input(value) {\n            this.$input.prop('checked', false);\n            if ($.isArray(value) && value.length) {\n                this.$input.each(function (i, el) {\n                    var $el = $(el);\n                    // cannot use $.inArray as it performs strict comparison\n                    $.each(value, function (j, val) {\n                        /*jslint eqeq: true*/\n                        if ($el.val() == val) {\n                            /*jslint eqeq: false*/\n                            $el.prop('checked', true);\n                        }\n                    });\n                });\n            }\n        },\n\n        input2value: function input2value() {\n            var checked = [];\n            this.$input.filter(':checked').each(function (i, el) {\n                checked.push($(el).val());\n            });\n            return checked;\n        },\n\n        //collect text of checked boxes\n        value2htmlFinal: function value2htmlFinal(value, element) {\n            var html = [],\n                checked = $.fn.editableutils.itemsByValue(value, this.sourceData),\n                escape = this.options.escape;\n\n            if (checked.length) {\n                $.each(checked, function (i, v) {\n                    var text = escape ? $.fn.editableutils.escape(v.text) : v.text;\n                    html.push(text);\n                });\n                $(element).html(html.join('<br>'));\n            } else {\n                $(element).empty();\n            }\n        },\n\n        activate: function activate() {\n            this.$input.first().focus();\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.on('keydown', function (e) {\n                if (e.which === 13) {\n                    $(this).closest('form').submit();\n                }\n            });\n        }\n    });\n\n    Checklist.defaults = $.extend({}, $.fn.editabletypes.list.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/\n        tpl: '<div class=\"editable-checklist\"></div>',\n\n        /**\n        @property inputclass \n        @type string\n        @default null\n        **/\n        inputclass: null,\n\n        /**\n        Separator of values when reading from `data-value` attribute\n         @property separator \n        @type string\n        @default ','\n        **/\n        separator: ','\n    });\n\n    $.fn.editabletypes.checklist = Checklist;\n})(window.jQuery);\n\n/**\nHTML5 input types.\nFollowing types are supported:\n\n* password\n* email\n* url\n* tel\n* number\n* range\n* time\n\nLearn more about html5 inputs:  \nhttp://www.w3.org/wiki/HTML5_form_additions  \nTo check browser compatibility please see:  \nhttps://developer.mozilla.org/en-US/docs/HTML/Element/Input\n            \n@class html5types \n@extends text\n@final\n@since 1.3.0\n@example\n<a href=\"#\" id=\"email\" data-type=\"email\" data-pk=\"1\">admin@example.com</a>\n<script>\n$(function(){\n    $('#email').editable({\n        url: '/post',\n        title: 'Enter email'\n    });\n});\n<\/script>\n**/\n\n/**\n@property tpl \n@default depends on type\n**/\n\n/*\nPassword\n*/\n(function ($) {\n    ;\n\n    var Password = function Password(options) {\n        this.init('password', options, Password.defaults);\n    };\n    $.fn.editableutils.inherit(Password, $.fn.editabletypes.text);\n    $.extend(Password.prototype, {\n        //do not display password, show '[hidden]' instead\n        value2html: function value2html(value, element) {\n            if (value) {\n                $(element).text('[hidden]');\n            } else {\n                $(element).empty();\n            }\n        },\n        //as password not displayed, should not set value by html\n        html2value: function html2value(html) {\n            return null;\n        }\n    });\n    Password.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"password\">'\n    });\n    $.fn.editabletypes.password = Password;\n})(window.jQuery);\n\n/*\nEmail\n*/\n(function ($) {\n    ;\n\n    var Email = function Email(options) {\n        this.init('email', options, Email.defaults);\n    };\n    $.fn.editableutils.inherit(Email, $.fn.editabletypes.text);\n    Email.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"email\">'\n    });\n    $.fn.editabletypes.email = Email;\n})(window.jQuery);\n\n/*\nUrl\n*/\n(function ($) {\n    ;\n\n    var Url = function Url(options) {\n        this.init('url', options, Url.defaults);\n    };\n    $.fn.editableutils.inherit(Url, $.fn.editabletypes.text);\n    Url.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"url\">'\n    });\n    $.fn.editabletypes.url = Url;\n})(window.jQuery);\n\n/*\nTel\n*/\n(function ($) {\n    ;\n\n    var Tel = function Tel(options) {\n        this.init('tel', options, Tel.defaults);\n    };\n    $.fn.editableutils.inherit(Tel, $.fn.editabletypes.text);\n    Tel.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"tel\">'\n    });\n    $.fn.editabletypes.tel = Tel;\n})(window.jQuery);\n\n/*\nNumber\n*/\n(function ($) {\n    ;\n\n    var NumberInput = function NumberInput(options) {\n        this.init('number', options, NumberInput.defaults);\n    };\n    $.fn.editableutils.inherit(NumberInput, $.fn.editabletypes.text);\n    $.extend(NumberInput.prototype, {\n        render: function render() {\n            NumberInput.superclass.render.call(this);\n            this.setAttr('min');\n            this.setAttr('max');\n            this.setAttr('step');\n        },\n        postrender: function postrender() {\n            if (this.$clear) {\n                //increase right ffset  for up/down arrows\n                this.$clear.css({ right: 24 });\n                /*\n                //can position clear button only here, when form is shown and height can be calculated\n                var h = this.$input.outerHeight(true) || 20,\n                    delta = (h - this.$clear.height()) / 2;\n                \n                //add 12px to offset right for up/down arrows    \n                this.$clear.css({top: delta, right: delta + 16});\n                */\n            }\n        }\n    });\n    NumberInput.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"number\">',\n        inputclass: 'input-mini',\n        min: null,\n        max: null,\n        step: null\n    });\n    $.fn.editabletypes.number = NumberInput;\n})(window.jQuery);\n\n/*\nRange (inherit from number)\n*/\n(function ($) {\n    ;\n\n    var Range = function Range(options) {\n        this.init('range', options, Range.defaults);\n    };\n    $.fn.editableutils.inherit(Range, $.fn.editabletypes.number);\n    $.extend(Range.prototype, {\n        render: function render() {\n            this.$input = this.$tpl.filter('input');\n\n            this.setClass();\n            this.setAttr('min');\n            this.setAttr('max');\n            this.setAttr('step');\n\n            this.$input.on('input', function () {\n                $(this).siblings('output').text($(this).val());\n            });\n        },\n        activate: function activate() {\n            this.$input.focus();\n        }\n    });\n    Range.defaults = $.extend({}, $.fn.editabletypes.number.defaults, {\n        tpl: '<input type=\"range\"><output style=\"width: 30px; display: inline-block\"></output>',\n        inputclass: 'input-medium'\n    });\n    $.fn.editabletypes.range = Range;\n})(window.jQuery);\n\n/*\nTime\n*/\n(function ($) {\n    ;\n\n    var Time = function Time(options) {\n        this.init('time', options, Time.defaults);\n    };\n    //inherit from abstract, as inheritance from text gives selection error.\n    $.fn.editableutils.inherit(Time, $.fn.editabletypes.abstractinput);\n    $.extend(Time.prototype, {\n        render: function render() {\n            this.setClass();\n        }\n    });\n    Time.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        tpl: '<input type=\"time\">'\n    });\n    $.fn.editabletypes.time = Time;\n})(window.jQuery);\n\n/**\nSelect2 input. Based on amazing work of Igor Vaynberg https://github.com/ivaynberg/select2.  \nPlease see [original select2 docs](http://ivaynberg.github.com/select2) for detailed description and options.  \n \nYou should manually download and include select2 distributive:  \n\n    <link href=\"select2/select2.css\" rel=\"stylesheet\" type=\"text/css\"></link>  \n    <script src=\"select2/select2.js\"><\/script>  \n    \nTo make it **bootstrap-styled** you can use css from [here](https://github.com/t0m/select2-bootstrap-css): \n\n    <link href=\"select2-bootstrap.css\" rel=\"stylesheet\" type=\"text/css\"></link>    \n    \n**Note:** currently `autotext` feature does not work for select2 with `ajax` remote source.    \nYou need initially put both `data-value` and element's text youself:    \n\n    <a href=\"#\" data-type=\"select2\" data-value=\"1\">Text1</a>\n    \n    \n@class select2\n@extends abstractinput\n@since 1.4.1\n@final\n@example\n<a href=\"#\" id=\"country\" data-type=\"select2\" data-pk=\"1\" data-value=\"ru\" data-url=\"/post\" data-title=\"Select country\"></a>\n<script>\n$(function(){\n    //local source\n    $('#country').editable({\n        source: [\n              {id: 'gb', text: 'Great Britain'},\n              {id: 'us', text: 'United States'},\n              {id: 'ru', text: 'Russia'}\n           ],\n        select2: {\n           multiple: true\n        }\n    });\n    //remote source (simple)\n    $('#country').editable({\n        source: '/getCountries',\n        select2: {\n            placeholder: 'Select Country',\n            minimumInputLength: 1\n        }\n    });\n    //remote source (advanced)\n    $('#country').editable({\n        select2: {\n            placeholder: 'Select Country',\n            allowClear: true,\n            minimumInputLength: 3,\n            id: function (item) {\n                return item.CountryId;\n            },\n            ajax: {\n                url: '/getCountries',\n                dataType: 'json',\n                data: function (term, page) {\n                    return { query: term };\n                },\n                results: function (data, page) {\n                    return { results: data };\n                }\n            },\n            formatResult: function (item) {\n                return item.CountryName;\n            },\n            formatSelection: function (item) {\n                return item.CountryName;\n            },\n            initSelection: function (element, callback) {\n                return $.get('/getCountryById', { query: element.val() }, function (data) {\n                    callback(data);\n                });\n            } \n        }  \n    });\n});\n<\/script>\n**/\n(function ($) {\n    ;\n\n    var Constructor = function Constructor(options) {\n        this.init('select2', options, Constructor.defaults);\n\n        options.select2 = options.select2 || {};\n\n        this.sourceData = null;\n\n        //placeholder\n        if (options.placeholder) {\n            options.select2.placeholder = options.placeholder;\n        }\n\n        //if not `tags` mode, use source\n        if (!options.select2.tags && options.source) {\n            var source = options.source;\n            //if source is function, call it (once!)\n            if ($.isFunction(options.source)) {\n                source = options.source.call(options.scope);\n            }\n\n            if (typeof source === 'string') {\n                options.select2.ajax = options.select2.ajax || {};\n                //some default ajax params\n                if (!options.select2.ajax.data) {\n                    options.select2.ajax.data = function (term) {\n                        return { query: term };\n                    };\n                }\n                if (!options.select2.ajax.results) {\n                    options.select2.ajax.results = function (data) {\n                        return { results: data };\n                    };\n                }\n                options.select2.ajax.url = source;\n            } else {\n                //check format and convert x-editable format to select2 format (if needed)\n                this.sourceData = this.convertSource(source);\n                options.select2.data = this.sourceData;\n            }\n        }\n\n        //overriding objects in config (as by default jQuery extend() is not recursive)\n        this.options.select2 = $.extend({}, Constructor.defaults.select2, options.select2);\n\n        //detect whether it is multi-valued\n        this.isMultiple = this.options.select2.tags || this.options.select2.multiple;\n        this.isRemote = 'ajax' in this.options.select2;\n\n        //store function returning ID of item\n        //should be here as used inautotext for local source\n        this.idFunc = this.options.select2.id;\n        if (typeof this.idFunc !== \"function\") {\n            var idKey = this.idFunc || 'id';\n            this.idFunc = function (e) {\n                return e[idKey];\n            };\n        }\n\n        //store function that renders text in select2\n        this.formatSelection = this.options.select2.formatSelection;\n        if (typeof this.formatSelection !== \"function\") {\n            this.formatSelection = function (e) {\n                return e.text;\n            };\n        }\n    };\n\n    $.fn.editableutils.inherit(Constructor, $.fn.editabletypes.abstractinput);\n\n    $.extend(Constructor.prototype, {\n        render: function render() {\n            this.setClass();\n\n            //can not apply select2 here as it calls initSelection \n            //over input that does not have correct value yet.\n            //apply select2 only in value2input\n            //this.$input.select2(this.options.select2);\n\n            //when data is loaded via ajax, we need to know when it's done to populate listData\n            if (this.isRemote) {\n                //listen to loaded event to populate data\n                this.$input.on('select2-loaded', $.proxy(function (e) {\n                    this.sourceData = e.items.results;\n                }, this));\n            }\n\n            //trigger resize of editableform to re-position container in multi-valued mode\n            if (this.isMultiple) {\n                this.$input.on('change', function () {\n                    $(this).closest('form').parent().triggerHandler('resize');\n                });\n            }\n        },\n\n        value2html: function value2html(value, element) {\n            var text = '',\n                data,\n                that = this;\n\n            if (this.options.select2.tags) {\n                //in tags mode just assign value\n                data = value;\n                //data = $.fn.editableutils.itemsByValue(value, this.options.select2.tags, this.idFunc);\n            } else if (this.sourceData) {\n                data = $.fn.editableutils.itemsByValue(value, this.sourceData, this.idFunc);\n            } else {}\n            //can not get list of possible values \n            //(e.g. autotext for select2 with ajax source)\n\n\n            //data may be array (when multiple values allowed)\n            if ($.isArray(data)) {\n                //collect selected data and show with separator\n                text = [];\n                $.each(data, function (k, v) {\n                    text.push(v && (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' ? that.formatSelection(v) : v);\n                });\n            } else if (data) {\n                text = that.formatSelection(data);\n            }\n\n            text = $.isArray(text) ? text.join(this.options.viewseparator) : text;\n\n            //$(element).text(text);\n            Constructor.superclass.value2html.call(this, text, element);\n        },\n\n        html2value: function html2value(html) {\n            return this.options.select2.tags ? this.str2value(html, this.options.viewseparator) : null;\n        },\n\n        value2input: function value2input(value) {\n            // if value array => join it anyway\n            if ($.isArray(value)) {\n                value = value.join(this.getSeparator());\n            }\n\n            //for remote source just set value, text is updated by initSelection\n            if (!this.$input.data('select2')) {\n                this.$input.val(value);\n                this.$input.select2(this.options.select2);\n            } else {\n                //second argument needed to separate initial change from user's click (for autosubmit)   \n                this.$input.val(value).trigger('change', true);\n\n                //Uncaught Error: cannot call val() if initSelection() is not defined\n                //this.$input.select2('val', value);\n            }\n\n            // if defined remote source AND no multiple mode AND no user's initSelection provided --\x3e \n            // we should somehow get text for provided id.\n            // The solution is to use element's text as text for that id (exclude empty)\n            if (this.isRemote && !this.isMultiple && !this.options.select2.initSelection) {\n                // customId and customText are methods to extract `id` and `text` from data object\n                // we can use this workaround only if user did not define these methods\n                // otherwise we cant construct data object\n                var customId = this.options.select2.id,\n                    customText = this.options.select2.formatSelection;\n\n                if (!customId && !customText) {\n                    var $el = $(this.options.scope);\n                    if (!$el.data('editable').isEmpty) {\n                        var data = { id: value, text: $el.text() };\n                        this.$input.select2('data', data);\n                    }\n                }\n            }\n        },\n\n        input2value: function input2value() {\n            return this.$input.select2('val');\n        },\n\n        str2value: function str2value(str, separator) {\n            if (typeof str !== 'string' || !this.isMultiple) {\n                return str;\n            }\n\n            separator = separator || this.getSeparator();\n\n            var val, i, l;\n\n            if (str === null || str.length < 1) {\n                return null;\n            }\n            val = str.split(separator);\n            for (i = 0, l = val.length; i < l; i = i + 1) {\n                val[i] = $.trim(val[i]);\n            }\n\n            return val;\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.on('change', function (e, isInitial) {\n                if (!isInitial) {\n                    $(this).closest('form').submit();\n                }\n            });\n        },\n\n        getSeparator: function getSeparator() {\n            return this.options.select2.separator || $.fn.select2.defaults.separator;\n        },\n\n        /*\n        Converts source from x-editable format: {value: 1, text: \"1\"} to\n        select2 format: {id: 1, text: \"1\"}\n        */\n        convertSource: function convertSource(source) {\n            if ($.isArray(source) && source.length && source[0].value !== undefined) {\n                for (var i = 0; i < source.length; i++) {\n                    if (source[i].value !== undefined) {\n                        source[i].id = source[i].value;\n                        delete source[i].value;\n                    }\n                }\n            }\n            return source;\n        },\n\n        destroy: function destroy() {\n            if (this.$input.data('select2')) {\n                this.$input.select2('destroy');\n            }\n        }\n\n    });\n\n    Constructor.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"hidden\">\n        **/\n        tpl: '<input type=\"hidden\">',\n        /**\n        Configuration of select2. [Full list of options](http://ivaynberg.github.com/select2).\n         @property select2 \n        @type object\n        @default null\n        **/\n        select2: null,\n        /**\n        Placeholder attribute of select\n         @property placeholder \n        @type string\n        @default null\n        **/\n        placeholder: null,\n        /**\n        Source data for select. It will be assigned to select2 `data` property and kept here just for convenience.\n        Please note, that format is different from simple `select` input: use 'id' instead of 'value'.\n        E.g. `[{id: 1, text: \"text1\"}, {id: 2, text: \"text2\"}, ...]`.\n         @property source \n        @type array|string|function\n        @default null        \n        **/\n        source: null,\n        /**\n        Separator used to display tags.\n         @property viewseparator \n        @type string\n        @default ', '        \n        **/\n        viewseparator: ', '\n    });\n\n    $.fn.editabletypes.select2 = Constructor;\n})(window.jQuery);\n\n/**\n* Combodate - 1.0.5\n* Dropdown date and time picker.\n* Converts text input into dropdowns to pick day, month, year, hour, minute and second.\n* Uses momentjs as datetime library http://momentjs.com.\n* For i18n include corresponding file from https://github.com/timrwood/moment/tree/master/lang \n*\n* Confusion at noon and midnight - see http://en.wikipedia.org/wiki/12-hour_clock#Confusion_at_noon_and_midnight\n* In combodate: \n* 12:00 pm --\x3e 12:00 (24-h format, midday)\n* 12:00 am --\x3e 00:00 (24-h format, midnight, start of day)\n* \n* Differs from momentjs parse rules:\n* 00:00 pm, 12:00 pm --\x3e 12:00 (24-h format, day not change)\n* 00:00 am, 12:00 am --\x3e 00:00 (24-h format, day not change)\n* \n* \n* Author: Vitaliy Potapov\n* Project page: http://github.com/vitalets/combodate\n* Copyright (c) 2012 Vitaliy Potapov. Released under MIT License.\n**/\n(function ($) {\n\n    var Combodate = function Combodate(element, options) {\n        this.$element = $(element);\n        if (!this.$element.is('input')) {\n            $.error('Combodate should be applied to INPUT element');\n            return;\n        }\n        this.options = $.extend({}, $.fn.combodate.defaults, options, this.$element.data());\n        this.init();\n    };\n\n    Combodate.prototype = {\n        constructor: Combodate,\n        init: function init() {\n            this.map = {\n                //key   regexp    moment.method\n                day: ['D', 'date'],\n                month: ['M', 'month'],\n                year: ['Y', 'year'],\n                hour: ['[Hh]', 'hours'],\n                minute: ['m', 'minutes'],\n                second: ['s', 'seconds'],\n                ampm: ['[Aa]', '']\n            };\n\n            this.$widget = $('<span class=\"combodate\"></span>').html(this.getTemplate());\n\n            this.initCombos();\n\n            //update original input on change \n            this.$widget.on('change', 'select', $.proxy(function (e) {\n                this.$element.val(this.getValue()).change();\n                // update days count if month or year changes\n                if (this.options.smartDays) {\n                    if ($(e.target).is('.month') || $(e.target).is('.year')) {\n                        this.fillCombo('day');\n                    }\n                }\n            }, this));\n\n            this.$widget.find('select').css('width', 'auto');\n\n            // hide original input and insert widget                                       \n            this.$element.hide().after(this.$widget);\n\n            // set initial value\n            this.setValue(this.$element.val() || this.options.value);\n        },\n\n        /*\n         Replace tokens in template with <select> elements \n        */\n        getTemplate: function getTemplate() {\n            var tpl = this.options.template;\n\n            //first pass\n            $.each(this.map, function (k, v) {\n                v = v[0];\n                var r = new RegExp(v + '+'),\n                    token = v.length > 1 ? v.substring(1, 2) : v;\n\n                tpl = tpl.replace(r, '{' + token + '}');\n            });\n\n            //replace spaces with &nbsp;\n            tpl = tpl.replace(/ /g, '&nbsp;');\n\n            //second pass\n            $.each(this.map, function (k, v) {\n                v = v[0];\n                var token = v.length > 1 ? v.substring(1, 2) : v;\n\n                tpl = tpl.replace('{' + token + '}', '<select class=\"' + k + '\"></select>');\n            });\n\n            return tpl;\n        },\n\n        /*\n         Initialize combos that presents in template \n        */\n        initCombos: function initCombos() {\n            for (var k in this.map) {\n                var $c = this.$widget.find('.' + k);\n                // set properties like this.$day, this.$month etc.\n                this['$' + k] = $c.length ? $c : null;\n                // fill with items\n                this.fillCombo(k);\n            }\n        },\n\n        /*\n         Fill combo with items \n        */\n        fillCombo: function fillCombo(k) {\n            var $combo = this['$' + k];\n            if (!$combo) {\n                return;\n            }\n\n            // define method name to fill items, e.g `fillDays`\n            var f = 'fill' + k.charAt(0).toUpperCase() + k.slice(1);\n            var items = this[f]();\n            var value = $combo.val();\n\n            $combo.empty();\n            for (var i = 0; i < items.length; i++) {\n                $combo.append('<option value=\"' + items[i][0] + '\">' + items[i][1] + '</option>');\n            }\n\n            $combo.val(value);\n        },\n\n        /*\n         Initialize items of combos. Handles `firstItem` option \n        */\n        fillCommon: function fillCommon(key) {\n            var values = [],\n                relTime;\n\n            if (this.options.firstItem === 'name') {\n                //need both to support moment ver < 2 and  >= 2\n                relTime = moment.relativeTime || moment.langData()._relativeTime;\n                var header = typeof relTime[key] === 'function' ? relTime[key](1, true, key, false) : relTime[key];\n                //take last entry (see momentjs lang files structure) \n                header = header.split(' ').reverse()[0];\n                values.push(['', header]);\n            } else if (this.options.firstItem === 'empty') {\n                values.push(['', '']);\n            }\n            return values;\n        },\n\n        /*\n        fill day\n        */\n        fillDay: function fillDay() {\n            var items = this.fillCommon('d'),\n                name,\n                i,\n                twoDigit = this.options.template.indexOf('DD') !== -1,\n                daysCount = 31;\n\n            // detect days count (depends on month and year)\n            // originally https://github.com/vitalets/combodate/pull/7\n            if (this.options.smartDays && this.$month && this.$year) {\n                var month = parseInt(this.$month.val(), 10);\n                var year = parseInt(this.$year.val(), 10);\n\n                if (!isNaN(month) && !isNaN(year)) {\n                    daysCount = moment([year, month]).daysInMonth();\n                }\n            }\n\n            for (i = 1; i <= daysCount; i++) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill month\n        */\n        fillMonth: function fillMonth() {\n            var items = this.fillCommon('M'),\n                name,\n                i,\n                longNames = this.options.template.indexOf('MMMM') !== -1,\n                shortNames = this.options.template.indexOf('MMM') !== -1,\n                twoDigit = this.options.template.indexOf('MM') !== -1;\n\n            for (i = 0; i <= 11; i++) {\n                if (longNames) {\n                    //see https://github.com/timrwood/momentjs.com/pull/36\n                    name = moment().date(1).month(i).format('MMMM');\n                } else if (shortNames) {\n                    name = moment().date(1).month(i).format('MMM');\n                } else if (twoDigit) {\n                    name = this.leadZero(i + 1);\n                } else {\n                    name = i + 1;\n                }\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill year\n        */\n        fillYear: function fillYear() {\n            var items = [],\n                name,\n                i,\n                longNames = this.options.template.indexOf('YYYY') !== -1;\n\n            for (i = this.options.maxYear; i >= this.options.minYear; i--) {\n                name = longNames ? i : (i + '').substring(2);\n                items[this.options.yearDescending ? 'push' : 'unshift']([i, name]);\n            }\n\n            items = this.fillCommon('y').concat(items);\n\n            return items;\n        },\n\n        /*\n        fill hour\n        */\n        fillHour: function fillHour() {\n            var items = this.fillCommon('h'),\n                name,\n                i,\n                h12 = this.options.template.indexOf('h') !== -1,\n                h24 = this.options.template.indexOf('H') !== -1,\n                twoDigit = this.options.template.toLowerCase().indexOf('hh') !== -1,\n                min = h12 ? 1 : 0,\n                max = h12 ? 12 : 23;\n\n            for (i = min; i <= max; i++) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill minute\n        */\n        fillMinute: function fillMinute() {\n            var items = this.fillCommon('m'),\n                name,\n                i,\n                twoDigit = this.options.template.indexOf('mm') !== -1;\n\n            for (i = 0; i <= 59; i += this.options.minuteStep) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill second\n        */\n        fillSecond: function fillSecond() {\n            var items = this.fillCommon('s'),\n                name,\n                i,\n                twoDigit = this.options.template.indexOf('ss') !== -1;\n\n            for (i = 0; i <= 59; i += this.options.secondStep) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill ampm\n        */\n        fillAmpm: function fillAmpm() {\n            var ampmL = this.options.template.indexOf('a') !== -1,\n                ampmU = this.options.template.indexOf('A') !== -1,\n                items = [['am', ampmL ? 'am' : 'AM'], ['pm', ampmL ? 'pm' : 'PM']];\n            return items;\n        },\n\n        /*\n         Returns current date value from combos. \n         If format not specified - `options.format` used.\n         If format = `null` - Moment object returned.\n        */\n        getValue: function getValue(format) {\n            var dt,\n                values = {},\n                that = this,\n                notSelected = false;\n\n            //getting selected values    \n            $.each(this.map, function (k, v) {\n                if (k === 'ampm') {\n                    return;\n                }\n                var def = k === 'day' ? 1 : 0;\n\n                values[k] = that['$' + k] ? parseInt(that['$' + k].val(), 10) : def;\n\n                if (isNaN(values[k])) {\n                    notSelected = true;\n                    return false;\n                }\n            });\n\n            //if at least one visible combo not selected - return empty string\n            if (notSelected) {\n                return '';\n            }\n\n            //convert hours 12h --\x3e 24h \n            if (this.$ampm) {\n                //12:00 pm --\x3e 12:00 (24-h format, midday), 12:00 am --\x3e 00:00 (24-h format, midnight, start of day)\n                if (values.hour === 12) {\n                    values.hour = this.$ampm.val() === 'am' ? 0 : 12;\n                } else {\n                    values.hour = this.$ampm.val() === 'am' ? values.hour : values.hour + 12;\n                }\n            }\n\n            dt = moment([values.year, values.month, values.day, values.hour, values.minute, values.second]);\n\n            //highlight invalid date\n            this.highlight(dt);\n\n            format = format === undefined ? this.options.format : format;\n            if (format === null) {\n                return dt.isValid() ? dt : null;\n            } else {\n                return dt.isValid() ? dt.format(format) : '';\n            }\n        },\n\n        setValue: function setValue(value) {\n            if (!value) {\n                return;\n            }\n\n            var dt = typeof value === 'string' ? moment(value, this.options.format) : moment(value),\n                that = this,\n                values = {};\n\n            //function to find nearest value in select options\n            function getNearest($select, value) {\n                var delta = {};\n                $select.children('option').each(function (i, opt) {\n                    var optValue = $(opt).attr('value'),\n                        distance;\n\n                    if (optValue === '') return;\n                    distance = Math.abs(optValue - value);\n                    if (typeof delta.distance === 'undefined' || distance < delta.distance) {\n                        delta = { value: optValue, distance: distance };\n                    }\n                });\n                return delta.value;\n            }\n\n            if (dt.isValid()) {\n                //read values from date object\n                $.each(this.map, function (k, v) {\n                    if (k === 'ampm') {\n                        return;\n                    }\n                    values[k] = dt[v[1]]();\n                });\n\n                if (this.$ampm) {\n                    //12:00 pm --\x3e 12:00 (24-h format, midday), 12:00 am --\x3e 00:00 (24-h format, midnight, start of day)\n                    if (values.hour >= 12) {\n                        values.ampm = 'pm';\n                        if (values.hour > 12) {\n                            values.hour -= 12;\n                        }\n                    } else {\n                        values.ampm = 'am';\n                        if (values.hour === 0) {\n                            values.hour = 12;\n                        }\n                    }\n                }\n\n                $.each(values, function (k, v) {\n                    //call val() for each existing combo, e.g. this.$hour.val()\n                    if (that['$' + k]) {\n\n                        if (k === 'minute' && that.options.minuteStep > 1 && that.options.roundTime) {\n                            v = getNearest(that['$' + k], v);\n                        }\n\n                        if (k === 'second' && that.options.secondStep > 1 && that.options.roundTime) {\n                            v = getNearest(that['$' + k], v);\n                        }\n\n                        that['$' + k].val(v);\n                    }\n                });\n\n                // update days count\n                if (this.options.smartDays) {\n                    this.fillCombo('day');\n                }\n\n                this.$element.val(dt.format(this.options.format)).change();\n            }\n        },\n\n        /*\n         highlight combos if date is invalid\n        */\n        highlight: function highlight(dt) {\n            if (!dt.isValid()) {\n                if (this.options.errorClass) {\n                    this.$widget.addClass(this.options.errorClass);\n                } else {\n                    //store original border color\n                    if (!this.borderColor) {\n                        this.borderColor = this.$widget.find('select').css('border-color');\n                    }\n                    this.$widget.find('select').css('border-color', 'red');\n                }\n            } else {\n                if (this.options.errorClass) {\n                    this.$widget.removeClass(this.options.errorClass);\n                } else {\n                    this.$widget.find('select').css('border-color', this.borderColor);\n                }\n            }\n        },\n\n        leadZero: function leadZero(v) {\n            return v <= 9 ? '0' + v : v;\n        },\n\n        destroy: function destroy() {\n            this.$widget.remove();\n            this.$element.removeData('combodate').show();\n        }\n\n        //todo: clear method        \n    };\n\n    $.fn.combodate = function (option) {\n        var d,\n            args = Array.apply(null, arguments);\n        args.shift();\n\n        //getValue returns date as string / object (not jQuery object)\n        if (option === 'getValue' && this.length && (d = this.eq(0).data('combodate'))) {\n            return d.getValue.apply(d, args);\n        }\n\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data('combodate'),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option;\n            if (!data) {\n                $this.data('combodate', data = new Combodate(this, options));\n            }\n            if (typeof option == 'string' && typeof data[option] == 'function') {\n                data[option].apply(data, args);\n            }\n        });\n    };\n\n    $.fn.combodate.defaults = {\n        //in this format value stored in original input\n        format: 'DD-MM-YYYY HH:mm',\n        //in this format items in dropdowns are displayed\n        template: 'D / MMM / YYYY   H : mm',\n        //initial value, can be `new Date()`    \n        value: null,\n        minYear: 1970,\n        maxYear: 2015,\n        yearDescending: true,\n        minuteStep: 5,\n        secondStep: 1,\n        firstItem: 'empty', //'name', 'empty', 'none'\n        errorClass: null,\n        roundTime: true, // whether to round minutes and seconds if step > 1\n        smartDays: false // whether days in combo depend on selected month: 31, 30, 28\n    };\n})(window.jQuery);\n/**\nCombodate input - dropdown date and time picker.    \nBased on [combodate](http://vitalets.github.com/combodate) plugin (included). To use it you should manually include [momentjs](http://momentjs.com).\n\n    <script src=\"js/moment.min.js\"><\/script>\n   \nAllows to input:\n\n* only date\n* only time \n* both date and time  \n\nPlease note, that format is taken from momentjs and **not compatible** with bootstrap-datepicker / jquery UI datepicker.  \nInternally value stored as `momentjs` object. \n\n@class combodate\n@extends abstractinput\n@final\n@since 1.4.0\n@example\n<a href=\"#\" id=\"dob\" data-type=\"combodate\" data-pk=\"1\" data-url=\"/post\" data-value=\"1984-05-15\" data-title=\"Select date\"></a>\n<script>\n$(function(){\n    $('#dob').editable({\n        format: 'YYYY-MM-DD',    \n        viewformat: 'DD.MM.YYYY',    \n        template: 'D / MMMM / YYYY',    \n        combodate: {\n                minYear: 2000,\n                maxYear: 2015,\n                minuteStep: 1\n           }\n        }\n    });\n});\n<\/script>\n**/\n\n/*global moment*/\n\n(function ($) {\n    ;\n\n    var Constructor = function Constructor(options) {\n        this.init('combodate', options, Constructor.defaults);\n\n        //by default viewformat equals to format\n        if (!this.options.viewformat) {\n            this.options.viewformat = this.options.format;\n        }\n\n        //try parse combodate config defined as json string in data-combodate\n        options.combodate = $.fn.editableutils.tryParseJson(options.combodate, true);\n\n        //overriding combodate config (as by default jQuery extend() is not recursive)\n        this.options.combodate = $.extend({}, Constructor.defaults.combodate, options.combodate, {\n            format: this.options.format,\n            template: this.options.template\n        });\n    };\n\n    $.fn.editableutils.inherit(Constructor, $.fn.editabletypes.abstractinput);\n\n    $.extend(Constructor.prototype, {\n        render: function render() {\n            this.$input.combodate(this.options.combodate);\n\n            if ($.fn.editableform.engine === 'bs3') {\n                this.$input.siblings().find('select').addClass('form-control');\n            }\n\n            if (this.options.inputclass) {\n                this.$input.siblings().find('select').addClass(this.options.inputclass);\n            }\n            //\"clear\" link\n            /*\n            if(this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function(e){\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n                \n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));  \n            } \n            */\n        },\n\n        value2html: function value2html(value, element) {\n            var text = value ? value.format(this.options.viewformat) : '';\n            //$(element).text(text);\n            Constructor.superclass.value2html.call(this, text, element);\n        },\n\n        html2value: function html2value(html) {\n            return html ? moment(html, this.options.viewformat) : null;\n        },\n\n        value2str: function value2str(value) {\n            return value ? value.format(this.options.format) : '';\n        },\n\n        str2value: function str2value(str) {\n            return str ? moment(str, this.options.format) : null;\n        },\n\n        value2submit: function value2submit(value) {\n            return this.value2str(value);\n        },\n\n        value2input: function value2input(value) {\n            this.$input.combodate('setValue', value);\n        },\n\n        input2value: function input2value() {\n            return this.$input.combodate('getValue', null);\n        },\n\n        activate: function activate() {\n            this.$input.siblings('.combodate').find('select').eq(0).focus();\n        },\n\n        /*\n        clear:  function() {\n           this.$input.data('datepicker').date = null;\n           this.$input.find('.active').removeClass('active');\n        },\n        */\n\n        autosubmit: function autosubmit() {}\n\n    });\n\n    Constructor.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"text\">\n        **/\n        tpl: '<input type=\"text\">',\n        /**\n        @property inputclass \n        @default null\n        **/\n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        See list of tokens in [momentjs docs](http://momentjs.com/docs/#/parsing/string-format)  \n        \n        @property format \n        @type string\n        @default YYYY-MM-DD\n        **/\n        format: 'YYYY-MM-DD',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to `format`.\n        \n        @property viewformat \n        @type string\n        @default null\n        **/\n        viewformat: null,\n        /**\n        Template used for displaying dropdowns.\n        \n        @property template \n        @type string\n        @default D / MMM / YYYY\n        **/\n        template: 'D / MMM / YYYY',\n        /**\n        Configuration of combodate.\n        Full list of options: http://vitalets.github.com/combodate/#docs\n        \n        @property combodate \n        @type object\n        @default null\n        **/\n        combodate: null\n\n        /*\n        (not implemented yet)\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n        \n        @property clear \n        @type boolean|string\n        @default 'x clear'         \n        */\n        //clear: '&times; clear'\n    });\n\n    $.fn.editabletypes.combodate = Constructor;\n})(window.jQuery);\n\n/*\nEditableform based on Twitter Bootstrap 3\n*/\n(function ($) {\n    ;\n\n    //store parent methods\n    var pInitInput = $.fn.editableform.Constructor.prototype.initInput;\n\n    $.extend($.fn.editableform.Constructor.prototype, {\n        initTemplate: function initTemplate() {\n            this.$form = $($.fn.editableform.template);\n            this.$form.find('.control-group').addClass('form-group');\n            this.$form.find('.editable-error-block').addClass('help-block');\n        },\n        initInput: function initInput() {\n            pInitInput.apply(this);\n\n            //for bs3 set default class `input-sm` to standard inputs\n            var emptyInputClass = this.input.options.inputclass === null || this.input.options.inputclass === false;\n            var defaultClass = 'input-sm';\n\n            //bs3 add `form-control` class to standard inputs\n            var stdtypes = 'text,select,textarea,password,email,url,tel,number,range,time,typeaheadjs'.split(',');\n            if (~$.inArray(this.input.type, stdtypes)) {\n                this.input.$input.addClass('form-control');\n                if (emptyInputClass) {\n                    this.input.options.inputclass = defaultClass;\n                    this.input.$input.addClass(defaultClass);\n                }\n            }\n\n            //apply bs3 size class also to buttons (to fit size of control)\n            var $btn = this.$form.find('.editable-buttons');\n            var classes = emptyInputClass ? [defaultClass] : this.input.options.inputclass.split(' ');\n            for (var i = 0; i < classes.length; i++) {\n                // `btn-sm` is default now\n                /*\n                if(classes[i].toLowerCase() === 'input-sm') { \n                    $btn.find('button').addClass('btn-sm');  \n                }\n                */\n                if (classes[i].toLowerCase() === 'input-lg') {\n                    $btn.find('button').removeClass('btn-sm').addClass('btn-lg');\n                }\n            }\n        }\n    });\n\n    //buttons\n    $.fn.editableform.buttons = '<button type=\"submit\" class=\"btn btn-primary btn-sm editable-submit\">' + '<i class=\"fa fa-ok\"></i>' + '</button>' + '<button type=\"button\" class=\"btn btn-default btn-sm editable-cancel\">' + '<i class=\"fa fa-remove\"></i>' + '</button>';\n\n    //error classes\n    $.fn.editableform.errorGroupClass = 'has-error';\n    $.fn.editableform.errorBlockClass = null;\n    //engine\n    $.fn.editableform.engine = 'bs3';\n})(window.jQuery);\n/**\n* Editable Popover3 (for Bootstrap 3) \n* ---------------------\n* requires bootstrap-popover.js\n*/\n(function ($) {\n    ;\n\n    //extend methods\n    $.extend($.fn.editableContainer.Popup.prototype, {\n        containerName: 'popover',\n        containerDataName: 'bs.popover',\n        innerCss: '.popover-content',\n        defaults: $.fn.popover.Constructor.DEFAULTS,\n\n        initContainer: function initContainer() {\n            $.extend(this.containerOptions, {\n                trigger: 'manual',\n                selector: false,\n                content: ' ',\n                template: this.defaults.template\n            });\n\n            //as template property is used in inputs, hide it from popover\n            var t;\n            if (this.$element.data('template')) {\n                t = this.$element.data('template');\n                this.$element.removeData('template');\n            }\n\n            this.call(this.containerOptions);\n\n            if (t) {\n                //restore data('template')\n                this.$element.data('template', t);\n            }\n        },\n\n        /* show */\n        innerShow: function innerShow() {\n            this.call('show');\n        },\n\n        /* hide */\n        innerHide: function innerHide() {\n            this.call('hide');\n        },\n\n        /* destroy */\n        innerDestroy: function innerDestroy() {\n            this.call('destroy');\n        },\n\n        setContainerOption: function setContainerOption(key, value) {\n            this.container().options[key] = value;\n        },\n\n        /**\n        * move popover to new position. This function mainly copied from bootstrap-popover.\n        */\n        /*jshint laxcomma: true, eqeqeq: false*/\n        setPosition: function setPosition() {\n\n            (function () {\n                /*    \n                    var $tip = this.tip()\n                    , inside\n                    , pos\n                    , actualWidth\n                    , actualHeight\n                    , placement\n                    , tp\n                    , tpt\n                    , tpb\n                    , tpl\n                    , tpr;\n                     placement = typeof this.options.placement === 'function' ?\n                    this.options.placement.call(this, $tip[0], this.$element[0]) :\n                    this.options.placement;\n                     inside = /in/.test(placement);\n                   \n                    $tip\n                  //  .detach()\n                  //vitalets: remove any placement class because otherwise they dont influence on re-positioning of visible popover\n                    .removeClass('top right bottom left')\n                    .css({ top: 0, left: 0, display: 'block' });\n                  //  .insertAfter(this.$element);\n                   \n                    pos = this.getPosition(inside);\n                     actualWidth = $tip[0].offsetWidth;\n                    actualHeight = $tip[0].offsetHeight;\n                     placement = inside ? placement.split(' ')[1] : placement;\n                     tpb = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2};\n                    tpt = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2};\n                    tpl = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth};\n                    tpr = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width};\n                     switch (placement) {\n                        case 'bottom':\n                            if ((tpb.top + actualHeight) > ($(window).scrollTop() + $(window).height())) {\n                                if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'top';\n                                } else if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                    placement = 'right';\n                                } else if (tpl.left > $(window).scrollLeft()) {\n                                    placement = 'left';\n                                } else {\n                                    placement = 'right';\n                                }\n                            }\n                            break;\n                        case 'top':\n                            if (tpt.top < $(window).scrollTop()) {\n                                if ((tpb.top + actualHeight) < ($(window).scrollTop() + $(window).height())) {\n                                    placement = 'bottom';\n                                } else if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                    placement = 'right';\n                                } else if (tpl.left > $(window).scrollLeft()) {\n                                    placement = 'left';\n                                } else {\n                                    placement = 'right';\n                                }\n                            }\n                            break;\n                        case 'left':\n                            if (tpl.left < $(window).scrollLeft()) {\n                                if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                    placement = 'right';\n                                } else if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'top';\n                                } else if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'bottom';\n                                } else {\n                                    placement = 'right';\n                                }\n                            }\n                            break;\n                        case 'right':\n                            if ((tpr.left + actualWidth) > ($(window).scrollLeft() + $(window).width())) {\n                                if (tpl.left > $(window).scrollLeft()) {\n                                    placement = 'left';\n                                } else if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'top';\n                                } else if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'bottom';\n                                }\n                            }\n                            break;\n                    }\n                     switch (placement) {\n                        case 'bottom':\n                            tp = tpb;\n                            break;\n                        case 'top':\n                            tp = tpt;\n                            break;\n                        case 'left':\n                            tp = tpl;\n                            break;\n                        case 'right':\n                            tp = tpr;\n                            break;\n                    }\n                     $tip\n                    .offset(tp)\n                    .addClass(placement)\n                    .addClass('in');\n                */\n\n                var $tip = this.tip();\n\n                var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;\n\n                var autoToken = /\\s?auto?\\s?/i;\n                var autoPlace = autoToken.test(placement);\n                if (autoPlace) {\n                    placement = placement.replace(autoToken, '') || 'top';\n                }\n\n                var pos = this.getPosition();\n                var actualWidth = $tip[0].offsetWidth;\n                var actualHeight = $tip[0].offsetHeight;\n\n                if (autoPlace) {\n                    var $parent = this.$element.parent();\n\n                    var orgPlacement = placement;\n                    var docScroll = document.documentElement.scrollTop || document.body.scrollTop;\n                    var parentWidth = this.options.container == 'body' ? window.innerWidth : $parent.outerWidth();\n                    var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight();\n                    var parentLeft = this.options.container == 'body' ? 0 : $parent.offset().left;\n\n                    placement = placement == 'bottom' && pos.top + pos.height + actualHeight - docScroll > parentHeight ? 'top' : placement == 'top' && pos.top - docScroll - actualHeight < 0 ? 'bottom' : placement == 'right' && pos.right + actualWidth > parentWidth ? 'left' : placement == 'left' && pos.left - actualWidth < parentLeft ? 'right' : placement;\n\n                    $tip.removeClass(orgPlacement).addClass(placement);\n                }\n\n                var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);\n\n                this.applyPlacement(calculatedOffset, placement);\n            }).call(this.container());\n            /*jshint laxcomma: false, eqeqeq: true*/\n        }\n    });\n})(window.jQuery);\n\n/* =========================================================\n * bootstrap-datepicker.js\n * http://www.eyecon.ro/bootstrap-datepicker\n * =========================================================\n * Copyright 2012 Stefan Petre\n * Improvements by Andrew Rowls\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ========================================================= */\n\n(function ($) {\n\n    function UTCDate() {\n        return new Date(Date.UTC.apply(Date, arguments));\n    }\n    function UTCToday() {\n        var today = new Date();\n        return UTCDate(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate());\n    }\n\n    // Picker object\n\n    var Datepicker = function Datepicker(element, options) {\n        var that = this;\n\n        this._process_options(options);\n\n        this.element = $(element);\n        this.isInline = false;\n        this.isInput = this.element.is('input');\n        this.component = this.element.is('.date') ? this.element.find('.add-on, .btn') : false;\n        this.hasInput = this.component && this.element.find('input').length;\n        if (this.component && this.component.length === 0) this.component = false;\n\n        this.picker = $(DPGlobal.template);\n        this._buildEvents();\n        this._attachEvents();\n\n        if (this.isInline) {\n            this.picker.addClass('datepicker-inline').appendTo(this.element);\n        } else {\n            this.picker.addClass('datepicker-dropdown dropdown-menu');\n        }\n\n        if (this.o.rtl) {\n            this.picker.addClass('datepicker-rtl');\n            this.picker.find('.prev i, .next i').toggleClass('icon-arrow-left icon-arrow-right');\n        }\n\n        this.viewMode = this.o.startView;\n\n        if (this.o.calendarWeeks) this.picker.find('tfoot th.today').attr('colspan', function (i, val) {\n            return parseInt(val) + 1;\n        });\n\n        this._allow_update = false;\n\n        this.setStartDate(this.o.startDate);\n        this.setEndDate(this.o.endDate);\n        this.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled);\n\n        this.fillDow();\n        this.fillMonths();\n\n        this._allow_update = true;\n\n        this.update();\n        this.showMode();\n\n        if (this.isInline) {\n            this.show();\n        }\n    };\n\n    Datepicker.prototype = {\n        constructor: Datepicker,\n\n        _process_options: function _process_options(opts) {\n            // Store raw options for reference\n            this._o = $.extend({}, this._o, opts);\n            // Processed options\n            var o = this.o = $.extend({}, this._o);\n\n            // Check if \"de-DE\" style date is available, if not language should\n            // fallback to 2 letter code eg \"de\"\n            var lang = o.language;\n            if (!dates[lang]) {\n                lang = lang.split('-')[0];\n                if (!dates[lang]) lang = defaults.language;\n            }\n            o.language = lang;\n\n            switch (o.startView) {\n                case 2:\n                case 'decade':\n                    o.startView = 2;\n                    break;\n                case 1:\n                case 'year':\n                    o.startView = 1;\n                    break;\n                default:\n                    o.startView = 0;\n            }\n\n            switch (o.minViewMode) {\n                case 1:\n                case 'months':\n                    o.minViewMode = 1;\n                    break;\n                case 2:\n                case 'years':\n                    o.minViewMode = 2;\n                    break;\n                default:\n                    o.minViewMode = 0;\n            }\n\n            o.startView = Math.max(o.startView, o.minViewMode);\n\n            o.weekStart %= 7;\n            o.weekEnd = (o.weekStart + 6) % 7;\n\n            var format = DPGlobal.parseFormat(o.format);\n            if (o.startDate !== -Infinity) {\n                o.startDate = DPGlobal.parseDate(o.startDate, format, o.language);\n            }\n            if (o.endDate !== Infinity) {\n                o.endDate = DPGlobal.parseDate(o.endDate, format, o.language);\n            }\n\n            o.daysOfWeekDisabled = o.daysOfWeekDisabled || [];\n            if (!$.isArray(o.daysOfWeekDisabled)) o.daysOfWeekDisabled = o.daysOfWeekDisabled.split(/[,\\s]*/);\n            o.daysOfWeekDisabled = $.map(o.daysOfWeekDisabled, function (d) {\n                return parseInt(d, 10);\n            });\n        },\n        _events: [],\n        _secondaryEvents: [],\n        _applyEvents: function _applyEvents(evs) {\n            for (var i = 0, el, ev; i < evs.length; i++) {\n                el = evs[i][0];\n                ev = evs[i][1];\n                el.on(ev);\n            }\n        },\n        _unapplyEvents: function _unapplyEvents(evs) {\n            for (var i = 0, el, ev; i < evs.length; i++) {\n                el = evs[i][0];\n                ev = evs[i][1];\n                el.off(ev);\n            }\n        },\n        _buildEvents: function _buildEvents() {\n            if (this.isInput) {\n                // single input\n                this._events = [[this.element, {\n                    focus: $.proxy(this.show, this),\n                    keyup: $.proxy(this.update, this),\n                    keydown: $.proxy(this.keydown, this)\n                }]];\n            } else if (this.component && this.hasInput) {\n                // component: input + button\n                this._events = [\n                // For components that are not readonly, allow keyboard nav\n                [this.element.find('input'), {\n                    focus: $.proxy(this.show, this),\n                    keyup: $.proxy(this.update, this),\n                    keydown: $.proxy(this.keydown, this)\n                }], [this.component, {\n                    click: $.proxy(this.show, this)\n                }]];\n            } else if (this.element.is('div')) {\n                // inline datepicker\n                this.isInline = true;\n            } else {\n                this._events = [[this.element, {\n                    click: $.proxy(this.show, this)\n                }]];\n            }\n\n            this._secondaryEvents = [[this.picker, {\n                click: $.proxy(this.click, this)\n            }], [$(window), {\n                resize: $.proxy(this.place, this)\n            }], [$(document), {\n                mousedown: $.proxy(function (e) {\n                    // Clicked outside the datepicker, hide it\n                    if (!(this.element.is(e.target) || this.element.find(e.target).size() || this.picker.is(e.target) || this.picker.find(e.target).size())) {\n                        this.hide();\n                    }\n                }, this)\n            }]];\n        },\n        _attachEvents: function _attachEvents() {\n            this._detachEvents();\n            this._applyEvents(this._events);\n        },\n        _detachEvents: function _detachEvents() {\n            this._unapplyEvents(this._events);\n        },\n        _attachSecondaryEvents: function _attachSecondaryEvents() {\n            this._detachSecondaryEvents();\n            this._applyEvents(this._secondaryEvents);\n        },\n        _detachSecondaryEvents: function _detachSecondaryEvents() {\n            this._unapplyEvents(this._secondaryEvents);\n        },\n        _trigger: function _trigger(event, altdate) {\n            var date = altdate || this.date,\n                local_date = new Date(date.getTime() + date.getTimezoneOffset() * 60000);\n\n            this.element.trigger({\n                type: event,\n                date: local_date,\n                format: $.proxy(function (altformat) {\n                    var format = altformat || this.o.format;\n                    return DPGlobal.formatDate(date, format, this.o.language);\n                }, this)\n            });\n        },\n\n        show: function show(e) {\n            if (!this.isInline) this.picker.appendTo('body');\n            this.picker.show();\n            this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();\n            this.place();\n            this._attachSecondaryEvents();\n            if (e) {\n                e.preventDefault();\n            }\n            this._trigger('show');\n        },\n\n        hide: function hide(e) {\n            if (this.isInline) return;\n            if (!this.picker.is(':visible')) return;\n            this.picker.hide().detach();\n            this._detachSecondaryEvents();\n            this.viewMode = this.o.startView;\n            this.showMode();\n\n            if (this.o.forceParse && (this.isInput && this.element.val() || this.hasInput && this.element.find('input').val())) this.setValue();\n            this._trigger('hide');\n        },\n\n        remove: function remove() {\n            this.hide();\n            this._detachEvents();\n            this._detachSecondaryEvents();\n            this.picker.remove();\n            delete this.element.data().datepicker;\n            if (!this.isInput) {\n                delete this.element.data().date;\n            }\n        },\n\n        getDate: function getDate() {\n            var d = this.getUTCDate();\n            return new Date(d.getTime() + d.getTimezoneOffset() * 60000);\n        },\n\n        getUTCDate: function getUTCDate() {\n            return this.date;\n        },\n\n        setDate: function setDate(d) {\n            this.setUTCDate(new Date(d.getTime() - d.getTimezoneOffset() * 60000));\n        },\n\n        setUTCDate: function setUTCDate(d) {\n            this.date = d;\n            this.setValue();\n        },\n\n        setValue: function setValue() {\n            var formatted = this.getFormattedDate();\n            if (!this.isInput) {\n                if (this.component) {\n                    this.element.find('input').val(formatted);\n                }\n            } else {\n                this.element.val(formatted);\n            }\n        },\n\n        getFormattedDate: function getFormattedDate(format) {\n            if (format === undefined) format = this.o.format;\n            return DPGlobal.formatDate(this.date, format, this.o.language);\n        },\n\n        setStartDate: function setStartDate(startDate) {\n            this._process_options({ startDate: startDate });\n            this.update();\n            this.updateNavArrows();\n        },\n\n        setEndDate: function setEndDate(endDate) {\n            this._process_options({ endDate: endDate });\n            this.update();\n            this.updateNavArrows();\n        },\n\n        setDaysOfWeekDisabled: function setDaysOfWeekDisabled(daysOfWeekDisabled) {\n            this._process_options({ daysOfWeekDisabled: daysOfWeekDisabled });\n            this.update();\n            this.updateNavArrows();\n        },\n\n        place: function place() {\n            if (this.isInline) return;\n            var zIndex = parseInt(this.element.parents().filter(function () {\n                return $(this).css('z-index') != 'auto';\n            }).first().css('z-index')) + 10;\n            var offset = this.component ? this.component.parent().offset() : this.element.offset();\n            var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(true);\n            this.picker.css({\n                top: offset.top + height,\n                left: offset.left,\n                zIndex: zIndex\n            });\n        },\n\n        _allow_update: true,\n        update: function update() {\n            if (!this._allow_update) return;\n\n            var date,\n                fromArgs = false;\n            if (arguments && arguments.length && (typeof arguments[0] === 'string' || arguments[0] instanceof Date)) {\n                date = arguments[0];\n                fromArgs = true;\n            } else {\n                date = this.isInput ? this.element.val() : this.element.data('date') || this.element.find('input').val();\n                delete this.element.data().date;\n            }\n\n            this.date = DPGlobal.parseDate(date, this.o.format, this.o.language);\n\n            if (fromArgs) this.setValue();\n\n            if (this.date < this.o.startDate) {\n                this.viewDate = new Date(this.o.startDate);\n            } else if (this.date > this.o.endDate) {\n                this.viewDate = new Date(this.o.endDate);\n            } else {\n                this.viewDate = new Date(this.date);\n            }\n            this.fill();\n        },\n\n        fillDow: function fillDow() {\n            var dowCnt = this.o.weekStart,\n                html = '<tr>';\n            if (this.o.calendarWeeks) {\n                var cell = '<th class=\"cw\">&nbsp;</th>';\n                html += cell;\n                this.picker.find('.datepicker-days thead tr:first-child').prepend(cell);\n            }\n            while (dowCnt < this.o.weekStart + 7) {\n                html += '<th class=\"dow\">' + dates[this.o.language].daysMin[dowCnt++ % 7] + '</th>';\n            }\n            html += '</tr>';\n            this.picker.find('.datepicker-days thead').append(html);\n        },\n\n        fillMonths: function fillMonths() {\n            var html = '',\n                i = 0;\n            while (i < 12) {\n                html += '<span class=\"month\">' + dates[this.o.language].monthsShort[i++] + '</span>';\n            }\n            this.picker.find('.datepicker-months td').html(html);\n        },\n\n        setRange: function setRange(range) {\n            if (!range || !range.length) delete this.range;else this.range = $.map(range, function (d) {\n                return d.valueOf();\n            });\n            this.fill();\n        },\n\n        getClassNames: function getClassNames(date) {\n            var cls = [],\n                year = this.viewDate.getUTCFullYear(),\n                month = this.viewDate.getUTCMonth(),\n                currentDate = this.date.valueOf(),\n                today = new Date();\n            if (date.getUTCFullYear() < year || date.getUTCFullYear() == year && date.getUTCMonth() < month) {\n                cls.push('old');\n            } else if (date.getUTCFullYear() > year || date.getUTCFullYear() == year && date.getUTCMonth() > month) {\n                cls.push('new');\n            }\n            // Compare internal UTC date with local today, not UTC today\n            if (this.o.todayHighlight && date.getUTCFullYear() == today.getFullYear() && date.getUTCMonth() == today.getMonth() && date.getUTCDate() == today.getDate()) {\n                cls.push('today');\n            }\n            if (currentDate && date.valueOf() == currentDate) {\n                cls.push('active');\n            }\n            if (date.valueOf() < this.o.startDate || date.valueOf() > this.o.endDate || $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1) {\n                cls.push('disabled');\n            }\n            if (this.range) {\n                if (date > this.range[0] && date < this.range[this.range.length - 1]) {\n                    cls.push('range');\n                }\n                if ($.inArray(date.valueOf(), this.range) != -1) {\n                    cls.push('selected');\n                }\n            }\n            return cls;\n        },\n\n        fill: function fill() {\n            var d = new Date(this.viewDate),\n                year = d.getUTCFullYear(),\n                month = d.getUTCMonth(),\n                startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,\n                startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,\n                endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,\n                endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,\n                currentDate = this.date && this.date.valueOf(),\n                tooltip;\n            this.picker.find('.datepicker-days thead th.datepicker-switch').text(dates[this.o.language].months[month] + ' ' + year);\n            this.picker.find('tfoot th.today').text(dates[this.o.language].today).toggle(this.o.todayBtn !== false);\n            this.picker.find('tfoot th.clear').text(dates[this.o.language].clear).toggle(this.o.clearBtn !== false);\n            this.updateNavArrows();\n            this.fillMonths();\n            var prevMonth = UTCDate(year, month - 1, 28, 0, 0, 0, 0),\n                day = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());\n            prevMonth.setUTCDate(day);\n            prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7) % 7);\n            var nextMonth = new Date(prevMonth);\n            nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);\n            nextMonth = nextMonth.valueOf();\n            var html = [];\n            var clsName;\n            while (prevMonth.valueOf() < nextMonth) {\n                if (prevMonth.getUTCDay() == this.o.weekStart) {\n                    html.push('<tr>');\n                    if (this.o.calendarWeeks) {\n                        // ISO 8601: First week contains first thursday.\n                        // ISO also states week starts on Monday, but we can be more abstract here.\n                        var\n                        // Start of current week: based on weekstart/current date\n                        ws = new Date(+prevMonth + (this.o.weekStart - prevMonth.getUTCDay() - 7) % 7 * 864e5),\n\n                        // Thursday of this week\n                        th = new Date(+ws + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),\n\n                        // First Thursday of year, year from thursday\n                        yth = new Date(+(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay()) % 7 * 864e5),\n\n                        // Calendar week: ms between thursdays, div ms per day, div 7 days\n                        calWeek = (th - yth) / 864e5 / 7 + 1;\n                        html.push('<td class=\"cw\">' + calWeek + '</td>');\n                    }\n                }\n                clsName = this.getClassNames(prevMonth);\n                clsName.push('day');\n\n                var before = this.o.beforeShowDay(prevMonth);\n                if (before === undefined) before = {};else if (typeof before === 'boolean') before = { enabled: before };else if (typeof before === 'string') before = { classes: before };\n                if (before.enabled === false) clsName.push('disabled');\n                if (before.classes) clsName = clsName.concat(before.classes.split(/\\s+/));\n                if (before.tooltip) tooltip = before.tooltip;\n\n                clsName = $.unique(clsName);\n                html.push('<td class=\"' + clsName.join(' ') + '\"' + (tooltip ? ' title=\"' + tooltip + '\"' : '') + '>' + prevMonth.getUTCDate() + '</td>');\n                if (prevMonth.getUTCDay() == this.o.weekEnd) {\n                    html.push('</tr>');\n                }\n                prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);\n            }\n            this.picker.find('.datepicker-days tbody').empty().append(html.join(''));\n            var currentYear = this.date && this.date.getUTCFullYear();\n\n            var months = this.picker.find('.datepicker-months').find('th:eq(1)').text(year).end().find('span').removeClass('active');\n            if (currentYear && currentYear == year) {\n                months.eq(this.date.getUTCMonth()).addClass('active');\n            }\n            if (year < startYear || year > endYear) {\n                months.addClass('disabled');\n            }\n            if (year == startYear) {\n                months.slice(0, startMonth).addClass('disabled');\n            }\n            if (year == endYear) {\n                months.slice(endMonth + 1).addClass('disabled');\n            }\n\n            html = '';\n            year = parseInt(year / 10, 10) * 10;\n            var yearCont = this.picker.find('.datepicker-years').find('th:eq(1)').text(year + '-' + (year + 9)).end().find('td');\n            year -= 1;\n            for (var i = -1; i < 11; i++) {\n                html += '<span class=\"year' + (i == -1 ? ' old' : i == 10 ? ' new' : '') + (currentYear == year ? ' active' : '') + (year < startYear || year > endYear ? ' disabled' : '') + '\">' + year + '</span>';\n                year += 1;\n            }\n            yearCont.html(html);\n        },\n\n        updateNavArrows: function updateNavArrows() {\n            if (!this._allow_update) return;\n\n            var d = new Date(this.viewDate),\n                year = d.getUTCFullYear(),\n                month = d.getUTCMonth();\n            switch (this.viewMode) {\n                case 0:\n                    if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear() && month <= this.o.startDate.getUTCMonth()) {\n                        this.picker.find('.prev').css({ visibility: 'hidden' });\n                    } else {\n                        this.picker.find('.prev').css({ visibility: 'visible' });\n                    }\n                    if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear() && month >= this.o.endDate.getUTCMonth()) {\n                        this.picker.find('.next').css({ visibility: 'hidden' });\n                    } else {\n                        this.picker.find('.next').css({ visibility: 'visible' });\n                    }\n                    break;\n                case 1:\n                case 2:\n                    if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear()) {\n                        this.picker.find('.prev').css({ visibility: 'hidden' });\n                    } else {\n                        this.picker.find('.prev').css({ visibility: 'visible' });\n                    }\n                    if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear()) {\n                        this.picker.find('.next').css({ visibility: 'hidden' });\n                    } else {\n                        this.picker.find('.next').css({ visibility: 'visible' });\n                    }\n                    break;\n            }\n        },\n\n        click: function click(e) {\n            e.preventDefault();\n            var target = $(e.target).closest('span, td, th');\n            if (target.length == 1) {\n                switch (target[0].nodeName.toLowerCase()) {\n                    case 'th':\n                        switch (target[0].className) {\n                            case 'datepicker-switch':\n                                this.showMode(1);\n                                break;\n                            case 'prev':\n                            case 'next':\n                                var dir = DPGlobal.modes[this.viewMode].navStep * (target[0].className == 'prev' ? -1 : 1);\n                                switch (this.viewMode) {\n                                    case 0:\n                                        this.viewDate = this.moveMonth(this.viewDate, dir);\n                                        break;\n                                    case 1:\n                                    case 2:\n                                        this.viewDate = this.moveYear(this.viewDate, dir);\n                                        break;\n                                }\n                                this.fill();\n                                break;\n                            case 'today':\n                                var date = new Date();\n                                date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\n\n                                this.showMode(-2);\n                                var which = this.o.todayBtn == 'linked' ? null : 'view';\n                                this._setDate(date, which);\n                                break;\n                            case 'clear':\n                                var element;\n                                if (this.isInput) element = this.element;else if (this.component) element = this.element.find('input');\n                                if (element) element.val(\"\").change();\n                                this._trigger('changeDate');\n                                this.update();\n                                if (this.o.autoclose) this.hide();\n                                break;\n                        }\n                        break;\n                    case 'span':\n                        if (!target.is('.disabled')) {\n                            this.viewDate.setUTCDate(1);\n                            if (target.is('.month')) {\n                                var day = 1;\n                                var month = target.parent().find('span').index(target);\n                                var year = this.viewDate.getUTCFullYear();\n                                this.viewDate.setUTCMonth(month);\n                                this._trigger('changeMonth', this.viewDate);\n                                if (this.o.minViewMode === 1) {\n                                    this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));\n                                }\n                            } else {\n                                var year = parseInt(target.text(), 10) || 0;\n                                var day = 1;\n                                var month = 0;\n                                this.viewDate.setUTCFullYear(year);\n                                this._trigger('changeYear', this.viewDate);\n                                if (this.o.minViewMode === 2) {\n                                    this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));\n                                }\n                            }\n                            this.showMode(-1);\n                            this.fill();\n                        }\n                        break;\n                    case 'td':\n                        if (target.is('.day') && !target.is('.disabled')) {\n                            var day = parseInt(target.text(), 10) || 1;\n                            var year = this.viewDate.getUTCFullYear(),\n                                month = this.viewDate.getUTCMonth();\n                            if (target.is('.old')) {\n                                if (month === 0) {\n                                    month = 11;\n                                    year -= 1;\n                                } else {\n                                    month -= 1;\n                                }\n                            } else if (target.is('.new')) {\n                                if (month == 11) {\n                                    month = 0;\n                                    year += 1;\n                                } else {\n                                    month += 1;\n                                }\n                            }\n                            this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));\n                        }\n                        break;\n                }\n            }\n        },\n\n        _setDate: function _setDate(date, which) {\n            if (!which || which == 'date') this.date = new Date(date);\n            if (!which || which == 'view') this.viewDate = new Date(date);\n            this.fill();\n            this.setValue();\n            this._trigger('changeDate');\n            var element;\n            if (this.isInput) {\n                element = this.element;\n            } else if (this.component) {\n                element = this.element.find('input');\n            }\n            if (element) {\n                element.change();\n                if (this.o.autoclose && (!which || which == 'date')) {\n                    this.hide();\n                }\n            }\n        },\n\n        moveMonth: function moveMonth(date, dir) {\n            if (!dir) return date;\n            var new_date = new Date(date.valueOf()),\n                day = new_date.getUTCDate(),\n                month = new_date.getUTCMonth(),\n                mag = Math.abs(dir),\n                new_month,\n                test;\n            dir = dir > 0 ? 1 : -1;\n            if (mag == 1) {\n                test = dir == -1\n                // If going back one month, make sure month is not current month\n                // (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)\n                ? function () {\n                    return new_date.getUTCMonth() == month;\n                }\n                // If going forward one month, make sure month is as expected\n                // (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)\n                : function () {\n                    return new_date.getUTCMonth() != new_month;\n                };\n                new_month = month + dir;\n                new_date.setUTCMonth(new_month);\n                // Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11\n                if (new_month < 0 || new_month > 11) new_month = (new_month + 12) % 12;\n            } else {\n                // For magnitudes >1, move one month at a time...\n                for (var i = 0; i < mag; i++) {\n                    // ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...\n                    new_date = this.moveMonth(new_date, dir);\n                } // ...then reset the day, keeping it in the new month\n                new_month = new_date.getUTCMonth();\n                new_date.setUTCDate(day);\n                test = function test() {\n                    return new_month != new_date.getUTCMonth();\n                };\n            }\n            // Common date-resetting loop -- if date is beyond end of month, make it\n            // end of month\n            while (test()) {\n                new_date.setUTCDate(--day);\n                new_date.setUTCMonth(new_month);\n            }\n            return new_date;\n        },\n\n        moveYear: function moveYear(date, dir) {\n            return this.moveMonth(date, dir * 12);\n        },\n\n        dateWithinRange: function dateWithinRange(date) {\n            return date >= this.o.startDate && date <= this.o.endDate;\n        },\n\n        keydown: function keydown(e) {\n            if (this.picker.is(':not(:visible)')) {\n                if (e.keyCode == 27) // allow escape to hide and re-show picker\n                    this.show();\n                return;\n            }\n            var dateChanged = false,\n                dir,\n                day,\n                month,\n                newDate,\n                newViewDate;\n            switch (e.keyCode) {\n                case 27:\n                    // escape\n                    this.hide();\n                    e.preventDefault();\n                    break;\n                case 37: // left\n                case 39:\n                    // right\n                    if (!this.o.keyboardNavigation) break;\n                    dir = e.keyCode == 37 ? -1 : 1;\n                    if (e.ctrlKey) {\n                        newDate = this.moveYear(this.date, dir);\n                        newViewDate = this.moveYear(this.viewDate, dir);\n                    } else if (e.shiftKey) {\n                        newDate = this.moveMonth(this.date, dir);\n                        newViewDate = this.moveMonth(this.viewDate, dir);\n                    } else {\n                        newDate = new Date(this.date);\n                        newDate.setUTCDate(this.date.getUTCDate() + dir);\n                        newViewDate = new Date(this.viewDate);\n                        newViewDate.setUTCDate(this.viewDate.getUTCDate() + dir);\n                    }\n                    if (this.dateWithinRange(newDate)) {\n                        this.date = newDate;\n                        this.viewDate = newViewDate;\n                        this.setValue();\n                        this.update();\n                        e.preventDefault();\n                        dateChanged = true;\n                    }\n                    break;\n                case 38: // up\n                case 40:\n                    // down\n                    if (!this.o.keyboardNavigation) break;\n                    dir = e.keyCode == 38 ? -1 : 1;\n                    if (e.ctrlKey) {\n                        newDate = this.moveYear(this.date, dir);\n                        newViewDate = this.moveYear(this.viewDate, dir);\n                    } else if (e.shiftKey) {\n                        newDate = this.moveMonth(this.date, dir);\n                        newViewDate = this.moveMonth(this.viewDate, dir);\n                    } else {\n                        newDate = new Date(this.date);\n                        newDate.setUTCDate(this.date.getUTCDate() + dir * 7);\n                        newViewDate = new Date(this.viewDate);\n                        newViewDate.setUTCDate(this.viewDate.getUTCDate() + dir * 7);\n                    }\n                    if (this.dateWithinRange(newDate)) {\n                        this.date = newDate;\n                        this.viewDate = newViewDate;\n                        this.setValue();\n                        this.update();\n                        e.preventDefault();\n                        dateChanged = true;\n                    }\n                    break;\n                case 13:\n                    // enter\n                    this.hide();\n                    e.preventDefault();\n                    break;\n                case 9:\n                    // tab\n                    this.hide();\n                    break;\n            }\n            if (dateChanged) {\n                this._trigger('changeDate');\n                var element;\n                if (this.isInput) {\n                    element = this.element;\n                } else if (this.component) {\n                    element = this.element.find('input');\n                }\n                if (element) {\n                    element.change();\n                }\n            }\n        },\n\n        showMode: function showMode(dir) {\n            if (dir) {\n                this.viewMode = Math.max(this.o.minViewMode, Math.min(2, this.viewMode + dir));\n            }\n            /*\n            \tvitalets: fixing bug of very special conditions:\n            \tjquery 1.7.1 + webkit + show inline datepicker in bootstrap popover.\n            \tMethod show() does not set display css correctly and datepicker is not shown.\n            \tChanged to .css('display', 'block') solve the problem.\n            \tSee https://github.com/vitalets/x-editable/issues/37\n            \t\tIn jquery 1.7.2+ everything works fine.\n            */\n            //this.picker.find('>div').hide().filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName).show();\n            this.picker.find('>div').hide().filter('.datepicker-' + DPGlobal.modes[this.viewMode].clsName).css('display', 'block');\n            this.updateNavArrows();\n        }\n    };\n\n    var DateRangePicker = function DateRangePicker(element, options) {\n        this.element = $(element);\n        this.inputs = $.map(options.inputs, function (i) {\n            return i.jquery ? i[0] : i;\n        });\n        delete options.inputs;\n\n        $(this.inputs).datepicker(options).bind('changeDate', $.proxy(this.dateUpdated, this));\n\n        this.pickers = $.map(this.inputs, function (i) {\n            return $(i).data('datepicker');\n        });\n        this.updateDates();\n    };\n    DateRangePicker.prototype = {\n        updateDates: function updateDates() {\n            this.dates = $.map(this.pickers, function (i) {\n                return i.date;\n            });\n            this.updateRanges();\n        },\n        updateRanges: function updateRanges() {\n            var range = $.map(this.dates, function (d) {\n                return d.valueOf();\n            });\n            $.each(this.pickers, function (i, p) {\n                p.setRange(range);\n            });\n        },\n        dateUpdated: function dateUpdated(e) {\n            var dp = $(e.target).data('datepicker'),\n                new_date = dp.getUTCDate(),\n                i = $.inArray(e.target, this.inputs),\n                l = this.inputs.length;\n            if (i == -1) return;\n\n            if (new_date < this.dates[i]) {\n                // Date being moved earlier/left\n                while (i >= 0 && new_date < this.dates[i]) {\n                    this.pickers[i--].setUTCDate(new_date);\n                }\n            } else if (new_date > this.dates[i]) {\n                // Date being moved later/right\n                while (i < l && new_date > this.dates[i]) {\n                    this.pickers[i++].setUTCDate(new_date);\n                }\n            }\n            this.updateDates();\n        },\n        remove: function remove() {\n            $.map(this.pickers, function (p) {\n                p.remove();\n            });\n            delete this.element.data().datepicker;\n        }\n    };\n\n    function opts_from_el(el, prefix) {\n        // Derive options from element data-attrs\n        var data = $(el).data(),\n            out = {},\n            inkey,\n            replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])'),\n            prefix = new RegExp('^' + prefix.toLowerCase());\n        for (var key in data) {\n            if (prefix.test(key)) {\n                inkey = key.replace(replace, function (_, a) {\n                    return a.toLowerCase();\n                });\n                out[inkey] = data[key];\n            }\n        }return out;\n    }\n\n    function opts_from_locale(lang) {\n        // Derive options from locale plugins\n        var out = {};\n        // Check if \"de-DE\" style date is available, if not language should\n        // fallback to 2 letter code eg \"de\"\n        if (!dates[lang]) {\n            lang = lang.split('-')[0];\n            if (!dates[lang]) return;\n        }\n        var d = dates[lang];\n        $.each(locale_opts, function (i, k) {\n            if (k in d) out[k] = d[k];\n        });\n        return out;\n    }\n\n    var old = $.fn.datepicker;\n    var datepicker = $.fn.datepicker = function (option) {\n        var args = Array.apply(null, arguments);\n        args.shift();\n        var internal_return, this_return;\n        this.each(function () {\n            var $this = $(this),\n                data = $this.data('datepicker'),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option;\n            if (!data) {\n                var elopts = opts_from_el(this, 'date'),\n\n                // Preliminary otions\n                xopts = $.extend({}, defaults, elopts, options),\n                    locopts = opts_from_locale(xopts.language),\n\n                // Options priority: js args, data-attrs, locales, defaults\n                opts = $.extend({}, defaults, locopts, elopts, options);\n                if ($this.is('.input-daterange') || opts.inputs) {\n                    var ropts = {\n                        inputs: opts.inputs || $this.find('input').toArray()\n                    };\n                    $this.data('datepicker', data = new DateRangePicker(this, $.extend(opts, ropts)));\n                } else {\n                    $this.data('datepicker', data = new Datepicker(this, opts));\n                }\n            }\n            if (typeof option == 'string' && typeof data[option] == 'function') {\n                internal_return = data[option].apply(data, args);\n                if (internal_return !== undefined) return false;\n            }\n        });\n        if (internal_return !== undefined) return internal_return;else return this;\n    };\n\n    var defaults = $.fn.datepicker.defaults = {\n        autoclose: false,\n        beforeShowDay: $.noop,\n        calendarWeeks: false,\n        clearBtn: false,\n        daysOfWeekDisabled: [],\n        endDate: Infinity,\n        forceParse: true,\n        format: 'mm/dd/yyyy',\n        keyboardNavigation: true,\n        language: 'en',\n        minViewMode: 0,\n        rtl: false,\n        startDate: -Infinity,\n        startView: 0,\n        todayBtn: false,\n        todayHighlight: false,\n        weekStart: 0\n    };\n    var locale_opts = $.fn.datepicker.locale_opts = ['format', 'rtl', 'weekStart'];\n    $.fn.datepicker.Constructor = Datepicker;\n    var dates = $.fn.datepicker.dates = {\n        en: {\n            days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\n            daysShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\n            daysMin: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\", \"Su\"],\n            months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n            monthsShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n            today: \"Today\",\n            clear: \"Clear\"\n        }\n    };\n\n    var DPGlobal = {\n        modes: [{\n            clsName: 'days',\n            navFnc: 'Month',\n            navStep: 1\n        }, {\n            clsName: 'months',\n            navFnc: 'FullYear',\n            navStep: 1\n        }, {\n            clsName: 'years',\n            navFnc: 'FullYear',\n            navStep: 10\n        }],\n        isLeapYear: function isLeapYear(year) {\n            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n        },\n        getDaysInMonth: function getDaysInMonth(year, month) {\n            return [31, DPGlobal.isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n        },\n        validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,\n        nonpunctuation: /[^ -\\/:-@\\[\\u3400-\\u9fff-`{-~\\t\\n\\r]+/g,\n        parseFormat: function parseFormat(format) {\n            // IE treats \\0 as a string end in inputs (truncating the value),\n            // so it's a bad format delimiter, anyway\n            var separators = format.replace(this.validParts, '\\0').split('\\0'),\n                parts = format.match(this.validParts);\n            if (!separators || !separators.length || !parts || parts.length === 0) {\n                throw new Error(\"Invalid date format.\");\n            }\n            return { separators: separators, parts: parts };\n        },\n        parseDate: function parseDate(date, format, language) {\n            if (date instanceof Date) return date;\n            if (typeof format === 'string') format = DPGlobal.parseFormat(format);\n            if (/^[\\-+]\\d+[dmwy]([\\s,]+[\\-+]\\d+[dmwy])*$/.test(date)) {\n                var part_re = /([\\-+]\\d+)([dmwy])/,\n                    parts = date.match(/([\\-+]\\d+)([dmwy])/g),\n                    part,\n                    dir;\n                date = new Date();\n                for (var i = 0; i < parts.length; i++) {\n                    part = part_re.exec(parts[i]);\n                    dir = parseInt(part[1]);\n                    switch (part[2]) {\n                        case 'd':\n                            date.setUTCDate(date.getUTCDate() + dir);\n                            break;\n                        case 'm':\n                            date = Datepicker.prototype.moveMonth.call(Datepicker.prototype, date, dir);\n                            break;\n                        case 'w':\n                            date.setUTCDate(date.getUTCDate() + dir * 7);\n                            break;\n                        case 'y':\n                            date = Datepicker.prototype.moveYear.call(Datepicker.prototype, date, dir);\n                            break;\n                    }\n                }\n                return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);\n            }\n            var parts = date && date.match(this.nonpunctuation) || [],\n                date = new Date(),\n                parsed = {},\n                setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],\n                setters_map = {\n                yyyy: function yyyy(d, v) {\n                    return d.setUTCFullYear(v);\n                },\n                yy: function yy(d, v) {\n                    return d.setUTCFullYear(2000 + v);\n                },\n                m: function m(d, v) {\n                    v -= 1;\n                    while (v < 0) {\n                        v += 12;\n                    }v %= 12;\n                    d.setUTCMonth(v);\n                    while (d.getUTCMonth() != v) {\n                        d.setUTCDate(d.getUTCDate() - 1);\n                    }return d;\n                },\n                d: function d(_d, v) {\n                    return _d.setUTCDate(v);\n                }\n            },\n                val,\n                filtered,\n                part;\n            setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];\n            setters_map['dd'] = setters_map['d'];\n            date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\n            var fparts = format.parts.slice();\n            // Remove noop parts\n            if (parts.length != fparts.length) {\n                fparts = $(fparts).filter(function (i, p) {\n                    return $.inArray(p, setters_order) !== -1;\n                }).toArray();\n            }\n            // Process remainder\n            if (parts.length == fparts.length) {\n                for (var i = 0, cnt = fparts.length; i < cnt; i++) {\n                    val = parseInt(parts[i], 10);\n                    part = fparts[i];\n                    if (isNaN(val)) {\n                        switch (part) {\n                            case 'MM':\n                                filtered = $(dates[language].months).filter(function () {\n                                    var m = this.slice(0, parts[i].length),\n                                        p = parts[i].slice(0, m.length);\n                                    return m == p;\n                                });\n                                val = $.inArray(filtered[0], dates[language].months) + 1;\n                                break;\n                            case 'M':\n                                filtered = $(dates[language].monthsShort).filter(function () {\n                                    var m = this.slice(0, parts[i].length),\n                                        p = parts[i].slice(0, m.length);\n                                    return m == p;\n                                });\n                                val = $.inArray(filtered[0], dates[language].monthsShort) + 1;\n                                break;\n                        }\n                    }\n                    parsed[part] = val;\n                }\n                for (var i = 0, s; i < setters_order.length; i++) {\n                    s = setters_order[i];\n                    if (s in parsed && !isNaN(parsed[s])) setters_map[s](date, parsed[s]);\n                }\n            }\n            return date;\n        },\n        formatDate: function formatDate(date, format, language) {\n            if (typeof format === 'string') format = DPGlobal.parseFormat(format);\n            var val = {\n                d: date.getUTCDate(),\n                D: dates[language].daysShort[date.getUTCDay()],\n                DD: dates[language].days[date.getUTCDay()],\n                m: date.getUTCMonth() + 1,\n                M: dates[language].monthsShort[date.getUTCMonth()],\n                MM: dates[language].months[date.getUTCMonth()],\n                yy: date.getUTCFullYear().toString().substring(2),\n                yyyy: date.getUTCFullYear()\n            };\n            val.dd = (val.d < 10 ? '0' : '') + val.d;\n            val.mm = (val.m < 10 ? '0' : '') + val.m;\n            var date = [],\n                seps = $.extend([], format.separators);\n            for (var i = 0, cnt = format.parts.length; i <= cnt; i++) {\n                if (seps.length) date.push(seps.shift());\n                date.push(val[format.parts[i]]);\n            }\n            return date.join('');\n        },\n        headTemplate: '<thead>' + '<tr>' + '<th class=\"prev\"><i class=\"icon-arrow-left\"/></th>' + '<th colspan=\"5\" class=\"datepicker-switch\"></th>' + '<th class=\"next\"><i class=\"icon-arrow-right\"/></th>' + '</tr>' + '</thead>',\n        contTemplate: '<tbody><tr><td colspan=\"7\"></td></tr></tbody>',\n        footTemplate: '<tfoot><tr><th colspan=\"7\" class=\"today\"></th></tr><tr><th colspan=\"7\" class=\"clear\"></th></tr></tfoot>'\n    };\n    DPGlobal.template = '<div class=\"datepicker\">' + '<div class=\"datepicker-days\">' + '<table class=\" table-condensed\">' + DPGlobal.headTemplate + '<tbody></tbody>' + DPGlobal.footTemplate + '</table>' + '</div>' + '<div class=\"datepicker-months\">' + '<table class=\"table-condensed\">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table>' + '</div>' + '<div class=\"datepicker-years\">' + '<table class=\"table-condensed\">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table>' + '</div>' + '</div>';\n\n    $.fn.datepicker.DPGlobal = DPGlobal;\n\n    /* DATEPICKER NO CONFLICT\n    * =================== */\n\n    $.fn.datepicker.noConflict = function () {\n        $.fn.datepicker = old;\n        return this;\n    };\n\n    /* DATEPICKER DATA-API\n    * ================== */\n\n    $(document).on('focus.datepicker.data-api click.datepicker.data-api', '[data-provide=\"datepicker\"]', function (e) {\n        var $this = $(this);\n        if ($this.data('datepicker')) return;\n        e.preventDefault();\n        // component click requires us to explicitly show it\n        datepicker.call($this, 'show');\n    });\n    $(function () {\n        //$('[data-provide=\"datepicker-inline\"]').datepicker();\n        //vit: changed to support noConflict()\n        datepicker.call($('[data-provide=\"datepicker-inline\"]'));\n    });\n})(window.jQuery);\n\n/**\nBootstrap-datepicker.  \nDescription and examples: https://github.com/eternicode/bootstrap-datepicker.  \nFor **i18n** you should include js file from here: https://github.com/eternicode/bootstrap-datepicker/tree/master/js/locales\nand set `language` option.  \nSince 1.4.0 date has different appearance in **popup** and **inline** modes. \n\n@class date\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"dob\" data-type=\"date\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select date\">15/05/1984</a>\n<script>\n$(function(){\n    $('#dob').editable({\n        format: 'yyyy-mm-dd',    \n        viewformat: 'dd/mm/yyyy',    \n        datepicker: {\n                weekStart: 1\n           }\n        }\n    });\n});\n<\/script>\n**/\n(function ($) {\n    ;\n\n    //store bootstrap-datepicker as bdateicker to exclude conflict with jQuery UI one\n    $.fn.bdatepicker = $.fn.datepicker.noConflict();\n    if (!$.fn.datepicker) {\n        //if there were no other datepickers, keep also original name\n        $.fn.datepicker = $.fn.bdatepicker;\n    }\n\n    var Date = function Date(options) {\n        this.init('date', options, Date.defaults);\n        this.initPicker(options, Date.defaults);\n    };\n\n    $.fn.editableutils.inherit(Date, $.fn.editabletypes.abstractinput);\n\n    $.extend(Date.prototype, {\n        initPicker: function initPicker(options, defaults) {\n            //'format' is set directly from settings or data-* attributes\n\n            //by default viewformat equals to format\n            if (!this.options.viewformat) {\n                this.options.viewformat = this.options.format;\n            }\n\n            //try parse datepicker config defined as json string in data-datepicker\n            options.datepicker = $.fn.editableutils.tryParseJson(options.datepicker, true);\n\n            //overriding datepicker config (as by default jQuery extend() is not recursive)\n            //since 1.4 datepicker internally uses viewformat instead of format. Format is for submit only\n            this.options.datepicker = $.extend({}, defaults.datepicker, options.datepicker, {\n                format: this.options.viewformat\n            });\n\n            //language\n            this.options.datepicker.language = this.options.datepicker.language || 'en';\n\n            //store DPglobal\n            this.dpg = $.fn.bdatepicker.DPGlobal;\n\n            //store parsed formats\n            this.parsedFormat = this.dpg.parseFormat(this.options.format);\n            this.parsedViewFormat = this.dpg.parseFormat(this.options.viewformat);\n        },\n\n        render: function render() {\n            this.$input.bdatepicker(this.options.datepicker);\n\n            //\"clear\" link\n            if (this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function (e) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n\n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));\n            }\n        },\n\n        value2html: function value2html(value, element) {\n            var text = value ? this.dpg.formatDate(value, this.parsedViewFormat, this.options.datepicker.language) : '';\n            Date.superclass.value2html.call(this, text, element);\n        },\n\n        html2value: function html2value(html) {\n            return this.parseDate(html, this.parsedViewFormat);\n        },\n\n        value2str: function value2str(value) {\n            return value ? this.dpg.formatDate(value, this.parsedFormat, this.options.datepicker.language) : '';\n        },\n\n        str2value: function str2value(str) {\n            return this.parseDate(str, this.parsedFormat);\n        },\n\n        value2submit: function value2submit(value) {\n            return this.value2str(value);\n        },\n\n        value2input: function value2input(value) {\n            this.$input.bdatepicker('update', value);\n        },\n\n        input2value: function input2value() {\n            return this.$input.data('datepicker').date;\n        },\n\n        activate: function activate() {},\n\n        clear: function clear() {\n            this.$input.data('datepicker').date = null;\n            this.$input.find('.active').removeClass('active');\n            if (!this.options.showbuttons) {\n                this.$input.closest('form').submit();\n            }\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.on('mouseup', '.day', function (e) {\n                if ($(e.currentTarget).is('.old') || $(e.currentTarget).is('.new')) {\n                    return;\n                }\n                var $form = $(this).closest('form');\n                setTimeout(function () {\n                    $form.submit();\n                }, 200);\n            });\n            //changedate is not suitable as it triggered when showing datepicker. see #149\n            /*\n            this.$input.on('changeDate', function(e){\n                var $form = $(this).closest('form');\n                setTimeout(function() {\n                    $form.submit();\n                }, 200);\n            });\n            */\n        },\n\n        /*\n         For incorrect date bootstrap-datepicker returns current date that is not suitable\n         for datefield.\n         This function returns null for incorrect date.  \n        */\n        parseDate: function parseDate(str, format) {\n            var date = null,\n                formattedBack;\n            if (str) {\n                date = this.dpg.parseDate(str, format, this.options.datepicker.language);\n                if (typeof str === 'string') {\n                    formattedBack = this.dpg.formatDate(date, format, this.options.datepicker.language);\n                    if (str !== formattedBack) {\n                        date = null;\n                    }\n                }\n            }\n            return date;\n        }\n\n    });\n\n    Date.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/\n        tpl: '<div class=\"editable-date well\"></div>',\n        /**\n        @property inputclass \n        @default null\n        **/\n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        Possible tokens are: <code>d, dd, m, mm, yy, yyyy</code>  \n         @property format \n        @type string\n        @default yyyy-mm-dd\n        **/\n        format: 'yyyy-mm-dd',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to <code>format</code>\n         @property viewformat \n        @type string\n        @default null\n        **/\n        viewformat: null,\n        /**\n        Configuration of datepicker.\n        Full list of options: http://bootstrap-datepicker.readthedocs.org/en/latest/options.html\n         @property datepicker \n        @type object\n        @default {\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: false\n        }\n        **/\n        datepicker: {\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: false\n        },\n        /**\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n         @property clear \n        @type boolean|string\n        @default 'x clear'\n        **/\n        clear: '&times; clear'\n    });\n\n    $.fn.editabletypes.date = Date;\n})(window.jQuery);\n\n/**\nBootstrap datefield input - modification for inline mode.\nShows normal <input type=\"text\"> and binds popup datepicker.  \nAutomatically shown in inline mode.\n\n@class datefield\n@extends date\n\n@since 1.4.0\n**/\n(function ($) {\n    ;\n\n    var DateField = function DateField(options) {\n        this.init('datefield', options, DateField.defaults);\n        this.initPicker(options, DateField.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateField, $.fn.editabletypes.date);\n\n    $.extend(DateField.prototype, {\n        render: function render() {\n            this.$input = this.$tpl.find('input');\n            this.setClass();\n            this.setAttr('placeholder');\n\n            //bootstrap-datepicker is set `bdateicker` to exclude conflict with jQuery UI one. (in date.js)        \n            this.$tpl.bdatepicker(this.options.datepicker);\n\n            //need to disable original event handlers\n            this.$input.off('focus keydown');\n\n            //update value of datepicker\n            this.$input.keyup($.proxy(function () {\n                this.$tpl.removeData('date');\n                this.$tpl.bdatepicker('update');\n            }, this));\n        },\n\n        value2input: function value2input(value) {\n            this.$input.val(value ? this.dpg.formatDate(value, this.parsedViewFormat, this.options.datepicker.language) : '');\n            this.$tpl.bdatepicker('update');\n        },\n\n        input2value: function input2value() {\n            return this.html2value(this.$input.val());\n        },\n\n        activate: function activate() {\n            $.fn.editabletypes.text.prototype.activate.call(this);\n        },\n\n        autosubmit: function autosubmit() {\n            //reset autosubmit to empty  \n        }\n    });\n\n    DateField.defaults = $.extend({}, $.fn.editabletypes.date.defaults, {\n        /**\n        @property tpl \n        **/\n        tpl: '<div class=\"input-append date\"><input type=\"text\"/><span class=\"add-on\"><i class=\"icon-th\"></i></span></div>',\n        /**\n        @property inputclass \n        @default 'input-small'\n        **/\n        inputclass: 'input-small',\n\n        /* datepicker config */\n        datepicker: {\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: true\n        }\n    });\n\n    $.fn.editabletypes.datefield = DateField;\n})(window.jQuery);\n/**\nBootstrap-datetimepicker.  \nBased on [smalot bootstrap-datetimepicker plugin](https://github.com/smalot/bootstrap-datetimepicker). \nBefore usage you should manually include dependent js and css:\n\n    <link href=\"css/datetimepicker.css\" rel=\"stylesheet\" type=\"text/css\"></link> \n    <script src=\"js/bootstrap-datetimepicker.js\"><\/script>\n\nFor **i18n** you should include js file from here: https://github.com/smalot/bootstrap-datetimepicker/tree/master/js/locales\nand set `language` option.  \n\n@class datetime\n@extends abstractinput\n@final\n@since 1.4.4\n@example\n<a href=\"#\" id=\"last_seen\" data-type=\"datetime\" data-pk=\"1\" data-url=\"/post\" title=\"Select date & time\">15/03/2013 12:45</a>\n<script>\n$(function(){\n    $('#last_seen').editable({\n        format: 'yyyy-mm-dd hh:ii',    \n        viewformat: 'dd/mm/yyyy hh:ii',    \n        datetimepicker: {\n                weekStart: 1\n           }\n        }\n    });\n});\n<\/script>\n**/\n(function ($) {\n    ;\n\n    var DateTime = function DateTime(options) {\n        this.init('datetime', options, DateTime.defaults);\n        this.initPicker(options, DateTime.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateTime, $.fn.editabletypes.abstractinput);\n\n    $.extend(DateTime.prototype, {\n        initPicker: function initPicker(options, defaults) {\n            //'format' is set directly from settings or data-* attributes\n\n            //by default viewformat equals to format\n            if (!this.options.viewformat) {\n                this.options.viewformat = this.options.format;\n            }\n\n            //try parse datetimepicker config defined as json string in data-datetimepicker\n            options.datetimepicker = $.fn.editableutils.tryParseJson(options.datetimepicker, true);\n\n            //overriding datetimepicker config (as by default jQuery extend() is not recursive)\n            //since 1.4 datetimepicker internally uses viewformat instead of format. Format is for submit only\n            this.options.datetimepicker = $.extend({}, defaults.datetimepicker, options.datetimepicker, {\n                format: this.options.viewformat\n            });\n\n            //language\n            this.options.datetimepicker.language = this.options.datetimepicker.language || 'en';\n\n            //store DPglobal\n            this.dpg = $.fn.datetimepicker.DPGlobal;\n\n            //store parsed formats\n            this.parsedFormat = this.dpg.parseFormat(this.options.format, this.options.formatType);\n            this.parsedViewFormat = this.dpg.parseFormat(this.options.viewformat, this.options.formatType);\n        },\n\n        render: function render() {\n            this.$input.datetimepicker(this.options.datetimepicker);\n\n            //adjust container position when viewMode changes\n            //see https://github.com/smalot/bootstrap-datetimepicker/pull/80\n            this.$input.on('changeMode', function (e) {\n                var f = $(this).closest('form').parent();\n                //timeout here, otherwise container changes position before form has new size\n                setTimeout(function () {\n                    f.triggerHandler('resize');\n                }, 0);\n            });\n\n            //\"clear\" link\n            if (this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function (e) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n\n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));\n            }\n        },\n\n        value2html: function value2html(value, element) {\n            //formatDate works with UTCDate!\n            var text = value ? this.dpg.formatDate(this.toUTC(value), this.parsedViewFormat, this.options.datetimepicker.language, this.options.formatType) : '';\n            if (element) {\n                DateTime.superclass.value2html.call(this, text, element);\n            } else {\n                return text;\n            }\n        },\n\n        html2value: function html2value(html) {\n            //parseDate return utc date!\n            var value = this.parseDate(html, this.parsedViewFormat);\n            return value ? this.fromUTC(value) : null;\n        },\n\n        value2str: function value2str(value) {\n            //formatDate works with UTCDate!\n            return value ? this.dpg.formatDate(this.toUTC(value), this.parsedFormat, this.options.datetimepicker.language, this.options.formatType) : '';\n        },\n\n        str2value: function str2value(str) {\n            //parseDate return utc date!\n            var value = this.parseDate(str, this.parsedFormat);\n            return value ? this.fromUTC(value) : null;\n        },\n\n        value2submit: function value2submit(value) {\n            return this.value2str(value);\n        },\n\n        value2input: function value2input(value) {\n            if (value) {\n                this.$input.data('datetimepicker').setDate(value);\n            }\n        },\n\n        input2value: function input2value() {\n            //date may be cleared, in that case getDate() triggers error\n            var dt = this.$input.data('datetimepicker');\n            return dt.date ? dt.getDate() : null;\n        },\n\n        activate: function activate() {},\n\n        clear: function clear() {\n            this.$input.data('datetimepicker').date = null;\n            this.$input.find('.active').removeClass('active');\n            if (!this.options.showbuttons) {\n                this.$input.closest('form').submit();\n            }\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.on('mouseup', '.minute', function (e) {\n                var $form = $(this).closest('form');\n                setTimeout(function () {\n                    $form.submit();\n                }, 200);\n            });\n        },\n\n        //convert date from local to utc\n        toUTC: function toUTC(value) {\n            return value ? new Date(value.valueOf() - value.getTimezoneOffset() * 60000) : value;\n        },\n\n        //convert date from utc to local\n        fromUTC: function fromUTC(value) {\n            return value ? new Date(value.valueOf() + value.getTimezoneOffset() * 60000) : value;\n        },\n\n        /*\n         For incorrect date bootstrap-datetimepicker returns current date that is not suitable\n         for datetimefield.\n         This function returns null for incorrect date.  \n        */\n        parseDate: function parseDate(str, format) {\n            var date = null,\n                formattedBack;\n            if (str) {\n                date = this.dpg.parseDate(str, format, this.options.datetimepicker.language, this.options.formatType);\n                if (typeof str === 'string') {\n                    formattedBack = this.dpg.formatDate(date, format, this.options.datetimepicker.language, this.options.formatType);\n                    if (str !== formattedBack) {\n                        date = null;\n                    }\n                }\n            }\n            return date;\n        }\n\n    });\n\n    DateTime.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/\n        tpl: '<div class=\"editable-date well\"></div>',\n        /**\n        @property inputclass \n        @default null\n        **/\n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        Possible tokens are: <code>d, dd, m, mm, yy, yyyy, h, i</code>  \n        \n        @property format \n        @type string\n        @default yyyy-mm-dd hh:ii\n        **/\n        format: 'yyyy-mm-dd hh:ii',\n        formatType: 'standard',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to <code>format</code>\n        \n        @property viewformat \n        @type string\n        @default null\n        **/\n        viewformat: null,\n        /**\n        Configuration of datetimepicker.\n        Full list of options: https://github.com/smalot/bootstrap-datetimepicker\n         @property datetimepicker \n        @type object\n        @default { }\n        **/\n        datetimepicker: {\n            todayHighlight: false,\n            autoclose: false\n        },\n        /**\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n         @property clear \n        @type boolean|string\n        @default 'x clear'\n        **/\n        clear: '&times; clear'\n    });\n\n    $.fn.editabletypes.datetime = DateTime;\n})(window.jQuery);\n/**\nBootstrap datetimefield input - datetime input for inline mode.\nShows normal <input type=\"text\"> and binds popup datetimepicker.  \nAutomatically shown in inline mode.\n\n@class datetimefield\n@extends datetime\n\n**/\n(function ($) {\n    ;\n\n    var DateTimeField = function DateTimeField(options) {\n        this.init('datetimefield', options, DateTimeField.defaults);\n        this.initPicker(options, DateTimeField.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateTimeField, $.fn.editabletypes.datetime);\n\n    $.extend(DateTimeField.prototype, {\n        render: function render() {\n            this.$input = this.$tpl.find('input');\n            this.setClass();\n            this.setAttr('placeholder');\n\n            this.$tpl.datetimepicker(this.options.datetimepicker);\n\n            //need to disable original event handlers\n            this.$input.off('focus keydown');\n\n            //update value of datepicker\n            this.$input.keyup($.proxy(function () {\n                this.$tpl.removeData('date');\n                this.$tpl.datetimepicker('update');\n            }, this));\n        },\n\n        value2input: function value2input(value) {\n            this.$input.val(this.value2html(value));\n            this.$tpl.datetimepicker('update');\n        },\n\n        input2value: function input2value() {\n            return this.html2value(this.$input.val());\n        },\n\n        activate: function activate() {\n            $.fn.editabletypes.text.prototype.activate.call(this);\n        },\n\n        autosubmit: function autosubmit() {\n            //reset autosubmit to empty  \n        }\n    });\n\n    DateTimeField.defaults = $.extend({}, $.fn.editabletypes.datetime.defaults, {\n        /**\n        @property tpl \n        **/\n        tpl: '<div class=\"input-append date\"><input type=\"text\"/><span class=\"add-on\"><i class=\"icon-th\"></i></span></div>',\n        /**\n        @property inputclass \n        @default 'input-medium'\n        **/\n        inputclass: 'input-medium',\n\n        /* datetimepicker config */\n        datetimepicker: {\n            todayHighlight: false,\n            autoclose: true\n        }\n    });\n\n    $.fn.editabletypes.datetimefield = DateTimeField;\n})(window.jQuery);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvanMvYm9vdHN0cmFwLWVkaXRhYmxlLmpzPzI5MzQiXSwibmFtZXMiOlsiJCIsIkVkaXRhYmxlRm9ybSIsImRpdiIsIm9wdGlvbnMiLCJleHRlbmQiLCJmbiIsImVkaXRhYmxlZm9ybSIsImRlZmF1bHRzIiwiJGRpdiIsInNjb3BlIiwicHJvdG90eXBlIiwiY29uc3RydWN0b3IiLCJpbml0SW5wdXQiLCJpbnB1dCIsInZhbHVlIiwic3RyMnZhbHVlIiwicHJlcmVuZGVyIiwiaW5pdFRlbXBsYXRlIiwiJGZvcm0iLCJ0ZW1wbGF0ZSIsImluaXRCdXR0b25zIiwiJGJ0biIsImZpbmQiLCJhcHBlbmQiLCJidXR0b25zIiwic2hvd2J1dHRvbnMiLCJhZGRDbGFzcyIsInJlbmRlciIsIiRsb2FkaW5nIiwibG9hZGluZyIsImVtcHR5IiwicmVtb3ZlIiwic2hvd0xvYWRpbmciLCJpc1NhdmluZyIsInRyaWdnZXJIYW5kbGVyIiwiJHRwbCIsIndoZW4iLCJ0aGVuIiwicHJveHkiLCJhdXRvc3VibWl0IiwiY2xpY2siLCJjYW5jZWwiLCJlcnJvciIsImF0dHIiLCIkaW5wdXQiLCJzdWJtaXQiLCJlIiwicHJldmVudERlZmF1bHQiLCJyZW1vdmVBdHRyIiwidW5kZWZpbmVkIiwiZGVmYXVsdFZhbHVlIiwidmFsdWUyaW5wdXQiLCJzaG93Rm9ybSIsInBvc3RyZW5kZXIiLCJ3IiwiaCIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsIndpZHRoIiwiaGVpZ2h0IiwiaGlkZSIsInBhcmVudCIsInNob3ciLCJhY3RpdmF0ZSIsIm1zZyIsIiRncm91cCIsIiRibG9jayIsImxpbmVzIiwicmVtb3ZlQ2xhc3MiLCJlcnJvckdyb3VwQ2xhc3MiLCJlcnJvckJsb2NrQ2xhc3MiLCJzcGxpdCIsImkiLCJsZW5ndGgiLCJ0ZXh0IiwiaHRtbCIsImpvaW4iLCJzdG9wUHJvcGFnYXRpb24iLCJuZXdWYWx1ZSIsImlucHV0MnZhbHVlIiwidmFsaWRhdGUiLCJ0eXBlIiwic2F2ZW5vY2hhbmdlIiwidmFsdWUyc3RyIiwic3VibWl0VmFsdWUiLCJ2YWx1ZTJzdWJtaXQiLCJzYXZlIiwiZG9uZSIsInJlc3BvbnNlIiwicmVzIiwic3VjY2VzcyIsImNhbGwiLCJoYXNPd25Qcm9wZXJ0eSIsImZhaWwiLCJ4aHIiLCJyZXNwb25zZVRleHQiLCJzdGF0dXNUZXh0IiwicGsiLCJlZGl0YWJsZXV0aWxzIiwidHJ5UGFyc2VKc29uIiwic2VuZCIsInVybCIsInBhcmFtcyIsIm5hbWUiLCJhamF4IiwiZGF0YSIsImFqYXhPcHRpb25zIiwib3B0aW9uIiwia2V5Iiwic2V0VmFsdWUiLCJjb252ZXJ0U3RyIiwiaXMiLCJhcmdzIiwiYXJndW1lbnRzIiwiZWFjaCIsIiR0aGlzIiwiYXBwbHkiLCJBcnJheSIsInNsaWNlIiwiQ29uc3RydWN0b3IiLCJlbmdpbmUiLCJ3aW5kb3ciLCJqUXVlcnkiLCJpbmhlcml0IiwiQ2hpbGQiLCJQYXJlbnQiLCJGIiwic3VwZXJjbGFzcyIsInNldEN1cnNvclBvc2l0aW9uIiwiZWxlbSIsInBvcyIsInNldFNlbGVjdGlvblJhbmdlIiwiY3JlYXRlVGV4dFJhbmdlIiwicmFuZ2UiLCJjb2xsYXBzZSIsIm1vdmVFbmQiLCJtb3ZlU3RhcnQiLCJzZWxlY3QiLCJzIiwic2FmZSIsIm1hdGNoIiwiRnVuY3Rpb24iLCJzbGljZU9iaiIsIm9iaiIsImtleXMiLCJjYXNlU2Vuc2l0aXZlIiwia2V5TG93ZXIiLCJuZXdPYmoiLCJpc0FycmF5IiwidG9Mb3dlckNhc2UiLCJnZXRDb25maWdEYXRhIiwiJGVsZW1lbnQiLCJrIiwidiIsIk9iamVjdCIsIm9iamVjdEtleXMiLCJvIiwiVHlwZUVycm9yIiwicCIsInB1c2giLCJlc2NhcGUiLCJzdHIiLCJpdGVtc0J5VmFsdWUiLCJzb3VyY2VEYXRhIiwidmFsdWVQcm9wIiwiaWRLZXkiLCJpc1ZhbEFycmF5IiwicmVzdWx0IiwidGhhdCIsImNoaWxkcmVuIiwiY29uY2F0IiwiZ3JlcCIsIml0ZW1WYWx1ZSIsImNyZWF0ZUlucHV0IiwiVHlwZUNvbnN0cnVjdG9yIiwidHlwZU9wdGlvbnMiLCJtb2RlIiwiZWRpdGFibGV0eXBlcyIsImRhdGVmaWVsZCIsImRhdGV1aWZpZWxkIiwiZGF0ZSIsImRhdGV1aSIsInN1cHBvcnRzVHJhbnNpdGlvbnMiLCJiIiwiZG9jdW1lbnQiLCJib2R5IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInN1YnN0ciIsIlBvcHVwIiwiZWxlbWVudCIsImluaXQiLCJJbmxpbmUiLCJjb250YWluZXJOYW1lIiwiY29udGFpbmVyRGF0YU5hbWUiLCJpbm5lckNzcyIsImNvbnRhaW5lckNsYXNzIiwiZWRpdGFibGVDb250YWluZXIiLCJzcGxpdE9wdGlvbnMiLCJmb3JtT3B0aW9ucyIsImluaXRDb250YWluZXIiLCJkZWxheWVkSGlkZSIsIm9uIiwiZGVzdHJveSIsIndoaWNoIiwiJHRhcmdldCIsInRhcmdldCIsImV4Y2x1ZGVfY2xhc3NlcyIsImNvbnRhaW5zIiwicGFyZW50cyIsImNsb3NlT3RoZXJzIiwiY29udGFpbmVyT3B0aW9ucyIsIkVycm9yIiwidGlwIiwiY29udGFpbmVyIiwiJHRpcCIsInJlbmRlckZvcm0iLCJub2NoYW5nZSIsInJlYXNvbiIsInNldFBvc2l0aW9uIiwicmVuZGVyaW5nIiwicmVzaXplIiwicmVuZGVyZWQiLCJjbG9zZUFsbCIsImlubmVyU2hvdyIsImhhc0NsYXNzIiwiaW5uZXJIaWRlIiwidG9nZ2xlIiwic2V0Q29udGFpbmVyT3B0aW9uIiwiaW5uZXJEZXN0cm95Iiwib2ZmIiwicmVtb3ZlRGF0YSIsImVsIiwiJGVsIiwiZWMiLCJvbmJsdXIiLCJkYXRhS2V5IiwicGxhY2VtZW50IiwiYXV0b2hpZGUiLCJhbmltIiwiZXZlbnQiLCJzcGVjaWFsIiwiZGVzdHJveWVkIiwiaGFuZGxlciIsImluc2VydEFmdGVyIiwiRWRpdGFibGUiLCJlZGl0YWJsZSIsInNlbGVjdG9yIiwiaW5pdExpdmUiLCJoaWdobGlnaHQiLCJpc1ZhbHVlQnlUZXh0IiwiZG9BdXRvdGV4dCIsImZpbmFsaXplIiwiaHRtbDJ2YWx1ZSIsInRyaW0iLCJkaXNhYmxlZCIsImRpc3BsYXkiLCJhdXRvdGV4dCIsImRpc2FibGUiLCJlbmFibGUiLCJlbXB0eWNsYXNzIiwidHJpZ2dlciIsInZhbHVlMmh0bWxGaW5hbCIsInZhbHVlMmh0bWwiLCJoYW5kbGVFbXB0eSIsImlzRW1wdHkiLCJ0b2dnbGVEaXNhYmxlZCIsImVtcHR5dGV4dCIsInVuc2F2ZWRjbGFzcyIsInNlbnQiLCIkZSIsImJnQ29sb3IiLCJjc3MiLCJzZXRUaW1lb3V0IiwiZGF0YWtleSIsImVxIiwiY29uZmlnIiwiJGVsZW1zIiwiZXJyb3JzIiwiaXNFbXB0eU9iamVjdCIsInZhbHVlcyIsIm5vb3AiLCJBYnN0cmFjdElucHV0IiwidHBsIiwiJGNsZWFyIiwidmFsIiwiZm9jdXMiLCJjbGVhciIsInNldENsYXNzIiwiaW5wdXRjbGFzcyIsInNldEF0dHIiLCJhYnN0cmFjdGlucHV0IiwiTGlzdCIsImRlZmVycmVkIiwiRGVmZXJyZWQiLCJvblNvdXJjZVJlYWR5IiwicmVuZGVyTGlzdCIsInJlc29sdmUiLCJzb3VyY2VFcnJvciIsInByb21pc2UiLCJzb3VyY2UiLCJpc0Z1bmN0aW9uIiwic291cmNlQ2FjaGUiLCJjYWNoZUlEIiwiY2FjaGUiLCJkb1ByZXBlbmQiLCJjYWxsYmFja3MiLCJlcnJfY2FsbGJhY2tzIiwiZGF0YVR5cGUiLCJtYWtlQXJyYXkiLCJzb3VyY2VPcHRpb25zIiwicHJlcGVuZCIsInByZXBlbmREYXRhIiwiY291bnQiLCJpdGVtIiwiaXRlcmF0ZUl0ZW0iLCJsaXN0IiwiVGV4dCIsInJlbmRlckNsZWFyIiwiZ2V0IiwidG9nZ2xlQ2xlYXIiLCJhZnRlciIsImtleXVwIiwiaW5BcnJheSIsImtleUNvZGUiLCJjbGVhclRpbWVvdXQiLCJ0IiwibGVuIiwidmlzaWJsZSIsInBsYWNlaG9sZGVyIiwiVGV4dGFyZWEiLCJrZXlkb3duIiwiY3RybEtleSIsImNsb3Nlc3QiLCJyb3dzIiwidGV4dGFyZWEiLCJTZWxlY3QiLCJmaWxsSXRlbXMiLCJsYWJlbCIsIml0ZW1zIiwiQ2hlY2tsaXN0IiwiJGxhYmVsIiwiYXBwZW5kVG8iLCJzb3J0Iiwic2VwYXJhdG9yIiwicmVnIiwiUmVnRXhwIiwicHJvcCIsImoiLCJjaGVja2VkIiwiZmlsdGVyIiwiZmlyc3QiLCJjaGVja2xpc3QiLCJQYXNzd29yZCIsInBhc3N3b3JkIiwiRW1haWwiLCJlbWFpbCIsIlVybCIsIlRlbCIsInRlbCIsIk51bWJlcklucHV0IiwicmlnaHQiLCJtaW4iLCJtYXgiLCJzdGVwIiwibnVtYmVyIiwiUmFuZ2UiLCJzaWJsaW5ncyIsIlRpbWUiLCJ0aW1lIiwic2VsZWN0MiIsInRhZ3MiLCJ0ZXJtIiwicXVlcnkiLCJyZXN1bHRzIiwiY29udmVydFNvdXJjZSIsImlzTXVsdGlwbGUiLCJtdWx0aXBsZSIsImlzUmVtb3RlIiwiaWRGdW5jIiwiaWQiLCJmb3JtYXRTZWxlY3Rpb24iLCJ2aWV3c2VwYXJhdG9yIiwiZ2V0U2VwYXJhdG9yIiwiaW5pdFNlbGVjdGlvbiIsImN1c3RvbUlkIiwiY3VzdG9tVGV4dCIsImwiLCJpc0luaXRpYWwiLCJDb21ib2RhdGUiLCJjb21ib2RhdGUiLCJtYXAiLCJkYXkiLCJtb250aCIsInllYXIiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwiYW1wbSIsIiR3aWRnZXQiLCJnZXRUZW1wbGF0ZSIsImluaXRDb21ib3MiLCJnZXRWYWx1ZSIsImNoYW5nZSIsInNtYXJ0RGF5cyIsImZpbGxDb21ibyIsInIiLCJ0b2tlbiIsInN1YnN0cmluZyIsInJlcGxhY2UiLCIkYyIsIiRjb21ibyIsImYiLCJmaWxsQ29tbW9uIiwicmVsVGltZSIsImZpcnN0SXRlbSIsIm1vbWVudCIsInJlbGF0aXZlVGltZSIsImxhbmdEYXRhIiwiX3JlbGF0aXZlVGltZSIsImhlYWRlciIsInJldmVyc2UiLCJmaWxsRGF5IiwidHdvRGlnaXQiLCJpbmRleE9mIiwiZGF5c0NvdW50IiwiJG1vbnRoIiwiJHllYXIiLCJwYXJzZUludCIsImlzTmFOIiwiZGF5c0luTW9udGgiLCJsZWFkWmVybyIsImZpbGxNb250aCIsImxvbmdOYW1lcyIsInNob3J0TmFtZXMiLCJmb3JtYXQiLCJmaWxsWWVhciIsIm1heFllYXIiLCJtaW5ZZWFyIiwieWVhckRlc2NlbmRpbmciLCJmaWxsSG91ciIsImgxMiIsImgyNCIsImZpbGxNaW51dGUiLCJtaW51dGVTdGVwIiwiZmlsbFNlY29uZCIsInNlY29uZFN0ZXAiLCJmaWxsQW1wbSIsImFtcG1MIiwiYW1wbVUiLCJkdCIsIm5vdFNlbGVjdGVkIiwiZGVmIiwiJGFtcG0iLCJpc1ZhbGlkIiwiZ2V0TmVhcmVzdCIsIiRzZWxlY3QiLCJkZWx0YSIsIm9wdCIsIm9wdFZhbHVlIiwiZGlzdGFuY2UiLCJNYXRoIiwiYWJzIiwicm91bmRUaW1lIiwiZXJyb3JDbGFzcyIsImJvcmRlckNvbG9yIiwiZCIsInNoaWZ0Iiwidmlld2Zvcm1hdCIsInBJbml0SW5wdXQiLCJlbXB0eUlucHV0Q2xhc3MiLCJkZWZhdWx0Q2xhc3MiLCJzdGR0eXBlcyIsImNsYXNzZXMiLCJwb3BvdmVyIiwiREVGQVVMVFMiLCJjb250ZW50IiwiYXV0b1Rva2VuIiwiYXV0b1BsYWNlIiwidGVzdCIsImdldFBvc2l0aW9uIiwiYWN0dWFsV2lkdGgiLCJvZmZzZXRXaWR0aCIsImFjdHVhbEhlaWdodCIsIm9mZnNldEhlaWdodCIsIiRwYXJlbnQiLCJvcmdQbGFjZW1lbnQiLCJkb2NTY3JvbGwiLCJzY3JvbGxUb3AiLCJwYXJlbnRXaWR0aCIsImlubmVyV2lkdGgiLCJwYXJlbnRIZWlnaHQiLCJpbm5lckhlaWdodCIsInBhcmVudExlZnQiLCJvZmZzZXQiLCJsZWZ0IiwidG9wIiwiY2FsY3VsYXRlZE9mZnNldCIsImdldENhbGN1bGF0ZWRPZmZzZXQiLCJhcHBseVBsYWNlbWVudCIsIlVUQ0RhdGUiLCJEYXRlIiwiVVRDIiwiVVRDVG9kYXkiLCJ0b2RheSIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiRGF0ZXBpY2tlciIsIl9wcm9jZXNzX29wdGlvbnMiLCJpc0lubGluZSIsImlzSW5wdXQiLCJjb21wb25lbnQiLCJoYXNJbnB1dCIsInBpY2tlciIsIkRQR2xvYmFsIiwiX2J1aWxkRXZlbnRzIiwiX2F0dGFjaEV2ZW50cyIsInJ0bCIsInRvZ2dsZUNsYXNzIiwidmlld01vZGUiLCJzdGFydFZpZXciLCJjYWxlbmRhcldlZWtzIiwiX2FsbG93X3VwZGF0ZSIsInNldFN0YXJ0RGF0ZSIsInN0YXJ0RGF0ZSIsInNldEVuZERhdGUiLCJlbmREYXRlIiwic2V0RGF5c09mV2Vla0Rpc2FibGVkIiwiZGF5c09mV2Vla0Rpc2FibGVkIiwiZmlsbERvdyIsImZpbGxNb250aHMiLCJ1cGRhdGUiLCJzaG93TW9kZSIsIm9wdHMiLCJfbyIsImxhbmciLCJsYW5ndWFnZSIsImRhdGVzIiwibWluVmlld01vZGUiLCJ3ZWVrU3RhcnQiLCJ3ZWVrRW5kIiwicGFyc2VGb3JtYXQiLCJJbmZpbml0eSIsInBhcnNlRGF0ZSIsIl9ldmVudHMiLCJfc2Vjb25kYXJ5RXZlbnRzIiwiX2FwcGx5RXZlbnRzIiwiZXZzIiwiZXYiLCJfdW5hcHBseUV2ZW50cyIsInBsYWNlIiwibW91c2Vkb3duIiwic2l6ZSIsIl9kZXRhY2hFdmVudHMiLCJfYXR0YWNoU2Vjb25kYXJ5RXZlbnRzIiwiX2RldGFjaFNlY29uZGFyeUV2ZW50cyIsIl90cmlnZ2VyIiwiYWx0ZGF0ZSIsImxvY2FsX2RhdGUiLCJnZXRUaW1lIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJhbHRmb3JtYXQiLCJmb3JtYXREYXRlIiwiZGV0YWNoIiwiZm9yY2VQYXJzZSIsImRhdGVwaWNrZXIiLCJnZXREYXRlIiwic2V0RGF0ZSIsInNldFVUQ0RhdGUiLCJmb3JtYXR0ZWQiLCJnZXRGb3JtYXR0ZWREYXRlIiwidXBkYXRlTmF2QXJyb3dzIiwiekluZGV4IiwiZnJvbUFyZ3MiLCJ2aWV3RGF0ZSIsImZpbGwiLCJkb3dDbnQiLCJjZWxsIiwiZGF5c01pbiIsIm1vbnRoc1Nob3J0Iiwic2V0UmFuZ2UiLCJ2YWx1ZU9mIiwiZ2V0Q2xhc3NOYW1lcyIsImNscyIsImN1cnJlbnREYXRlIiwidG9kYXlIaWdobGlnaHQiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0VVRDRGF5Iiwic3RhcnRZZWFyIiwic3RhcnRNb250aCIsImVuZFllYXIiLCJlbmRNb250aCIsInRvb2x0aXAiLCJtb250aHMiLCJ0b2RheUJ0biIsImNsZWFyQnRuIiwicHJldk1vbnRoIiwiZ2V0RGF5c0luTW9udGgiLCJuZXh0TW9udGgiLCJjbHNOYW1lIiwid3MiLCJ0aCIsInl0aCIsImNhbFdlZWsiLCJiZWZvcmUiLCJiZWZvcmVTaG93RGF5IiwiZW5hYmxlZCIsInVuaXF1ZSIsImN1cnJlbnRZZWFyIiwiZW5kIiwieWVhckNvbnQiLCJ2aXNpYmlsaXR5Iiwibm9kZU5hbWUiLCJjbGFzc05hbWUiLCJkaXIiLCJtb2RlcyIsIm5hdlN0ZXAiLCJtb3ZlTW9udGgiLCJtb3ZlWWVhciIsIl9zZXREYXRlIiwiYXV0b2Nsb3NlIiwiaW5kZXgiLCJzZXRVVENNb250aCIsInNldFVUQ0Z1bGxZZWFyIiwibmV3X2RhdGUiLCJtYWciLCJuZXdfbW9udGgiLCJkYXRlV2l0aGluUmFuZ2UiLCJkYXRlQ2hhbmdlZCIsIm5ld0RhdGUiLCJuZXdWaWV3RGF0ZSIsImtleWJvYXJkTmF2aWdhdGlvbiIsInNoaWZ0S2V5IiwiRGF0ZVJhbmdlUGlja2VyIiwiaW5wdXRzIiwianF1ZXJ5IiwiYmluZCIsImRhdGVVcGRhdGVkIiwicGlja2VycyIsInVwZGF0ZURhdGVzIiwidXBkYXRlUmFuZ2VzIiwiZHAiLCJvcHRzX2Zyb21fZWwiLCJwcmVmaXgiLCJvdXQiLCJpbmtleSIsIl8iLCJhIiwib3B0c19mcm9tX2xvY2FsZSIsImxvY2FsZV9vcHRzIiwib2xkIiwiaW50ZXJuYWxfcmV0dXJuIiwidGhpc19yZXR1cm4iLCJlbG9wdHMiLCJ4b3B0cyIsImxvY29wdHMiLCJyb3B0cyIsInRvQXJyYXkiLCJlbiIsImRheXMiLCJkYXlzU2hvcnQiLCJuYXZGbmMiLCJpc0xlYXBZZWFyIiwidmFsaWRQYXJ0cyIsIm5vbnB1bmN0dWF0aW9uIiwic2VwYXJhdG9ycyIsInBhcnRzIiwicGFydF9yZSIsInBhcnQiLCJleGVjIiwicGFyc2VkIiwic2V0dGVyc19vcmRlciIsInNldHRlcnNfbWFwIiwieXl5eSIsInl5IiwibSIsImZpbHRlcmVkIiwiZnBhcnRzIiwiY250IiwiRCIsIkREIiwiTSIsIk1NIiwidG9TdHJpbmciLCJkZCIsIm1tIiwic2VwcyIsImhlYWRUZW1wbGF0ZSIsImNvbnRUZW1wbGF0ZSIsImZvb3RUZW1wbGF0ZSIsIm5vQ29uZmxpY3QiLCJiZGF0ZXBpY2tlciIsImluaXRQaWNrZXIiLCJkcGciLCJwYXJzZWRGb3JtYXQiLCJwYXJzZWRWaWV3Rm9ybWF0IiwiY3VycmVudFRhcmdldCIsImZvcm1hdHRlZEJhY2siLCJEYXRlRmllbGQiLCJEYXRlVGltZSIsImRhdGV0aW1lcGlja2VyIiwiZm9ybWF0VHlwZSIsInRvVVRDIiwiZnJvbVVUQyIsImRhdGV0aW1lIiwiRGF0ZVRpbWVGaWVsZCIsImRhdGV0aW1lZmllbGQiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7QUFJQTs7Ozs7Ozs7O0FBU0MsV0FBVUEsQ0FBVixFQUFhOztBQUVWLFFBQUlDLGVBQWUsU0FBZkEsWUFBZSxDQUFVQyxHQUFWLEVBQWVDLE9BQWYsRUFBd0I7QUFDdkMsYUFBS0EsT0FBTCxHQUFlSCxFQUFFSSxNQUFGLENBQVMsRUFBVCxFQUFhSixFQUFFSyxFQUFGLENBQUtDLFlBQUwsQ0FBa0JDLFFBQS9CLEVBQXlDSixPQUF6QyxDQUFmO0FBQ0EsYUFBS0ssSUFBTCxHQUFZUixFQUFFRSxHQUFGLENBQVosQ0FGdUMsQ0FFbkI7QUFDcEIsWUFBRyxDQUFDLEtBQUtDLE9BQUwsQ0FBYU0sS0FBakIsRUFBd0I7QUFDcEIsaUJBQUtOLE9BQUwsQ0FBYU0sS0FBYixHQUFxQixJQUFyQjtBQUNIO0FBQ0Q7QUFDSCxLQVBEOztBQVNBUixpQkFBYVMs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QW1CcWhCLGFBQW5CLEdBQW1DRCxhQUFuQztBQUVILENBbkVBLEVBbUVDNWtCLE9BQU9DLE1BbkVSLENBQUQiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBYLWVkaXRhYmxlIC0gdjEuNS4xIFxuKiBJbi1wbGFjZSBlZGl0aW5nIHdpdGggVHdpdHRlciBCb290c3RyYXAsIGpRdWVyeSBVSSBvciBwdXJlIGpRdWVyeVxuKiBodHRwOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlXG4qIENvcHlyaWdodCAoYykgMjAxMyBWaXRhbGl5IFBvdGFwb3Y7IExpY2Vuc2VkIE1JVCAqL1xuLyoqXG5Gb3JtIHdpdGggc2luZ2xlIGlucHV0IGVsZW1lbnQsIHR3byBidXR0b25zIGFuZCB0d28gc3RhdGVzOiBub3JtYWwvbG9hZGluZy5cbkFwcGxpZWQgYXMgalF1ZXJ5IG1ldGhvZCB0byBESVYgdGFnIChub3QgdG8gZm9ybSB0YWchKS4gVGhpcyBpcyBiZWNhdXNlIGZvcm0gY2FuIGJlIGluIGxvYWRpbmcgc3RhdGUgd2hlbiBzcGlubmVyIHNob3duLlxuRWRpdGFibGVmb3JtIGlzIGxpbmtlZCB3aXRoIG9uZSBvZiBpbnB1dCB0eXBlcywgZS5nLiAndGV4dCcsICdzZWxlY3QnIGV0Yy5cblxuQGNsYXNzIGVkaXRhYmxlZm9ybVxuQHVzZXMgdGV4dFxuQHVzZXMgdGV4dGFyZWFcbioqL1xuKGZ1bmN0aW9uICgkKSB7XG5cbiAgICB2YXIgRWRpdGFibGVGb3JtID0gZnVuY3Rpb24gKGRpdiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZWZvcm0uZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiRkaXYgPSAkKGRpdik7IC8vZGl2LCBjb250YWluaW5nIGZvcm0uIE5vdCBmb3JtIHRhZy4gTm90IGVkaXRhYmxlLWVsZW1lbnQuXG4gICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zY29wZSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy9ub3RoaW5nIHNob3duIGFmdGVyIGluaXRcbiAgICB9O1xuXG4gICAgRWRpdGFibGVGb3JtLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IEVkaXRhYmxlRm9ybSxcbiAgICAgICAgaW5pdElucHV0OiBmdW5jdGlvbigpIHsgIC8vY2FsbGVkIG9uY2VcbiAgICAgICAgICAgIC8vdGFrZSBpbnB1dCBmcm9tIG9wdGlvbnMgKGFzIGl0IGlzIGNyZWF0ZWQgaW4gZWRpdGFibGUtZWxlbWVudClcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLm9wdGlvbnMuaW5wdXQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2V0IGluaXRpYWwgdmFsdWVcbiAgICAgICAgICAgIC8vdG9kbzogbWF5IGJlIGFkZCBjaGVjazogdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmlucHV0LnN0cjJ2YWx1ZSh0aGlzLm9wdGlvbnMudmFsdWUpOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9wcmVyZW5kZXI6IGdldCBpbnB1dC4kaW5wdXRcbiAgICAgICAgICAgIHRoaXMuaW5wdXQucHJlcmVuZGVyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRUZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRmb3JtID0gJCgkLmZuLmVkaXRhYmxlZm9ybS50ZW1wbGF0ZSk7IFxuICAgICAgICB9LFxuICAgICAgICBpbml0QnV0dG9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgJGJ0biA9IHRoaXMuJGZvcm0uZmluZCgnLmVkaXRhYmxlLWJ1dHRvbnMnKTtcbiAgICAgICAgICAgICRidG4uYXBwZW5kKCQuZm4uZWRpdGFibGVmb3JtLmJ1dHRvbnMpO1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnNob3didXR0b25zID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICAgICRidG4uYWRkQ2xhc3MoJ2VkaXRhYmxlLWJ1dHRvbnMtYm90dG9tJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICBSZW5kZXJzIGVkaXRhYmxlZm9ybVxuXG4gICAgICAgIEBtZXRob2QgcmVuZGVyXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvL2luaXQgbG9hZGVyXG4gICAgICAgICAgICB0aGlzLiRsb2FkaW5nID0gJCgkLmZuLmVkaXRhYmxlZm9ybS5sb2FkaW5nKTsgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kZGl2LmVtcHR5KCkuYXBwZW5kKHRoaXMuJGxvYWRpbmcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2luaXQgZm9ybSB0ZW1wbGF0ZSBhbmQgYnV0dG9uc1xuICAgICAgICAgICAgdGhpcy5pbml0VGVtcGxhdGUoKTtcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5zaG93YnV0dG9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdEJ1dHRvbnMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtYnV0dG9ucycpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3Nob3cgbG9hZGluZyBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5zaG93TG9hZGluZygpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2ZsYWcgc2hvd2luZyBpcyBmb3JtIG5vdyBzYXZpbmcgdmFsdWUgdG8gc2VydmVyLiBcbiAgICAgICAgICAgIC8vSXQgaXMgbmVlZGVkIHRvIHdhaXQgd2hlbiBjbG9zaW5nIGZvcm0uXG4gICAgICAgICAgICB0aGlzLmlzU2F2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICBGaXJlZCB3aGVuIHJlbmRlcmluZyBzdGFydHNcbiAgICAgICAgICAgIEBldmVudCByZW5kZXJpbmcgXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAqKi8gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGRpdi50cmlnZ2VySGFuZGxlcigncmVuZGVyaW5nJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaW5pdCBpbnB1dFxuICAgICAgICAgICAgdGhpcy5pbml0SW5wdXQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hcHBlbmQgaW5wdXQgdG8gZm9ybVxuICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCdkaXYuZWRpdGFibGUtaW5wdXQnKS5hcHBlbmQodGhpcy5pbnB1dC4kdHBsKTsgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hcHBlbmQgZm9ybSB0byBjb250YWluZXJcbiAgICAgICAgICAgIHRoaXMuJGRpdi5hcHBlbmQodGhpcy4kZm9ybSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcmVuZGVyIGlucHV0XG4gICAgICAgICAgICAkLndoZW4odGhpcy5pbnB1dC5yZW5kZXIoKSlcbiAgICAgICAgICAgIC50aGVuKCQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vc2V0dXAgaW5wdXQgdG8gc3VibWl0IGF1dG9tYXRpY2FsbHkgd2hlbiBubyBidXR0b25zIHNob3duXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMub3B0aW9ucy5zaG93YnV0dG9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmF1dG9zdWJtaXQoKTsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL2F0dGFjaCAnY2FuY2VsJyBoYW5kbGVyXG4gICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtY2FuY2VsJykuY2xpY2soJC5wcm94eSh0aGlzLmNhbmNlbCwgdGhpcykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcih0aGlzLmlucHV0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtc3VibWl0JykuYXR0cignZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC4kaW5wdXQuYXR0cignZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IGZvcm0gZnJvbSBzdWJtaXR0aW5nXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uc3VibWl0KGZ1bmN0aW9uKGUpeyBlLnByZXZlbnREZWZhdWx0KCk7IH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LiRpbnB1dC5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1zdWJtaXQnKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAodGhpcy52YWx1ZSA9PT0gbnVsbCB8fCB0aGlzLnZhbHVlID09PSB1bmRlZmluZWQgfHwgdGhpcy52YWx1ZSA9PT0gJycpID8gdGhpcy5vcHRpb25zLmRlZmF1bHRWYWx1ZSA6IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQudmFsdWUyaW5wdXQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAvL2F0dGFjaCBzdWJtaXQgaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLnN1Ym1pdCgkLnByb3h5KHRoaXMuc3VibWl0LCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgICAgICBGaXJlZCB3aGVuIGZvcm0gaXMgcmVuZGVyZWRcbiAgICAgICAgICAgICAgICBAZXZlbnQgcmVuZGVyZWRcbiAgICAgICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgKiovICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy4kZGl2LnRyaWdnZXJIYW5kbGVyKCdyZW5kZXJlZCcpOyAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zvcm0oKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL2NhbGwgcG9zdHJlbmRlciBtZXRob2QgdG8gcGVyZm9ybSBhY3Rpb25zIHJlcXVpcmVkIHZpc2liaWxpdHkgb2YgZm9ybVxuICAgICAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQucG9zdHJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnBvc3RyZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkgeyAgIFxuICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgIEZpcmVkIHdoZW4gZm9ybSB3YXMgY2FuY2VsbGVkIGJ5IHVzZXJcbiAgICAgICAgICAgIEBldmVudCBjYW5jZWwgXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAqKi8gICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kZGl2LnRyaWdnZXJIYW5kbGVyKCdjYW5jZWwnKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2hvd0xvYWRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHcsIGg7XG4gICAgICAgICAgICBpZih0aGlzLiRmb3JtKSB7XG4gICAgICAgICAgICAgICAgLy9zZXQgbG9hZGluZyBzaXplIGVxdWFsIHRvIGZvcm1cbiAgICAgICAgICAgICAgICB3ID0gdGhpcy4kZm9ybS5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgICAgICAgaCA9IHRoaXMuJGZvcm0ub3V0ZXJIZWlnaHQoKTsgXG4gICAgICAgICAgICAgICAgaWYodykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2FkaW5nLndpZHRoKHcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvYWRpbmcuaGVpZ2h0KGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9zdHJldGNoIGxvYWRpbmcgdG8gZmlsbCBjb250YWluZXIgd2lkdGhcbiAgICAgICAgICAgICAgICB3ID0gdGhpcy4kbG9hZGluZy5wYXJlbnQoKS53aWR0aCgpO1xuICAgICAgICAgICAgICAgIGlmKHcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9hZGluZy53aWR0aCh3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRsb2FkaW5nLnNob3coKTsgXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvd0Zvcm06IGZ1bmN0aW9uKGFjdGl2YXRlKSB7XG4gICAgICAgICAgICB0aGlzLiRsb2FkaW5nLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuJGZvcm0uc2hvdygpO1xuICAgICAgICAgICAgaWYoYWN0aXZhdGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5hY3RpdmF0ZSgpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICBGaXJlZCB3aGVuIGZvcm0gaXMgc2hvd25cbiAgICAgICAgICAgIEBldmVudCBzaG93IFxuICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgKiovICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGRpdi50cmlnZ2VySGFuZGxlcignc2hvdycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgIHZhciAkZ3JvdXAgPSB0aGlzLiRmb3JtLmZpbmQoJy5jb250cm9sLWdyb3VwJyksXG4gICAgICAgICAgICAgICAgJGJsb2NrID0gdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtZXJyb3ItYmxvY2snKSxcbiAgICAgICAgICAgICAgICBsaW5lcztcblxuICAgICAgICAgICAgaWYobXNnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICRncm91cC5yZW1vdmVDbGFzcygkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckdyb3VwQ2xhc3MpO1xuICAgICAgICAgICAgICAgICRibG9jay5yZW1vdmVDbGFzcygkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckJsb2NrQ2xhc3MpLmVtcHR5KCkuaGlkZSgpOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IG5ld2xpbmUgdG8gPGJyPiBmb3IgbW9yZSBwcmV0dHkgZXJyb3IgZGlzcGxheVxuICAgICAgICAgICAgICAgIGlmKG1zZykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lcyA9ICgnJyttc2cpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbaV0gPSAkKCc8ZGl2PicpLnRleHQobGluZXNbaV0pLmh0bWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtc2cgPSBsaW5lcy5qb2luKCc8YnI+Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRncm91cC5hZGRDbGFzcygkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckdyb3VwQ2xhc3MpO1xuICAgICAgICAgICAgICAgICRibG9jay5hZGRDbGFzcygkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckJsb2NrQ2xhc3MpLmh0bWwobXNnKS5zaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3VibWl0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2dldCBuZXcgdmFsdWUgZnJvbSBpbnB1dFxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5pbnB1dC5pbnB1dDJ2YWx1ZSgpOyBcblxuICAgICAgICAgICAgLy92YWxpZGF0aW9uOiBpZiB2YWxpZGF0ZSByZXR1cm5zIHN0cmluZyBvciB0cnV0aHkgdmFsdWUgLSBtZWFucyBlcnJvclxuICAgICAgICAgICAgLy9pZiByZXR1cm5zIG9iamVjdCBsaWtlIHtuZXdWYWx1ZTogJy4uLid9ID0+IHN1Ym1pdHRlZCB2YWx1ZSBpcyByZWFzc2lnbmVkIHRvIGl0XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGlmICgkLnR5cGUoZXJyb3IpID09PSAnb2JqZWN0JyAmJiBlcnJvci5uZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBlcnJvci5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnZhbHVlMmlucHV0KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgZXJyb3IubXNnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yLm1zZyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zvcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dGb3JtKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiB2YWx1ZSBub3QgY2hhbmdlZCAtLT4gdHJpZ2dlciAnbm9jaGFuZ2UnIGV2ZW50IGFuZCByZXR1cm5cbiAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IHRydWUqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2F2ZW5vY2hhbmdlICYmIHRoaXMuaW5wdXQudmFsdWUyc3RyKG5ld1ZhbHVlKSA9PSB0aGlzLmlucHV0LnZhbHVlMnN0cih0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgLypqc2xpbnQgZXFlcTogZmFsc2UqLyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKiogICAgICAgIFxuICAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gdmFsdWUgbm90IGNoYW5nZWQgYnV0IGZvcm0gaXMgc3VibWl0dGVkLiBSZXF1aXJlcyBzYXZlbm9jaGFuZ2UgPSBmYWxzZS5cbiAgICAgICAgICAgICAgICBAZXZlbnQgbm9jaGFuZ2UgXG4gICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgICAgICoqLyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy4kZGl2LnRyaWdnZXJIYW5kbGVyKCdub2NoYW5nZScpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgIC8vY29udmVydCB2YWx1ZSBmb3Igc3VibWl0dGluZyB0byBzZXJ2ZXJcbiAgICAgICAgICAgIHZhciBzdWJtaXRWYWx1ZSA9IHRoaXMuaW5wdXQudmFsdWUyc3VibWl0KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5pc1NhdmluZyA9IHRydWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2VuZGluZyBkYXRhIHRvIHNlcnZlclxuICAgICAgICAgICAgJC53aGVuKHRoaXMuc2F2ZShzdWJtaXRWYWx1ZSkpXG4gICAgICAgICAgICAuZG9uZSgkLnByb3h5KGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy9ydW4gc3VjY2VzcyBjYWxsYmFja1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnN1Y2Nlc3MgPT09ICdmdW5jdGlvbicgPyB0aGlzLm9wdGlvbnMuc3VjY2Vzcy5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSwgcmVzcG9uc2UsIG5ld1ZhbHVlKSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHN1Y2Nlc3MgY2FsbGJhY2sgcmV0dXJucyBmYWxzZSAtLT4ga2VlcCBmb3JtIG9wZW4gYW5kIGRvIG5vdCBhY3RpdmF0ZSBpbnB1dFxuICAgICAgICAgICAgICAgIGlmKHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zvcm0oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pZiBzdWNjZXNzIGNhbGxiYWNrIHJldHVybnMgc3RyaW5nIC0tPiAga2VlcCBmb3JtIG9wZW4sIHNob3cgZXJyb3IgYW5kIGFjdGl2YXRlIGlucHV0ICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHJlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihyZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dGb3JtKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2lmIHN1Y2Nlc3MgY2FsbGJhY2sgcmV0dXJucyBvYmplY3QgbGlrZSB7bmV3VmFsdWU6IDxzb21ldGhpbmc+fSAtLT4gdXNlIHRoYXQgdmFsdWUgaW5zdGVhZCBvZiBzdWJtaXR0ZWRcbiAgICAgICAgICAgICAgICAvL2l0IGlzIHVzZWZ1bGwgaWYgeW91IHdhbnQgdG8gY2huYWdlIHZhbHVlIGluIHVybC1mdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmKHJlcyAmJiB0eXBlb2YgcmVzID09PSAnb2JqZWN0JyAmJiByZXMuaGFzT3duUHJvcGVydHkoJ25ld1ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSByZXMubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9jbGVhciBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihmYWxzZSk7ICAgXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICAgICAgRmlyZWQgd2hlbiBmb3JtIGlzIHN1Ym1pdHRlZFxuICAgICAgICAgICAgICAgIEBldmVudCBzYXZlIFxuICAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gcGFyYW1zIGFkZGl0aW9uYWwgcGFyYW1zXG4gICAgICAgICAgICAgICAgQHBhcmFtIHttaXhlZH0gcGFyYW1zLm5ld1ZhbHVlIHJhdyBuZXcgdmFsdWVcbiAgICAgICAgICAgICAgICBAcGFyYW0ge21peGVkfSBwYXJhbXMuc3VibWl0VmFsdWUgc3VibWl0dGVkIHZhbHVlIGFzIHN0cmluZ1xuICAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucmVzcG9uc2UgYWpheCByZXNwb25zZVxuXG4gICAgICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAkKCcjZm9ybS1kaXYnKS5vbignc2F2ZScpLCBmdW5jdGlvbihlLCBwYXJhbXMpe1xuICAgICAgICAgICAgICAgICAgICBpZihwYXJhbXMubmV3VmFsdWUgPT09ICd1c2VybmFtZScpIHsuLi59XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgKiovXG4gICAgICAgICAgICAgICAgdGhpcy4kZGl2LnRyaWdnZXJIYW5kbGVyKCdzYXZlJywge25ld1ZhbHVlOiBuZXdWYWx1ZSwgc3VibWl0VmFsdWU6IHN1Ym1pdFZhbHVlLCByZXNwb25zZTogcmVzcG9uc2V9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgLmZhaWwoJC5wcm94eShmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB2YXIgbXNnO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiB0aGlzLm9wdGlvbnMuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gdGhpcy5vcHRpb25zLmVycm9yLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlLCB4aHIsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtc2cgPSB0eXBlb2YgeGhyID09PSAnc3RyaW5nJyA/IHhociA6IHhoci5yZXNwb25zZVRleHQgfHwgeGhyLnN0YXR1c1RleHQgfHwgJ1Vua25vd24gZXJyb3IhJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93Rm9ybSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uKHN1Ym1pdFZhbHVlKSB7XG4gICAgICAgICAgICAvL3RyeSBwYXJzZSBjb21wb3NpdGUgcGsgZGVmaW5lZCBhcyBqc29uIHN0cmluZyBpbiBkYXRhLXBrIFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBrID0gJC5mbi5lZGl0YWJsZXV0aWxzLnRyeVBhcnNlSnNvbih0aGlzLm9wdGlvbnMucGssIHRydWUpOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBrID0gKHR5cGVvZiB0aGlzLm9wdGlvbnMucGsgPT09ICdmdW5jdGlvbicpID8gdGhpcy5vcHRpb25zLnBrLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlKSA6IHRoaXMub3B0aW9ucy5wayxcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIHNlbmQgb24gc2VydmVyIGluIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgICAgICAgMS4gdXJsIGlzIGZ1bmN0aW9uXG4gICAgICAgICAgICAgIDIuIHVybCBpcyBzdHJpbmcgQU5EIChwayBkZWZpbmVkIE9SIHNlbmQgb3B0aW9uID0gYWx3YXlzKSBcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZW5kID0gISEodHlwZW9mIHRoaXMub3B0aW9ucy51cmwgPT09ICdmdW5jdGlvbicgfHwgKHRoaXMub3B0aW9ucy51cmwgJiYgKCh0aGlzLm9wdGlvbnMuc2VuZCA9PT0gJ2Fsd2F5cycpIHx8ICh0aGlzLm9wdGlvbnMuc2VuZCA9PT0gJ2F1dG8nICYmIHBrICE9PSBudWxsICYmIHBrICE9PSB1bmRlZmluZWQpKSkpLFxuICAgICAgICAgICAgcGFyYW1zO1xuXG4gICAgICAgICAgICBpZiAoc2VuZCkgeyAvL3NlbmQgdG8gc2VydmVyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93TG9hZGluZygpO1xuXG4gICAgICAgICAgICAgICAgLy9zdGFuZGFyZCBwYXJhbXNcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMub3B0aW9ucy5uYW1lIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3VibWl0VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBrOiBwayBcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy9hZGRpdGlvbmFsIHBhcmFtc1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiB0aGlzLm9wdGlvbnMucGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHRoaXMub3B0aW9ucy5wYXJhbXMuY2FsbCh0aGlzLm9wdGlvbnMuc2NvcGUsIHBhcmFtcyk7ICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL3RyeSBwYXJzZSBqc29uIGluIHNpbmdsZSBxdW90ZXMgKGZyb20gZGF0YS1wYXJhbXMgYXR0cmlidXRlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucGFyYW1zID0gJC5mbi5lZGl0YWJsZXV0aWxzLnRyeVBhcnNlSnNvbih0aGlzLm9wdGlvbnMucGFyYW1zLCB0cnVlKTsgICBcbiAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQocGFyYW1zLCB0aGlzLm9wdGlvbnMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgdGhpcy5vcHRpb25zLnVybCA9PT0gJ2Z1bmN0aW9uJykgeyAvL3VzZXIncyBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnVybC5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAgXG4gICAgICAgICAgICAgICAgICAgIC8vc2VuZCBhamF4IHRvIHNlcnZlciBhbmQgcmV0dXJuIGRlZmVycmVkIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5hamF4KCQuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCAgICAgOiB0aGlzLm9wdGlvbnMudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSAgICA6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgICAgOiAnUE9TVCdcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLmFqYXhPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBcblxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnZhbGlkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YWxpZGF0ZS5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYoa2V5IGluIHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2RvIG5vdCBwYXNzIG9wdGlvbiB0byBpbnB1dCBhcyBpdCBpcyBwYXNzZWQgaW4gZWRpdGFibGUtZWxlbWVudFxuICAgICAgICB9LFxuXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgY29udmVydFN0cikge1xuICAgICAgICAgICAgaWYoY29udmVydFN0cikge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmlucHV0LnN0cjJ2YWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiBmb3JtIGlzIHZpc2libGUsIHVwZGF0ZSBpbnB1dFxuICAgICAgICAgICAgaWYodGhpcy4kZm9ybSAmJiB0aGlzLiRmb3JtLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC52YWx1ZTJpbnB1dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfSAgICAgICAgICAgICAgIFxuICAgIH07XG5cbiAgICAvKlxuICAgIEluaXRpYWxpemUgZWRpdGFibGVmb3JtLiBBcHBsaWVkIHRvIGpRdWVyeSBvYmplY3QuXG5cbiAgICBAbWV0aG9kICQoKS5lZGl0YWJsZWZvcm0ob3B0aW9ucylcbiAgICBAcGFyYW1zIHtPYmplY3R9IG9wdGlvbnNcbiAgICBAZXhhbXBsZVxuICAgIHZhciAkZm9ybSA9ICQoJyZsdDtkaXYmZ3Q7JykuZWRpdGFibGVmb3JtKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBuYW1lOiAndXNlcm5hbWUnLFxuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHZhbHVlOiAndml0YWxpeSdcbiAgICB9KTtcblxuICAgIC8vdG8gZGlzcGxheSBmb3JtIHlvdSBzaG91bGQgY2FsbCAncmVuZGVyJyBtZXRob2RcbiAgICAkZm9ybS5lZGl0YWJsZWZvcm0oJ3JlbmRlcicpOyAgICAgXG4gICAgKi9cbiAgICAkLmZuLmVkaXRhYmxlZm9ybSA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSwgXG4gICAgICAgICAgICBkYXRhID0gJHRoaXMuZGF0YSgnZWRpdGFibGVmb3JtJyksIFxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT09ICdvYmplY3QnICYmIG9wdGlvbjsgXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKCdlZGl0YWJsZWZvcm0nLCAoZGF0YSA9IG5ldyBFZGl0YWJsZUZvcm0odGhpcywgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnKSB7IC8vY2FsbCBtZXRob2QgXG4gICAgICAgICAgICAgICAgZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvL2tlZXAgbGluayB0byBjb25zdHJ1Y3RvciB0byBhbGxvdyBpbmhlcml0YW5jZVxuICAgICQuZm4uZWRpdGFibGVmb3JtLkNvbnN0cnVjdG9yID0gRWRpdGFibGVGb3JtOyAgICBcblxuICAgIC8vZGVmYXVsdHNcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5kZWZhdWx0cyA9IHtcbiAgICAgICAgLyogc2VlIGFsc28gZGVmYXVsdHMgZm9yIGlucHV0ICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgIFR5cGUgb2YgaW5wdXQuIENhbiBiZSA8Y29kZT50ZXh0fHRleHRhcmVhfHNlbGVjdHxkYXRlfGNoZWNrbGlzdDwvY29kZT5cblxuICAgICAgICBAcHJvcGVydHkgdHlwZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICd0ZXh0J1xuICAgICAgICAqKi9cbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAvKipcbiAgICAgICAgVXJsIGZvciBzdWJtaXQsIGUuZy4gPGNvZGU+Jy9wb3N0JzwvY29kZT4gIFxuICAgICAgICBJZiBmdW5jdGlvbiAtIGl0IHdpbGwgYmUgY2FsbGVkIGluc3RlYWQgb2YgYWpheC4gRnVuY3Rpb24gc2hvdWxkIHJldHVybiBkZWZlcnJlZCBvYmplY3QgdG8gcnVuIGZhaWwvZG9uZSBjYWxsYmFja3MuXG5cbiAgICAgICAgQHByb3BlcnR5IHVybCBcbiAgICAgICAgQHR5cGUgc3RyaW5nfGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgdXJsOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBkID0gbmV3ICQuRGVmZXJyZWQ7XG4gICAgICAgICAgICBpZihwYXJhbXMudmFsdWUgPT09ICdhYmMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQucmVqZWN0KCdlcnJvciBtZXNzYWdlJyk7IC8vcmV0dXJuaW5nIGVycm9yIHZpYSBkZWZlcnJlZCBvYmplY3RcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9hc3luYyBzYXZpbmcgZGF0YSBpbiBqcyBtb2RlbFxuICAgICAgICAgICAgICAgIHNvbWVNb2RlbC5hc3luY1NhdmVNZXRob2Qoe1xuICAgICAgICAgICAgICAgICAgIC4uLiwgXG4gICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICBkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7IFxuICAgICAgICAgICAgICAgIHJldHVybiBkLnByb21pc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgdXJsOm51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBBZGRpdGlvbmFsIHBhcmFtcyBmb3Igc3VibWl0LiBJZiBkZWZpbmVkIGFzIDxjb2RlPm9iamVjdDwvY29kZT4gLSBpdCBpcyAqKmFwcGVuZGVkKiogdG8gb3JpZ2luYWwgYWpheCBkYXRhIChwaywgbmFtZSBhbmQgdmFsdWUpLiAgXG4gICAgICAgIElmIGRlZmluZWQgYXMgPGNvZGU+ZnVuY3Rpb248L2NvZGU+IC0gcmV0dXJuZWQgb2JqZWN0ICoqb3ZlcndyaXRlcyoqIG9yaWdpbmFsIGFqYXggZGF0YS5cbiAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgcGFyYW1zOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgIC8vb3JpZ2luYWxseSBwYXJhbXMgY29udGFpbiBwaywgbmFtZSBhbmQgdmFsdWVcbiAgICAgICAgICAgIHBhcmFtcy5hID0gMTtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH1cblxuICAgICAgICBAcHJvcGVydHkgcGFyYW1zIFxuICAgICAgICBAdHlwZSBvYmplY3R8ZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIHBhcmFtczpudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgTmFtZSBvZiBmaWVsZC4gV2lsbCBiZSBzdWJtaXR0ZWQgb24gc2VydmVyLiBDYW4gYmUgdGFrZW4gZnJvbSA8Y29kZT5pZDwvY29kZT4gYXR0cmlidXRlXG5cbiAgICAgICAgQHByb3BlcnR5IG5hbWUgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgUHJpbWFyeSBrZXkgb2YgZWRpdGFibGUgb2JqZWN0IChlLmcuIHJlY29yZCBpZCBpbiBkYXRhYmFzZSkuIEZvciBjb21wb3NpdGUga2V5cyB1c2Ugb2JqZWN0LCBlLmcuIDxjb2RlPntpZDogMSwgbGFuZzogJ2VuJ308L2NvZGU+LlxuICAgICAgICBDYW4gYmUgY2FsY3VsYXRlZCBkeW5hbWljYWxseSB2aWEgZnVuY3Rpb24uXG5cbiAgICAgICAgQHByb3BlcnR5IHBrIFxuICAgICAgICBAdHlwZSBzdHJpbmd8b2JqZWN0fGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHBrOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgSW5pdGlhbCB2YWx1ZS4gSWYgbm90IGRlZmluZWQgLSB3aWxsIGJlIHRha2VuIGZyb20gZWxlbWVudCdzIGNvbnRlbnQuXG4gICAgICAgIEZvciBfX3NlbGVjdF9fIHR5cGUgc2hvdWxkIGJlIGRlZmluZWQgKGFzIGl0IGlzIElEIG9mIHNob3duIHRleHQpLlxuXG4gICAgICAgIEBwcm9wZXJ0eSB2YWx1ZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nfG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgVmFsdWUgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBpbiBpbnB1dCBpZiBvcmlnaW5hbCBmaWVsZCB2YWx1ZSBpcyBlbXB0eSAoYG51bGx8dW5kZWZpbmVkfCcnYCkuXG5cbiAgICAgICAgQHByb3BlcnR5IGRlZmF1bHRWYWx1ZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nfG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjQuNlxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBTdHJhdGVneSBmb3Igc2VuZGluZyBkYXRhIG9uIHNlcnZlci4gQ2FuIGJlIGBhdXRvfGFsd2F5c3xuZXZlcmAuXG4gICAgICAgIFdoZW4gJ2F1dG8nIGRhdGEgd2lsbCBiZSBzZW50IG9uIHNlcnZlciAqKm9ubHkgaWYgcGsgYW5kIHVybCBkZWZpbmVkKiosIG90aGVyd2lzZSBuZXcgdmFsdWUgd2lsbCBiZSBzdG9yZWQgbG9jYWxseS5cblxuICAgICAgICBAcHJvcGVydHkgc2VuZCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICdhdXRvJ1xuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIHNlbmQ6ICdhdXRvJywgXG4gICAgICAgIC8qKlxuICAgICAgICBGdW5jdGlvbiBmb3IgY2xpZW50LXNpZGUgdmFsaWRhdGlvbi4gSWYgcmV0dXJucyBzdHJpbmcgLSBtZWFucyB2YWxpZGF0aW9uIG5vdCBwYXNzZWQgYW5kIHN0cmluZyBzaG93ZWQgYXMgZXJyb3IuXG4gICAgICAgIFNpbmNlIDEuNS4xIHlvdSBjYW4gbW9kaWZ5IHN1Ym1pdHRlZCB2YWx1ZSBieSByZXR1cm5pbmcgb2JqZWN0IGZyb20gYHZhbGlkYXRlYDogXG4gICAgICAgIGB7bmV3VmFsdWU6ICcuLi4nfWAgb3IgYHtuZXdWYWx1ZTogJy4uLicsIG1zZzogJy4uLid9YFxuXG4gICAgICAgIEBwcm9wZXJ0eSB2YWxpZGF0ZSBcbiAgICAgICAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmKCQudHJpbSh2YWx1ZSkgPT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1RoaXMgZmllbGQgaXMgcmVxdWlyZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB2YWxpZGF0ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIFN1Y2Nlc3MgY2FsbGJhY2suIENhbGxlZCB3aGVuIHZhbHVlIHN1Y2Nlc3NmdWxseSBzZW50IG9uIHNlcnZlciBhbmQgKipyZXNwb25zZSBzdGF0dXMgPSAyMDAqKi4gIFxuICAgICAgICBVc2VmdWxsIHRvIHdvcmsgd2l0aCBqc29uIHJlc3BvbnNlLiBGb3IgZXhhbXBsZSwgaWYgeW91ciBiYWNrZW5kIHJlc3BvbnNlIGNhbiBiZSA8Y29kZT57c3VjY2VzczogdHJ1ZX08L2NvZGU+XG4gICAgICAgIG9yIDxjb2RlPntzdWNjZXNzOiBmYWxzZSwgbXNnOiBcInNlcnZlciBlcnJvclwifTwvY29kZT4geW91IGNhbiBjaGVjayBpdCBpbnNpZGUgdGhpcyBjYWxsYmFjay4gIFxuICAgICAgICBJZiBpdCByZXR1cm5zICoqc3RyaW5nKiogLSBtZWFucyBlcnJvciBvY2N1cmVkIGFuZCBzdHJpbmcgaXMgc2hvd24gYXMgZXJyb3IgbWVzc2FnZS4gIFxuICAgICAgICBJZiBpdCByZXR1cm5zICoqb2JqZWN0IGxpa2UqKiA8Y29kZT57bmV3VmFsdWU6ICZsdDtzb21ldGhpbmcmZ3Q7fTwvY29kZT4gLSBpdCBvdmVyd3JpdGVzIHZhbHVlLCBzdWJtaXR0ZWQgYnkgdXNlci4gIFxuICAgICAgICBPdGhlcndpc2UgbmV3VmFsdWUgc2ltcGx5IHJlbmRlcmVkIGludG8gZWxlbWVudC5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBzdWNjZXNzIFxuICAgICAgICBAdHlwZSBmdW5jdGlvblxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlc3BvbnNlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYoIXJlc3BvbnNlLnN1Y2Nlc3MpIHJldHVybiByZXNwb25zZS5tc2c7XG4gICAgICAgIH1cbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBzdWNjZXNzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgRXJyb3IgY2FsbGJhY2suIENhbGxlZCB3aGVuIHJlcXVlc3QgZmFpbGVkIChyZXNwb25zZSBzdGF0dXMgIT0gMjAwKS4gIFxuICAgICAgICBVc2VmdWxsIHdoZW4geW91IHdhbnQgdG8gcGFyc2UgZXJyb3IgcmVzcG9uc2UgYW5kIGRpc3BsYXkgYSBjdXN0b20gbWVzc2FnZS5cbiAgICAgICAgTXVzdCByZXR1cm4gKipzdHJpbmcqKiAtIHRoZSBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgZXJyb3IgYmxvY2suXG4gICAgICAgICAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBlcnJvciBcbiAgICAgICAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAc2luY2UgMS40LjRcbiAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHJlc3BvbnNlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYocmVzcG9uc2Uuc3RhdHVzID09PSA1MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1NlcnZpY2UgdW5hdmFpbGFibGUuIFBsZWFzZSB0cnkgbGF0ZXIuJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgQWRkaXRpb25hbCBvcHRpb25zIGZvciBzdWJtaXQgYWpheCByZXF1ZXN0LlxuICAgICAgICBMaXN0IG9mIHZhbHVlczogaHR0cDovL2FwaS5qcXVlcnkuY29tL2pRdWVyeS5hamF4XG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgYWpheE9wdGlvbnMgXG4gICAgICAgIEB0eXBlIG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjEuMSAgICAgICAgXG4gICAgICAgIEBleGFtcGxlIFxuICAgICAgICBhamF4T3B0aW9uczoge1xuICAgICAgICAgICAgdHlwZTogJ3B1dCcsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBhamF4T3B0aW9uczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZXJlIHRvIHNob3cgYnV0dG9uczogbGVmdCh0cnVlKXxib3R0b218ZmFsc2UgIFxuICAgICAgICBGb3JtIHdpdGhvdXQgYnV0dG9ucyBpcyBhdXRvLXN1Ym1pdHRlZC5cblxuICAgICAgICBAcHJvcGVydHkgc2hvd2J1dHRvbnMgXG4gICAgICAgIEB0eXBlIGJvb2xlYW58c3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IHRydWVcbiAgICAgICAgQHNpbmNlIDEuMS4xXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBzaG93YnV0dG9uczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgIFNjb3BlIGZvciBjYWxsYmFjayBtZXRob2RzIChzdWNjZXNzLCB2YWxpZGF0ZSkuICBcbiAgICAgICAgSWYgPGNvZGU+bnVsbDwvY29kZT4gbWVhbnMgZWRpdGFibGVmb3JtIGluc3RhbmNlIGl0c2VsZi4gXG5cbiAgICAgICAgQHByb3BlcnR5IHNjb3BlIFxuICAgICAgICBAdHlwZSBET01FbGVtZW50fG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICBAcHJpdmF0ZVxuICAgICAgICAqKi8gICAgICAgICAgICBcbiAgICAgICAgc2NvcGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBXaGV0aGVyIHRvIHNhdmUgb3IgY2FuY2VsIHZhbHVlIHdoZW4gaXQgd2FzIG5vdCBjaGFuZ2VkIGJ1dCBmb3JtIHdhcyBzdWJtaXR0ZWRcblxuICAgICAgICBAcHJvcGVydHkgc2F2ZW5vY2hhbmdlIFxuICAgICAgICBAdHlwZSBib29sZWFuXG4gICAgICAgIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICAqKi9cbiAgICAgICAgc2F2ZW5vY2hhbmdlOiBmYWxzZVxuICAgIH07ICAgXG5cbiAgICAvKlxuICAgIE5vdGU6IGZvbGxvd2luZyBwYXJhbXMgY291bGQgcmVkZWZpbmVkIGluIGVuZ2luZTogYm9vdHN0cmFwIG9yIGpxdWVyeXVpOlxuICAgIENsYXNzZXMgJ2NvbnRyb2wtZ3JvdXAnIGFuZCAnZWRpdGFibGUtZXJyb3ItYmxvY2snIG11c3QgYWx3YXlzIHByZXNlbnQhXG4gICAgKi8gICAgICBcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS50ZW1wbGF0ZSA9ICc8Zm9ybSBjbGFzcz1cImZvcm0taW5saW5lIGVkaXRhYmxlZm9ybVwiPicrXG4gICAgJzxkaXYgY2xhc3M9XCJjb250cm9sLWdyb3VwXCI+JyArIFxuICAgICc8ZGl2PjxkaXYgY2xhc3M9XCJlZGl0YWJsZS1pbnB1dFwiPjwvZGl2PjxkaXYgY2xhc3M9XCJlZGl0YWJsZS1idXR0b25zXCI+PC9kaXY+PC9kaXY+JytcbiAgICAnPGRpdiBjbGFzcz1cImVkaXRhYmxlLWVycm9yLWJsb2NrXCI+PC9kaXY+JyArIFxuICAgICc8L2Rpdj4nICsgXG4gICAgJzwvZm9ybT4nO1xuXG4gICAgLy9sb2FkaW5nIGRpdlxuICAgICQuZm4uZWRpdGFibGVmb3JtLmxvYWRpbmcgPSAnPGRpdiBjbGFzcz1cImVkaXRhYmxlZm9ybS1sb2FkaW5nXCI+PC9kaXY+JztcblxuICAgIC8vYnV0dG9uc1xuICAgICQuZm4uZWRpdGFibGVmb3JtLmJ1dHRvbnMgPSAnPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3M9XCJlZGl0YWJsZS1zdWJtaXRcIj5vazwvYnV0dG9uPicrXG4gICAgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiZWRpdGFibGUtY2FuY2VsXCI+Y2FuY2VsPC9idXR0b24+JzsgICAgICBcblxuICAgIC8vZXJyb3IgY2xhc3MgYXR0YWNoZWQgdG8gY29udHJvbC1ncm91cFxuICAgICQuZm4uZWRpdGFibGVmb3JtLmVycm9yR3JvdXBDbGFzcyA9IG51bGw7ICBcblxuICAgIC8vZXJyb3IgY2xhc3MgYXR0YWNoZWQgdG8gZWRpdGFibGUtZXJyb3ItYmxvY2tcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckJsb2NrQ2xhc3MgPSAnZWRpdGFibGUtZXJyb3InO1xuICAgIFxuICAgIC8vZW5naW5lXG4gICAgJC5mbi5lZGl0YWJsZWZvcm0uZW5naW5lID0gJ2pxdWVyeSc7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG4qIEVkaXRhYmxlRm9ybSB1dGlsaXRlc1xuKi9cbihmdW5jdGlvbiAoJCkge1xuXG4gICAgLy91dGlsc1xuICAgICQuZm4uZWRpdGFibGV1dGlscyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICogY2xhc3NpYyBKUyBpbmhlcml0YW5jZSBmdW5jdGlvblxuICAgICAgICAqLyAgXG4gICAgICAgIGluaGVyaXQ6IGZ1bmN0aW9uIChDaGlsZCwgUGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgRiA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBQYXJlbnQucHJvdG90eXBlO1xuICAgICAgICAgICAgQ2hpbGQucHJvdG90eXBlID0gbmV3IEYoKTtcbiAgICAgICAgICAgIENoaWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENoaWxkO1xuICAgICAgICAgICAgQ2hpbGQuc3VwZXJjbGFzcyA9IFBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogc2V0IGNhcmV0IHBvc2l0aW9uIGluIGlucHV0XG4gICAgICAgICogc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk5MTI2L2pxdWVyeS1zZXQtY3Vyc29yLXBvc2l0aW9uLWluLXRleHQtYXJlYVxuICAgICAgICAqLyAgICAgICAgXG4gICAgICAgIHNldEN1cnNvclBvc2l0aW9uOiBmdW5jdGlvbihlbGVtLCBwb3MpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLnNldFNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zZXRTZWxlY3Rpb25SYW5nZShwb3MsIHBvcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0uY3JlYXRlVGV4dFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZWxlbS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBwb3MpO1xuICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgcG9zKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgKiBmdW5jdGlvbiB0byBwYXJzZSBKU09OIGluICpzaW5nbGUqIHF1b3Rlcy4gKGpxdWVyeSBhdXRvbWF0aWNhbGx5IHBhcnNlIG9ubHkgZG91YmxlIHF1b3RlcylcbiAgICAgICAgKiBUaGF0IGFsbG93cyBzdWNoIGNvZGUgYXM6IDxhIGRhdGEtc291cmNlPVwieydhJzogJ2InLCAnYyc6ICdkJ31cIj5cbiAgICAgICAgKiBzYWZlID0gdHJ1ZSAtLT4gbWVhbnMgbm8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duXG4gICAgICAgICogZm9yIGRldGFpbHMgc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQxMDM0OC9ob3ctdG8tc2V0LWpzb24tZm9ybWF0LXRvLWh0bWw1LWRhdGEtYXR0cmlidXRlcy1pbi10aGUtanF1ZXJ5XG4gICAgICAgICovXG4gICAgICAgIHRyeVBhcnNlSnNvbjogZnVuY3Rpb24ocywgc2FmZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJyAmJiBzLmxlbmd0aCAmJiBzLm1hdGNoKC9eW1xce1xcW10uKltcXH1cXF1dJC8pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhZmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGV2aWw6IHRydWUqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgcykpKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKmpzbGludCBldmlsOiBmYWxzZSovXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKmpzbGludCBldmlsOiB0cnVlKi9cbiAgICAgICAgICAgICAgICAgICAgcyA9IChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgcykpKCk7XG4gICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGV2aWw6IGZhbHNlKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgKiBzbGljZSBvYmplY3QgYnkgc3BlY2lmaWVkIGtleXNcbiAgICAgICAgKi9cbiAgICAgICAgc2xpY2VPYmo6IGZ1bmN0aW9uKG9iaiwga2V5cywgY2FzZVNlbnNpdGl2ZSAvKiBkZWZhdWx0OiBmYWxzZSAqLykge1xuICAgICAgICAgICAgdmFyIGtleSwga2V5TG93ZXIsIG5ld09iaiA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoISQuaXNBcnJheShrZXlzKSB8fCAha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGNhc2VTZW5zaXRpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy93aGVuIGdldHRpbmcgZGF0YS0qIGF0dHJpYnV0ZXMgdmlhICQuZGF0YSgpIGl0J3MgY29udmVydGVkIHRvIGxvd2VyY2FzZS5cbiAgICAgICAgICAgICAgICAvL2RldGFpbHM6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzYwMjU2NS91c2luZy1kYXRhLWF0dHJpYnV0ZXMtd2l0aC1qcXVlcnlcbiAgICAgICAgICAgICAgICAvL3dvcmthcm91bmQgaXMgY29kZSBiZWxvdy5cbiAgICAgICAgICAgICAgICBrZXlMb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5TG93ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleUxvd2VyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgZXhjbHVkZSBjb21wbGV4IG9iamVjdHMgZnJvbSAkLmRhdGEoKSBiZWZvcmUgcGFzcyB0byBjb25maWdcbiAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29uZmlnRGF0YTogZnVuY3Rpb24oJGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICAkLmVhY2goJGVsZW1lbnQuZGF0YSgpLCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHYgIT09ICdvYmplY3QnIHx8ICh2ICYmIHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiAodi5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8IHYuY29uc3RydWN0b3IgPT09IEFycmF5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgcmV0dXJucyBrZXlzIG9mIG9iamVjdFxuICAgICAgICAqL1xuICAgICAgICBvYmplY3RLZXlzOiBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobyk7ICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG8gIT09IE9iamVjdChvKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrPVtdLCBwO1xuICAgICAgICAgICAgICAgIGZvciAocCBpbiBvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobyxwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgay5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgIC8qKlxuICAgICAgICBtZXRob2QgdG8gZXNjYXBlIGh0bWwuXG4gICAgICAgKiovXG4gICAgICAgZXNjYXBlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgcmV0dXJuICQoJzxkaXY+JykudGV4dChzdHIpLmh0bWwoKTtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgIHJldHVybnMgYXJyYXkgaXRlbXMgZnJvbSBzb3VyY2VEYXRhIGhhdmluZyB2YWx1ZSBwcm9wZXJ0eSBlcXVhbCBvciBpbkFycmF5IG9mICd2YWx1ZSdcbiAgICAgICAqL1xuICAgICAgIGl0ZW1zQnlWYWx1ZTogZnVuY3Rpb24odmFsdWUsIHNvdXJjZURhdGEsIHZhbHVlUHJvcCkge1xuICAgICAgICAgICBpZighc291cmNlRGF0YSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICBpZiAodHlwZW9mKHZhbHVlUHJvcCkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgdmFyIGlkS2V5ID0gdmFsdWVQcm9wIHx8ICd2YWx1ZSc7XG4gICAgICAgICAgICAgICB2YWx1ZVByb3AgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZVtpZEtleV07IH07XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgdmFyIGlzVmFsQXJyYXkgPSAkLmlzQXJyYXkodmFsdWUpLFxuICAgICAgICAgICByZXN1bHQgPSBbXSwgXG4gICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICQuZWFjaChzb3VyY2VEYXRhLCBmdW5jdGlvbihpLCBvKSB7XG4gICAgICAgICAgICAgICBpZihvLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGF0Lml0ZW1zQnlWYWx1ZSh2YWx1ZSwgby5jaGlsZHJlbiwgdmFsdWVQcm9wKSk7XG4gICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IHRydWUqL1xuICAgICAgICAgICAgICAgICAgIGlmKGlzVmFsQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgaWYoJC5ncmVwKHZhbHVlLCBmdW5jdGlvbih2KXsgIHJldHVybiB2ID09IChvICYmIHR5cGVvZiBvID09PSAnb2JqZWN0JyA/IHZhbHVlUHJvcChvKSA6IG8pOyB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG8pOyBcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVmFsdWUgPSAobyAmJiAodHlwZW9mIG8gPT09ICdvYmplY3QnKSkgPyB2YWx1ZVByb3AobykgOiBvO1xuICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZSA9PSBpdGVtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG8pOyBcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAvKmpzbGludCBlcWVxOiBmYWxzZSovXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgICBcbiAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgUmV0dXJucyBpbnB1dCBieSBvcHRpb25zOiB0eXBlLCBtb2RlLiBcbiAgICAgICAqL1xuICAgICAgIGNyZWF0ZUlucHV0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgIHZhciBUeXBlQ29uc3RydWN0b3IsIHR5cGVPcHRpb25zLCBpbnB1dCxcbiAgICAgICAgICAgdHlwZSA9IG9wdGlvbnMudHlwZTtcblxuICAgICAgICAgICAvL2BkYXRlYCBpcyBzb21lIGtpbmQgb2YgdmlydHVhbCB0eXBlIHRoYXQgaXMgdHJhbnNmb3JtZWQgdG8gb25lIG9mIGV4YWN0IHR5cGVzXG4gICAgICAgICAgIC8vZGVwZW5kaW5nIG9uIG1vZGUgYW5kIGNvcmUgbGliXG4gICAgICAgICAgIGlmKHR5cGUgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgICAgLy9pbmxpbmVcbiAgICAgICAgICAgICAgIGlmKG9wdGlvbnMubW9kZSA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICAgICBpZigkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnZGF0ZWZpZWxkJztcbiAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGV1aWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnZGF0ZXVpZmllbGQnO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIC8vcG9wdXBcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgaWYoJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdkYXRlJztcbiAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGV1aSkge1xuICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2RhdGV1aSc7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAvL2lmIHR5cGUgc3RpbGwgYGRhdGVgIGFuZCBub3QgZXhpc3QgaW4gdHlwZXMsIHJlcGxhY2Ugd2l0aCBgY29tYm9kYXRlYCB0aGF0IGlzIGJhc2UgaW5wdXRcbiAgICAgICAgICAgICAgIGlmKHR5cGUgPT09ICdkYXRlJyAmJiAhJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2NvbWJvZGF0ZSc7XG4gICAgICAgICAgICAgICB9IFxuICAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICAvL2BkYXRldGltZWAgc2hvdWxkIGJlIGRhdGV0aW1lZmllbGQgaW4gJ2lubGluZScgbW9kZVxuICAgICAgICAgICBpZih0eXBlID09PSAnZGF0ZXRpbWUnICYmIG9wdGlvbnMubW9kZSA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICB0eXBlID0gJ2RhdGV0aW1lZmllbGQnOyAgXG4gICAgICAgICAgIH0gICAgICAgICAgIFxuXG4gICAgICAgICAgIC8vY2hhbmdlIHd5c2lodG1sNSB0byB0ZXh0YXJlYSBmb3IganF1ZXJ5IFVJIGFuZCBwbGFpbiB2ZXJzaW9uc1xuICAgICAgICAgICBpZih0eXBlID09PSAnd3lzaWh0bWw1JyAmJiAhJC5mbi5lZGl0YWJsZXR5cGVzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICB0eXBlID0gJ3RleHRhcmVhJztcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vY3JlYXRlIGlucHV0IG9mIHNwZWNpZmllZCB0eXBlLiBJbnB1dCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgdmFsdWUsIG5vdCBpbiBmb3JtXG4gICAgICAgICAgIGlmKHR5cGVvZiAkLmZuLmVkaXRhYmxldHlwZXNbdHlwZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgIFR5cGVDb25zdHJ1Y3RvciA9ICQuZm4uZWRpdGFibGV0eXBlc1t0eXBlXTtcbiAgICAgICAgICAgICAgIHR5cGVPcHRpb25zID0gdGhpcy5zbGljZU9iaihvcHRpb25zLCB0aGlzLm9iamVjdEtleXMoVHlwZUNvbnN0cnVjdG9yLmRlZmF1bHRzKSk7XG4gICAgICAgICAgICAgICBpbnB1dCA9IG5ldyBUeXBlQ29uc3RydWN0b3IodHlwZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgJC5lcnJvcignVW5rbm93biB0eXBlOiAnKyB0eXBlKTtcbiAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgXG4gICAgICAgICAgIH0gIFxuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgLy9zZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MjY0ODk5L2RldGVjdC1jc3MtdHJhbnNpdGlvbnMtdXNpbmctamF2YXNjcmlwdC1hbmQtd2l0aG91dC1tb2Rlcm5penJcbiAgICAgICBzdXBwb3J0c1RyYW5zaXRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgIHZhciBiID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICBzID0gYi5zdHlsZSxcbiAgICAgICAgICAgICAgIHAgPSAndHJhbnNpdGlvbicsXG4gICAgICAgICAgICAgICB2ID0gWydNb3onLCAnV2Via2l0JywgJ0todG1sJywgJ08nLCAnbXMnXTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICBpZih0eXBlb2Ygc1twXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyBcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vIFRlc3RzIGZvciB2ZW5kb3Igc3BlY2lmaWMgcHJvcFxuICAgICAgICAgICBwID0gcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHAuc3Vic3RyKDEpO1xuICAgICAgICAgICBmb3IodmFyIGk9MDsgaTx2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICBpZih0eXBlb2Ygc1t2W2ldICsgcF0gPT09ICdzdHJpbmcnKSB7IFxuICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyBcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgfSAgICAgICAgICAgIFxuICAgICAgIFxuICAgIH07ICAgICAgXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5BdHRhY2hlcyBzdGFuZC1hbG9uZSBjb250YWluZXIgd2l0aCBlZGl0YWJsZS1mb3JtIHRvIEhUTUwgZWxlbWVudC4gRWxlbWVudCBpcyB1c2VkIG9ubHkgZm9yIHBvc2l0aW9uaW5nLCB2YWx1ZSBpcyBub3Qgc3RvcmVkIGFueXdoZXJlLjxicj5cblRoaXMgbWV0aG9kIGFwcGxpZWQgaW50ZXJuYWxseSBpbiA8Y29kZT4kKCkuZWRpdGFibGUoKTwvY29kZT4uIFlvdSBzaG91bGQgc3Vic2NyaWJlIG9uIGl0J3MgZXZlbnRzIChzYXZlIC8gY2FuY2VsKSB0byBnZXQgcHJvZml0IG9mIGl0Ljxicj5cbkZpbmFsIHJlYWxpemF0aW9uIGNhbiBiZSBkaWZmZXJlbnQ6IGJvb3RzdHJhcC1wb3BvdmVyLCBqcXVlcnl1aS10b29sdGlwLCBwb3NoeXRpcCwgaW5saW5lLWRpdi4gSXQgZGVwZW5kcyBvbiB3aGljaCBqcyBmaWxlIHlvdSBpbmNsdWRlLjxicj5cbkFwcGxpZWQgYXMgalF1ZXJ5IG1ldGhvZC5cblxuQGNsYXNzIGVkaXRhYmxlQ29udGFpbmVyXG5AdXNlcyBlZGl0YWJsZWZvcm1cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG5cbiAgICB2YXIgUG9wdXAgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgSW5saW5lID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH07ICAgIFxuXG4gICAgLy9tZXRob2RzXG4gICAgUG9wdXAucHJvdG90eXBlID0ge1xuICAgICAgICBjb250YWluZXJOYW1lOiBudWxsLCAvL21ldGhvZCB0byBjYWxsIGNvbnRhaW5lciBvbiBlbGVtZW50XG4gICAgICAgIGNvbnRhaW5lckRhdGFOYW1lOiBudWxsLCAvL29iamVjdCBuYW1lIGluIGVsZW1lbnQncyAuZGF0YSgpXG4gICAgICAgIGlubmVyQ3NzOiBudWxsLCAvL3RiZCBpbiBjaGlsZCBjbGFzc1xuICAgICAgICBjb250YWluZXJDbGFzczogJ2VkaXRhYmxlLWNvbnRhaW5lciBlZGl0YWJsZS1wb3B1cCcsIC8vY3NzIGNsYXNzIGFwcGxpZWQgdG8gY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgZGVmYXVsdHM6IHt9LCAvL2NvbnRhaW5lciBpdHNlbGYgZGVmYXVsdHNcbiAgICAgICAgXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgICAgICAgLy9zaW5jZSAxLjQuMSBjb250YWluZXIgZG8gbm90IHVzZSBkYXRhLSogZGlyZWN0bHkgYXMgdGhleSBhbHJlYWR5IG1lcmdlZCBpbnRvIG9wdGlvbnMuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZUNvbnRhaW5lci5kZWZhdWx0cywgb3B0aW9ucyk7ICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnNwbGl0T3B0aW9ucygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3NldCBzY29wZSBvZiBmb3JtIGNhbGxiYWNrcyB0byBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLmZvcm1PcHRpb25zLnNjb3BlID0gdGhpcy4kZWxlbWVudFswXTsgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaW5pdENvbnRhaW5lcigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2ZsYWcgdG8gaGlkZSBjb250YWluZXIsIHdoZW4gc2F2aW5nIHZhbHVlIHdpbGwgZmluaXNoXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRIaWRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vYmluZCAnZGVzdHJveWVkJyBsaXN0ZW5lciB0byBkZXN0cm95IGNvbnRhaW5lciB3aGVuIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIGRvbVxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vbignZGVzdHJveWVkJywgJC5wcm94eShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hdHRhY2ggZG9jdW1lbnQgaGFuZGxlciB0byBjbG9zZSBjb250YWluZXJzIG9uIGNsaWNrIC8gZXNjYXBlXG4gICAgICAgICAgICBpZighJChkb2N1bWVudCkuZGF0YSgnZWRpdGFibGUtaGFuZGxlcnMtYXR0YWNoZWQnKSkge1xuICAgICAgICAgICAgICAgIC8vY2xvc2UgYWxsIG9uIGVzY2FwZVxuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdrZXl1cC5lZGl0YWJsZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAyNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnLmVkaXRhYmxlLW9wZW4nKS5lZGl0YWJsZUNvbnRhaW5lcignaGlkZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy90b2RvOiByZXR1cm4gZm9jdXMgb24gZWxlbWVudCBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9jbG9zZSBjb250YWluZXJzIHdoZW4gY2xpY2sgb3V0c2lkZSBcbiAgICAgICAgICAgICAgICAvLyhtb3VzZWRvd24gY291bGQgYmUgYmV0dGVyIHRoYW4gY2xpY2ssIGl0IGNsb3NlcyBldmVyeXRoaW5nIGFsc28gb24gZHJhZyBkcm9wKVxuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljay5lZGl0YWJsZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KSwgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVfY2xhc3NlcyA9IFsnLmVkaXRhYmxlLWNvbnRhaW5lcicsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcudWktZGF0ZXBpY2tlci1oZWFkZXInLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLmRhdGVwaWNrZXInLCAvL2luIGlubGluZSBtb2RlIGRhdGVwaWNrZXIgaXMgcmVuZGVyZWQgaW50byBib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy5tb2RhbC1iYWNrZHJvcCcsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtaW1hZ2UtbW9kYWwnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLmJvb3RzdHJhcC13eXNpaHRtbDUtaW5zZXJ0LWxpbmstbW9kYWwnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgZWxlbWVudCBpcyBkZXRhY2hlZC4gSXQgb2NjdXJzIHdoZW4gY2xpY2tpbmcgaW4gYm9vdHN0cmFwIGRhdGVwaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkLmNvbnRhaW5zKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9mb3Igc29tZSByZWFzb24gRkYgMjAgZ2VuZXJhdGVzIGV4dHJhIGV2ZW50IChjbGljaykgaW4gc2VsZWN0MiB3aWRnZXQgd2l0aCBlLnRhcmdldCA9IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vd2UgbmVlZCB0byBmaWx0ZXIgaXQgdmlhIGNvbnN0cnVjdGlvbiBiZWxvdy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlL2lzc3Vlcy8xOTlcbiAgICAgICAgICAgICAgICAgICAgLy9Qb3NzaWJseSByZWxhdGVkIHRvIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAxMTk3OTMvd2h5LWRvZXMtZmlyZWZveC1yZWFjdC1kaWZmZXJlbnRseS1mcm9tLXdlYmtpdC1hbmQtaWUtdG8tY2xpY2stZXZlbnQtb24tc2VsZWNcbiAgICAgICAgICAgICAgICAgICAgaWYoJHRhcmdldC5pcyhkb2N1bWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBjbGljayBpbnNpZGUgb25lIG9mIGV4Y2x1ZGUgY2xhc3NlcyAtLT4gbm8gbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICBmb3IoaT0wOyBpPGV4Y2x1ZGVfY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCR0YXJnZXQuaXMoZXhjbHVkZV9jbGFzc2VzW2ldKSB8fCAkdGFyZ2V0LnBhcmVudHMoZXhjbHVkZV9jbGFzc2VzW2ldKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL2Nsb3NlIGFsbCBvcGVuIGNvbnRhaW5lcnMgKGV4Y2VwdCBvbmUgLSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgIFBvcHVwLnByb3RvdHlwZS5jbG9zZU90aGVycyhlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkuZGF0YSgnZWRpdGFibGUtaGFuZGxlcnMtYXR0YWNoZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfSxcblxuICAgICAgICAvL3NwbGl0IG9wdGlvbnMgb24gY29udGFpbmVyT3B0aW9ucyBhbmQgZm9ybU9wdGlvbnNcbiAgICAgICAgc3BsaXRPcHRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5mb3JtT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZighJC5mblt0aGlzLmNvbnRhaW5lck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuY29udGFpbmVyTmFtZSArICcgbm90IGZvdW5kLiBIYXZlIHlvdSBpbmNsdWRlZCBjb3JyZXNwb25kaW5nIGpzIGZpbGU/Jyk7ICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8va2V5cyBkZWZpbmVkIGluIGNvbnRhaW5lciBkZWZhdWx0cyBnbyB0byBjb250YWluZXIsIG90aGVycyBnbyB0byBmb3JtXG4gICAgICAgICAgICBmb3IodmFyIGsgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIGlmKGsgaW4gdGhpcy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lck9wdGlvbnNba10gPSB0aGlzLm9wdGlvbnNba107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIHRoaXMuZm9ybU9wdGlvbnNba10gPSB0aGlzLm9wdGlvbnNba107XG4gICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBSZXR1cm5zIGpxdWVyeSBvYmplY3Qgb2YgY29udGFpbmVyXG4gICAgICAgIEBtZXRob2QgdGlwKClcbiAgICAgICAgKi8gICAgICAgICBcbiAgICAgICAgdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcigpID8gdGhpcy5jb250YWluZXIoKS4kdGlwIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiByZXR1cm5zIGNvbnRhaW5lciBvYmplY3QgKi9cbiAgICAgICAgY29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXI7XG4gICAgICAgICAgICAvL2ZpcnN0LCB0cnkgZ2V0IGl0IGJ5IGBjb250YWluZXJEYXRhTmFtZWBcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyRGF0YU5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZihjb250YWluZXIgPSB0aGlzLiRlbGVtZW50LmRhdGEodGhpcy5jb250YWluZXJEYXRhTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3NlY29uZCwgdHJ5IGBjb250YWluZXJOYW1lYFxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy4kZWxlbWVudC5kYXRhKHRoaXMuY29udGFpbmVyTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qIGNhbGwgbmF0aXZlIG1ldGhvZCBvZiB1bmRlcmx5aW5nIGNvbnRhaW5lciwgZS5nLiB0aGlzLiRlbGVtZW50LnBvcG92ZXIoJ21ldGhvZCcpICovIFxuICAgICAgICBjYWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnRbdGhpcy5jb250YWluZXJOYW1lXS5hcHBseSh0aGlzLiRlbGVtZW50LCBhcmd1bWVudHMpOyBcbiAgICAgICAgfSwgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaW5pdENvbnRhaW5lcjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuY2FsbCh0aGlzLmNvbnRhaW5lck9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlckZvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kZm9ybVxuICAgICAgICAgICAgLmVkaXRhYmxlZm9ybSh0aGlzLmZvcm1PcHRpb25zKVxuICAgICAgICAgICAgLm9uKHtcbiAgICAgICAgICAgICAgICBzYXZlOiAkLnByb3h5KHRoaXMuc2F2ZSwgdGhpcyksIC8vY2xpY2sgb24gc3VibWl0IGJ1dHRvbiAodmFsdWUgY2hhbmdlZClcbiAgICAgICAgICAgICAgICBub2NoYW5nZTogJC5wcm94eShmdW5jdGlvbigpeyB0aGlzLmhpZGUoJ25vY2hhbmdlJyk7IH0sIHRoaXMpLCAvL2NsaWNrIG9uIHN1Ym1pdCBidXR0b24gKHZhbHVlIE5PVCBjaGFuZ2VkKSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjYW5jZWw6ICQucHJveHkoZnVuY3Rpb24oKXsgdGhpcy5oaWRlKCdjYW5jZWwnKTsgfSwgdGhpcyksIC8vY2xpY2sgb24gY2FsY2VsIGJ1dHRvblxuICAgICAgICAgICAgICAgIHNob3c6ICQucHJveHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZGVsYXllZEhpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZSh0aGlzLmRlbGF5ZWRIaWRlLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ZWRIaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKSwgLy9yZS1wb3NpdGlvbiBjb250YWluZXIgZXZlcnkgdGltZSBmb3JtIGlzIHNob3duIChvY2N1cnMgZWFjaCB0aW1lIGFmdGVyIGxvYWRpbmcgc3RhdGUpXG4gICAgICAgICAgICAgICAgcmVuZGVyaW5nOiAkLnByb3h5KHRoaXMuc2V0UG9zaXRpb24sIHRoaXMpLCAvL3RoaXMgYWxsb3dzIHRvIHBsYWNlIGNvbnRhaW5lciBjb3JyZWN0bHkgd2hlbiBsb2FkaW5nIHNob3duXG4gICAgICAgICAgICAgICAgcmVzaXplOiAkLnByb3h5KHRoaXMuc2V0UG9zaXRpb24sIHRoaXMpLCAvL3RoaXMgYWxsb3dzIHRvIHJlLXBvc2l0aW9uIGNvbnRhaW5lciB3aGVuIGZvcm0gc2l6ZSBpcyBjaGFuZ2VkIFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiAkLnByb3h5KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gY29udGFpbmVyIGlzIHNob3duIGFuZCBmb3JtIGlzIHJlbmRlcmVkIChmb3Igc2VsZWN0IHdpbGwgd2FpdCBmb3IgbG9hZGluZyBkcm9wZG93biBvcHRpb25zKS4gIFxuICAgICAgICAgICAgICAgICAgICAqKk5vdGU6KiogQm9vdHN0cmFwIHBvcG92ZXIgaGFzIG93biBgc2hvd25gIGV2ZW50IHRoYXQgbm93IGNhbm5vdCBiZSBzZXBhcmF0ZWQgZnJvbSB4LWVkaXRhYmxlJ3Mgb25lLlxuICAgICAgICAgICAgICAgICAgICBUaGUgd29ya2Fyb3VuZCBpcyB0byBjaGVjayBgYXJndW1lbnRzLmxlbmd0aGAgdGhhdCBpcyBhbHdheXMgYDJgIGZvciB4LWVkaXRhYmxlLiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgQGV2ZW50IHNob3duIFxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICQoJyN1c2VybmFtZScpLm9uKCdzaG93bicsIGZ1bmN0aW9uKGUsIGVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5pbnB1dC4kaW5wdXQudmFsKCdvdmVyd3JpdGluZyB2YWx1ZSBvZiBpbnB1dC4uJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pOyAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAqKi8gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICBUT0RPOiBhZGRlZCBzZWNvbmQgcGFyYW0gbWFpbmx5IHRvIGRpc3Rpbmd1aXNoIGZyb20gYm9vdHN0cmFwJ3Mgc2hvd24gZXZlbnQuIEl0J3MgYSBob3RmaXggdGhhdCB3aWxsIGJlIHNvbHZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgdmlhIG5hbWVzcGFjZWQgZXZlbnRzLiAgXG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlckhhbmRsZXIoJ3Nob3duJywgJCh0aGlzLm9wdGlvbnMuc2NvcGUpLmRhdGEoJ2VkaXRhYmxlJykpOyBcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZWRpdGFibGVmb3JtKCdyZW5kZXInKTtcbiAgICAgICAgfSwgICAgICAgIFxuXG4gICAgICAgIC8qKlxuICAgICAgICBTaG93cyBjb250YWluZXIgd2l0aCBmb3JtXG4gICAgICAgIEBtZXRob2Qgc2hvdygpXG4gICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gY2xvc2VBbGwgV2hldGhlciB0byBjbG9zZSBhbGwgb3RoZXIgZWRpdGFibGUgY29udGFpbmVycyB3aGVuIHNob3dpbmcgdGhpcyBvbmUuIERlZmF1bHQgdHJ1ZS5cbiAgICAgICAgKiovXG4gICAgICAgIC8qIE5vdGU6IHBvc2h5dGlwIG93ZXJ3cml0ZXMgdGhpcyBtZXRob2QgdG90YWxseSEgKi8gICAgICAgICAgXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uIChjbG9zZUFsbCkge1xuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUtb3BlbicpO1xuICAgICAgICAgICAgaWYoY2xvc2VBbGwgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy9jbG9zZSBhbGwgb3BlbiBjb250YWluZXJzIChleGNlcHQgdGhpcylcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlT3RoZXJzKHRoaXMuJGVsZW1lbnRbMF0pOyAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2hvdyBjb250YWluZXIgaXRzZWxmXG4gICAgICAgICAgICB0aGlzLmlubmVyU2hvdygpO1xuICAgICAgICAgICAgdGhpcy50aXAoKS5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lckNsYXNzKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIEN1cnJlbnRseSwgZm9ybSBpcyByZS1yZW5kZXJlZCBvbiBldmVyeSBzaG93LiBcbiAgICAgICAgICAgIFRoZSBtYWluIHJlYXNvbiBpcyB0aGF0IHdlIGRvbnQga25vdywgd2hhdCB3aWxsIGNvbnRhaW5lciBkbyB3aXRoIGNvbnRlbnQgd2hlbiBjbG9zZWQ6XG4gICAgICAgICAgICByZW1vdmUoKSwgZGV0YWNoKCkgb3IganVzdCBoaWRlKCkgLSBpdCBkZXBlbmRzIG9uIGNvbnRhaW5lci5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgRGV0YWNoaW5nIGZvcm0gaXRzZWxmIGJlZm9yZSBoaWRlIGFuZCByZS1pbnNlcnQgYmVmb3JlIHNob3cgaXMgZ29vZCBzb2x1dGlvbiwgXG4gICAgICAgICAgICBidXQgdmlzdWFsbHkgaXQgbG9va3MgdWdseSAtLT4gY29udGFpbmVyIGNoYW5nZXMgc2l6ZSBiZWZvcmUgaGlkZS4gIFxuICAgICAgICAgICAgKi8gICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgZm9ybSBhbHJlYWR5IGV4aXN0IC0gZGVsZXRlIHByZXZpb3VzIGRhdGEgXG4gICAgICAgICAgICBpZih0aGlzLiRmb3JtKSB7XG4gICAgICAgICAgICAgICAgLy90b2RvOiBkZXN0cm95IHByZXYgZGF0YSFcbiAgICAgICAgICAgICAgICAvL3RoaXMuJGZvcm0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRmb3JtID0gJCgnPGRpdj4nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pbnNlcnQgZm9ybSBpbnRvIGNvbnRhaW5lciBib2R5XG4gICAgICAgICAgICBpZih0aGlzLnRpcCgpLmlzKHRoaXMuaW5uZXJDc3MpKSB7XG4gICAgICAgICAgICAgICAgLy9mb3IgaW5saW5lIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIHRoaXMudGlwKCkuYXBwZW5kKHRoaXMuJGZvcm0pOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aXAoKS5maW5kKHRoaXMuaW5uZXJDc3MpLmFwcGVuZCh0aGlzLiRmb3JtKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcmVuZGVyIGZvcm1cbiAgICAgICAgICAgIHRoaXMucmVuZGVyRm9ybSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICBIaWRlcyBjb250YWluZXIgd2l0aCBmb3JtXG4gICAgICAgIEBtZXRob2QgaGlkZSgpXG4gICAgICAgIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gUmVhc29uIGNhdXNlZCBoaWRpbmcuIENhbiBiZSA8Y29kZT5zYXZlfGNhbmNlbHxvbmJsdXJ8bm9jaGFuZ2V8dW5kZWZpbmVkICg9bWFudWFsKTwvY29kZT5cbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKHJlYXNvbikgeyAgXG4gICAgICAgICAgICBpZighdGhpcy50aXAoKSB8fCAhdGhpcy50aXAoKS5pcygnOnZpc2libGUnKSB8fCAhdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZWRpdGFibGUtb3BlbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2lmIGZvcm0gaXMgc2F2aW5nIHZhbHVlLCBzY2hlZHVsZSBoaWRlXG4gICAgICAgICAgICBpZih0aGlzLiRmb3JtLmRhdGEoJ2VkaXRhYmxlZm9ybScpLmlzU2F2aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheWVkSGlkZSA9IHtyZWFzb246IHJlYXNvbn07XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheWVkSGlkZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdlZGl0YWJsZS1vcGVuJyk7ICAgXG4gICAgICAgICAgICB0aGlzLmlubmVySGlkZSgpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEZpcmVkIHdoZW4gY29udGFpbmVyIHdhcyBoaWRkZW4uIEl0IG9jY3VycyBvbiBib3RoIHNhdmUgb3IgY2FuY2VsLiAgXG4gICAgICAgICAgICAqKk5vdGU6KiogQm9vdHN0cmFwIHBvcG92ZXIgaGFzIG93biBgaGlkZGVuYCBldmVudCB0aGF0IG5vdyBjYW5ub3QgYmUgc2VwYXJhdGVkIGZyb20geC1lZGl0YWJsZSdzIG9uZS5cbiAgICAgICAgICAgIFRoZSB3b3JrYXJvdW5kIGlzIHRvIGNoZWNrIGBhcmd1bWVudHMubGVuZ3RoYCB0aGF0IGlzIGFsd2F5cyBgMmAgZm9yIHgtZWRpdGFibGUuIFxuXG4gICAgICAgICAgICBAZXZlbnQgaGlkZGVuIFxuICAgICAgICAgICAgQHBhcmFtIHtvYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiBSZWFzb24gY2F1c2VkIGhpZGluZy4gQ2FuIGJlIDxjb2RlPnNhdmV8Y2FuY2VsfG9uYmx1cnxub2NoYW5nZXxtYW51YWw8L2NvZGU+XG4gICAgICAgICAgICBAZXhhbXBsZVxuICAgICAgICAgICAgJCgnI3VzZXJuYW1lJykub24oJ2hpZGRlbicsIGZ1bmN0aW9uKGUsIHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGlmKHJlYXNvbiA9PT0gJ3NhdmUnIHx8IHJlYXNvbiA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9hdXRvLW9wZW4gbmV4dCBlZGl0YWJsZVxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ3RyJykubmV4dCgpLmZpbmQoJy5lZGl0YWJsZScpLmVkaXRhYmxlKCdzaG93Jyk7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCdoaWRkZW4nLCByZWFzb24gfHwgJ21hbnVhbCcpOyAgIFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qIGludGVybmFsIHNob3cgbWV0aG9kLiBUbyBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBjbGFzc2VzICovXG4gICAgICAgIGlubmVyU2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIFxuICAgICAgICB9LCAgICAgICAgXG5cbiAgICAgICAgLyogaW50ZXJuYWwgaGlkZSBtZXRob2QuIFRvIGJlIG92ZXJ3cml0dGVuIGluIGNoaWxkIGNsYXNzZXMgKi9cbiAgICAgICAgaW5uZXJIaWRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBUb2dnbGVzIGNvbnRhaW5lciB2aXNpYmlsaXR5IChzaG93IC8gaGlkZSlcbiAgICAgICAgQG1ldGhvZCB0b2dnbGUoKVxuICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlQWxsIFdoZXRoZXIgdG8gY2xvc2UgYWxsIG90aGVyIGVkaXRhYmxlIGNvbnRhaW5lcnMgd2hlbiBzaG93aW5nIHRoaXMgb25lLiBEZWZhdWx0IHRydWUuXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbihjbG9zZUFsbCkge1xuICAgICAgICAgICAgaWYodGhpcy5jb250YWluZXIoKSAmJiB0aGlzLnRpcCgpICYmIHRoaXMudGlwKCkuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93KGNsb3NlQWxsKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgY29udGFpbmVyIHdoZW4gY29udGVudCBjaGFuZ2VkLlxuICAgICAgICBAbWV0aG9kIHNldFBvc2l0aW9uKClcbiAgICAgICAgKi8gICAgICAgXG4gICAgICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vdGJkIGluIGNoaWxkIGNsYXNzXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2F2ZTogZnVuY3Rpb24oZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICAvKiogICAgICAgIFxuICAgICAgICAgICAgRmlyZWQgd2hlbiBuZXcgdmFsdWUgd2FzIHN1Ym1pdHRlZC4gWW91IGNhbiB1c2UgPGNvZGU+JCh0aGlzKS5kYXRhKCdlZGl0YWJsZUNvbnRhaW5lcicpPC9jb2RlPiBpbnNpZGUgaGFuZGxlciB0byBhY2Nlc3MgdG8gZWRpdGFibGVDb250YWluZXIgaW5zdGFuY2VcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQGV2ZW50IHNhdmUgXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gcGFyYW1zIGFkZGl0aW9uYWwgcGFyYW1zXG4gICAgICAgICAgICBAcGFyYW0ge21peGVkfSBwYXJhbXMubmV3VmFsdWUgc3VibWl0dGVkIHZhbHVlXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnJlc3BvbnNlIGFqYXggcmVzcG9uc2VcbiAgICAgICAgICAgIEBleGFtcGxlXG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5vbignc2F2ZScsIGZ1bmN0aW9uKGUsIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIC8vYXNzdW1pbmcgc2VydmVyIHJlc3BvbnNlOiAne3N1Y2Nlc3M6IHRydWV9J1xuICAgICAgICAgICAgICAgIHZhciBwayA9ICQodGhpcykuZGF0YSgnZWRpdGFibGVDb250YWluZXInKS5vcHRpb25zLnBrO1xuICAgICAgICAgICAgICAgIGlmKHBhcmFtcy5yZXNwb25zZSAmJiBwYXJhbXMucmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBhbGVydCgndmFsdWU6ICcgKyBwYXJhbXMubmV3VmFsdWUgKyAnIHdpdGggcGs6ICcgKyBwayArICcgc2F2ZWQhJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ2Vycm9yIScpOyBcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAqKi8gICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCdzYXZlJywgcGFyYW1zKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9oaWRlIG11c3QgYmUgYWZ0ZXIgdHJpZ2dlciwgYXMgc2F2aW5nIHZhbHVlIG1heSByZXF1aXJlIG1ldGhvZHMgb2YgcGx1Z2luLCBhcHBsaWVkIHRvIGlucHV0XG4gICAgICAgICAgICB0aGlzLmhpZGUoJ3NhdmUnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgU2V0cyBuZXcgb3B0aW9uXG4gICAgICAgIFxuICAgICAgICBAbWV0aG9kIG9wdGlvbihrZXksIHZhbHVlKVxuICAgICAgICBAcGFyYW0ge3N0cmluZ30ga2V5IFxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZSBcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIG9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmKGtleSBpbiB0aGlzLmNvbnRhaW5lck9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lck9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29udGFpbmVyT3B0aW9uKGtleSwgdmFsdWUpOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtT3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYodGhpcy4kZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLmVkaXRhYmxlZm9ybSgnb3B0aW9uJywga2V5LCB2YWx1ZSk7ICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBzZXRDb250YWluZXJPcHRpb246IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbCgnb3B0aW9uJywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgIERlc3Ryb3lzIHRoZSBjb250YWluZXIgaW5zdGFuY2VcbiAgICAgICAgQG1ldGhvZCBkZXN0cm95KClcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignZGVzdHJveWVkJyk7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoJ2VkaXRhYmxlQ29udGFpbmVyJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKiB0byBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBjbGFzc2VzICovXG4gICAgICAgIGlubmVyRGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgfSwgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBDbG9zZXMgb3RoZXIgY29udGFpbmVycyBleGNlcHQgb25lIHJlbGF0ZWQgdG8gcGFzc2VkIGVsZW1lbnQuIFxuICAgICAgICBPdGhlciBjb250YWluZXJzIGNhbiBiZSBjYW5jZWxsZWQgb3Igc3VibWl0dGVkIChkZXBlbmRzIG9uIG9uYmx1ciBvcHRpb24pXG4gICAgICAgICovXG4gICAgICAgIGNsb3NlT3RoZXJzOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAkKCcuZWRpdGFibGUtb3BlbicpLmVhY2goZnVuY3Rpb24oaSwgZWwpe1xuICAgICAgICAgICAgICAgIC8vZG8gbm90aGluZyB3aXRoIHBhc3NlZCBlbGVtZW50IGFuZCBpdCdzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgaWYoZWwgPT09IGVsZW1lbnQgfHwgJChlbCkuZmluZChlbGVtZW50KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGNhbmNlbCBvciBzdWJtaXQgYWxsIG9wZW4gY29udGFpbmVycyBcbiAgICAgICAgICAgICAgICB2YXIgJGVsID0gJChlbCksXG4gICAgICAgICAgICAgICAgZWMgPSAkZWwuZGF0YSgnZWRpdGFibGVDb250YWluZXInKTtcblxuICAgICAgICAgICAgICAgIGlmKCFlYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoZWMub3B0aW9ucy5vbmJsdXIgPT09ICdjYW5jZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICRlbC5kYXRhKCdlZGl0YWJsZUNvbnRhaW5lcicpLmhpZGUoJ29uYmx1cicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihlYy5vcHRpb25zLm9uYmx1ciA9PT0gJ3N1Ym1pdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVsLmRhdGEoJ2VkaXRhYmxlQ29udGFpbmVyJykudGlwKCkuZmluZCgnZm9ybScpLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgQWN0aXZhdGVzIGlucHV0IG9mIHZpc2libGUgY29udGFpbmVyIChlLmcuIHNldCBmb2N1cylcbiAgICAgICAgQG1ldGhvZCBhY3RpdmF0ZSgpXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLnRpcCAmJiB0aGlzLnRpcCgpLmlzKCc6dmlzaWJsZScpICYmIHRoaXMuJGZvcm0pIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uZGF0YSgnZWRpdGFibGVmb3JtJykuaW5wdXQuYWN0aXZhdGUoKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgalF1ZXJ5IG1ldGhvZCB0byBpbml0aWFsaXplIGVkaXRhYmxlQ29udGFpbmVyLlxuICAgIFxuICAgIEBtZXRob2QgJCgpLmVkaXRhYmxlQ29udGFpbmVyKG9wdGlvbnMpXG4gICAgQHBhcmFtcyB7T2JqZWN0fSBvcHRpb25zXG4gICAgQGV4YW1wbGVcbiAgICAkKCcjZWRpdCcpLmVkaXRhYmxlQ29udGFpbmVyKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHBrOiAxLFxuICAgICAgICB2YWx1ZTogJ2hlbGxvJ1xuICAgIH0pO1xuICAgICoqLyAgXG4gICAgJC5mbi5lZGl0YWJsZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcbiAgICAgICAgICAgIGRhdGFLZXkgPSAnZWRpdGFibGVDb250YWluZXInLCBcbiAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKGRhdGFLZXkpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT09ICdvYmplY3QnICYmIG9wdGlvbixcbiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gKG9wdGlvbnMubW9kZSA9PT0gJ2lubGluZScpID8gSW5saW5lIDogUG9wdXA7ICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKGRhdGFLZXksIChkYXRhID0gbmV3IENvbnN0cnVjdG9yKHRoaXMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJykgeyAvL2NhbGwgbWV0aG9kIFxuICAgICAgICAgICAgICAgIGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgIH0pO1xuICAgIH07ICAgICBcblxuICAgIC8vc3RvcmUgY29uc3RydWN0b3JzXG4gICAgJC5mbi5lZGl0YWJsZUNvbnRhaW5lci5Qb3B1cCA9IFBvcHVwO1xuICAgICQuZm4uZWRpdGFibGVDb250YWluZXIuSW5saW5lID0gSW5saW5lO1xuXG4gICAgLy9kZWZhdWx0c1xuICAgICQuZm4uZWRpdGFibGVDb250YWluZXIuZGVmYXVsdHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICBJbml0aWFsIHZhbHVlIG9mIGZvcm0gaW5wdXRcblxuICAgICAgICBAcHJvcGVydHkgdmFsdWUgXG4gICAgICAgIEB0eXBlIG1peGVkXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQHByaXZhdGVcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBQbGFjZW1lbnQgb2YgY29udGFpbmVyIHJlbGF0aXZlIHRvIGVsZW1lbnQuIENhbiBiZSA8Y29kZT50b3B8cmlnaHR8Ym90dG9tfGxlZnQ8L2NvZGU+LiBOb3QgdXNlZCBmb3IgaW5saW5lIGNvbnRhaW5lci5cblxuICAgICAgICBAcHJvcGVydHkgcGxhY2VtZW50IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ3RvcCdcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZXRoZXIgdG8gaGlkZSBjb250YWluZXIgb24gc2F2ZS9jYW5jZWwuXG5cbiAgICAgICAgQHByb3BlcnR5IGF1dG9oaWRlIFxuICAgICAgICBAdHlwZSBib29sZWFuXG4gICAgICAgIEBkZWZhdWx0IHRydWVcbiAgICAgICAgQHByaXZhdGUgXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIGF1dG9oaWRlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgQWN0aW9uIHdoZW4gdXNlciBjbGlja3Mgb3V0c2lkZSB0aGUgY29udGFpbmVyLiBDYW4gYmUgPGNvZGU+Y2FuY2VsfHN1Ym1pdHxpZ25vcmU8L2NvZGU+LiAgXG4gICAgICAgIFNldHRpbmcgPGNvZGU+aWdub3JlPC9jb2RlPiBhbGxvd3MgdG8gaGF2ZSBzZXZlcmFsIGNvbnRhaW5lcnMgb3Blbi4gXG5cbiAgICAgICAgQHByb3BlcnR5IG9uYmx1ciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICdjYW5jZWwnXG4gICAgICAgIEBzaW5jZSAxLjEuMVxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBvbmJsdXI6ICdjYW5jZWwnLFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIEFuaW1hdGlvbiBzcGVlZCAoaW5saW5lIG1vZGUgb25seSlcbiAgICAgICAgQHByb3BlcnR5IGFuaW0gXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBhbmltOiBmYWxzZSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBNb2RlIG9mIGVkaXRhYmxlLCBjYW4gYmUgYHBvcHVwYCBvciBgaW5saW5lYCBcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBtb2RlIFxuICAgICAgICBAdHlwZSBzdHJpbmcgICAgICAgICBcbiAgICAgICAgQGRlZmF1bHQgJ3BvcHVwJ1xuICAgICAgICBAc2luY2UgMS40LjAgICAgICAgIFxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBtb2RlOiAncG9wdXAnICAgICAgICBcbiAgICB9O1xuXG4gICAgLyogXG4gICAgKiB3b3JrYXJvdW5kIHRvIGhhdmUgJ2Rlc3Ryb3llZCcgZXZlbnQgdG8gZGVzdHJveSBwb3BvdmVyIHdoZW4gZWxlbWVudCBpcyBkZXN0cm95ZWRcbiAgICAqIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIyMDA0OTQvanF1ZXJ5LXRyaWdnZXItZXZlbnQtd2hlbi1hbi1lbGVtZW50LWlzLXJlbW92ZWQtZnJvbS10aGUtZG9tXG4gICAgKi9cbiAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbC5kZXN0cm95ZWQgPSB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24obykge1xuICAgICAgICAgICAgaWYgKG8uaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIG8uaGFuZGxlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTsgICAgXG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcbiogRWRpdGFibGUgSW5saW5lIFxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIC8vY29weSBwcm90b3R5cGUgZnJvbSBFZGl0YWJsZUNvbnRhaW5lclxuICAgIC8vZXh0ZW5kIG1ldGhvZHNcbiAgICAkLmV4dGVuZCgkLmZuLmVkaXRhYmxlQ29udGFpbmVyLklubGluZS5wcm90b3R5cGUsICQuZm4uZWRpdGFibGVDb250YWluZXIuUG9wdXAucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnRhaW5lck5hbWU6ICdlZGl0YWJsZWZvcm0nLFxuICAgICAgICBpbm5lckNzczogJy5lZGl0YWJsZS1pbmxpbmUnLFxuICAgICAgICBjb250YWluZXJDbGFzczogJ2VkaXRhYmxlLWNvbnRhaW5lciBlZGl0YWJsZS1pbmxpbmUnLCAvL2NzcyBjbGFzcyBhcHBsaWVkIHRvIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICAgICAgICAgICAgIFxuICAgICAgICBpbml0Q29udGFpbmVyOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy9jb250YWluZXIgaXMgPHNwYW4+IGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuJHRpcCA9ICQoJzxzcGFuPjwvc3Bhbj4nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jb252ZXJ0IGFuaW0gdG8gbWlsaXNlY29uZHMgKGludClcbiAgICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuYW5pbSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hbmltID0gMDtcbiAgICAgICAgICAgIH0gICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHNwbGl0T3B0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvL2FsbCBvcHRpb25zIGFyZSBwYXNzZWQgdG8gZm9ybVxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJPcHRpb25zID0ge307XG4gICAgICAgICAgICB0aGlzLmZvcm1PcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuJHRpcDsgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBpbm5lclNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy50aXAoKS5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KS5zaG93KCk7XG4gICAgICAgIH0sIFxuICAgICAgICBcbiAgICAgICAgaW5uZXJIaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiR0aXAuaGlkZSh0aGlzLm9wdGlvbnMuYW5pbSwgJC5wcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnNob3coKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyRGVzdHJveSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpOyBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGlubmVyRGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLnRpcCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aXAoKS5lbXB0eSgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgIH0pO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcbi8qKlxuTWFrZXMgZWRpdGFibGUgYW55IEhUTUwgZWxlbWVudCBvbiB0aGUgcGFnZS4gQXBwbGllZCBhcyBqUXVlcnkgbWV0aG9kLlxuXG5AY2xhc3MgZWRpdGFibGVcbkB1c2VzIGVkaXRhYmxlQ29udGFpbmVyXG4qKi9cbihmdW5jdGlvbiAoJCkge1xuXG4gICAgdmFyIEVkaXRhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgIC8vZGF0YS0qIGhhcyBtb3JlIHByaW9yaXR5IG92ZXIganMgb3B0aW9uczogYmVjYXVzZSBkeW5hbWljYWxseSBjcmVhdGVkIGVsZW1lbnRzIG1heSBjaGFuZ2UgZGF0YS0qIFxuICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZS5kZWZhdWx0cywgb3B0aW9ucywgJC5mbi5lZGl0YWJsZXV0aWxzLmdldENvbmZpZ0RhdGEodGhpcy4kZWxlbWVudCkpOyAgXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5zZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5pbml0TGl2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vY2hlY2sgZm9yIHRyYW5zaXRpb24gc3VwcG9ydFxuICAgICAgICBpZih0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ICYmICEkLmZuLmVkaXRhYmxldXRpbHMuc3VwcG9ydHNUcmFuc2l0aW9ucygpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRWRpdGFibGUucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogRWRpdGFibGUsIFxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXNWYWx1ZUJ5VGV4dCA9IGZhbHNlLCBcbiAgICAgICAgICAgICAgICBkb0F1dG90ZXh0LCBmaW5hbGl6ZTtcblxuICAgICAgICAgICAgLy9uYW1lXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMub3B0aW9ucy5uYW1lIHx8IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTtcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY3JlYXRlIGlucHV0IG9mIHNwZWNpZmllZCB0eXBlLiBJbnB1dCBuZWVkZWQgYWxyZWFkeSBoZXJlIHRvIGNvbnZlcnQgdmFsdWUgZm9yIGluaXRpYWwgZGlzcGxheSAoZS5nLiBzaG93IHRleHQgYnkgaWQgZm9yIHNlbGVjdClcbiAgICAgICAgICAgIC8vYWxzbyB3ZSBzZXQgc2NvcGUgb3B0aW9uIHRvIGhhdmUgYWNjZXNzIHRvIGVsZW1lbnQgaW5zaWRlIGlucHV0IHNwZWNpZmljIGNhbGxiYWNrcyAoZS4gZy4gc291cmNlIGFzIGZ1bmN0aW9uKVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNjb3BlID0gdGhpcy4kZWxlbWVudFswXTsgXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gJC5mbi5lZGl0YWJsZXV0aWxzLmNyZWF0ZUlucHV0KHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICBpZighdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgXG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIC8vc2V0IHZhbHVlIGZyb20gc2V0dGluZ3Mgb3IgYnkgZWxlbWVudCdzIHRleHRcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbnB1dC5odG1sMnZhbHVlKCQudHJpbSh0aGlzLiRlbGVtZW50Lmh0bWwoKSkpO1xuICAgICAgICAgICAgICAgIGlzVmFsdWVCeVRleHQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgdmFsdWUgY2FuIGJlIHN0cmluZyB3aGVuIHJlY2VpdmVkIGZyb20gJ2RhdGEtdmFsdWUnIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgZm9yIGNvbXBsZXh0IG9iamVjdHMgdmFsdWUgY2FuIGJlIHNldCBhcyBqc29uIHN0cmluZyBpbiBkYXRhLXZhbHVlIGF0dHJpYnV0ZSwgXG4gICAgICAgICAgICAgICAgICBlLmcuIGRhdGEtdmFsdWU9XCJ7Y2l0eTogJ01vc2NvdycsIHN0cmVldDogJ0xlbmluYSd9XCJcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy52YWx1ZSA9ICQuZm4uZWRpdGFibGV1dGlscy50cnlQYXJzZUpzb24odGhpcy5vcHRpb25zLnZhbHVlLCB0cnVlKTsgXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHRoaXMub3B0aW9ucy52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5wdXQuc3RyMnZhbHVlKHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vYWRkICdlZGl0YWJsZScgY2xhc3MgdG8gZXZlcnkgZWRpdGFibGUgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zcGVjaWZpY2FsbHkgZm9yIFwidGV4dGFyZWFcIiBhZGQgY2xhc3MgLmVkaXRhYmxlLXByZS13cmFwcGVkIHRvIGtlZXAgbGluZWJyZWFrc1xuICAgICAgICAgICAgaWYodGhpcy5pbnB1dC50eXBlID09PSAndGV4dGFyZWEnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUtcHJlLXdyYXBwZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hdHRhY2ggaGFuZGxlciBhY3RpdmF0aW5nIGVkaXRhYmxlLiBJbiBkaXNhYmxlZCBtb2RlIGl0IGp1c3QgcHJldmVudCBkZWZhdWx0IGFjdGlvbiAodXNlZnVsIGZvciBsaW5rcylcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy50b2dnbGUgIT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUtY2xpY2snKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKHRoaXMub3B0aW9ucy50b2dnbGUgKyAnLmVkaXRhYmxlJywgJC5wcm94eShmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IGZvbGxvd2luZyBsaW5rIGlmIGVkaXRhYmxlIGVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL3N0b3AgcHJvcGFnYXRpb24gbm90IHJlcXVpcmVkIGJlY2F1c2UgaW4gZG9jdW1lbnQgY2xpY2sgaGFuZGxlciBpdCBjaGVja3MgZXZlbnQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIC8vZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy50b2dnbGUgPT09ICdtb3VzZWVudGVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9mb3IgaG92ZXIgb25seSBzaG93IGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3doZW4gdG9nZ2xlPSdjbGljaycgd2Ugc2hvdWxkIG5vdCBjbG9zZSBhbGwgb3RoZXIgY29udGFpbmVycyBhcyB0aGV5IHdpbGwgYmUgY2xvc2VkIGF1dG9tYXRpY2FsbHkgaW4gZG9jdW1lbnQgY2xpY2sgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZUFsbCA9ICh0aGlzLm9wdGlvbnMudG9nZ2xlICE9PSAnY2xpY2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGNsb3NlQWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsIC0xKTsgLy9kbyBub3Qgc3RvcCBmb2N1cyBvbiBlbGVtZW50IHdoZW4gdG9nZ2xlZCBtYW51YWxseVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2lmIGRpc3BsYXkgaXMgZnVuY3Rpb24gaXQncyBmYXIgbW9yZSBjb252aW5pZW50IHRvIGhhdmUgYXV0b3RleHQgPSBhbHdheXMgdG8gcmVuZGVyIGNvcnJlY3RseSBvbiBpbml0XG4gICAgICAgICAgICAvL3NlZSBodHRwczovL2dpdGh1Yi5jb20vdml0YWxldHMveC1lZGl0YWJsZS15aWkvaXNzdWVzLzM0XG4gICAgICAgICAgICBpZih0eXBlb2YgdGhpcy5vcHRpb25zLmRpc3BsYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXV0b3RleHQgPSAnYWx3YXlzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jaGVjayBjb25kaXRpb25zIGZvciBhdXRvdGV4dDpcbiAgICAgICAgICAgIHN3aXRjaCh0aGlzLm9wdGlvbnMuYXV0b3RleHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAnYWx3YXlzJzpcbiAgICAgICAgICAgICAgIGRvQXV0b3RleHQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYXV0byc6XG4gICAgICAgICAgICAgICAgLy9pZiBlbGVtZW50IHRleHQgaXMgZW1wdHkgYW5kIHZhbHVlIGlzIGRlZmluZWQgYW5kIHZhbHVlIG5vdCBnZW5lcmF0ZWQgYnkgdGV4dCAtLT4gcnVuIGF1dG90ZXh0XG4gICAgICAgICAgICAgICAgZG9BdXRvdGV4dCA9ICEkLnRyaW0odGhpcy4kZWxlbWVudC50ZXh0KCkpLmxlbmd0aCAmJiB0aGlzLnZhbHVlICE9PSBudWxsICYmIHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhaXNWYWx1ZUJ5VGV4dDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICBkb0F1dG90ZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZGVwZW5kaW5nIG9uIGF1dG90ZXh0IHJ1biByZW5kZXIoKSBvciBqdXN0IGZpbmlsaXplIGluaXRcbiAgICAgICAgICAgICQud2hlbihkb0F1dG90ZXh0ID8gdGhpcy5yZW5kZXIoKSA6IHRydWUpLnRoZW4oJC5wcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoKTsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gZWxlbWVudCB3YXMgaW5pdGlhbGl6ZWQgYnkgYCQoKS5lZGl0YWJsZSgpYCBtZXRob2QuIFxuICAgICAgICAgICAgICAgUGxlYXNlIG5vdGUgdGhhdCB5b3Ugc2hvdWxkIHNldHVwIGBpbml0YCBoYW5kbGVyICoqYmVmb3JlKiogYXBwbHlpbmcgYGVkaXRhYmxlYC4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIEBldmVudCBpbml0IFxuICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGVkaXRhYmxlIGVkaXRhYmxlIGluc3RhbmNlIChhcyBoZXJlIGl0IGNhbm5vdCBhY2Nlc3NlZCB2aWEgZGF0YSgnZWRpdGFibGUnKSlcbiAgICAgICAgICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICAgICQoJyN1c2VybmFtZScpLm9uKCdpbml0JywgZnVuY3Rpb24oZSwgZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICBhbGVydCgnaW5pdGlhbGl6ZWQgJyArIGVkaXRhYmxlLm9wdGlvbnMubmFtZSk7XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICQoJyN1c2VybmFtZScpLmVkaXRhYmxlKCk7XG4gICAgICAgICAgICAgICAqKi8gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCdpbml0JywgdGhpcyk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgIEluaXRpYWxpemVzIHBhcmVudCBlbGVtZW50IGZvciBsaXZlIGVkaXRhYmxlcyBcbiAgICAgICAgKi9cbiAgICAgICAgaW5pdExpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAvL3N0b3JlIHNlbGVjdG9yIFxuICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLm9wdGlvbnMuc2VsZWN0b3I7XG4gICAgICAgICAgIC8vbW9kaWZ5IG9wdGlvbnMgZm9yIGNoaWxkIGVsZW1lbnRzXG4gICAgICAgICAgIHRoaXMub3B0aW9ucy5zZWxlY3RvciA9IGZhbHNlOyBcbiAgICAgICAgICAgdGhpcy5vcHRpb25zLmF1dG90ZXh0ID0gJ25ldmVyJztcbiAgICAgICAgICAgLy9saXN0ZW4gdG9nZ2xlIGV2ZW50c1xuICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKHRoaXMub3B0aW9ucy50b2dnbGUgKyAnLmVkaXRhYmxlJywgc2VsZWN0b3IsICQucHJveHkoZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICB2YXIgJHRhcmdldCA9ICQoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgaWYoISR0YXJnZXQuZGF0YSgnZWRpdGFibGUnKSkge1xuICAgICAgICAgICAgICAgICAgIC8vaWYgZGVsZWdhdGVkIGVsZW1lbnQgaW5pdGlhbGx5IGVtcHR5LCB3ZSBuZWVkIHRvIGNsZWFyIGl0J3MgdGV4dCAodGhhdCB3YXMgbWFudWFsbHkgc2V0IHRvIGBlbXB0eWAgYnkgdXNlcilcbiAgICAgICAgICAgICAgICAgICAvL3NlZSBodHRwczovL2dpdGh1Yi5jb20vdml0YWxldHMveC1lZGl0YWJsZS9pc3N1ZXMvMTM3IFxuICAgICAgICAgICAgICAgICAgIGlmKCR0YXJnZXQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmVtcHR5Y2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHRhcmdldC5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAkdGFyZ2V0LmVkaXRhYmxlKHRoaXMub3B0aW9ucykudHJpZ2dlcihlKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSwgdGhpcykpOyBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgIFJlbmRlcnMgdmFsdWUgaW50byBlbGVtZW50J3MgdGV4dC5cbiAgICAgICAgQ2FuIGNhbGwgY3VzdG9tIGRpc3BsYXkgbWV0aG9kIGZyb20gb3B0aW9ucy5cbiAgICAgICAgQ2FuIHJldHVybiBkZWZlcnJlZCBvYmplY3QuXG4gICAgICAgIEBtZXRob2QgcmVuZGVyKClcbiAgICAgICAgQHBhcmFtIHttaXhlZH0gcmVzcG9uc2Ugc2VydmVyIHJlc3BvbnNlIChpZiBleGlzdCkgdG8gcGFzcyBpbnRvIGRpc3BsYXkgZnVuY3Rpb25cbiAgICAgICAgKi8gICAgICAgICAgXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IGRpc3BsYXkgYW55dGhpbmdcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5kaXNwbGF5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiBpbnB1dCBoYXMgYHZhbHVlMmh0bWxGaW5hbGAgbWV0aG9kLCB3ZSBwYXNzIGNhbGxiYWNrIGluIHRoaXJkIHBhcmFtIHRvIGJlIGNhbGxlZCB3aGVuIHNvdXJjZSBpcyBsb2FkZWRcbiAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQudmFsdWUyaHRtbEZpbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQudmFsdWUyaHRtbCh0aGlzLnZhbHVlLCB0aGlzLiRlbGVtZW50WzBdLCB0aGlzLm9wdGlvbnMuZGlzcGxheSwgcmVzcG9uc2UpOyBcbiAgICAgICAgICAgIC8vaWYgZGlzcGxheSBtZXRob2QgZGVmaW5lZCAtLT4gdXNlIGl0ICAgIFxuICAgICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiB0aGlzLm9wdGlvbnMuZGlzcGxheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZGlzcGxheS5jYWxsKHRoaXMuJGVsZW1lbnRbMF0sIHRoaXMudmFsdWUsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vZWxzZSB1c2UgaW5wdXQncyBvcmlnaW5hbCB2YWx1ZTJodG1sKCkgbWV0aG9kICAgIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC52YWx1ZTJodG1sKHRoaXMudmFsdWUsIHRoaXMuJGVsZW1lbnRbMF0pOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBFbmFibGVzIGVkaXRhYmxlXG4gICAgICAgIEBtZXRob2QgZW5hYmxlKClcbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBlbmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdlZGl0YWJsZS1kaXNhYmxlZCcpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFbXB0eSh0aGlzLmlzRW1wdHkpO1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnRvZ2dsZSAhPT0gJ21hbnVhbCcpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JykgPT09ICctMScpIHsgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQXR0cigndGFiaW5kZXgnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBEaXNhYmxlcyBlZGl0YWJsZVxuICAgICAgICBAbWV0aG9kIGRpc2FibGUoKVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSB0cnVlOyBcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpOyAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdlZGl0YWJsZS1kaXNhYmxlZCcpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFbXB0eSh0aGlzLmlzRW1wdHkpO1xuICAgICAgICAgICAgLy9kbyBub3Qgc3RvcCBmb2N1cyBvbiB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAtMSk7ICAgICAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFRvZ2dsZXMgZW5hYmxlZCAvIGRpc2FibGVkIHN0YXRlIG9mIGVkaXRhYmxlIGVsZW1lbnRcbiAgICAgICAgQG1ldGhvZCB0b2dnbGVEaXNhYmxlZCgpXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0b2dnbGVEaXNhYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHsgXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgU2V0cyBuZXcgb3B0aW9uXG4gICAgICAgIFxuICAgICAgICBAbWV0aG9kIG9wdGlvbihrZXksIHZhbHVlKVxuICAgICAgICBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGtleSBvcHRpb24gbmFtZSBvciBvYmplY3Qgd2l0aCBzZXZlcmFsIG9wdGlvbnNcbiAgICAgICAgQHBhcmFtIHttaXhlZH0gdmFsdWUgb3B0aW9uIG5ldyB2YWx1ZVxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICAkKCcuZWRpdGFibGUnKS5lZGl0YWJsZSgnb3B0aW9uJywgJ3BrJywgMik7XG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgb3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAvL3NldCBvcHRpb24ocykgYnkgb2JqZWN0XG4gICAgICAgICAgICBpZihrZXkgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICQuZWFjaChrZXksICQucHJveHkoZnVuY3Rpb24oaywgdil7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbigkLnRyaW0oayksIHYpOyBcbiAgICAgICAgICAgICAgIH0sIHRoaXMpKTsgXG4gICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vc2V0IG9wdGlvbiBieSBzdHJpbmcgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZGlzYWJsZWRcbiAgICAgICAgICAgIGlmKGtleSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdGhpcy5kaXNhYmxlKCkgOiB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy92YWx1ZVxuICAgICAgICAgICAgaWYoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vdHJhbnNmZXIgbmV3IG9wdGlvbiB0byBjb250YWluZXIhIFxuICAgICAgICAgICAgaWYodGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5vcHRpb24oa2V5LCB2YWx1ZSk7ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcGFzcyBvcHRpb24gdG8gaW5wdXQgZGlyZWN0bHkgKGFzIGl0IHBvaW50cyB0byB0aGUgc2FtZSBpbiBmb3JtKVxuICAgICAgICAgICAgaWYodGhpcy5pbnB1dC5vcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Lm9wdGlvbihrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9LCAgICAgICAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAqIHNldCBlbXB0eXRleHQgaWYgZWxlbWVudCBpcyBlbXB0eVxuICAgICAgICAqL1xuICAgICAgICBoYW5kbGVFbXB0eTogZnVuY3Rpb24gKGlzRW1wdHkpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IGhhbmRsZSBlbXB0eSBpZiB3ZSBkbyBub3QgZGlzcGxheSBhbnl0aGluZ1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBcbiAgICAgICAgICAgIGlzRW1wdHkgbWF5IGJlIHNldCBkaXJlY3RseSBhcyBwYXJhbSBvZiBtZXRob2QuXG4gICAgICAgICAgICBJdCBpcyByZXF1aXJlZCB3aGVuIHdlIGVuYWJsZS9kaXNhYmxlIGZpZWxkIGFuZCBjYW4ndCByZWx5IG9uIGNvbnRlbnQgXG4gICAgICAgICAgICBhcyBub2RlIGNvbnRlbnQgaXMgdGV4dDogXCJFbXB0eVwiIHRoYXQgaXMgbm90IGVtcHR5ICUpXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYoaXNFbXB0eSAhPT0gdW5kZWZpbmVkKSB7IFxuICAgICAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vZGV0ZWN0IGVtcHR5XG4gICAgICAgICAgICAgICAgLy9mb3Igc29tZSBpbnB1dHMgd2UgbmVlZCBtb3JlIHNtYXJ0IGNoZWNrXG4gICAgICAgICAgICAgICAgLy9lLmcuIHd5c2lodG1sNSBtYXkgaGF2ZSA8YnI+LCA8cD48L3A+LCA8aW1nPlxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZih0aGlzLmlucHV0LmlzRW1wdHkpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA9IHRoaXMuaW5wdXQuaXNFbXB0eSh0aGlzLiRlbGVtZW50KTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA9ICQudHJpbSh0aGlzLiRlbGVtZW50Lmh0bWwoKSkgPT09ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2VtcHR5dGV4dCBzaG93biBvbmx5IGZvciBlbmFibGVkXG4gICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50Lmh0bWwodGhpcy5vcHRpb25zLmVtcHR5dGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLm9wdGlvbnMuZW1wdHljbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vYmVsb3cgcmVxdWlyZWQgaWYgZWxlbWVudCBkaXNhYmxlIHByb3BlcnR5IHdhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgaWYodGhpcy5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmVtcHR5Y2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmVtcHR5Y2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgU2hvd3MgY29udGFpbmVyIHdpdGggZm9ybVxuICAgICAgICBAbWV0aG9kIHNob3coKVxuICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlQWxsIFdoZXRoZXIgdG8gY2xvc2UgYWxsIG90aGVyIGVkaXRhYmxlIGNvbnRhaW5lcnMgd2hlbiBzaG93aW5nIHRoaXMgb25lLiBEZWZhdWx0IHRydWUuXG4gICAgICAgICoqLyAgXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uIChjbG9zZUFsbCkge1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2luaXQgZWRpdGFibGVDb250YWluZXI6IHBvcG92ZXIsIHRvb2x0aXAsIGlubGluZSwgZXRjLi5cbiAgICAgICAgICAgIGlmKCF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJPcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQgLy9wYXNzIGlucHV0IHRvIGZvcm0gKGFzIGl0IGlzIGFscmVhZHkgY3JlYXRlZClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LmVkaXRhYmxlQ29udGFpbmVyKGNvbnRhaW5lck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vbGlzdGVuIGBzYXZlYCBldmVudCBcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKFwic2F2ZS5pbnRlcm5hbFwiLCAkLnByb3h5KHRoaXMuc2F2ZSwgdGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy4kZWxlbWVudC5kYXRhKCdlZGl0YWJsZUNvbnRhaW5lcicpOyBcbiAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLmNvbnRhaW5lci50aXAoKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zaG93IGNvbnRhaW5lclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc2hvdyhjbG9zZUFsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgSGlkZXMgY29udGFpbmVyIHdpdGggZm9ybVxuICAgICAgICBAbWV0aG9kIGhpZGUoKVxuICAgICAgICAqKi8gICAgICAgXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHsgICBcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyKSB7ICBcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgVG9nZ2xlcyBjb250YWluZXIgdmlzaWJpbGl0eSAoc2hvdyAvIGhpZGUpXG4gICAgICAgIEBtZXRob2QgdG9nZ2xlKClcbiAgICAgICAgQHBhcmFtIHtib29sZWFufSBjbG9zZUFsbCBXaGV0aGVyIHRvIGNsb3NlIGFsbCBvdGhlciBlZGl0YWJsZSBjb250YWluZXJzIHdoZW4gc2hvd2luZyB0aGlzIG9uZS4gRGVmYXVsdCB0cnVlLlxuICAgICAgICAqKi8gIFxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uKGNsb3NlQWxsKSB7XG4gICAgICAgICAgICBpZih0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci50aXAoKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coY2xvc2VBbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgKiBjYWxsZWQgd2hlbiBmb3JtIHdhcyBzdWJtaXR0ZWRcbiAgICAgICAgKi8gICAgICAgICAgXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uKGUsIHBhcmFtcykge1xuICAgICAgICAgICAgLy9tYXJrIGVsZW1lbnQgd2l0aCB1bnNhdmVkIGNsYXNzIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnVuc2F2ZWRjbGFzcykge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgIEFkZCB1bnNhdmVkIGNzcyB0byBlbGVtZW50IGlmOlxuICAgICAgICAgICAgICAgICAgLSB1cmwgaXMgbm90IHVzZXIncyBmdW5jdGlvbiBcbiAgICAgICAgICAgICAgICAgIC0gdmFsdWUgd2FzIG5vdCBzZW50IHRvIHNlcnZlclxuICAgICAgICAgICAgICAgICAgLSBwYXJhbXMucmVzcG9uc2UgPT09IHVuZGVmaW5lZCwgdGhhdCBtZWFucyBkYXRhIHdhcyBub3Qgc2VudFxuICAgICAgICAgICAgICAgICAgLSB2YWx1ZSBjaGFuZ2VkIFxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZW50ID0gc2VudCB8fCB0eXBlb2YgdGhpcy5vcHRpb25zLnVybCA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgICAgICBzZW50ID0gc2VudCB8fCB0aGlzLm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2U7IFxuICAgICAgICAgICAgICAgIHNlbnQgPSBzZW50IHx8IHBhcmFtcy5yZXNwb25zZSAhPT0gdW5kZWZpbmVkOyBcbiAgICAgICAgICAgICAgICBzZW50ID0gc2VudCB8fCAodGhpcy5pbnB1dC52YWx1ZTJzdHIodGhpcy52YWx1ZSkgIT09IHRoaXMuaW5wdXQudmFsdWUyc3RyKHBhcmFtcy5uZXdWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMudW5zYXZlZGNsYXNzKTsgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMudW5zYXZlZGNsYXNzKTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9oaWdobGlnaHQgd2hlbiBzYXZpbmdcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgJGUgPSB0aGlzLiRlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gJGUuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICRlLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHRoaXMub3B0aW9ucy5oaWdobGlnaHQpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoYmdDb2xvciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmdDb2xvciA9ICcnOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkZS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBiZ0NvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgJGUuYWRkQ2xhc3MoJ2VkaXRhYmxlLWJnLXRyYW5zaXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAkZS5yZW1vdmVDbGFzcygnZWRpdGFibGUtYmctdHJhbnNpdGlvbicpOyAgXG4gICAgICAgICAgICAgICAgICAgIH0sIDE3MDApO1xuICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zZXQgbmV3IHZhbHVlXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHBhcmFtcy5uZXdWYWx1ZSwgZmFsc2UsIHBhcmFtcy5yZXNwb25zZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICBGaXJlZCB3aGVuIG5ldyB2YWx1ZSB3YXMgc3VibWl0dGVkLiBZb3UgY2FuIHVzZSA8Y29kZT4kKHRoaXMpLmRhdGEoJ2VkaXRhYmxlJyk8L2NvZGU+IHRvIGFjY2VzcyB0byBlZGl0YWJsZSBpbnN0YW5jZVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBAZXZlbnQgc2F2ZSBcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgYWRkaXRpb25hbCBwYXJhbXNcbiAgICAgICAgICAgIEBwYXJhbSB7bWl4ZWR9IHBhcmFtcy5uZXdWYWx1ZSBzdWJtaXR0ZWQgdmFsdWVcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucmVzcG9uc2UgYWpheCByZXNwb25zZVxuICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICQoJyN1c2VybmFtZScpLm9uKCdzYXZlJywgZnVuY3Rpb24oZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ1NhdmVkIHZhbHVlOiAnICsgcGFyYW1zLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICAvL2V2ZW50IGl0c2VsZiBpcyB0cmlnZ2VyZWQgYnkgZWRpdGFibGVDb250YWluZXIuIERlc2NyaXB0aW9uIGhlcmUgaXMgb25seSBmb3IgZG9jdW1lbnRhdGlvbiAgICAgICAgICAgICAgXG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnZhbGlkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YWxpZGF0ZS5jYWxsKHRoaXMsIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFNldHMgbmV3IHZhbHVlIG9mIGVkaXRhYmxlXG4gICAgICAgIEBtZXRob2Qgc2V0VmFsdWUodmFsdWUsIGNvbnZlcnRTdHIpXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHZhbHVlIG5ldyB2YWx1ZSBcbiAgICAgICAgQHBhcmFtIHtib29sZWFufSBjb252ZXJ0U3RyIHdoZXRoZXIgdG8gY29udmVydCB2YWx1ZSBmcm9tIHN0cmluZyB0byBpbnRlcm5hbCBmb3JtYXRcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgY29udmVydFN0ciwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmKGNvbnZlcnRTdHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbnB1dC5zdHIydmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLm9wdGlvbigndmFsdWUnLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQud2hlbih0aGlzLnJlbmRlcihyZXNwb25zZSkpXG4gICAgICAgICAgICAudGhlbigkLnByb3h5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRW1wdHkoKTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBBY3RpdmF0ZXMgaW5wdXQgb2YgdmlzaWJsZSBjb250YWluZXIgKGUuZy4gc2V0IGZvY3VzKVxuICAgICAgICBAbWV0aG9kIGFjdGl2YXRlKClcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hY3RpdmF0ZSgpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBSZW1vdmVzIGVkaXRhYmxlIGZlYXR1cmUgZnJvbSBlbGVtZW50XG4gICAgICAgIEBtZXRob2QgZGVzdHJveSgpXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5kZXN0cm95KCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnRvZ2dsZSAhPT0gJ21hbnVhbCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdlZGl0YWJsZS1jbGljaycpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKHRoaXMub3B0aW9ucy50b2dnbGUgKyAnLmVkaXRhYmxlJyk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZihcInNhdmUuaW50ZXJuYWxcIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2VkaXRhYmxlIGVkaXRhYmxlLW9wZW4gZWRpdGFibGUtZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnZWRpdGFibGUnKTtcbiAgICAgICAgfSAgICAgICAgXG4gICAgfTtcblxuICAgIC8qIEVESVRBQkxFIFBMVUdJTiBERUZJTklUSU9OXG4gICAgKiA9PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgLyoqXG4gICAgalF1ZXJ5IG1ldGhvZCB0byBpbml0aWFsaXplIGVkaXRhYmxlIGVsZW1lbnQuXG4gICAgXG4gICAgQG1ldGhvZCAkKCkuZWRpdGFibGUob3B0aW9ucylcbiAgICBAcGFyYW1zIHtPYmplY3R9IG9wdGlvbnNcbiAgICBAZXhhbXBsZVxuICAgICQoJyN1c2VybmFtZScpLmVkaXRhYmxlKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHBrOiAxXG4gICAgfSk7XG4gICAgKiovXG4gICAgJC5mbi5lZGl0YWJsZSA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgLy9zcGVjaWFsIEFQSSBtZXRob2RzIHJldHVybmluZyBub24tanF1ZXJ5IG9iamVjdFxuICAgICAgICB2YXIgcmVzdWx0ID0ge30sIGFyZ3MgPSBhcmd1bWVudHMsIGRhdGFrZXkgPSAnZWRpdGFibGUnO1xuICAgICAgICBzd2l0Y2ggKG9wdGlvbikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBSdW5zIGNsaWVudC1zaWRlIHZhbGlkYXRpb24gZm9yIGFsbCBtYXRjaGVkIGVkaXRhYmxlc1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBAbWV0aG9kIHZhbGlkYXRlKClcbiAgICAgICAgICAgIEByZXR1cm5zIHtPYmplY3R9IHZhbGlkYXRpb24gZXJyb3JzIG1hcFxuICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICQoJyN1c2VybmFtZSwgI2Z1bGxuYW1lJykuZWRpdGFibGUoJ3ZhbGlkYXRlJyk7XG4gICAgICAgICAgICAvLyBwb3NzaWJsZSByZXN1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHVzZXJuYW1lOiBcInVzZXJuYW1lIGlzIHJlcXVpcmVkXCIsXG4gICAgICAgICAgICAgIGZ1bGxuYW1lOiBcImZ1bGxuYW1lIHNob3VsZCBiZSBtaW5pbXVtIDMgbGV0dGVycyBsZW5ndGhcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICBjYXNlICd2YWxpZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSwgZGF0YSA9ICR0aGlzLmRhdGEoZGF0YWtleSksIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiAoZXJyb3IgPSBkYXRhLnZhbGlkYXRlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbZGF0YS5vcHRpb25zLm5hbWVdID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgUmV0dXJucyBjdXJyZW50IHZhbHVlcyBvZiBlZGl0YWJsZSBlbGVtZW50cy4gICBcbiAgICAgICAgICAgIE5vdGUgdGhhdCBpdCByZXR1cm5zIGFuICoqb2JqZWN0Kiogd2l0aCBuYW1lLXZhbHVlIHBhaXJzLCBub3QgYSB2YWx1ZSBpdHNlbGYuIEl0IGFsbG93cyB0byBnZXQgZGF0YSBmcm9tIHNldmVyYWwgZWxlbWVudHMuICAgIFxuICAgICAgICAgICAgSWYgdmFsdWUgb2Ygc29tZSBlZGl0YWJsZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgaXQgaXMgZXhjbHVkZWQgZnJvbSByZXN1bHQgb2JqZWN0LlxuICAgICAgICAgICAgV2hlbiBwYXJhbSBgaXNTaW5nbGVgIGlzIHNldCB0byAqKnRydWUqKiAtIGl0IGlzIHN1cHBvc2VkIHlvdSBoYXZlIHNpbmdsZSBlbGVtZW50IGFuZCB3aWxsIHJldHVybiB2YWx1ZSBvZiBlZGl0YWJsZSBpbnN0ZWFkIG9mIG9iamVjdC4gICBcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIEBtZXRob2QgZ2V0VmFsdWUoKVxuICAgICAgICAgICAgQHBhcmFtIHtib29sfSBpc1NpbmdsZSB3aGV0aGVyIHRvIHJldHVybiBqdXN0IHZhbHVlIG9mIHNpbmdsZSBlbGVtZW50XG4gICAgICAgICAgICBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgb2YgZWxlbWVudCBuYW1lcyBhbmQgdmFsdWVzXG4gICAgICAgICAgICBAZXhhbXBsZVxuICAgICAgICAgICAgJCgnI3VzZXJuYW1lLCAjZnVsbG5hbWUnKS5lZGl0YWJsZSgnZ2V0VmFsdWUnKTtcbiAgICAgICAgICAgIC8vcmVzdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgdXNlcm5hbWU6IFwic3VwZXJ1c2VyXCIsXG4gICAgICAgICAgICBmdWxsbmFtZTogXCJKb2huXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaXNTaW5nbGUgPSB0cnVlXG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSgnZ2V0VmFsdWUnLCB0cnVlKTtcbiAgICAgICAgICAgIC8vcmVzdWx0IFwic3VwZXJ1c2VyXCIgXG4gICAgICAgICAgICAqKi9cbiAgICAgICAgICAgIGNhc2UgJ2dldFZhbHVlJzpcbiAgICAgICAgICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIGFyZ3VtZW50c1sxXSA9PT0gdHJ1ZSkgeyAvL2lzU2luZ2xlID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmVxKDApLmRhdGEoZGF0YWtleSkudmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksIGRhdGEgPSAkdGhpcy5kYXRhKGRhdGFrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGRhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbZGF0YS5vcHRpb25zLm5hbWVdID0gZGF0YS5pbnB1dC52YWx1ZTJzdWJtaXQoZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgVGhpcyBtZXRob2QgY29sbGVjdHMgdmFsdWVzIGZyb20gc2V2ZXJhbCBlZGl0YWJsZSBlbGVtZW50cyBhbmQgc3VibWl0IHRoZW0gYWxsIHRvIHNlcnZlci4gICBcbiAgICAgICAgICAgIEludGVybmFsbHkgaXQgcnVucyBjbGllbnQtc2lkZSB2YWxpZGF0aW9uIGZvciBhbGwgZmllbGRzIGFuZCBzdWJtaXRzIG9ubHkgaW4gY2FzZSBvZiBzdWNjZXNzLiAgXG4gICAgICAgICAgICBTZWUgPGEgaHJlZj1cIiNuZXdyZWNvcmRcIj5jcmVhdGluZyBuZXcgcmVjb3JkczwvYT4gZm9yIGRldGFpbHMuICBcbiAgICAgICAgICAgIFNpbmNlIDEuNS4xIGBzdWJtaXRgIGNhbiBiZSBhcHBsaWVkIHRvIHNpbmdsZSBlbGVtZW50IHRvIHNlbmQgZGF0YSBwcm9ncmFtbWF0aWNhbGx5LiBJbiB0aGF0IGNhc2VcbiAgICAgICAgICAgIGB1cmxgLCBgc3VjY2Vzc2AgYW5kIGBlcnJvcmAgaXMgdGFrZW4gZnJvbSBpbml0aWFsIG9wdGlvbnMgYW5kIHlvdSBjYW4ganVzdCBjYWxsIGAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSgnc3VibWl0JylgLiBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQG1ldGhvZCBzdWJtaXQob3B0aW9ucylcbiAgICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFxuICAgICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudXJsIHVybCB0byBzdWJtaXQgZGF0YSBcbiAgICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmRhdGEgYWRkaXRpb25hbCBkYXRhIHRvIHN1Ym1pdFxuICAgICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuYWpheE9wdGlvbnMgYWRkaXRpb25hbCBhamF4IG9wdGlvbnNcbiAgICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuZXJyb3Iob2JqKSBlcnJvciBoYW5kbGVyIFxuICAgICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5zdWNjZXNzKG9iaixjb25maWcpIHN1Y2Nlc3MgaGFuZGxlclxuICAgICAgICAgICAgQHJldHVybnMge09iamVjdH0galF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICBjYXNlICdzdWJtaXQnOiAgLy9jb2xsZWN0cyB2YWx1ZSwgdmFsaWRhdGUgYW5kIHN1Ym1pdCB0byBzZXJ2ZXIgZm9yIGNyZWF0aW5nIG5ldyByZWNvcmRcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gYXJndW1lbnRzWzFdIHx8IHt9LFxuICAgICAgICAgICAgICAgICRlbGVtcyA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZXJyb3JzID0gdGhpcy5lZGl0YWJsZSgndmFsaWRhdGUnKTtcblxuICAgICAgICAgICAgICAgIC8vIHZhbGlkYXRpb24gb2tcbiAgICAgICAgICAgICAgICBpZigkLmlzRW1wdHlPYmplY3QoZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWpheE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3Igc2luZ2xlIGVsZW1lbnQgdXNlIHVybCwgc3VjY2VzcyBldGMgZnJvbSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmKCRlbGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9ICRlbGVtcy5kYXRhKCdlZGl0YWJsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9zdGFuZGFyZCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWRpdGFibGUub3B0aW9ucy5uYW1lIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlZGl0YWJsZS5pbnB1dC52YWx1ZTJzdWJtaXQoZWRpdGFibGUudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrOiAodHlwZW9mIGVkaXRhYmxlLm9wdGlvbnMucGsgPT09ICdmdW5jdGlvbicpID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLm9wdGlvbnMucGsuY2FsbChlZGl0YWJsZS5vcHRpb25zLnNjb3BlKSA6IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5vcHRpb25zLnBrIFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGRpdGlvbmFsIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGVkaXRhYmxlLm9wdGlvbnMucGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gZWRpdGFibGUub3B0aW9ucy5wYXJhbXMuY2FsbChlZGl0YWJsZS5vcHRpb25zLnNjb3BlLCBwYXJhbXMpOyAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGpzb24gaW4gc2luZ2xlIHF1b3RlcyAoZnJvbSBkYXRhLXBhcmFtcyBhdHRyaWJ1dGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUub3B0aW9ucy5wYXJhbXMgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKGVkaXRhYmxlLm9wdGlvbnMucGFyYW1zLCB0cnVlKTsgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChwYXJhbXMsIGVkaXRhYmxlLm9wdGlvbnMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYWpheE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBlZGl0YWJsZS5vcHRpb25zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBzdWNjZXNzIC8gZXJyb3IgZnJvbSBvcHRpb25zIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN1Y2Nlc3MgPSBjb25maWcuc3VjY2VzcyB8fCBlZGl0YWJsZS5vcHRpb25zLnN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZXJyb3IgPSBjb25maWcuZXJyb3IgfHwgZWRpdGFibGUub3B0aW9ucy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBtdWx0aXBsZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZWRpdGFibGUoJ2dldFZhbHVlJyk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBhamF4T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGNvbmZpZy51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFqYXggc3VjY2VzcyBjYWxsYWJjayAocmVzcG9uc2UgMjAwIE9LKVxuICAgICAgICAgICAgICAgICAgICBhamF4T3B0aW9ucy5zdWNjZXNzID0gdHlwZW9mIGNvbmZpZy5zdWNjZXNzID09PSAnZnVuY3Rpb24nID8gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc3VjY2Vzcy5jYWxsKCRlbGVtcywgcmVzcG9uc2UsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IDogJC5ub29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBhamF4IGVycm9yIGNhbGxhYmNrXG4gICAgICAgICAgICAgICAgICAgIGFqYXhPcHRpb25zLmVycm9yID0gdHlwZW9mIGNvbmZpZy5lcnJvciA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZXJyb3IuYXBwbHkoJGVsZW1zLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSA6ICQubm9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dGVuZCBhamF4T3B0aW9ucyAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoY29uZmlnLmFqYXhPcHRpb25zKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQoYWpheE9wdGlvbnMsIGNvbmZpZy5hamF4T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dHJhIGRhdGEgXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbmZpZy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChhamF4T3B0aW9ucy5kYXRhLCBjb25maWcuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gYWpheCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICQuYWpheChhamF4T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9jbGllbnQtc2lkZSB2YWxpZGF0aW9uIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb25maWcuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lcnJvci5jYWxsKCRlbGVtcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9yZXR1cm4ganF1ZXJ5IG9iamVjdFxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksIFxuICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKGRhdGFrZXkpLCBcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PT0gJ29iamVjdCcgJiYgb3B0aW9uO1xuXG4gICAgICAgICAgICAvL2ZvciBkZWxlZ2F0ZWQgdGFyZ2V0cyBkbyBub3Qgc3RvcmUgYGVkaXRhYmxlYCBvYmplY3QgZm9yIGVsZW1lbnRcbiAgICAgICAgICAgIC8vaXQncyBhbGxvd3Mgc2V2ZXJhbCBkaWZmZXJlbnQgc2VsZWN0b3JzLlxuICAgICAgICAgICAgLy9zZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlL2lzc3Vlcy8zMTIgICAgXG4gICAgICAgICAgICBpZihvcHRpb25zICYmIG9wdGlvbnMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbmV3IEVkaXRhYmxlKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgXG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKGRhdGFrZXksIChkYXRhID0gbmV3IEVkaXRhYmxlKHRoaXMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJykgeyAvL2NhbGwgbWV0aG9kIFxuICAgICAgICAgICAgICAgIGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICB9OyAgICBcbiAgICAgICAgICAgIFxuXG4gICAgJC5mbi5lZGl0YWJsZS5kZWZhdWx0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgIFR5cGUgb2YgaW5wdXQuIENhbiBiZSA8Y29kZT50ZXh0fHRleHRhcmVhfHNlbGVjdHxkYXRlfGNoZWNrbGlzdDwvY29kZT4gYW5kIG1vcmVcblxuICAgICAgICBAcHJvcGVydHkgdHlwZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICd0ZXh0J1xuICAgICAgICAqKi9cbiAgICAgICAgdHlwZTogJ3RleHQnLCAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBTZXRzIGRpc2FibGVkIHN0YXRlIG9mIGVkaXRhYmxlXG5cbiAgICAgICAgQHByb3BlcnR5IGRpc2FibGVkIFxuICAgICAgICBAdHlwZSBib29sZWFuXG4gICAgICAgIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICBIb3cgdG8gdG9nZ2xlIGVkaXRhYmxlLiBDYW4gYmUgPGNvZGU+Y2xpY2t8ZGJsY2xpY2t8bW91c2VlbnRlcnxtYW51YWw8L2NvZGU+LiAgIFxuICAgICAgICBXaGVuIHNldCB0byA8Y29kZT5tYW51YWw8L2NvZGU+IHlvdSBzaG91bGQgbWFudWFsbHkgY2FsbCA8Y29kZT5zaG93L2hpZGU8L2NvZGU+IG1ldGhvZHMgb2YgZWRpdGFibGUuICAgIFxuICAgICAgICAqKk5vdGUqKjogaWYgeW91IGNhbGwgPGNvZGU+c2hvdzwvY29kZT4gb3IgPGNvZGU+dG9nZ2xlPC9jb2RlPiBpbnNpZGUgKipjbGljayoqIGhhbmRsZXIgb2Ygc29tZSBET00gZWxlbWVudCwgXG4gICAgICAgIHlvdSBuZWVkIHRvIGFwcGx5IDxjb2RlPmUuc3RvcFByb3BhZ2F0aW9uKCk8L2NvZGU+IGJlY2F1c2UgY29udGFpbmVycyBhcmUgYmVpbmcgY2xvc2VkIG9uIGFueSBjbGljayBvbiBkb2N1bWVudC5cbiAgICAgICAgXG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgICQoJyNlZGl0LWJ1dHRvbicpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSgndG9nZ2xlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIEBwcm9wZXJ0eSB0b2dnbGUgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAnY2xpY2snXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgdG9nZ2xlOiAnY2xpY2snLFxuICAgICAgICAvKipcbiAgICAgICAgVGV4dCBzaG93biB3aGVuIGVsZW1lbnQgaXMgZW1wdHkuXG5cbiAgICAgICAgQHByb3BlcnR5IGVtcHR5dGV4dCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICdFbXB0eSdcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGVtcHR5dGV4dDogJ0VtcHR5JyxcbiAgICAgICAgLyoqXG4gICAgICAgIEFsbG93cyB0byBhdXRvbWF0aWNhbGx5IHNldCBlbGVtZW50J3MgdGV4dCBiYXNlZCBvbiBpdCdzIHZhbHVlLiBDYW4gYmUgPGNvZGU+YXV0b3xhbHdheXN8bmV2ZXI8L2NvZGU+LiBVc2VmdWwgZm9yIHNlbGVjdCBhbmQgZGF0ZS5cbiAgICAgICAgRm9yIGV4YW1wbGUsIGlmIGRyb3Bkb3duIGxpc3QgaXMgPGNvZGU+ezE6ICdhJywgMjogJ2InfTwvY29kZT4gYW5kIGVsZW1lbnQncyB2YWx1ZSBzZXQgdG8gPGNvZGU+MTwvY29kZT4sIGl0J3MgaHRtbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIDxjb2RlPidhJzwvY29kZT4uICBcbiAgICAgICAgPGNvZGU+YXV0bzwvY29kZT4gLSB0ZXh0IHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgb25seSBpZiBlbGVtZW50IGlzIGVtcHR5LiAgXG4gICAgICAgIDxjb2RlPmFsd2F5c3xuZXZlcjwvY29kZT4gLSBhbHdheXMobmV2ZXIpIHRyeSB0byBzZXQgZWxlbWVudCdzIHRleHQuXG5cbiAgICAgICAgQHByb3BlcnR5IGF1dG90ZXh0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ2F1dG8nXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgYXV0b3RleHQ6ICdhdXRvJywgXG4gICAgICAgIC8qKlxuICAgICAgICBJbml0aWFsIHZhbHVlIG9mIGlucHV0LiBJZiBub3Qgc2V0LCB0YWtlbiBmcm9tIGVsZW1lbnQncyB0ZXh0LiAgXG4gICAgICAgIE5vdGUsIHRoYXQgaWYgZWxlbWVudCdzIHRleHQgaXMgZW1wdHkgLSB0ZXh0IGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGZyb20gdmFsdWUgYW5kIGNhbiBiZSBjdXN0b21pemVkIChzZWUgYGF1dG90ZXh0YCBvcHRpb24pLiAgXG4gICAgICAgIEZvciBleGFtcGxlLCB0byBkaXNwbGF5IGN1cnJlbmN5IHNpZ246XG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIDxhIGlkPVwicHJpY2VcIiBkYXRhLXR5cGU9XCJ0ZXh0XCIgZGF0YS12YWx1ZT1cIjEwMFwiPjwvYT5cbiAgICAgICAgPHNjcmlwdD5cbiAgICAgICAgJCgnI3ByaWNlJykuZWRpdGFibGUoe1xuICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICBkaXNwbGF5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAkKHRoaXMpLnRleHQodmFsdWUgKyAnJCcpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSkgXG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICAgICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgdmFsdWUgXG4gICAgICAgIEB0eXBlIG1peGVkXG4gICAgICAgIEBkZWZhdWx0IGVsZW1lbnQncyB0ZXh0XG4gICAgICAgICoqL1xuICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIENhbGxiYWNrIHRvIHBlcmZvcm0gY3VzdG9tIGRpc3BsYXlpbmcgb2YgdmFsdWUgaW4gZWxlbWVudCdzIHRleHQuICBcbiAgICAgICAgSWYgYG51bGxgLCBkZWZhdWx0IGlucHV0J3MgZGlzcGxheSB1c2VkLiAgXG4gICAgICAgIElmIGBmYWxzZWAsIG5vIGRpc3BsYXlpbmcgbWV0aG9kcyB3aWxsIGJlIGNhbGxlZCwgZWxlbWVudCdzIHRleHQgd2lsbCBuZXZlciBjaGFuZ2UuICBcbiAgICAgICAgUnVucyB1bmRlciBlbGVtZW50J3Mgc2NvcGUuICBcbiAgICAgICAgXyoqUGFyYW1ldGVyczoqKl8gIFxuICAgICAgICBcbiAgICAgICAgKiBgdmFsdWVgIGN1cnJlbnQgdmFsdWUgdG8gYmUgZGlzcGxheWVkXG4gICAgICAgICogYHJlc3BvbnNlYCBzZXJ2ZXIgcmVzcG9uc2UgKGlmIGRpc3BsYXkgY2FsbGVkIGFmdGVyIGFqYXggc3VibWl0KSwgc2luY2UgMS40LjBcbiAgICAgICAgIFxuICAgICAgICBGb3IgX2lucHV0cyB3aXRoIHNvdXJjZV8gKHNlbGVjdCwgY2hlY2tsaXN0KSBwYXJhbWV0ZXJzIGFyZSBkaWZmZXJlbnQ6ICBcbiAgICAgICAgICBcbiAgICAgICAgKiBgdmFsdWVgIGN1cnJlbnQgdmFsdWUgdG8gYmUgZGlzcGxheWVkXG4gICAgICAgICogYHNvdXJjZURhdGFgIGFycmF5IG9mIGl0ZW1zIGZvciBjdXJyZW50IGlucHV0IChlLmcuIGRyb3Bkb3duIGl0ZW1zKSBcbiAgICAgICAgKiBgcmVzcG9uc2VgIHNlcnZlciByZXNwb25zZSAoaWYgZGlzcGxheSBjYWxsZWQgYWZ0ZXIgYWpheCBzdWJtaXQpLCBzaW5jZSAxLjQuMFxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgIFRvIGdldCBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXMgdXNlIGAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCBzb3VyY2VEYXRhKWAuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgZGlzcGxheSBcbiAgICAgICAgQHR5cGUgZnVuY3Rpb258Ym9vbGVhblxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICBkaXNwbGF5OiBmdW5jdGlvbih2YWx1ZSwgc291cmNlRGF0YSkge1xuICAgICAgICAgICAvL2Rpc3BsYXkgY2hlY2tsaXN0IGFzIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgdmFyIGh0bWwgPSBbXSxcbiAgICAgICAgICAgICAgIGNoZWNrZWQgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCBzb3VyY2VEYXRhKTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICBpZihjaGVja2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgJC5lYWNoKGNoZWNrZWQsIGZ1bmN0aW9uKGksIHYpIHsgaHRtbC5wdXNoKCQuZm4uZWRpdGFibGV1dGlscy5lc2NhcGUodi50ZXh0KSk7IH0pO1xuICAgICAgICAgICAgICAgJCh0aGlzKS5odG1sKGh0bWwuam9pbignLCAnKSk7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAkKHRoaXMpLmVtcHR5KCk7IFxuICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBkaXNwbGF5OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgQ3NzIGNsYXNzIGFwcGxpZWQgd2hlbiBlZGl0YWJsZSB0ZXh0IGlzIGVtcHR5LlxuXG4gICAgICAgIEBwcm9wZXJ0eSBlbXB0eWNsYXNzIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQHNpbmNlIDEuNC4xICAgICAgICBcbiAgICAgICAgQGRlZmF1bHQgZWRpdGFibGUtZW1wdHlcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgZW1wdHljbGFzczogJ2VkaXRhYmxlLWVtcHR5JyxcbiAgICAgICAgLyoqXG4gICAgICAgIENzcyBjbGFzcyBhcHBsaWVkIHdoZW4gdmFsdWUgd2FzIHN0b3JlZCBidXQgbm90IHNlbnQgdG8gc2VydmVyIChgcGtgIGlzIGVtcHR5IG9yIGBzZW5kID0gJ25ldmVyJ2ApLiAgXG4gICAgICAgIFlvdSBtYXkgc2V0IGl0IHRvIGBudWxsYCBpZiB5b3Ugd29yayB3aXRoIGVkaXRhYmxlcyBsb2NhbGx5IGFuZCBzdWJtaXQgdGhlbSB0b2dldGhlci4gIFxuXG4gICAgICAgIEBwcm9wZXJ0eSB1bnNhdmVkY2xhc3MgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAc2luY2UgMS40LjEgICAgICAgIFxuICAgICAgICBAZGVmYXVsdCBlZGl0YWJsZS11bnNhdmVkXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHVuc2F2ZWRjbGFzczogJ2VkaXRhYmxlLXVuc2F2ZWQnLFxuICAgICAgICAvKipcbiAgICAgICAgSWYgc2VsZWN0b3IgaXMgcHJvdmlkZWQsIGVkaXRhYmxlIHdpbGwgYmUgZGVsZWdhdGVkIHRvIHRoZSBzcGVjaWZpZWQgdGFyZ2V0cy4gIFxuICAgICAgICBVc2VmdWxsIGZvciBkeW5hbWljYWxseSBnZW5lcmF0ZWQgRE9NIGVsZW1lbnRzLiAgXG4gICAgICAgICoqUGxlYXNlIG5vdGUqKiwgdGhhdCBkZWxlZ2F0ZWQgdGFyZ2V0cyBjYW4ndCBiZSBpbml0aWFsaXplZCB3aXRoIGBlbXB0eXRleHRgIGFuZCBgYXV0b3RleHRgIG9wdGlvbnMsIFxuICAgICAgICBhcyB0aGV5IGFjdHVhbGx5IGJlY29tZSBlZGl0YWJsZSBvbmx5IGFmdGVyIGZpcnN0IGNsaWNrLiAgXG4gICAgICAgIFlvdSBzaG91bGQgbWFudWFsbHkgc2V0IGNsYXNzIGBlZGl0YWJsZS1jbGlja2AgdG8gdGhlc2UgZWxlbWVudHMuICBcbiAgICAgICAgQWxzbywgaWYgZWxlbWVudCBvcmlnaW5hbGx5IGVtcHR5IHlvdSBzaG91bGQgYWRkIGNsYXNzIGBlZGl0YWJsZS1lbXB0eWAsIHNldCBgZGF0YS12YWx1ZT1cIlwiYCBhbmQgd3JpdGUgZW1wdHl0ZXh0IGludG8gZWxlbWVudDpcblxuICAgICAgICBAcHJvcGVydHkgc2VsZWN0b3IgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAc2luY2UgMS40LjEgICAgICAgIFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIDxkaXYgaWQ9XCJ1c2VyXCI+XG4gICAgICAgICAgPCEtLSBlbXB0eSAtLT5cbiAgICAgICAgICA8YSBocmVmPVwiI1wiIGRhdGEtbmFtZT1cInVzZXJuYW1lXCIgZGF0YS10eXBlPVwidGV4dFwiIGNsYXNzPVwiZWRpdGFibGUtY2xpY2sgZWRpdGFibGUtZW1wdHlcIiBkYXRhLXZhbHVlPVwiXCIgdGl0bGU9XCJVc2VybmFtZVwiPkVtcHR5PC9hPlxuICAgICAgICAgIDwhLS0gbm9uLWVtcHR5IC0tPlxuICAgICAgICAgIDxhIGhyZWY9XCIjXCIgZGF0YS1uYW1lPVwiZ3JvdXBcIiBkYXRhLXR5cGU9XCJzZWxlY3RcIiBkYXRhLXNvdXJjZT1cIi9ncm91cHNcIiBkYXRhLXZhbHVlPVwiMVwiIGNsYXNzPVwiZWRpdGFibGUtY2xpY2tcIiB0aXRsZT1cIkdyb3VwXCI+T3BlcmF0b3I8L2E+XG4gICAgICAgIDwvZGl2PiAgICAgXG4gICAgICAgIFxuICAgICAgICA8c2NyaXB0PlxuICAgICAgICAkKCcjdXNlcicpLmVkaXRhYmxlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnYScsXG4gICAgICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgICAgICBwazogMVxuICAgICAgICB9KTtcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBzZWxlY3RvcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIENvbG9yIHVzZWQgdG8gaGlnaGxpZ2h0IGVsZW1lbnQgYWZ0ZXIgdXBkYXRlLiBJbXBsZW1lbnRlZCB2aWEgQ1NTMyB0cmFuc2l0aW9uLCB3b3JrcyBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgaGlnaGxpZ2h0IFxuICAgICAgICBAdHlwZSBzdHJpbmd8Ym9vbGVhblxuICAgICAgICBAc2luY2UgMS40LjUgICAgICAgIFxuICAgICAgICBAZGVmYXVsdCAjRkZGRjgwIFxuICAgICAgICAqKi9cbiAgICAgICAgaGlnaGxpZ2h0OiAnI0ZGRkY4MCdcbiAgICB9O1xuICAgIFxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuQWJzdHJhY3RJbnB1dCAtIGJhc2UgY2xhc3MgZm9yIGFsbCBlZGl0YWJsZSBpbnB1dHMuXG5JdCBkZWZpbmVzIGludGVyZmFjZSB0byBiZSBpbXBsZW1lbnRlZCBieSBhbnkgaW5wdXQgdHlwZS5cblRvIGNyZWF0ZSB5b3VyIG93biBpbnB1dCB5b3UgY2FuIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzLlxuXG5AY2xhc3MgYWJzdHJhY3RpbnB1dFxuKiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIC8vdHlwZXNcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMgPSB7fTtcblxuICAgIHZhciBBYnN0cmFjdElucHV0ID0gZnVuY3Rpb24gKCkgeyB9O1xuXG4gICAgQWJzdHJhY3RJbnB1dC5wcm90b3R5cGUgPSB7XG4gICAgICAgLyoqXG4gICAgICAgIEluaXRpYWxpemVzIGlucHV0XG5cbiAgICAgICAgQG1ldGhvZCBpbml0KCkgXG4gICAgICAgICoqL1xuICAgICAgIGluaXQ6IGZ1bmN0aW9uKHR5cGUsIG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgfSxcblxuICAgICAgIC8qXG4gICAgICAgdGhpcyBtZXRob2QgY2FsbGVkIGJlZm9yZSByZW5kZXIgdG8gaW5pdCAkdHBsIHRoYXQgaXMgaW5zZXJ0ZWQgaW4gRE9NXG4gICAgICAgKi9cbiAgICAgICBwcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB0aGlzLiR0cGwgPSAkKHRoaXMub3B0aW9ucy50cGwpOyAvL3dob2xlIHRwbCBhcyBqcXVlcnkgb2JqZWN0ICAgIFxuICAgICAgICAgICB0aGlzLiRpbnB1dCA9IHRoaXMuJHRwbDsgICAgICAgICAvL2NvbnRyb2wgaXRzZWxmLCBjYW4gYmUgY2hhbmdlZCBpbiByZW5kZXIgbWV0aG9kXG4gICAgICAgICAgIHRoaXMuJGNsZWFyID0gbnVsbDsgICAgICAgICAgICAgIC8vY2xlYXIgYnV0dG9uXG4gICAgICAgICAgIHRoaXMuZXJyb3IgPSBudWxsOyAgICAgICAgICAgICAgIC8vZXJyb3IgbWVzc2FnZSwgaWYgaW5wdXQgY2Fubm90IGJlIHJlbmRlcmVkICAgICAgICAgICBcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qKlxuICAgICAgICBSZW5kZXJzIGlucHV0IGZyb20gdHBsLiBDYW4gcmV0dXJuIGpRdWVyeSBkZWZlcnJlZCBvYmplY3QuXG4gICAgICAgIENhbiBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBvYmplY3RzXG5cbiAgICAgICAgQG1ldGhvZCByZW5kZXIoKVxuICAgICAgICoqL1xuICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICB9LCBcblxuICAgICAgIC8qKlxuICAgICAgICBTZXRzIGVsZW1lbnQncyBodG1sIGJ5IHZhbHVlLiBcblxuICAgICAgICBAbWV0aG9kIHZhbHVlMmh0bWwodmFsdWUsIGVsZW1lbnQpXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHZhbHVlXG4gICAgICAgIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudFxuICAgICAgICoqL1xuICAgICAgIHZhbHVlMmh0bWw6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICQoZWxlbWVudClbdGhpcy5vcHRpb25zLmVzY2FwZSA/ICd0ZXh0JyA6ICdodG1sJ10oJC50cmltKHZhbHVlKSk7XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICBDb252ZXJ0cyBlbGVtZW50J3MgaHRtbCB0byB2YWx1ZVxuXG4gICAgICAgIEBtZXRob2QgaHRtbDJ2YWx1ZShodG1sKVxuICAgICAgICBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAgICBAcmV0dXJucyB7bWl4ZWR9XG4gICAgICAgKiovXG4gICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICByZXR1cm4gJCgnPGRpdj4nKS5odG1sKGh0bWwpLnRleHQoKTtcbiAgICAgICB9LFxuXG4gICAgICAgLyoqXG4gICAgICAgIENvbnZlcnRzIHZhbHVlIHRvIHN0cmluZyAoZm9yIGludGVybmFsIGNvbXBhcmUpLiBGb3Igc3VibWl0dGluZyB0byBzZXJ2ZXIgdXNlZCB2YWx1ZTJzdWJtaXQoKS5cblxuICAgICAgICBAbWV0aG9kIHZhbHVlMnN0cih2YWx1ZSkgXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHZhbHVlXG4gICAgICAgIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgKiovXG4gICAgICAgdmFsdWUyc3RyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgfSwgXG5cbiAgICAgICAvKipcbiAgICAgICAgQ29udmVydHMgc3RyaW5nIHJlY2VpdmVkIGZyb20gc2VydmVyIGludG8gdmFsdWUuIFVzdWFsbHkgZnJvbSBgZGF0YS12YWx1ZWAgYXR0cmlidXRlLlxuXG4gICAgICAgIEBtZXRob2Qgc3RyMnZhbHVlKHN0cilcbiAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAgICBAcmV0dXJucyB7bWl4ZWR9XG4gICAgICAgKiovXG4gICAgICAgc3RyMnZhbHVlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICB9LCBcbiAgICAgICBcbiAgICAgICAvKipcbiAgICAgICAgQ29udmVydHMgdmFsdWUgZm9yIHN1Ym1pdHRpbmcgdG8gc2VydmVyLiBSZXN1bHQgY2FuIGJlIHN0cmluZyBvciBvYmplY3QuXG5cbiAgICAgICAgQG1ldGhvZCB2YWx1ZTJzdWJtaXQodmFsdWUpIFxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZVxuICAgICAgICBAcmV0dXJucyB7bWl4ZWR9XG4gICAgICAgKiovXG4gICAgICAgdmFsdWUyc3VibWl0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICBTZXRzIHZhbHVlIG9mIGlucHV0LlxuXG4gICAgICAgIEBtZXRob2QgdmFsdWUyaW5wdXQodmFsdWUpIFxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZVxuICAgICAgICoqL1xuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwodmFsdWUpO1xuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgUmV0dXJucyB2YWx1ZSBvZiBpbnB1dC4gVmFsdWUgY2FuIGJlIG9iamVjdCAoZS5nLiBkYXRlcGlja2VyKVxuXG4gICAgICAgIEBtZXRob2QgaW5wdXQydmFsdWUoKSBcbiAgICAgICAqKi9cbiAgICAgICBpbnB1dDJ2YWx1ZTogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQudmFsKCk7XG4gICAgICAgfSwgXG5cbiAgICAgICAvKipcbiAgICAgICAgQWN0aXZhdGVzIGlucHV0LiBGb3IgdGV4dCBpdCBzZXRzIGZvY3VzLlxuXG4gICAgICAgIEBtZXRob2QgYWN0aXZhdGUoKSBcbiAgICAgICAqKi9cbiAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIGlmKHRoaXMuJGlucHV0LmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICB9XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICBDcmVhdGVzIGlucHV0LlxuXG4gICAgICAgIEBtZXRob2QgY2xlYXIoKSBcbiAgICAgICAqKi8gICAgICAgIFxuICAgICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQudmFsKG51bGwpO1xuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgbWV0aG9kIHRvIGVzY2FwZSBodG1sLlxuICAgICAgICoqL1xuICAgICAgIGVzY2FwZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgIHJldHVybiAkKCc8ZGl2PicpLnRleHQoc3RyKS5odG1sKCk7XG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICAvKipcbiAgICAgICAgYXR0YWNoIGhhbmRsZXIgdG8gYXV0b21hdGljYWxseSBzdWJtaXQgZm9ybSB3aGVuIHZhbHVlIGNoYW5nZWQgKHVzZWZ1bCB3aGVuIGJ1dHRvbnMgbm90IHNob3duKVxuICAgICAgICoqL1xuICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qKlxuICAgICAgIEFkZGl0aW9uYWwgYWN0aW9ucyB3aGVuIGRlc3Ryb3lpbmcgZWxlbWVudCBcbiAgICAgICAqKi9cbiAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICB9LFxuXG4gICAgICAgLy8gLS0tLS0tLS0gaGVscGVyIGZ1bmN0aW9ucyAtLS0tLS0tLVxuICAgICAgIHNldENsYXNzOiBmdW5jdGlvbigpIHsgICAgICAgICAgXG4gICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5pbnB1dGNsYXNzKSB7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRjbGFzcyk7IFxuICAgICAgICAgICB9IFxuICAgICAgIH0sXG5cbiAgICAgICBzZXRBdHRyOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNbYXR0cl0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnNbYXR0cl0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LmF0dHIoYXR0ciwgdGhpcy5vcHRpb25zW2F0dHJdKTtcbiAgICAgICAgICAgfSBcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIG9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICB9XG4gICAgICAgXG4gICAgfTtcbiAgICAgICAgXG4gICAgQWJzdHJhY3RJbnB1dC5kZWZhdWx0cyA9IHsgIFxuICAgICAgICAvKipcbiAgICAgICAgSFRNTCB0ZW1wbGF0ZSBvZiBpbnB1dC4gTm9ybWFsbHkgeW91IHNob3VsZCBub3QgY2hhbmdlIGl0LlxuXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAnJ1xuICAgICAgICAqKi8gICBcbiAgICAgICAgdHBsOiAnJyxcbiAgICAgICAgLyoqXG4gICAgICAgIENTUyBjbGFzcyBhdXRvbWF0aWNhbGx5IGFwcGxpZWQgdG8gaW5wdXRcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgaW5wdXRjbGFzczogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBJZiBgdHJ1ZWAgLSBodG1sIHdpbGwgYmUgZXNjYXBlZCBpbiBjb250ZW50IG9mIGVsZW1lbnQgdmlhICQudGV4dCgpIG1ldGhvZC4gIFxuICAgICAgICBJZiBgZmFsc2VgIC0gaHRtbCB3aWxsIG5vdCBiZSBlc2NhcGVkLCAkLmh0bWwoKSB1c2VkLiAgXG4gICAgICAgIFdoZW4geW91IHVzZSBvd24gYGRpc3BsYXlgIGZ1bmN0aW9uLCB0aGlzIG9wdGlvbiBvYnZpb3NseSBoYXMgbm8gZWZmZWN0LlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IGVzY2FwZSBcbiAgICAgICAgQHR5cGUgYm9vbGVhblxuICAgICAgICBAc2luY2UgMS41LjBcbiAgICAgICAgQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgZXNjYXBlOiB0cnVlLFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAvL3Njb3BlIGZvciBleHRlcm5hbCBtZXRob2RzIChlLmcuIHNvdXJjZSBkZWZpbmVkIGFzIGZ1bmN0aW9uKVxuICAgICAgICAvL2ZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAgICBzY29wZTogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIC8vbmVlZCB0byByZS1kZWNsYXJlIHNob3didXR0b25zIGhlcmUgdG8gZ2V0IGl0J3MgdmFsdWUgZnJvbSBjb21tb24gY29uZmlnIChwYXNzZWQgb25seSBvcHRpb25zIGV4aXN0aW5nIGluIGRlZmF1bHRzKVxuICAgICAgICBzaG93YnV0dG9uczogdHJ1ZSBcbiAgICB9O1xuICAgIFxuICAgICQuZXh0ZW5kKCQuZm4uZWRpdGFibGV0eXBlcywge2Fic3RyYWN0aW5wdXQ6IEFic3RyYWN0SW5wdXR9KTtcbiAgICAgICAgXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5MaXN0IC0gYWJzdHJhY3QgY2xhc3MgZm9yIGlucHV0cyB0aGF0IGhhdmUgc291cmNlIG9wdGlvbiBsb2FkZWQgZnJvbSBqcyBhcnJheSBvciB2aWEgYWpheFxuXG5AY2xhc3MgbGlzdFxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuKiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIHZhciBMaXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICBcbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoTGlzdCwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpO1xuXG4gICAgJC5leHRlbmQoTGlzdC5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vblNvdXJjZVJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxpc3QoKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IHRoaXMub3B0aW9ucy5zb3VyY2VFcnJvcjtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBodG1sMnZhbHVlOiBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vY2FuJ3Qgc2V0IHZhbHVlIGJ5IHRleHRcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHZhbHVlMmh0bWw6IGZ1bmN0aW9uICh2YWx1ZSwgZWxlbWVudCwgZGlzcGxheSwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgZGlzcGxheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jdXN0b20gZGlzcGxheSBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkuY2FsbChlbGVtZW50LCB2YWx1ZSwgdGhpcy5zb3VyY2VEYXRhLCByZXNwb25zZSk7IFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZTJodG1sRmluYWwodmFsdWUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZm9yIG51bGwgdmFsdWUganVzdCBjYWxsIHN1Y2Nlc3Mgd2l0aG91dCBsb2FkaW5nIHNvdXJjZVxuICAgICAgICAgICAgaWYodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgIHN1Y2Nlc3MuY2FsbCh0aGlzKTsgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICB0aGlzLm9uU291cmNlUmVhZHkoc3VjY2VzcywgZnVuY3Rpb24gKCkgeyBkZWZlcnJlZC5yZXNvbHZlKCk7IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgICB9LCAgXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLSBhZGRpdGlvbmFsIGZ1bmN0aW9ucyAtLS0tLS0tLS0tLS1cblxuICAgICAgICBvblNvdXJjZVJlYWR5OiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIC8vcnVuIHNvdXJjZSBpZiBpdCBmdW5jdGlvblxuICAgICAgICAgICAgdmFyIHNvdXJjZTtcbiAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGlzLm9wdGlvbnMuc291cmNlLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vbm90ZTogaWYgZnVuY3Rpb24gcmV0dXJucyB0aGUgc2FtZSBzb3VyY2UgYXMgVVJMIC0gc291cmNlRGF0YSB3aWxsIGJlIHRha2VuIGZyb20gY2FoY2UgYW5kIG5vIGV4dHJhIHJlcXVlc3QgcGVyZm9ybWVkXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgYWxscmVhZHkgbG9hZGVkIGp1c3QgY2FsbCBzdWNjZXNzXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuc291cmNlQ2FjaGUgJiYgJC5pc0FycmF5KHRoaXMuc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy90cnkgcGFyc2UganNvbiBpbiBzaW5nbGUgcXVvdGVzIChmb3IgZG91YmxlIHF1b3RlcyBqcXVlcnkgZG9lcyBhdXRvbWF0aWNhbGx5KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKHNvdXJjZSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2xvYWRpbmcgZnJvbSB1cmxcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vdHJ5IHRvIGdldCBzb3VyY2VEYXRhIGZyb20gY2FjaGVcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuc291cmNlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlSUQgPSBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghJChkb2N1bWVudCkuZGF0YShjYWNoZUlEKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJChkb2N1bWVudCkuZGF0YShjYWNoZUlELCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSAkKGRvY3VtZW50KS5kYXRhKGNhY2hlSUQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIGNhY2hlZCBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZS5sb2FkaW5nID09PSBmYWxzZSAmJiBjYWNoZS5zb3VyY2VEYXRhKSB7IC8vdGFrZSBzb3VyY2UgZnJvbSBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gY2FjaGUuc291cmNlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9QcmVwZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FjaGUubG9hZGluZyA9PT0gdHJ1ZSkgeyAvL2NhY2hlIGlzIGxvYWRpbmcsIHB1dCBjYWxsYmFjayBpbiBzdGFjayB0byBiZSBjYWxsZWQgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmNhbGxiYWNrcy5wdXNoKCQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRGF0YSA9IGNhY2hlLnNvdXJjZURhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1ByZXBlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWxzbyBjb2xsZWN0aW5nIGVycm9yIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuZXJyX2NhbGxiYWNrcy5wdXNoKCQucHJveHkoZXJyb3IsIHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9ubyBjYWNoZSB5ZXQsIGFjdGl2YXRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuZXJyX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vYWpheE9wdGlvbnMgZm9yIHNvdXJjZS4gQ2FuIGJlIG92ZXJ3cml0dGVuIGJ0IG9wdGlvbnMuc291cmNlT3B0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBhamF4T3B0aW9ucyA9ICQuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdnZXQnLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6ICQucHJveHkoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gdGhpcy5tYWtlQXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZigkLmlzQXJyYXkodGhpcy5zb3VyY2VEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3RvcmUgcmVzdWx0IGluIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNvdXJjZURhdGEgPSB0aGlzLnNvdXJjZURhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcnVuIHN1Y2Nlc3MgY2FsbGJhY2tzIGZvciBvdGhlciBmaWVsZHMgd2FpdGluZyBmb3IgdGhpcyBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGNhY2hlLmNhbGxiYWNrcywgZnVuY3Rpb24gKCkgeyB0aGlzLmNhbGwoKTsgfSk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvUHJlcGVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3J1biBlcnJvciBjYWxsYmFja3MgZm9yIG90aGVyIGZpZWxkcyB3YWl0aW5nIGZvciB0aGlzIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goY2FjaGUuZXJyX2NhbGxiYWNrcywgZnVuY3Rpb24gKCkgeyB0aGlzLmNhbGwoKTsgfSk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAkLnByb3h5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcnVuIGVycm9yIGNhbGxiYWNrcyBmb3Igb3RoZXIgZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChjYWNoZS5lcnJfY2FsbGJhY2tzLCBmdW5jdGlvbiAoKSB7IHRoaXMuY2FsbCgpOyB9KTsgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnNvdXJjZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vbG9hZGluZyBzb3VyY2VEYXRhIGZyb20gc2VydmVyXG4gICAgICAgICAgICAgICAgJC5hamF4KGFqYXhPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vb3B0aW9ucyBhcyBqc29uL2FycmF5XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gdGhpcy5tYWtlQXJyYXkoc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoJC5pc0FycmF5KHRoaXMuc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1ByZXBlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcy5jYWxsKHRoaXMpOyAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRvUHJlcGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnByZXBlbmQgPT09IG51bGwgfHwgdGhpcy5vcHRpb25zLnByZXBlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZighJC5pc0FycmF5KHRoaXMucHJlcGVuZERhdGEpKSB7XG4gICAgICAgICAgICAgICAgLy9ydW4gcHJlcGVuZCBpZiBpdCBpcyBmdW5jdGlvbiAob25jZSlcbiAgICAgICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5wcmVwZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucHJlcGVuZCA9IHRoaXMub3B0aW9ucy5wcmVwZW5kLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGpzb24gaW4gc2luZ2xlIHF1b3Rlc1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wcmVwZW5kID0gJC5mbi5lZGl0YWJsZXV0aWxzLnRyeVBhcnNlSnNvbih0aGlzLm9wdGlvbnMucHJlcGVuZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IHByZXBlbmQgZnJvbSBzdHJpbmcgdG8gb2JqZWN0XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucHJlcGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnByZXBlbmQgPSB7Jyc6IHRoaXMub3B0aW9ucy5wcmVwZW5kfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5wcmVwZW5kRGF0YSA9IHRoaXMubWFrZUFycmF5KHRoaXMub3B0aW9ucy5wcmVwZW5kKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoJC5pc0FycmF5KHRoaXMucHJlcGVuZERhdGEpICYmICQuaXNBcnJheSh0aGlzLnNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gdGhpcy5wcmVwZW5kRGF0YS5jb25jYXQodGhpcy5zb3VyY2VEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgcmVuZGVycyBpbnB1dCBsaXN0XG4gICAgICAgICovXG4gICAgICAgIHJlbmRlckxpc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gdGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJ3cml0dGVuIGluIGNoaWxkIGNsYXNzXG4gICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgICAvKlxuICAgICAgICAgc2V0IGVsZW1lbnQncyBodG1sIGJ5IHZhbHVlXG4gICAgICAgICovXG4gICAgICAgIHZhbHVlMmh0bWxGaW5hbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBjbGFzc1xuICAgICAgICB9LCAgICAgICAgXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogY29udmVydCBkYXRhIHRvIGFycmF5IHN1aXRhYmxlIGZvciBzb3VyY2VEYXRhLCBlLmcuIFt7dmFsdWU6IDEsIHRleHQ6ICdhYmMnfSwgey4uLn1dXG4gICAgICAgICovXG4gICAgICAgIG1ha2VBcnJheTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvdW50LCBvYmosIHJlc3VsdCA9IFtdLCBpdGVtLCBpdGVyYXRlSXRlbTtcbiAgICAgICAgICAgIGlmKCFkYXRhIHx8IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoJC5pc0FycmF5KGRhdGEpKSB7IC8vYXJyYXlcbiAgICAgICAgICAgICAgICAvKiBcbiAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0byBpdGVyYXRlIGluc2lkZSBpdGVtIG9mIGFycmF5IGlmIGl0ZW0gaXMgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgIENhY2x1bGF0ZXMgY291bnQgb2Yga2V5cyBpbiBpdGVtIGFuZCBzdG9yZSBpbiBvYmouIFxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaXRlcmF0ZUl0ZW0gPSBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSB7dmFsdWU6IGssIHRleHQ6IHZ9O1xuICAgICAgICAgICAgICAgICAgICBpZihjb3VudCsrID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsvLyBleGl0IGZyb20gYGVhY2hgIGlmIGl0ZW0gaGFzIG1vcmUgdGhhbiBvbmUga2V5LlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBkYXRhW2ldOyBcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDA7IC8vY291bnQgb2Yga2V5cyBpbnNpZGUgaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGl0ZW0sIGl0ZXJhdGVJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FzZTogW3t2YWwxOiAndGV4dDEnfSwge3ZhbDI6ICd0ZXh0Mn0gLi4uXVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY291bnQgPT09IDEpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jYXNlOiBbe3ZhbHVlOiAxLCB0ZXh0OiAndGV4dDEnfSwge3ZhbHVlOiAyLCB0ZXh0OiAndGV4dDInfSwgLi4uXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKGNvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlZCBjaGVjayBvZiBleGlzdGFuY2U6IGl0ZW0uaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgJiYgaXRlbS5oYXNPd25Qcm9wZXJ0eSgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNoaWxkcmVuID0gdGhpcy5tYWtlQXJyYXkoaXRlbS5jaGlsZHJlbik7ICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jYXNlOiBbJ3RleHQxJywgJ3RleHQyJyAuLi5dXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7dmFsdWU6IGl0ZW0sIHRleHQ6IGl0ZW19KTsgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAgLy9jYXNlOiB7dmFsMTogJ3RleHQxJywgdmFsMjogJ3RleHQyLCAuLi59XG4gICAgICAgICAgICAgICAgJC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHt2YWx1ZTogaywgdGV4dDogdn0pO1xuICAgICAgICAgICAgICAgIH0pOyAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgb3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYoa2V5ID09PSAnc291cmNlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihrZXkgPT09ICdwcmVwZW5kJykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlcGVuZERhdGEgPSBudWxsO1xuICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICB9ICAgICAgICBcblxuICAgIH0pOyAgICAgIFxuXG4gICAgTGlzdC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgU291cmNlIGRhdGEgZm9yIGxpc3QuICBcbiAgICAgICAgSWYgKiphcnJheSoqIC0gaXQgc2hvdWxkIGJlIGluIGZvcm1hdDogYFt7dmFsdWU6IDEsIHRleHQ6IFwidGV4dDFcIn0sIHt2YWx1ZTogMiwgdGV4dDogXCJ0ZXh0MlwifSwgLi4uXWAgIFxuICAgICAgICBGb3IgY29tcGFiaWxpdHksIG9iamVjdCBmb3JtYXQgaXMgYWxzbyBzdXBwb3J0ZWQ6IGB7XCIxXCI6IFwidGV4dDFcIiwgXCIyXCI6IFwidGV4dDJcIiAuLi59YCBidXQgaXQgZG9lcyBub3QgZ3VhcmFudGVlIGVsZW1lbnRzIG9yZGVyLlxuICAgICAgICBcbiAgICAgICAgSWYgKipzdHJpbmcqKiAtIGNvbnNpZGVyZWQgYWpheCB1cmwgdG8gbG9hZCBpdGVtcy4gSW4gdGhhdCBjYXNlIHJlc3VsdHMgd2lsbCBiZSBjYWNoZWQgZm9yIGZpZWxkcyB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmQgbmFtZS4gU2VlIGFsc28gYHNvdXJjZUNhY2hlYCBvcHRpb24uXG4gICAgICAgICAgXG4gICAgICAgIElmICoqZnVuY3Rpb24qKiwgaXQgc2hvdWxkIHJldHVybiBkYXRhIGluIGZvcm1hdCBhYm92ZSAoc2luY2UgMS40LjApLlxuICAgICAgICBcbiAgICAgICAgU2luY2UgMS40LjEga2V5IGBjaGlsZHJlbmAgc3VwcG9ydGVkIHRvIHJlbmRlciBPUFRHUk9VUCAoZm9yICoqc2VsZWN0KiogaW5wdXQgb25seSkuICBcbiAgICAgICAgYFt7dGV4dDogXCJncm91cDFcIiwgY2hpbGRyZW46IFt7dmFsdWU6IDEsIHRleHQ6IFwidGV4dDFcIn0sIHt2YWx1ZTogMiwgdGV4dDogXCJ0ZXh0MlwifV19LCAuLi5dYCBcblxuXHRcdFxuICAgICAgICBAcHJvcGVydHkgc291cmNlIFxuICAgICAgICBAdHlwZSBzdHJpbmcgfCBhcnJheSB8IG9iamVjdCB8IGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHNvdXJjZTogbnVsbCwgXG4gICAgICAgIC8qKlxuICAgICAgICBEYXRhIGF1dG9tYXRpY2FsbHkgcHJlcGVuZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgZHJvcGRvd24gbGlzdC5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBwcmVwZW5kIFxuICAgICAgICBAdHlwZSBzdHJpbmcgfCBhcnJheSB8IG9iamVjdCB8IGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBwcmVwZW5kOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgIEVycm9yIG1lc3NhZ2Ugd2hlbiBsaXN0IGNhbm5vdCBiZSBsb2FkZWQgKGUuZy4gYWpheCBlcnJvcilcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBzb3VyY2VFcnJvciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IEVycm9yIHdoZW4gbG9hZGluZyBsaXN0XG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgc291cmNlRXJyb3I6ICdFcnJvciB3aGVuIGxvYWRpbmcgbGlzdCcsXG4gICAgICAgIC8qKlxuICAgICAgICBpZiA8Y29kZT50cnVlPC9jb2RlPiBhbmQgc291cmNlIGlzICoqc3RyaW5nIHVybCoqIC0gcmVzdWx0cyB3aWxsIGJlIGNhY2hlZCBmb3IgZmllbGRzIHdpdGggdGhlIHNhbWUgc291cmNlLiAgICBcbiAgICAgICAgVXNlZnVsbCBmb3IgZWRpdGFibGUgY29sdW1uIGluIGdyaWQgdG8gcHJldmVudCBleHRyYSByZXF1ZXN0cy5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBzb3VyY2VDYWNoZSBcbiAgICAgICAgQHR5cGUgYm9vbGVhblxuICAgICAgICBAZGVmYXVsdCB0cnVlXG4gICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBzb3VyY2VDYWNoZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgIEFkZGl0aW9uYWwgYWpheCBvcHRpb25zIHRvIGJlIHVzZWQgaW4gJC5hamF4KCkgd2hlbiBsb2FkaW5nIGxpc3QgZnJvbSBzZXJ2ZXIuXG4gICAgICAgIFVzZWZ1bCB0byBzZW5kIGV4dHJhIHBhcmFtZXRlcnMgKGBkYXRhYCBrZXkpIG9yIGNoYW5nZSByZXF1ZXN0IG1ldGhvZCAoYHR5cGVgIGtleSkuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgc291cmNlT3B0aW9ucyBcbiAgICAgICAgQHR5cGUgb2JqZWN0fGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQHNpbmNlIDEuNS4wXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHNvdXJjZU9wdGlvbnM6IG51bGxcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5saXN0ID0gTGlzdDsgICAgICBcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuVGV4dCBpbnB1dFxuXG5AY2xhc3MgdGV4dFxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQGZpbmFsXG5AZXhhbXBsZVxuPGEgaHJlZj1cIiNcIiBpZD1cInVzZXJuYW1lXCIgZGF0YS10eXBlPVwidGV4dFwiIGRhdGEtcGs9XCIxXCI+YXdlc29tZTwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI3VzZXJuYW1lJykuZWRpdGFibGUoe1xuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHRpdGxlOiAnRW50ZXIgdXNlcm5hbWUnXG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIHZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCd0ZXh0Jywgb3B0aW9ucywgVGV4dC5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KFRleHQsICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTtcblxuICAgICQuZXh0ZW5kKFRleHQucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMucmVuZGVyQ2xlYXIoKTtcbiAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3BsYWNlaG9sZGVyJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLiRpbnB1dC5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgJC5mbi5lZGl0YWJsZXV0aWxzLnNldEN1cnNvclBvc2l0aW9uKHRoaXMuJGlucHV0LmdldCgwKSwgdGhpcy4kaW5wdXQudmFsKCkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnRvZ2dsZUNsZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlQ2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvL3JlbmRlciBjbGVhciBidXR0b25cbiAgICAgICAgcmVuZGVyQ2xlYXI6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGVhcikge1xuICAgICAgICAgICAgICAgdGhpcy4kY2xlYXIgPSAkKCc8c3BhbiBjbGFzcz1cImVkaXRhYmxlLWNsZWFyLXhcIj48L3NwYW4+Jyk7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5hZnRlcih0aGlzLiRjbGVhcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygncGFkZGluZy1yaWdodCcsIDI0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAua2V5dXAoJC5wcm94eShmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Fycm93cywgZW50ZXIsIHRhYiwgZXRjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih+JC5pbkFycmF5KGUua2V5Q29kZSwgWzQwLDM4LDksMTMsMjddKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudG9nZ2xlQ2xlYXIoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAucGFyZW50KCkuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLmNsaWNrKCQucHJveHkodGhpcy5jbGVhciwgdGhpcykpOyAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHBvc3RyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIC8vbm93IGBjbGVhcmAgaXMgcG9zaXRpb25lZCB2aWEgY3NzXG4gICAgICAgICAgICBpZih0aGlzLiRjbGVhcikge1xuICAgICAgICAgICAgICAgIC8vY2FuIHBvc2l0aW9uIGNsZWFyIGJ1dHRvbiBvbmx5IGhlcmUsIHdoZW4gZm9ybSBpcyBzaG93biBhbmQgaGVpZ2h0IGNhbiBiZSBjYWxjdWxhdGVkXG4vLyAgICAgICAgICAgICAgICB2YXIgaCA9IHRoaXMuJGlucHV0Lm91dGVySGVpZ2h0KHRydWUpIHx8IDIwLFxuICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy4kY2xlYXIucGFyZW50KCkuaGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gKGggLSB0aGlzLiRjbGVhci5oZWlnaHQoKSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL3RoaXMuJGNsZWFyLmNzcyh7Ym90dG9tOiBkZWx0YSwgcmlnaHQ6IGRlbHRhfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAqLyBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8vc2hvdyAvIGhpZGUgY2xlYXIgYnV0dG9uXG4gICAgICAgIHRvZ2dsZUNsZWFyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZighdGhpcy4kY2xlYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLiRpbnB1dC52YWwoKS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdmlzaWJsZSA9IHRoaXMuJGNsZWFyLmlzKCc6dmlzaWJsZScpO1xuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGxlbiAmJiAhdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLnNob3coKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCFsZW4gJiYgdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLmhpZGUoKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMuJGNsZWFyLmhpZGUoKTtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQudmFsKCcnKS5mb2N1cygpO1xuICAgICAgICB9ICAgICAgICAgIFxuICAgIH0pO1xuXG4gICAgVGV4dC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbCBcbiAgICAgICAgQGRlZmF1bHQgPGlucHV0IHR5cGU9XCJ0ZXh0XCI+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0cGw6ICc8aW5wdXQgdHlwZT1cInRleHRcIj4nLFxuICAgICAgICAvKipcbiAgICAgICAgUGxhY2Vob2xkZXIgYXR0cmlidXRlIG9mIGlucHV0LiBTaG93biB3aGVuIGlucHV0IGlzIGVtcHR5LlxuXG4gICAgICAgIEBwcm9wZXJ0eSBwbGFjZWhvbGRlciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgICAgIFxuICAgICAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBXaGV0aGVyIHRvIHNob3cgYGNsZWFyYCBidXR0b24gXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgY2xlYXIgXG4gICAgICAgIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgQGRlZmF1bHQgdHJ1ZSAgICAgICAgXG4gICAgICAgICoqL1xuICAgICAgICBjbGVhcjogdHJ1ZVxuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQgPSBUZXh0O1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5UZXh0YXJlYSBpbnB1dFxuXG5AY2xhc3MgdGV4dGFyZWFcbkBleHRlbmRzIGFic3RyYWN0aW5wdXRcbkBmaW5hbFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJjb21tZW50c1wiIGRhdGEtdHlwZT1cInRleHRhcmVhXCIgZGF0YS1waz1cIjFcIj5hd2Vzb21lIGNvbW1lbnQhPC9hPlxuPHNjcmlwdD5cbiQoZnVuY3Rpb24oKXtcbiAgICAkKCcjY29tbWVudHMnKS5lZGl0YWJsZSh7XG4gICAgICAgIHVybDogJy9wb3N0JyxcbiAgICAgICAgdGl0bGU6ICdFbnRlciBjb21tZW50cycsXG4gICAgICAgIHJvd3M6IDEwXG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIHZhciBUZXh0YXJlYSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgndGV4dGFyZWEnLCBvcHRpb25zLCBUZXh0YXJlYS5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KFRleHRhcmVhLCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dCk7XG5cbiAgICAkLmV4dGVuZChUZXh0YXJlYS5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNldENsYXNzKCk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3BsYWNlaG9sZGVyJyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3Jvd3MnKTsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jdHJsICsgZW50ZXJcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmtleWRvd24oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5ICYmIGUud2hpY2ggPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnZm9ybScpLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAvL3VzaW5nIGB3aGl0ZS1zcGFjZTogcHJlLXdyYXBgIHNvbHZlcyBcXG4gIDwtLT4gQlIgY29udmVyc2lvbiB2ZXJ5IGVsZWdhbnQhXG4gICAgICAgLyogXG4gICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBodG1sID0gJycsIGxpbmVzO1xuICAgICAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsaW5lcyA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXNbaV0gPSAkKCc8ZGl2PicpLnRleHQobGluZXNbaV0pLmh0bWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHRtbCA9IGxpbmVzLmpvaW4oJzxicj4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQoZWxlbWVudCkuaHRtbChodG1sKTtcbiAgICAgICAgfSxcbiAgICAgICBcbiAgICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgaWYoIWh0bWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoU3RyaW5nLmZyb21DaGFyQ29kZSgxMCksICdnJyk7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBodG1sLnNwbGl0KC88YnJcXHMqXFwvPz4vaSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSAkKCc8ZGl2PicpLmh0bWwobGluZXNbaV0pLnRleHQoKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBuZXdsaW5lIGNoYXJhY3RlcnMgKFxcbikgdG8gYXZvaWQgdGhlbSBiZWluZyBjb252ZXJ0ZWQgYnkgdmFsdWUyaHRtbCgpIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHRodXMgYWRkaW5nIGV4dHJhIDxicj4gdGFnc1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVnZXgsICcnKTtcblxuICAgICAgICAgICAgICAgIGxpbmVzW2ldID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9LFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQucHJvdG90eXBlLmFjdGl2YXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFRleHRhcmVhLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsXG4gICAgICAgIEBkZWZhdWx0IDx0ZXh0YXJlYT48L3RleHRhcmVhPlxuICAgICAgICAqKi9cbiAgICAgICAgdHBsOic8dGV4dGFyZWE+PC90ZXh0YXJlYT4nLFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3NcbiAgICAgICAgQGRlZmF1bHQgaW5wdXQtbGFyZ2VcbiAgICAgICAgKiovXG4gICAgICAgIGlucHV0Y2xhc3M6ICdpbnB1dC1sYXJnZScsXG4gICAgICAgIC8qKlxuICAgICAgICBQbGFjZWhvbGRlciBhdHRyaWJ1dGUgb2YgaW5wdXQuIFNob3duIHdoZW4gaW5wdXQgaXMgZW1wdHkuXG5cbiAgICAgICAgQHByb3BlcnR5IHBsYWNlaG9sZGVyXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIE51bWJlciBvZiByb3dzIGluIHRleHRhcmVhXG5cbiAgICAgICAgQHByb3BlcnR5IHJvd3NcbiAgICAgICAgQHR5cGUgaW50ZWdlclxuICAgICAgICBAZGVmYXVsdCA3XG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHJvd3M6IDcgICAgICAgIFxuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHRhcmVhID0gVGV4dGFyZWE7XG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcblNlbGVjdCAoZHJvcGRvd24pXG5cbkBjbGFzcyBzZWxlY3RcbkBleHRlbmRzIGxpc3RcbkBmaW5hbFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJzdGF0dXNcIiBkYXRhLXR5cGU9XCJzZWxlY3RcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IHN0YXR1c1wiPjwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI3N0YXR1cycpLmVkaXRhYmxlKHtcbiAgICAgICAgdmFsdWU6IDIsICAgIFxuICAgICAgICBzb3VyY2U6IFtcbiAgICAgICAgICAgICAge3ZhbHVlOiAxLCB0ZXh0OiAnQWN0aXZlJ30sXG4gICAgICAgICAgICAgIHt2YWx1ZTogMiwgdGV4dDogJ0Jsb2NrZWQnfSxcbiAgICAgICAgICAgICAge3ZhbHVlOiAzLCB0ZXh0OiAnRGVsZXRlZCd9XG4gICAgICAgICAgIF1cbiAgICB9KTtcbn0pO1xuPC9zY3JpcHQ+XG4qKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgU2VsZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdzZWxlY3QnLCBvcHRpb25zLCBTZWxlY3QuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChTZWxlY3QsICQuZm4uZWRpdGFibGV0eXBlcy5saXN0KTtcblxuICAgICQuZXh0ZW5kKFNlbGVjdC5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyTGlzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5lbXB0eSgpO1xuXG4gICAgICAgICAgICB2YXIgZmlsbEl0ZW1zID0gZnVuY3Rpb24oJGVsLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgICAgICAgICAgaWYoJC5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhdGFbaV0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmxhYmVsID0gZGF0YVtpXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRlbC5hcHBlbmQoZmlsbEl0ZW1zKCQoJzxvcHRncm91cD4nLCBhdHRyKSwgZGF0YVtpXS5jaGlsZHJlbikpOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci52YWx1ZSA9IGRhdGFbaV0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGF0YVtpXS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGVsLmFwcGVuZCgkKCc8b3B0aW9uPicsIGF0dHIpLnRleHQoZGF0YVtpXS50ZXh0KSk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkZWw7XG4gICAgICAgICAgICB9OyAgICAgICAgXG5cbiAgICAgICAgICAgIGZpbGxJdGVtcyh0aGlzLiRpbnB1dCwgdGhpcy5zb3VyY2VEYXRhKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2VudGVyIHN1Ym1pdFxuICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2tleWRvd24uZWRpdGFibGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAxMykge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTsgICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICBcbiAgICAgICAgdmFsdWUyaHRtbEZpbmFsOiBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSAnJywgXG4gICAgICAgICAgICAgICAgaXRlbXMgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCB0aGlzLnNvdXJjZURhdGEpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGl0ZW1zWzBdLnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vJChlbGVtZW50KS50ZXh0KHRleHQpO1xuICAgICAgICAgICAgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQucHJvdG90eXBlLnZhbHVlMmh0bWwuY2FsbCh0aGlzLCB0ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQub2ZmKCdrZXlkb3duLmVkaXRhYmxlJykub24oJ2NoYW5nZS5lZGl0YWJsZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pOyAgICAgIFxuXG4gICAgU2VsZWN0LmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5saXN0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICBAZGVmYXVsdCA8c2VsZWN0Pjwvc2VsZWN0PlxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdHBsOic8c2VsZWN0Pjwvc2VsZWN0PidcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5zZWxlY3QgPSBTZWxlY3Q7ICAgICAgXG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcbkxpc3Qgb2YgY2hlY2tib3hlcy4gXG5JbnRlcm5hbGx5IHZhbHVlIHN0b3JlZCBhcyBqYXZhc2NyaXB0IGFycmF5IG9mIHZhbHVlcy5cblxuQGNsYXNzIGNoZWNrbGlzdFxuQGV4dGVuZHMgbGlzdFxuQGZpbmFsXG5AZXhhbXBsZVxuPGEgaHJlZj1cIiNcIiBpZD1cIm9wdGlvbnNcIiBkYXRhLXR5cGU9XCJjaGVja2xpc3RcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IG9wdGlvbnNcIj48L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNvcHRpb25zJykuZWRpdGFibGUoe1xuICAgICAgICB2YWx1ZTogWzIsIDNdLCAgICBcbiAgICAgICAgc291cmNlOiBbXG4gICAgICAgICAgICAgIHt2YWx1ZTogMSwgdGV4dDogJ29wdGlvbjEnfSxcbiAgICAgICAgICAgICAge3ZhbHVlOiAyLCB0ZXh0OiAnb3B0aW9uMid9LFxuICAgICAgICAgICAgICB7dmFsdWU6IDMsIHRleHQ6ICdvcHRpb24zJ31cbiAgICAgICAgICAgXVxuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIHZhciBDaGVja2xpc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2NoZWNrbGlzdCcsIG9wdGlvbnMsIENoZWNrbGlzdC5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KENoZWNrbGlzdCwgJC5mbi5lZGl0YWJsZXR5cGVzLmxpc3QpO1xuXG4gICAgJC5leHRlbmQoQ2hlY2tsaXN0LnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXJMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkbGFiZWwsICRkaXY7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJHRwbC5lbXB0eSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZighJC5pc0FycmF5KHRoaXMuc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuc291cmNlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICRsYWJlbCA9ICQoJzxsYWJlbD4nKS5hcHBlbmQoJCgnPGlucHV0PicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNvdXJjZURhdGFbaV0udmFsdWUgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8c3Bhbj4nKS50ZXh0KCcgJyt0aGlzLnNvdXJjZURhdGFbaV0udGV4dCkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICQoJzxkaXY+JykuYXBwZW5kKCRsYWJlbCkuYXBwZW5kVG8odGhpcy4kdHBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kaW5wdXQgPSB0aGlzLiR0cGwuZmluZCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJyk7XG4gICAgICAgICAgICB0aGlzLnNldENsYXNzKCk7XG4gICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgdmFsdWUyc3RyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICByZXR1cm4gJC5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNvcnQoKS5qb2luKCQudHJpbSh0aGlzLm9wdGlvbnMuc2VwYXJhdG9yKSkgOiAnJztcbiAgICAgICB9LCAgXG4gICAgICAgXG4gICAgICAgLy9wYXJzZSBzZXBhcmF0ZWQgc3RyaW5nXG4gICAgICAgIHN0cjJ2YWx1ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgIHZhciByZWcsIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgcmVnID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyskLnRyaW0odGhpcy5vcHRpb25zLnNlcGFyYXRvcikrJ1xcXFxzKicpO1xuICAgICAgICAgICAgICAgdmFsdWUgPSBzdHIuc3BsaXQocmVnKTtcbiAgICAgICAgICAgfSBlbHNlIGlmKCQuaXNBcnJheShzdHIpKSB7XG4gICAgICAgICAgICAgICB2YWx1ZSA9IHN0cjsgXG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICB2YWx1ZSA9IFtzdHJdO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSwgICAgICAgXG4gICAgICAgXG4gICAgICAgLy9zZXQgY2hlY2tlZCBvbiByZXF1aXJlZCBjaGVja2JveGVzXG4gICAgICAgdmFsdWUyaW5wdXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xuICAgICAgICAgICAgaWYoJC5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LmVhY2goZnVuY3Rpb24oaSwgZWwpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgJGVsID0gJChlbCk7XG4gICAgICAgICAgICAgICAgICAgLy8gY2Fubm90IHVzZSAkLmluQXJyYXkgYXMgaXQgcGVyZm9ybXMgc3RyaWN0IGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICAgICAkLmVhY2godmFsdWUsIGZ1bmN0aW9uKGosIHZhbCl7XG4gICAgICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IHRydWUqL1xuICAgICAgICAgICAgICAgICAgICAgICBpZigkZWwudmFsKCkgPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IGZhbHNlKi8gICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICRlbC5wcm9wKCdjaGVja2VkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgIH0pOyBcbiAgICAgICAgICAgIH0gIFxuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgIGlucHV0MnZhbHVlOiBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgIHZhciBjaGVja2VkID0gW107XG4gICAgICAgICAgIHRoaXMuJGlucHV0LmZpbHRlcignOmNoZWNrZWQnKS5lYWNoKGZ1bmN0aW9uKGksIGVsKSB7XG4gICAgICAgICAgICAgICBjaGVja2VkLnB1c2goJChlbCkudmFsKCkpO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgICAgcmV0dXJuIGNoZWNrZWQ7XG4gICAgICAgfSwgICAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAvL2NvbGxlY3QgdGV4dCBvZiBjaGVja2VkIGJveGVzXG4gICAgICAgIHZhbHVlMmh0bWxGaW5hbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgdmFyIGh0bWwgPSBbXSxcbiAgICAgICAgICAgICAgIGNoZWNrZWQgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCB0aGlzLnNvdXJjZURhdGEpLFxuICAgICAgICAgICAgICAgZXNjYXBlID0gdGhpcy5vcHRpb25zLmVzY2FwZTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICBpZihjaGVja2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgJC5lYWNoKGNoZWNrZWQsIGZ1bmN0aW9uKGksIHYpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGVzY2FwZSA/ICQuZm4uZWRpdGFibGV1dGlscy5lc2NhcGUodi50ZXh0KSA6IHYudGV4dDsgXG4gICAgICAgICAgICAgICAgICAgaHRtbC5wdXNoKHRleHQpOyBcbiAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgJChlbGVtZW50KS5odG1sKGh0bWwuam9pbignPGJyPicpKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICQoZWxlbWVudCkuZW1wdHkoKTsgXG4gICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICBhdXRvc3VibWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2tleWRvd24nLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAxMykge1xuICAgICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnZm9ybScpLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgfSk7ICAgICAgXG5cbiAgICBDaGVja2xpc3QuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmxpc3QuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEBkZWZhdWx0IDxkaXY+PC9kaXY+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0cGw6JzxkaXYgY2xhc3M9XCJlZGl0YWJsZS1jaGVja2xpc3RcIj48L2Rpdj4nLFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgaW5wdXRjbGFzczogbnVsbCwgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFNlcGFyYXRvciBvZiB2YWx1ZXMgd2hlbiByZWFkaW5nIGZyb20gYGRhdGEtdmFsdWVgIGF0dHJpYnV0ZVxuXG4gICAgICAgIEBwcm9wZXJ0eSBzZXBhcmF0b3IgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAnLCdcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHNlcGFyYXRvcjogJywnXG4gICAgfSk7XG5cbiAgICAkLmZuLmVkaXRhYmxldHlwZXMuY2hlY2tsaXN0ID0gQ2hlY2tsaXN0OyAgICAgIFxuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5IVE1MNSBpbnB1dCB0eXBlcy5cbkZvbGxvd2luZyB0eXBlcyBhcmUgc3VwcG9ydGVkOlxuXG4qIHBhc3N3b3JkXG4qIGVtYWlsXG4qIHVybFxuKiB0ZWxcbiogbnVtYmVyXG4qIHJhbmdlXG4qIHRpbWVcblxuTGVhcm4gbW9yZSBhYm91dCBodG1sNSBpbnB1dHM6ICBcbmh0dHA6Ly93d3cudzMub3JnL3dpa2kvSFRNTDVfZm9ybV9hZGRpdGlvbnMgIFxuVG8gY2hlY2sgYnJvd3NlciBjb21wYXRpYmlsaXR5IHBsZWFzZSBzZWU6ICBcbmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9FbGVtZW50L0lucHV0XG4gICAgICAgICAgICBcbkBjbGFzcyBodG1sNXR5cGVzIFxuQGV4dGVuZHMgdGV4dFxuQGZpbmFsXG5Ac2luY2UgMS4zLjBcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwiZW1haWxcIiBkYXRhLXR5cGU9XCJlbWFpbFwiIGRhdGEtcGs9XCIxXCI+YWRtaW5AZXhhbXBsZS5jb208L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNlbWFpbCcpLmVkaXRhYmxlKHtcbiAgICAgICAgdXJsOiAnL3Bvc3QnLFxuICAgICAgICB0aXRsZTogJ0VudGVyIGVtYWlsJ1xuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuXG4vKipcbkBwcm9wZXJ0eSB0cGwgXG5AZGVmYXVsdCBkZXBlbmRzIG9uIHR5cGVcbioqLyBcblxuLypcblBhc3N3b3JkXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIHZhciBQYXNzd29yZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgncGFzc3dvcmQnLCBvcHRpb25zLCBQYXNzd29yZC5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChQYXNzd29yZCwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQpO1xuICAgICQuZXh0ZW5kKFBhc3N3b3JkLnByb3RvdHlwZSwge1xuICAgICAgIC8vZG8gbm90IGRpc3BsYXkgcGFzc3dvcmQsIHNob3cgJ1toaWRkZW5dJyBpbnN0ZWFkXG4gICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICAgICAgICQoZWxlbWVudCkudGV4dCgnW2hpZGRlbl0nKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICQoZWxlbWVudCkuZW1wdHkoKTsgXG4gICAgICAgICAgIH1cbiAgICAgICB9LFxuICAgICAgIC8vYXMgcGFzc3dvcmQgbm90IGRpc3BsYXllZCwgc2hvdWxkIG5vdCBzZXQgdmFsdWUgYnkgaHRtbFxuICAgICAgIGh0bWwydmFsdWU6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgfSAgICAgICBcbiAgICB9KTsgICAgXG4gICAgUGFzc3dvcmQuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiPidcbiAgICB9KTtcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMucGFzc3dvcmQgPSBQYXNzd29yZDtcbn0od2luZG93LmpRdWVyeSkpO1xuXG5cbi8qXG5FbWFpbFxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgRW1haWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2VtYWlsJywgb3B0aW9ucywgRW1haWwuZGVmYXVsdHMpO1xuICAgIH07XG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoRW1haWwsICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0KTtcbiAgICBFbWFpbC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMudGV4dC5kZWZhdWx0cywge1xuICAgICAgICB0cGw6ICc8aW5wdXQgdHlwZT1cImVtYWlsXCI+J1xuICAgIH0pO1xuICAgICQuZm4uZWRpdGFibGV0eXBlcy5lbWFpbCA9IEVtYWlsO1xufSh3aW5kb3cualF1ZXJ5KSk7XG5cblxuLypcblVybFxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgVXJsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCd1cmwnLCBvcHRpb25zLCBVcmwuZGVmYXVsdHMpO1xuICAgIH07XG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoVXJsLCAkLmZuLmVkaXRhYmxldHlwZXMudGV4dCk7XG4gICAgVXJsLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0LmRlZmF1bHRzLCB7XG4gICAgICAgIHRwbDogJzxpbnB1dCB0eXBlPVwidXJsXCI+J1xuICAgIH0pO1xuICAgICQuZm4uZWRpdGFibGV0eXBlcy51cmwgPSBVcmw7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuXG4vKlxuVGVsXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIHZhciBUZWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ3RlbCcsIG9wdGlvbnMsIFRlbC5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChUZWwsICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0KTtcbiAgICBUZWwuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJ0ZWxcIj4nXG4gICAgfSk7XG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRlbCA9IFRlbDtcbn0od2luZG93LmpRdWVyeSkpO1xuXG5cbi8qXG5OdW1iZXJcbiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG4gICAgXG4gICAgdmFyIE51bWJlcklucHV0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdudW1iZXInLCBvcHRpb25zLCBOdW1iZXJJbnB1dC5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChOdW1iZXJJbnB1dCwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQpO1xuICAgICQuZXh0ZW5kKE51bWJlcklucHV0LnByb3RvdHlwZSwge1xuICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBOdW1iZXJJbnB1dC5zdXBlcmNsYXNzLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdtaW4nKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbWF4Jyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3N0ZXAnKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLiRjbGVhcikge1xuICAgICAgICAgICAgICAgIC8vaW5jcmVhc2UgcmlnaHQgZmZzZXQgIGZvciB1cC9kb3duIGFycm93c1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLmNzcyh7cmlnaHQ6IDI0fSk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAvL2NhbiBwb3NpdGlvbiBjbGVhciBidXR0b24gb25seSBoZXJlLCB3aGVuIGZvcm0gaXMgc2hvd24gYW5kIGhlaWdodCBjYW4gYmUgY2FsY3VsYXRlZFxuICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy4kaW5wdXQub3V0ZXJIZWlnaHQodHJ1ZSkgfHwgMjAsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gKGggLSB0aGlzLiRjbGVhci5oZWlnaHQoKSkgLyAyO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vYWRkIDEycHggdG8gb2Zmc2V0IHJpZ2h0IGZvciB1cC9kb3duIGFycm93cyAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiRjbGVhci5jc3Moe3RvcDogZGVsdGEsIHJpZ2h0OiBkZWx0YSArIDE2fSk7XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0gICAgICAgIFxuICAgIH0pOyAgICAgXG4gICAgTnVtYmVySW5wdXQuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJudW1iZXJcIj4nLFxuICAgICAgICBpbnB1dGNsYXNzOiAnaW5wdXQtbWluaScsXG4gICAgICAgIG1pbjogbnVsbCxcbiAgICAgICAgbWF4OiBudWxsLFxuICAgICAgICBzdGVwOiBudWxsXG4gICAgfSk7XG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLm51bWJlciA9IE51bWJlcklucHV0O1xufSh3aW5kb3cualF1ZXJ5KSk7XG5cblxuLypcblJhbmdlIChpbmhlcml0IGZyb20gbnVtYmVyKVxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgUmFuZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ3JhbmdlJywgb3B0aW9ucywgUmFuZ2UuZGVmYXVsdHMpO1xuICAgIH07XG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoUmFuZ2UsICQuZm4uZWRpdGFibGV0eXBlcy5udW1iZXIpO1xuICAgICQuZXh0ZW5kKFJhbmdlLnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0ID0gdGhpcy4kdHBsLmZpbHRlcignaW5wdXQnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdtaW4nKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbWF4Jyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3N0ZXAnKTsgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vbignaW5wdXQnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICQodGhpcykuc2libGluZ3MoJ291dHB1dCcpLnRleHQoJCh0aGlzKS52YWwoKSk7IFxuICAgICAgICAgICAgfSk7ICBcbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfSAgICAgICAgIFxuICAgIH0pO1xuICAgIFJhbmdlLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5udW1iZXIuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJyYW5nZVwiPjxvdXRwdXQgc3R5bGU9XCJ3aWR0aDogMzBweDsgZGlzcGxheTogaW5saW5lLWJsb2NrXCI+PC9vdXRwdXQ+JyxcbiAgICAgICAgaW5wdXRjbGFzczogJ2lucHV0LW1lZGl1bSdcbiAgICB9KTtcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMucmFuZ2UgPSBSYW5nZTtcbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKlxuVGltZVxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcblxuICAgIHZhciBUaW1lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCd0aW1lJywgb3B0aW9ucywgVGltZS5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAvL2luaGVyaXQgZnJvbSBhYnN0cmFjdCwgYXMgaW5oZXJpdGFuY2UgZnJvbSB0ZXh0IGdpdmVzIHNlbGVjdGlvbiBlcnJvci5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChUaW1lLCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dCk7XG4gICAgJC5leHRlbmQoVGltZS5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICB9ICAgICAgICBcbiAgICB9KTtcbiAgICBUaW1lLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIHRwbDogJzxpbnB1dCB0eXBlPVwidGltZVwiPidcbiAgICB9KTtcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMudGltZSA9IFRpbWU7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5TZWxlY3QyIGlucHV0LiBCYXNlZCBvbiBhbWF6aW5nIHdvcmsgb2YgSWdvciBWYXluYmVyZyBodHRwczovL2dpdGh1Yi5jb20vaXZheW5iZXJnL3NlbGVjdDIuICBcblBsZWFzZSBzZWUgW29yaWdpbmFsIHNlbGVjdDIgZG9jc10oaHR0cDovL2l2YXluYmVyZy5naXRodWIuY29tL3NlbGVjdDIpIGZvciBkZXRhaWxlZCBkZXNjcmlwdGlvbiBhbmQgb3B0aW9ucy4gIFxuIFxuWW91IHNob3VsZCBtYW51YWxseSBkb3dubG9hZCBhbmQgaW5jbHVkZSBzZWxlY3QyIGRpc3RyaWJ1dGl2ZTogIFxuXG4gICAgPGxpbmsgaHJlZj1cInNlbGVjdDIvc2VsZWN0Mi5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCI+PC9saW5rPiAgXG4gICAgPHNjcmlwdCBzcmM9XCJzZWxlY3QyL3NlbGVjdDIuanNcIj48L3NjcmlwdD4gIFxuICAgIFxuVG8gbWFrZSBpdCAqKmJvb3RzdHJhcC1zdHlsZWQqKiB5b3UgY2FuIHVzZSBjc3MgZnJvbSBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL3QwbS9zZWxlY3QyLWJvb3RzdHJhcC1jc3MpOiBcblxuICAgIDxsaW5rIGhyZWY9XCJzZWxlY3QyLWJvb3RzdHJhcC5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCI+PC9saW5rPiAgICBcbiAgICBcbioqTm90ZToqKiBjdXJyZW50bHkgYGF1dG90ZXh0YCBmZWF0dXJlIGRvZXMgbm90IHdvcmsgZm9yIHNlbGVjdDIgd2l0aCBgYWpheGAgcmVtb3RlIHNvdXJjZS4gICAgXG5Zb3UgbmVlZCBpbml0aWFsbHkgcHV0IGJvdGggYGRhdGEtdmFsdWVgIGFuZCBlbGVtZW50J3MgdGV4dCB5b3VzZWxmOiAgICBcblxuICAgIDxhIGhyZWY9XCIjXCIgZGF0YS10eXBlPVwic2VsZWN0MlwiIGRhdGEtdmFsdWU9XCIxXCI+VGV4dDE8L2E+XG4gICAgXG4gICAgXG5AY2xhc3Mgc2VsZWN0MlxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQHNpbmNlIDEuNC4xXG5AZmluYWxcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwiY291bnRyeVwiIGRhdGEtdHlwZT1cInNlbGVjdDJcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdmFsdWU9XCJydVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IGNvdW50cnlcIj48L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgIC8vbG9jYWwgc291cmNlXG4gICAgJCgnI2NvdW50cnknKS5lZGl0YWJsZSh7XG4gICAgICAgIHNvdXJjZTogW1xuICAgICAgICAgICAgICB7aWQ6ICdnYicsIHRleHQ6ICdHcmVhdCBCcml0YWluJ30sXG4gICAgICAgICAgICAgIHtpZDogJ3VzJywgdGV4dDogJ1VuaXRlZCBTdGF0ZXMnfSxcbiAgICAgICAgICAgICAge2lkOiAncnUnLCB0ZXh0OiAnUnVzc2lhJ31cbiAgICAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0Mjoge1xuICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy9yZW1vdGUgc291cmNlIChzaW1wbGUpXG4gICAgJCgnI2NvdW50cnknKS5lZGl0YWJsZSh7XG4gICAgICAgIHNvdXJjZTogJy9nZXRDb3VudHJpZXMnLFxuICAgICAgICBzZWxlY3QyOiB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogJ1NlbGVjdCBDb3VudHJ5JyxcbiAgICAgICAgICAgIG1pbmltdW1JbnB1dExlbmd0aDogMVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy9yZW1vdGUgc291cmNlIChhZHZhbmNlZClcbiAgICAkKCcjY291bnRyeScpLmVkaXRhYmxlKHtcbiAgICAgICAgc2VsZWN0Mjoge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdTZWxlY3QgQ291bnRyeScsXG4gICAgICAgICAgICBhbGxvd0NsZWFyOiB0cnVlLFxuICAgICAgICAgICAgbWluaW11bUlucHV0TGVuZ3RoOiAzLFxuICAgICAgICAgICAgaWQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uQ291bnRyeUlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFqYXg6IHtcbiAgICAgICAgICAgICAgICB1cmw6ICcvZ2V0Q291bnRyaWVzJyxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uICh0ZXJtLCBwYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHF1ZXJ5OiB0ZXJtIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBmdW5jdGlvbiAoZGF0YSwgcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHRzOiBkYXRhIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm1hdFJlc3VsdDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5Db3VudHJ5TmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uQ291bnRyeU5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5pdFNlbGVjdGlvbjogZnVuY3Rpb24gKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQuZ2V0KCcvZ2V0Q291bnRyeUJ5SWQnLCB7IHF1ZXJ5OiBlbGVtZW50LnZhbCgpIH0sIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSAgXG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG4gICAgXG4gICAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdzZWxlY3QyJywgb3B0aW9ucywgQ29uc3RydWN0b3IuZGVmYXVsdHMpO1xuXG4gICAgICAgIG9wdGlvbnMuc2VsZWN0MiA9IG9wdGlvbnMuc2VsZWN0MiB8fCB7fTtcblxuICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgLy9wbGFjZWhvbGRlclxuICAgICAgICBpZihvcHRpb25zLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIucGxhY2Vob2xkZXIgPSBvcHRpb25zLnBsYWNlaG9sZGVyO1xuICAgICAgICB9XG4gICAgICAgXG4gICAgICAgIC8vaWYgbm90IGB0YWdzYCBtb2RlLCB1c2Ugc291cmNlXG4gICAgICAgIGlmKCFvcHRpb25zLnNlbGVjdDIudGFncyAmJiBvcHRpb25zLnNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlO1xuICAgICAgICAgICAgLy9pZiBzb3VyY2UgaXMgZnVuY3Rpb24sIGNhbGwgaXQgKG9uY2UhKVxuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihvcHRpb25zLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZS5jYWxsKG9wdGlvbnMuc2NvcGUpO1xuICAgICAgICAgICAgfSAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIuYWpheCA9IG9wdGlvbnMuc2VsZWN0Mi5hamF4IHx8IHt9O1xuICAgICAgICAgICAgICAgIC8vc29tZSBkZWZhdWx0IGFqYXggcGFyYW1zXG4gICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuc2VsZWN0Mi5hamF4LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZWxlY3QyLmFqYXguZGF0YSA9IGZ1bmN0aW9uKHRlcm0pIHtyZXR1cm4geyBxdWVyeTp0ZXJtIH07fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuc2VsZWN0Mi5hamF4LnJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZWxlY3QyLmFqYXgucmVzdWx0cyA9IGZ1bmN0aW9uKGRhdGEpIHsgcmV0dXJuIHtyZXN1bHRzOmRhdGEgfTt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIuYWpheC51cmwgPSBzb3VyY2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9ybWF0IGFuZCBjb252ZXJ0IHgtZWRpdGFibGUgZm9ybWF0IHRvIHNlbGVjdDIgZm9ybWF0IChpZiBuZWVkZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gdGhpcy5jb252ZXJ0U291cmNlKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZWxlY3QyLmRhdGEgPSB0aGlzLnNvdXJjZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG5cbiAgICAgICAgLy9vdmVycmlkaW5nIG9iamVjdHMgaW4gY29uZmlnIChhcyBieSBkZWZhdWx0IGpRdWVyeSBleHRlbmQoKSBpcyBub3QgcmVjdXJzaXZlKVxuICAgICAgICB0aGlzLm9wdGlvbnMuc2VsZWN0MiA9ICQuZXh0ZW5kKHt9LCBDb25zdHJ1Y3Rvci5kZWZhdWx0cy5zZWxlY3QyLCBvcHRpb25zLnNlbGVjdDIpO1xuXG4gICAgICAgIC8vZGV0ZWN0IHdoZXRoZXIgaXQgaXMgbXVsdGktdmFsdWVkXG4gICAgICAgIHRoaXMuaXNNdWx0aXBsZSA9IHRoaXMub3B0aW9ucy5zZWxlY3QyLnRhZ3MgfHwgdGhpcy5vcHRpb25zLnNlbGVjdDIubXVsdGlwbGU7XG4gICAgICAgIHRoaXMuaXNSZW1vdGUgPSAoJ2FqYXgnIGluIHRoaXMub3B0aW9ucy5zZWxlY3QyKTtcblxuICAgICAgICAvL3N0b3JlIGZ1bmN0aW9uIHJldHVybmluZyBJRCBvZiBpdGVtXG4gICAgICAgIC8vc2hvdWxkIGJlIGhlcmUgYXMgdXNlZCBpbmF1dG90ZXh0IGZvciBsb2NhbCBzb3VyY2VcbiAgICAgICAgdGhpcy5pZEZ1bmMgPSB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5pZDtcbiAgICAgICAgaWYgKHR5cGVvZih0aGlzLmlkRnVuYykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGlkS2V5ID0gdGhpcy5pZEZ1bmMgfHwgJ2lkJztcbiAgICAgICAgICAgIHRoaXMuaWRGdW5jID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGVbaWRLZXldOyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9zdG9yZSBmdW5jdGlvbiB0aGF0IHJlbmRlcnMgdGV4dCBpbiBzZWxlY3QyXG4gICAgICAgIHRoaXMuZm9ybWF0U2VsZWN0aW9uID0gdGhpcy5vcHRpb25zLnNlbGVjdDIuZm9ybWF0U2VsZWN0aW9uO1xuICAgICAgICBpZiAodHlwZW9mKHRoaXMuZm9ybWF0U2VsZWN0aW9uKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRleHQ7IH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoQ29uc3RydWN0b3IsICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTtcblxuICAgICQuZXh0ZW5kKENvbnN0cnVjdG9yLnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuXG4gICAgICAgICAgICAvL2NhbiBub3QgYXBwbHkgc2VsZWN0MiBoZXJlIGFzIGl0IGNhbGxzIGluaXRTZWxlY3Rpb24gXG4gICAgICAgICAgICAvL292ZXIgaW5wdXQgdGhhdCBkb2VzIG5vdCBoYXZlIGNvcnJlY3QgdmFsdWUgeWV0LlxuICAgICAgICAgICAgLy9hcHBseSBzZWxlY3QyIG9ubHkgaW4gdmFsdWUyaW5wdXRcbiAgICAgICAgICAgIC8vdGhpcy4kaW5wdXQuc2VsZWN0Mih0aGlzLm9wdGlvbnMuc2VsZWN0Mik7XG5cbiAgICAgICAgICAgIC8vd2hlbiBkYXRhIGlzIGxvYWRlZCB2aWEgYWpheCwgd2UgbmVlZCB0byBrbm93IHdoZW4gaXQncyBkb25lIHRvIHBvcHVsYXRlIGxpc3REYXRhXG4gICAgICAgICAgICBpZih0aGlzLmlzUmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgLy9saXN0ZW4gdG8gbG9hZGVkIGV2ZW50IHRvIHBvcHVsYXRlIGRhdGFcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5vbignc2VsZWN0Mi1sb2FkZWQnLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gZS5pdGVtcy5yZXN1bHRzO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy90cmlnZ2VyIHJlc2l6ZSBvZiBlZGl0YWJsZWZvcm0gdG8gcmUtcG9zaXRpb24gY29udGFpbmVyIGluIG11bHRpLXZhbHVlZCBtb2RlXG4gICAgICAgICAgICBpZih0aGlzLmlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5wYXJlbnQoKS50cmlnZ2VySGFuZGxlcigncmVzaXplJyk7XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICB9LFxuXG4gICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgdmFyIHRleHQgPSAnJywgZGF0YSxcbiAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5zZWxlY3QyLnRhZ3MpIHsgLy9pbiB0YWdzIG1vZGUganVzdCBhc3NpZ24gdmFsdWVcbiAgICAgICAgICAgICAgZGF0YSA9IHZhbHVlOyBcbiAgICAgICAgICAgICAgLy9kYXRhID0gJC5mbi5lZGl0YWJsZXV0aWxzLml0ZW1zQnlWYWx1ZSh2YWx1ZSwgdGhpcy5vcHRpb25zLnNlbGVjdDIudGFncywgdGhpcy5pZEZ1bmMpO1xuICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5zb3VyY2VEYXRhKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCB0aGlzLnNvdXJjZURhdGEsIHRoaXMuaWRGdW5jKTsgXG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vY2FuIG5vdCBnZXQgbGlzdCBvZiBwb3NzaWJsZSB2YWx1ZXMgXG4gICAgICAgICAgICAgIC8vKGUuZy4gYXV0b3RleHQgZm9yIHNlbGVjdDIgd2l0aCBhamF4IHNvdXJjZSlcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vZGF0YSBtYXkgYmUgYXJyYXkgKHdoZW4gbXVsdGlwbGUgdmFsdWVzIGFsbG93ZWQpXG4gICAgICAgICAgIGlmKCQuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgLy9jb2xsZWN0IHNlbGVjdGVkIGRhdGEgYW5kIHNob3cgd2l0aCBzZXBhcmF0b3JcbiAgICAgICAgICAgICAgIHRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICQuZWFjaChkYXRhLCBmdW5jdGlvbihrLCB2KXtcbiAgICAgICAgICAgICAgICAgICB0ZXh0LnB1c2godiAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgPyB0aGF0LmZvcm1hdFNlbGVjdGlvbih2KSA6IHYpO1xuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgIH0gZWxzZSBpZihkYXRhKSB7XG4gICAgICAgICAgICAgICB0ZXh0ID0gdGhhdC5mb3JtYXRTZWxlY3Rpb24oZGF0YSk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB0ZXh0ID0gJC5pc0FycmF5KHRleHQpID8gdGV4dC5qb2luKHRoaXMub3B0aW9ucy52aWV3c2VwYXJhdG9yKSA6IHRleHQ7XG5cbiAgICAgICAgICAgLy8kKGVsZW1lbnQpLnRleHQodGV4dCk7XG4gICAgICAgICAgIENvbnN0cnVjdG9yLnN1cGVyY2xhc3MudmFsdWUyaHRtbC5jYWxsKHRoaXMsIHRleHQsIGVsZW1lbnQpOyBcbiAgICAgICB9LFxuXG4gICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNlbGVjdDIudGFncyA/IHRoaXMuc3RyMnZhbHVlKGh0bWwsIHRoaXMub3B0aW9ucy52aWV3c2VwYXJhdG9yKSA6IG51bGw7XG4gICAgICAgfSxcblxuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAvLyBpZiB2YWx1ZSBhcnJheSA9PiBqb2luIGl0IGFueXdheVxuICAgICAgICAgICBpZigkLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuam9pbih0aGlzLmdldFNlcGFyYXRvcigpKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vZm9yIHJlbW90ZSBzb3VyY2UganVzdCBzZXQgdmFsdWUsIHRleHQgaXMgdXBkYXRlZCBieSBpbml0U2VsZWN0aW9uXG4gICAgICAgICAgIGlmKCF0aGlzLiRpbnB1dC5kYXRhKCdzZWxlY3QyJykpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LnZhbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zZWxlY3QyKHRoaXMub3B0aW9ucy5zZWxlY3QyKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIC8vc2Vjb25kIGFyZ3VtZW50IG5lZWRlZCB0byBzZXBhcmF0ZSBpbml0aWFsIGNoYW5nZSBmcm9tIHVzZXIncyBjbGljayAoZm9yIGF1dG9zdWJtaXQpICAgXG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwodmFsdWUpLnRyaWdnZXIoJ2NoYW5nZScsIHRydWUpOyBcblxuICAgICAgICAgICAgICAgLy9VbmNhdWdodCBFcnJvcjogY2Fubm90IGNhbGwgdmFsKCkgaWYgaW5pdFNlbGVjdGlvbigpIGlzIG5vdCBkZWZpbmVkXG4gICAgICAgICAgICAgICAvL3RoaXMuJGlucHV0LnNlbGVjdDIoJ3ZhbCcsIHZhbHVlKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vIGlmIGRlZmluZWQgcmVtb3RlIHNvdXJjZSBBTkQgbm8gbXVsdGlwbGUgbW9kZSBBTkQgbm8gdXNlcidzIGluaXRTZWxlY3Rpb24gcHJvdmlkZWQgLS0+IFxuICAgICAgICAgICAvLyB3ZSBzaG91bGQgc29tZWhvdyBnZXQgdGV4dCBmb3IgcHJvdmlkZWQgaWQuXG4gICAgICAgICAgIC8vIFRoZSBzb2x1dGlvbiBpcyB0byB1c2UgZWxlbWVudCdzIHRleHQgYXMgdGV4dCBmb3IgdGhhdCBpZCAoZXhjbHVkZSBlbXB0eSlcbiAgICAgICAgICAgaWYodGhpcy5pc1JlbW90ZSAmJiAhdGhpcy5pc011bHRpcGxlICYmICF0aGlzLm9wdGlvbnMuc2VsZWN0Mi5pbml0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAvLyBjdXN0b21JZCBhbmQgY3VzdG9tVGV4dCBhcmUgbWV0aG9kcyB0byBleHRyYWN0IGBpZGAgYW5kIGB0ZXh0YCBmcm9tIGRhdGEgb2JqZWN0XG4gICAgICAgICAgICAgICAvLyB3ZSBjYW4gdXNlIHRoaXMgd29ya2Fyb3VuZCBvbmx5IGlmIHVzZXIgZGlkIG5vdCBkZWZpbmUgdGhlc2UgbWV0aG9kc1xuICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGNhbnQgY29uc3RydWN0IGRhdGEgb2JqZWN0XG4gICAgICAgICAgICAgICB2YXIgY3VzdG9tSWQgPSB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5pZCxcbiAgICAgICAgICAgICAgICAgICBjdXN0b21UZXh0ID0gdGhpcy5vcHRpb25zLnNlbGVjdDIuZm9ybWF0U2VsZWN0aW9uO1xuXG4gICAgICAgICAgICAgICBpZighY3VzdG9tSWQgJiYgIWN1c3RvbVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgJGVsID0gJCh0aGlzLm9wdGlvbnMuc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgIGlmICghJGVsLmRhdGEoJ2VkaXRhYmxlJykuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtpZDogdmFsdWUsIHRleHQ6ICRlbC50ZXh0KCl9O1xuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zZWxlY3QyKCdkYXRhJywgZGF0YSk7IFxuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LnNlbGVjdDIoJ3ZhbCcpO1xuICAgICAgIH0sXG5cbiAgICAgICBzdHIydmFsdWU6IGZ1bmN0aW9uKHN0ciwgc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBpZih0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyB8fCAhdGhpcy5pc011bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8IHRoaXMuZ2V0U2VwYXJhdG9yKCk7XG5cbiAgICAgICAgICAgIHZhciB2YWwsIGksIGw7XG5cbiAgICAgICAgICAgIGlmIChzdHIgPT09IG51bGwgfHwgc3RyLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbCA9IHN0ci5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB2YWxbaV0gPSAkLnRyaW0odmFsW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICB9LFxuXG4gICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGUsIGlzSW5pdGlhbCl7XG4gICAgICAgICAgICAgICAgaWYoIWlzSW5pdGlhbCkge1xuICAgICAgICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2VwYXJhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5zZXBhcmF0b3IgfHwgJC5mbi5zZWxlY3QyLmRlZmF1bHRzLnNlcGFyYXRvcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICBDb252ZXJ0cyBzb3VyY2UgZnJvbSB4LWVkaXRhYmxlIGZvcm1hdDoge3ZhbHVlOiAxLCB0ZXh0OiBcIjFcIn0gdG9cbiAgICAgICAgc2VsZWN0MiBmb3JtYXQ6IHtpZDogMSwgdGV4dDogXCIxXCJ9XG4gICAgICAgICovXG4gICAgICAgIGNvbnZlcnRTb3VyY2U6IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYoJC5pc0FycmF5KHNvdXJjZSkgJiYgc291cmNlLmxlbmd0aCAmJiBzb3VyY2VbMF0udmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8c291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHNvdXJjZVtpXS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VbaV0uaWQgPSBzb3VyY2VbaV0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc291cmNlW2ldLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYodGhpcy4kaW5wdXQuZGF0YSgnc2VsZWN0MicpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuc2VsZWN0MignZGVzdHJveScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0pO1xuXG4gICAgQ29uc3RydWN0b3IuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEBkZWZhdWx0IDxpbnB1dCB0eXBlPVwiaGlkZGVuXCI+XG4gICAgICAgICoqL1xuICAgICAgICB0cGw6JzxpbnB1dCB0eXBlPVwiaGlkZGVuXCI+JyxcbiAgICAgICAgLyoqXG4gICAgICAgIENvbmZpZ3VyYXRpb24gb2Ygc2VsZWN0Mi4gW0Z1bGwgbGlzdCBvZiBvcHRpb25zXShodHRwOi8vaXZheW5iZXJnLmdpdGh1Yi5jb20vc2VsZWN0MikuXG5cbiAgICAgICAgQHByb3BlcnR5IHNlbGVjdDIgXG4gICAgICAgIEB0eXBlIG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBzZWxlY3QyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgUGxhY2Vob2xkZXIgYXR0cmlidXRlIG9mIHNlbGVjdFxuXG4gICAgICAgIEBwcm9wZXJ0eSBwbGFjZWhvbGRlciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovXG4gICAgICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgU291cmNlIGRhdGEgZm9yIHNlbGVjdC4gSXQgd2lsbCBiZSBhc3NpZ25lZCB0byBzZWxlY3QyIGBkYXRhYCBwcm9wZXJ0eSBhbmQga2VwdCBoZXJlIGp1c3QgZm9yIGNvbnZlbmllbmNlLlxuICAgICAgICBQbGVhc2Ugbm90ZSwgdGhhdCBmb3JtYXQgaXMgZGlmZmVyZW50IGZyb20gc2ltcGxlIGBzZWxlY3RgIGlucHV0OiB1c2UgJ2lkJyBpbnN0ZWFkIG9mICd2YWx1ZScuXG4gICAgICAgIEUuZy4gYFt7aWQ6IDEsIHRleHQ6IFwidGV4dDFcIn0sIHtpZDogMiwgdGV4dDogXCJ0ZXh0MlwifSwgLi4uXWAuXG5cbiAgICAgICAgQHByb3BlcnR5IHNvdXJjZSBcbiAgICAgICAgQHR5cGUgYXJyYXl8c3RyaW5nfGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGwgICAgICAgIFxuICAgICAgICAqKi9cbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgU2VwYXJhdG9yIHVzZWQgdG8gZGlzcGxheSB0YWdzLlxuXG4gICAgICAgIEBwcm9wZXJ0eSB2aWV3c2VwYXJhdG9yIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJywgJyAgICAgICAgXG4gICAgICAgICoqL1xuICAgICAgICB2aWV3c2VwYXJhdG9yOiAnLCAnXG4gICAgfSk7XG5cbiAgICAkLmZuLmVkaXRhYmxldHlwZXMuc2VsZWN0MiA9IENvbnN0cnVjdG9yO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG4qIENvbWJvZGF0ZSAtIDEuMC41XG4qIERyb3Bkb3duIGRhdGUgYW5kIHRpbWUgcGlja2VyLlxuKiBDb252ZXJ0cyB0ZXh0IGlucHV0IGludG8gZHJvcGRvd25zIHRvIHBpY2sgZGF5LCBtb250aCwgeWVhciwgaG91ciwgbWludXRlIGFuZCBzZWNvbmQuXG4qIFVzZXMgbW9tZW50anMgYXMgZGF0ZXRpbWUgbGlicmFyeSBodHRwOi8vbW9tZW50anMuY29tLlxuKiBGb3IgaTE4biBpbmNsdWRlIGNvcnJlc3BvbmRpbmcgZmlsZSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1yd29vZC9tb21lbnQvdHJlZS9tYXN0ZXIvbGFuZyBcbipcbiogQ29uZnVzaW9uIGF0IG5vb24gYW5kIG1pZG5pZ2h0IC0gc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvMTItaG91cl9jbG9jayNDb25mdXNpb25fYXRfbm9vbl9hbmRfbWlkbmlnaHRcbiogSW4gY29tYm9kYXRlOiBcbiogMTI6MDAgcG0gLS0+IDEyOjAwICgyNC1oIGZvcm1hdCwgbWlkZGF5KVxuKiAxMjowMCBhbSAtLT4gMDA6MDAgKDI0LWggZm9ybWF0LCBtaWRuaWdodCwgc3RhcnQgb2YgZGF5KVxuKiBcbiogRGlmZmVycyBmcm9tIG1vbWVudGpzIHBhcnNlIHJ1bGVzOlxuKiAwMDowMCBwbSwgMTI6MDAgcG0gLS0+IDEyOjAwICgyNC1oIGZvcm1hdCwgZGF5IG5vdCBjaGFuZ2UpXG4qIDAwOjAwIGFtLCAxMjowMCBhbSAtLT4gMDA6MDAgKDI0LWggZm9ybWF0LCBkYXkgbm90IGNoYW5nZSlcbiogXG4qIFxuKiBBdXRob3I6IFZpdGFsaXkgUG90YXBvdlxuKiBQcm9qZWN0IHBhZ2U6IGh0dHA6Ly9naXRodWIuY29tL3ZpdGFsZXRzL2NvbWJvZGF0ZVxuKiBDb3B5cmlnaHQgKGMpIDIwMTIgVml0YWxpeSBQb3RhcG92LiBSZWxlYXNlZCB1bmRlciBNSVQgTGljZW5zZS5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG5cbiAgICB2YXIgQ29tYm9kYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgIGlmKCF0aGlzLiRlbGVtZW50LmlzKCdpbnB1dCcpKSB7XG4gICAgICAgICAgICAkLmVycm9yKCdDb21ib2RhdGUgc2hvdWxkIGJlIGFwcGxpZWQgdG8gSU5QVVQgZWxlbWVudCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmNvbWJvZGF0ZS5kZWZhdWx0cywgb3B0aW9ucywgdGhpcy4kZWxlbWVudC5kYXRhKCkpO1xuICAgICAgICB0aGlzLmluaXQoKTsgIFxuICAgICB9O1xuXG4gICAgQ29tYm9kYXRlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IENvbWJvZGF0ZSwgXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0ge1xuICAgICAgICAgICAgICAgIC8va2V5ICAgcmVnZXhwICAgIG1vbWVudC5tZXRob2RcbiAgICAgICAgICAgICAgICBkYXk6ICAgIFsnRCcsICAgICdkYXRlJ10sIFxuICAgICAgICAgICAgICAgIG1vbnRoOiAgWydNJywgICAgJ21vbnRoJ10sIFxuICAgICAgICAgICAgICAgIHllYXI6ICAgWydZJywgICAgJ3llYXInXSwgXG4gICAgICAgICAgICAgICAgaG91cjogICBbJ1tIaF0nLCAnaG91cnMnXSxcbiAgICAgICAgICAgICAgICBtaW51dGU6IFsnbScsICAgICdtaW51dGVzJ10sIFxuICAgICAgICAgICAgICAgIHNlY29uZDogWydzJywgICAgJ3NlY29uZHMnXSxcbiAgICAgICAgICAgICAgICBhbXBtOiAgIFsnW0FhXScsICcnXSBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJHdpZGdldCA9ICQoJzxzcGFuIGNsYXNzPVwiY29tYm9kYXRlXCI+PC9zcGFuPicpLmh0bWwodGhpcy5nZXRUZW1wbGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaW5pdENvbWJvcygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3VwZGF0ZSBvcmlnaW5hbCBpbnB1dCBvbiBjaGFuZ2UgXG4gICAgICAgICAgICB0aGlzLiR3aWRnZXQub24oJ2NoYW5nZScsICdzZWxlY3QnLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnZhbCh0aGlzLmdldFZhbHVlKCkpLmNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBkYXlzIGNvdW50IGlmIG1vbnRoIG9yIHllYXIgY2hhbmdlc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnREYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcygnLm1vbnRoJykgfHwgJChlLnRhcmdldCkuaXMoJy55ZWFyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsbENvbWJvKCdkYXknKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kd2lkZ2V0LmZpbmQoJ3NlbGVjdCcpLmNzcygnd2lkdGgnLCAnYXV0bycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBoaWRlIG9yaWdpbmFsIGlucHV0IGFuZCBpbnNlcnQgd2lkZ2V0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmhpZGUoKS5hZnRlcih0aGlzLiR3aWRnZXQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLiRlbGVtZW50LnZhbCgpIHx8IHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAgUmVwbGFjZSB0b2tlbnMgaW4gdGVtcGxhdGUgd2l0aCA8c2VsZWN0PiBlbGVtZW50cyBcbiAgICAgICAgKi8gICAgICAgICBcbiAgICAgICAgZ2V0VGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRwbCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZTtcblxuICAgICAgICAgICAgLy9maXJzdCBwYXNzXG4gICAgICAgICAgICAkLmVhY2godGhpcy5tYXAsIGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgICAgICAgICB2ID0gdlswXTsgXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBuZXcgUmVnRXhwKHYrJysnKSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB2Lmxlbmd0aCA+IDEgPyB2LnN1YnN0cmluZygxLCAyKSA6IHY7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKHIsICd7Jyt0b2tlbisnfScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vcmVwbGFjZSBzcGFjZXMgd2l0aCAmbmJzcDtcbiAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKC8gL2csICcmbmJzcDsnKTtcblxuICAgICAgICAgICAgLy9zZWNvbmQgcGFzc1xuICAgICAgICAgICAgJC5lYWNoKHRoaXMubWFwLCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgICAgICAgdiA9IHZbMF07XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdi5sZW5ndGggPiAxID8gdi5zdWJzdHJpbmcoMSwgMikgOiB2O1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0cGwgPSB0cGwucmVwbGFjZSgneycrdG9rZW4rJ30nLCAnPHNlbGVjdCBjbGFzcz1cIicraysnXCI+PC9zZWxlY3Q+Jyk7XG4gICAgICAgICAgICB9KTsgICBcblxuICAgICAgICAgICAgcmV0dXJuIHRwbDtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICBJbml0aWFsaXplIGNvbWJvcyB0aGF0IHByZXNlbnRzIGluIHRlbXBsYXRlIFxuICAgICAgICAqLyAgICAgICAgXG4gICAgICAgIGluaXRDb21ib3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgICAgIHZhciAkYyA9IHRoaXMuJHdpZGdldC5maW5kKCcuJytrKTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgcHJvcGVydGllcyBsaWtlIHRoaXMuJGRheSwgdGhpcy4kbW9udGggZXRjLlxuICAgICAgICAgICAgICAgIHRoaXNbJyQnK2tdID0gJGMubGVuZ3RoID8gJGMgOiBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGZpbGwgd2l0aCBpdGVtc1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsbENvbWJvKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICBGaWxsIGNvbWJvIHdpdGggaXRlbXMgXG4gICAgICAgICovICAgICAgICBcbiAgICAgICAgZmlsbENvbWJvOiBmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICB2YXIgJGNvbWJvID0gdGhpc1snJCcra107XG4gICAgICAgICAgICBpZiAoISRjb21ibykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGVmaW5lIG1ldGhvZCBuYW1lIHRvIGZpbGwgaXRlbXMsIGUuZyBgZmlsbERheXNgXG4gICAgICAgICAgICB2YXIgZiA9ICdmaWxsJyArIGsuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrLnNsaWNlKDEpOyBcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXNbZl0oKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICRjb21iby52YWwoKTtcblxuICAgICAgICAgICAgJGNvbWJvLmVtcHR5KCk7XG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICRjb21iby5hcHBlbmQoJzxvcHRpb24gdmFsdWU9XCInK2l0ZW1zW2ldWzBdKydcIj4nK2l0ZW1zW2ldWzFdKyc8L29wdGlvbj4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGNvbWJvLnZhbCh2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgIEluaXRpYWxpemUgaXRlbXMgb2YgY29tYm9zLiBIYW5kbGVzIGBmaXJzdEl0ZW1gIG9wdGlvbiBcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbENvbW1vbjogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW10sXG4gICAgICAgICAgICAgICAgcmVsVGltZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5maXJzdEl0ZW0gPT09ICduYW1lJykge1xuICAgICAgICAgICAgICAgIC8vbmVlZCBib3RoIHRvIHN1cHBvcnQgbW9tZW50IHZlciA8IDIgYW5kICA+PSAyXG4gICAgICAgICAgICAgICAgcmVsVGltZSA9IG1vbWVudC5yZWxhdGl2ZVRpbWUgfHwgbW9tZW50LmxhbmdEYXRhKCkuX3JlbGF0aXZlVGltZTsgXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IHR5cGVvZiByZWxUaW1lW2tleV0gPT09ICdmdW5jdGlvbicgPyByZWxUaW1lW2tleV0oMSwgdHJ1ZSwga2V5LCBmYWxzZSkgOiByZWxUaW1lW2tleV07XG4gICAgICAgICAgICAgICAgLy90YWtlIGxhc3QgZW50cnkgKHNlZSBtb21lbnRqcyBsYW5nIGZpbGVzIHN0cnVjdHVyZSkgXG4gICAgICAgICAgICAgICAgaGVhZGVyID0gaGVhZGVyLnNwbGl0KCcgJykucmV2ZXJzZSgpWzBdOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChbJycsIGhlYWRlcl0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMub3B0aW9ucy5maXJzdEl0ZW0gPT09ICdlbXB0eScpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChbJycsICcnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9LCAgXG5cblxuICAgICAgICAvKlxuICAgICAgICBmaWxsIGRheVxuICAgICAgICAqL1xuICAgICAgICBmaWxsRGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXMuZmlsbENvbW1vbignZCcpLCBuYW1lLCBpLFxuICAgICAgICAgICAgICAgIHR3b0RpZ2l0ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ0REJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIGRheXNDb3VudCA9IDMxO1xuXG4gICAgICAgICAgICAvLyBkZXRlY3QgZGF5cyBjb3VudCAoZGVwZW5kcyBvbiBtb250aCBhbmQgeWVhcilcbiAgICAgICAgICAgIC8vIG9yaWdpbmFsbHkgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGFsZXRzL2NvbWJvZGF0ZS9wdWxsLzdcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnREYXlzICYmIHRoaXMuJG1vbnRoICYmIHRoaXMuJHllYXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGggPSBwYXJzZUludCh0aGlzLiRtb250aC52YWwoKSwgMTApO1xuICAgICAgICAgICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQodGhpcy4keWVhci52YWwoKSwgMTApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihtb250aCkgJiYgIWlzTmFOKHllYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRheXNDb3VudCA9IG1vbWVudChbeWVhciwgbW9udGhdKS5kYXlzSW5Nb250aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBkYXlzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0d29EaWdpdCA/IHRoaXMubGVhZFplcm8oaSkgOiBpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtczsgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBtb250aFxuICAgICAgICAqL1xuICAgICAgICBmaWxsTW9udGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5maWxsQ29tbW9uKCdNJyksIG5hbWUsIGksIFxuICAgICAgICAgICAgICAgIGxvbmdOYW1lcyA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdNTU1NJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIHNob3J0TmFtZXMgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUuaW5kZXhPZignTU1NJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIHR3b0RpZ2l0ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ01NJykgIT09IC0xO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKGk9MDsgaTw9MTE7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmKGxvbmdOYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAvL3NlZSBodHRwczovL2dpdGh1Yi5jb20vdGltcndvb2QvbW9tZW50anMuY29tL3B1bGwvMzZcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG1vbWVudCgpLmRhdGUoMSkubW9udGgoaSkuZm9ybWF0KCdNTU1NJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHNob3J0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG1vbWVudCgpLmRhdGUoMSkubW9udGgoaSkuZm9ybWF0KCdNTU0nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodHdvRGlnaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMubGVhZFplcm8oaSsxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gaSsxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKFtpLCBuYW1lXSk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBmaWxsIHllYXJcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbFllYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gW10sIG5hbWUsIGksIFxuICAgICAgICAgICAgICAgIGxvbmdOYW1lcyA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdZWVlZJykgIT09IC0xO1xuICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcihpPXRoaXMub3B0aW9ucy5tYXhZZWFyOyBpPj10aGlzLm9wdGlvbnMubWluWWVhcjsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGxvbmdOYW1lcyA/IGkgOiAoaSsnJykuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgICAgIGl0ZW1zW3RoaXMub3B0aW9ucy55ZWFyRGVzY2VuZGluZyA/ICdwdXNoJyA6ICd1bnNoaWZ0J10oW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaXRlbXMgPSB0aGlzLmZpbGxDb21tb24oJ3knKS5jb25jYXQoaXRlbXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7ICAgICAgICAgICAgICBcbiAgICAgICAgfSwgICAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBmaWxsIGhvdXJcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbEhvdXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5maWxsQ29tbW9uKCdoJyksIG5hbWUsIGksXG4gICAgICAgICAgICAgICAgaDEyID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ2gnKSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgaDI0ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ0gnKSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgdHdvRGlnaXQgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdoaCcpICE9PSAtMSxcbiAgICAgICAgICAgICAgICBtaW4gPSBoMTIgPyAxIDogMCwgXG4gICAgICAgICAgICAgICAgbWF4ID0gaDEyID8gMTIgOiAyMztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcihpPW1pbjsgaTw9bWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gdHdvRGlnaXQgPyB0aGlzLmxlYWRaZXJvKGkpIDogaTtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKFtpLCBuYW1lXSk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zOyAgICAgICAgICAgICAgICAgXG4gICAgICAgIH0sICAgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBtaW51dGVcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbE1pbnV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmZpbGxDb21tb24oJ20nKSwgbmFtZSwgaSxcbiAgICAgICAgICAgICAgICB0d29EaWdpdCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdtbScpICE9PSAtMTtcblxuICAgICAgICAgICAgZm9yKGk9MDsgaTw9NTk7IGkrPSB0aGlzLm9wdGlvbnMubWludXRlU3RlcCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0d29EaWdpdCA/IHRoaXMubGVhZFplcm8oaSkgOiBpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7ICAgICAgICAgICAgICBcbiAgICAgICAgfSwgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBzZWNvbmRcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbFNlY29uZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmZpbGxDb21tb24oJ3MnKSwgbmFtZSwgaSxcbiAgICAgICAgICAgICAgICB0d29EaWdpdCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdzcycpICE9PSAtMTtcblxuICAgICAgICAgICAgZm9yKGk9MDsgaTw9NTk7IGkrPSB0aGlzLm9wdGlvbnMuc2Vjb25kU3RlcCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0d29EaWdpdCA/IHRoaXMubGVhZFplcm8oaSkgOiBpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7ICAgICAgICAgICAgICBcbiAgICAgICAgfSwgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBhbXBtXG4gICAgICAgICovXG4gICAgICAgIGZpbGxBbXBtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhbXBtTCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdhJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIGFtcG1VID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ0EnKSAhPT0gLTEsICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaXRlbXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIFsnYW0nLCBhbXBtTCA/ICdhbScgOiAnQU0nXSxcbiAgICAgICAgICAgICAgICAgICAgWydwbScsIGFtcG1MID8gJ3BtJyA6ICdQTSddXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAvKlxuICAgICAgICAgUmV0dXJucyBjdXJyZW50IGRhdGUgdmFsdWUgZnJvbSBjb21ib3MuIFxuICAgICAgICAgSWYgZm9ybWF0IG5vdCBzcGVjaWZpZWQgLSBgb3B0aW9ucy5mb3JtYXRgIHVzZWQuXG4gICAgICAgICBJZiBmb3JtYXQgPSBgbnVsbGAgLSBNb21lbnQgb2JqZWN0IHJldHVybmVkLlxuICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgICAgICB2YXIgZHQsIHZhbHVlcyA9IHt9LCBcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBub3RTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9nZXR0aW5nIHNlbGVjdGVkIHZhbHVlcyAgICBcbiAgICAgICAgICAgICQuZWFjaCh0aGlzLm1hcCwgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgICAgIGlmKGsgPT09ICdhbXBtJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZWYgPSBrID09PSAnZGF5JyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFsdWVzW2tdID0gdGhhdFsnJCcra10gPyBwYXJzZUludCh0aGF0WyckJytrXS52YWwoKSwgMTApIDogZGVmOyBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihpc05hTih2YWx1ZXNba10pKSB7XG4gICAgICAgICAgICAgICAgICAgbm90U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgYXQgbGVhc3Qgb25lIHZpc2libGUgY29tYm8gbm90IHNlbGVjdGVkIC0gcmV0dXJuIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgaWYobm90U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jb252ZXJ0IGhvdXJzIDEyaCAtLT4gMjRoIFxuICAgICAgICAgICAgaWYodGhpcy4kYW1wbSkge1xuICAgICAgICAgICAgICAgIC8vMTI6MDAgcG0gLS0+IDEyOjAwICgyNC1oIGZvcm1hdCwgbWlkZGF5KSwgMTI6MDAgYW0gLS0+IDAwOjAwICgyNC1oIGZvcm1hdCwgbWlkbmlnaHQsIHN0YXJ0IG9mIGRheSlcbiAgICAgICAgICAgICAgICBpZih2YWx1ZXMuaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmhvdXIgPSB0aGlzLiRhbXBtLnZhbCgpID09PSAnYW0nID8gMCA6IDEyOyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmhvdXIgPSB0aGlzLiRhbXBtLnZhbCgpID09PSAnYW0nID8gdmFsdWVzLmhvdXIgOiB2YWx1ZXMuaG91cisxMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBkdCA9IG1vbWVudChbdmFsdWVzLnllYXIsIHZhbHVlcy5tb250aCwgdmFsdWVzLmRheSwgdmFsdWVzLmhvdXIsIHZhbHVlcy5taW51dGUsIHZhbHVlcy5zZWNvbmRdKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9oaWdobGlnaHQgaW52YWxpZCBkYXRlXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodChkdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmZvcm1hdCA6IGZvcm1hdDtcbiAgICAgICAgICAgIGlmKGZvcm1hdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgcmV0dXJuIGR0LmlzVmFsaWQoKSA/IGR0IDogbnVsbDsgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgcmV0dXJuIGR0LmlzVmFsaWQoKSA/IGR0LmZvcm1hdChmb3JtYXQpIDogJyc7IFxuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGR0ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IG1vbWVudCh2YWx1ZSwgdGhpcy5vcHRpb25zLmZvcm1hdCkgOiBtb21lbnQodmFsdWUpLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2Z1bmN0aW9uIHRvIGZpbmQgbmVhcmVzdCB2YWx1ZSBpbiBzZWxlY3Qgb3B0aW9uc1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TmVhcmVzdCgkc2VsZWN0LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IHt9O1xuICAgICAgICAgICAgICAgICRzZWxlY3QuY2hpbGRyZW4oJ29wdGlvbicpLmVhY2goZnVuY3Rpb24oaSwgb3B0KXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdFZhbHVlID0gJChvcHQpLmF0dHIoJ3ZhbHVlJyksXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdFZhbHVlID09PSAnJykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKG9wdFZhbHVlIC0gdmFsdWUpOyBcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGRlbHRhLmRpc3RhbmNlID09PSAndW5kZWZpbmVkJyB8fCBkaXN0YW5jZSA8IGRlbHRhLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IHt2YWx1ZTogb3B0VmFsdWUsIGRpc3RhbmNlOiBkaXN0YW5jZX07XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgfSk7IFxuICAgICAgICAgICAgICAgIHJldHVybiBkZWx0YS52YWx1ZTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGR0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIC8vcmVhZCB2YWx1ZXMgZnJvbSBkYXRlIG9iamVjdFxuICAgICAgICAgICAgICAgICQuZWFjaCh0aGlzLm1hcCwgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgICAgICAgICBpZihrID09PSAnYW1wbScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba10gPSBkdFt2WzFdXSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodGhpcy4kYW1wbSkge1xuICAgICAgICAgICAgICAgICAgICAvLzEyOjAwIHBtIC0tPiAxMjowMCAoMjQtaCBmb3JtYXQsIG1pZGRheSksIDEyOjAwIGFtIC0tPiAwMDowMCAoMjQtaCBmb3JtYXQsIG1pZG5pZ2h0LCBzdGFydCBvZiBkYXkpXG4gICAgICAgICAgICAgICAgICAgIGlmKHZhbHVlcy5ob3VyID49IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuYW1wbSA9ICdwbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZXMuaG91ciA+IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmhvdXIgLT0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuYW1wbSA9ICdhbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZXMuaG91ciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5ob3VyID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJC5lYWNoKHZhbHVlcywgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgICAgICAgICAvL2NhbGwgdmFsKCkgZm9yIGVhY2ggZXhpc3RpbmcgY29tYm8sIGUuZy4gdGhpcy4kaG91ci52YWwoKVxuICAgICAgICAgICAgICAgICAgICBpZih0aGF0WyckJytrXSkge1xuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGsgPT09ICdtaW51dGUnICYmIHRoYXQub3B0aW9ucy5taW51dGVTdGVwID4gMSAmJiB0aGF0Lm9wdGlvbnMucm91bmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2V0TmVhcmVzdCh0aGF0WyckJytrXSwgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoayA9PT0gJ3NlY29uZCcgJiYgdGhhdC5vcHRpb25zLnNlY29uZFN0ZXAgPiAxICYmIHRoYXQub3B0aW9ucy5yb3VuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnZXROZWFyZXN0KHRoYXRbJyQnK2tdLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXRbJyQnK2tdLnZhbCh2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGRheXMgY291bnRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNtYXJ0RGF5cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGxDb21ibygnZGF5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnZhbChkdC5mb3JtYXQodGhpcy5vcHRpb25zLmZvcm1hdCkpLmNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgIGhpZ2hsaWdodCBjb21ib3MgaWYgZGF0ZSBpcyBpbnZhbGlkXG4gICAgICAgICovXG4gICAgICAgIGhpZ2hsaWdodDogZnVuY3Rpb24oZHQpIHtcbiAgICAgICAgICAgIGlmKCFkdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR3aWRnZXQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vc3RvcmUgb3JpZ2luYWwgYm9yZGVyIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gdGhpcy4kd2lkZ2V0LmZpbmQoJ3NlbGVjdCcpLmNzcygnYm9yZGVyLWNvbG9yJyk7IFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHdpZGdldC5maW5kKCdzZWxlY3QnKS5jc3MoJ2JvcmRlci1jb2xvcicsICdyZWQnKTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR3aWRnZXQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHdpZGdldC5maW5kKCdzZWxlY3QnKS5jc3MoJ2JvcmRlci1jb2xvcicsIHRoaXMuYm9yZGVyQ29sb3IpO1xuICAgICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgbGVhZFplcm86IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2IDw9IDkgPyAnMCcgKyB2IDogdjsgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJHdpZGdldC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnY29tYm9kYXRlJykuc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL3RvZG86IGNsZWFyIG1ldGhvZCAgICAgICAgXG4gICAgfTtcblxuICAgICQuZm4uY29tYm9kYXRlID0gZnVuY3Rpb24gKCBvcHRpb24gKSB7XG4gICAgICAgIHZhciBkLCBhcmdzID0gQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgYXJncy5zaGlmdCgpO1xuXG4gICAgICAgIC8vZ2V0VmFsdWUgcmV0dXJucyBkYXRlIGFzIHN0cmluZyAvIG9iamVjdCAobm90IGpRdWVyeSBvYmplY3QpXG4gICAgICAgIGlmKG9wdGlvbiA9PT0gJ2dldFZhbHVlJyAmJiB0aGlzLmxlbmd0aCAmJiAoZCA9IHRoaXMuZXEoMCkuZGF0YSgnY29tYm9kYXRlJykpKSB7XG4gICAgICAgICAgcmV0dXJuIGQuZ2V0VmFsdWUuYXBwbHkoZCwgYXJncyk7XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgZGF0YSA9ICR0aGlzLmRhdGEoJ2NvbWJvZGF0ZScpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uO1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnY29tYm9kYXRlJywgKGRhdGEgPSBuZXcgQ29tYm9kYXRlKHRoaXMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGF0YVtvcHRpb25dID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkYXRhW29wdGlvbl0uYXBwbHkoZGF0YSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07ICBcbiAgICBcbiAgICAkLmZuLmNvbWJvZGF0ZS5kZWZhdWx0cyA9IHtcbiAgICAgICAgIC8vaW4gdGhpcyBmb3JtYXQgdmFsdWUgc3RvcmVkIGluIG9yaWdpbmFsIGlucHV0XG4gICAgICAgIGZvcm1hdDogJ0RELU1NLVlZWVkgSEg6bW0nLCAgICAgIFxuICAgICAgICAvL2luIHRoaXMgZm9ybWF0IGl0ZW1zIGluIGRyb3Bkb3ducyBhcmUgZGlzcGxheWVkXG4gICAgICAgIHRlbXBsYXRlOiAnRCAvIE1NTSAvIFlZWVkgICBIIDogbW0nLFxuICAgICAgICAvL2luaXRpYWwgdmFsdWUsIGNhbiBiZSBgbmV3IERhdGUoKWAgICAgXG4gICAgICAgIHZhbHVlOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIG1pblllYXI6IDE5NzAsXG4gICAgICAgIG1heFllYXI6IDIwMTUsXG4gICAgICAgIHllYXJEZXNjZW5kaW5nOiB0cnVlLFxuICAgICAgICBtaW51dGVTdGVwOiA1LFxuICAgICAgICBzZWNvbmRTdGVwOiAxLFxuICAgICAgICBmaXJzdEl0ZW06ICdlbXB0eScsIC8vJ25hbWUnLCAnZW1wdHknLCAnbm9uZSdcbiAgICAgICAgZXJyb3JDbGFzczogbnVsbCxcbiAgICAgICAgcm91bmRUaW1lOiB0cnVlLCAvLyB3aGV0aGVyIHRvIHJvdW5kIG1pbnV0ZXMgYW5kIHNlY29uZHMgaWYgc3RlcCA+IDFcbiAgICAgICAgc21hcnREYXlzOiBmYWxzZSAvLyB3aGV0aGVyIGRheXMgaW4gY29tYm8gZGVwZW5kIG9uIHNlbGVjdGVkIG1vbnRoOiAzMSwgMzAsIDI4XG4gICAgfTtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG4vKipcbkNvbWJvZGF0ZSBpbnB1dCAtIGRyb3Bkb3duIGRhdGUgYW5kIHRpbWUgcGlja2VyLiAgICBcbkJhc2VkIG9uIFtjb21ib2RhdGVdKGh0dHA6Ly92aXRhbGV0cy5naXRodWIuY29tL2NvbWJvZGF0ZSkgcGx1Z2luIChpbmNsdWRlZCkuIFRvIHVzZSBpdCB5b3Ugc2hvdWxkIG1hbnVhbGx5IGluY2x1ZGUgW21vbWVudGpzXShodHRwOi8vbW9tZW50anMuY29tKS5cblxuICAgIDxzY3JpcHQgc3JjPVwianMvbW9tZW50Lm1pbi5qc1wiPjwvc2NyaXB0PlxuICAgXG5BbGxvd3MgdG8gaW5wdXQ6XG5cbiogb25seSBkYXRlXG4qIG9ubHkgdGltZSBcbiogYm90aCBkYXRlIGFuZCB0aW1lICBcblxuUGxlYXNlIG5vdGUsIHRoYXQgZm9ybWF0IGlzIHRha2VuIGZyb20gbW9tZW50anMgYW5kICoqbm90IGNvbXBhdGlibGUqKiB3aXRoIGJvb3RzdHJhcC1kYXRlcGlja2VyIC8ganF1ZXJ5IFVJIGRhdGVwaWNrZXIuICBcbkludGVybmFsbHkgdmFsdWUgc3RvcmVkIGFzIGBtb21lbnRqc2Agb2JqZWN0LiBcblxuQGNsYXNzIGNvbWJvZGF0ZVxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQGZpbmFsXG5Ac2luY2UgMS40LjBcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwiZG9iXCIgZGF0YS10eXBlPVwiY29tYm9kYXRlXCIgZGF0YS1waz1cIjFcIiBkYXRhLXVybD1cIi9wb3N0XCIgZGF0YS12YWx1ZT1cIjE5ODQtMDUtMTVcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IGRhdGVcIj48L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNkb2InKS5lZGl0YWJsZSh7XG4gICAgICAgIGZvcm1hdDogJ1lZWVktTU0tREQnLCAgICBcbiAgICAgICAgdmlld2Zvcm1hdDogJ0RELk1NLllZWVknLCAgICBcbiAgICAgICAgdGVtcGxhdGU6ICdEIC8gTU1NTSAvIFlZWVknLCAgICBcbiAgICAgICAgY29tYm9kYXRlOiB7XG4gICAgICAgICAgICAgICAgbWluWWVhcjogMjAwMCxcbiAgICAgICAgICAgICAgICBtYXhZZWFyOiAyMDE1LFxuICAgICAgICAgICAgICAgIG1pbnV0ZVN0ZXA6IDFcbiAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG5cbi8qZ2xvYmFsIG1vbWVudCovXG5cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2NvbWJvZGF0ZScsIG9wdGlvbnMsIENvbnN0cnVjdG9yLmRlZmF1bHRzKTtcbiAgICAgICAgXG4gICAgICAgIC8vYnkgZGVmYXVsdCB2aWV3Zm9ybWF0IGVxdWFscyB0byBmb3JtYXRcbiAgICAgICAgaWYoIXRoaXMub3B0aW9ucy52aWV3Zm9ybWF0KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCA9IHRoaXMub3B0aW9ucy5mb3JtYXQ7XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy90cnkgcGFyc2UgY29tYm9kYXRlIGNvbmZpZyBkZWZpbmVkIGFzIGpzb24gc3RyaW5nIGluIGRhdGEtY29tYm9kYXRlXG4gICAgICAgIG9wdGlvbnMuY29tYm9kYXRlID0gJC5mbi5lZGl0YWJsZXV0aWxzLnRyeVBhcnNlSnNvbihvcHRpb25zLmNvbWJvZGF0ZSwgdHJ1ZSk7XG5cbiAgICAgICAgLy9vdmVycmlkaW5nIGNvbWJvZGF0ZSBjb25maWcgKGFzIGJ5IGRlZmF1bHQgalF1ZXJ5IGV4dGVuZCgpIGlzIG5vdCByZWN1cnNpdmUpXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb21ib2RhdGUgPSAkLmV4dGVuZCh7fSwgQ29uc3RydWN0b3IuZGVmYXVsdHMuY29tYm9kYXRlLCBvcHRpb25zLmNvbWJvZGF0ZSwge1xuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLm9wdGlvbnMuZm9ybWF0LFxuICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMub3B0aW9ucy50ZW1wbGF0ZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoQ29uc3RydWN0b3IsICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTsgICAgXG4gICAgXG4gICAgJC5leHRlbmQoQ29uc3RydWN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuY29tYm9kYXRlKHRoaXMub3B0aW9ucy5jb21ib2RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCQuZm4uZWRpdGFibGVmb3JtLmVuZ2luZSA9PT0gJ2JzMycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zaWJsaW5ncygpLmZpbmQoJ3NlbGVjdCcpLmFkZENsYXNzKCdmb3JtLWNvbnRyb2wnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmlucHV0Y2xhc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zaWJsaW5ncygpLmZpbmQoJ3NlbGVjdCcpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5pbnB1dGNsYXNzKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vXCJjbGVhclwiIGxpbmtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuY2xlYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjbGVhciA9ICQoJzxhIGhyZWY9XCIjXCI+PC9hPicpLmh0bWwodGhpcy5vcHRpb25zLmNsZWFyKS5jbGljaygkLnByb3h5KGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy4kdHBsLnBhcmVudCgpLmFwcGVuZCgkKCc8ZGl2IGNsYXNzPVwiZWRpdGFibGUtY2xlYXJcIj4nKS5hcHBlbmQodGhpcy4kY2xlYXIpKTsgIFxuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICovICAgICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICB2YWx1ZTJodG1sOiBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSB2YWx1ZSA/IHZhbHVlLmZvcm1hdCh0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCkgOiAnJztcbiAgICAgICAgICAgIC8vJChlbGVtZW50KS50ZXh0KHRleHQpO1xuICAgICAgICAgICAgQ29uc3RydWN0b3Iuc3VwZXJjbGFzcy52YWx1ZTJodG1sLmNhbGwodGhpcywgdGV4dCwgZWxlbWVudCk7ICBcbiAgICAgICAgfSxcblxuICAgICAgICBodG1sMnZhbHVlOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbCA/IG1vbWVudChodG1sLCB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCkgOiBudWxsO1xuICAgICAgICB9LCAgIFxuICAgICAgICBcbiAgICAgICAgdmFsdWUyc3RyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdmFsdWUuZm9ybWF0KHRoaXMub3B0aW9ucy5mb3JtYXQpIDogJyc7XG4gICAgICAgfSwgXG4gICAgICAgXG4gICAgICAgc3RyMnZhbHVlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgcmV0dXJuIHN0ciA/IG1vbWVudChzdHIsIHRoaXMub3B0aW9ucy5mb3JtYXQpIDogbnVsbDtcbiAgICAgICB9LCBcbiAgICAgICBcbiAgICAgICB2YWx1ZTJzdWJtaXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlMnN0cih2YWx1ZSk7XG4gICAgICAgfSwgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgdmFsdWUyaW5wdXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHRoaXMuJGlucHV0LmNvbWJvZGF0ZSgnc2V0VmFsdWUnLCB2YWx1ZSk7XG4gICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LmNvbWJvZGF0ZSgnZ2V0VmFsdWUnLCBudWxsKTtcbiAgICAgICB9LCAgICAgICBcbiAgICAgICBcbiAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMuJGlucHV0LnNpYmxpbmdzKCcuY29tYm9kYXRlJykuZmluZCgnc2VsZWN0JykuZXEoMCkuZm9jdXMoKTtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgY2xlYXI6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLiRpbnB1dC5kYXRhKCdkYXRlcGlja2VyJykuZGF0ZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy4kaW5wdXQuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICB9LFxuICAgICAgICovXG4gICAgICAgXG4gICAgICAgYXV0b3N1Ym1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIFxuICAgICAgIH1cblxuICAgIH0pO1xuICAgIFxuICAgIENvbnN0cnVjdG9yLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICBAZGVmYXVsdCA8aW5wdXQgdHlwZT1cInRleHRcIj5cbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHRwbDonPGlucHV0IHR5cGU9XCJ0ZXh0XCI+JyxcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBpbnB1dGNsYXNzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgRm9ybWF0IHVzZWQgZm9yIHNlbmRpbmcgdmFsdWUgdG8gc2VydmVyLiBBbHNvIGFwcGxpZWQgd2hlbiBjb252ZXJ0aW5nIGRhdGUgZnJvbSA8Y29kZT5kYXRhLXZhbHVlPC9jb2RlPiBhdHRyaWJ1dGUuPGJyPlxuICAgICAgICBTZWUgbGlzdCBvZiB0b2tlbnMgaW4gW21vbWVudGpzIGRvY3NdKGh0dHA6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3BhcnNpbmcvc3RyaW5nLWZvcm1hdCkgIFxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IGZvcm1hdCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IFlZWVktTU0tRERcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGZvcm1hdDonWVlZWS1NTS1ERCcsXG4gICAgICAgIC8qKlxuICAgICAgICBGb3JtYXQgdXNlZCBmb3IgZGlzcGxheWluZyBkYXRlLiBBbHNvIGFwcGxpZWQgd2hlbiBjb252ZXJ0aW5nIGRhdGUgZnJvbSBlbGVtZW50J3MgdGV4dCBvbiBpbml0LiAgIFxuICAgICAgICBJZiBub3Qgc3BlY2lmaWVkIGVxdWFscyB0byBgZm9ybWF0YC5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSB2aWV3Zm9ybWF0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIHZpZXdmb3JtYXQ6IG51bGwsICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFRlbXBsYXRlIHVzZWQgZm9yIGRpc3BsYXlpbmcgZHJvcGRvd25zLlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IHRlbXBsYXRlIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgRCAvIE1NTSAvIFlZWVlcbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICB0ZW1wbGF0ZTogJ0QgLyBNTU0gLyBZWVlZJywgIFxuICAgICAgICAvKipcbiAgICAgICAgQ29uZmlndXJhdGlvbiBvZiBjb21ib2RhdGUuXG4gICAgICAgIEZ1bGwgbGlzdCBvZiBvcHRpb25zOiBodHRwOi8vdml0YWxldHMuZ2l0aHViLmNvbS9jb21ib2RhdGUvI2RvY3NcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBjb21ib2RhdGUgXG4gICAgICAgIEB0eXBlIG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBjb21ib2RhdGU6IG51bGxcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgIChub3QgaW1wbGVtZW50ZWQgeWV0KVxuICAgICAgICBUZXh0IHNob3duIGFzIGNsZWFyIGRhdGUgYnV0dG9uLiBcbiAgICAgICAgSWYgPGNvZGU+ZmFsc2U8L2NvZGU+IGNsZWFyIGJ1dHRvbiB3aWxsIG5vdCBiZSByZW5kZXJlZC5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBjbGVhciBcbiAgICAgICAgQHR5cGUgYm9vbGVhbnxzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ3ggY2xlYXInICAgICAgICAgXG4gICAgICAgICovXG4gICAgICAgIC8vY2xlYXI6ICcmdGltZXM7IGNsZWFyJ1xuICAgIH0pOyAgIFxuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLmNvbWJvZGF0ZSA9IENvbnN0cnVjdG9yO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLypcbkVkaXRhYmxlZm9ybSBiYXNlZCBvbiBUd2l0dGVyIEJvb3RzdHJhcCAzXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIC8vc3RvcmUgcGFyZW50IG1ldGhvZHNcbiAgICB2YXIgcEluaXRJbnB1dCA9ICQuZm4uZWRpdGFibGVmb3JtLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5pbml0SW5wdXQ7XG4gICAgXG4gICAgJC5leHRlbmQoJC5mbi5lZGl0YWJsZWZvcm0uQ29uc3RydWN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGluaXRUZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRmb3JtID0gJCgkLmZuLmVkaXRhYmxlZm9ybS50ZW1wbGF0ZSk7IFxuICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuY29udHJvbC1ncm91cCcpLmFkZENsYXNzKCdmb3JtLWdyb3VwJyk7XG4gICAgICAgICAgICB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1lcnJvci1ibG9jaycpLmFkZENsYXNzKCdoZWxwLWJsb2NrJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRJbnB1dDogZnVuY3Rpb24oKSB7ICBcbiAgICAgICAgICAgIHBJbml0SW5wdXQuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgICAgIC8vZm9yIGJzMyBzZXQgZGVmYXVsdCBjbGFzcyBgaW5wdXQtc21gIHRvIHN0YW5kYXJkIGlucHV0c1xuICAgICAgICAgICAgdmFyIGVtcHR5SW5wdXRDbGFzcyA9IHRoaXMuaW5wdXQub3B0aW9ucy5pbnB1dGNsYXNzID09PSBudWxsIHx8IHRoaXMuaW5wdXQub3B0aW9ucy5pbnB1dGNsYXNzID09PSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Q2xhc3MgPSAnaW5wdXQtc20nO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2JzMyBhZGQgYGZvcm0tY29udHJvbGAgY2xhc3MgdG8gc3RhbmRhcmQgaW5wdXRzXG4gICAgICAgICAgICB2YXIgc3RkdHlwZXMgPSAndGV4dCxzZWxlY3QsdGV4dGFyZWEscGFzc3dvcmQsZW1haWwsdXJsLHRlbCxudW1iZXIscmFuZ2UsdGltZSx0eXBlYWhlYWRqcycuc3BsaXQoJywnKTsgXG4gICAgICAgICAgICBpZih+JC5pbkFycmF5KHRoaXMuaW5wdXQudHlwZSwgc3RkdHlwZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC4kaW5wdXQuYWRkQ2xhc3MoJ2Zvcm0tY29udHJvbCcpO1xuICAgICAgICAgICAgICAgIGlmKGVtcHR5SW5wdXRDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0Lm9wdGlvbnMuaW5wdXRjbGFzcyA9IGRlZmF1bHRDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC4kaW5wdXQuYWRkQ2xhc3MoZGVmYXVsdENsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgICAgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgICAgIC8vYXBwbHkgYnMzIHNpemUgY2xhc3MgYWxzbyB0byBidXR0b25zICh0byBmaXQgc2l6ZSBvZiBjb250cm9sKVxuICAgICAgICAgICAgdmFyICRidG4gPSB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1idXR0b25zJyk7XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IGVtcHR5SW5wdXRDbGFzcyA/IFtkZWZhdWx0Q2xhc3NdIDogdGhpcy5pbnB1dC5vcHRpb25zLmlucHV0Y2xhc3Muc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBgYnRuLXNtYCBpcyBkZWZhdWx0IG5vd1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgaWYoY2xhc3Nlc1tpXS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQtc20nKSB7IFxuICAgICAgICAgICAgICAgICAgICAkYnRuLmZpbmQoJ2J1dHRvbicpLmFkZENsYXNzKCdidG4tc20nKTsgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmKGNsYXNzZXNbaV0udG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0LWxnJykge1xuICAgICAgICAgICAgICAgICAgICAkYnRuLmZpbmQoJ2J1dHRvbicpLnJlbW92ZUNsYXNzKCdidG4tc20nKS5hZGRDbGFzcygnYnRuLWxnJyk7IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pOyAgICBcbiAgICBcbiAgICAvL2J1dHRvbnNcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5idXR0b25zID0gXG4gICAgICAnPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLXNtIGVkaXRhYmxlLXN1Ym1pdFwiPicrXG4gICAgICAgICc8aSBjbGFzcz1cImZhIGZhLW9rXCI+PC9pPicrXG4gICAgICAnPC9idXR0b24+JytcbiAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBidG4tc20gZWRpdGFibGUtY2FuY2VsXCI+JytcbiAgICAgICAgJzxpIGNsYXNzPVwiZmEgZmEtcmVtb3ZlXCI+PC9pPicrXG4gICAgICAnPC9idXR0b24+JzsgICAgICAgICBcbiAgICBcbiAgICAvL2Vycm9yIGNsYXNzZXNcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckdyb3VwQ2xhc3MgPSAnaGFzLWVycm9yJztcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckJsb2NrQ2xhc3MgPSBudWxsOyAgXG4gICAgLy9lbmdpbmVcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5lbmdpbmUgPSAnYnMzJzsgIFxufSh3aW5kb3cualF1ZXJ5KSk7XG4vKipcbiogRWRpdGFibGUgUG9wb3ZlcjMgKGZvciBCb290c3RyYXAgMykgXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiByZXF1aXJlcyBib290c3RyYXAtcG9wb3Zlci5qc1xuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcblxuICAgIC8vZXh0ZW5kIG1ldGhvZHNcbiAgICAkLmV4dGVuZCgkLmZuLmVkaXRhYmxlQ29udGFpbmVyLlBvcHVwLnByb3RvdHlwZSwge1xuICAgICAgICBjb250YWluZXJOYW1lOiAncG9wb3ZlcicsXG4gICAgICAgIGNvbnRhaW5lckRhdGFOYW1lOiAnYnMucG9wb3ZlcicsXG4gICAgICAgIGlubmVyQ3NzOiAnLnBvcG92ZXItY29udGVudCcsXG4gICAgICAgIGRlZmF1bHRzOiAkLmZuLnBvcG92ZXIuQ29uc3RydWN0b3IuREVGQVVMVFMsXG5cbiAgICAgICAgaW5pdENvbnRhaW5lcjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICQuZXh0ZW5kKHRoaXMuY29udGFpbmVyT3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnICcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMuZGVmYXVsdHMudGVtcGxhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2FzIHRlbXBsYXRlIHByb3BlcnR5IGlzIHVzZWQgaW4gaW5wdXRzLCBoaWRlIGl0IGZyb20gcG9wb3ZlclxuICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICBpZih0aGlzLiRlbGVtZW50LmRhdGEoJ3RlbXBsYXRlJykpIHtcbiAgICAgICAgICAgICAgIHQgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoJ3RlbXBsYXRlJyk7ICBcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuY2FsbCh0aGlzLmNvbnRhaW5lck9wdGlvbnMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0KSB7XG4gICAgICAgICAgICAgICAvL3Jlc3RvcmUgZGF0YSgndGVtcGxhdGUnKVxuICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5kYXRhKCd0ZW1wbGF0ZScsIHQpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgXG4gICAgICAgIFxuICAgICAgICAvKiBzaG93ICovXG4gICAgICAgIGlubmVyU2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsKCdzaG93Jyk7ICAgICAgICAgICAgICAgIFxuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgICAvKiBoaWRlICovXG4gICAgICAgIGlubmVySGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsKCdoaWRlJyk7ICAgICAgIFxuICAgICAgICB9LCBcbiAgICAgICAgXG4gICAgICAgIC8qIGRlc3Ryb3kgKi9cbiAgICAgICAgaW5uZXJEZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbCgnZGVzdHJveScpO1xuICAgICAgICB9LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHNldENvbnRhaW5lck9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIoKS5vcHRpb25zW2tleV0gPSB2YWx1ZTsgXG4gICAgICAgIH0sICAgICAgICAgICAgICAgXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogbW92ZSBwb3BvdmVyIHRvIG5ldyBwb3NpdGlvbi4gVGhpcyBmdW5jdGlvbiBtYWlubHkgY29waWVkIGZyb20gYm9vdHN0cmFwLXBvcG92ZXIuXG4gICAgICAgICovXG4gICAgICAgIC8qanNoaW50IGxheGNvbW1hOiB0cnVlLCBlcWVxZXE6IGZhbHNlKi9cbiAgICAgICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHsgXG5cbiAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8qICAgIFxuICAgICAgICAgICAgICAgIHZhciAkdGlwID0gdGhpcy50aXAoKVxuICAgICAgICAgICAgICAgICwgaW5zaWRlXG4gICAgICAgICAgICAgICAgLCBwb3NcbiAgICAgICAgICAgICAgICAsIGFjdHVhbFdpZHRoXG4gICAgICAgICAgICAgICAgLCBhY3R1YWxIZWlnaHRcbiAgICAgICAgICAgICAgICAsIHBsYWNlbWVudFxuICAgICAgICAgICAgICAgICwgdHBcbiAgICAgICAgICAgICAgICAsIHRwdFxuICAgICAgICAgICAgICAgICwgdHBiXG4gICAgICAgICAgICAgICAgLCB0cGxcbiAgICAgICAgICAgICAgICAsIHRwcjtcblxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50LmNhbGwodGhpcywgJHRpcFswXSwgdGhpcy4kZWxlbWVudFswXSkgOlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICBpbnNpZGUgPSAvaW4vLnRlc3QocGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICR0aXBcbiAgICAgICAgICAgICAgLy8gIC5kZXRhY2goKVxuICAgICAgICAgICAgICAvL3ZpdGFsZXRzOiByZW1vdmUgYW55IHBsYWNlbWVudCBjbGFzcyBiZWNhdXNlIG90aGVyd2lzZSB0aGV5IGRvbnQgaW5mbHVlbmNlIG9uIHJlLXBvc2l0aW9uaW5nIG9mIHZpc2libGUgcG9wb3ZlclxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygndG9wIHJpZ2h0IGJvdHRvbSBsZWZ0JylcbiAgICAgICAgICAgICAgICAuY3NzKHsgdG9wOiAwLCBsZWZ0OiAwLCBkaXNwbGF5OiAnYmxvY2snIH0pO1xuICAgICAgICAgICAgICAvLyAgLmluc2VydEFmdGVyKHRoaXMuJGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbihpbnNpZGUpO1xuXG4gICAgICAgICAgICAgICAgYWN0dWFsV2lkdGggPSAkdGlwWzBdLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIGFjdHVhbEhlaWdodCA9ICR0aXBbMF0ub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gaW5zaWRlID8gcGxhY2VtZW50LnNwbGl0KCcgJylbMV0gOiBwbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB0cGIgPSB7dG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCwgbGVmdDogcG9zLmxlZnQgKyBwb3Mud2lkdGggLyAyIC0gYWN0dWFsV2lkdGggLyAyfTtcbiAgICAgICAgICAgICAgICB0cHQgPSB7dG9wOiBwb3MudG9wIC0gYWN0dWFsSGVpZ2h0LCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDJ9O1xuICAgICAgICAgICAgICAgIHRwbCA9IHt0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0IC0gYWN0dWFsV2lkdGh9O1xuICAgICAgICAgICAgICAgIHRwciA9IHt0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRofTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRwYi50b3AgKyBhY3R1YWxIZWlnaHQpID4gKCQod2luZG93KS5zY3JvbGxUb3AoKSArICQod2luZG93KS5oZWlnaHQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHB0LnRvcCA+ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0cHIubGVmdCArIGFjdHVhbFdpZHRoKSA8ICgkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgJCh3aW5kb3cpLndpZHRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cGwubGVmdCA+ICQod2luZG93KS5zY3JvbGxMZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHB0LnRvcCA8ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHBiLnRvcCArIGFjdHVhbEhlaWdodCkgPCAoJCh3aW5kb3cpLnNjcm9sbFRvcCgpICsgJCh3aW5kb3cpLmhlaWdodCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0cHIubGVmdCArIGFjdHVhbFdpZHRoKSA8ICgkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgJCh3aW5kb3cpLndpZHRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cGwubGVmdCA+ICQod2luZG93KS5zY3JvbGxMZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRwbC5sZWZ0IDwgJCh3aW5kb3cpLnNjcm9sbExlZnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHByLmxlZnQgKyBhY3R1YWxXaWR0aCkgPCAoJCh3aW5kb3cpLnNjcm9sbExlZnQoKSArICQod2luZG93KS53aWR0aCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHB0LnRvcCA+ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRwdC50b3AgPiAkKHdpbmRvdykuc2Nyb2xsVG9wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0cHIubGVmdCArIGFjdHVhbFdpZHRoKSA+ICgkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgJCh3aW5kb3cpLndpZHRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRwbC5sZWZ0ID4gJCh3aW5kb3cpLnNjcm9sbExlZnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cHQudG9wID4gJCh3aW5kb3cpLnNjcm9sbFRvcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICd0b3AnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHB0LnRvcCA+ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHAgPSB0cGI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwID0gdHB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHAgPSB0cGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHAgPSB0cHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkdGlwXG4gICAgICAgICAgICAgICAgLm9mZnNldCh0cClcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnaW4nKTtcbiAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciAkdGlwID0gdGhpcy50aXAoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQuY2FsbCh0aGlzLCAkdGlwWzBdLCB0aGlzLiRlbGVtZW50WzBdKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBsYWNlbWVudDsgICAgICAgICAgICBcblxuICAgICAgICAgICAgdmFyIGF1dG9Ub2tlbiA9IC9cXHM/YXV0bz9cXHM/L2k7XG4gICAgICAgICAgICB2YXIgYXV0b1BsYWNlID0gYXV0b1Rva2VuLnRlc3QocGxhY2VtZW50KTtcbiAgICAgICAgICAgIGlmIChhdXRvUGxhY2UpIHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQucmVwbGFjZShhdXRvVG9rZW4sICcnKSB8fCAndG9wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgdmFyIGFjdHVhbFdpZHRoID0gJHRpcFswXS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHZhciBhY3R1YWxIZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgaWYgKGF1dG9QbGFjZSkge1xuICAgICAgICAgICAgICAgIHZhciAkcGFyZW50ID0gdGhpcy4kZWxlbWVudC5wYXJlbnQoKTtcblxuICAgICAgICAgICAgICAgIHZhciBvcmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGRvY1Njcm9sbCAgICA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFdpZHRoICA9IHRoaXMub3B0aW9ucy5jb250YWluZXIgPT0gJ2JvZHknID8gd2luZG93LmlubmVyV2lkdGggIDogJHBhcmVudC5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEhlaWdodCA9IHRoaXMub3B0aW9ucy5jb250YWluZXIgPT0gJ2JvZHknID8gd2luZG93LmlubmVySGVpZ2h0IDogJHBhcmVudC5vdXRlckhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRMZWZ0ICAgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyID09ICdib2R5JyA/IDAgOiAkcGFyZW50Lm9mZnNldCgpLmxlZnQ7XG5cbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQgPT0gJ2JvdHRvbScgJiYgcG9zLnRvcCAgICsgcG9zLmhlaWdodCAgKyBhY3R1YWxIZWlnaHQgLSBkb2NTY3JvbGwgPiBwYXJlbnRIZWlnaHQgID8gJ3RvcCcgICAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICAmJiBwb3MudG9wICAgLSBkb2NTY3JvbGwgICAtIGFjdHVhbEhlaWdodCA8IDAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm90dG9tJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICdyaWdodCcgICYmIHBvcy5yaWdodCArIGFjdHVhbFdpZHRoID4gcGFyZW50V2lkdGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdsZWZ0JyAgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ2xlZnQnICAgJiYgcG9zLmxlZnQgIC0gYWN0dWFsV2lkdGggPCBwYXJlbnRMZWZ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3JpZ2h0JyAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDtcblxuICAgICAgICAgICAgICAgICR0aXBcbiAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhvcmdQbGFjZW1lbnQpXG4gICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlZE9mZnNldCA9IHRoaXMuZ2V0Q2FsY3VsYXRlZE9mZnNldChwbGFjZW1lbnQsIHBvcywgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoY2FsY3VsYXRlZE9mZnNldCwgcGxhY2VtZW50KTsgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSkuY2FsbCh0aGlzLmNvbnRhaW5lcigpKTtcbiAgICAgICAgICAvKmpzaGludCBsYXhjb21tYTogZmFsc2UsIGVxZXFlcTogdHJ1ZSovICBcbiAgICAgICAgfSAgICAgICAgICAgIFxuICAgIH0pO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBib290c3RyYXAtZGF0ZXBpY2tlci5qc1xuICogaHR0cDovL3d3dy5leWVjb24ucm8vYm9vdHN0cmFwLWRhdGVwaWNrZXJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTIgU3RlZmFuIFBldHJlXG4gKiBJbXByb3ZlbWVudHMgYnkgQW5kcmV3IFJvd2xzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuKGZ1bmN0aW9uKCAkICkge1xuXG5cdGZ1bmN0aW9uIFVUQ0RhdGUoKXtcblx0XHRyZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkoRGF0ZSwgYXJndW1lbnRzKSk7XG5cdH1cblx0ZnVuY3Rpb24gVVRDVG9kYXkoKXtcblx0XHR2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuXHRcdHJldHVybiBVVENEYXRlKHRvZGF5LmdldFVUQ0Z1bGxZZWFyKCksIHRvZGF5LmdldFVUQ01vbnRoKCksIHRvZGF5LmdldFVUQ0RhdGUoKSk7XG5cdH1cblxuXHQvLyBQaWNrZXIgb2JqZWN0XG5cblx0dmFyIERhdGVwaWNrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKG9wdGlvbnMpO1xuXG5cdFx0dGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcblx0XHR0aGlzLmlzSW5saW5lID0gZmFsc2U7XG5cdFx0dGhpcy5pc0lucHV0ID0gdGhpcy5lbGVtZW50LmlzKCdpbnB1dCcpO1xuXHRcdHRoaXMuY29tcG9uZW50ID0gdGhpcy5lbGVtZW50LmlzKCcuZGF0ZScpID8gdGhpcy5lbGVtZW50LmZpbmQoJy5hZGQtb24sIC5idG4nKSA6IGZhbHNlO1xuXHRcdHRoaXMuaGFzSW5wdXQgPSB0aGlzLmNvbXBvbmVudCAmJiB0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKS5sZW5ndGg7XG5cdFx0aWYodGhpcy5jb21wb25lbnQgJiYgdGhpcy5jb21wb25lbnQubGVuZ3RoID09PSAwKVxuXHRcdFx0dGhpcy5jb21wb25lbnQgPSBmYWxzZTtcblxuXHRcdHRoaXMucGlja2VyID0gJChEUEdsb2JhbC50ZW1wbGF0ZSk7XG5cdFx0dGhpcy5fYnVpbGRFdmVudHMoKTtcblx0XHR0aGlzLl9hdHRhY2hFdmVudHMoKTtcblxuXHRcdGlmKHRoaXMuaXNJbmxpbmUpIHtcblx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLWlubGluZScpLmFwcGVuZFRvKHRoaXMuZWxlbWVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLWRyb3Bkb3duIGRyb3Bkb3duLW1lbnUnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vLnJ0bCl7XG5cdFx0XHR0aGlzLnBpY2tlci5hZGRDbGFzcygnZGF0ZXBpY2tlci1ydGwnKTtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5wcmV2IGksIC5uZXh0IGknKVxuXHRcdFx0XHRcdFx0LnRvZ2dsZUNsYXNzKCdpY29uLWFycm93LWxlZnQgaWNvbi1hcnJvdy1yaWdodCcpO1xuXHRcdH1cblxuXG5cdFx0dGhpcy52aWV3TW9kZSA9IHRoaXMuby5zdGFydFZpZXc7XG5cblx0XHRpZiAodGhpcy5vLmNhbGVuZGFyV2Vla3MpXG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCd0Zm9vdCB0aC50b2RheScpXG5cdFx0XHRcdFx0XHQuYXR0cignY29sc3BhbicsIGZ1bmN0aW9uKGksIHZhbCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwYXJzZUludCh2YWwpICsgMTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0dGhpcy5fYWxsb3dfdXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLnNldFN0YXJ0RGF0ZSh0aGlzLm8uc3RhcnREYXRlKTtcblx0XHR0aGlzLnNldEVuZERhdGUodGhpcy5vLmVuZERhdGUpO1xuXHRcdHRoaXMuc2V0RGF5c09mV2Vla0Rpc2FibGVkKHRoaXMuby5kYXlzT2ZXZWVrRGlzYWJsZWQpO1xuXG5cdFx0dGhpcy5maWxsRG93KCk7XG5cdFx0dGhpcy5maWxsTW9udGhzKCk7XG5cblx0XHR0aGlzLl9hbGxvd191cGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblx0XHR0aGlzLnNob3dNb2RlKCk7XG5cblx0XHRpZih0aGlzLmlzSW5saW5lKSB7XG5cdFx0XHR0aGlzLnNob3coKTtcblx0XHR9XG5cdH07XG5cblx0RGF0ZXBpY2tlci5wcm90b3R5cGUgPSB7XG5cdFx0Y29uc3RydWN0b3I6IERhdGVwaWNrZXIsXG5cblx0XHRfcHJvY2Vzc19vcHRpb25zOiBmdW5jdGlvbihvcHRzKXtcblx0XHRcdC8vIFN0b3JlIHJhdyBvcHRpb25zIGZvciByZWZlcmVuY2Vcblx0XHRcdHRoaXMuX28gPSAkLmV4dGVuZCh7fSwgdGhpcy5fbywgb3B0cyk7XG5cdFx0XHQvLyBQcm9jZXNzZWQgb3B0aW9uc1xuXHRcdFx0dmFyIG8gPSB0aGlzLm8gPSAkLmV4dGVuZCh7fSwgdGhpcy5fbyk7XG5cblx0XHRcdC8vIENoZWNrIGlmIFwiZGUtREVcIiBzdHlsZSBkYXRlIGlzIGF2YWlsYWJsZSwgaWYgbm90IGxhbmd1YWdlIHNob3VsZFxuXHRcdFx0Ly8gZmFsbGJhY2sgdG8gMiBsZXR0ZXIgY29kZSBlZyBcImRlXCJcblx0XHRcdHZhciBsYW5nID0gby5sYW5ndWFnZTtcblx0XHRcdGlmICghZGF0ZXNbbGFuZ10pIHtcblx0XHRcdFx0bGFuZyA9IGxhbmcuc3BsaXQoJy0nKVswXTtcblx0XHRcdFx0aWYgKCFkYXRlc1tsYW5nXSlcblx0XHRcdFx0XHRsYW5nID0gZGVmYXVsdHMubGFuZ3VhZ2U7XG5cdFx0XHR9XG5cdFx0XHRvLmxhbmd1YWdlID0gbGFuZztcblxuXHRcdFx0c3dpdGNoKG8uc3RhcnRWaWV3KXtcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRjYXNlICdkZWNhZGUnOlxuXHRcdFx0XHRcdG8uc3RhcnRWaWV3ID0gMjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRjYXNlICd5ZWFyJzpcblx0XHRcdFx0XHRvLnN0YXJ0VmlldyA9IDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0by5zdGFydFZpZXcgPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKG8ubWluVmlld01vZGUpIHtcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRjYXNlICdtb250aHMnOlxuXHRcdFx0XHRcdG8ubWluVmlld01vZGUgPSAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdGNhc2UgJ3llYXJzJzpcblx0XHRcdFx0XHRvLm1pblZpZXdNb2RlID0gMjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRvLm1pblZpZXdNb2RlID0gMDtcblx0XHRcdH1cblxuXHRcdFx0by5zdGFydFZpZXcgPSBNYXRoLm1heChvLnN0YXJ0Vmlldywgby5taW5WaWV3TW9kZSk7XG5cblx0XHRcdG8ud2Vla1N0YXJ0ICU9IDc7XG5cdFx0XHRvLndlZWtFbmQgPSAoKG8ud2Vla1N0YXJ0ICsgNikgJSA3KTtcblxuXHRcdFx0dmFyIGZvcm1hdCA9IERQR2xvYmFsLnBhcnNlRm9ybWF0KG8uZm9ybWF0KVxuXHRcdFx0aWYgKG8uc3RhcnREYXRlICE9PSAtSW5maW5pdHkpIHtcblx0XHRcdFx0by5zdGFydERhdGUgPSBEUEdsb2JhbC5wYXJzZURhdGUoby5zdGFydERhdGUsIGZvcm1hdCwgby5sYW5ndWFnZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoby5lbmREYXRlICE9PSBJbmZpbml0eSkge1xuXHRcdFx0XHRvLmVuZERhdGUgPSBEUEdsb2JhbC5wYXJzZURhdGUoby5lbmREYXRlLCBmb3JtYXQsIG8ubGFuZ3VhZ2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRvLmRheXNPZldlZWtEaXNhYmxlZCA9IG8uZGF5c09mV2Vla0Rpc2FibGVkfHxbXTtcblx0XHRcdGlmICghJC5pc0FycmF5KG8uZGF5c09mV2Vla0Rpc2FibGVkKSlcblx0XHRcdFx0by5kYXlzT2ZXZWVrRGlzYWJsZWQgPSBvLmRheXNPZldlZWtEaXNhYmxlZC5zcGxpdCgvWyxcXHNdKi8pO1xuXHRcdFx0by5kYXlzT2ZXZWVrRGlzYWJsZWQgPSAkLm1hcChvLmRheXNPZldlZWtEaXNhYmxlZCwgZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KGQsIDEwKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0X2V2ZW50czogW10sXG5cdFx0X3NlY29uZGFyeUV2ZW50czogW10sXG5cdFx0X2FwcGx5RXZlbnRzOiBmdW5jdGlvbihldnMpe1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBlbCwgZXY7IGk8ZXZzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0ZWwgPSBldnNbaV1bMF07XG5cdFx0XHRcdGV2ID0gZXZzW2ldWzFdO1xuXHRcdFx0XHRlbC5vbihldik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfdW5hcHBseUV2ZW50czogZnVuY3Rpb24oZXZzKXtcblx0XHRcdGZvciAodmFyIGk9MCwgZWwsIGV2OyBpPGV2cy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdGVsID0gZXZzW2ldWzBdO1xuXHRcdFx0XHRldiA9IGV2c1tpXVsxXTtcblx0XHRcdFx0ZWwub2ZmKGV2KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9idWlsZEV2ZW50czogZnVuY3Rpb24oKXtcblx0XHRcdGlmICh0aGlzLmlzSW5wdXQpIHsgLy8gc2luZ2xlIGlucHV0XG5cdFx0XHRcdHRoaXMuX2V2ZW50cyA9IFtcblx0XHRcdFx0XHRbdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdFx0XHRmb2N1czogJC5wcm94eSh0aGlzLnNob3csIHRoaXMpLFxuXHRcdFx0XHRcdFx0a2V5dXA6ICQucHJveHkodGhpcy51cGRhdGUsIHRoaXMpLFxuXHRcdFx0XHRcdFx0a2V5ZG93bjogJC5wcm94eSh0aGlzLmtleWRvd24sIHRoaXMpXG5cdFx0XHRcdFx0fV1cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHRoaXMuY29tcG9uZW50ICYmIHRoaXMuaGFzSW5wdXQpeyAvLyBjb21wb25lbnQ6IGlucHV0ICsgYnV0dG9uXG5cdFx0XHRcdHRoaXMuX2V2ZW50cyA9IFtcblx0XHRcdFx0XHQvLyBGb3IgY29tcG9uZW50cyB0aGF0IGFyZSBub3QgcmVhZG9ubHksIGFsbG93IGtleWJvYXJkIG5hdlxuXHRcdFx0XHRcdFt0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKSwge1xuXHRcdFx0XHRcdFx0Zm9jdXM6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKSxcblx0XHRcdFx0XHRcdGtleXVwOiAkLnByb3h5KHRoaXMudXBkYXRlLCB0aGlzKSxcblx0XHRcdFx0XHRcdGtleWRvd246ICQucHJveHkodGhpcy5rZXlkb3duLCB0aGlzKVxuXHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFt0aGlzLmNvbXBvbmVudCwge1xuXHRcdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKVxuXHRcdFx0XHRcdH1dXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0aGlzLmVsZW1lbnQuaXMoJ2RpdicpKSB7ICAvLyBpbmxpbmUgZGF0ZXBpY2tlclxuXHRcdFx0XHR0aGlzLmlzSW5saW5lID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9ldmVudHMgPSBbXG5cdFx0XHRcdFx0W3RoaXMuZWxlbWVudCwge1xuXHRcdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKVxuXHRcdFx0XHRcdH1dXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NlY29uZGFyeUV2ZW50cyA9IFtcblx0XHRcdFx0W3RoaXMucGlja2VyLCB7XG5cdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5jbGljaywgdGhpcylcblx0XHRcdFx0fV0sXG5cdFx0XHRcdFskKHdpbmRvdyksIHtcblx0XHRcdFx0XHRyZXNpemU6ICQucHJveHkodGhpcy5wbGFjZSwgdGhpcylcblx0XHRcdFx0fV0sXG5cdFx0XHRcdFskKGRvY3VtZW50KSwge1xuXHRcdFx0XHRcdG1vdXNlZG93bjogJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0Ly8gQ2xpY2tlZCBvdXRzaWRlIHRoZSBkYXRlcGlja2VyLCBoaWRlIGl0XG5cdFx0XHRcdFx0XHRpZiAoIShcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmlzKGUudGFyZ2V0KSB8fFxuXHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZChlLnRhcmdldCkuc2l6ZSgpIHx8XG5cdFx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmlzKGUudGFyZ2V0KSB8fFxuXHRcdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKGUudGFyZ2V0KS5zaXplKClcblx0XHRcdFx0XHRcdCkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcylcblx0XHRcdFx0fV1cblx0XHRcdF07XG5cdFx0fSxcblx0XHRfYXR0YWNoRXZlbnRzOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5fZGV0YWNoRXZlbnRzKCk7XG5cdFx0XHR0aGlzLl9hcHBseUV2ZW50cyh0aGlzLl9ldmVudHMpO1xuXHRcdH0sXG5cdFx0X2RldGFjaEV2ZW50czogZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuX3VuYXBwbHlFdmVudHModGhpcy5fZXZlbnRzKTtcblx0XHR9LFxuXHRcdF9hdHRhY2hTZWNvbmRhcnlFdmVudHM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLl9kZXRhY2hTZWNvbmRhcnlFdmVudHMoKTtcblx0XHRcdHRoaXMuX2FwcGx5RXZlbnRzKHRoaXMuX3NlY29uZGFyeUV2ZW50cyk7XG5cdFx0fSxcblx0XHRfZGV0YWNoU2Vjb25kYXJ5RXZlbnRzOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5fdW5hcHBseUV2ZW50cyh0aGlzLl9zZWNvbmRhcnlFdmVudHMpO1xuXHRcdH0sXG5cdFx0X3RyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50LCBhbHRkYXRlKXtcblx0XHRcdHZhciBkYXRlID0gYWx0ZGF0ZSB8fCB0aGlzLmRhdGUsXG5cdFx0XHRcdGxvY2FsX2RhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkqNjAwMDApKTtcblxuXHRcdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoe1xuXHRcdFx0XHR0eXBlOiBldmVudCxcblx0XHRcdFx0ZGF0ZTogbG9jYWxfZGF0ZSxcblx0XHRcdFx0Zm9ybWF0OiAkLnByb3h5KGZ1bmN0aW9uKGFsdGZvcm1hdCl7XG5cdFx0XHRcdFx0dmFyIGZvcm1hdCA9IGFsdGZvcm1hdCB8fCB0aGlzLm8uZm9ybWF0O1xuXHRcdFx0XHRcdHJldHVybiBEUEdsb2JhbC5mb3JtYXREYXRlKGRhdGUsIGZvcm1hdCwgdGhpcy5vLmxhbmd1YWdlKTtcblx0XHRcdFx0fSwgdGhpcylcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRzaG93OiBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoIXRoaXMuaXNJbmxpbmUpXG5cdFx0XHRcdHRoaXMucGlja2VyLmFwcGVuZFRvKCdib2R5Jyk7XG5cdFx0XHR0aGlzLnBpY2tlci5zaG93KCk7XG5cdFx0XHR0aGlzLmhlaWdodCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQub3V0ZXJIZWlnaHQoKSA6IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpO1xuXHRcdFx0dGhpcy5wbGFjZSgpO1xuXHRcdFx0dGhpcy5fYXR0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XG5cdFx0XHRpZiAoZSkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCdzaG93Jyk7XG5cdFx0fSxcblxuXHRcdGhpZGU6IGZ1bmN0aW9uKGUpe1xuXHRcdFx0aWYodGhpcy5pc0lubGluZSkgcmV0dXJuO1xuXHRcdFx0aWYgKCF0aGlzLnBpY2tlci5pcygnOnZpc2libGUnKSkgcmV0dXJuO1xuXHRcdFx0dGhpcy5waWNrZXIuaGlkZSgpLmRldGFjaCgpO1xuXHRcdFx0dGhpcy5fZGV0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XG5cdFx0XHR0aGlzLnZpZXdNb2RlID0gdGhpcy5vLnN0YXJ0Vmlldztcblx0XHRcdHRoaXMuc2hvd01vZGUoKTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0aGlzLm8uZm9yY2VQYXJzZSAmJlxuXHRcdFx0XHQoXG5cdFx0XHRcdFx0dGhpcy5pc0lucHV0ICYmIHRoaXMuZWxlbWVudC52YWwoKSB8fFxuXHRcdFx0XHRcdHRoaXMuaGFzSW5wdXQgJiYgdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0JykudmFsKClcblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdFx0XHR0aGlzLnNldFZhbHVlKCk7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCdoaWRlJyk7XG5cdFx0fSxcblxuXHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdHRoaXMuX2RldGFjaEV2ZW50cygpO1xuXHRcdFx0dGhpcy5fZGV0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XG5cdFx0XHR0aGlzLnBpY2tlci5yZW1vdmUoKTtcblx0XHRcdGRlbGV0ZSB0aGlzLmVsZW1lbnQuZGF0YSgpLmRhdGVwaWNrZXI7XG5cdFx0XHRpZiAoIXRoaXMuaXNJbnB1dCkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5lbGVtZW50LmRhdGEoKS5kYXRlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXREYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkID0gdGhpcy5nZXRVVENEYXRlKCk7XG5cdFx0XHRyZXR1cm4gbmV3IERhdGUoZC5nZXRUaW1lKCkgKyAoZC5nZXRUaW1lem9uZU9mZnNldCgpKjYwMDAwKSk7XG5cdFx0fSxcblxuXHRcdGdldFVUQ0RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0ZTtcblx0XHR9LFxuXG5cdFx0c2V0RGF0ZTogZnVuY3Rpb24oZCkge1xuXHRcdFx0dGhpcy5zZXRVVENEYXRlKG5ldyBEYXRlKGQuZ2V0VGltZSgpIC0gKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMCkpKTtcblx0XHR9LFxuXG5cdFx0c2V0VVRDRGF0ZTogZnVuY3Rpb24oZCkge1xuXHRcdFx0dGhpcy5kYXRlID0gZDtcblx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcblx0XHR9LFxuXG5cdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGZvcm1hdHRlZCA9IHRoaXMuZ2V0Rm9ybWF0dGVkRGF0ZSgpO1xuXHRcdFx0aWYgKCF0aGlzLmlzSW5wdXQpIHtcblx0XHRcdFx0aWYgKHRoaXMuY29tcG9uZW50KXtcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKS52YWwoZm9ybWF0dGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnZhbChmb3JtYXR0ZWQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRGb3JtYXR0ZWREYXRlOiBmdW5jdGlvbihmb3JtYXQpIHtcblx0XHRcdGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0Zm9ybWF0ID0gdGhpcy5vLmZvcm1hdDtcblx0XHRcdHJldHVybiBEUEdsb2JhbC5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgZm9ybWF0LCB0aGlzLm8ubGFuZ3VhZ2UpO1xuXHRcdH0sXG5cblx0XHRzZXRTdGFydERhdGU6IGZ1bmN0aW9uKHN0YXJ0RGF0ZSl7XG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe3N0YXJ0RGF0ZTogc3RhcnREYXRlfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcblx0XHR9LFxuXG5cdFx0c2V0RW5kRGF0ZTogZnVuY3Rpb24oZW5kRGF0ZSl7XG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe2VuZERhdGU6IGVuZERhdGV9KTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xuXHRcdH0sXG5cblx0XHRzZXREYXlzT2ZXZWVrRGlzYWJsZWQ6IGZ1bmN0aW9uKGRheXNPZldlZWtEaXNhYmxlZCl7XG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe2RheXNPZldlZWtEaXNhYmxlZDogZGF5c09mV2Vla0Rpc2FibGVkfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcblx0XHR9LFxuXG5cdFx0cGxhY2U6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRpZih0aGlzLmlzSW5saW5lKSByZXR1cm47XG5cdFx0XHR2YXIgekluZGV4ID0gcGFyc2VJbnQodGhpcy5lbGVtZW50LnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAkKHRoaXMpLmNzcygnei1pbmRleCcpICE9ICdhdXRvJztcblx0XHRcdFx0XHRcdH0pLmZpcnN0KCkuY3NzKCd6LWluZGV4JykpKzEwO1xuXHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQucGFyZW50KCkub2Zmc2V0KCkgOiB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XG5cdFx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5jb21wb25lbnQgPyB0aGlzLmNvbXBvbmVudC5vdXRlckhlaWdodCh0cnVlKSA6IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCh0cnVlKTtcblx0XHRcdHRoaXMucGlja2VyLmNzcyh7XG5cdFx0XHRcdHRvcDogb2Zmc2V0LnRvcCArIGhlaWdodCxcblx0XHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQsXG5cdFx0XHRcdHpJbmRleDogekluZGV4XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0X2FsbG93X3VwZGF0ZTogdHJ1ZSxcblx0XHR1cGRhdGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAoIXRoaXMuX2FsbG93X3VwZGF0ZSkgcmV0dXJuO1xuXG5cdFx0XHR2YXIgZGF0ZSwgZnJvbUFyZ3MgPSBmYWxzZTtcblx0XHRcdGlmKGFyZ3VtZW50cyAmJiBhcmd1bWVudHMubGVuZ3RoICYmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJyB8fCBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBEYXRlKSkge1xuXHRcdFx0XHRkYXRlID0gYXJndW1lbnRzWzBdO1xuXHRcdFx0XHRmcm9tQXJncyA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRlID0gdGhpcy5pc0lucHV0ID8gdGhpcy5lbGVtZW50LnZhbCgpIDogdGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUnKSB8fCB0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKS52YWwoKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRhKCkuZGF0ZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5kYXRlID0gRFBHbG9iYWwucGFyc2VEYXRlKGRhdGUsIHRoaXMuby5mb3JtYXQsIHRoaXMuby5sYW5ndWFnZSk7XG5cblx0XHRcdGlmKGZyb21BcmdzKSB0aGlzLnNldFZhbHVlKCk7XG5cblx0XHRcdGlmICh0aGlzLmRhdGUgPCB0aGlzLm8uc3RhcnREYXRlKSB7XG5cdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLm8uc3RhcnREYXRlKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5kYXRlID4gdGhpcy5vLmVuZERhdGUpIHtcblx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuby5lbmREYXRlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLmRhdGUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5maWxsKCk7XG5cdFx0fSxcblxuXHRcdGZpbGxEb3c6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgZG93Q250ID0gdGhpcy5vLndlZWtTdGFydCxcblx0XHRcdGh0bWwgPSAnPHRyPic7XG5cdFx0XHRpZih0aGlzLm8uY2FsZW5kYXJXZWVrcyl7XG5cdFx0XHRcdHZhciBjZWxsID0gJzx0aCBjbGFzcz1cImN3XCI+Jm5ic3A7PC90aD4nO1xuXHRcdFx0XHRodG1sICs9IGNlbGw7XG5cdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQgdHI6Zmlyc3QtY2hpbGQnKS5wcmVwZW5kKGNlbGwpO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGRvd0NudCA8IHRoaXMuby53ZWVrU3RhcnQgKyA3KSB7XG5cdFx0XHRcdGh0bWwgKz0gJzx0aCBjbGFzcz1cImRvd1wiPicrZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5kYXlzTWluWyhkb3dDbnQrKyklN10rJzwvdGg+Jztcblx0XHRcdH1cblx0XHRcdGh0bWwgKz0gJzwvdHI+Jztcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQnKS5hcHBlbmQoaHRtbCk7XG5cdFx0fSxcblxuXHRcdGZpbGxNb250aHM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgaHRtbCA9ICcnLFxuXHRcdFx0aSA9IDA7XG5cdFx0XHR3aGlsZSAoaSA8IDEyKSB7XG5cdFx0XHRcdGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwibW9udGhcIj4nK2RhdGVzW3RoaXMuby5sYW5ndWFnZV0ubW9udGhzU2hvcnRbaSsrXSsnPC9zcGFuPic7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMgdGQnKS5odG1sKGh0bWwpO1xuXHRcdH0sXG5cblx0XHRzZXRSYW5nZTogZnVuY3Rpb24ocmFuZ2Upe1xuXHRcdFx0aWYgKCFyYW5nZSB8fCAhcmFuZ2UubGVuZ3RoKVxuXHRcdFx0XHRkZWxldGUgdGhpcy5yYW5nZTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhpcy5yYW5nZSA9ICQubWFwKHJhbmdlLCBmdW5jdGlvbihkKXsgcmV0dXJuIGQudmFsdWVPZigpOyB9KTtcblx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdH0sXG5cblx0XHRnZXRDbGFzc05hbWVzOiBmdW5jdGlvbihkYXRlKXtcblx0XHRcdHZhciBjbHMgPSBbXSxcblx0XHRcdFx0eWVhciA9IHRoaXMudmlld0RhdGUuZ2V0VVRDRnVsbFllYXIoKSxcblx0XHRcdFx0bW9udGggPSB0aGlzLnZpZXdEYXRlLmdldFVUQ01vbnRoKCksXG5cdFx0XHRcdGN1cnJlbnREYXRlID0gdGhpcy5kYXRlLnZhbHVlT2YoKSxcblx0XHRcdFx0dG9kYXkgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0aWYgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA8IHllYXIgfHwgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA9PSB5ZWFyICYmIGRhdGUuZ2V0VVRDTW9udGgoKSA8IG1vbnRoKSkge1xuXHRcdFx0XHRjbHMucHVzaCgnb2xkJyk7XG5cdFx0XHR9IGVsc2UgaWYgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA+IHllYXIgfHwgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA9PSB5ZWFyICYmIGRhdGUuZ2V0VVRDTW9udGgoKSA+IG1vbnRoKSkge1xuXHRcdFx0XHRjbHMucHVzaCgnbmV3Jyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDb21wYXJlIGludGVybmFsIFVUQyBkYXRlIHdpdGggbG9jYWwgdG9kYXksIG5vdCBVVEMgdG9kYXlcblx0XHRcdGlmICh0aGlzLm8udG9kYXlIaWdobGlnaHQgJiZcblx0XHRcdFx0ZGF0ZS5nZXRVVENGdWxsWWVhcigpID09IHRvZGF5LmdldEZ1bGxZZWFyKCkgJiZcblx0XHRcdFx0ZGF0ZS5nZXRVVENNb250aCgpID09IHRvZGF5LmdldE1vbnRoKCkgJiZcblx0XHRcdFx0ZGF0ZS5nZXRVVENEYXRlKCkgPT0gdG9kYXkuZ2V0RGF0ZSgpKSB7XG5cdFx0XHRcdGNscy5wdXNoKCd0b2RheScpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnREYXRlICYmIGRhdGUudmFsdWVPZigpID09IGN1cnJlbnREYXRlKSB7XG5cdFx0XHRcdGNscy5wdXNoKCdhY3RpdmUnKTtcblx0XHRcdH1cblx0XHRcdGlmIChkYXRlLnZhbHVlT2YoKSA8IHRoaXMuby5zdGFydERhdGUgfHwgZGF0ZS52YWx1ZU9mKCkgPiB0aGlzLm8uZW5kRGF0ZSB8fFxuXHRcdFx0XHQkLmluQXJyYXkoZGF0ZS5nZXRVVENEYXkoKSwgdGhpcy5vLmRheXNPZldlZWtEaXNhYmxlZCkgIT09IC0xKSB7XG5cdFx0XHRcdGNscy5wdXNoKCdkaXNhYmxlZCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMucmFuZ2Upe1xuXHRcdFx0XHRpZiAoZGF0ZSA+IHRoaXMucmFuZ2VbMF0gJiYgZGF0ZSA8IHRoaXMucmFuZ2VbdGhpcy5yYW5nZS5sZW5ndGgtMV0pe1xuXHRcdFx0XHRcdGNscy5wdXNoKCdyYW5nZScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgkLmluQXJyYXkoZGF0ZS52YWx1ZU9mKCksIHRoaXMucmFuZ2UpICE9IC0xKXtcblx0XHRcdFx0XHRjbHMucHVzaCgnc2VsZWN0ZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNscztcblx0XHR9LFxuXG5cdFx0ZmlsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZCA9IG5ldyBEYXRlKHRoaXMudmlld0RhdGUpLFxuXHRcdFx0XHR5ZWFyID0gZC5nZXRVVENGdWxsWWVhcigpLFxuXHRcdFx0XHRtb250aCA9IGQuZ2V0VVRDTW9udGgoKSxcblx0XHRcdFx0c3RhcnRZZWFyID0gdGhpcy5vLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5ID8gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENGdWxsWWVhcigpIDogLUluZmluaXR5LFxuXHRcdFx0XHRzdGFydE1vbnRoID0gdGhpcy5vLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5ID8gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENNb250aCgpIDogLUluZmluaXR5LFxuXHRcdFx0XHRlbmRZZWFyID0gdGhpcy5vLmVuZERhdGUgIT09IEluZmluaXR5ID8gdGhpcy5vLmVuZERhdGUuZ2V0VVRDRnVsbFllYXIoKSA6IEluZmluaXR5LFxuXHRcdFx0XHRlbmRNb250aCA9IHRoaXMuby5lbmREYXRlICE9PSBJbmZpbml0eSA/IHRoaXMuby5lbmREYXRlLmdldFVUQ01vbnRoKCkgOiBJbmZpbml0eSxcblx0XHRcdFx0Y3VycmVudERhdGUgPSB0aGlzLmRhdGUgJiYgdGhpcy5kYXRlLnZhbHVlT2YoKSxcblx0XHRcdFx0dG9vbHRpcDtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQgdGguZGF0ZXBpY2tlci1zd2l0Y2gnKVxuXHRcdFx0XHRcdFx0LnRleHQoZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5tb250aHNbbW9udGhdKycgJyt5ZWFyKTtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJ3Rmb290IHRoLnRvZGF5Jylcblx0XHRcdFx0XHRcdC50ZXh0KGRhdGVzW3RoaXMuby5sYW5ndWFnZV0udG9kYXkpXG5cdFx0XHRcdFx0XHQudG9nZ2xlKHRoaXMuby50b2RheUJ0biAhPT0gZmFsc2UpO1xuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgndGZvb3QgdGguY2xlYXInKVxuXHRcdFx0XHRcdFx0LnRleHQoZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5jbGVhcilcblx0XHRcdFx0XHRcdC50b2dnbGUodGhpcy5vLmNsZWFyQnRuICE9PSBmYWxzZSk7XG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xuXHRcdFx0dGhpcy5maWxsTW9udGhzKCk7XG5cdFx0XHR2YXIgcHJldk1vbnRoID0gVVRDRGF0ZSh5ZWFyLCBtb250aC0xLCAyOCwwLDAsMCwwKSxcblx0XHRcdFx0ZGF5ID0gRFBHbG9iYWwuZ2V0RGF5c0luTW9udGgocHJldk1vbnRoLmdldFVUQ0Z1bGxZZWFyKCksIHByZXZNb250aC5nZXRVVENNb250aCgpKTtcblx0XHRcdHByZXZNb250aC5zZXRVVENEYXRlKGRheSk7XG5cdFx0XHRwcmV2TW9udGguc2V0VVRDRGF0ZShkYXkgLSAocHJldk1vbnRoLmdldFVUQ0RheSgpIC0gdGhpcy5vLndlZWtTdGFydCArIDcpJTcpO1xuXHRcdFx0dmFyIG5leHRNb250aCA9IG5ldyBEYXRlKHByZXZNb250aCk7XG5cdFx0XHRuZXh0TW9udGguc2V0VVRDRGF0ZShuZXh0TW9udGguZ2V0VVRDRGF0ZSgpICsgNDIpO1xuXHRcdFx0bmV4dE1vbnRoID0gbmV4dE1vbnRoLnZhbHVlT2YoKTtcblx0XHRcdHZhciBodG1sID0gW107XG5cdFx0XHR2YXIgY2xzTmFtZTtcblx0XHRcdHdoaWxlKHByZXZNb250aC52YWx1ZU9mKCkgPCBuZXh0TW9udGgpIHtcblx0XHRcdFx0aWYgKHByZXZNb250aC5nZXRVVENEYXkoKSA9PSB0aGlzLm8ud2Vla1N0YXJ0KSB7XG5cdFx0XHRcdFx0aHRtbC5wdXNoKCc8dHI+Jyk7XG5cdFx0XHRcdFx0aWYodGhpcy5vLmNhbGVuZGFyV2Vla3Mpe1xuXHRcdFx0XHRcdFx0Ly8gSVNPIDg2MDE6IEZpcnN0IHdlZWsgY29udGFpbnMgZmlyc3QgdGh1cnNkYXkuXG5cdFx0XHRcdFx0XHQvLyBJU08gYWxzbyBzdGF0ZXMgd2VlayBzdGFydHMgb24gTW9uZGF5LCBidXQgd2UgY2FuIGJlIG1vcmUgYWJzdHJhY3QgaGVyZS5cblx0XHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0XHQvLyBTdGFydCBvZiBjdXJyZW50IHdlZWs6IGJhc2VkIG9uIHdlZWtzdGFydC9jdXJyZW50IGRhdGVcblx0XHRcdFx0XHRcdFx0d3MgPSBuZXcgRGF0ZSgrcHJldk1vbnRoICsgKHRoaXMuby53ZWVrU3RhcnQgLSBwcmV2TW9udGguZ2V0VVRDRGF5KCkgLSA3KSAlIDcgKiA4NjRlNSksXG5cdFx0XHRcdFx0XHRcdC8vIFRodXJzZGF5IG9mIHRoaXMgd2Vla1xuXHRcdFx0XHRcdFx0XHR0aCA9IG5ldyBEYXRlKCt3cyArICg3ICsgNCAtIHdzLmdldFVUQ0RheSgpKSAlIDcgKiA4NjRlNSksXG5cdFx0XHRcdFx0XHRcdC8vIEZpcnN0IFRodXJzZGF5IG9mIHllYXIsIHllYXIgZnJvbSB0aHVyc2RheVxuXHRcdFx0XHRcdFx0XHR5dGggPSBuZXcgRGF0ZSgrKHl0aCA9IFVUQ0RhdGUodGguZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpICsgKDcgKyA0IC0geXRoLmdldFVUQ0RheSgpKSU3Kjg2NGU1KSxcblx0XHRcdFx0XHRcdFx0Ly8gQ2FsZW5kYXIgd2VlazogbXMgYmV0d2VlbiB0aHVyc2RheXMsIGRpdiBtcyBwZXIgZGF5LCBkaXYgNyBkYXlzXG5cdFx0XHRcdFx0XHRcdGNhbFdlZWsgPSAgKHRoIC0geXRoKSAvIDg2NGU1IC8gNyArIDE7XG5cdFx0XHRcdFx0XHRodG1sLnB1c2goJzx0ZCBjbGFzcz1cImN3XCI+JysgY2FsV2VlayArJzwvdGQ+Jyk7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2xzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lcyhwcmV2TW9udGgpO1xuXHRcdFx0XHRjbHNOYW1lLnB1c2goJ2RheScpO1xuXG5cdFx0XHRcdHZhciBiZWZvcmUgPSB0aGlzLm8uYmVmb3JlU2hvd0RheShwcmV2TW9udGgpO1xuXHRcdFx0XHRpZiAoYmVmb3JlID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0YmVmb3JlID0ge307XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZihiZWZvcmUpID09PSAnYm9vbGVhbicpXG5cdFx0XHRcdFx0YmVmb3JlID0ge2VuYWJsZWQ6IGJlZm9yZX07XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZihiZWZvcmUpID09PSAnc3RyaW5nJylcblx0XHRcdFx0XHRiZWZvcmUgPSB7Y2xhc3NlczogYmVmb3JlfTtcblx0XHRcdFx0aWYgKGJlZm9yZS5lbmFibGVkID09PSBmYWxzZSlcblx0XHRcdFx0XHRjbHNOYW1lLnB1c2goJ2Rpc2FibGVkJyk7XG5cdFx0XHRcdGlmIChiZWZvcmUuY2xhc3Nlcylcblx0XHRcdFx0XHRjbHNOYW1lID0gY2xzTmFtZS5jb25jYXQoYmVmb3JlLmNsYXNzZXMuc3BsaXQoL1xccysvKSk7XG5cdFx0XHRcdGlmIChiZWZvcmUudG9vbHRpcClcblx0XHRcdFx0XHR0b29sdGlwID0gYmVmb3JlLnRvb2x0aXA7XG5cblx0XHRcdFx0Y2xzTmFtZSA9ICQudW5pcXVlKGNsc05hbWUpO1xuXHRcdFx0XHRodG1sLnB1c2goJzx0ZCBjbGFzcz1cIicrY2xzTmFtZS5qb2luKCcgJykrJ1wiJyArICh0b29sdGlwID8gJyB0aXRsZT1cIicrdG9vbHRpcCsnXCInIDogJycpICsgJz4nK3ByZXZNb250aC5nZXRVVENEYXRlKCkgKyAnPC90ZD4nKTtcblx0XHRcdFx0aWYgKHByZXZNb250aC5nZXRVVENEYXkoKSA9PSB0aGlzLm8ud2Vla0VuZCkge1xuXHRcdFx0XHRcdGh0bWwucHVzaCgnPC90cj4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcmV2TW9udGguc2V0VVRDRGF0ZShwcmV2TW9udGguZ2V0VVRDRGF0ZSgpKzEpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItZGF5cyB0Ym9keScpLmVtcHR5KCkuYXBwZW5kKGh0bWwuam9pbignJykpO1xuXHRcdFx0dmFyIGN1cnJlbnRZZWFyID0gdGhpcy5kYXRlICYmIHRoaXMuZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuXG5cdFx0XHR2YXIgbW9udGhzID0gdGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzJylcblx0XHRcdFx0XHRcdC5maW5kKCd0aDplcSgxKScpXG5cdFx0XHRcdFx0XHRcdC50ZXh0KHllYXIpXG5cdFx0XHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdFx0LmZpbmQoJ3NwYW4nKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cdFx0XHRpZiAoY3VycmVudFllYXIgJiYgY3VycmVudFllYXIgPT0geWVhcikge1xuXHRcdFx0XHRtb250aHMuZXEodGhpcy5kYXRlLmdldFVUQ01vbnRoKCkpLmFkZENsYXNzKCdhY3RpdmUnKTtcblx0XHRcdH1cblx0XHRcdGlmICh5ZWFyIDwgc3RhcnRZZWFyIHx8IHllYXIgPiBlbmRZZWFyKSB7XG5cdFx0XHRcdG1vbnRocy5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblx0XHRcdH1cblx0XHRcdGlmICh5ZWFyID09IHN0YXJ0WWVhcikge1xuXHRcdFx0XHRtb250aHMuc2xpY2UoMCwgc3RhcnRNb250aCkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoeWVhciA9PSBlbmRZZWFyKSB7XG5cdFx0XHRcdG1vbnRocy5zbGljZShlbmRNb250aCsxKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblx0XHRcdH1cblxuXHRcdFx0aHRtbCA9ICcnO1xuXHRcdFx0eWVhciA9IHBhcnNlSW50KHllYXIvMTAsIDEwKSAqIDEwO1xuXHRcdFx0dmFyIHllYXJDb250ID0gdGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXIteWVhcnMnKVxuXHRcdFx0XHRcdFx0XHRcdC5maW5kKCd0aDplcSgxKScpXG5cdFx0XHRcdFx0XHRcdFx0XHQudGV4dCh5ZWFyICsgJy0nICsgKHllYXIgKyA5KSlcblx0XHRcdFx0XHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdFx0XHRcdC5maW5kKCd0ZCcpO1xuXHRcdFx0eWVhciAtPSAxO1xuXHRcdFx0Zm9yICh2YXIgaSA9IC0xOyBpIDwgMTE7IGkrKykge1xuXHRcdFx0XHRodG1sICs9ICc8c3BhbiBjbGFzcz1cInllYXInKyhpID09IC0xID8gJyBvbGQnIDogaSA9PSAxMCA/ICcgbmV3JyA6ICcnKSsoY3VycmVudFllYXIgPT0geWVhciA/ICcgYWN0aXZlJyA6ICcnKSsoeWVhciA8IHN0YXJ0WWVhciB8fCB5ZWFyID4gZW5kWWVhciA/ICcgZGlzYWJsZWQnIDogJycpKydcIj4nK3llYXIrJzwvc3Bhbj4nO1xuXHRcdFx0XHR5ZWFyICs9IDE7XG5cdFx0XHR9XG5cdFx0XHR5ZWFyQ29udC5odG1sKGh0bWwpO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVOYXZBcnJvd3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9hbGxvd191cGRhdGUpIHJldHVybjtcblxuXHRcdFx0dmFyIGQgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKSxcblx0XHRcdFx0eWVhciA9IGQuZ2V0VVRDRnVsbFllYXIoKSxcblx0XHRcdFx0bW9udGggPSBkLmdldFVUQ01vbnRoKCk7XG5cdFx0XHRzd2l0Y2ggKHRoaXMudmlld01vZGUpIHtcblx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdGlmICh0aGlzLm8uc3RhcnREYXRlICE9PSAtSW5maW5pdHkgJiYgeWVhciA8PSB0aGlzLm8uc3RhcnREYXRlLmdldFVUQ0Z1bGxZZWFyKCkgJiYgbW9udGggPD0gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENNb250aCgpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcucHJldicpLmNzcyh7dmlzaWJpbGl0eTogJ2hpZGRlbid9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLnByZXYnKS5jc3Moe3Zpc2liaWxpdHk6ICd2aXNpYmxlJ30pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5vLmVuZERhdGUgIT09IEluZmluaXR5ICYmIHllYXIgPj0gdGhpcy5vLmVuZERhdGUuZ2V0VVRDRnVsbFllYXIoKSAmJiBtb250aCA+PSB0aGlzLm8uZW5kRGF0ZS5nZXRVVENNb250aCgpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcubmV4dCcpLmNzcyh7dmlzaWJpbGl0eTogJ2hpZGRlbid9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLm5leHQnKS5jc3Moe3Zpc2liaWxpdHk6ICd2aXNpYmxlJ30pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0aWYgKHRoaXMuby5zdGFydERhdGUgIT09IC1JbmZpbml0eSAmJiB5ZWFyIDw9IHRoaXMuby5zdGFydERhdGUuZ2V0VVRDRnVsbFllYXIoKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLnByZXYnKS5jc3Moe3Zpc2liaWxpdHk6ICdoaWRkZW4nfSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5wcmV2JykuY3NzKHt2aXNpYmlsaXR5OiAndmlzaWJsZSd9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuby5lbmREYXRlICE9PSBJbmZpbml0eSAmJiB5ZWFyID49IHRoaXMuby5lbmREYXRlLmdldFVUQ0Z1bGxZZWFyKCkpIHtcblx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5uZXh0JykuY3NzKHt2aXNpYmlsaXR5OiAnaGlkZGVuJ30pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcubmV4dCcpLmNzcyh7dmlzaWJpbGl0eTogJ3Zpc2libGUnfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjbGljazogZnVuY3Rpb24oZSkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dmFyIHRhcmdldCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJ3NwYW4sIHRkLCB0aCcpO1xuXHRcdFx0aWYgKHRhcmdldC5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHRzd2l0Y2godGFyZ2V0WzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRjYXNlICd0aCc6XG5cdFx0XHRcdFx0XHRzd2l0Y2godGFyZ2V0WzBdLmNsYXNzTmFtZSkge1xuXHRcdFx0XHRcdFx0XHRjYXNlICdkYXRlcGlja2VyLXN3aXRjaCc6XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zaG93TW9kZSgxKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAncHJldic6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ25leHQnOlxuXHRcdFx0XHRcdFx0XHRcdHZhciBkaXIgPSBEUEdsb2JhbC5tb2Rlc1t0aGlzLnZpZXdNb2RlXS5uYXZTdGVwICogKHRhcmdldFswXS5jbGFzc05hbWUgPT0gJ3ByZXYnID8gLTEgOiAxKTtcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2godGhpcy52aWV3TW9kZSl7XG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSB0aGlzLm1vdmVNb250aCh0aGlzLnZpZXdEYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IHRoaXMubW92ZVllYXIodGhpcy52aWV3RGF0ZSwgZGlyKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlICd0b2RheSc6XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGUgPSBVVENEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSwgMCwgMCwgMCk7XG5cblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNob3dNb2RlKC0yKTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgd2hpY2ggPSB0aGlzLm8udG9kYXlCdG4gPT0gJ2xpbmtlZCcgPyBudWxsIDogJ3ZpZXcnO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NldERhdGUoZGF0ZSwgd2hpY2gpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlICdjbGVhcic6XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGVsZW1lbnQ7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuaXNJbnB1dClcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAodGhpcy5jb21wb25lbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0Jyk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtZW50LnZhbChcIlwiKS5jaGFuZ2UoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VEYXRlJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5vLmF1dG9jbG9zZSlcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnc3Bhbic6XG5cdFx0XHRcdFx0XHRpZiAoIXRhcmdldC5pcygnLmRpc2FibGVkJykpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy52aWV3RGF0ZS5zZXRVVENEYXRlKDEpO1xuXHRcdFx0XHRcdFx0XHRpZiAodGFyZ2V0LmlzKCcubW9udGgnKSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBkYXkgPSAxO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBtb250aCA9IHRhcmdldC5wYXJlbnQoKS5maW5kKCdzcGFuJykuaW5kZXgodGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgeWVhciA9IHRoaXMudmlld0RhdGUuZ2V0VVRDRnVsbFllYXIoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlLnNldFVUQ01vbnRoKG1vbnRoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VNb250aCcsIHRoaXMudmlld0RhdGUpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm8ubWluVmlld01vZGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NldERhdGUoVVRDRGF0ZSh5ZWFyLCBtb250aCwgZGF5LDAsMCwwLDApKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHllYXIgPSBwYXJzZUludCh0YXJnZXQudGV4dCgpLCAxMCl8fDA7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRheSA9IDE7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1vbnRoID0gMDtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZVllYXInLCB0aGlzLnZpZXdEYXRlKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5vLm1pblZpZXdNb2RlID09PSAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zZXREYXRlKFVUQ0RhdGUoeWVhciwgbW9udGgsIGRheSwwLDAsMCwwKSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2hvd01vZGUoLTEpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmZpbGwoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3RkJzpcblx0XHRcdFx0XHRcdGlmICh0YXJnZXQuaXMoJy5kYXknKSAmJiAhdGFyZ2V0LmlzKCcuZGlzYWJsZWQnKSl7XG5cdFx0XHRcdFx0XHRcdHZhciBkYXkgPSBwYXJzZUludCh0YXJnZXQudGV4dCgpLCAxMCl8fDE7XG5cdFx0XHRcdFx0XHRcdHZhciB5ZWFyID0gdGhpcy52aWV3RGF0ZS5nZXRVVENGdWxsWWVhcigpLFxuXHRcdFx0XHRcdFx0XHRcdG1vbnRoID0gdGhpcy52aWV3RGF0ZS5nZXRVVENNb250aCgpO1xuXHRcdFx0XHRcdFx0XHRpZiAodGFyZ2V0LmlzKCcub2xkJykpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAobW9udGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vbnRoID0gMTE7XG5cdFx0XHRcdFx0XHRcdFx0XHR5ZWFyIC09IDE7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vbnRoIC09IDE7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRhcmdldC5pcygnLm5ldycpKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG1vbnRoID09IDExKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb250aCA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHR5ZWFyICs9IDE7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vbnRoICs9IDE7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3NldERhdGUoVVRDRGF0ZSh5ZWFyLCBtb250aCwgZGF5LDAsMCwwLDApKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9zZXREYXRlOiBmdW5jdGlvbihkYXRlLCB3aGljaCl7XG5cdFx0XHRpZiAoIXdoaWNoIHx8IHdoaWNoID09ICdkYXRlJylcblx0XHRcdFx0dGhpcy5kYXRlID0gbmV3IERhdGUoZGF0ZSk7XG5cdFx0XHRpZiAoIXdoaWNoIHx8IHdoaWNoICA9PSAndmlldycpXG5cdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcblx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSgpO1xuXHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlRGF0ZScpO1xuXHRcdFx0dmFyIGVsZW1lbnQ7XG5cdFx0XHRpZiAodGhpcy5pc0lucHV0KSB7XG5cdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuY29tcG9uZW50KXtcblx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudC5maW5kKCdpbnB1dCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0ZWxlbWVudC5jaGFuZ2UoKTtcblx0XHRcdFx0aWYgKHRoaXMuby5hdXRvY2xvc2UgJiYgKCF3aGljaCB8fCB3aGljaCA9PSAnZGF0ZScpKSB7XG5cdFx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0bW92ZU1vbnRoOiBmdW5jdGlvbihkYXRlLCBkaXIpe1xuXHRcdFx0aWYgKCFkaXIpIHJldHVybiBkYXRlO1xuXHRcdFx0dmFyIG5ld19kYXRlID0gbmV3IERhdGUoZGF0ZS52YWx1ZU9mKCkpLFxuXHRcdFx0XHRkYXkgPSBuZXdfZGF0ZS5nZXRVVENEYXRlKCksXG5cdFx0XHRcdG1vbnRoID0gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKSxcblx0XHRcdFx0bWFnID0gTWF0aC5hYnMoZGlyKSxcblx0XHRcdFx0bmV3X21vbnRoLCB0ZXN0O1xuXHRcdFx0ZGlyID0gZGlyID4gMCA/IDEgOiAtMTtcblx0XHRcdGlmIChtYWcgPT0gMSl7XG5cdFx0XHRcdHRlc3QgPSBkaXIgPT0gLTFcblx0XHRcdFx0XHQvLyBJZiBnb2luZyBiYWNrIG9uZSBtb250aCwgbWFrZSBzdXJlIG1vbnRoIGlzIG5vdCBjdXJyZW50IG1vbnRoXG5cdFx0XHRcdFx0Ly8gKGVnLCBNYXIgMzEgLT4gRmViIDMxID09IEZlYiAyOCwgbm90IE1hciAwMilcblx0XHRcdFx0XHQ/IGZ1bmN0aW9uKCl7IHJldHVybiBuZXdfZGF0ZS5nZXRVVENNb250aCgpID09IG1vbnRoOyB9XG5cdFx0XHRcdFx0Ly8gSWYgZ29pbmcgZm9yd2FyZCBvbmUgbW9udGgsIG1ha2Ugc3VyZSBtb250aCBpcyBhcyBleHBlY3RlZFxuXHRcdFx0XHRcdC8vIChlZywgSmFuIDMxIC0+IEZlYiAzMSA9PSBGZWIgMjgsIG5vdCBNYXIgMDIpXG5cdFx0XHRcdFx0OiBmdW5jdGlvbigpeyByZXR1cm4gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKSAhPSBuZXdfbW9udGg7IH07XG5cdFx0XHRcdG5ld19tb250aCA9IG1vbnRoICsgZGlyO1xuXHRcdFx0XHRuZXdfZGF0ZS5zZXRVVENNb250aChuZXdfbW9udGgpO1xuXHRcdFx0XHQvLyBEZWMgLT4gSmFuICgxMikgb3IgSmFuIC0+IERlYyAoLTEpIC0tIGxpbWl0IGV4cGVjdGVkIGRhdGUgdG8gMC0xMVxuXHRcdFx0XHRpZiAobmV3X21vbnRoIDwgMCB8fCBuZXdfbW9udGggPiAxMSlcblx0XHRcdFx0XHRuZXdfbW9udGggPSAobmV3X21vbnRoICsgMTIpICUgMTI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBGb3IgbWFnbml0dWRlcyA+MSwgbW92ZSBvbmUgbW9udGggYXQgYSB0aW1lLi4uXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTxtYWc7IGkrKylcblx0XHRcdFx0XHQvLyAuLi53aGljaCBtaWdodCBkZWNyZWFzZSB0aGUgZGF5IChlZywgSmFuIDMxIHRvIEZlYiAyOCwgZXRjKS4uLlxuXHRcdFx0XHRcdG5ld19kYXRlID0gdGhpcy5tb3ZlTW9udGgobmV3X2RhdGUsIGRpcik7XG5cdFx0XHRcdC8vIC4uLnRoZW4gcmVzZXQgdGhlIGRheSwga2VlcGluZyBpdCBpbiB0aGUgbmV3IG1vbnRoXG5cdFx0XHRcdG5ld19tb250aCA9IG5ld19kYXRlLmdldFVUQ01vbnRoKCk7XG5cdFx0XHRcdG5ld19kYXRlLnNldFVUQ0RhdGUoZGF5KTtcblx0XHRcdFx0dGVzdCA9IGZ1bmN0aW9uKCl7IHJldHVybiBuZXdfbW9udGggIT0gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKTsgfTtcblx0XHRcdH1cblx0XHRcdC8vIENvbW1vbiBkYXRlLXJlc2V0dGluZyBsb29wIC0tIGlmIGRhdGUgaXMgYmV5b25kIGVuZCBvZiBtb250aCwgbWFrZSBpdFxuXHRcdFx0Ly8gZW5kIG9mIG1vbnRoXG5cdFx0XHR3aGlsZSAodGVzdCgpKXtcblx0XHRcdFx0bmV3X2RhdGUuc2V0VVRDRGF0ZSgtLWRheSk7XG5cdFx0XHRcdG5ld19kYXRlLnNldFVUQ01vbnRoKG5ld19tb250aCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3X2RhdGU7XG5cdFx0fSxcblxuXHRcdG1vdmVZZWFyOiBmdW5jdGlvbihkYXRlLCBkaXIpe1xuXHRcdFx0cmV0dXJuIHRoaXMubW92ZU1vbnRoKGRhdGUsIGRpcioxMik7XG5cdFx0fSxcblxuXHRcdGRhdGVXaXRoaW5SYW5nZTogZnVuY3Rpb24oZGF0ZSl7XG5cdFx0XHRyZXR1cm4gZGF0ZSA+PSB0aGlzLm8uc3RhcnREYXRlICYmIGRhdGUgPD0gdGhpcy5vLmVuZERhdGU7XG5cdFx0fSxcblxuXHRcdGtleWRvd246IGZ1bmN0aW9uKGUpe1xuXHRcdFx0aWYgKHRoaXMucGlja2VyLmlzKCc6bm90KDp2aXNpYmxlKScpKXtcblx0XHRcdFx0aWYgKGUua2V5Q29kZSA9PSAyNykgLy8gYWxsb3cgZXNjYXBlIHRvIGhpZGUgYW5kIHJlLXNob3cgcGlja2VyXG5cdFx0XHRcdFx0dGhpcy5zaG93KCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBkYXRlQ2hhbmdlZCA9IGZhbHNlLFxuXHRcdFx0XHRkaXIsIGRheSwgbW9udGgsXG5cdFx0XHRcdG5ld0RhdGUsIG5ld1ZpZXdEYXRlO1xuXHRcdFx0c3dpdGNoKGUua2V5Q29kZSl7XG5cdFx0XHRcdGNhc2UgMjc6IC8vIGVzY2FwZVxuXHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAzNzogLy8gbGVmdFxuXHRcdFx0XHRjYXNlIDM5OiAvLyByaWdodFxuXHRcdFx0XHRcdGlmICghdGhpcy5vLmtleWJvYXJkTmF2aWdhdGlvbikgYnJlYWs7XG5cdFx0XHRcdFx0ZGlyID0gZS5rZXlDb2RlID09IDM3ID8gLTEgOiAxO1xuXHRcdFx0XHRcdGlmIChlLmN0cmxLZXkpe1xuXHRcdFx0XHRcdFx0bmV3RGF0ZSA9IHRoaXMubW92ZVllYXIodGhpcy5kYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSB0aGlzLm1vdmVZZWFyKHRoaXMudmlld0RhdGUsIGRpcik7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlLnNoaWZ0S2V5KXtcblx0XHRcdFx0XHRcdG5ld0RhdGUgPSB0aGlzLm1vdmVNb250aCh0aGlzLmRhdGUsIGRpcik7XG5cdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZU1vbnRoKHRoaXMudmlld0RhdGUsIGRpcik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLmRhdGUpO1xuXHRcdFx0XHRcdFx0bmV3RGF0ZS5zZXRVVENEYXRlKHRoaXMuZGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIpO1xuXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlLnNldFVUQ0RhdGUodGhpcy52aWV3RGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5kYXRlV2l0aGluUmFuZ2UobmV3RGF0ZSkpe1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRlID0gbmV3RGF0ZTtcblx0XHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXdWaWV3RGF0ZTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRkYXRlQ2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDM4OiAvLyB1cFxuXHRcdFx0XHRjYXNlIDQwOiAvLyBkb3duXG5cdFx0XHRcdFx0aWYgKCF0aGlzLm8ua2V5Ym9hcmROYXZpZ2F0aW9uKSBicmVhaztcblx0XHRcdFx0XHRkaXIgPSBlLmtleUNvZGUgPT0gMzggPyAtMSA6IDE7XG5cdFx0XHRcdFx0aWYgKGUuY3RybEtleSl7XG5cdFx0XHRcdFx0XHRuZXdEYXRlID0gdGhpcy5tb3ZlWWVhcih0aGlzLmRhdGUsIGRpcik7XG5cdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZVllYXIodGhpcy52aWV3RGF0ZSwgZGlyKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGUuc2hpZnRLZXkpe1xuXHRcdFx0XHRcdFx0bmV3RGF0ZSA9IHRoaXMubW92ZU1vbnRoKHRoaXMuZGF0ZSwgZGlyKTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlID0gdGhpcy5tb3ZlTW9udGgodGhpcy52aWV3RGF0ZSwgZGlyKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuZGF0ZSk7XG5cdFx0XHRcdFx0XHRuZXdEYXRlLnNldFVUQ0RhdGUodGhpcy5kYXRlLmdldFVUQ0RhdGUoKSArIGRpciAqIDcpO1xuXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlLnNldFVUQ0RhdGUodGhpcy52aWV3RGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIgKiA3KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuZGF0ZVdpdGhpblJhbmdlKG5ld0RhdGUpKXtcblx0XHRcdFx0XHRcdHRoaXMuZGF0ZSA9IG5ld0RhdGU7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gbmV3Vmlld0RhdGU7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFZhbHVlKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0ZGF0ZUNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAxMzogLy8gZW50ZXJcblx0XHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgOTogLy8gdGFiXG5cdFx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0ZUNoYW5nZWQpe1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VEYXRlJyk7XG5cdFx0XHRcdHZhciBlbGVtZW50O1xuXHRcdFx0XHRpZiAodGhpcy5pc0lucHV0KSB7XG5cdFx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudCl7XG5cdFx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudC5maW5kKCdpbnB1dCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5jaGFuZ2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzaG93TW9kZTogZnVuY3Rpb24oZGlyKSB7XG5cdFx0XHRpZiAoZGlyKSB7XG5cdFx0XHRcdHRoaXMudmlld01vZGUgPSBNYXRoLm1heCh0aGlzLm8ubWluVmlld01vZGUsIE1hdGgubWluKDIsIHRoaXMudmlld01vZGUgKyBkaXIpKTtcblx0XHRcdH1cblx0XHRcdC8qXG5cdFx0XHRcdHZpdGFsZXRzOiBmaXhpbmcgYnVnIG9mIHZlcnkgc3BlY2lhbCBjb25kaXRpb25zOlxuXHRcdFx0XHRqcXVlcnkgMS43LjEgKyB3ZWJraXQgKyBzaG93IGlubGluZSBkYXRlcGlja2VyIGluIGJvb3RzdHJhcCBwb3BvdmVyLlxuXHRcdFx0XHRNZXRob2Qgc2hvdygpIGRvZXMgbm90IHNldCBkaXNwbGF5IGNzcyBjb3JyZWN0bHkgYW5kIGRhdGVwaWNrZXIgaXMgbm90IHNob3duLlxuXHRcdFx0XHRDaGFuZ2VkIHRvIC5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKSBzb2x2ZSB0aGUgcHJvYmxlbS5cblx0XHRcdFx0U2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlL2lzc3Vlcy8zN1xuXG5cdFx0XHRcdEluIGpxdWVyeSAxLjcuMisgZXZlcnl0aGluZyB3b3JrcyBmaW5lLlxuXHRcdFx0Ki9cblx0XHRcdC8vdGhpcy5waWNrZXIuZmluZCgnPmRpdicpLmhpZGUoKS5maWx0ZXIoJy5kYXRlcGlja2VyLScrRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZSkuc2hvdygpO1xuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnPmRpdicpLmhpZGUoKS5maWx0ZXIoJy5kYXRlcGlja2VyLScrRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZSkuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgRGF0ZVJhbmdlUGlja2VyID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucyl7XG5cdFx0dGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcblx0XHR0aGlzLmlucHV0cyA9ICQubWFwKG9wdGlvbnMuaW5wdXRzLCBmdW5jdGlvbihpKXsgcmV0dXJuIGkuanF1ZXJ5ID8gaVswXSA6IGk7IH0pO1xuXHRcdGRlbGV0ZSBvcHRpb25zLmlucHV0cztcblxuXHRcdCQodGhpcy5pbnB1dHMpXG5cdFx0XHQuZGF0ZXBpY2tlcihvcHRpb25zKVxuXHRcdFx0LmJpbmQoJ2NoYW5nZURhdGUnLCAkLnByb3h5KHRoaXMuZGF0ZVVwZGF0ZWQsIHRoaXMpKTtcblxuXHRcdHRoaXMucGlja2VycyA9ICQubWFwKHRoaXMuaW5wdXRzLCBmdW5jdGlvbihpKXsgcmV0dXJuICQoaSkuZGF0YSgnZGF0ZXBpY2tlcicpOyB9KTtcblx0XHR0aGlzLnVwZGF0ZURhdGVzKCk7XG5cdH07XG5cdERhdGVSYW5nZVBpY2tlci5wcm90b3R5cGUgPSB7XG5cdFx0dXBkYXRlRGF0ZXM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLmRhdGVzID0gJC5tYXAodGhpcy5waWNrZXJzLCBmdW5jdGlvbihpKXsgcmV0dXJuIGkuZGF0ZTsgfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZVJhbmdlcygpO1xuXHRcdH0sXG5cdFx0dXBkYXRlUmFuZ2VzOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHJhbmdlID0gJC5tYXAodGhpcy5kYXRlcywgZnVuY3Rpb24oZCl7IHJldHVybiBkLnZhbHVlT2YoKTsgfSk7XG5cdFx0XHQkLmVhY2godGhpcy5waWNrZXJzLCBmdW5jdGlvbihpLCBwKXtcblx0XHRcdFx0cC5zZXRSYW5nZShyYW5nZSk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdGRhdGVVcGRhdGVkOiBmdW5jdGlvbihlKXtcblx0XHRcdHZhciBkcCA9ICQoZS50YXJnZXQpLmRhdGEoJ2RhdGVwaWNrZXInKSxcblx0XHRcdFx0bmV3X2RhdGUgPSBkcC5nZXRVVENEYXRlKCksXG5cdFx0XHRcdGkgPSAkLmluQXJyYXkoZS50YXJnZXQsIHRoaXMuaW5wdXRzKSxcblx0XHRcdFx0bCA9IHRoaXMuaW5wdXRzLmxlbmd0aDtcblx0XHRcdGlmIChpID09IC0xKSByZXR1cm47XG5cblx0XHRcdGlmIChuZXdfZGF0ZSA8IHRoaXMuZGF0ZXNbaV0pe1xuXHRcdFx0XHQvLyBEYXRlIGJlaW5nIG1vdmVkIGVhcmxpZXIvbGVmdFxuXHRcdFx0XHR3aGlsZSAoaT49MCAmJiBuZXdfZGF0ZSA8IHRoaXMuZGF0ZXNbaV0pe1xuXHRcdFx0XHRcdHRoaXMucGlja2Vyc1tpLS1dLnNldFVUQ0RhdGUobmV3X2RhdGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChuZXdfZGF0ZSA+IHRoaXMuZGF0ZXNbaV0pe1xuXHRcdFx0XHQvLyBEYXRlIGJlaW5nIG1vdmVkIGxhdGVyL3JpZ2h0XG5cdFx0XHRcdHdoaWxlIChpPGwgJiYgbmV3X2RhdGUgPiB0aGlzLmRhdGVzW2ldKXtcblx0XHRcdFx0XHR0aGlzLnBpY2tlcnNbaSsrXS5zZXRVVENEYXRlKG5ld19kYXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy51cGRhdGVEYXRlcygpO1xuXHRcdH0sXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbigpe1xuXHRcdFx0JC5tYXAodGhpcy5waWNrZXJzLCBmdW5jdGlvbihwKXsgcC5yZW1vdmUoKTsgfSk7XG5cdFx0XHRkZWxldGUgdGhpcy5lbGVtZW50LmRhdGEoKS5kYXRlcGlja2VyO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBvcHRzX2Zyb21fZWwoZWwsIHByZWZpeCl7XG5cdFx0Ly8gRGVyaXZlIG9wdGlvbnMgZnJvbSBlbGVtZW50IGRhdGEtYXR0cnNcblx0XHR2YXIgZGF0YSA9ICQoZWwpLmRhdGEoKSxcblx0XHRcdG91dCA9IHt9LCBpbmtleSxcblx0XHRcdHJlcGxhY2UgPSBuZXcgUmVnRXhwKCdeJyArIHByZWZpeC50b0xvd2VyQ2FzZSgpICsgJyhbQS1aXSknKSxcblx0XHRcdHByZWZpeCA9IG5ldyBSZWdFeHAoJ14nICsgcHJlZml4LnRvTG93ZXJDYXNlKCkpO1xuXHRcdGZvciAodmFyIGtleSBpbiBkYXRhKVxuXHRcdFx0aWYgKHByZWZpeC50ZXN0KGtleSkpe1xuXHRcdFx0XHRpbmtleSA9IGtleS5yZXBsYWNlKHJlcGxhY2UsIGZ1bmN0aW9uKF8sYSl7IHJldHVybiBhLnRvTG93ZXJDYXNlKCk7IH0pO1xuXHRcdFx0XHRvdXRbaW5rZXldID0gZGF0YVtrZXldO1xuXHRcdFx0fVxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBvcHRzX2Zyb21fbG9jYWxlKGxhbmcpe1xuXHRcdC8vIERlcml2ZSBvcHRpb25zIGZyb20gbG9jYWxlIHBsdWdpbnNcblx0XHR2YXIgb3V0ID0ge307XG5cdFx0Ly8gQ2hlY2sgaWYgXCJkZS1ERVwiIHN0eWxlIGRhdGUgaXMgYXZhaWxhYmxlLCBpZiBub3QgbGFuZ3VhZ2Ugc2hvdWxkXG5cdFx0Ly8gZmFsbGJhY2sgdG8gMiBsZXR0ZXIgY29kZSBlZyBcImRlXCJcblx0XHRpZiAoIWRhdGVzW2xhbmddKSB7XG5cdFx0XHRsYW5nID0gbGFuZy5zcGxpdCgnLScpWzBdXG5cdFx0XHRpZiAoIWRhdGVzW2xhbmddKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBkID0gZGF0ZXNbbGFuZ107XG5cdFx0JC5lYWNoKGxvY2FsZV9vcHRzLCBmdW5jdGlvbihpLGspe1xuXHRcdFx0aWYgKGsgaW4gZClcblx0XHRcdFx0b3V0W2tdID0gZFtrXTtcblx0XHR9KTtcblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cblx0dmFyIG9sZCA9ICQuZm4uZGF0ZXBpY2tlcjtcblx0dmFyIGRhdGVwaWNrZXIgPSAkLmZuLmRhdGVwaWNrZXIgPSBmdW5jdGlvbiAoIG9wdGlvbiApIHtcblx0XHR2YXIgYXJncyA9IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0YXJncy5zaGlmdCgpO1xuXHRcdHZhciBpbnRlcm5hbF9yZXR1cm4sXG5cdFx0XHR0aGlzX3JldHVybjtcblx0XHR0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKSxcblx0XHRcdFx0ZGF0YSA9ICR0aGlzLmRhdGEoJ2RhdGVwaWNrZXInKSxcblx0XHRcdFx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uO1xuXHRcdFx0aWYgKCFkYXRhKSB7XG5cdFx0XHRcdHZhciBlbG9wdHMgPSBvcHRzX2Zyb21fZWwodGhpcywgJ2RhdGUnKSxcblx0XHRcdFx0XHQvLyBQcmVsaW1pbmFyeSBvdGlvbnNcblx0XHRcdFx0XHR4b3B0cyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZWxvcHRzLCBvcHRpb25zKSxcblx0XHRcdFx0XHRsb2NvcHRzID0gb3B0c19mcm9tX2xvY2FsZSh4b3B0cy5sYW5ndWFnZSksXG5cdFx0XHRcdFx0Ly8gT3B0aW9ucyBwcmlvcml0eToganMgYXJncywgZGF0YS1hdHRycywgbG9jYWxlcywgZGVmYXVsdHNcblx0XHRcdFx0XHRvcHRzID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBsb2NvcHRzLCBlbG9wdHMsIG9wdGlvbnMpO1xuXHRcdFx0XHRpZiAoJHRoaXMuaXMoJy5pbnB1dC1kYXRlcmFuZ2UnKSB8fCBvcHRzLmlucHV0cyl7XG5cdFx0XHRcdFx0dmFyIHJvcHRzID0ge1xuXHRcdFx0XHRcdFx0aW5wdXRzOiBvcHRzLmlucHV0cyB8fCAkdGhpcy5maW5kKCdpbnB1dCcpLnRvQXJyYXkoKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0JHRoaXMuZGF0YSgnZGF0ZXBpY2tlcicsIChkYXRhID0gbmV3IERhdGVSYW5nZVBpY2tlcih0aGlzLCAkLmV4dGVuZChvcHRzLCByb3B0cykpKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZXtcblx0XHRcdFx0XHQkdGhpcy5kYXRhKCdkYXRlcGlja2VyJywgKGRhdGEgPSBuZXcgRGF0ZXBpY2tlcih0aGlzLCBvcHRzKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGF0YVtvcHRpb25dID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aW50ZXJuYWxfcmV0dXJuID0gZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIGFyZ3MpO1xuXHRcdFx0XHRpZiAoaW50ZXJuYWxfcmV0dXJuICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlmIChpbnRlcm5hbF9yZXR1cm4gIT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiBpbnRlcm5hbF9yZXR1cm47XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0dmFyIGRlZmF1bHRzID0gJC5mbi5kYXRlcGlja2VyLmRlZmF1bHRzID0ge1xuXHRcdGF1dG9jbG9zZTogZmFsc2UsXG5cdFx0YmVmb3JlU2hvd0RheTogJC5ub29wLFxuXHRcdGNhbGVuZGFyV2Vla3M6IGZhbHNlLFxuXHRcdGNsZWFyQnRuOiBmYWxzZSxcblx0XHRkYXlzT2ZXZWVrRGlzYWJsZWQ6IFtdLFxuXHRcdGVuZERhdGU6IEluZmluaXR5LFxuXHRcdGZvcmNlUGFyc2U6IHRydWUsXG5cdFx0Zm9ybWF0OiAnbW0vZGQveXl5eScsXG5cdFx0a2V5Ym9hcmROYXZpZ2F0aW9uOiB0cnVlLFxuXHRcdGxhbmd1YWdlOiAnZW4nLFxuXHRcdG1pblZpZXdNb2RlOiAwLFxuXHRcdHJ0bDogZmFsc2UsXG5cdFx0c3RhcnREYXRlOiAtSW5maW5pdHksXG5cdFx0c3RhcnRWaWV3OiAwLFxuXHRcdHRvZGF5QnRuOiBmYWxzZSxcblx0XHR0b2RheUhpZ2hsaWdodDogZmFsc2UsXG5cdFx0d2Vla1N0YXJ0OiAwXG5cdH07XG5cdHZhciBsb2NhbGVfb3B0cyA9ICQuZm4uZGF0ZXBpY2tlci5sb2NhbGVfb3B0cyA9IFtcblx0XHQnZm9ybWF0Jyxcblx0XHQncnRsJyxcblx0XHQnd2Vla1N0YXJ0J1xuXHRdO1xuXHQkLmZuLmRhdGVwaWNrZXIuQ29uc3RydWN0b3IgPSBEYXRlcGlja2VyO1xuXHR2YXIgZGF0ZXMgPSAkLmZuLmRhdGVwaWNrZXIuZGF0ZXMgPSB7XG5cdFx0ZW46IHtcblx0XHRcdGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCIsIFwiU3VuZGF5XCJdLFxuXHRcdFx0ZGF5c1Nob3J0OiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiwgXCJTdW5cIl0sXG5cdFx0XHRkYXlzTWluOiBbXCJTdVwiLCBcIk1vXCIsIFwiVHVcIiwgXCJXZVwiLCBcIlRoXCIsIFwiRnJcIiwgXCJTYVwiLCBcIlN1XCJdLFxuXHRcdFx0bW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcblx0XHRcdG1vbnRoc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sXG5cdFx0XHR0b2RheTogXCJUb2RheVwiLFxuXHRcdFx0Y2xlYXI6IFwiQ2xlYXJcIlxuXHRcdH1cblx0fTtcblxuXHR2YXIgRFBHbG9iYWwgPSB7XG5cdFx0bW9kZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0Y2xzTmFtZTogJ2RheXMnLFxuXHRcdFx0XHRuYXZGbmM6ICdNb250aCcsXG5cdFx0XHRcdG5hdlN0ZXA6IDFcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGNsc05hbWU6ICdtb250aHMnLFxuXHRcdFx0XHRuYXZGbmM6ICdGdWxsWWVhcicsXG5cdFx0XHRcdG5hdlN0ZXA6IDFcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGNsc05hbWU6ICd5ZWFycycsXG5cdFx0XHRcdG5hdkZuYzogJ0Z1bGxZZWFyJyxcblx0XHRcdFx0bmF2U3RlcDogMTBcblx0XHR9XSxcblx0XHRpc0xlYXBZZWFyOiBmdW5jdGlvbiAoeWVhcikge1xuXHRcdFx0cmV0dXJuICgoKHllYXIgJSA0ID09PSAwKSAmJiAoeWVhciAlIDEwMCAhPT0gMCkpIHx8ICh5ZWFyICUgNDAwID09PSAwKSk7XG5cdFx0fSxcblx0XHRnZXREYXlzSW5Nb250aDogZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG5cdFx0XHRyZXR1cm4gWzMxLCAoRFBHbG9iYWwuaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjgpLCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1bbW9udGhdO1xuXHRcdH0sXG5cdFx0dmFsaWRQYXJ0czogL2RkP3xERD98bW0/fE1NP3x5eSg/Onl5KT8vZyxcblx0XHRub25wdW5jdHVhdGlvbjogL1teIC1cXC86LUBcXFtcXHUzNDAwLVxcdTlmZmYtYHstflxcdFxcblxccl0rL2csXG5cdFx0cGFyc2VGb3JtYXQ6IGZ1bmN0aW9uKGZvcm1hdCl7XG5cdFx0XHQvLyBJRSB0cmVhdHMgXFwwIGFzIGEgc3RyaW5nIGVuZCBpbiBpbnB1dHMgKHRydW5jYXRpbmcgdGhlIHZhbHVlKSxcblx0XHRcdC8vIHNvIGl0J3MgYSBiYWQgZm9ybWF0IGRlbGltaXRlciwgYW55d2F5XG5cdFx0XHR2YXIgc2VwYXJhdG9ycyA9IGZvcm1hdC5yZXBsYWNlKHRoaXMudmFsaWRQYXJ0cywgJ1xcMCcpLnNwbGl0KCdcXDAnKSxcblx0XHRcdFx0cGFydHMgPSBmb3JtYXQubWF0Y2godGhpcy52YWxpZFBhcnRzKTtcblx0XHRcdGlmICghc2VwYXJhdG9ycyB8fCAhc2VwYXJhdG9ycy5sZW5ndGggfHwgIXBhcnRzIHx8IHBhcnRzLmxlbmd0aCA9PT0gMCl7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtzZXBhcmF0b3JzOiBzZXBhcmF0b3JzLCBwYXJ0czogcGFydHN9O1xuXHRcdH0sXG5cdFx0cGFyc2VEYXRlOiBmdW5jdGlvbihkYXRlLCBmb3JtYXQsIGxhbmd1YWdlKSB7XG5cdFx0XHRpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBkYXRlO1xuXHRcdFx0aWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRmb3JtYXQgPSBEUEdsb2JhbC5wYXJzZUZvcm1hdChmb3JtYXQpO1xuXHRcdFx0aWYgKC9eW1xcLStdXFxkK1tkbXd5XShbXFxzLF0rW1xcLStdXFxkK1tkbXd5XSkqJC8udGVzdChkYXRlKSkge1xuXHRcdFx0XHR2YXIgcGFydF9yZSA9IC8oW1xcLStdXFxkKykoW2Rtd3ldKS8sXG5cdFx0XHRcdFx0cGFydHMgPSBkYXRlLm1hdGNoKC8oW1xcLStdXFxkKykoW2Rtd3ldKS9nKSxcblx0XHRcdFx0XHRwYXJ0LCBkaXI7XG5cdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRwYXJ0ID0gcGFydF9yZS5leGVjKHBhcnRzW2ldKTtcblx0XHRcdFx0XHRkaXIgPSBwYXJzZUludChwYXJ0WzFdKTtcblx0XHRcdFx0XHRzd2l0Y2gocGFydFsyXSl7XG5cdFx0XHRcdFx0XHRjYXNlICdkJzpcblx0XHRcdFx0XHRcdFx0ZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlyKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtJzpcblx0XHRcdFx0XHRcdFx0ZGF0ZSA9IERhdGVwaWNrZXIucHJvdG90eXBlLm1vdmVNb250aC5jYWxsKERhdGVwaWNrZXIucHJvdG90eXBlLCBkYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3cnOlxuXHRcdFx0XHRcdFx0XHRkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIgKiA3KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICd5Jzpcblx0XHRcdFx0XHRcdFx0ZGF0ZSA9IERhdGVwaWNrZXIucHJvdG90eXBlLm1vdmVZZWFyLmNhbGwoRGF0ZXBpY2tlci5wcm90b3R5cGUsIGRhdGUsIGRpcik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gVVRDRGF0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgZGF0ZS5nZXRVVENEYXRlKCksIDAsIDAsIDApO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHBhcnRzID0gZGF0ZSAmJiBkYXRlLm1hdGNoKHRoaXMubm9ucHVuY3R1YXRpb24pIHx8IFtdLFxuXHRcdFx0XHRkYXRlID0gbmV3IERhdGUoKSxcblx0XHRcdFx0cGFyc2VkID0ge30sXG5cdFx0XHRcdHNldHRlcnNfb3JkZXIgPSBbJ3l5eXknLCAneXknLCAnTScsICdNTScsICdtJywgJ21tJywgJ2QnLCAnZGQnXSxcblx0XHRcdFx0c2V0dGVyc19tYXAgPSB7XG5cdFx0XHRcdFx0eXl5eTogZnVuY3Rpb24oZCx2KXsgcmV0dXJuIGQuc2V0VVRDRnVsbFllYXIodik7IH0sXG5cdFx0XHRcdFx0eXk6IGZ1bmN0aW9uKGQsdil7IHJldHVybiBkLnNldFVUQ0Z1bGxZZWFyKDIwMDArdik7IH0sXG5cdFx0XHRcdFx0bTogZnVuY3Rpb24oZCx2KXtcblx0XHRcdFx0XHRcdHYgLT0gMTtcblx0XHRcdFx0XHRcdHdoaWxlICh2PDApIHYgKz0gMTI7XG5cdFx0XHRcdFx0XHR2ICU9IDEyO1xuXHRcdFx0XHRcdFx0ZC5zZXRVVENNb250aCh2KTtcblx0XHRcdFx0XHRcdHdoaWxlIChkLmdldFVUQ01vbnRoKCkgIT0gdilcblx0XHRcdFx0XHRcdFx0ZC5zZXRVVENEYXRlKGQuZ2V0VVRDRGF0ZSgpLTEpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGQ7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRkOiBmdW5jdGlvbihkLHYpeyByZXR1cm4gZC5zZXRVVENEYXRlKHYpOyB9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHZhbCwgZmlsdGVyZWQsIHBhcnQ7XG5cdFx0XHRzZXR0ZXJzX21hcFsnTSddID0gc2V0dGVyc19tYXBbJ01NJ10gPSBzZXR0ZXJzX21hcFsnbW0nXSA9IHNldHRlcnNfbWFwWydtJ107XG5cdFx0XHRzZXR0ZXJzX21hcFsnZGQnXSA9IHNldHRlcnNfbWFwWydkJ107XG5cdFx0XHRkYXRlID0gVVRDRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIDAsIDAsIDApO1xuXHRcdFx0dmFyIGZwYXJ0cyA9IGZvcm1hdC5wYXJ0cy5zbGljZSgpO1xuXHRcdFx0Ly8gUmVtb3ZlIG5vb3AgcGFydHNcblx0XHRcdGlmIChwYXJ0cy5sZW5ndGggIT0gZnBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHRmcGFydHMgPSAkKGZwYXJ0cykuZmlsdGVyKGZ1bmN0aW9uKGkscCl7XG5cdFx0XHRcdFx0cmV0dXJuICQuaW5BcnJheShwLCBzZXR0ZXJzX29yZGVyKSAhPT0gLTE7XG5cdFx0XHRcdH0pLnRvQXJyYXkoKTtcblx0XHRcdH1cblx0XHRcdC8vIFByb2Nlc3MgcmVtYWluZGVyXG5cdFx0XHRpZiAocGFydHMubGVuZ3RoID09IGZwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0Zm9yICh2YXIgaT0wLCBjbnQgPSBmcGFydHMubGVuZ3RoOyBpIDwgY250OyBpKyspIHtcblx0XHRcdFx0XHR2YWwgPSBwYXJzZUludChwYXJ0c1tpXSwgMTApO1xuXHRcdFx0XHRcdHBhcnQgPSBmcGFydHNbaV07XG5cdFx0XHRcdFx0aWYgKGlzTmFOKHZhbCkpIHtcblx0XHRcdFx0XHRcdHN3aXRjaChwYXJ0KSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ01NJzpcblx0XHRcdFx0XHRcdFx0XHRmaWx0ZXJlZCA9ICQoZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRocykuZmlsdGVyKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgbSA9IHRoaXMuc2xpY2UoMCwgcGFydHNbaV0ubGVuZ3RoKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cCA9IHBhcnRzW2ldLnNsaWNlKDAsIG0ubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBtID09IHA7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0dmFsID0gJC5pbkFycmF5KGZpbHRlcmVkWzBdLCBkYXRlc1tsYW5ndWFnZV0ubW9udGhzKSArIDE7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ00nOlxuXHRcdFx0XHRcdFx0XHRcdGZpbHRlcmVkID0gJChkYXRlc1tsYW5ndWFnZV0ubW9udGhzU2hvcnQpLmZpbHRlcihmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG0gPSB0aGlzLnNsaWNlKDAsIHBhcnRzW2ldLmxlbmd0aCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSBwYXJ0c1tpXS5zbGljZSgwLCBtLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbSA9PSBwO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdHZhbCA9ICQuaW5BcnJheShmaWx0ZXJlZFswXSwgZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRoc1Nob3J0KSArIDE7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcnNlZFtwYXJ0XSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHZhciBpPTAsIHM7IGk8c2V0dGVyc19vcmRlci5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0cyA9IHNldHRlcnNfb3JkZXJbaV07XG5cdFx0XHRcdFx0aWYgKHMgaW4gcGFyc2VkICYmICFpc05hTihwYXJzZWRbc10pKVxuXHRcdFx0XHRcdFx0c2V0dGVyc19tYXBbc10oZGF0ZSwgcGFyc2VkW3NdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRhdGU7XG5cdFx0fSxcblx0XHRmb3JtYXREYXRlOiBmdW5jdGlvbihkYXRlLCBmb3JtYXQsIGxhbmd1YWdlKXtcblx0XHRcdGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJylcblx0XHRcdFx0Zm9ybWF0ID0gRFBHbG9iYWwucGFyc2VGb3JtYXQoZm9ybWF0KTtcblx0XHRcdHZhciB2YWwgPSB7XG5cdFx0XHRcdGQ6IGRhdGUuZ2V0VVRDRGF0ZSgpLFxuXHRcdFx0XHREOiBkYXRlc1tsYW5ndWFnZV0uZGF5c1Nob3J0W2RhdGUuZ2V0VVRDRGF5KCldLFxuXHRcdFx0XHRERDogZGF0ZXNbbGFuZ3VhZ2VdLmRheXNbZGF0ZS5nZXRVVENEYXkoKV0sXG5cdFx0XHRcdG06IGRhdGUuZ2V0VVRDTW9udGgoKSArIDEsXG5cdFx0XHRcdE06IGRhdGVzW2xhbmd1YWdlXS5tb250aHNTaG9ydFtkYXRlLmdldFVUQ01vbnRoKCldLFxuXHRcdFx0XHRNTTogZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRoc1tkYXRlLmdldFVUQ01vbnRoKCldLFxuXHRcdFx0XHR5eTogZGF0ZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFxuXHRcdFx0XHR5eXl5OiBkYXRlLmdldFVUQ0Z1bGxZZWFyKClcblx0XHRcdH07XG5cdFx0XHR2YWwuZGQgPSAodmFsLmQgPCAxMCA/ICcwJyA6ICcnKSArIHZhbC5kO1xuXHRcdFx0dmFsLm1tID0gKHZhbC5tIDwgMTAgPyAnMCcgOiAnJykgKyB2YWwubTtcblx0XHRcdHZhciBkYXRlID0gW10sXG5cdFx0XHRcdHNlcHMgPSAkLmV4dGVuZChbXSwgZm9ybWF0LnNlcGFyYXRvcnMpO1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBjbnQgPSBmb3JtYXQucGFydHMubGVuZ3RoOyBpIDw9IGNudDsgaSsrKSB7XG5cdFx0XHRcdGlmIChzZXBzLmxlbmd0aClcblx0XHRcdFx0XHRkYXRlLnB1c2goc2Vwcy5zaGlmdCgpKTtcblx0XHRcdFx0ZGF0ZS5wdXNoKHZhbFtmb3JtYXQucGFydHNbaV1dKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkYXRlLmpvaW4oJycpO1xuXHRcdH0sXG5cdFx0aGVhZFRlbXBsYXRlOiAnPHRoZWFkPicrXG5cdFx0XHRcdFx0XHRcdCc8dHI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNsYXNzPVwicHJldlwiPjxpIGNsYXNzPVwiaWNvbi1hcnJvdy1sZWZ0XCIvPjwvdGg+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNvbHNwYW49XCI1XCIgY2xhc3M9XCJkYXRlcGlja2VyLXN3aXRjaFwiPjwvdGg+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNsYXNzPVwibmV4dFwiPjxpIGNsYXNzPVwiaWNvbi1hcnJvdy1yaWdodFwiLz48L3RoPicrXG5cdFx0XHRcdFx0XHRcdCc8L3RyPicrXG5cdFx0XHRcdFx0XHQnPC90aGVhZD4nLFxuXHRcdGNvbnRUZW1wbGF0ZTogJzx0Ym9keT48dHI+PHRkIGNvbHNwYW49XCI3XCI+PC90ZD48L3RyPjwvdGJvZHk+Jyxcblx0XHRmb290VGVtcGxhdGU6ICc8dGZvb3Q+PHRyPjx0aCBjb2xzcGFuPVwiN1wiIGNsYXNzPVwidG9kYXlcIj48L3RoPjwvdHI+PHRyPjx0aCBjb2xzcGFuPVwiN1wiIGNsYXNzPVwiY2xlYXJcIj48L3RoPjwvdHI+PC90Zm9vdD4nXG5cdH07XG5cdERQR2xvYmFsLnRlbXBsYXRlID0gJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyXCI+Jytcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWRheXNcIj4nK1xuXHRcdFx0XHRcdFx0XHRcdCc8dGFibGUgY2xhc3M9XCIgdGFibGUtY29uZGVuc2VkXCI+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdCc8dGJvZHk+PC90Ym9keT4nK1xuXHRcdFx0XHRcdFx0XHRcdFx0RFBHbG9iYWwuZm9vdFRlbXBsYXRlK1xuXHRcdFx0XHRcdFx0XHRcdCc8L3RhYmxlPicrXG5cdFx0XHRcdFx0XHRcdCc8L2Rpdj4nK1xuXHRcdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItbW9udGhzXCI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmNvbnRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xuXHRcdFx0XHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLXllYXJzXCI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmNvbnRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xuXHRcdFx0XHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdFx0XHRcdCc8L2Rpdj4nO1xuXG5cdCQuZm4uZGF0ZXBpY2tlci5EUEdsb2JhbCA9IERQR2xvYmFsO1xuXG5cblx0LyogREFURVBJQ0tFUiBOTyBDT05GTElDVFxuXHQqID09PT09PT09PT09PT09PT09PT0gKi9cblxuXHQkLmZuLmRhdGVwaWNrZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCl7XG5cdFx0JC5mbi5kYXRlcGlja2VyID0gb2xkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cblx0LyogREFURVBJQ0tFUiBEQVRBLUFQSVxuXHQqID09PT09PT09PT09PT09PT09PSAqL1xuXG5cdCQoZG9jdW1lbnQpLm9uKFxuXHRcdCdmb2N1cy5kYXRlcGlja2VyLmRhdGEtYXBpIGNsaWNrLmRhdGVwaWNrZXIuZGF0YS1hcGknLFxuXHRcdCdbZGF0YS1wcm92aWRlPVwiZGF0ZXBpY2tlclwiXScsXG5cdFx0ZnVuY3Rpb24oZSl7XG5cdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXHRcdFx0aWYgKCR0aGlzLmRhdGEoJ2RhdGVwaWNrZXInKSkgcmV0dXJuO1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0Ly8gY29tcG9uZW50IGNsaWNrIHJlcXVpcmVzIHVzIHRvIGV4cGxpY2l0bHkgc2hvdyBpdFxuXHRcdFx0ZGF0ZXBpY2tlci5jYWxsKCR0aGlzLCAnc2hvdycpO1xuXHRcdH1cblx0KTtcblx0JChmdW5jdGlvbigpe1xuXHRcdC8vJCgnW2RhdGEtcHJvdmlkZT1cImRhdGVwaWNrZXItaW5saW5lXCJdJykuZGF0ZXBpY2tlcigpO1xuICAgICAgICAvL3ZpdDogY2hhbmdlZCB0byBzdXBwb3J0IG5vQ29uZmxpY3QoKVxuICAgICAgICBkYXRlcGlja2VyLmNhbGwoJCgnW2RhdGEtcHJvdmlkZT1cImRhdGVwaWNrZXItaW5saW5lXCJdJykpO1xuXHR9KTtcblxufSggd2luZG93LmpRdWVyeSApKTtcblxuLyoqXG5Cb290c3RyYXAtZGF0ZXBpY2tlci4gIFxuRGVzY3JpcHRpb24gYW5kIGV4YW1wbGVzOiBodHRwczovL2dpdGh1Yi5jb20vZXRlcm5pY29kZS9ib290c3RyYXAtZGF0ZXBpY2tlci4gIFxuRm9yICoqaTE4bioqIHlvdSBzaG91bGQgaW5jbHVkZSBqcyBmaWxlIGZyb20gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL2V0ZXJuaWNvZGUvYm9vdHN0cmFwLWRhdGVwaWNrZXIvdHJlZS9tYXN0ZXIvanMvbG9jYWxlc1xuYW5kIHNldCBgbGFuZ3VhZ2VgIG9wdGlvbi4gIFxuU2luY2UgMS40LjAgZGF0ZSBoYXMgZGlmZmVyZW50IGFwcGVhcmFuY2UgaW4gKipwb3B1cCoqIGFuZCAqKmlubGluZSoqIG1vZGVzLiBcblxuQGNsYXNzIGRhdGVcbkBleHRlbmRzIGFic3RyYWN0aW5wdXRcbkBmaW5hbFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJkb2JcIiBkYXRhLXR5cGU9XCJkYXRlXCIgZGF0YS1waz1cIjFcIiBkYXRhLXVybD1cIi9wb3N0XCIgZGF0YS10aXRsZT1cIlNlbGVjdCBkYXRlXCI+MTUvMDUvMTk4NDwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI2RvYicpLmVkaXRhYmxlKHtcbiAgICAgICAgZm9ybWF0OiAneXl5eS1tbS1kZCcsICAgIFxuICAgICAgICB2aWV3Zm9ybWF0OiAnZGQvbW0veXl5eScsICAgIFxuICAgICAgICBkYXRlcGlja2VyOiB7XG4gICAgICAgICAgICAgICAgd2Vla1N0YXJ0OiAxXG4gICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIC8vc3RvcmUgYm9vdHN0cmFwLWRhdGVwaWNrZXIgYXMgYmRhdGVpY2tlciB0byBleGNsdWRlIGNvbmZsaWN0IHdpdGggalF1ZXJ5IFVJIG9uZVxuICAgICQuZm4uYmRhdGVwaWNrZXIgPSAkLmZuLmRhdGVwaWNrZXIubm9Db25mbGljdCgpO1xuICAgIGlmKCEkLmZuLmRhdGVwaWNrZXIpIHsgLy9pZiB0aGVyZSB3ZXJlIG5vIG90aGVyIGRhdGVwaWNrZXJzLCBrZWVwIGFsc28gb3JpZ2luYWwgbmFtZVxuICAgICAgICAkLmZuLmRhdGVwaWNrZXIgPSAkLmZuLmJkYXRlcGlja2VyOyAgICBcbiAgICB9ICAgIFxuICAgIFxuICAgIHZhciBEYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdkYXRlJywgb3B0aW9ucywgRGF0ZS5kZWZhdWx0cyk7XG4gICAgICAgIHRoaXMuaW5pdFBpY2tlcihvcHRpb25zLCBEYXRlLmRlZmF1bHRzKTtcbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoRGF0ZSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpOyAgICBcbiAgICBcbiAgICAkLmV4dGVuZChEYXRlLnByb3RvdHlwZSwge1xuICAgICAgICBpbml0UGlja2VyOiBmdW5jdGlvbihvcHRpb25zLCBkZWZhdWx0cykge1xuICAgICAgICAgICAgLy8nZm9ybWF0JyBpcyBzZXQgZGlyZWN0bHkgZnJvbSBzZXR0aW5ncyBvciBkYXRhLSogYXR0cmlidXRlc1xuXG4gICAgICAgICAgICAvL2J5IGRlZmF1bHQgdmlld2Zvcm1hdCBlcXVhbHMgdG8gZm9ybWF0XG4gICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLnZpZXdmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCA9IHRoaXMub3B0aW9ucy5mb3JtYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGRhdGVwaWNrZXIgY29uZmlnIGRlZmluZWQgYXMganNvbiBzdHJpbmcgaW4gZGF0YS1kYXRlcGlja2VyXG4gICAgICAgICAgICBvcHRpb25zLmRhdGVwaWNrZXIgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKG9wdGlvbnMuZGF0ZXBpY2tlciwgdHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vb3ZlcnJpZGluZyBkYXRlcGlja2VyIGNvbmZpZyAoYXMgYnkgZGVmYXVsdCBqUXVlcnkgZXh0ZW5kKCkgaXMgbm90IHJlY3Vyc2l2ZSlcbiAgICAgICAgICAgIC8vc2luY2UgMS40IGRhdGVwaWNrZXIgaW50ZXJuYWxseSB1c2VzIHZpZXdmb3JtYXQgaW5zdGVhZCBvZiBmb3JtYXQuIEZvcm1hdCBpcyBmb3Igc3VibWl0IG9ubHlcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kYXRlcGlja2VyID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLmRhdGVwaWNrZXIsIG9wdGlvbnMuZGF0ZXBpY2tlciwge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5vcHRpb25zLnZpZXdmb3JtYXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2xhbmd1YWdlXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlci5sYW5ndWFnZSA9IHRoaXMub3B0aW9ucy5kYXRlcGlja2VyLmxhbmd1YWdlIHx8ICdlbic7IFxuXG4gICAgICAgICAgICAvL3N0b3JlIERQZ2xvYmFsXG4gICAgICAgICAgICB0aGlzLmRwZyA9ICQuZm4uYmRhdGVwaWNrZXIuRFBHbG9iYWw7IFxuXG4gICAgICAgICAgICAvL3N0b3JlIHBhcnNlZCBmb3JtYXRzXG4gICAgICAgICAgICB0aGlzLnBhcnNlZEZvcm1hdCA9IHRoaXMuZHBnLnBhcnNlRm9ybWF0KHRoaXMub3B0aW9ucy5mb3JtYXQpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRWaWV3Rm9ybWF0ID0gdGhpcy5kcGcucGFyc2VGb3JtYXQodGhpcy5vcHRpb25zLnZpZXdmb3JtYXQpOyAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5iZGF0ZXBpY2tlcih0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vXCJjbGVhclwiIGxpbmtcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5jbGVhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyID0gJCgnPGEgaHJlZj1cIiNcIj48L2E+JykuaHRtbCh0aGlzLm9wdGlvbnMuY2xlYXIpLmNsaWNrKCQucHJveHkoZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiR0cGwucGFyZW50KCkuYXBwZW5kKCQoJzxkaXYgY2xhc3M9XCJlZGl0YWJsZS1jbGVhclwiPicpLmFwcGVuZCh0aGlzLiRjbGVhcikpOyAgXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgdmFyIHRleHQgPSB2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodmFsdWUsIHRoaXMucGFyc2VkVmlld0Zvcm1hdCwgdGhpcy5vcHRpb25zLmRhdGVwaWNrZXIubGFuZ3VhZ2UpIDogJyc7XG4gICAgICAgICAgIERhdGUuc3VwZXJjbGFzcy52YWx1ZTJodG1sLmNhbGwodGhpcywgdGV4dCwgZWxlbWVudCk7IFxuICAgICAgICB9LFxuXG4gICAgICAgIGh0bWwydmFsdWU6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGF0ZShodG1sLCB0aGlzLnBhcnNlZFZpZXdGb3JtYXQpO1xuICAgICAgICB9LCAgIFxuXG4gICAgICAgIHZhbHVlMnN0cjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodmFsdWUsIHRoaXMucGFyc2VkRm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlci5sYW5ndWFnZSkgOiAnJztcbiAgICAgICAgfSwgXG5cbiAgICAgICAgc3RyMnZhbHVlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGF0ZShzdHIsIHRoaXMucGFyc2VkRm9ybWF0KTtcbiAgICAgICAgfSwgXG5cbiAgICAgICAgdmFsdWUyc3VibWl0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUyc3RyKHZhbHVlKTtcbiAgICAgICAgfSwgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuYmRhdGVwaWNrZXIoJ3VwZGF0ZScsIHZhbHVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnB1dDJ2YWx1ZTogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LmRhdGEoJ2RhdGVwaWNrZXInKS5kYXRlO1xuICAgICAgICB9LCAgICAgICBcblxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXI6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmRhdGEoJ2RhdGVwaWNrZXInKS5kYXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmZpbmQoJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLnNob3didXR0b25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuY2xvc2VzdCgnZm9ybScpLnN1Ym1pdCgpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdXRvc3VibWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdtb3VzZXVwJywgJy5kYXknLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICBpZigkKGUuY3VycmVudFRhcmdldCkuaXMoJy5vbGQnKSB8fCAkKGUuY3VycmVudFRhcmdldCkuaXMoJy5uZXcnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAkZm9ybSA9ICQodGhpcykuY2xvc2VzdCgnZm9ybScpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgLy9jaGFuZ2VkYXRlIGlzIG5vdCBzdWl0YWJsZSBhcyBpdCB0cmlnZ2VyZWQgd2hlbiBzaG93aW5nIGRhdGVwaWNrZXIuIHNlZSAjMTQ5XG4gICAgICAgICAgIC8qXG4gICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdjaGFuZ2VEYXRlJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICB2YXIgJGZvcm0gPSAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgJGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgICAgKi9cbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgIEZvciBpbmNvcnJlY3QgZGF0ZSBib290c3RyYXAtZGF0ZXBpY2tlciByZXR1cm5zIGN1cnJlbnQgZGF0ZSB0aGF0IGlzIG5vdCBzdWl0YWJsZVxuICAgICAgICBmb3IgZGF0ZWZpZWxkLlxuICAgICAgICBUaGlzIGZ1bmN0aW9uIHJldHVybnMgbnVsbCBmb3IgaW5jb3JyZWN0IGRhdGUuICBcbiAgICAgICAqL1xuICAgICAgIHBhcnNlRGF0ZTogZnVuY3Rpb24oc3RyLCBmb3JtYXQpIHtcbiAgICAgICAgICAgdmFyIGRhdGUgPSBudWxsLCBmb3JtYXR0ZWRCYWNrO1xuICAgICAgICAgICBpZihzdHIpIHtcbiAgICAgICAgICAgICAgIGRhdGUgPSB0aGlzLmRwZy5wYXJzZURhdGUoc3RyLCBmb3JtYXQsIHRoaXMub3B0aW9ucy5kYXRlcGlja2VyLmxhbmd1YWdlKTtcbiAgICAgICAgICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkQmFjayA9IHRoaXMuZHBnLmZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlci5sYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgICAgaWYoc3RyICE9PSBmb3JtYXR0ZWRCYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIERhdGUuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEBkZWZhdWx0IDxkaXY+PC9kaXY+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0cGw6JzxkaXYgY2xhc3M9XCJlZGl0YWJsZS1kYXRlIHdlbGxcIj48L2Rpdj4nLFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3MgXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovXG4gICAgICAgIGlucHV0Y2xhc3M6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBGb3JtYXQgdXNlZCBmb3Igc2VuZGluZyB2YWx1ZSB0byBzZXJ2ZXIuIEFsc28gYXBwbGllZCB3aGVuIGNvbnZlcnRpbmcgZGF0ZSBmcm9tIDxjb2RlPmRhdGEtdmFsdWU8L2NvZGU+IGF0dHJpYnV0ZS48YnI+XG4gICAgICAgIFBvc3NpYmxlIHRva2VucyBhcmU6IDxjb2RlPmQsIGRkLCBtLCBtbSwgeXksIHl5eXk8L2NvZGU+ICBcblxuICAgICAgICBAcHJvcGVydHkgZm9ybWF0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgeXl5eS1tbS1kZFxuICAgICAgICAqKi9cbiAgICAgICAgZm9ybWF0Oid5eXl5LW1tLWRkJyxcbiAgICAgICAgLyoqXG4gICAgICAgIEZvcm1hdCB1c2VkIGZvciBkaXNwbGF5aW5nIGRhdGUuIEFsc28gYXBwbGllZCB3aGVuIGNvbnZlcnRpbmcgZGF0ZSBmcm9tIGVsZW1lbnQncyB0ZXh0IG9uIGluaXQuICAgXG4gICAgICAgIElmIG5vdCBzcGVjaWZpZWQgZXF1YWxzIHRvIDxjb2RlPmZvcm1hdDwvY29kZT5cblxuICAgICAgICBAcHJvcGVydHkgdmlld2Zvcm1hdCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovXG4gICAgICAgIHZpZXdmb3JtYXQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBDb25maWd1cmF0aW9uIG9mIGRhdGVwaWNrZXIuXG4gICAgICAgIEZ1bGwgbGlzdCBvZiBvcHRpb25zOiBodHRwOi8vYm9vdHN0cmFwLWRhdGVwaWNrZXIucmVhZHRoZWRvY3Mub3JnL2VuL2xhdGVzdC9vcHRpb25zLmh0bWxcblxuICAgICAgICBAcHJvcGVydHkgZGF0ZXBpY2tlciBcbiAgICAgICAgQHR5cGUgb2JqZWN0XG4gICAgICAgIEBkZWZhdWx0IHtcbiAgICAgICAgICAgIHdlZWtTdGFydDogMCxcbiAgICAgICAgICAgIHN0YXJ0VmlldzogMCxcbiAgICAgICAgICAgIG1pblZpZXdNb2RlOiAwLFxuICAgICAgICAgICAgYXV0b2Nsb3NlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgICoqL1xuICAgICAgICBkYXRlcGlja2VyOntcbiAgICAgICAgICAgIHdlZWtTdGFydDogMCxcbiAgICAgICAgICAgIHN0YXJ0VmlldzogMCxcbiAgICAgICAgICAgIG1pblZpZXdNb2RlOiAwLFxuICAgICAgICAgICAgYXV0b2Nsb3NlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgVGV4dCBzaG93biBhcyBjbGVhciBkYXRlIGJ1dHRvbi4gXG4gICAgICAgIElmIDxjb2RlPmZhbHNlPC9jb2RlPiBjbGVhciBidXR0b24gd2lsbCBub3QgYmUgcmVuZGVyZWQuXG5cbiAgICAgICAgQHByb3BlcnR5IGNsZWFyIFxuICAgICAgICBAdHlwZSBib29sZWFufHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAneCBjbGVhcidcbiAgICAgICAgKiovXG4gICAgICAgIGNsZWFyOiAnJnRpbWVzOyBjbGVhcidcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5kYXRlID0gRGF0ZTtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuQm9vdHN0cmFwIGRhdGVmaWVsZCBpbnB1dCAtIG1vZGlmaWNhdGlvbiBmb3IgaW5saW5lIG1vZGUuXG5TaG93cyBub3JtYWwgPGlucHV0IHR5cGU9XCJ0ZXh0XCI+IGFuZCBiaW5kcyBwb3B1cCBkYXRlcGlja2VyLiAgXG5BdXRvbWF0aWNhbGx5IHNob3duIGluIGlubGluZSBtb2RlLlxuXG5AY2xhc3MgZGF0ZWZpZWxkXG5AZXh0ZW5kcyBkYXRlXG5cbkBzaW5jZSAxLjQuMFxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG4gICAgXG4gICAgdmFyIERhdGVGaWVsZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgnZGF0ZWZpZWxkJywgb3B0aW9ucywgRGF0ZUZpZWxkLmRlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5pbml0UGlja2VyKG9wdGlvbnMsIERhdGVGaWVsZC5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KERhdGVGaWVsZCwgJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGUpOyAgICBcbiAgICBcbiAgICAkLmV4dGVuZChEYXRlRmllbGQucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQgPSB0aGlzLiR0cGwuZmluZCgnaW5wdXQnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cigncGxhY2Vob2xkZXInKTtcbiAgICBcbiAgICAgICAgICAgIC8vYm9vdHN0cmFwLWRhdGVwaWNrZXIgaXMgc2V0IGBiZGF0ZWlja2VyYCB0byBleGNsdWRlIGNvbmZsaWN0IHdpdGggalF1ZXJ5IFVJIG9uZS4gKGluIGRhdGUuanMpICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJHRwbC5iZGF0ZXBpY2tlcih0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vbmVlZCB0byBkaXNhYmxlIG9yaWdpbmFsIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vZmYoJ2ZvY3VzIGtleWRvd24nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy91cGRhdGUgdmFsdWUgb2YgZGF0ZXBpY2tlclxuICAgICAgICAgICAgdGhpcy4kaW5wdXQua2V5dXAoJC5wcm94eShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgdGhpcy4kdHBsLnJlbW92ZURhdGEoJ2RhdGUnKTtcbiAgICAgICAgICAgICAgIHRoaXMuJHRwbC5iZGF0ZXBpY2tlcigndXBkYXRlJyk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSwgICBcbiAgICAgICAgXG4gICAgICAgdmFsdWUyaW5wdXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHRoaXMuJGlucHV0LnZhbCh2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodmFsdWUsIHRoaXMucGFyc2VkVmlld0Zvcm1hdCwgdGhpcy5vcHRpb25zLmRhdGVwaWNrZXIubGFuZ3VhZ2UpIDogJycpO1xuICAgICAgICAgICB0aGlzLiR0cGwuYmRhdGVwaWNrZXIoJ3VwZGF0ZScpO1xuICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgIGlucHV0MnZhbHVlOiBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgIHJldHVybiB0aGlzLmh0bWwydmFsdWUodGhpcy4kaW5wdXQudmFsKCkpO1xuICAgICAgIH0sICAgICAgICAgICAgICBcbiAgICAgICAgXG4gICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAkLmZuLmVkaXRhYmxldHlwZXMudGV4dC5wcm90b3R5cGUuYWN0aXZhdGUuY2FsbCh0aGlzKTtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgLy9yZXNldCBhdXRvc3VibWl0IHRvIGVtcHR5ICBcbiAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgRGF0ZUZpZWxkLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5kYXRlLmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdHBsOic8ZGl2IGNsYXNzPVwiaW5wdXQtYXBwZW5kIGRhdGVcIj48aW5wdXQgdHlwZT1cInRleHRcIi8+PHNwYW4gY2xhc3M9XCJhZGQtb25cIj48aSBjbGFzcz1cImljb24tdGhcIj48L2k+PC9zcGFuPjwvZGl2PicsXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgaW5wdXRjbGFzcyBcbiAgICAgICAgQGRlZmF1bHQgJ2lucHV0LXNtYWxsJ1xuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgaW5wdXRjbGFzczogJ2lucHV0LXNtYWxsJyxcbiAgICAgICAgXG4gICAgICAgIC8qIGRhdGVwaWNrZXIgY29uZmlnICovXG4gICAgICAgIGRhdGVwaWNrZXI6IHtcbiAgICAgICAgICAgIHdlZWtTdGFydDogMCxcbiAgICAgICAgICAgIHN0YXJ0VmlldzogMCxcbiAgICAgICAgICAgIG1pblZpZXdNb2RlOiAwLFxuICAgICAgICAgICAgYXV0b2Nsb3NlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZWZpZWxkID0gRGF0ZUZpZWxkO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcbi8qKlxuQm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLiAgXG5CYXNlZCBvbiBbc21hbG90IGJvb3RzdHJhcC1kYXRldGltZXBpY2tlciBwbHVnaW5dKGh0dHBzOi8vZ2l0aHViLmNvbS9zbWFsb3QvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyKS4gXG5CZWZvcmUgdXNhZ2UgeW91IHNob3VsZCBtYW51YWxseSBpbmNsdWRlIGRlcGVuZGVudCBqcyBhbmQgY3NzOlxuXG4gICAgPGxpbmsgaHJlZj1cImNzcy9kYXRldGltZXBpY2tlci5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCI+PC9saW5rPiBcbiAgICA8c2NyaXB0IHNyYz1cImpzL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci5qc1wiPjwvc2NyaXB0PlxuXG5Gb3IgKippMThuKiogeW91IHNob3VsZCBpbmNsdWRlIGpzIGZpbGUgZnJvbSBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vc21hbG90L2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci90cmVlL21hc3Rlci9qcy9sb2NhbGVzXG5hbmQgc2V0IGBsYW5ndWFnZWAgb3B0aW9uLiAgXG5cbkBjbGFzcyBkYXRldGltZVxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQGZpbmFsXG5Ac2luY2UgMS40LjRcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwibGFzdF9zZWVuXCIgZGF0YS10eXBlPVwiZGF0ZXRpbWVcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiB0aXRsZT1cIlNlbGVjdCBkYXRlICYgdGltZVwiPjE1LzAzLzIwMTMgMTI6NDU8L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNsYXN0X3NlZW4nKS5lZGl0YWJsZSh7XG4gICAgICAgIGZvcm1hdDogJ3l5eXktbW0tZGQgaGg6aWknLCAgICBcbiAgICAgICAgdmlld2Zvcm1hdDogJ2RkL21tL3l5eXkgaGg6aWknLCAgICBcbiAgICAgICAgZGF0ZXRpbWVwaWNrZXI6IHtcbiAgICAgICAgICAgICAgICB3ZWVrU3RhcnQ6IDFcbiAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG5cbiAgICB2YXIgRGF0ZVRpbWUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2RhdGV0aW1lJywgb3B0aW9ucywgRGF0ZVRpbWUuZGVmYXVsdHMpO1xuICAgICAgICB0aGlzLmluaXRQaWNrZXIob3B0aW9ucywgRGF0ZVRpbWUuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChEYXRlVGltZSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpO1xuXG4gICAgJC5leHRlbmQoRGF0ZVRpbWUucHJvdG90eXBlLCB7XG4gICAgICAgIGluaXRQaWNrZXI6IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAvLydmb3JtYXQnIGlzIHNldCBkaXJlY3RseSBmcm9tIHNldHRpbmdzIG9yIGRhdGEtKiBhdHRyaWJ1dGVzXG5cbiAgICAgICAgICAgIC8vYnkgZGVmYXVsdCB2aWV3Zm9ybWF0IGVxdWFscyB0byBmb3JtYXRcbiAgICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy52aWV3Zm9ybWF0ID0gdGhpcy5vcHRpb25zLmZvcm1hdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy90cnkgcGFyc2UgZGF0ZXRpbWVwaWNrZXIgY29uZmlnIGRlZmluZWQgYXMganNvbiBzdHJpbmcgaW4gZGF0YS1kYXRldGltZXBpY2tlclxuICAgICAgICAgICAgb3B0aW9ucy5kYXRldGltZXBpY2tlciA9ICQuZm4uZWRpdGFibGV1dGlscy50cnlQYXJzZUpzb24ob3B0aW9ucy5kYXRldGltZXBpY2tlciwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vb3ZlcnJpZGluZyBkYXRldGltZXBpY2tlciBjb25maWcgKGFzIGJ5IGRlZmF1bHQgalF1ZXJ5IGV4dGVuZCgpIGlzIG5vdCByZWN1cnNpdmUpXG4gICAgICAgICAgICAvL3NpbmNlIDEuNCBkYXRldGltZXBpY2tlciBpbnRlcm5hbGx5IHVzZXMgdmlld2Zvcm1hdCBpbnN0ZWFkIG9mIGZvcm1hdC4gRm9ybWF0IGlzIGZvciBzdWJtaXQgb25seVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLmRhdGV0aW1lcGlja2VyLCBvcHRpb25zLmRhdGV0aW1lcGlja2VyLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vbGFuZ3VhZ2VcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlci5sYW5ndWFnZSA9IHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlci5sYW5ndWFnZSB8fCAnZW4nOyBcblxuICAgICAgICAgICAgLy9zdG9yZSBEUGdsb2JhbFxuICAgICAgICAgICAgdGhpcy5kcGcgPSAkLmZuLmRhdGV0aW1lcGlja2VyLkRQR2xvYmFsOyBcblxuICAgICAgICAgICAgLy9zdG9yZSBwYXJzZWQgZm9ybWF0c1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRGb3JtYXQgPSB0aGlzLmRwZy5wYXJzZUZvcm1hdCh0aGlzLm9wdGlvbnMuZm9ybWF0LCB0aGlzLm9wdGlvbnMuZm9ybWF0VHlwZSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFZpZXdGb3JtYXQgPSB0aGlzLmRwZy5wYXJzZUZvcm1hdCh0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCwgdGhpcy5vcHRpb25zLmZvcm1hdFR5cGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuZGF0ZXRpbWVwaWNrZXIodGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyKTtcblxuICAgICAgICAgICAgLy9hZGp1c3QgY29udGFpbmVyIHBvc2l0aW9uIHdoZW4gdmlld01vZGUgY2hhbmdlc1xuICAgICAgICAgICAgLy9zZWUgaHR0cHM6Ly9naXRodWIuY29tL3NtYWxvdC9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvcHVsbC84MFxuICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2NoYW5nZU1vZGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAvL3RpbWVvdXQgaGVyZSwgb3RoZXJ3aXNlIGNvbnRhaW5lciBjaGFuZ2VzIHBvc2l0aW9uIGJlZm9yZSBmb3JtIGhhcyBuZXcgc2l6ZVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgZi50cmlnZ2VySGFuZGxlcigncmVzaXplJyk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9cImNsZWFyXCIgbGlua1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmNsZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2xlYXIgPSAkKCc8YSBocmVmPVwiI1wiPjwvYT4nKS5odG1sKHRoaXMub3B0aW9ucy5jbGVhcikuY2xpY2soJC5wcm94eShmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy4kdHBsLnBhcmVudCgpLmFwcGVuZCgkKCc8ZGl2IGNsYXNzPVwiZWRpdGFibGUtY2xlYXJcIj4nKS5hcHBlbmQodGhpcy4kY2xlYXIpKTsgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlMmh0bWw6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAvL2Zvcm1hdERhdGUgd29ya3Mgd2l0aCBVVENEYXRlIVxuICAgICAgICAgICAgdmFyIHRleHQgPSB2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodGhpcy50b1VUQyh2YWx1ZSksIHRoaXMucGFyc2VkVmlld0Zvcm1hdCwgdGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyLmxhbmd1YWdlLCB0aGlzLm9wdGlvbnMuZm9ybWF0VHlwZSkgOiAnJztcbiAgICAgICAgICAgIGlmKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBEYXRlVGltZS5zdXBlcmNsYXNzLnZhbHVlMmh0bWwuY2FsbCh0aGlzLCB0ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgLy9wYXJzZURhdGUgcmV0dXJuIHV0YyBkYXRlIVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZURhdGUoaHRtbCwgdGhpcy5wYXJzZWRWaWV3Rm9ybWF0KTsgXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPyB0aGlzLmZyb21VVEModmFsdWUpIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZTJzdHI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAvL2Zvcm1hdERhdGUgd29ya3Mgd2l0aCBVVENEYXRlIVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdGhpcy5kcGcuZm9ybWF0RGF0ZSh0aGlzLnRvVVRDKHZhbHVlKSwgdGhpcy5wYXJzZWRGb3JtYXQsIHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlci5sYW5ndWFnZSwgdGhpcy5vcHRpb25zLmZvcm1hdFR5cGUpIDogJyc7XG4gICAgICAgfSxcblxuICAgICAgIHN0cjJ2YWx1ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgIC8vcGFyc2VEYXRlIHJldHVybiB1dGMgZGF0ZSFcbiAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZURhdGUoc3RyLCB0aGlzLnBhcnNlZEZvcm1hdCk7XG4gICAgICAgICAgIHJldHVybiB2YWx1ZSA/IHRoaXMuZnJvbVVUQyh2YWx1ZSkgOiBudWxsO1xuICAgICAgIH0sXG5cbiAgICAgICB2YWx1ZTJzdWJtaXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlMnN0cih2YWx1ZSk7XG4gICAgICAgfSxcblxuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICBpZih2YWx1ZSkge1xuICAgICAgICAgICAgIHRoaXMuJGlucHV0LmRhdGEoJ2RhdGV0aW1lcGlja2VyJykuc2V0RGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgIH1cbiAgICAgICB9LFxuXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgLy9kYXRlIG1heSBiZSBjbGVhcmVkLCBpbiB0aGF0IGNhc2UgZ2V0RGF0ZSgpIHRyaWdnZXJzIGVycm9yXG4gICAgICAgICAgIHZhciBkdCA9IHRoaXMuJGlucHV0LmRhdGEoJ2RhdGV0aW1lcGlja2VyJyk7XG4gICAgICAgICAgIHJldHVybiBkdC5kYXRlID8gZHQuZ2V0RGF0ZSgpIDogbnVsbDtcbiAgICAgICB9LFxuXG4gICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgIH0sXG5cbiAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy4kaW5wdXQuZGF0YSgnZGF0ZXRpbWVwaWNrZXInKS5kYXRlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiRpbnB1dC5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuc2hvd2J1dHRvbnMpIHtcbiAgICAgICAgICAgICB0aGlzLiRpbnB1dC5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7IFxuICAgICAgICAgIH0gICAgICAgICAgXG4gICAgICAgfSxcblxuICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC5vbignbW91c2V1cCcsICcubWludXRlJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICB2YXIgJGZvcm0gPSAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgJGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICB9KTtcbiAgICAgICB9LFxuXG4gICAgICAgLy9jb252ZXJ0IGRhdGUgZnJvbSBsb2NhbCB0byB1dGNcbiAgICAgICB0b1VUQzogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgIHJldHVybiB2YWx1ZSA/IG5ldyBEYXRlKHZhbHVlLnZhbHVlT2YoKSAtIHZhbHVlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMCkgOiB2YWx1ZTsgIFxuICAgICAgIH0sXG5cbiAgICAgICAvL2NvbnZlcnQgZGF0ZSBmcm9tIHV0YyB0byBsb2NhbFxuICAgICAgIGZyb21VVEM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICByZXR1cm4gdmFsdWUgPyBuZXcgRGF0ZSh2YWx1ZS52YWx1ZU9mKCkgKyB2YWx1ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApIDogdmFsdWU7ICBcbiAgICAgICB9LFxuXG4gICAgICAgLypcbiAgICAgICAgRm9yIGluY29ycmVjdCBkYXRlIGJvb3RzdHJhcC1kYXRldGltZXBpY2tlciByZXR1cm5zIGN1cnJlbnQgZGF0ZSB0aGF0IGlzIG5vdCBzdWl0YWJsZVxuICAgICAgICBmb3IgZGF0ZXRpbWVmaWVsZC5cbiAgICAgICAgVGhpcyBmdW5jdGlvbiByZXR1cm5zIG51bGwgZm9yIGluY29ycmVjdCBkYXRlLiAgXG4gICAgICAgKi9cbiAgICAgICBwYXJzZURhdGU6IGZ1bmN0aW9uKHN0ciwgZm9ybWF0KSB7XG4gICAgICAgICAgIHZhciBkYXRlID0gbnVsbCwgZm9ybWF0dGVkQmFjaztcbiAgICAgICAgICAgaWYoc3RyKSB7XG4gICAgICAgICAgICAgICBkYXRlID0gdGhpcy5kcGcucGFyc2VEYXRlKHN0ciwgZm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXRpbWVwaWNrZXIubGFuZ3VhZ2UsIHRoaXMub3B0aW9ucy5mb3JtYXRUeXBlKTtcbiAgICAgICAgICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkQmFjayA9IHRoaXMuZHBnLmZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXRpbWVwaWNrZXIubGFuZ3VhZ2UsIHRoaXMub3B0aW9ucy5mb3JtYXRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICBpZihzdHIgIT09IGZvcm1hdHRlZEJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIERhdGVUaW1lLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICBAZGVmYXVsdCA8ZGl2PjwvZGl2PlxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdHBsOic8ZGl2IGNsYXNzPVwiZWRpdGFibGUtZGF0ZSB3ZWxsXCI+PC9kaXY+JyxcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBpbnB1dGNsYXNzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgRm9ybWF0IHVzZWQgZm9yIHNlbmRpbmcgdmFsdWUgdG8gc2VydmVyLiBBbHNvIGFwcGxpZWQgd2hlbiBjb252ZXJ0aW5nIGRhdGUgZnJvbSA8Y29kZT5kYXRhLXZhbHVlPC9jb2RlPiBhdHRyaWJ1dGUuPGJyPlxuICAgICAgICBQb3NzaWJsZSB0b2tlbnMgYXJlOiA8Y29kZT5kLCBkZCwgbSwgbW0sIHl5LCB5eXl5LCBoLCBpPC9jb2RlPiAgXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgZm9ybWF0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgeXl5eS1tbS1kZCBoaDppaVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgZm9ybWF0Oid5eXl5LW1tLWRkIGhoOmlpJyxcbiAgICAgICAgZm9ybWF0VHlwZTonc3RhbmRhcmQnLFxuICAgICAgICAvKipcbiAgICAgICAgRm9ybWF0IHVzZWQgZm9yIGRpc3BsYXlpbmcgZGF0ZS4gQWxzbyBhcHBsaWVkIHdoZW4gY29udmVydGluZyBkYXRlIGZyb20gZWxlbWVudCdzIHRleHQgb24gaW5pdC4gICBcbiAgICAgICAgSWYgbm90IHNwZWNpZmllZCBlcXVhbHMgdG8gPGNvZGU+Zm9ybWF0PC9jb2RlPlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IHZpZXdmb3JtYXQgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICB2aWV3Zm9ybWF0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgQ29uZmlndXJhdGlvbiBvZiBkYXRldGltZXBpY2tlci5cbiAgICAgICAgRnVsbCBsaXN0IG9mIG9wdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9zbWFsb3QvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyXG5cbiAgICAgICAgQHByb3BlcnR5IGRhdGV0aW1lcGlja2VyIFxuICAgICAgICBAdHlwZSBvYmplY3RcbiAgICAgICAgQGRlZmF1bHQgeyB9XG4gICAgICAgICoqL1xuICAgICAgICBkYXRldGltZXBpY2tlcjp7XG4gICAgICAgICAgICB0b2RheUhpZ2hsaWdodDogZmFsc2UsXG4gICAgICAgICAgICBhdXRvY2xvc2U6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICBUZXh0IHNob3duIGFzIGNsZWFyIGRhdGUgYnV0dG9uLiBcbiAgICAgICAgSWYgPGNvZGU+ZmFsc2U8L2NvZGU+IGNsZWFyIGJ1dHRvbiB3aWxsIG5vdCBiZSByZW5kZXJlZC5cblxuICAgICAgICBAcHJvcGVydHkgY2xlYXIgXG4gICAgICAgIEB0eXBlIGJvb2xlYW58c3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICd4IGNsZWFyJ1xuICAgICAgICAqKi9cbiAgICAgICAgY2xlYXI6ICcmdGltZXM7IGNsZWFyJ1xuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGV0aW1lID0gRGF0ZVRpbWU7XG5cbn0od2luZG93LmpRdWVyeSkpO1xuLyoqXG5Cb290c3RyYXAgZGF0ZXRpbWVmaWVsZCBpbnB1dCAtIGRhdGV0aW1lIGlucHV0IGZvciBpbmxpbmUgbW9kZS5cblNob3dzIG5vcm1hbCA8aW5wdXQgdHlwZT1cInRleHRcIj4gYW5kIGJpbmRzIHBvcHVwIGRhdGV0aW1lcGlja2VyLiAgXG5BdXRvbWF0aWNhbGx5IHNob3duIGluIGlubGluZSBtb2RlLlxuXG5AY2xhc3MgZGF0ZXRpbWVmaWVsZFxuQGV4dGVuZHMgZGF0ZXRpbWVcblxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG4gICAgXG4gICAgdmFyIERhdGVUaW1lRmllbGQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2RhdGV0aW1lZmllbGQnLCBvcHRpb25zLCBEYXRlVGltZUZpZWxkLmRlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5pbml0UGlja2VyKG9wdGlvbnMsIERhdGVUaW1lRmllbGQuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChEYXRlVGltZUZpZWxkLCAkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZXRpbWUpO1xuICAgIFxuICAgICQuZXh0ZW5kKERhdGVUaW1lRmllbGQucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQgPSB0aGlzLiR0cGwuZmluZCgnaW5wdXQnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cigncGxhY2Vob2xkZXInKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kdHBsLmRhdGV0aW1lcGlja2VyKHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vbmVlZCB0byBkaXNhYmxlIG9yaWdpbmFsIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vZmYoJ2ZvY3VzIGtleWRvd24nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy91cGRhdGUgdmFsdWUgb2YgZGF0ZXBpY2tlclxuICAgICAgICAgICAgdGhpcy4kaW5wdXQua2V5dXAoJC5wcm94eShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgdGhpcy4kdHBsLnJlbW92ZURhdGEoJ2RhdGUnKTtcbiAgICAgICAgICAgICAgIHRoaXMuJHRwbC5kYXRldGltZXBpY2tlcigndXBkYXRlJyk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSwgICBcbiAgICAgIFxuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwodGhpcy52YWx1ZTJodG1sKHZhbHVlKSk7XG4gICAgICAgICAgIHRoaXMuJHRwbC5kYXRldGltZXBpY2tlcigndXBkYXRlJyk7XG4gICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuaHRtbDJ2YWx1ZSh0aGlzLiRpbnB1dC52YWwoKSk7XG4gICAgICAgfSwgICAgICAgICAgICAgIFxuICAgICAgICBcbiAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0LnByb3RvdHlwZS5hY3RpdmF0ZS5jYWxsKHRoaXMpO1xuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgYXV0b3N1Ym1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAvL3Jlc2V0IGF1dG9zdWJtaXQgdG8gZW1wdHkgIFxuICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBEYXRlVGltZUZpZWxkLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5kYXRldGltZS5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbCBcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHRwbDonPGRpdiBjbGFzcz1cImlucHV0LWFwcGVuZCBkYXRlXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIvPjxzcGFuIGNsYXNzPVwiYWRkLW9uXCI+PGkgY2xhc3M9XCJpY29uLXRoXCI+PC9pPjwvc3Bhbj48L2Rpdj4nLFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3MgXG4gICAgICAgIEBkZWZhdWx0ICdpbnB1dC1tZWRpdW0nXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBpbnB1dGNsYXNzOiAnaW5wdXQtbWVkaXVtJyxcbiAgICAgICAgXG4gICAgICAgIC8qIGRhdGV0aW1lcGlja2VyIGNvbmZpZyAqL1xuICAgICAgICBkYXRldGltZXBpY2tlcjp7XG4gICAgICAgICAgICB0b2RheUhpZ2hsaWdodDogZmFsc2UsXG4gICAgICAgICAgICBhdXRvY2xvc2U6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5kYXRldGltZWZpZWxkID0gRGF0ZVRpbWVGaWVsZDtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VkaXRhYmxlL2pzL2Jvb3RzdHJhcC1lZGl0YWJsZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n")},function(module,exports,__webpack_require__){eval('var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\n__webpack_require__(13);\n/*!\n * Bootstrap v3.3.5 (http://getbootstrap.com)\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under the MIT license\n */\nif ("undefined" == typeof jQuery) throw new Error("Bootstrap\'s JavaScript requires jQuery");+function (a) {\n  "use strict";\n  var b = a.fn.jquery.split(" ")[0].split(".");if (b[0] < 2 && b[1] < 9 || 1 == b[0] && 9 == b[1] && b[2] < 1) throw new Error("Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher");\n}(jQuery), +function (a) {\n  "use strict";\n  function b() {\n    var a = document.createElement("bootstrap"),\n        b = { WebkitTransition: "webkitTransitionEnd", MozTransition: "transitionend", OTransition: "oTransitionEnd otransitionend", transition: "transitionend" };for (var c in b) {\n      if (void 0 !== a.style[c]) return { end: b[c] };\n    }return !1;\n  }a.fn.emulateTransitionEnd = function (b) {\n    var c = !1,\n        d = this;a(this).one("bsTransitionEnd", function () {\n      c = !0;\n    });var e = function e() {\n      c || a(d).trigger(a.support.transition.end);\n    };return setTimeout(e, b), this;\n  }, a(function () {\n    a.support.transition = b(), a.support.transition && (a.event.special.bsTransitionEnd = { bindType: a.support.transition.end, delegateType: a.support.transition.end, handle: function handle(b) {\n        return a(b.target).is(this) ? b.handleObj.handler.apply(this, arguments) : void 0;\n      } });\n  });\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    return this.each(function () {\n      var c = a(this),\n          e = c.data("bs.alert");e || c.data("bs.alert", e = new d(this)), "string" == typeof b && e[b].call(c);\n    });\n  }var c = \'[data-dismiss="alert"]\',\n      d = function d(b) {\n    a(b).on("click", c, this.close);\n  };d.VERSION = "3.3.5", d.TRANSITION_DURATION = 150, d.prototype.close = function (b) {\n    function c() {\n      g.detach().trigger("closed.bs.alert").remove();\n    }var e = a(this),\n        f = e.attr("data-target");f || (f = e.attr("href"), f = f && f.replace(/.*(?=#[^\\s]*$)/, ""));var g = a(f);b && b.preventDefault(), g.length || (g = e.closest(".alert")), g.trigger(b = a.Event("close.bs.alert")), b.isDefaultPrevented() || (g.removeClass("in"), a.support.transition && g.hasClass("fade") ? g.one("bsTransitionEnd", c).emulateTransitionEnd(d.TRANSITION_DURATION) : c());\n  };var e = a.fn.alert;a.fn.alert = b, a.fn.alert.Constructor = d, a.fn.alert.noConflict = function () {\n    return a.fn.alert = e, this;\n  }, a(document).on("click.bs.alert.data-api", c, d.prototype.close);\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data("bs.button"),\n          f = "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b;e || d.data("bs.button", e = new c(this, f)), "toggle" == b ? e.toggle() : b && e.setState(b);\n    });\n  }var c = function c(b, d) {\n    this.$element = a(b), this.options = a.extend({}, c.DEFAULTS, d), this.isLoading = !1;\n  };c.VERSION = "3.3.5", c.DEFAULTS = { loadingText: "loading..." }, c.prototype.setState = function (b) {\n    var c = "disabled",\n        d = this.$element,\n        e = d.is("input") ? "val" : "html",\n        f = d.data();b += "Text", null == f.resetText && d.data("resetText", d[e]()), setTimeout(a.proxy(function () {\n      d[e](null == f[b] ? this.options[b] : f[b]), "loadingText" == b ? (this.isLoading = !0, d.addClass(c).attr(c, c)) : this.isLoading && (this.isLoading = !1, d.removeClass(c).removeAttr(c));\n    }, this), 0);\n  }, c.prototype.toggle = function () {\n    var a = !0,\n        b = this.$element.closest(\'[data-toggle="buttons"]\');if (b.length) {\n      var c = this.$element.find("input");"radio" == c.prop("type") ? (c.prop("checked") && (a = !1), b.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == c.prop("type") && (c.prop("checked") !== this.$element.hasClass("active") && (a = !1), this.$element.toggleClass("active")), c.prop("checked", this.$element.hasClass("active")), a && c.trigger("change");\n    } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active");\n  };var d = a.fn.button;a.fn.button = b, a.fn.button.Constructor = c, a.fn.button.noConflict = function () {\n    return a.fn.button = d, this;\n  }, a(document).on("click.bs.button.data-api", \'[data-toggle^="button"]\', function (c) {\n    var d = a(c.target);d.hasClass("btn") || (d = d.closest(".btn")), b.call(d, "toggle"), a(c.target).is(\'input[type="radio"]\') || a(c.target).is(\'input[type="checkbox"]\') || c.preventDefault();\n  }).on("focus.bs.button.data-api blur.bs.button.data-api", \'[data-toggle^="button"]\', function (b) {\n    a(b.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(b.type));\n  });\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data("bs.carousel"),\n          f = a.extend({}, c.DEFAULTS, d.data(), "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b),\n          g = "string" == typeof b ? b : f.slide;e || d.data("bs.carousel", e = new c(this, f)), "number" == typeof b ? e.to(b) : g ? e[g]() : f.interval && e.pause().cycle();\n    });\n  }var c = function c(b, _c) {\n    this.$element = a(b), this.$indicators = this.$element.find(".carousel-indicators"), this.options = _c, this.paused = null, this.sliding = null, this.interval = null, this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", a.proxy(this.keydown, this)), "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", a.proxy(this.pause, this)).on("mouseleave.bs.carousel", a.proxy(this.cycle, this));\n  };c.VERSION = "3.3.5", c.TRANSITION_DURATION = 600, c.DEFAULTS = { interval: 5e3, pause: "hover", wrap: !0, keyboard: !0 }, c.prototype.keydown = function (a) {\n    if (!/input|textarea/i.test(a.target.tagName)) {\n      switch (a.which) {case 37:\n          this.prev();break;case 39:\n          this.next();break;default:\n          return;}a.preventDefault();\n    }\n  }, c.prototype.cycle = function (b) {\n    return b || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(a.proxy(this.next, this), this.options.interval)), this;\n  }, c.prototype.getItemIndex = function (a) {\n    return this.$items = a.parent().children(".item"), this.$items.index(a || this.$active);\n  }, c.prototype.getItemForDirection = function (a, b) {\n    var c = this.getItemIndex(b),\n        d = "prev" == a && 0 === c || "next" == a && c == this.$items.length - 1;if (d && !this.options.wrap) return b;var e = "prev" == a ? -1 : 1,\n        f = (c + e) % this.$items.length;return this.$items.eq(f);\n  }, c.prototype.to = function (a) {\n    var b = this,\n        c = this.getItemIndex(this.$active = this.$element.find(".item.active"));return a > this.$items.length - 1 || 0 > a ? void 0 : this.sliding ? this.$element.one("slid.bs.carousel", function () {\n      b.to(a);\n    }) : c == a ? this.pause().cycle() : this.slide(a > c ? "next" : "prev", this.$items.eq(a));\n  }, c.prototype.pause = function (b) {\n    return b || (this.paused = !0), this.$element.find(".next, .prev").length && a.support.transition && (this.$element.trigger(a.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this;\n  }, c.prototype.next = function () {\n    return this.sliding ? void 0 : this.slide("next");\n  }, c.prototype.prev = function () {\n    return this.sliding ? void 0 : this.slide("prev");\n  }, c.prototype.slide = function (b, d) {\n    var e = this.$element.find(".item.active"),\n        f = d || this.getItemForDirection(b, e),\n        g = this.interval,\n        h = "next" == b ? "left" : "right",\n        i = this;if (f.hasClass("active")) return this.sliding = !1;var j = f[0],\n        k = a.Event("slide.bs.carousel", { relatedTarget: j, direction: h });if (this.$element.trigger(k), !k.isDefaultPrevented()) {\n      if (this.sliding = !0, g && this.pause(), this.$indicators.length) {\n        this.$indicators.find(".active").removeClass("active");var l = a(this.$indicators.children()[this.getItemIndex(f)]);l && l.addClass("active");\n      }var m = a.Event("slid.bs.carousel", { relatedTarget: j, direction: h });return a.support.transition && this.$element.hasClass("slide") ? (f.addClass(b), f[0].offsetWidth, e.addClass(h), f.addClass(h), e.one("bsTransitionEnd", function () {\n        f.removeClass([b, h].join(" ")).addClass("active"), e.removeClass(["active", h].join(" ")), i.sliding = !1, setTimeout(function () {\n          i.$element.trigger(m);\n        }, 0);\n      }).emulateTransitionEnd(c.TRANSITION_DURATION)) : (e.removeClass("active"), f.addClass("active"), this.sliding = !1, this.$element.trigger(m)), g && this.cycle(), this;\n    }\n  };var d = a.fn.carousel;a.fn.carousel = b, a.fn.carousel.Constructor = c, a.fn.carousel.noConflict = function () {\n    return a.fn.carousel = d, this;\n  };var e = function e(c) {\n    var d,\n        e = a(this),\n        f = a(e.attr("data-target") || (d = e.attr("href")) && d.replace(/.*(?=#[^\\s]+$)/, ""));if (f.hasClass("carousel")) {\n      var g = a.extend({}, f.data(), e.data()),\n          h = e.attr("data-slide-to");h && (g.interval = !1), b.call(f, g), h && f.data("bs.carousel").to(h), c.preventDefault();\n    }\n  };a(document).on("click.bs.carousel.data-api", "[data-slide]", e).on("click.bs.carousel.data-api", "[data-slide-to]", e), a(window).on("load", function () {\n    a(\'[data-ride="carousel"]\').each(function () {\n      var c = a(this);b.call(c, c.data());\n    });\n  });\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    var c,\n        d = b.attr("data-target") || (c = b.attr("href")) && c.replace(/.*(?=#[^\\s]+$)/, "");return a(d);\n  }function c(b) {\n    return this.each(function () {\n      var c = a(this),\n          e = c.data("bs.collapse"),\n          f = a.extend({}, d.DEFAULTS, c.data(), "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b);!e && f.toggle && /show|hide/.test(b) && (f.toggle = !1), e || c.data("bs.collapse", e = new d(this, f)), "string" == typeof b && e[b]();\n    });\n  }var d = function d(b, c) {\n    this.$element = a(b), this.options = a.extend({}, d.DEFAULTS, c), this.$trigger = a(\'[data-toggle="collapse"][href="#\' + b.id + \'"],[data-toggle="collapse"][data-target="#\' + b.id + \'"]\'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle();\n  };d.VERSION = "3.3.5", d.TRANSITION_DURATION = 350, d.DEFAULTS = { toggle: !0 }, d.prototype.dimension = function () {\n    var a = this.$element.hasClass("width");return a ? "width" : "height";\n  }, d.prototype.show = function () {\n    if (!this.transitioning && !this.$element.hasClass("in")) {\n      var b,\n          e = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");if (!(e && e.length && (b = e.data("bs.collapse"), b && b.transitioning))) {\n        var f = a.Event("show.bs.collapse");if (this.$element.trigger(f), !f.isDefaultPrevented()) {\n          e && e.length && (c.call(e, "hide"), b || e.data("bs.collapse", null));var g = this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded", !0), this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1;var h = function h() {\n            this.$element.removeClass("collapsing").addClass("collapse in")[g](""), this.transitioning = 0, this.$element.trigger("shown.bs.collapse");\n          };if (!a.support.transition) return h.call(this);var i = a.camelCase(["scroll", g].join("-"));this.$element.one("bsTransitionEnd", a.proxy(h, this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i]);\n        }\n      }\n    }\n  }, d.prototype.hide = function () {\n    if (!this.transitioning && this.$element.hasClass("in")) {\n      var b = a.Event("hide.bs.collapse");if (this.$element.trigger(b), !b.isDefaultPrevented()) {\n        var c = this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1;var e = function e() {\n          this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse");\n        };return a.support.transition ? void this.$element[c](0).one("bsTransitionEnd", a.proxy(e, this)).emulateTransitionEnd(d.TRANSITION_DURATION) : e.call(this);\n      }\n    }\n  }, d.prototype.toggle = function () {\n    this[this.$element.hasClass("in") ? "hide" : "show"]();\n  }, d.prototype.getParent = function () {\n    return a(this.options.parent).find(\'[data-toggle="collapse"][data-parent="\' + this.options.parent + \'"]\').each(a.proxy(function (c, d) {\n      var e = a(d);this.addAriaAndCollapsedClass(b(e), e);\n    }, this)).end();\n  }, d.prototype.addAriaAndCollapsedClass = function (a, b) {\n    var c = a.hasClass("in");a.attr("aria-expanded", c), b.toggleClass("collapsed", !c).attr("aria-expanded", c);\n  };var e = a.fn.collapse;a.fn.collapse = c, a.fn.collapse.Constructor = d, a.fn.collapse.noConflict = function () {\n    return a.fn.collapse = e, this;\n  }, a(document).on("click.bs.collapse.data-api", \'[data-toggle="collapse"]\', function (d) {\n    var e = a(this);e.attr("data-target") || d.preventDefault();var f = b(e),\n        g = f.data("bs.collapse"),\n        h = g ? "toggle" : e.data();c.call(f, h);\n  });\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    var c = b.attr("data-target");c || (c = b.attr("href"), c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\\s]*$)/, ""));var d = c && a(c);return d && d.length ? d : b.parent();\n  }function c(c) {\n    c && 3 === c.which || (a(e).remove(), a(f).each(function () {\n      var d = a(this),\n          e = b(d),\n          f = { relatedTarget: this };e.hasClass("open") && (c && "click" == c.type && /input|textarea/i.test(c.target.tagName) && a.contains(e[0], c.target) || (e.trigger(c = a.Event("hide.bs.dropdown", f)), c.isDefaultPrevented() || (d.attr("aria-expanded", "false"), e.removeClass("open").trigger("hidden.bs.dropdown", f))));\n    }));\n  }function d(b) {\n    return this.each(function () {\n      var c = a(this),\n          d = c.data("bs.dropdown");d || c.data("bs.dropdown", d = new g(this)), "string" == typeof b && d[b].call(c);\n    });\n  }var e = ".dropdown-backdrop",\n      f = \'[data-toggle="dropdown"]\',\n      g = function g(b) {\n    a(b).on("click.bs.dropdown", this.toggle);\n  };g.VERSION = "3.3.5", g.prototype.toggle = function (d) {\n    var e = a(this);if (!e.is(".disabled, :disabled")) {\n      var f = b(e),\n          g = f.hasClass("open");if (c(), !g) {\n        "ontouchstart" in document.documentElement && !f.closest(".navbar-nav").length && a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click", c);var h = { relatedTarget: this };if (f.trigger(d = a.Event("show.bs.dropdown", h)), d.isDefaultPrevented()) return;e.trigger("focus").attr("aria-expanded", "true"), f.toggleClass("open").trigger("shown.bs.dropdown", h);\n      }return !1;\n    }\n  }, g.prototype.keydown = function (c) {\n    if (/(38|40|27|32)/.test(c.which) && !/input|textarea/i.test(c.target.tagName)) {\n      var d = a(this);if (c.preventDefault(), c.stopPropagation(), !d.is(".disabled, :disabled")) {\n        var e = b(d),\n            g = e.hasClass("open");if (!g && 27 != c.which || g && 27 == c.which) return 27 == c.which && e.find(f).trigger("focus"), d.trigger("click");var h = " li:not(.disabled):visible a",\n            i = e.find(".dropdown-menu" + h);if (i.length) {\n          var j = i.index(c.target);38 == c.which && j > 0 && j--, 40 == c.which && j < i.length - 1 && j++, ~j || (j = 0), i.eq(j).trigger("focus");\n        }\n      }\n    }\n  };var h = a.fn.dropdown;a.fn.dropdown = d, a.fn.dropdown.Constructor = g, a.fn.dropdown.noConflict = function () {\n    return a.fn.dropdown = h, this;\n  }, a(document).on("click.bs.dropdown.data-api", c).on("click.bs.dropdown.data-api", ".dropdown form", function (a) {\n    a.stopPropagation();\n  }).on("click.bs.dropdown.data-api", f, g.prototype.toggle).on("keydown.bs.dropdown.data-api", f, g.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", g.prototype.keydown);\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b, d) {\n    return this.each(function () {\n      var e = a(this),\n          f = e.data("bs.modal"),\n          g = a.extend({}, c.DEFAULTS, e.data(), "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b);f || e.data("bs.modal", f = new c(this, g)), "string" == typeof b ? f[b](d) : g.show && f.show(d);\n    });\n  }var c = function c(b, _c2) {\n    this.options = _c2, this.$body = a(document.body), this.$element = a(b), this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, a.proxy(function () {\n      this.$element.trigger("loaded.bs.modal");\n    }, this));\n  };c.VERSION = "3.3.5", c.TRANSITION_DURATION = 300, c.BACKDROP_TRANSITION_DURATION = 150, c.DEFAULTS = { backdrop: !0, keyboard: !0, show: !0 }, c.prototype.toggle = function (a) {\n    return this.isShown ? this.hide() : this.show(a);\n  }, c.prototype.show = function (b) {\n    var d = this,\n        e = a.Event("show.bs.modal", { relatedTarget: b });this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", \'[data-dismiss="modal"]\', a.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", function () {\n      d.$element.one("mouseup.dismiss.bs.modal", function (b) {\n        a(b.target).is(d.$element) && (d.ignoreBackdropClick = !0);\n      });\n    }), this.backdrop(function () {\n      var e = a.support.transition && d.$element.hasClass("fade");d.$element.parent().length || d.$element.appendTo(d.$body), d.$element.show().scrollTop(0), d.adjustDialog(), e && d.$element[0].offsetWidth, d.$element.addClass("in"), d.enforceFocus();var f = a.Event("shown.bs.modal", { relatedTarget: b });e ? d.$dialog.one("bsTransitionEnd", function () {\n        d.$element.trigger("focus").trigger(f);\n      }).emulateTransitionEnd(c.TRANSITION_DURATION) : d.$element.trigger("focus").trigger(f);\n    }));\n  }, c.prototype.hide = function (b) {\n    b && b.preventDefault(), b = a.Event("hide.bs.modal"), this.$element.trigger(b), this.isShown && !b.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), a(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), a.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", a.proxy(this.hideModal, this)).emulateTransitionEnd(c.TRANSITION_DURATION) : this.hideModal());\n  }, c.prototype.enforceFocus = function () {\n    a(document).off("focusin.bs.modal").on("focusin.bs.modal", a.proxy(function (a) {\n      this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.trigger("focus");\n    }, this));\n  }, c.prototype.escape = function () {\n    this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", a.proxy(function (a) {\n      27 == a.which && this.hide();\n    }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal");\n  }, c.prototype.resize = function () {\n    this.isShown ? a(window).on("resize.bs.modal", a.proxy(this.handleUpdate, this)) : a(window).off("resize.bs.modal");\n  }, c.prototype.hideModal = function () {\n    var a = this;this.$element.hide(), this.backdrop(function () {\n      a.$body.removeClass("modal-open"), a.resetAdjustments(), a.resetScrollbar(), a.$element.trigger("hidden.bs.modal");\n    });\n  }, c.prototype.removeBackdrop = function () {\n    this.$backdrop && this.$backdrop.remove(), this.$backdrop = null;\n  }, c.prototype.backdrop = function (b) {\n    var d = this,\n        e = this.$element.hasClass("fade") ? "fade" : "";if (this.isShown && this.options.backdrop) {\n      var f = a.support.transition && e;if (this.$backdrop = a(document.createElement("div")).addClass("modal-backdrop " + e).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", a.proxy(function (a) {\n        return this.ignoreBackdropClick ? void (this.ignoreBackdropClick = !1) : void (a.target === a.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()));\n      }, this)), f && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !b) return;f ? this.$backdrop.one("bsTransitionEnd", b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : b();\n    } else if (!this.isShown && this.$backdrop) {\n      this.$backdrop.removeClass("in");var g = function g() {\n        d.removeBackdrop(), b && b();\n      };a.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : g();\n    } else b && b();\n  }, c.prototype.handleUpdate = function () {\n    this.adjustDialog();\n  }, c.prototype.adjustDialog = function () {\n    var a = this.$element[0].scrollHeight > document.documentElement.clientHeight;this.$element.css({ paddingLeft: !this.bodyIsOverflowing && a ? this.scrollbarWidth : "", paddingRight: this.bodyIsOverflowing && !a ? this.scrollbarWidth : "" });\n  }, c.prototype.resetAdjustments = function () {\n    this.$element.css({ paddingLeft: "", paddingRight: "" });\n  }, c.prototype.checkScrollbar = function () {\n    var a = window.innerWidth;if (!a) {\n      var b = document.documentElement.getBoundingClientRect();a = b.right - Math.abs(b.left);\n    }this.bodyIsOverflowing = document.body.clientWidth < a, this.scrollbarWidth = this.measureScrollbar();\n  }, c.prototype.setScrollbar = function () {\n    var a = parseInt(this.$body.css("padding-right") || 0, 10);this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", a + this.scrollbarWidth);\n  }, c.prototype.resetScrollbar = function () {\n    this.$body.css("padding-right", this.originalBodyPad);\n  }, c.prototype.measureScrollbar = function () {\n    var a = document.createElement("div");a.className = "modal-scrollbar-measure", this.$body.append(a);var b = a.offsetWidth - a.clientWidth;return this.$body[0].removeChild(a), b;\n  };var d = a.fn.modal;a.fn.modal = b, a.fn.modal.Constructor = c, a.fn.modal.noConflict = function () {\n    return a.fn.modal = d, this;\n  }, a(document).on("click.bs.modal.data-api", \'[data-toggle="modal"]\', function (c) {\n    var d = a(this),\n        e = d.attr("href"),\n        f = a(d.attr("data-target") || e && e.replace(/.*(?=#[^\\s]+$)/, "")),\n        g = f.data("bs.modal") ? "toggle" : a.extend({ remote: !/#/.test(e) && e }, f.data(), d.data());d.is("a") && c.preventDefault(), f.one("show.bs.modal", function (a) {\n      a.isDefaultPrevented() || f.one("hidden.bs.modal", function () {\n        d.is(":visible") && d.trigger("focus");\n      });\n    }), b.call(f, g, this);\n  });\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data("bs.tooltip"),\n          f = "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b;(e || !/destroy|hide/.test(b)) && (e || d.data("bs.tooltip", e = new c(this, f)), "string" == typeof b && e[b]());\n    });\n  }var c = function c(a, b) {\n    this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", a, b);\n  };c.VERSION = "3.3.5", c.TRANSITION_DURATION = 150, c.DEFAULTS = { animation: !0, placement: "top", selector: !1, template: \'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>\', trigger: "hover focus", title: "", delay: 0, html: !1, container: !1, viewport: { selector: "body", padding: 0 } }, c.prototype.init = function (b, c, d) {\n    if (this.enabled = !0, this.type = b, this.$element = a(c), this.options = this.getOptions(d), this.$viewport = this.options.viewport && a(a.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = { click: !1, hover: !1, focus: !1 }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");for (var e = this.options.trigger.split(" "), f = e.length; f--;) {\n      var g = e[f];if ("click" == g) this.$element.on("click." + this.type, this.options.selector, a.proxy(this.toggle, this));else if ("manual" != g) {\n        var h = "hover" == g ? "mouseenter" : "focusin",\n            i = "hover" == g ? "mouseleave" : "focusout";this.$element.on(h + "." + this.type, this.options.selector, a.proxy(this.enter, this)), this.$element.on(i + "." + this.type, this.options.selector, a.proxy(this.leave, this));\n      }\n    }this.options.selector ? this._options = a.extend({}, this.options, { trigger: "manual", selector: "" }) : this.fixTitle();\n  }, c.prototype.getDefaults = function () {\n    return c.DEFAULTS;\n  }, c.prototype.getOptions = function (b) {\n    return b = a.extend({}, this.getDefaults(), this.$element.data(), b), b.delay && "number" == typeof b.delay && (b.delay = { show: b.delay, hide: b.delay }), b;\n  }, c.prototype.getDelegateOptions = function () {\n    var b = {},\n        c = this.getDefaults();return this._options && a.each(this._options, function (a, d) {\n      c[a] != d && (b[a] = d);\n    }), b;\n  }, c.prototype.enter = function (b) {\n    var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type);return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusin" == b.type ? "focus" : "hover"] = !0), c.tip().hasClass("in") || "in" == c.hoverState ? void (c.hoverState = "in") : (clearTimeout(c.timeout), c.hoverState = "in", c.options.delay && c.options.delay.show ? void (c.timeout = setTimeout(function () {\n      "in" == c.hoverState && c.show();\n    }, c.options.delay.show)) : c.show());\n  }, c.prototype.isInStateTrue = function () {\n    for (var a in this.inState) {\n      if (this.inState[a]) return !0;\n    }return !1;\n  }, c.prototype.leave = function (b) {\n    var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type);return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusout" == b.type ? "focus" : "hover"] = !1), c.isInStateTrue() ? void 0 : (clearTimeout(c.timeout), c.hoverState = "out", c.options.delay && c.options.delay.hide ? void (c.timeout = setTimeout(function () {\n      "out" == c.hoverState && c.hide();\n    }, c.options.delay.hide)) : c.hide());\n  }, c.prototype.show = function () {\n    var b = a.Event("show.bs." + this.type);if (this.hasContent() && this.enabled) {\n      this.$element.trigger(b);var d = a.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);if (b.isDefaultPrevented() || !d) return;var e = this,\n          f = this.tip(),\n          g = this.getUID(this.type);this.setContent(), f.attr("id", g), this.$element.attr("aria-describedby", g), this.options.animation && f.addClass("fade");var h = "function" == typeof this.options.placement ? this.options.placement.call(this, f[0], this.$element[0]) : this.options.placement,\n          i = /\\s?auto?\\s?/i,\n          j = i.test(h);j && (h = h.replace(i, "") || "top"), f.detach().css({ top: 0, left: 0, display: "block" }).addClass(h).data("bs." + this.type, this), this.options.container ? f.appendTo(this.options.container) : f.insertAfter(this.$element), this.$element.trigger("inserted.bs." + this.type);var k = this.getPosition(),\n          l = f[0].offsetWidth,\n          m = f[0].offsetHeight;if (j) {\n        var n = h,\n            o = this.getPosition(this.$viewport);h = "bottom" == h && k.bottom + m > o.bottom ? "top" : "top" == h && k.top - m < o.top ? "bottom" : "right" == h && k.right + l > o.width ? "left" : "left" == h && k.left - l < o.left ? "right" : h, f.removeClass(n).addClass(h);\n      }var p = this.getCalculatedOffset(h, k, l, m);this.applyPlacement(p, h);var q = function q() {\n        var a = e.hoverState;e.$element.trigger("shown.bs." + e.type), e.hoverState = null, "out" == a && e.leave(e);\n      };a.support.transition && this.$tip.hasClass("fade") ? f.one("bsTransitionEnd", q).emulateTransitionEnd(c.TRANSITION_DURATION) : q();\n    }\n  }, c.prototype.applyPlacement = function (b, c) {\n    var d = this.tip(),\n        e = d[0].offsetWidth,\n        f = d[0].offsetHeight,\n        g = parseInt(d.css("margin-top"), 10),\n        h = parseInt(d.css("margin-left"), 10);isNaN(g) && (g = 0), isNaN(h) && (h = 0), b.top += g, b.left += h, a.offset.setOffset(d[0], a.extend({ using: function using(a) {\n        d.css({ top: Math.round(a.top), left: Math.round(a.left) });\n      } }, b), 0), d.addClass("in");var i = d[0].offsetWidth,\n        j = d[0].offsetHeight;"top" == c && j != f && (b.top = b.top + f - j);var k = this.getViewportAdjustedDelta(c, b, i, j);k.left ? b.left += k.left : b.top += k.top;var l = /top|bottom/.test(c),\n        m = l ? 2 * k.left - e + i : 2 * k.top - f + j,\n        n = l ? "offsetWidth" : "offsetHeight";d.offset(b), this.replaceArrow(m, d[0][n], l);\n  }, c.prototype.replaceArrow = function (a, b, c) {\n    this.arrow().css(c ? "left" : "top", 50 * (1 - a / b) + "%").css(c ? "top" : "left", "");\n  }, c.prototype.setContent = function () {\n    var a = this.tip(),\n        b = this.getTitle();a.find(".tooltip-inner")[this.options.html ? "html" : "text"](b), a.removeClass("fade in top bottom left right");\n  }, c.prototype.hide = function (b) {\n    function d() {\n      "in" != e.hoverState && f.detach(), e.$element.removeAttr("aria-describedby").trigger("hidden.bs." + e.type), b && b();\n    }var e = this,\n        f = a(this.$tip),\n        g = a.Event("hide.bs." + this.type);return this.$element.trigger(g), g.isDefaultPrevented() ? void 0 : (f.removeClass("in"), a.support.transition && f.hasClass("fade") ? f.one("bsTransitionEnd", d).emulateTransitionEnd(c.TRANSITION_DURATION) : d(), this.hoverState = null, this);\n  }, c.prototype.fixTitle = function () {\n    var a = this.$element;(a.attr("title") || "string" != typeof a.attr("data-original-title")) && a.attr("data-original-title", a.attr("title") || "").attr("title", "");\n  }, c.prototype.hasContent = function () {\n    return this.getTitle();\n  }, c.prototype.getPosition = function (b) {\n    b = b || this.$element;var c = b[0],\n        d = "BODY" == c.tagName,\n        e = c.getBoundingClientRect();null == e.width && (e = a.extend({}, e, { width: e.right - e.left, height: e.bottom - e.top }));var f = d ? { top: 0, left: 0 } : b.offset(),\n        g = { scroll: d ? document.documentElement.scrollTop || document.body.scrollTop : b.scrollTop() },\n        h = d ? { width: a(window).width(), height: a(window).height() } : null;return a.extend({}, e, g, h, f);\n  }, c.prototype.getCalculatedOffset = function (a, b, c, d) {\n    return "bottom" == a ? { top: b.top + b.height, left: b.left + b.width / 2 - c / 2 } : "top" == a ? { top: b.top - d, left: b.left + b.width / 2 - c / 2 } : "left" == a ? { top: b.top + b.height / 2 - d / 2, left: b.left - c } : { top: b.top + b.height / 2 - d / 2, left: b.left + b.width };\n  }, c.prototype.getViewportAdjustedDelta = function (a, b, c, d) {\n    var e = { top: 0, left: 0 };if (!this.$viewport) return e;var f = this.options.viewport && this.options.viewport.padding || 0,\n        g = this.getPosition(this.$viewport);if (/right|left/.test(a)) {\n      var h = b.top - f - g.scroll,\n          i = b.top + f - g.scroll + d;h < g.top ? e.top = g.top - h : i > g.top + g.height && (e.top = g.top + g.height - i);\n    } else {\n      var j = b.left - f,\n          k = b.left + f + c;j < g.left ? e.left = g.left - j : k > g.right && (e.left = g.left + g.width - k);\n    }return e;\n  }, c.prototype.getTitle = function () {\n    var a,\n        b = this.$element,\n        c = this.options;return a = b.attr("data-original-title") || ("function" == typeof c.title ? c.title.call(b[0]) : c.title);\n  }, c.prototype.getUID = function (a) {\n    do {\n      a += ~~(1e6 * Math.random());\n    } while (document.getElementById(a));return a;\n  }, c.prototype.tip = function () {\n    if (!this.$tip && (this.$tip = a(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");return this.$tip;\n  }, c.prototype.arrow = function () {\n    return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");\n  }, c.prototype.enable = function () {\n    this.enabled = !0;\n  }, c.prototype.disable = function () {\n    this.enabled = !1;\n  }, c.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled;\n  }, c.prototype.toggle = function (b) {\n    var c = this;b && (c = a(b.currentTarget).data("bs." + this.type), c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c))), b ? (c.inState.click = !c.inState.click, c.isInStateTrue() ? c.enter(c) : c.leave(c)) : c.tip().hasClass("in") ? c.leave(c) : c.enter(c);\n  }, c.prototype.destroy = function () {\n    var a = this;clearTimeout(this.timeout), this.hide(function () {\n      a.$element.off("." + a.type).removeData("bs." + a.type), a.$tip && a.$tip.detach(), a.$tip = null, a.$arrow = null, a.$viewport = null;\n    });\n  };var d = a.fn.tooltip;a.fn.tooltip = b, a.fn.tooltip.Constructor = c, a.fn.tooltip.noConflict = function () {\n    return a.fn.tooltip = d, this;\n  };\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data("bs.popover"),\n          f = "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b;(e || !/destroy|hide/.test(b)) && (e || d.data("bs.popover", e = new c(this, f)), "string" == typeof b && e[b]());\n    });\n  }var c = function c(a, b) {\n    this.init("popover", a, b);\n  };if (!a.fn.tooltip) throw new Error("Popover requires tooltip.js");c.VERSION = "3.3.5", c.DEFAULTS = a.extend({}, a.fn.tooltip.Constructor.DEFAULTS, { placement: "right", trigger: "click", content: "", template: \'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>\' }), c.prototype = a.extend({}, a.fn.tooltip.Constructor.prototype), c.prototype.constructor = c, c.prototype.getDefaults = function () {\n    return c.DEFAULTS;\n  }, c.prototype.setContent = function () {\n    var a = this.tip(),\n        b = this.getTitle(),\n        c = this.getContent();a.find(".popover-title")[this.options.html ? "html" : "text"](b), a.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof c ? "html" : "append" : "text"](c), a.removeClass("fade top bottom left right in"), a.find(".popover-title").html() || a.find(".popover-title").hide();\n  }, c.prototype.hasContent = function () {\n    return this.getTitle() || this.getContent();\n  }, c.prototype.getContent = function () {\n    var a = this.$element,\n        b = this.options;return a.attr("data-content") || ("function" == typeof b.content ? b.content.call(a[0]) : b.content);\n  }, c.prototype.arrow = function () {\n    return this.$arrow = this.$arrow || this.tip().find(".arrow");\n  };var d = a.fn.popover;a.fn.popover = b, a.fn.popover.Constructor = c, a.fn.popover.noConflict = function () {\n    return a.fn.popover = d, this;\n  };\n}(jQuery), +function (a) {\n  "use strict";\n  function b(c, d) {\n    this.$body = a(document.body), this.$scrollElement = a(a(c).is(document.body) ? window : c), this.options = a.extend({}, b.DEFAULTS, d), this.selector = (this.options.target || "") + " .nav li > a", this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on("scroll.bs.scrollspy", a.proxy(this.process, this)), this.refresh(), this.process();\n  }function c(c) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data("bs.scrollspy"),\n          f = "object" == (typeof c === "undefined" ? "undefined" : _typeof(c)) && c;e || d.data("bs.scrollspy", e = new b(this, f)), "string" == typeof c && e[c]();\n    });\n  }b.VERSION = "3.3.5", b.DEFAULTS = { offset: 10 }, b.prototype.getScrollHeight = function () {\n    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);\n  }, b.prototype.refresh = function () {\n    var b = this,\n        c = "offset",\n        d = 0;this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), a.isWindow(this.$scrollElement[0]) || (c = "position", d = this.$scrollElement.scrollTop()), this.$body.find(this.selector).map(function () {\n      var b = a(this),\n          e = b.data("target") || b.attr("href"),\n          f = /^#./.test(e) && a(e);return f && f.length && f.is(":visible") && [[f[c]().top + d, e]] || null;\n    }).sort(function (a, b) {\n      return a[0] - b[0];\n    }).each(function () {\n      b.offsets.push(this[0]), b.targets.push(this[1]);\n    });\n  }, b.prototype.process = function () {\n    var a,\n        b = this.$scrollElement.scrollTop() + this.options.offset,\n        c = this.getScrollHeight(),\n        d = this.options.offset + c - this.$scrollElement.height(),\n        e = this.offsets,\n        f = this.targets,\n        g = this.activeTarget;if (this.scrollHeight != c && this.refresh(), b >= d) return g != (a = f[f.length - 1]) && this.activate(a);if (g && b < e[0]) return this.activeTarget = null, this.clear();for (a = e.length; a--;) {\n      g != f[a] && b >= e[a] && (void 0 === e[a + 1] || b < e[a + 1]) && this.activate(f[a]);\n    }\n  }, b.prototype.activate = function (b) {\n    this.activeTarget = b, this.clear();var c = this.selector + \'[data-target="\' + b + \'"],\' + this.selector + \'[href="\' + b + \'"]\',\n        d = a(c).parents("li").addClass("active");d.parent(".dropdown-menu").length && (d = d.closest("li.dropdown").addClass("active")), d.trigger("activate.bs.scrollspy");\n  }, b.prototype.clear = function () {\n    a(this.selector).parentsUntil(this.options.target, ".active").removeClass("active");\n  };var d = a.fn.scrollspy;a.fn.scrollspy = c, a.fn.scrollspy.Constructor = b, a.fn.scrollspy.noConflict = function () {\n    return a.fn.scrollspy = d, this;\n  }, a(window).on("load.bs.scrollspy.data-api", function () {\n    a(\'[data-spy="scroll"]\').each(function () {\n      var b = a(this);c.call(b, b.data());\n    });\n  });\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data("bs.tab");e || d.data("bs.tab", e = new c(this)), "string" == typeof b && e[b]();\n    });\n  }var c = function c(b) {\n    this.element = a(b);\n  };c.VERSION = "3.3.5", c.TRANSITION_DURATION = 150, c.prototype.show = function () {\n    var b = this.element,\n        c = b.closest("ul:not(.dropdown-menu)"),\n        d = b.data("target");if (d || (d = b.attr("href"), d = d && d.replace(/.*(?=#[^\\s]*$)/, "")), !b.parent("li").hasClass("active")) {\n      var e = c.find(".active:last a"),\n          f = a.Event("hide.bs.tab", { relatedTarget: b[0] }),\n          g = a.Event("show.bs.tab", { relatedTarget: e[0] });if (e.trigger(f), b.trigger(g), !g.isDefaultPrevented() && !f.isDefaultPrevented()) {\n        var h = a(d);this.activate(b.closest("li"), c), this.activate(h, h.parent(), function () {\n          e.trigger({ type: "hidden.bs.tab", relatedTarget: b[0] }), b.trigger({ type: "shown.bs.tab", relatedTarget: e[0] });\n        });\n      }\n    }\n  }, c.prototype.activate = function (b, d, e) {\n    function f() {\n      g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find(\'[data-toggle="tab"]\').attr("aria-expanded", !1), b.addClass("active").find(\'[data-toggle="tab"]\').attr("aria-expanded", !0), h ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"), b.parent(".dropdown-menu").length && b.closest("li.dropdown").addClass("active").end().find(\'[data-toggle="tab"]\').attr("aria-expanded", !0), e && e();\n    }var g = d.find("> .active"),\n        h = e && a.support.transition && (g.length && g.hasClass("fade") || !!d.find("> .fade").length);g.length && h ? g.one("bsTransitionEnd", f).emulateTransitionEnd(c.TRANSITION_DURATION) : f(), g.removeClass("in");\n  };var d = a.fn.tab;a.fn.tab = b, a.fn.tab.Constructor = c, a.fn.tab.noConflict = function () {\n    return a.fn.tab = d, this;\n  };var e = function e(c) {\n    c.preventDefault(), b.call(a(this), "show");\n  };a(document).on("click.bs.tab.data-api", \'[data-toggle="tab"]\', e).on("click.bs.tab.data-api", \'[data-toggle="pill"]\', e);\n}(jQuery), +function (a) {\n  "use strict";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data("bs.affix"),\n          f = "object" == (typeof b === "undefined" ? "undefined" : _typeof(b)) && b;e || d.data("bs.affix", e = new c(this, f)), "string" == typeof b && e[b]();\n    });\n  }var c = function c(b, d) {\n    this.options = a.extend({}, c.DEFAULTS, d), this.$target = a(this.options.target).on("scroll.bs.affix.data-api", a.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", a.proxy(this.checkPositionWithEventLoop, this)), this.$element = a(b), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this.checkPosition();\n  };c.VERSION = "3.3.5", c.RESET = "affix affix-top affix-bottom", c.DEFAULTS = { offset: 0, target: window }, c.prototype.getState = function (a, b, c, d) {\n    var e = this.$target.scrollTop(),\n        f = this.$element.offset(),\n        g = this.$target.height();if (null != c && "top" == this.affixed) return c > e ? "top" : !1;if ("bottom" == this.affixed) return null != c ? e + this.unpin <= f.top ? !1 : "bottom" : a - d >= e + g ? !1 : "bottom";var h = null == this.affixed,\n        i = h ? e : f.top,\n        j = h ? g : b;return null != c && c >= e ? "top" : null != d && i + j >= a - d ? "bottom" : !1;\n  }, c.prototype.getPinnedOffset = function () {\n    if (this.pinnedOffset) return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a = this.$target.scrollTop(),\n        b = this.$element.offset();return this.pinnedOffset = b.top - a;\n  }, c.prototype.checkPositionWithEventLoop = function () {\n    setTimeout(a.proxy(this.checkPosition, this), 1);\n  }, c.prototype.checkPosition = function () {\n    if (this.$element.is(":visible")) {\n      var b = this.$element.height(),\n          d = this.options.offset,\n          e = d.top,\n          f = d.bottom,\n          g = Math.max(a(document).height(), a(document.body).height());"object" != (typeof d === "undefined" ? "undefined" : _typeof(d)) && (f = e = d), "function" == typeof e && (e = d.top(this.$element)), "function" == typeof f && (f = d.bottom(this.$element));var h = this.getState(g, b, e, f);if (this.affixed != h) {\n        null != this.unpin && this.$element.css("top", "");var i = "affix" + (h ? "-" + h : ""),\n            j = a.Event(i + ".bs.affix");if (this.$element.trigger(j), j.isDefaultPrevented()) return;this.affixed = h, this.unpin = "bottom" == h ? this.getPinnedOffset() : null, this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix", "affixed") + ".bs.affix");\n      }"bottom" == h && this.$element.offset({ top: g - b - f });\n    }\n  };var d = a.fn.affix;a.fn.affix = b, a.fn.affix.Constructor = c, a.fn.affix.noConflict = function () {\n    return a.fn.affix = d, this;\n  }, a(window).on("load", function () {\n    a(\'[data-spy="affix"]\').each(function () {\n      var c = a(this),\n          d = c.data();d.offset = d.offset || {}, null != d.offsetBottom && (d.offset.bottom = d.offsetBottom), null != d.offsetTop && (d.offset.top = d.offsetTop), b.call(c, d);\n    });\n  });\n}(jQuery);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvanMvYm9vdHN0cmFwLm1pbi5qcz9iYzA2Il0sIm5hbWVzIjpbInJlcXVpcmUiLCJqUXVlcnkiLCJFcnJvciIsImEiLCJiIiwiZm4iLCJqcXVlcnkiLCJzcGxpdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIldlYmtpdFRyYW5zaXRpb24iLCJNb3pUcmFuc2l0aW9uIiwiT1RyYW5zaXRpb24iLCJ0cmFuc2l0aW9uIiwiYyIsInN0eWxlIiwiZW5kIiwiZW11bGF0ZVRyYW5zaXRpb25FbmQiLCJkIiwib25lIiwiZSIsInRyaWdnZXIiLCJzdXBwb3J0Iiwic2V0VGltZW91dCIsImV2ZW50Iiwic3BlY2lhbCIsImJzVHJhbnNpdGlvbkVuZCIsImJpbmRUeXBlIiwiZGVsZWdhdGVUeXBlIiwiaGFuZGxlIiwidGFyZ2V0IiwiaXMiLCJoYW5kbGVPYmoiLCJoYW5kbGVyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJlYWNoIiwiZGF0YSIsImNhbGwiLCJvbiIsImNsb3NlIiwiVkVSU0lPTiIsIlRSQU5TSVRJT05fRFVSQVRJT04iLCJwcm90b3R5cGUiLCJnIiwiZGV0YWNoIiwicmVtb3ZlIiwiZiIsImF0dHIiLCJyZXBsYWNlIiwicHJldmVudERlZmF1bHQiLCJsZW5ndGgiLCJjbG9zZXN0IiwiRXZlbnQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJyZW1vdmVDbGFzcyIsImhhc0NsYXNzIiwiYWxlcnQiLCJDb25zdHJ1Y3RvciIsIm5vQ29uZmxpY3QiLCJ0b2dnbGUiLCJzZXRTdGF0ZSIsIiRlbGVtZW50Iiwib3B0aW9ucyIsImV4dGVuZCIsIkRFRkFVTFRTIiwiaXNMb2FkaW5nIiwibG9hZGluZ1RleHQiLCJyZXNldFRleHQiLCJwcm94eSIsImFkZENsYXNzIiwicmVtb3ZlQXR0ciIsImZpbmQiLCJwcm9wIiwidG9nZ2xlQ2xhc3MiLCJidXR0b24iLCJ0ZXN0IiwidHlwZSIsInNsaWRlIiwidG8iLCJpbnRlcnZhbCIsInBhdXNlIiwiY3ljbGUiLCIkaW5kaWNhdG9ycyIsInBhdXNlZCIsInNsaWRpbmciLCIkYWN0aXZlIiwiJGl0ZW1zIiwia2V5Ym9hcmQiLCJrZXlkb3duIiwiZG9jdW1lbnRFbGVtZW50Iiwid3JhcCIsInRhZ05hbWUiLCJ3aGljaCIsInByZXYiLCJuZXh0IiwiY2xlYXJJbnRlcnZhbCIsInNldEludGVydmFsIiwiZ2V0SXRlbUluZGV4IiwicGFyZW50IiwiY2hpbGRyZW4iLCJpbmRleCIsImdldEl0ZW1Gb3JEaXJlY3Rpb24iLCJlcSIsImgiLCJpIiwiaiIsImsiLCJyZWxhdGVkVGFyZ2V0IiwiZGlyZWN0aW9uIiwibCIsIm0iLCJvZmZzZXRXaWR0aCIsImpvaW4iLCJjYXJvdXNlbCIsIndpbmRvdyIsIiR0cmlnZ2VyIiwiaWQiLCJ0cmFuc2l0aW9uaW5nIiwiJHBhcmVudCIsImdldFBhcmVudCIsImFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyIsImRpbWVuc2lvbiIsInNob3ciLCJjYW1lbENhc2UiLCJoaWRlIiwib2Zmc2V0SGVpZ2h0IiwiY29sbGFwc2UiLCJjb250YWlucyIsImluc2VydEFmdGVyIiwic3RvcFByb3BhZ2F0aW9uIiwiZHJvcGRvd24iLCIkYm9keSIsImJvZHkiLCIkZGlhbG9nIiwiJGJhY2tkcm9wIiwiaXNTaG93biIsIm9yaWdpbmFsQm9keVBhZCIsInNjcm9sbGJhcldpZHRoIiwiaWdub3JlQmFja2Ryb3BDbGljayIsInJlbW90ZSIsImxvYWQiLCJCQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OIiwiYmFja2Ryb3AiLCJjaGVja1Njcm9sbGJhciIsInNldFNjcm9sbGJhciIsImVzY2FwZSIsInJlc2l6ZSIsImFwcGVuZFRvIiwic2Nyb2xsVG9wIiwiYWRqdXN0RGlhbG9nIiwiZW5mb3JjZUZvY3VzIiwib2ZmIiwiaGlkZU1vZGFsIiwiaGFzIiwiaGFuZGxlVXBkYXRlIiwicmVzZXRBZGp1c3RtZW50cyIsInJlc2V0U2Nyb2xsYmFyIiwicmVtb3ZlQmFja2Ryb3AiLCJjdXJyZW50VGFyZ2V0IiwiZm9jdXMiLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJjc3MiLCJwYWRkaW5nTGVmdCIsImJvZHlJc092ZXJmbG93aW5nIiwicGFkZGluZ1JpZ2h0IiwiaW5uZXJXaWR0aCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInJpZ2h0IiwiTWF0aCIsImFicyIsImxlZnQiLCJjbGllbnRXaWR0aCIsIm1lYXN1cmVTY3JvbGxiYXIiLCJwYXJzZUludCIsImNsYXNzTmFtZSIsImFwcGVuZCIsInJlbW92ZUNoaWxkIiwibW9kYWwiLCJlbmFibGVkIiwidGltZW91dCIsImhvdmVyU3RhdGUiLCJpblN0YXRlIiwiaW5pdCIsImFuaW1hdGlvbiIsInBsYWNlbWVudCIsInNlbGVjdG9yIiwidGVtcGxhdGUiLCJ0aXRsZSIsImRlbGF5IiwiaHRtbCIsImNvbnRhaW5lciIsInZpZXdwb3J0IiwicGFkZGluZyIsImdldE9wdGlvbnMiLCIkdmlld3BvcnQiLCJpc0Z1bmN0aW9uIiwiY2xpY2siLCJob3ZlciIsImNvbnN0cnVjdG9yIiwiZW50ZXIiLCJsZWF2ZSIsIl9vcHRpb25zIiwiZml4VGl0bGUiLCJnZXREZWZhdWx0cyIsImdldERlbGVnYXRlT3B0aW9ucyIsInRpcCIsImNsZWFyVGltZW91dCIsImlzSW5TdGF0ZVRydWUiLCJoYXNDb250ZW50Iiwib3duZXJEb2N1bWVudCIsImdldFVJRCIsInNldENvbnRlbnQiLCJ0b3AiLCJkaXNwbGF5IiwiZ2V0UG9zaXRpb24iLCJuIiwibyIsImJvdHRvbSIsIndpZHRoIiwicCIsImdldENhbGN1bGF0ZWRPZmZzZXQiLCJhcHBseVBsYWNlbWVudCIsInEiLCIkdGlwIiwiaXNOYU4iLCJvZmZzZXQiLCJzZXRPZmZzZXQiLCJ1c2luZyIsInJvdW5kIiwiZ2V0Vmlld3BvcnRBZGp1c3RlZERlbHRhIiwicmVwbGFjZUFycm93IiwiYXJyb3ciLCJnZXRUaXRsZSIsImhlaWdodCIsInNjcm9sbCIsInJhbmRvbSIsImdldEVsZW1lbnRCeUlkIiwiJGFycm93IiwiZW5hYmxlIiwiZGlzYWJsZSIsInRvZ2dsZUVuYWJsZWQiLCJkZXN0cm95IiwicmVtb3ZlRGF0YSIsInRvb2x0aXAiLCJjb250ZW50IiwiZ2V0Q29udGVudCIsInBvcG92ZXIiLCIkc2Nyb2xsRWxlbWVudCIsIm9mZnNldHMiLCJ0YXJnZXRzIiwiYWN0aXZlVGFyZ2V0IiwicHJvY2VzcyIsInJlZnJlc2giLCJnZXRTY3JvbGxIZWlnaHQiLCJtYXgiLCJpc1dpbmRvdyIsIm1hcCIsInNvcnQiLCJwdXNoIiwiYWN0aXZhdGUiLCJjbGVhciIsInBhcmVudHMiLCJwYXJlbnRzVW50aWwiLCJzY3JvbGxzcHkiLCJlbGVtZW50IiwidGFiIiwiJHRhcmdldCIsImNoZWNrUG9zaXRpb24iLCJjaGVja1Bvc2l0aW9uV2l0aEV2ZW50TG9vcCIsImFmZml4ZWQiLCJ1bnBpbiIsInBpbm5lZE9mZnNldCIsIlJFU0VUIiwiZ2V0U3RhdGUiLCJnZXRQaW5uZWRPZmZzZXQiLCJhZmZpeCIsIm9mZnNldEJvdHRvbSIsIm9mZnNldFRvcCJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxtQkFBQUEsQ0FBUSxFQUFSO0FBQ0E7Ozs7O0FBS0EsSUFBRyxlQUFhLE9BQU9DLE1BQXZCLEVBQThCLE1BQU0sSUFBSUMsS0FBSixDQUFVLHdDQUFWLENBQU4sQ0FBMEQsQ0FBQyxVQUFTQyxDQUFULEVBQVc7QUFBQztBQUFhLE1BQUlDLElBQUVELEVBQUVFLEVBQUYsQ0FBS0MsTUFBTCxDQUFZQyxLQUFaLENBQWtCLEdBQWxCLEVBQXVCLENBQXZCLEVBQTBCQSxLQUExQixDQUFnQyxHQUFoQyxDQUFOLENBQTJDLElBQUdILEVBQUUsQ0FBRixJQUFLLENBQUwsSUFBUUEsRUFBRSxDQUFGLElBQUssQ0FBYixJQUFnQixLQUFHQSxFQUFFLENBQUYsQ0FBSCxJQUFTLEtBQUdBLEVBQUUsQ0FBRixDQUFaLElBQWtCQSxFQUFFLENBQUYsSUFBSyxDQUExQyxFQUE0QyxNQUFNLElBQUlGLEtBQUosQ0FBVSxnRUFBVixDQUFOO0FBQWtGLENBQWxN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LENBQUtnUixLQUFMLENBQVczTixXQUFYLEdBQXVCNUMsQ0FBcEMsRUFBc0NYLEVBQUVFLEVBQUYsQ0FBS2dSLEtBQUwsQ0FBVzFOLFVBQVgsR0FBc0IsWUFBVTtBQUFDLFdBQU94RCxFQUFFRSxFQUFGLENBQUtnUixLQUFMLEdBQVduUSxDQUFYLEVBQWEsSUFBcEI7QUFBeUIsR0FBaEcsRUFBaUdmLEVBQUVnSCxNQUFGLEVBQVU1RSxFQUFWLENBQWEsTUFBYixFQUFvQixZQUFVO0FBQUNwQyxNQUFFLG9CQUFGLEVBQXdCaUMsSUFBeEIsQ0FBNkIsWUFBVTtBQUFDLFVBQUl0QixJQUFFWCxFQUFFLElBQUYsQ0FBTjtBQUFBLFVBQWNlLElBQUVKLEVBQUV1QixJQUFGLEVBQWhCLENBQXlCbkIsRUFBRWlOLE1BQUYsR0FBU2pOLEVBQUVpTixNQUFGLElBQVUsRUFBbkIsRUFBc0IsUUFBTWpOLEVBQUVvUSxZQUFSLEtBQXVCcFEsRUFBRWlOLE1BQUYsQ0FBU1IsTUFBVCxHQUFnQnpNLEVBQUVvUSxZQUF6QyxDQUF0QixFQUE2RSxRQUFNcFEsRUFBRXFRLFNBQVIsS0FBb0JyUSxFQUFFaU4sTUFBRixDQUFTYixHQUFULEdBQWFwTSxFQUFFcVEsU0FBbkMsQ0FBN0UsRUFBMkhuUixFQUFFa0MsSUFBRixDQUFPeEIsQ0FBUCxFQUFTSSxDQUFULENBQTNIO0FBQXVJLEtBQXhNO0FBQTBNLEdBQXpPLENBQWpHO0FBQTRVLENBQW4yRSxDQUFvMkVqQixNQUFwMkUsQ0FEaG5FIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCdqUXVlcnknKVxuLyohXG4gKiBCb290c3RyYXAgdjMuMy41IChodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbSlcbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmlmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBqUXVlcnkpdGhyb3cgbmV3IEVycm9yKFwiQm9vdHN0cmFwJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBqUXVlcnlcIik7K2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO3ZhciBiPWEuZm4uanF1ZXJ5LnNwbGl0KFwiIFwiKVswXS5zcGxpdChcIi5cIik7aWYoYlswXTwyJiZiWzFdPDl8fDE9PWJbMF0mJjk9PWJbMV0mJmJbMl08MSl0aHJvdyBuZXcgRXJyb3IoXCJCb290c3RyYXAncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeSB2ZXJzaW9uIDEuOS4xIG9yIGhpZ2hlclwiKX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJib290c3RyYXBcIiksYj17V2Via2l0VHJhbnNpdGlvbjpcIndlYmtpdFRyYW5zaXRpb25FbmRcIixNb3pUcmFuc2l0aW9uOlwidHJhbnNpdGlvbmVuZFwiLE9UcmFuc2l0aW9uOlwib1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmRcIix0cmFuc2l0aW9uOlwidHJhbnNpdGlvbmVuZFwifTtmb3IodmFyIGMgaW4gYilpZih2b2lkIDAhPT1hLnN0eWxlW2NdKXJldHVybntlbmQ6YltjXX07cmV0dXJuITF9YS5mbi5lbXVsYXRlVHJhbnNpdGlvbkVuZD1mdW5jdGlvbihiKXt2YXIgYz0hMSxkPXRoaXM7YSh0aGlzKS5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixmdW5jdGlvbigpe2M9ITB9KTt2YXIgZT1mdW5jdGlvbigpe2N8fGEoZCkudHJpZ2dlcihhLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQpfTtyZXR1cm4gc2V0VGltZW91dChlLGIpLHRoaXN9LGEoZnVuY3Rpb24oKXthLnN1cHBvcnQudHJhbnNpdGlvbj1iKCksYS5zdXBwb3J0LnRyYW5zaXRpb24mJihhLmV2ZW50LnNwZWNpYWwuYnNUcmFuc2l0aW9uRW5kPXtiaW5kVHlwZTphLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsZGVsZWdhdGVUeXBlOmEuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCxoYW5kbGU6ZnVuY3Rpb24oYil7cmV0dXJuIGEoYi50YXJnZXQpLmlzKHRoaXMpP2IuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOnZvaWQgMH19KX0pfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1hKHRoaXMpLGU9Yy5kYXRhKFwiYnMuYWxlcnRcIik7ZXx8Yy5kYXRhKFwiYnMuYWxlcnRcIixlPW5ldyBkKHRoaXMpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZVtiXS5jYWxsKGMpfSl9dmFyIGM9J1tkYXRhLWRpc21pc3M9XCJhbGVydFwiXScsZD1mdW5jdGlvbihiKXthKGIpLm9uKFwiY2xpY2tcIixjLHRoaXMuY2xvc2UpfTtkLlZFUlNJT049XCIzLjMuNVwiLGQuVFJBTlNJVElPTl9EVVJBVElPTj0xNTAsZC5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe2cuZGV0YWNoKCkudHJpZ2dlcihcImNsb3NlZC5icy5hbGVydFwiKS5yZW1vdmUoKX12YXIgZT1hKHRoaXMpLGY9ZS5hdHRyKFwiZGF0YS10YXJnZXRcIik7Znx8KGY9ZS5hdHRyKFwiaHJlZlwiKSxmPWYmJmYucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLyxcIlwiKSk7dmFyIGc9YShmKTtiJiZiLnByZXZlbnREZWZhdWx0KCksZy5sZW5ndGh8fChnPWUuY2xvc2VzdChcIi5hbGVydFwiKSksZy50cmlnZ2VyKGI9YS5FdmVudChcImNsb3NlLmJzLmFsZXJ0XCIpKSxiLmlzRGVmYXVsdFByZXZlbnRlZCgpfHwoZy5yZW1vdmVDbGFzcyhcImluXCIpLGEuc3VwcG9ydC50cmFuc2l0aW9uJiZnLmhhc0NsYXNzKFwiZmFkZVwiKT9nLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGMpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGQuVFJBTlNJVElPTl9EVVJBVElPTik6YygpKX07dmFyIGU9YS5mbi5hbGVydDthLmZuLmFsZXJ0PWIsYS5mbi5hbGVydC5Db25zdHJ1Y3Rvcj1kLGEuZm4uYWxlcnQubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLmFsZXJ0PWUsdGhpc30sYShkb2N1bWVudCkub24oXCJjbGljay5icy5hbGVydC5kYXRhLWFwaVwiLGMsZC5wcm90b3R5cGUuY2xvc2UpfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZD1hKHRoaXMpLGU9ZC5kYXRhKFwiYnMuYnV0dG9uXCIpLGY9XCJvYmplY3RcIj09dHlwZW9mIGImJmI7ZXx8ZC5kYXRhKFwiYnMuYnV0dG9uXCIsZT1uZXcgYyh0aGlzLGYpKSxcInRvZ2dsZVwiPT1iP2UudG9nZ2xlKCk6YiYmZS5zZXRTdGF0ZShiKX0pfXZhciBjPWZ1bmN0aW9uKGIsZCl7dGhpcy4kZWxlbWVudD1hKGIpLHRoaXMub3B0aW9ucz1hLmV4dGVuZCh7fSxjLkRFRkFVTFRTLGQpLHRoaXMuaXNMb2FkaW5nPSExfTtjLlZFUlNJT049XCIzLjMuNVwiLGMuREVGQVVMVFM9e2xvYWRpbmdUZXh0OlwibG9hZGluZy4uLlwifSxjLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihiKXt2YXIgYz1cImRpc2FibGVkXCIsZD10aGlzLiRlbGVtZW50LGU9ZC5pcyhcImlucHV0XCIpP1widmFsXCI6XCJodG1sXCIsZj1kLmRhdGEoKTtiKz1cIlRleHRcIixudWxsPT1mLnJlc2V0VGV4dCYmZC5kYXRhKFwicmVzZXRUZXh0XCIsZFtlXSgpKSxzZXRUaW1lb3V0KGEucHJveHkoZnVuY3Rpb24oKXtkW2VdKG51bGw9PWZbYl0/dGhpcy5vcHRpb25zW2JdOmZbYl0pLFwibG9hZGluZ1RleHRcIj09Yj8odGhpcy5pc0xvYWRpbmc9ITAsZC5hZGRDbGFzcyhjKS5hdHRyKGMsYykpOnRoaXMuaXNMb2FkaW5nJiYodGhpcy5pc0xvYWRpbmc9ITEsZC5yZW1vdmVDbGFzcyhjKS5yZW1vdmVBdHRyKGMpKX0sdGhpcyksMCl9LGMucHJvdG90eXBlLnRvZ2dsZT1mdW5jdGlvbigpe3ZhciBhPSEwLGI9dGhpcy4kZWxlbWVudC5jbG9zZXN0KCdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJyk7aWYoYi5sZW5ndGgpe3ZhciBjPXRoaXMuJGVsZW1lbnQuZmluZChcImlucHV0XCIpO1wicmFkaW9cIj09Yy5wcm9wKFwidHlwZVwiKT8oYy5wcm9wKFwiY2hlY2tlZFwiKSYmKGE9ITEpLGIuZmluZChcIi5hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIiksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcImFjdGl2ZVwiKSk6XCJjaGVja2JveFwiPT1jLnByb3AoXCJ0eXBlXCIpJiYoYy5wcm9wKFwiY2hlY2tlZFwiKSE9PXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJhY3RpdmVcIikmJihhPSExKSx0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKFwiYWN0aXZlXCIpKSxjLnByb3AoXCJjaGVja2VkXCIsdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImFjdGl2ZVwiKSksYSYmYy50cmlnZ2VyKFwiY2hhbmdlXCIpfWVsc2UgdGhpcy4kZWxlbWVudC5hdHRyKFwiYXJpYS1wcmVzc2VkXCIsIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJhY3RpdmVcIikpLHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoXCJhY3RpdmVcIil9O3ZhciBkPWEuZm4uYnV0dG9uO2EuZm4uYnV0dG9uPWIsYS5mbi5idXR0b24uQ29uc3RydWN0b3I9YyxhLmZuLmJ1dHRvbi5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4uYnV0dG9uPWQsdGhpc30sYShkb2N1bWVudCkub24oXCJjbGljay5icy5idXR0b24uZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlXj1cImJ1dHRvblwiXScsZnVuY3Rpb24oYyl7dmFyIGQ9YShjLnRhcmdldCk7ZC5oYXNDbGFzcyhcImJ0blwiKXx8KGQ9ZC5jbG9zZXN0KFwiLmJ0blwiKSksYi5jYWxsKGQsXCJ0b2dnbGVcIiksYShjLnRhcmdldCkuaXMoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXScpfHxhKGMudGFyZ2V0KS5pcygnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJyl8fGMucHJldmVudERlZmF1bHQoKX0pLm9uKFwiZm9jdXMuYnMuYnV0dG9uLmRhdGEtYXBpIGJsdXIuYnMuYnV0dG9uLmRhdGEtYXBpXCIsJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLGZ1bmN0aW9uKGIpe2EoYi50YXJnZXQpLmNsb3Nlc3QoXCIuYnRuXCIpLnRvZ2dsZUNsYXNzKFwiZm9jdXNcIiwvXmZvY3VzKGluKT8kLy50ZXN0KGIudHlwZSkpfSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy5jYXJvdXNlbFwiKSxmPWEuZXh0ZW5kKHt9LGMuREVGQVVMVFMsZC5kYXRhKCksXCJvYmplY3RcIj09dHlwZW9mIGImJmIpLGc9XCJzdHJpbmdcIj09dHlwZW9mIGI/YjpmLnNsaWRlO2V8fGQuZGF0YShcImJzLmNhcm91c2VsXCIsZT1uZXcgYyh0aGlzLGYpKSxcIm51bWJlclwiPT10eXBlb2YgYj9lLnRvKGIpOmc/ZVtnXSgpOmYuaW50ZXJ2YWwmJmUucGF1c2UoKS5jeWNsZSgpfSl9dmFyIGM9ZnVuY3Rpb24oYixjKXt0aGlzLiRlbGVtZW50PWEoYiksdGhpcy4kaW5kaWNhdG9ycz10aGlzLiRlbGVtZW50LmZpbmQoXCIuY2Fyb3VzZWwtaW5kaWNhdG9yc1wiKSx0aGlzLm9wdGlvbnM9Yyx0aGlzLnBhdXNlZD1udWxsLHRoaXMuc2xpZGluZz1udWxsLHRoaXMuaW50ZXJ2YWw9bnVsbCx0aGlzLiRhY3RpdmU9bnVsbCx0aGlzLiRpdGVtcz1udWxsLHRoaXMub3B0aW9ucy5rZXlib2FyZCYmdGhpcy4kZWxlbWVudC5vbihcImtleWRvd24uYnMuY2Fyb3VzZWxcIixhLnByb3h5KHRoaXMua2V5ZG93bix0aGlzKSksXCJob3ZlclwiPT10aGlzLm9wdGlvbnMucGF1c2UmJiEoXCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkmJnRoaXMuJGVsZW1lbnQub24oXCJtb3VzZWVudGVyLmJzLmNhcm91c2VsXCIsYS5wcm94eSh0aGlzLnBhdXNlLHRoaXMpKS5vbihcIm1vdXNlbGVhdmUuYnMuY2Fyb3VzZWxcIixhLnByb3h5KHRoaXMuY3ljbGUsdGhpcykpfTtjLlZFUlNJT049XCIzLjMuNVwiLGMuVFJBTlNJVElPTl9EVVJBVElPTj02MDAsYy5ERUZBVUxUUz17aW50ZXJ2YWw6NWUzLHBhdXNlOlwiaG92ZXJcIix3cmFwOiEwLGtleWJvYXJkOiEwfSxjLnByb3RvdHlwZS5rZXlkb3duPWZ1bmN0aW9uKGEpe2lmKCEvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGEudGFyZ2V0LnRhZ05hbWUpKXtzd2l0Y2goYS53aGljaCl7Y2FzZSAzNzp0aGlzLnByZXYoKTticmVhaztjYXNlIDM5OnRoaXMubmV4dCgpO2JyZWFrO2RlZmF1bHQ6cmV0dXJufWEucHJldmVudERlZmF1bHQoKX19LGMucHJvdG90eXBlLmN5Y2xlPWZ1bmN0aW9uKGIpe3JldHVybiBifHwodGhpcy5wYXVzZWQ9ITEpLHRoaXMuaW50ZXJ2YWwmJmNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCksdGhpcy5vcHRpb25zLmludGVydmFsJiYhdGhpcy5wYXVzZWQmJih0aGlzLmludGVydmFsPXNldEludGVydmFsKGEucHJveHkodGhpcy5uZXh0LHRoaXMpLHRoaXMub3B0aW9ucy5pbnRlcnZhbCkpLHRoaXN9LGMucHJvdG90eXBlLmdldEl0ZW1JbmRleD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy4kaXRlbXM9YS5wYXJlbnQoKS5jaGlsZHJlbihcIi5pdGVtXCIpLHRoaXMuJGl0ZW1zLmluZGV4KGF8fHRoaXMuJGFjdGl2ZSl9LGMucHJvdG90eXBlLmdldEl0ZW1Gb3JEaXJlY3Rpb249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldEl0ZW1JbmRleChiKSxkPVwicHJldlwiPT1hJiYwPT09Y3x8XCJuZXh0XCI9PWEmJmM9PXRoaXMuJGl0ZW1zLmxlbmd0aC0xO2lmKGQmJiF0aGlzLm9wdGlvbnMud3JhcClyZXR1cm4gYjt2YXIgZT1cInByZXZcIj09YT8tMToxLGY9KGMrZSkldGhpcy4kaXRlbXMubGVuZ3RoO3JldHVybiB0aGlzLiRpdGVtcy5lcShmKX0sYy5wcm90b3R5cGUudG89ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPXRoaXMuZ2V0SXRlbUluZGV4KHRoaXMuJGFjdGl2ZT10aGlzLiRlbGVtZW50LmZpbmQoXCIuaXRlbS5hY3RpdmVcIikpO3JldHVybiBhPnRoaXMuJGl0ZW1zLmxlbmd0aC0xfHwwPmE/dm9pZCAwOnRoaXMuc2xpZGluZz90aGlzLiRlbGVtZW50Lm9uZShcInNsaWQuYnMuY2Fyb3VzZWxcIixmdW5jdGlvbigpe2IudG8oYSl9KTpjPT1hP3RoaXMucGF1c2UoKS5jeWNsZSgpOnRoaXMuc2xpZGUoYT5jP1wibmV4dFwiOlwicHJldlwiLHRoaXMuJGl0ZW1zLmVxKGEpKX0sYy5wcm90b3R5cGUucGF1c2U9ZnVuY3Rpb24oYil7cmV0dXJuIGJ8fCh0aGlzLnBhdXNlZD0hMCksdGhpcy4kZWxlbWVudC5maW5kKFwiLm5leHQsIC5wcmV2XCIpLmxlbmd0aCYmYS5zdXBwb3J0LnRyYW5zaXRpb24mJih0aGlzLiRlbGVtZW50LnRyaWdnZXIoYS5zdXBwb3J0LnRyYW5zaXRpb24uZW5kKSx0aGlzLmN5Y2xlKCEwKSksdGhpcy5pbnRlcnZhbD1jbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpLHRoaXN9LGMucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zbGlkaW5nP3ZvaWQgMDp0aGlzLnNsaWRlKFwibmV4dFwiKX0sYy5wcm90b3R5cGUucHJldj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNsaWRpbmc/dm9pZCAwOnRoaXMuc2xpZGUoXCJwcmV2XCIpfSxjLnByb3RvdHlwZS5zbGlkZT1mdW5jdGlvbihiLGQpe3ZhciBlPXRoaXMuJGVsZW1lbnQuZmluZChcIi5pdGVtLmFjdGl2ZVwiKSxmPWR8fHRoaXMuZ2V0SXRlbUZvckRpcmVjdGlvbihiLGUpLGc9dGhpcy5pbnRlcnZhbCxoPVwibmV4dFwiPT1iP1wibGVmdFwiOlwicmlnaHRcIixpPXRoaXM7aWYoZi5oYXNDbGFzcyhcImFjdGl2ZVwiKSlyZXR1cm4gdGhpcy5zbGlkaW5nPSExO3ZhciBqPWZbMF0saz1hLkV2ZW50KFwic2xpZGUuYnMuY2Fyb3VzZWxcIix7cmVsYXRlZFRhcmdldDpqLGRpcmVjdGlvbjpofSk7aWYodGhpcy4kZWxlbWVudC50cmlnZ2VyKGspLCFrLmlzRGVmYXVsdFByZXZlbnRlZCgpKXtpZih0aGlzLnNsaWRpbmc9ITAsZyYmdGhpcy5wYXVzZSgpLHRoaXMuJGluZGljYXRvcnMubGVuZ3RoKXt0aGlzLiRpbmRpY2F0b3JzLmZpbmQoXCIuYWN0aXZlXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO3ZhciBsPWEodGhpcy4kaW5kaWNhdG9ycy5jaGlsZHJlbigpW3RoaXMuZ2V0SXRlbUluZGV4KGYpXSk7bCYmbC5hZGRDbGFzcyhcImFjdGl2ZVwiKX12YXIgbT1hLkV2ZW50KFwic2xpZC5icy5jYXJvdXNlbFwiLHtyZWxhdGVkVGFyZ2V0OmosZGlyZWN0aW9uOmh9KTtyZXR1cm4gYS5zdXBwb3J0LnRyYW5zaXRpb24mJnRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJzbGlkZVwiKT8oZi5hZGRDbGFzcyhiKSxmWzBdLm9mZnNldFdpZHRoLGUuYWRkQ2xhc3MoaCksZi5hZGRDbGFzcyhoKSxlLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGZ1bmN0aW9uKCl7Zi5yZW1vdmVDbGFzcyhbYixoXS5qb2luKFwiIFwiKSkuYWRkQ2xhc3MoXCJhY3RpdmVcIiksZS5yZW1vdmVDbGFzcyhbXCJhY3RpdmVcIixoXS5qb2luKFwiIFwiKSksaS5zbGlkaW5nPSExLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtpLiRlbGVtZW50LnRyaWdnZXIobSl9LDApfSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5UUkFOU0lUSU9OX0RVUkFUSU9OKSk6KGUucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIiksZi5hZGRDbGFzcyhcImFjdGl2ZVwiKSx0aGlzLnNsaWRpbmc9ITEsdGhpcy4kZWxlbWVudC50cmlnZ2VyKG0pKSxnJiZ0aGlzLmN5Y2xlKCksdGhpc319O3ZhciBkPWEuZm4uY2Fyb3VzZWw7YS5mbi5jYXJvdXNlbD1iLGEuZm4uY2Fyb3VzZWwuQ29uc3RydWN0b3I9YyxhLmZuLmNhcm91c2VsLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5jYXJvdXNlbD1kLHRoaXN9O3ZhciBlPWZ1bmN0aW9uKGMpe3ZhciBkLGU9YSh0aGlzKSxmPWEoZS5hdHRyKFwiZGF0YS10YXJnZXRcIil8fChkPWUuYXR0cihcImhyZWZcIikpJiZkLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sXCJcIikpO2lmKGYuaGFzQ2xhc3MoXCJjYXJvdXNlbFwiKSl7dmFyIGc9YS5leHRlbmQoe30sZi5kYXRhKCksZS5kYXRhKCkpLGg9ZS5hdHRyKFwiZGF0YS1zbGlkZS10b1wiKTtoJiYoZy5pbnRlcnZhbD0hMSksYi5jYWxsKGYsZyksaCYmZi5kYXRhKFwiYnMuY2Fyb3VzZWxcIikudG8oaCksYy5wcmV2ZW50RGVmYXVsdCgpfX07YShkb2N1bWVudCkub24oXCJjbGljay5icy5jYXJvdXNlbC5kYXRhLWFwaVwiLFwiW2RhdGEtc2xpZGVdXCIsZSkub24oXCJjbGljay5icy5jYXJvdXNlbC5kYXRhLWFwaVwiLFwiW2RhdGEtc2xpZGUtdG9dXCIsZSksYSh3aW5kb3cpLm9uKFwibG9hZFwiLGZ1bmN0aW9uKCl7YSgnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJykuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcyk7Yi5jYWxsKGMsYy5kYXRhKCkpfSl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXt2YXIgYyxkPWIuYXR0cihcImRhdGEtdGFyZ2V0XCIpfHwoYz1iLmF0dHIoXCJocmVmXCIpKSYmYy5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLFwiXCIpO3JldHVybiBhKGQpfWZ1bmN0aW9uIGMoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcyksZT1jLmRhdGEoXCJicy5jb2xsYXBzZVwiKSxmPWEuZXh0ZW5kKHt9LGQuREVGQVVMVFMsYy5kYXRhKCksXCJvYmplY3RcIj09dHlwZW9mIGImJmIpOyFlJiZmLnRvZ2dsZSYmL3Nob3d8aGlkZS8udGVzdChiKSYmKGYudG9nZ2xlPSExKSxlfHxjLmRhdGEoXCJicy5jb2xsYXBzZVwiLGU9bmV3IGQodGhpcyxmKSksXCJzdHJpbmdcIj09dHlwZW9mIGImJmVbYl0oKX0pfXZhciBkPWZ1bmN0aW9uKGIsYyl7dGhpcy4kZWxlbWVudD1hKGIpLHRoaXMub3B0aW9ucz1hLmV4dGVuZCh7fSxkLkRFRkFVTFRTLGMpLHRoaXMuJHRyaWdnZXI9YSgnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1baHJlZj1cIiMnK2IuaWQrJ1wiXSxbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXRhcmdldD1cIiMnK2IuaWQrJ1wiXScpLHRoaXMudHJhbnNpdGlvbmluZz1udWxsLHRoaXMub3B0aW9ucy5wYXJlbnQ/dGhpcy4kcGFyZW50PXRoaXMuZ2V0UGFyZW50KCk6dGhpcy5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy4kZWxlbWVudCx0aGlzLiR0cmlnZ2VyKSx0aGlzLm9wdGlvbnMudG9nZ2xlJiZ0aGlzLnRvZ2dsZSgpfTtkLlZFUlNJT049XCIzLjMuNVwiLGQuVFJBTlNJVElPTl9EVVJBVElPTj0zNTAsZC5ERUZBVUxUUz17dG9nZ2xlOiEwfSxkLnByb3RvdHlwZS5kaW1lbnNpb249ZnVuY3Rpb24oKXt2YXIgYT10aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwid2lkdGhcIik7cmV0dXJuIGE/XCJ3aWR0aFwiOlwiaGVpZ2h0XCJ9LGQucHJvdG90eXBlLnNob3c9ZnVuY3Rpb24oKXtpZighdGhpcy50cmFuc2l0aW9uaW5nJiYhdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImluXCIpKXt2YXIgYixlPXRoaXMuJHBhcmVudCYmdGhpcy4kcGFyZW50LmNoaWxkcmVuKFwiLnBhbmVsXCIpLmNoaWxkcmVuKFwiLmluLCAuY29sbGFwc2luZ1wiKTtpZighKGUmJmUubGVuZ3RoJiYoYj1lLmRhdGEoXCJicy5jb2xsYXBzZVwiKSxiJiZiLnRyYW5zaXRpb25pbmcpKSl7dmFyIGY9YS5FdmVudChcInNob3cuYnMuY29sbGFwc2VcIik7aWYodGhpcy4kZWxlbWVudC50cmlnZ2VyKGYpLCFmLmlzRGVmYXVsdFByZXZlbnRlZCgpKXtlJiZlLmxlbmd0aCYmKGMuY2FsbChlLFwiaGlkZVwiKSxifHxlLmRhdGEoXCJicy5jb2xsYXBzZVwiLG51bGwpKTt2YXIgZz10aGlzLmRpbWVuc2lvbigpO3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJjb2xsYXBzZVwiKS5hZGRDbGFzcyhcImNvbGxhcHNpbmdcIilbZ10oMCkuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMCksdGhpcy4kdHJpZ2dlci5yZW1vdmVDbGFzcyhcImNvbGxhcHNlZFwiKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCEwKSx0aGlzLnRyYW5zaXRpb25pbmc9MTt2YXIgaD1mdW5jdGlvbigpe3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJjb2xsYXBzaW5nXCIpLmFkZENsYXNzKFwiY29sbGFwc2UgaW5cIilbZ10oXCJcIiksdGhpcy50cmFuc2l0aW9uaW5nPTAsdGhpcy4kZWxlbWVudC50cmlnZ2VyKFwic2hvd24uYnMuY29sbGFwc2VcIil9O2lmKCFhLnN1cHBvcnQudHJhbnNpdGlvbilyZXR1cm4gaC5jYWxsKHRoaXMpO3ZhciBpPWEuY2FtZWxDYXNlKFtcInNjcm9sbFwiLGddLmpvaW4oXCItXCIpKTt0aGlzLiRlbGVtZW50Lm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGEucHJveHkoaCx0aGlzKSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoZC5UUkFOU0lUSU9OX0RVUkFUSU9OKVtnXSh0aGlzLiRlbGVtZW50WzBdW2ldKX19fX0sZC5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbigpe2lmKCF0aGlzLnRyYW5zaXRpb25pbmcmJnRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJpblwiKSl7dmFyIGI9YS5FdmVudChcImhpZGUuYnMuY29sbGFwc2VcIik7aWYodGhpcy4kZWxlbWVudC50cmlnZ2VyKGIpLCFiLmlzRGVmYXVsdFByZXZlbnRlZCgpKXt2YXIgYz10aGlzLmRpbWVuc2lvbigpO3RoaXMuJGVsZW1lbnRbY10odGhpcy4kZWxlbWVudFtjXSgpKVswXS5vZmZzZXRIZWlnaHQsdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcImNvbGxhcHNpbmdcIikucmVtb3ZlQ2xhc3MoXCJjb2xsYXBzZSBpblwiKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCExKSx0aGlzLiR0cmlnZ2VyLmFkZENsYXNzKFwiY29sbGFwc2VkXCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITEpLHRoaXMudHJhbnNpdGlvbmluZz0xO3ZhciBlPWZ1bmN0aW9uKCl7dGhpcy50cmFuc2l0aW9uaW5nPTAsdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcImNvbGxhcHNpbmdcIikuYWRkQ2xhc3MoXCJjb2xsYXBzZVwiKS50cmlnZ2VyKFwiaGlkZGVuLmJzLmNvbGxhcHNlXCIpfTtyZXR1cm4gYS5zdXBwb3J0LnRyYW5zaXRpb24/dm9pZCB0aGlzLiRlbGVtZW50W2NdKDApLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGEucHJveHkoZSx0aGlzKSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoZC5UUkFOU0lUSU9OX0RVUkFUSU9OKTplLmNhbGwodGhpcyl9fX0sZC5wcm90b3R5cGUudG9nZ2xlPWZ1bmN0aW9uKCl7dGhpc1t0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiaW5cIik/XCJoaWRlXCI6XCJzaG93XCJdKCl9LGQucHJvdG90eXBlLmdldFBhcmVudD1mdW5jdGlvbigpe3JldHVybiBhKHRoaXMub3B0aW9ucy5wYXJlbnQpLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2RhdGEtcGFyZW50PVwiJyt0aGlzLm9wdGlvbnMucGFyZW50KydcIl0nKS5lYWNoKGEucHJveHkoZnVuY3Rpb24oYyxkKXt2YXIgZT1hKGQpO3RoaXMuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKGIoZSksZSl9LHRoaXMpKS5lbmQoKX0sZC5wcm90b3R5cGUuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5oYXNDbGFzcyhcImluXCIpO2EuYXR0cihcImFyaWEtZXhwYW5kZWRcIixjKSxiLnRvZ2dsZUNsYXNzKFwiY29sbGFwc2VkXCIsIWMpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsYyl9O3ZhciBlPWEuZm4uY29sbGFwc2U7YS5mbi5jb2xsYXBzZT1jLGEuZm4uY29sbGFwc2UuQ29uc3RydWN0b3I9ZCxhLmZuLmNvbGxhcHNlLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5jb2xsYXBzZT1lLHRoaXN9LGEoZG9jdW1lbnQpLm9uKFwiY2xpY2suYnMuY29sbGFwc2UuZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nLGZ1bmN0aW9uKGQpe3ZhciBlPWEodGhpcyk7ZS5hdHRyKFwiZGF0YS10YXJnZXRcIil8fGQucHJldmVudERlZmF1bHQoKTt2YXIgZj1iKGUpLGc9Zi5kYXRhKFwiYnMuY29sbGFwc2VcIiksaD1nP1widG9nZ2xlXCI6ZS5kYXRhKCk7Yy5jYWxsKGYsaCl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXt2YXIgYz1iLmF0dHIoXCJkYXRhLXRhcmdldFwiKTtjfHwoYz1iLmF0dHIoXCJocmVmXCIpLGM9YyYmLyNbQS1aYS16XS8udGVzdChjKSYmYy5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLFwiXCIpKTt2YXIgZD1jJiZhKGMpO3JldHVybiBkJiZkLmxlbmd0aD9kOmIucGFyZW50KCl9ZnVuY3Rpb24gYyhjKXtjJiYzPT09Yy53aGljaHx8KGEoZSkucmVtb3ZlKCksYShmKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWIoZCksZj17cmVsYXRlZFRhcmdldDp0aGlzfTtlLmhhc0NsYXNzKFwib3BlblwiKSYmKGMmJlwiY2xpY2tcIj09Yy50eXBlJiYvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGMudGFyZ2V0LnRhZ05hbWUpJiZhLmNvbnRhaW5zKGVbMF0sYy50YXJnZXQpfHwoZS50cmlnZ2VyKGM9YS5FdmVudChcImhpZGUuYnMuZHJvcGRvd25cIixmKSksYy5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8KGQuYXR0cihcImFyaWEtZXhwYW5kZWRcIixcImZhbHNlXCIpLGUucmVtb3ZlQ2xhc3MoXCJvcGVuXCIpLnRyaWdnZXIoXCJoaWRkZW4uYnMuZHJvcGRvd25cIixmKSkpKX0pKX1mdW5jdGlvbiBkKGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1hKHRoaXMpLGQ9Yy5kYXRhKFwiYnMuZHJvcGRvd25cIik7ZHx8Yy5kYXRhKFwiYnMuZHJvcGRvd25cIixkPW5ldyBnKHRoaXMpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZFtiXS5jYWxsKGMpfSl9dmFyIGU9XCIuZHJvcGRvd24tYmFja2Ryb3BcIixmPSdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXScsZz1mdW5jdGlvbihiKXthKGIpLm9uKFwiY2xpY2suYnMuZHJvcGRvd25cIix0aGlzLnRvZ2dsZSl9O2cuVkVSU0lPTj1cIjMuMy41XCIsZy5wcm90b3R5cGUudG9nZ2xlPWZ1bmN0aW9uKGQpe3ZhciBlPWEodGhpcyk7aWYoIWUuaXMoXCIuZGlzYWJsZWQsIDpkaXNhYmxlZFwiKSl7dmFyIGY9YihlKSxnPWYuaGFzQ2xhc3MoXCJvcGVuXCIpO2lmKGMoKSwhZyl7XCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmIWYuY2xvc2VzdChcIi5uYXZiYXItbmF2XCIpLmxlbmd0aCYmYShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKS5hZGRDbGFzcyhcImRyb3Bkb3duLWJhY2tkcm9wXCIpLmluc2VydEFmdGVyKGEodGhpcykpLm9uKFwiY2xpY2tcIixjKTt2YXIgaD17cmVsYXRlZFRhcmdldDp0aGlzfTtpZihmLnRyaWdnZXIoZD1hLkV2ZW50KFwic2hvdy5icy5kcm9wZG93blwiLGgpKSxkLmlzRGVmYXVsdFByZXZlbnRlZCgpKXJldHVybjtlLnRyaWdnZXIoXCJmb2N1c1wiKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLFwidHJ1ZVwiKSxmLnRvZ2dsZUNsYXNzKFwib3BlblwiKS50cmlnZ2VyKFwic2hvd24uYnMuZHJvcGRvd25cIixoKX1yZXR1cm4hMX19LGcucHJvdG90eXBlLmtleWRvd249ZnVuY3Rpb24oYyl7aWYoLygzOHw0MHwyN3wzMikvLnRlc3QoYy53aGljaCkmJiEvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGMudGFyZ2V0LnRhZ05hbWUpKXt2YXIgZD1hKHRoaXMpO2lmKGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLCFkLmlzKFwiLmRpc2FibGVkLCA6ZGlzYWJsZWRcIikpe3ZhciBlPWIoZCksZz1lLmhhc0NsYXNzKFwib3BlblwiKTtpZighZyYmMjchPWMud2hpY2h8fGcmJjI3PT1jLndoaWNoKXJldHVybiAyNz09Yy53aGljaCYmZS5maW5kKGYpLnRyaWdnZXIoXCJmb2N1c1wiKSxkLnRyaWdnZXIoXCJjbGlja1wiKTt2YXIgaD1cIiBsaTpub3QoLmRpc2FibGVkKTp2aXNpYmxlIGFcIixpPWUuZmluZChcIi5kcm9wZG93bi1tZW51XCIraCk7aWYoaS5sZW5ndGgpe3ZhciBqPWkuaW5kZXgoYy50YXJnZXQpOzM4PT1jLndoaWNoJiZqPjAmJmotLSw0MD09Yy53aGljaCYmajxpLmxlbmd0aC0xJiZqKyssfmp8fChqPTApLGkuZXEoaikudHJpZ2dlcihcImZvY3VzXCIpfX19fTt2YXIgaD1hLmZuLmRyb3Bkb3duO2EuZm4uZHJvcGRvd249ZCxhLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yPWcsYS5mbi5kcm9wZG93bi5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4uZHJvcGRvd249aCx0aGlzfSxhKGRvY3VtZW50KS5vbihcImNsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpXCIsYykub24oXCJjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaVwiLFwiLmRyb3Bkb3duIGZvcm1cIixmdW5jdGlvbihhKXthLnN0b3BQcm9wYWdhdGlvbigpfSkub24oXCJjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaVwiLGYsZy5wcm90b3R5cGUudG9nZ2xlKS5vbihcImtleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGlcIixmLGcucHJvdG90eXBlLmtleWRvd24pLm9uKFwia2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaVwiLFwiLmRyb3Bkb3duLW1lbnVcIixnLnByb3RvdHlwZS5rZXlkb3duKX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiLGQpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZT1hKHRoaXMpLGY9ZS5kYXRhKFwiYnMubW9kYWxcIiksZz1hLmV4dGVuZCh7fSxjLkRFRkFVTFRTLGUuZGF0YSgpLFwib2JqZWN0XCI9PXR5cGVvZiBiJiZiKTtmfHxlLmRhdGEoXCJicy5tb2RhbFwiLGY9bmV3IGModGhpcyxnKSksXCJzdHJpbmdcIj09dHlwZW9mIGI/ZltiXShkKTpnLnNob3cmJmYuc2hvdyhkKX0pfXZhciBjPWZ1bmN0aW9uKGIsYyl7dGhpcy5vcHRpb25zPWMsdGhpcy4kYm9keT1hKGRvY3VtZW50LmJvZHkpLHRoaXMuJGVsZW1lbnQ9YShiKSx0aGlzLiRkaWFsb2c9dGhpcy4kZWxlbWVudC5maW5kKFwiLm1vZGFsLWRpYWxvZ1wiKSx0aGlzLiRiYWNrZHJvcD1udWxsLHRoaXMuaXNTaG93bj1udWxsLHRoaXMub3JpZ2luYWxCb2R5UGFkPW51bGwsdGhpcy5zY3JvbGxiYXJXaWR0aD0wLHRoaXMuaWdub3JlQmFja2Ryb3BDbGljaz0hMSx0aGlzLm9wdGlvbnMucmVtb3RlJiZ0aGlzLiRlbGVtZW50LmZpbmQoXCIubW9kYWwtY29udGVudFwiKS5sb2FkKHRoaXMub3B0aW9ucy5yZW1vdGUsYS5wcm94eShmdW5jdGlvbigpe3RoaXMuJGVsZW1lbnQudHJpZ2dlcihcImxvYWRlZC5icy5tb2RhbFwiKX0sdGhpcykpfTtjLlZFUlNJT049XCIzLjMuNVwiLGMuVFJBTlNJVElPTl9EVVJBVElPTj0zMDAsYy5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OPTE1MCxjLkRFRkFVTFRTPXtiYWNrZHJvcDohMCxrZXlib2FyZDohMCxzaG93OiEwfSxjLnByb3RvdHlwZS50b2dnbGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaXNTaG93bj90aGlzLmhpZGUoKTp0aGlzLnNob3coYSl9LGMucHJvdG90eXBlLnNob3c9ZnVuY3Rpb24oYil7dmFyIGQ9dGhpcyxlPWEuRXZlbnQoXCJzaG93LmJzLm1vZGFsXCIse3JlbGF0ZWRUYXJnZXQ6Yn0pO3RoaXMuJGVsZW1lbnQudHJpZ2dlcihlKSx0aGlzLmlzU2hvd258fGUuaXNEZWZhdWx0UHJldmVudGVkKCl8fCh0aGlzLmlzU2hvd249ITAsdGhpcy5jaGVja1Njcm9sbGJhcigpLHRoaXMuc2V0U2Nyb2xsYmFyKCksdGhpcy4kYm9keS5hZGRDbGFzcyhcIm1vZGFsLW9wZW5cIiksdGhpcy5lc2NhcGUoKSx0aGlzLnJlc2l6ZSgpLHRoaXMuJGVsZW1lbnQub24oXCJjbGljay5kaXNtaXNzLmJzLm1vZGFsXCIsJ1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScsYS5wcm94eSh0aGlzLmhpZGUsdGhpcykpLHRoaXMuJGRpYWxvZy5vbihcIm1vdXNlZG93bi5kaXNtaXNzLmJzLm1vZGFsXCIsZnVuY3Rpb24oKXtkLiRlbGVtZW50Lm9uZShcIm1vdXNldXAuZGlzbWlzcy5icy5tb2RhbFwiLGZ1bmN0aW9uKGIpe2EoYi50YXJnZXQpLmlzKGQuJGVsZW1lbnQpJiYoZC5pZ25vcmVCYWNrZHJvcENsaWNrPSEwKX0pfSksdGhpcy5iYWNrZHJvcChmdW5jdGlvbigpe3ZhciBlPWEuc3VwcG9ydC50cmFuc2l0aW9uJiZkLiRlbGVtZW50Lmhhc0NsYXNzKFwiZmFkZVwiKTtkLiRlbGVtZW50LnBhcmVudCgpLmxlbmd0aHx8ZC4kZWxlbWVudC5hcHBlbmRUbyhkLiRib2R5KSxkLiRlbGVtZW50LnNob3coKS5zY3JvbGxUb3AoMCksZC5hZGp1c3REaWFsb2coKSxlJiZkLiRlbGVtZW50WzBdLm9mZnNldFdpZHRoLGQuJGVsZW1lbnQuYWRkQ2xhc3MoXCJpblwiKSxkLmVuZm9yY2VGb2N1cygpO3ZhciBmPWEuRXZlbnQoXCJzaG93bi5icy5tb2RhbFwiLHtyZWxhdGVkVGFyZ2V0OmJ9KTtlP2QuJGRpYWxvZy5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixmdW5jdGlvbigpe2QuJGVsZW1lbnQudHJpZ2dlcihcImZvY3VzXCIpLnRyaWdnZXIoZil9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLlRSQU5TSVRJT05fRFVSQVRJT04pOmQuJGVsZW1lbnQudHJpZ2dlcihcImZvY3VzXCIpLnRyaWdnZXIoZil9KSl9LGMucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oYil7YiYmYi5wcmV2ZW50RGVmYXVsdCgpLGI9YS5FdmVudChcImhpZGUuYnMubW9kYWxcIiksdGhpcy4kZWxlbWVudC50cmlnZ2VyKGIpLHRoaXMuaXNTaG93biYmIWIuaXNEZWZhdWx0UHJldmVudGVkKCkmJih0aGlzLmlzU2hvd249ITEsdGhpcy5lc2NhcGUoKSx0aGlzLnJlc2l6ZSgpLGEoZG9jdW1lbnQpLm9mZihcImZvY3VzaW4uYnMubW9kYWxcIiksdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcImluXCIpLm9mZihcImNsaWNrLmRpc21pc3MuYnMubW9kYWxcIikub2ZmKFwibW91c2V1cC5kaXNtaXNzLmJzLm1vZGFsXCIpLHRoaXMuJGRpYWxvZy5vZmYoXCJtb3VzZWRvd24uZGlzbWlzcy5icy5tb2RhbFwiKSxhLnN1cHBvcnQudHJhbnNpdGlvbiYmdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImZhZGVcIik/dGhpcy4kZWxlbWVudC5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixhLnByb3h5KHRoaXMuaGlkZU1vZGFsLHRoaXMpKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLlRSQU5TSVRJT05fRFVSQVRJT04pOnRoaXMuaGlkZU1vZGFsKCkpfSxjLnByb3RvdHlwZS5lbmZvcmNlRm9jdXM9ZnVuY3Rpb24oKXthKGRvY3VtZW50KS5vZmYoXCJmb2N1c2luLmJzLm1vZGFsXCIpLm9uKFwiZm9jdXNpbi5icy5tb2RhbFwiLGEucHJveHkoZnVuY3Rpb24oYSl7dGhpcy4kZWxlbWVudFswXT09PWEudGFyZ2V0fHx0aGlzLiRlbGVtZW50LmhhcyhhLnRhcmdldCkubGVuZ3RofHx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJmb2N1c1wiKX0sdGhpcykpfSxjLnByb3RvdHlwZS5lc2NhcGU9ZnVuY3Rpb24oKXt0aGlzLmlzU2hvd24mJnRoaXMub3B0aW9ucy5rZXlib2FyZD90aGlzLiRlbGVtZW50Lm9uKFwia2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsXCIsYS5wcm94eShmdW5jdGlvbihhKXsyNz09YS53aGljaCYmdGhpcy5oaWRlKCl9LHRoaXMpKTp0aGlzLmlzU2hvd258fHRoaXMuJGVsZW1lbnQub2ZmKFwia2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsXCIpfSxjLnByb3RvdHlwZS5yZXNpemU9ZnVuY3Rpb24oKXt0aGlzLmlzU2hvd24/YSh3aW5kb3cpLm9uKFwicmVzaXplLmJzLm1vZGFsXCIsYS5wcm94eSh0aGlzLmhhbmRsZVVwZGF0ZSx0aGlzKSk6YSh3aW5kb3cpLm9mZihcInJlc2l6ZS5icy5tb2RhbFwiKX0sYy5wcm90b3R5cGUuaGlkZU1vZGFsPWZ1bmN0aW9uKCl7dmFyIGE9dGhpczt0aGlzLiRlbGVtZW50LmhpZGUoKSx0aGlzLmJhY2tkcm9wKGZ1bmN0aW9uKCl7YS4kYm9keS5yZW1vdmVDbGFzcyhcIm1vZGFsLW9wZW5cIiksYS5yZXNldEFkanVzdG1lbnRzKCksYS5yZXNldFNjcm9sbGJhcigpLGEuJGVsZW1lbnQudHJpZ2dlcihcImhpZGRlbi5icy5tb2RhbFwiKX0pfSxjLnByb3RvdHlwZS5yZW1vdmVCYWNrZHJvcD1mdW5jdGlvbigpe3RoaXMuJGJhY2tkcm9wJiZ0aGlzLiRiYWNrZHJvcC5yZW1vdmUoKSx0aGlzLiRiYWNrZHJvcD1udWxsfSxjLnByb3RvdHlwZS5iYWNrZHJvcD1mdW5jdGlvbihiKXt2YXIgZD10aGlzLGU9dGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImZhZGVcIik/XCJmYWRlXCI6XCJcIjtpZih0aGlzLmlzU2hvd24mJnRoaXMub3B0aW9ucy5iYWNrZHJvcCl7dmFyIGY9YS5zdXBwb3J0LnRyYW5zaXRpb24mJmU7aWYodGhpcy4kYmFja2Ryb3A9YShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKS5hZGRDbGFzcyhcIm1vZGFsLWJhY2tkcm9wIFwiK2UpLmFwcGVuZFRvKHRoaXMuJGJvZHkpLHRoaXMuJGVsZW1lbnQub24oXCJjbGljay5kaXNtaXNzLmJzLm1vZGFsXCIsYS5wcm94eShmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrP3ZvaWQodGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrPSExKTp2b2lkKGEudGFyZ2V0PT09YS5jdXJyZW50VGFyZ2V0JiYoXCJzdGF0aWNcIj09dGhpcy5vcHRpb25zLmJhY2tkcm9wP3RoaXMuJGVsZW1lbnRbMF0uZm9jdXMoKTp0aGlzLmhpZGUoKSkpfSx0aGlzKSksZiYmdGhpcy4kYmFja2Ryb3BbMF0ub2Zmc2V0V2lkdGgsdGhpcy4kYmFja2Ryb3AuYWRkQ2xhc3MoXCJpblwiKSwhYilyZXR1cm47Zj90aGlzLiRiYWNrZHJvcC5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixiKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pOmIoKX1lbHNlIGlmKCF0aGlzLmlzU2hvd24mJnRoaXMuJGJhY2tkcm9wKXt0aGlzLiRiYWNrZHJvcC5yZW1vdmVDbGFzcyhcImluXCIpO3ZhciBnPWZ1bmN0aW9uKCl7ZC5yZW1vdmVCYWNrZHJvcCgpLGImJmIoKX07YS5zdXBwb3J0LnRyYW5zaXRpb24mJnRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJmYWRlXCIpP3RoaXMuJGJhY2tkcm9wLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGcpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGMuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTik6ZygpfWVsc2UgYiYmYigpfSxjLnByb3RvdHlwZS5oYW5kbGVVcGRhdGU9ZnVuY3Rpb24oKXt0aGlzLmFkanVzdERpYWxvZygpfSxjLnByb3RvdHlwZS5hZGp1c3REaWFsb2c9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLiRlbGVtZW50WzBdLnNjcm9sbEhlaWdodD5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O3RoaXMuJGVsZW1lbnQuY3NzKHtwYWRkaW5nTGVmdDohdGhpcy5ib2R5SXNPdmVyZmxvd2luZyYmYT90aGlzLnNjcm9sbGJhcldpZHRoOlwiXCIscGFkZGluZ1JpZ2h0OnRoaXMuYm9keUlzT3ZlcmZsb3dpbmcmJiFhP3RoaXMuc2Nyb2xsYmFyV2lkdGg6XCJcIn0pfSxjLnByb3RvdHlwZS5yZXNldEFkanVzdG1lbnRzPWZ1bmN0aW9uKCl7dGhpcy4kZWxlbWVudC5jc3Moe3BhZGRpbmdMZWZ0OlwiXCIscGFkZGluZ1JpZ2h0OlwiXCJ9KX0sYy5wcm90b3R5cGUuY2hlY2tTY3JvbGxiYXI9ZnVuY3Rpb24oKXt2YXIgYT13aW5kb3cuaW5uZXJXaWR0aDtpZighYSl7dmFyIGI9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2E9Yi5yaWdodC1NYXRoLmFicyhiLmxlZnQpfXRoaXMuYm9keUlzT3ZlcmZsb3dpbmc9ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDxhLHRoaXMuc2Nyb2xsYmFyV2lkdGg9dGhpcy5tZWFzdXJlU2Nyb2xsYmFyKCl9LGMucHJvdG90eXBlLnNldFNjcm9sbGJhcj1mdW5jdGlvbigpe3ZhciBhPXBhcnNlSW50KHRoaXMuJGJvZHkuY3NzKFwicGFkZGluZy1yaWdodFwiKXx8MCwxMCk7dGhpcy5vcmlnaW5hbEJvZHlQYWQ9ZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHR8fFwiXCIsdGhpcy5ib2R5SXNPdmVyZmxvd2luZyYmdGhpcy4kYm9keS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIsYSt0aGlzLnNjcm9sbGJhcldpZHRoKX0sYy5wcm90b3R5cGUucmVzZXRTY3JvbGxiYXI9ZnVuY3Rpb24oKXt0aGlzLiRib2R5LmNzcyhcInBhZGRpbmctcmlnaHRcIix0aGlzLm9yaWdpbmFsQm9keVBhZCl9LGMucHJvdG90eXBlLm1lYXN1cmVTY3JvbGxiYXI9ZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2EuY2xhc3NOYW1lPVwibW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmVcIix0aGlzLiRib2R5LmFwcGVuZChhKTt2YXIgYj1hLm9mZnNldFdpZHRoLWEuY2xpZW50V2lkdGg7cmV0dXJuIHRoaXMuJGJvZHlbMF0ucmVtb3ZlQ2hpbGQoYSksYn07dmFyIGQ9YS5mbi5tb2RhbDthLmZuLm1vZGFsPWIsYS5mbi5tb2RhbC5Db25zdHJ1Y3Rvcj1jLGEuZm4ubW9kYWwubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLm1vZGFsPWQsdGhpc30sYShkb2N1bWVudCkub24oXCJjbGljay5icy5tb2RhbC5kYXRhLWFwaVwiLCdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXScsZnVuY3Rpb24oYyl7dmFyIGQ9YSh0aGlzKSxlPWQuYXR0cihcImhyZWZcIiksZj1hKGQuYXR0cihcImRhdGEtdGFyZ2V0XCIpfHxlJiZlLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sXCJcIikpLGc9Zi5kYXRhKFwiYnMubW9kYWxcIik/XCJ0b2dnbGVcIjphLmV4dGVuZCh7cmVtb3RlOiEvIy8udGVzdChlKSYmZX0sZi5kYXRhKCksZC5kYXRhKCkpO2QuaXMoXCJhXCIpJiZjLnByZXZlbnREZWZhdWx0KCksZi5vbmUoXCJzaG93LmJzLm1vZGFsXCIsZnVuY3Rpb24oYSl7YS5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8Zi5vbmUoXCJoaWRkZW4uYnMubW9kYWxcIixmdW5jdGlvbigpe2QuaXMoXCI6dmlzaWJsZVwiKSYmZC50cmlnZ2VyKFwiZm9jdXNcIil9KX0pLGIuY2FsbChmLGcsdGhpcyl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLnRvb2x0aXBcIiksZj1cIm9iamVjdFwiPT10eXBlb2YgYiYmYjsoZXx8IS9kZXN0cm95fGhpZGUvLnRlc3QoYikpJiYoZXx8ZC5kYXRhKFwiYnMudG9vbHRpcFwiLGU9bmV3IGModGhpcyxmKSksXCJzdHJpbmdcIj09dHlwZW9mIGImJmVbYl0oKSl9KX12YXIgYz1mdW5jdGlvbihhLGIpe3RoaXMudHlwZT1udWxsLHRoaXMub3B0aW9ucz1udWxsLHRoaXMuZW5hYmxlZD1udWxsLHRoaXMudGltZW91dD1udWxsLHRoaXMuaG92ZXJTdGF0ZT1udWxsLHRoaXMuJGVsZW1lbnQ9bnVsbCx0aGlzLmluU3RhdGU9bnVsbCx0aGlzLmluaXQoXCJ0b29sdGlwXCIsYSxiKX07Yy5WRVJTSU9OPVwiMy4zLjVcIixjLlRSQU5TSVRJT05fRFVSQVRJT049MTUwLGMuREVGQVVMVFM9e2FuaW1hdGlvbjohMCxwbGFjZW1lbnQ6XCJ0b3BcIixzZWxlY3RvcjohMSx0ZW1wbGF0ZTonPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLHRyaWdnZXI6XCJob3ZlciBmb2N1c1wiLHRpdGxlOlwiXCIsZGVsYXk6MCxodG1sOiExLGNvbnRhaW5lcjohMSx2aWV3cG9ydDp7c2VsZWN0b3I6XCJib2R5XCIscGFkZGluZzowfX0sYy5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihiLGMsZCl7aWYodGhpcy5lbmFibGVkPSEwLHRoaXMudHlwZT1iLHRoaXMuJGVsZW1lbnQ9YShjKSx0aGlzLm9wdGlvbnM9dGhpcy5nZXRPcHRpb25zKGQpLHRoaXMuJHZpZXdwb3J0PXRoaXMub3B0aW9ucy52aWV3cG9ydCYmYShhLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLnZpZXdwb3J0KT90aGlzLm9wdGlvbnMudmlld3BvcnQuY2FsbCh0aGlzLHRoaXMuJGVsZW1lbnQpOnRoaXMub3B0aW9ucy52aWV3cG9ydC5zZWxlY3Rvcnx8dGhpcy5vcHRpb25zLnZpZXdwb3J0KSx0aGlzLmluU3RhdGU9e2NsaWNrOiExLGhvdmVyOiExLGZvY3VzOiExfSx0aGlzLiRlbGVtZW50WzBdaW5zdGFuY2VvZiBkb2N1bWVudC5jb25zdHJ1Y3RvciYmIXRoaXMub3B0aW9ucy5zZWxlY3Rvcil0aHJvdyBuZXcgRXJyb3IoXCJgc2VsZWN0b3JgIG9wdGlvbiBtdXN0IGJlIHNwZWNpZmllZCB3aGVuIGluaXRpYWxpemluZyBcIit0aGlzLnR5cGUrXCIgb24gdGhlIHdpbmRvdy5kb2N1bWVudCBvYmplY3QhXCIpO2Zvcih2YXIgZT10aGlzLm9wdGlvbnMudHJpZ2dlci5zcGxpdChcIiBcIiksZj1lLmxlbmd0aDtmLS07KXt2YXIgZz1lW2ZdO2lmKFwiY2xpY2tcIj09Zyl0aGlzLiRlbGVtZW50Lm9uKFwiY2xpY2suXCIrdGhpcy50eXBlLHRoaXMub3B0aW9ucy5zZWxlY3RvcixhLnByb3h5KHRoaXMudG9nZ2xlLHRoaXMpKTtlbHNlIGlmKFwibWFudWFsXCIhPWcpe3ZhciBoPVwiaG92ZXJcIj09Zz9cIm1vdXNlZW50ZXJcIjpcImZvY3VzaW5cIixpPVwiaG92ZXJcIj09Zz9cIm1vdXNlbGVhdmVcIjpcImZvY3Vzb3V0XCI7dGhpcy4kZWxlbWVudC5vbihoK1wiLlwiK3RoaXMudHlwZSx0aGlzLm9wdGlvbnMuc2VsZWN0b3IsYS5wcm94eSh0aGlzLmVudGVyLHRoaXMpKSx0aGlzLiRlbGVtZW50Lm9uKGkrXCIuXCIrdGhpcy50eXBlLHRoaXMub3B0aW9ucy5zZWxlY3RvcixhLnByb3h5KHRoaXMubGVhdmUsdGhpcykpfX10aGlzLm9wdGlvbnMuc2VsZWN0b3I/dGhpcy5fb3B0aW9ucz1hLmV4dGVuZCh7fSx0aGlzLm9wdGlvbnMse3RyaWdnZXI6XCJtYW51YWxcIixzZWxlY3RvcjpcIlwifSk6dGhpcy5maXhUaXRsZSgpfSxjLnByb3RvdHlwZS5nZXREZWZhdWx0cz1mdW5jdGlvbigpe3JldHVybiBjLkRFRkFVTFRTfSxjLnByb3RvdHlwZS5nZXRPcHRpb25zPWZ1bmN0aW9uKGIpe3JldHVybiBiPWEuZXh0ZW5kKHt9LHRoaXMuZ2V0RGVmYXVsdHMoKSx0aGlzLiRlbGVtZW50LmRhdGEoKSxiKSxiLmRlbGF5JiZcIm51bWJlclwiPT10eXBlb2YgYi5kZWxheSYmKGIuZGVsYXk9e3Nob3c6Yi5kZWxheSxoaWRlOmIuZGVsYXl9KSxifSxjLnByb3RvdHlwZS5nZXREZWxlZ2F0ZU9wdGlvbnM9ZnVuY3Rpb24oKXt2YXIgYj17fSxjPXRoaXMuZ2V0RGVmYXVsdHMoKTtyZXR1cm4gdGhpcy5fb3B0aW9ucyYmYS5lYWNoKHRoaXMuX29wdGlvbnMsZnVuY3Rpb24oYSxkKXtjW2FdIT1kJiYoYlthXT1kKX0pLGJ9LGMucHJvdG90eXBlLmVudGVyPWZ1bmN0aW9uKGIpe3ZhciBjPWIgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yP2I6YShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUpO3JldHVybiBjfHwoYz1uZXcgdGhpcy5jb25zdHJ1Y3RvcihiLmN1cnJlbnRUYXJnZXQsdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSksYShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUsYykpLGIgaW5zdGFuY2VvZiBhLkV2ZW50JiYoYy5pblN0YXRlW1wiZm9jdXNpblwiPT1iLnR5cGU/XCJmb2N1c1wiOlwiaG92ZXJcIl09ITApLGMudGlwKCkuaGFzQ2xhc3MoXCJpblwiKXx8XCJpblwiPT1jLmhvdmVyU3RhdGU/dm9pZChjLmhvdmVyU3RhdGU9XCJpblwiKTooY2xlYXJUaW1lb3V0KGMudGltZW91dCksYy5ob3ZlclN0YXRlPVwiaW5cIixjLm9wdGlvbnMuZGVsYXkmJmMub3B0aW9ucy5kZWxheS5zaG93P3ZvaWQoYy50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtcImluXCI9PWMuaG92ZXJTdGF0ZSYmYy5zaG93KCl9LGMub3B0aW9ucy5kZWxheS5zaG93KSk6Yy5zaG93KCkpfSxjLnByb3RvdHlwZS5pc0luU3RhdGVUcnVlPWZ1bmN0aW9uKCl7Zm9yKHZhciBhIGluIHRoaXMuaW5TdGF0ZSlpZih0aGlzLmluU3RhdGVbYV0pcmV0dXJuITA7cmV0dXJuITF9LGMucHJvdG90eXBlLmxlYXZlPWZ1bmN0aW9uKGIpe3ZhciBjPWIgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yP2I6YShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUpO3JldHVybiBjfHwoYz1uZXcgdGhpcy5jb25zdHJ1Y3RvcihiLmN1cnJlbnRUYXJnZXQsdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSksYShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUsYykpLGIgaW5zdGFuY2VvZiBhLkV2ZW50JiYoYy5pblN0YXRlW1wiZm9jdXNvdXRcIj09Yi50eXBlP1wiZm9jdXNcIjpcImhvdmVyXCJdPSExKSxjLmlzSW5TdGF0ZVRydWUoKT92b2lkIDA6KGNsZWFyVGltZW91dChjLnRpbWVvdXQpLGMuaG92ZXJTdGF0ZT1cIm91dFwiLGMub3B0aW9ucy5kZWxheSYmYy5vcHRpb25zLmRlbGF5LmhpZGU/dm9pZChjLnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe1wib3V0XCI9PWMuaG92ZXJTdGF0ZSYmYy5oaWRlKCl9LGMub3B0aW9ucy5kZWxheS5oaWRlKSk6Yy5oaWRlKCkpfSxjLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKCl7dmFyIGI9YS5FdmVudChcInNob3cuYnMuXCIrdGhpcy50eXBlKTtpZih0aGlzLmhhc0NvbnRlbnQoKSYmdGhpcy5lbmFibGVkKXt0aGlzLiRlbGVtZW50LnRyaWdnZXIoYik7dmFyIGQ9YS5jb250YWlucyh0aGlzLiRlbGVtZW50WzBdLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHRoaXMuJGVsZW1lbnRbMF0pO2lmKGIuaXNEZWZhdWx0UHJldmVudGVkKCl8fCFkKXJldHVybjt2YXIgZT10aGlzLGY9dGhpcy50aXAoKSxnPXRoaXMuZ2V0VUlEKHRoaXMudHlwZSk7dGhpcy5zZXRDb250ZW50KCksZi5hdHRyKFwiaWRcIixnKSx0aGlzLiRlbGVtZW50LmF0dHIoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsZyksdGhpcy5vcHRpb25zLmFuaW1hdGlvbiYmZi5hZGRDbGFzcyhcImZhZGVcIik7dmFyIGg9XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5vcHRpb25zLnBsYWNlbWVudD90aGlzLm9wdGlvbnMucGxhY2VtZW50LmNhbGwodGhpcyxmWzBdLHRoaXMuJGVsZW1lbnRbMF0pOnRoaXMub3B0aW9ucy5wbGFjZW1lbnQsaT0vXFxzP2F1dG8/XFxzPy9pLGo9aS50ZXN0KGgpO2omJihoPWgucmVwbGFjZShpLFwiXCIpfHxcInRvcFwiKSxmLmRldGFjaCgpLmNzcyh7dG9wOjAsbGVmdDowLGRpc3BsYXk6XCJibG9ja1wifSkuYWRkQ2xhc3MoaCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSx0aGlzKSx0aGlzLm9wdGlvbnMuY29udGFpbmVyP2YuYXBwZW5kVG8odGhpcy5vcHRpb25zLmNvbnRhaW5lcik6Zi5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJpbnNlcnRlZC5icy5cIit0aGlzLnR5cGUpO3ZhciBrPXRoaXMuZ2V0UG9zaXRpb24oKSxsPWZbMF0ub2Zmc2V0V2lkdGgsbT1mWzBdLm9mZnNldEhlaWdodDtpZihqKXt2YXIgbj1oLG89dGhpcy5nZXRQb3NpdGlvbih0aGlzLiR2aWV3cG9ydCk7aD1cImJvdHRvbVwiPT1oJiZrLmJvdHRvbSttPm8uYm90dG9tP1widG9wXCI6XCJ0b3BcIj09aCYmay50b3AtbTxvLnRvcD9cImJvdHRvbVwiOlwicmlnaHRcIj09aCYmay5yaWdodCtsPm8ud2lkdGg/XCJsZWZ0XCI6XCJsZWZ0XCI9PWgmJmsubGVmdC1sPG8ubGVmdD9cInJpZ2h0XCI6aCxmLnJlbW92ZUNsYXNzKG4pLmFkZENsYXNzKGgpfXZhciBwPXRoaXMuZ2V0Q2FsY3VsYXRlZE9mZnNldChoLGssbCxtKTt0aGlzLmFwcGx5UGxhY2VtZW50KHAsaCk7dmFyIHE9ZnVuY3Rpb24oKXt2YXIgYT1lLmhvdmVyU3RhdGU7ZS4kZWxlbWVudC50cmlnZ2VyKFwic2hvd24uYnMuXCIrZS50eXBlKSxlLmhvdmVyU3RhdGU9bnVsbCxcIm91dFwiPT1hJiZlLmxlYXZlKGUpfTthLnN1cHBvcnQudHJhbnNpdGlvbiYmdGhpcy4kdGlwLmhhc0NsYXNzKFwiZmFkZVwiKT9mLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLHEpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGMuVFJBTlNJVElPTl9EVVJBVElPTik6cSgpfX0sYy5wcm90b3R5cGUuYXBwbHlQbGFjZW1lbnQ9ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLnRpcCgpLGU9ZFswXS5vZmZzZXRXaWR0aCxmPWRbMF0ub2Zmc2V0SGVpZ2h0LGc9cGFyc2VJbnQoZC5jc3MoXCJtYXJnaW4tdG9wXCIpLDEwKSxoPXBhcnNlSW50KGQuY3NzKFwibWFyZ2luLWxlZnRcIiksMTApO2lzTmFOKGcpJiYoZz0wKSxpc05hTihoKSYmKGg9MCksYi50b3ArPWcsYi5sZWZ0Kz1oLGEub2Zmc2V0LnNldE9mZnNldChkWzBdLGEuZXh0ZW5kKHt1c2luZzpmdW5jdGlvbihhKXtkLmNzcyh7dG9wOk1hdGgucm91bmQoYS50b3ApLGxlZnQ6TWF0aC5yb3VuZChhLmxlZnQpfSl9fSxiKSwwKSxkLmFkZENsYXNzKFwiaW5cIik7dmFyIGk9ZFswXS5vZmZzZXRXaWR0aCxqPWRbMF0ub2Zmc2V0SGVpZ2h0O1widG9wXCI9PWMmJmohPWYmJihiLnRvcD1iLnRvcCtmLWopO3ZhciBrPXRoaXMuZ2V0Vmlld3BvcnRBZGp1c3RlZERlbHRhKGMsYixpLGopO2subGVmdD9iLmxlZnQrPWsubGVmdDpiLnRvcCs9ay50b3A7dmFyIGw9L3RvcHxib3R0b20vLnRlc3QoYyksbT1sPzIqay5sZWZ0LWUraToyKmsudG9wLWYraixuPWw/XCJvZmZzZXRXaWR0aFwiOlwib2Zmc2V0SGVpZ2h0XCI7ZC5vZmZzZXQoYiksdGhpcy5yZXBsYWNlQXJyb3cobSxkWzBdW25dLGwpfSxjLnByb3RvdHlwZS5yZXBsYWNlQXJyb3c9ZnVuY3Rpb24oYSxiLGMpe3RoaXMuYXJyb3coKS5jc3MoYz9cImxlZnRcIjpcInRvcFwiLDUwKigxLWEvYikrXCIlXCIpLmNzcyhjP1widG9wXCI6XCJsZWZ0XCIsXCJcIil9LGMucHJvdG90eXBlLnNldENvbnRlbnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnRpcCgpLGI9dGhpcy5nZXRUaXRsZSgpO2EuZmluZChcIi50b29sdGlwLWlubmVyXCIpW3RoaXMub3B0aW9ucy5odG1sP1wiaHRtbFwiOlwidGV4dFwiXShiKSxhLnJlbW92ZUNsYXNzKFwiZmFkZSBpbiB0b3AgYm90dG9tIGxlZnQgcmlnaHRcIil9LGMucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gZCgpe1wiaW5cIiE9ZS5ob3ZlclN0YXRlJiZmLmRldGFjaCgpLGUuJGVsZW1lbnQucmVtb3ZlQXR0cihcImFyaWEtZGVzY3JpYmVkYnlcIikudHJpZ2dlcihcImhpZGRlbi5icy5cIitlLnR5cGUpLGImJmIoKX12YXIgZT10aGlzLGY9YSh0aGlzLiR0aXApLGc9YS5FdmVudChcImhpZGUuYnMuXCIrdGhpcy50eXBlKTtyZXR1cm4gdGhpcy4kZWxlbWVudC50cmlnZ2VyKGcpLGcuaXNEZWZhdWx0UHJldmVudGVkKCk/dm9pZCAwOihmLnJlbW92ZUNsYXNzKFwiaW5cIiksYS5zdXBwb3J0LnRyYW5zaXRpb24mJmYuaGFzQ2xhc3MoXCJmYWRlXCIpP2Yub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsZCkuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5UUkFOU0lUSU9OX0RVUkFUSU9OKTpkKCksdGhpcy5ob3ZlclN0YXRlPW51bGwsdGhpcyl9LGMucHJvdG90eXBlLmZpeFRpdGxlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy4kZWxlbWVudDsoYS5hdHRyKFwidGl0bGVcIil8fFwic3RyaW5nXCIhPXR5cGVvZiBhLmF0dHIoXCJkYXRhLW9yaWdpbmFsLXRpdGxlXCIpKSYmYS5hdHRyKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiLGEuYXR0cihcInRpdGxlXCIpfHxcIlwiKS5hdHRyKFwidGl0bGVcIixcIlwiKX0sYy5wcm90b3R5cGUuaGFzQ29udGVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFRpdGxlKCl9LGMucHJvdG90eXBlLmdldFBvc2l0aW9uPWZ1bmN0aW9uKGIpe2I9Ynx8dGhpcy4kZWxlbWVudDt2YXIgYz1iWzBdLGQ9XCJCT0RZXCI9PWMudGFnTmFtZSxlPWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7bnVsbD09ZS53aWR0aCYmKGU9YS5leHRlbmQoe30sZSx7d2lkdGg6ZS5yaWdodC1lLmxlZnQsaGVpZ2h0OmUuYm90dG9tLWUudG9wfSkpO3ZhciBmPWQ/e3RvcDowLGxlZnQ6MH06Yi5vZmZzZXQoKSxnPXtzY3JvbGw6ZD9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wfHxkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDpiLnNjcm9sbFRvcCgpfSxoPWQ/e3dpZHRoOmEod2luZG93KS53aWR0aCgpLGhlaWdodDphKHdpbmRvdykuaGVpZ2h0KCl9Om51bGw7cmV0dXJuIGEuZXh0ZW5kKHt9LGUsZyxoLGYpfSxjLnByb3RvdHlwZS5nZXRDYWxjdWxhdGVkT2Zmc2V0PWZ1bmN0aW9uKGEsYixjLGQpe3JldHVyblwiYm90dG9tXCI9PWE/e3RvcDpiLnRvcCtiLmhlaWdodCxsZWZ0OmIubGVmdCtiLndpZHRoLzItYy8yfTpcInRvcFwiPT1hP3t0b3A6Yi50b3AtZCxsZWZ0OmIubGVmdCtiLndpZHRoLzItYy8yfTpcImxlZnRcIj09YT97dG9wOmIudG9wK2IuaGVpZ2h0LzItZC8yLGxlZnQ6Yi5sZWZ0LWN9Ont0b3A6Yi50b3ArYi5oZWlnaHQvMi1kLzIsbGVmdDpiLmxlZnQrYi53aWR0aH19LGMucHJvdG90eXBlLmdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT17dG9wOjAsbGVmdDowfTtpZighdGhpcy4kdmlld3BvcnQpcmV0dXJuIGU7dmFyIGY9dGhpcy5vcHRpb25zLnZpZXdwb3J0JiZ0aGlzLm9wdGlvbnMudmlld3BvcnQucGFkZGluZ3x8MCxnPXRoaXMuZ2V0UG9zaXRpb24odGhpcy4kdmlld3BvcnQpO2lmKC9yaWdodHxsZWZ0Ly50ZXN0KGEpKXt2YXIgaD1iLnRvcC1mLWcuc2Nyb2xsLGk9Yi50b3ArZi1nLnNjcm9sbCtkO2g8Zy50b3A/ZS50b3A9Zy50b3AtaDppPmcudG9wK2cuaGVpZ2h0JiYoZS50b3A9Zy50b3ArZy5oZWlnaHQtaSl9ZWxzZXt2YXIgaj1iLmxlZnQtZixrPWIubGVmdCtmK2M7ajxnLmxlZnQ/ZS5sZWZ0PWcubGVmdC1qOms+Zy5yaWdodCYmKGUubGVmdD1nLmxlZnQrZy53aWR0aC1rKX1yZXR1cm4gZX0sYy5wcm90b3R5cGUuZ2V0VGl0bGU9ZnVuY3Rpb24oKXt2YXIgYSxiPXRoaXMuJGVsZW1lbnQsYz10aGlzLm9wdGlvbnM7cmV0dXJuIGE9Yi5hdHRyKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGMudGl0bGU/Yy50aXRsZS5jYWxsKGJbMF0pOmMudGl0bGUpfSxjLnByb3RvdHlwZS5nZXRVSUQ9ZnVuY3Rpb24oYSl7ZG8gYSs9fn4oMWU2Kk1hdGgucmFuZG9tKCkpO3doaWxlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpKTtyZXR1cm4gYX0sYy5wcm90b3R5cGUudGlwPWZ1bmN0aW9uKCl7aWYoIXRoaXMuJHRpcCYmKHRoaXMuJHRpcD1hKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSksMSE9dGhpcy4kdGlwLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKHRoaXMudHlwZStcIiBgdGVtcGxhdGVgIG9wdGlvbiBtdXN0IGNvbnNpc3Qgb2YgZXhhY3RseSAxIHRvcC1sZXZlbCBlbGVtZW50IVwiKTtyZXR1cm4gdGhpcy4kdGlwfSxjLnByb3RvdHlwZS5hcnJvdz1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRhcnJvdz10aGlzLiRhcnJvd3x8dGhpcy50aXAoKS5maW5kKFwiLnRvb2x0aXAtYXJyb3dcIil9LGMucHJvdG90eXBlLmVuYWJsZT1mdW5jdGlvbigpe3RoaXMuZW5hYmxlZD0hMH0sYy5wcm90b3R5cGUuZGlzYWJsZT1mdW5jdGlvbigpe3RoaXMuZW5hYmxlZD0hMX0sYy5wcm90b3R5cGUudG9nZ2xlRW5hYmxlZD1mdW5jdGlvbigpe3RoaXMuZW5hYmxlZD0hdGhpcy5lbmFibGVkfSxjLnByb3RvdHlwZS50b2dnbGU9ZnVuY3Rpb24oYil7dmFyIGM9dGhpcztiJiYoYz1hKGIuY3VycmVudFRhcmdldCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSksY3x8KGM9bmV3IHRoaXMuY29uc3RydWN0b3IoYi5jdXJyZW50VGFyZ2V0LHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpLGEoYi5jdXJyZW50VGFyZ2V0KS5kYXRhKFwiYnMuXCIrdGhpcy50eXBlLGMpKSksYj8oYy5pblN0YXRlLmNsaWNrPSFjLmluU3RhdGUuY2xpY2ssYy5pc0luU3RhdGVUcnVlKCk/Yy5lbnRlcihjKTpjLmxlYXZlKGMpKTpjLnRpcCgpLmhhc0NsYXNzKFwiaW5cIik/Yy5sZWF2ZShjKTpjLmVudGVyKGMpfSxjLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KSx0aGlzLmhpZGUoZnVuY3Rpb24oKXthLiRlbGVtZW50Lm9mZihcIi5cIithLnR5cGUpLnJlbW92ZURhdGEoXCJicy5cIithLnR5cGUpLGEuJHRpcCYmYS4kdGlwLmRldGFjaCgpLGEuJHRpcD1udWxsLGEuJGFycm93PW51bGwsYS4kdmlld3BvcnQ9bnVsbH0pfTt2YXIgZD1hLmZuLnRvb2x0aXA7YS5mbi50b29sdGlwPWIsYS5mbi50b29sdGlwLkNvbnN0cnVjdG9yPWMsYS5mbi50b29sdGlwLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi50b29sdGlwPWQsdGhpc319KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy5wb3BvdmVyXCIpLGY9XCJvYmplY3RcIj09dHlwZW9mIGImJmI7KGV8fCEvZGVzdHJveXxoaWRlLy50ZXN0KGIpKSYmKGV8fGQuZGF0YShcImJzLnBvcG92ZXJcIixlPW5ldyBjKHRoaXMsZikpLFwic3RyaW5nXCI9PXR5cGVvZiBiJiZlW2JdKCkpfSl9dmFyIGM9ZnVuY3Rpb24oYSxiKXt0aGlzLmluaXQoXCJwb3BvdmVyXCIsYSxiKX07aWYoIWEuZm4udG9vbHRpcCl0aHJvdyBuZXcgRXJyb3IoXCJQb3BvdmVyIHJlcXVpcmVzIHRvb2x0aXAuanNcIik7Yy5WRVJTSU9OPVwiMy4zLjVcIixjLkRFRkFVTFRTPWEuZXh0ZW5kKHt9LGEuZm4udG9vbHRpcC5Db25zdHJ1Y3Rvci5ERUZBVUxUUyx7cGxhY2VtZW50OlwicmlnaHRcIix0cmlnZ2VyOlwiY2xpY2tcIixjb250ZW50OlwiXCIsdGVtcGxhdGU6JzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwiYXJyb3dcIj48L2Rpdj48aDMgY2xhc3M9XCJwb3BvdmVyLXRpdGxlXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1jb250ZW50XCI+PC9kaXY+PC9kaXY+J30pLGMucHJvdG90eXBlPWEuZXh0ZW5kKHt9LGEuZm4udG9vbHRpcC5Db25zdHJ1Y3Rvci5wcm90b3R5cGUpLGMucHJvdG90eXBlLmNvbnN0cnVjdG9yPWMsYy5wcm90b3R5cGUuZ2V0RGVmYXVsdHM9ZnVuY3Rpb24oKXtyZXR1cm4gYy5ERUZBVUxUU30sYy5wcm90b3R5cGUuc2V0Q29udGVudD1mdW5jdGlvbigpe3ZhciBhPXRoaXMudGlwKCksYj10aGlzLmdldFRpdGxlKCksYz10aGlzLmdldENvbnRlbnQoKTthLmZpbmQoXCIucG9wb3Zlci10aXRsZVwiKVt0aGlzLm9wdGlvbnMuaHRtbD9cImh0bWxcIjpcInRleHRcIl0oYiksYS5maW5kKFwiLnBvcG92ZXItY29udGVudFwiKS5jaGlsZHJlbigpLmRldGFjaCgpLmVuZCgpW3RoaXMub3B0aW9ucy5odG1sP1wic3RyaW5nXCI9PXR5cGVvZiBjP1wiaHRtbFwiOlwiYXBwZW5kXCI6XCJ0ZXh0XCJdKGMpLGEucmVtb3ZlQ2xhc3MoXCJmYWRlIHRvcCBib3R0b20gbGVmdCByaWdodCBpblwiKSxhLmZpbmQoXCIucG9wb3Zlci10aXRsZVwiKS5odG1sKCl8fGEuZmluZChcIi5wb3BvdmVyLXRpdGxlXCIpLmhpZGUoKX0sYy5wcm90b3R5cGUuaGFzQ29udGVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFRpdGxlKCl8fHRoaXMuZ2V0Q29udGVudCgpfSxjLnByb3RvdHlwZS5nZXRDb250ZW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy4kZWxlbWVudCxiPXRoaXMub3B0aW9ucztyZXR1cm4gYS5hdHRyKFwiZGF0YS1jb250ZW50XCIpfHwoXCJmdW5jdGlvblwiPT10eXBlb2YgYi5jb250ZW50P2IuY29udGVudC5jYWxsKGFbMF0pOmIuY29udGVudCl9LGMucHJvdG90eXBlLmFycm93PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGFycm93PXRoaXMuJGFycm93fHx0aGlzLnRpcCgpLmZpbmQoXCIuYXJyb3dcIil9O3ZhciBkPWEuZm4ucG9wb3ZlcjthLmZuLnBvcG92ZXI9YixhLmZuLnBvcG92ZXIuQ29uc3RydWN0b3I9YyxhLmZuLnBvcG92ZXIubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLnBvcG92ZXI9ZCx0aGlzfX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihjLGQpe3RoaXMuJGJvZHk9YShkb2N1bWVudC5ib2R5KSx0aGlzLiRzY3JvbGxFbGVtZW50PWEoYShjKS5pcyhkb2N1bWVudC5ib2R5KT93aW5kb3c6YyksdGhpcy5vcHRpb25zPWEuZXh0ZW5kKHt9LGIuREVGQVVMVFMsZCksdGhpcy5zZWxlY3Rvcj0odGhpcy5vcHRpb25zLnRhcmdldHx8XCJcIikrXCIgLm5hdiBsaSA+IGFcIix0aGlzLm9mZnNldHM9W10sdGhpcy50YXJnZXRzPVtdLHRoaXMuYWN0aXZlVGFyZ2V0PW51bGwsdGhpcy5zY3JvbGxIZWlnaHQ9MCx0aGlzLiRzY3JvbGxFbGVtZW50Lm9uKFwic2Nyb2xsLmJzLnNjcm9sbHNweVwiLGEucHJveHkodGhpcy5wcm9jZXNzLHRoaXMpKSx0aGlzLnJlZnJlc2goKSx0aGlzLnByb2Nlc3MoKX1mdW5jdGlvbiBjKGMpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZD1hKHRoaXMpLGU9ZC5kYXRhKFwiYnMuc2Nyb2xsc3B5XCIpLGY9XCJvYmplY3RcIj09dHlwZW9mIGMmJmM7ZXx8ZC5kYXRhKFwiYnMuc2Nyb2xsc3B5XCIsZT1uZXcgYih0aGlzLGYpKSxcInN0cmluZ1wiPT10eXBlb2YgYyYmZVtjXSgpfSl9Yi5WRVJTSU9OPVwiMy4zLjVcIixiLkRFRkFVTFRTPXtvZmZzZXQ6MTB9LGIucHJvdG90eXBlLmdldFNjcm9sbEhlaWdodD1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRzY3JvbGxFbGVtZW50WzBdLnNjcm9sbEhlaWdodHx8TWF0aC5tYXgodGhpcy4kYm9keVswXS5zY3JvbGxIZWlnaHQsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCl9LGIucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLGM9XCJvZmZzZXRcIixkPTA7dGhpcy5vZmZzZXRzPVtdLHRoaXMudGFyZ2V0cz1bXSx0aGlzLnNjcm9sbEhlaWdodD10aGlzLmdldFNjcm9sbEhlaWdodCgpLGEuaXNXaW5kb3codGhpcy4kc2Nyb2xsRWxlbWVudFswXSl8fChjPVwicG9zaXRpb25cIixkPXRoaXMuJHNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wKCkpLHRoaXMuJGJvZHkuZmluZCh0aGlzLnNlbGVjdG9yKS5tYXAoZnVuY3Rpb24oKXt2YXIgYj1hKHRoaXMpLGU9Yi5kYXRhKFwidGFyZ2V0XCIpfHxiLmF0dHIoXCJocmVmXCIpLGY9L14jLi8udGVzdChlKSYmYShlKTtyZXR1cm4gZiYmZi5sZW5ndGgmJmYuaXMoXCI6dmlzaWJsZVwiKSYmW1tmW2NdKCkudG9wK2QsZV1dfHxudWxsfSkuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhWzBdLWJbMF19KS5lYWNoKGZ1bmN0aW9uKCl7Yi5vZmZzZXRzLnB1c2godGhpc1swXSksYi50YXJnZXRzLnB1c2godGhpc1sxXSl9KX0sYi5wcm90b3R5cGUucHJvY2Vzcz1mdW5jdGlvbigpe3ZhciBhLGI9dGhpcy4kc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3AoKSt0aGlzLm9wdGlvbnMub2Zmc2V0LGM9dGhpcy5nZXRTY3JvbGxIZWlnaHQoKSxkPXRoaXMub3B0aW9ucy5vZmZzZXQrYy10aGlzLiRzY3JvbGxFbGVtZW50LmhlaWdodCgpLGU9dGhpcy5vZmZzZXRzLGY9dGhpcy50YXJnZXRzLGc9dGhpcy5hY3RpdmVUYXJnZXQ7aWYodGhpcy5zY3JvbGxIZWlnaHQhPWMmJnRoaXMucmVmcmVzaCgpLGI+PWQpcmV0dXJuIGchPShhPWZbZi5sZW5ndGgtMV0pJiZ0aGlzLmFjdGl2YXRlKGEpO2lmKGcmJmI8ZVswXSlyZXR1cm4gdGhpcy5hY3RpdmVUYXJnZXQ9bnVsbCx0aGlzLmNsZWFyKCk7Zm9yKGE9ZS5sZW5ndGg7YS0tOylnIT1mW2FdJiZiPj1lW2FdJiYodm9pZCAwPT09ZVthKzFdfHxiPGVbYSsxXSkmJnRoaXMuYWN0aXZhdGUoZlthXSl9LGIucHJvdG90eXBlLmFjdGl2YXRlPWZ1bmN0aW9uKGIpe3RoaXMuYWN0aXZlVGFyZ2V0PWIsdGhpcy5jbGVhcigpO3ZhciBjPXRoaXMuc2VsZWN0b3IrJ1tkYXRhLXRhcmdldD1cIicrYisnXCJdLCcrdGhpcy5zZWxlY3RvcisnW2hyZWY9XCInK2IrJ1wiXScsZD1hKGMpLnBhcmVudHMoXCJsaVwiKS5hZGRDbGFzcyhcImFjdGl2ZVwiKTtkLnBhcmVudChcIi5kcm9wZG93bi1tZW51XCIpLmxlbmd0aCYmKGQ9ZC5jbG9zZXN0KFwibGkuZHJvcGRvd25cIikuYWRkQ2xhc3MoXCJhY3RpdmVcIikpLFxuICAgIGQudHJpZ2dlcihcImFjdGl2YXRlLmJzLnNjcm9sbHNweVwiKX0sYi5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXthKHRoaXMuc2VsZWN0b3IpLnBhcmVudHNVbnRpbCh0aGlzLm9wdGlvbnMudGFyZ2V0LFwiLmFjdGl2ZVwiKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKX07dmFyIGQ9YS5mbi5zY3JvbGxzcHk7YS5mbi5zY3JvbGxzcHk9YyxhLmZuLnNjcm9sbHNweS5Db25zdHJ1Y3Rvcj1iLGEuZm4uc2Nyb2xsc3B5Lm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5zY3JvbGxzcHk9ZCx0aGlzfSxhKHdpbmRvdykub24oXCJsb2FkLmJzLnNjcm9sbHNweS5kYXRhLWFwaVwiLGZ1bmN0aW9uKCl7YSgnW2RhdGEtc3B5PVwic2Nyb2xsXCJdJykuZWFjaChmdW5jdGlvbigpe3ZhciBiPWEodGhpcyk7Yy5jYWxsKGIsYi5kYXRhKCkpfSl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLnRhYlwiKTtlfHxkLmRhdGEoXCJicy50YWJcIixlPW5ldyBjKHRoaXMpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZVtiXSgpfSl9dmFyIGM9ZnVuY3Rpb24oYil7dGhpcy5lbGVtZW50PWEoYil9O2MuVkVSU0lPTj1cIjMuMy41XCIsYy5UUkFOU0lUSU9OX0RVUkFUSU9OPTE1MCxjLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5lbGVtZW50LGM9Yi5jbG9zZXN0KFwidWw6bm90KC5kcm9wZG93bi1tZW51KVwiKSxkPWIuZGF0YShcInRhcmdldFwiKTtpZihkfHwoZD1iLmF0dHIoXCJocmVmXCIpLGQ9ZCYmZC5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLFwiXCIpKSwhYi5wYXJlbnQoXCJsaVwiKS5oYXNDbGFzcyhcImFjdGl2ZVwiKSl7dmFyIGU9Yy5maW5kKFwiLmFjdGl2ZTpsYXN0IGFcIiksZj1hLkV2ZW50KFwiaGlkZS5icy50YWJcIix7cmVsYXRlZFRhcmdldDpiWzBdfSksZz1hLkV2ZW50KFwic2hvdy5icy50YWJcIix7cmVsYXRlZFRhcmdldDplWzBdfSk7aWYoZS50cmlnZ2VyKGYpLGIudHJpZ2dlcihnKSwhZy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSYmIWYuaXNEZWZhdWx0UHJldmVudGVkKCkpe3ZhciBoPWEoZCk7dGhpcy5hY3RpdmF0ZShiLmNsb3Nlc3QoXCJsaVwiKSxjKSx0aGlzLmFjdGl2YXRlKGgsaC5wYXJlbnQoKSxmdW5jdGlvbigpe2UudHJpZ2dlcih7dHlwZTpcImhpZGRlbi5icy50YWJcIixyZWxhdGVkVGFyZ2V0OmJbMF19KSxiLnRyaWdnZXIoe3R5cGU6XCJzaG93bi5icy50YWJcIixyZWxhdGVkVGFyZ2V0OmVbMF19KX0pfX19LGMucHJvdG90eXBlLmFjdGl2YXRlPWZ1bmN0aW9uKGIsZCxlKXtmdW5jdGlvbiBmKCl7Zy5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKS5maW5kKFwiPiAuZHJvcGRvd24tbWVudSA+IC5hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIikuZW5kKCkuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJykuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMSksYi5hZGRDbGFzcyhcImFjdGl2ZVwiKS5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCEwKSxoPyhiWzBdLm9mZnNldFdpZHRoLGIuYWRkQ2xhc3MoXCJpblwiKSk6Yi5yZW1vdmVDbGFzcyhcImZhZGVcIiksYi5wYXJlbnQoXCIuZHJvcGRvd24tbWVudVwiKS5sZW5ndGgmJmIuY2xvc2VzdChcImxpLmRyb3Bkb3duXCIpLmFkZENsYXNzKFwiYWN0aXZlXCIpLmVuZCgpLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITApLGUmJmUoKX12YXIgZz1kLmZpbmQoXCI+IC5hY3RpdmVcIiksaD1lJiZhLnN1cHBvcnQudHJhbnNpdGlvbiYmKGcubGVuZ3RoJiZnLmhhc0NsYXNzKFwiZmFkZVwiKXx8ISFkLmZpbmQoXCI+IC5mYWRlXCIpLmxlbmd0aCk7Zy5sZW5ndGgmJmg/Zy5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixmKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLlRSQU5TSVRJT05fRFVSQVRJT04pOmYoKSxnLnJlbW92ZUNsYXNzKFwiaW5cIil9O3ZhciBkPWEuZm4udGFiO2EuZm4udGFiPWIsYS5mbi50YWIuQ29uc3RydWN0b3I9YyxhLmZuLnRhYi5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4udGFiPWQsdGhpc307dmFyIGU9ZnVuY3Rpb24oYyl7Yy5wcmV2ZW50RGVmYXVsdCgpLGIuY2FsbChhKHRoaXMpLFwic2hvd1wiKX07YShkb2N1bWVudCkub24oXCJjbGljay5icy50YWIuZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJyxlKS5vbihcImNsaWNrLmJzLnRhYi5kYXRhLWFwaVwiLCdbZGF0YS10b2dnbGU9XCJwaWxsXCJdJyxlKX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLmFmZml4XCIpLGY9XCJvYmplY3RcIj09dHlwZW9mIGImJmI7ZXx8ZC5kYXRhKFwiYnMuYWZmaXhcIixlPW5ldyBjKHRoaXMsZikpLFwic3RyaW5nXCI9PXR5cGVvZiBiJiZlW2JdKCl9KX12YXIgYz1mdW5jdGlvbihiLGQpe3RoaXMub3B0aW9ucz1hLmV4dGVuZCh7fSxjLkRFRkFVTFRTLGQpLHRoaXMuJHRhcmdldD1hKHRoaXMub3B0aW9ucy50YXJnZXQpLm9uKFwic2Nyb2xsLmJzLmFmZml4LmRhdGEtYXBpXCIsYS5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb24sdGhpcykpLm9uKFwiY2xpY2suYnMuYWZmaXguZGF0YS1hcGlcIixhLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbldpdGhFdmVudExvb3AsdGhpcykpLHRoaXMuJGVsZW1lbnQ9YShiKSx0aGlzLmFmZml4ZWQ9bnVsbCx0aGlzLnVucGluPW51bGwsdGhpcy5waW5uZWRPZmZzZXQ9bnVsbCx0aGlzLmNoZWNrUG9zaXRpb24oKX07Yy5WRVJTSU9OPVwiMy4zLjVcIixjLlJFU0VUPVwiYWZmaXggYWZmaXgtdG9wIGFmZml4LWJvdHRvbVwiLGMuREVGQVVMVFM9e29mZnNldDowLHRhcmdldDp3aW5kb3d9LGMucHJvdG90eXBlLmdldFN0YXRlPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuJHRhcmdldC5zY3JvbGxUb3AoKSxmPXRoaXMuJGVsZW1lbnQub2Zmc2V0KCksZz10aGlzLiR0YXJnZXQuaGVpZ2h0KCk7aWYobnVsbCE9YyYmXCJ0b3BcIj09dGhpcy5hZmZpeGVkKXJldHVybiBjPmU/XCJ0b3BcIjohMTtpZihcImJvdHRvbVwiPT10aGlzLmFmZml4ZWQpcmV0dXJuIG51bGwhPWM/ZSt0aGlzLnVucGluPD1mLnRvcD8hMTpcImJvdHRvbVwiOmEtZD49ZStnPyExOlwiYm90dG9tXCI7dmFyIGg9bnVsbD09dGhpcy5hZmZpeGVkLGk9aD9lOmYudG9wLGo9aD9nOmI7cmV0dXJuIG51bGwhPWMmJmM+PWU/XCJ0b3BcIjpudWxsIT1kJiZpK2o+PWEtZD9cImJvdHRvbVwiOiExfSxjLnByb3RvdHlwZS5nZXRQaW5uZWRPZmZzZXQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBpbm5lZE9mZnNldClyZXR1cm4gdGhpcy5waW5uZWRPZmZzZXQ7dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhjLlJFU0VUKS5hZGRDbGFzcyhcImFmZml4XCIpO3ZhciBhPXRoaXMuJHRhcmdldC5zY3JvbGxUb3AoKSxiPXRoaXMuJGVsZW1lbnQub2Zmc2V0KCk7cmV0dXJuIHRoaXMucGlubmVkT2Zmc2V0PWIudG9wLWF9LGMucHJvdG90eXBlLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wPWZ1bmN0aW9uKCl7c2V0VGltZW91dChhLnByb3h5KHRoaXMuY2hlY2tQb3NpdGlvbix0aGlzKSwxKX0sYy5wcm90b3R5cGUuY2hlY2tQb3NpdGlvbj1mdW5jdGlvbigpe2lmKHRoaXMuJGVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKSl7dmFyIGI9dGhpcy4kZWxlbWVudC5oZWlnaHQoKSxkPXRoaXMub3B0aW9ucy5vZmZzZXQsZT1kLnRvcCxmPWQuYm90dG9tLGc9TWF0aC5tYXgoYShkb2N1bWVudCkuaGVpZ2h0KCksYShkb2N1bWVudC5ib2R5KS5oZWlnaHQoKSk7XCJvYmplY3RcIiE9dHlwZW9mIGQmJihmPWU9ZCksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmKGU9ZC50b3AodGhpcy4kZWxlbWVudCkpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGYmJihmPWQuYm90dG9tKHRoaXMuJGVsZW1lbnQpKTt2YXIgaD10aGlzLmdldFN0YXRlKGcsYixlLGYpO2lmKHRoaXMuYWZmaXhlZCE9aCl7bnVsbCE9dGhpcy51bnBpbiYmdGhpcy4kZWxlbWVudC5jc3MoXCJ0b3BcIixcIlwiKTt2YXIgaT1cImFmZml4XCIrKGg/XCItXCIraDpcIlwiKSxqPWEuRXZlbnQoaStcIi5icy5hZmZpeFwiKTtpZih0aGlzLiRlbGVtZW50LnRyaWdnZXIoaiksai5pc0RlZmF1bHRQcmV2ZW50ZWQoKSlyZXR1cm47dGhpcy5hZmZpeGVkPWgsdGhpcy51bnBpbj1cImJvdHRvbVwiPT1oP3RoaXMuZ2V0UGlubmVkT2Zmc2V0KCk6bnVsbCx0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKGMuUkVTRVQpLmFkZENsYXNzKGkpLnRyaWdnZXIoaS5yZXBsYWNlKFwiYWZmaXhcIixcImFmZml4ZWRcIikrXCIuYnMuYWZmaXhcIil9XCJib3R0b21cIj09aCYmdGhpcy4kZWxlbWVudC5vZmZzZXQoe3RvcDpnLWItZn0pfX07dmFyIGQ9YS5mbi5hZmZpeDthLmZuLmFmZml4PWIsYS5mbi5hZmZpeC5Db25zdHJ1Y3Rvcj1jLGEuZm4uYWZmaXgubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLmFmZml4PWQsdGhpc30sYSh3aW5kb3cpLm9uKFwibG9hZFwiLGZ1bmN0aW9uKCl7YSgnW2RhdGEtc3B5PVwiYWZmaXhcIl0nKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGM9YSh0aGlzKSxkPWMuZGF0YSgpO2Qub2Zmc2V0PWQub2Zmc2V0fHx7fSxudWxsIT1kLm9mZnNldEJvdHRvbSYmKGQub2Zmc2V0LmJvdHRvbT1kLm9mZnNldEJvdHRvbSksbnVsbCE9ZC5vZmZzZXRUb3AmJihkLm9mZnNldC50b3A9ZC5vZmZzZXRUb3ApLGIuY2FsbChjLGQpfSl9KX0oalF1ZXJ5KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWRpdGFibGUvanMvYm9vdHN0cmFwLm1pbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n')},function(module,exports){eval('var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {\n  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);\n};\n\nvar wysihtml5 = {\n  version: "0.3.0",\n\n  // namespaces\n  commands: {},\n  dom: {},\n  quirks: {},\n  toolbar: {},\n  lang: {},\n  selection: {},\n  views: {},\n\n  INVISIBLE_SPACE: "\\uFEFF",\n\n  EMPTY_FUNCTION: function EMPTY_FUNCTION() {},\n\n  ELEMENT_NODE: 1,\n  TEXT_NODE: 3,\n\n  BACKSPACE_KEY: 8,\n  ENTER_KEY: 13,\n  ESCAPE_KEY: 27,\n  SPACE_KEY: 32,\n  DELETE_KEY: 46\n}; /**\n   * @license Rangy, a cross-browser JavaScript range and selection library\n   * http://code.google.com/p/rangy/\n   *\n   * Copyright 2011, Tim Down\n   * Licensed under the MIT license.\n   * Version: 1.2.2\n   * Build date: 13 November 2011\n   */\nwindow[\'rangy\'] = function () {\n\n  var OBJECT = "object",\n      FUNCTION = "function",\n      UNDEFINED = "undefined";\n\n  var domRangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed", "commonAncestorContainer", "START_TO_START", "START_TO_END", "END_TO_START", "END_TO_END"];\n\n  var domRangeMethods = ["setStart", "setStartBefore", "setStartAfter", "setEnd", "setEndBefore", "setEndAfter", "collapse", "selectNode", "selectNodeContents", "compareBoundaryPoints", "deleteContents", "extractContents", "cloneContents", "insertNode", "surroundContents", "cloneRange", "toString", "detach"];\n\n  var textRangeProperties = ["boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "htmlText", "text"];\n\n  // Subset of TextRange\'s full set of methods that we\'re interested in\n  var textRangeMethods = ["collapse", "compareEndPoints", "duplicate", "getBookmark", "moveToBookmark", "moveToElementText", "parentElement", "pasteHTML", "select", "setEndPoint", "getBoundingClientRect"];\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Trio of functions taken from Peter Michaux\'s article:\n  // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting\n  function isHostMethod(o, p) {\n    var t = _typeof(o[p]);\n    return t == FUNCTION || !!(t == OBJECT && o[p]) || t == "unknown";\n  }\n\n  function isHostObject(o, p) {\n    return !!(_typeof(o[p]) == OBJECT && o[p]);\n  }\n\n  function isHostProperty(o, p) {\n    return _typeof(o[p]) != UNDEFINED;\n  }\n\n  // Creates a convenience function to save verbose repeated calls to tests functions\n  function createMultiplePropertyTest(testFunc) {\n    return function (o, props) {\n      var i = props.length;\n      while (i--) {\n        if (!testFunc(o, props[i])) {\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n\n  // Next trio of functions are a convenience to save verbose repeated calls to previous two functions\n  var areHostMethods = createMultiplePropertyTest(isHostMethod);\n  var areHostObjects = createMultiplePropertyTest(isHostObject);\n  var areHostProperties = createMultiplePropertyTest(isHostProperty);\n\n  function isTextRange(range) {\n    return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);\n  }\n\n  var api = {\n    version: "1.2.2",\n    initialized: false,\n    supported: true,\n\n    util: {\n      isHostMethod: isHostMethod,\n      isHostObject: isHostObject,\n      isHostProperty: isHostProperty,\n      areHostMethods: areHostMethods,\n      areHostObjects: areHostObjects,\n      areHostProperties: areHostProperties,\n      isTextRange: isTextRange\n    },\n\n    features: {},\n\n    modules: {},\n    config: {\n      alertOnWarn: false,\n      preferTextRange: false\n    }\n  };\n\n  function fail(reason) {\n    window.alert("Rangy not supported in your browser. Reason: " + reason);\n    api.initialized = true;\n    api.supported = false;\n  }\n\n  api.fail = fail;\n\n  function warn(msg) {\n    var warningMessage = "Rangy warning: " + msg;\n    if (api.config.alertOnWarn) {\n      window.alert(warningMessage);\n    } else if (_typeof(window.console) != UNDEFINED && _typeof(window.console.log) != UNDEFINED) {\n      window.console.log(warningMessage);\n    }\n  }\n\n  api.warn = warn;\n\n  if ({}.hasOwnProperty) {\n    api.util.extend = function (o, props) {\n      for (var i in props) {\n        if (props.hasOwnProperty(i)) {\n          o[i] = props[i];\n        }\n      }\n    };\n  } else {\n    fail("hasOwnProperty not supported");\n  }\n\n  var initListeners = [];\n  var moduleInitializers = [];\n\n  // Initialization\n  function init() {\n    if (api.initialized) {\n      return;\n    }\n    var testRange;\n    var implementsDomRange = false,\n        implementsTextRange = false;\n\n    // First, perform basic feature tests\n\n    if (isHostMethod(document, "createRange")) {\n      testRange = document.createRange();\n      if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {\n        implementsDomRange = true;\n      }\n      testRange.detach();\n    }\n\n    var body = isHostObject(document, "body") ? document.body : document.getElementsByTagName("body")[0];\n\n    if (body && isHostMethod(body, "createTextRange")) {\n      testRange = body.createTextRange();\n      if (isTextRange(testRange)) {\n        implementsTextRange = true;\n      }\n    }\n\n    if (!implementsDomRange && !implementsTextRange) {\n      fail("Neither Range nor TextRange are implemented");\n    }\n\n    api.initialized = true;\n    api.features = {\n      implementsDomRange: implementsDomRange,\n      implementsTextRange: implementsTextRange\n    };\n\n    // Initialize modules and call init listeners\n    var allListeners = moduleInitializers.concat(initListeners);\n    for (var i = 0, len = allListeners.length; i < len; ++i) {\n      try {\n        allListeners[i](api);\n      } catch (ex) {\n        if (isHostObject(window, "console") && isHostMethod(window.console, "log")) {\n          window.console.log("Init listener threw an exception. Continuing.", ex);\n        }\n      }\n    }\n  }\n\n  // Allow external scripts to initialize this library in case it\'s loaded after the document has loaded\n  api.init = init;\n\n  // Execute listener immediately if already initialized\n  api.addInitListener = function (listener) {\n    if (api.initialized) {\n      listener(api);\n    } else {\n      initListeners.push(listener);\n    }\n  };\n\n  var createMissingNativeApiListeners = [];\n\n  api.addCreateMissingNativeApiListener = function (listener) {\n    createMissingNativeApiListeners.push(listener);\n  };\n\n  function createMissingNativeApi(win) {\n    win = win || window;\n    init();\n\n    // Notify listeners\n    for (var i = 0, len = createMissingNativeApiListeners.length; i < len; ++i) {\n      createMissingNativeApiListeners[i](win);\n    }\n  }\n\n  api.createMissingNativeApi = createMissingNativeApi;\n\n  /**\n   * @constructor\n   */\n  function Module(name) {\n    this.name = name;\n    this.initialized = false;\n    this.supported = false;\n  }\n\n  Module.prototype.fail = function (reason) {\n    this.initialized = true;\n    this.supported = false;\n\n    throw new Error("Module \'" + this.name + "\' failed to load: " + reason);\n  };\n\n  Module.prototype.warn = function (msg) {\n    api.warn("Module " + this.name + ": " + msg);\n  };\n\n  Module.prototype.createError = function (msg) {\n    return new Error("Error in Rangy " + this.name + " module: " + msg);\n  };\n\n  api.createModule = function (name, initFunc) {\n    var module = new Module(name);\n    api.modules[name] = module;\n\n    moduleInitializers.push(function (api) {\n      initFunc(api, module);\n      module.initialized = true;\n      module.supported = true;\n    });\n  };\n\n  api.requireModules = function (modules) {\n    for (var i = 0, len = modules.length, module, moduleName; i < len; ++i) {\n      moduleName = modules[i];\n      module = api.modules[moduleName];\n      if (!module || !(module instanceof Module)) {\n        throw new Error("Module \'" + moduleName + "\' not found");\n      }\n      if (!module.supported) {\n        throw new Error("Module \'" + moduleName + "\' not supported");\n      }\n    }\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Wait for document to load before running tests\n\n  var docReady = false;\n\n  var loadHandler = function loadHandler(e) {\n\n    if (!docReady) {\n      docReady = true;\n      if (!api.initialized) {\n        init();\n      }\n    }\n  };\n\n  // Test whether we have window and document objects that we will need\n  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) == UNDEFINED) {\n    fail("No window found");\n    return;\n  }\n  if ((typeof document === "undefined" ? "undefined" : _typeof(document)) == UNDEFINED) {\n    fail("No document found");\n    return;\n  }\n\n  if (isHostMethod(document, "addEventListener")) {\n    document.addEventListener("DOMContentLoaded", loadHandler, false);\n  }\n\n  // Add a fallback in case the DOMContentLoaded event isn\'t supported\n  if (isHostMethod(window, "addEventListener")) {\n    window.addEventListener("load", loadHandler, false);\n  } else if (isHostMethod(window, "attachEvent")) {\n    window.attachEvent("onload", loadHandler);\n  } else {\n    fail("Window does not have required addEventListener or attachEvent method");\n  }\n\n  return api;\n}();\nrangy.createModule("DomUtil", function (api, module) {\n\n  var UNDEF = "undefined";\n  var util = api.util;\n\n  // Perform feature tests\n  if (!util.areHostMethods(document, ["createDocumentFragment", "createElement", "createTextNode"])) {\n    module.fail("document missing a Node creation method");\n  }\n\n  if (!util.isHostMethod(document, "getElementsByTagName")) {\n    module.fail("document missing getElementsByTagName method");\n  }\n\n  var el = document.createElement("div");\n  if (!util.areHostMethods(el, ["insertBefore", "appendChild", "cloneNode"] || !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]))) {\n    module.fail("Incomplete Element implementation");\n  }\n\n  // innerHTML is required for Range\'s createContextualFragment method\n  if (!util.isHostProperty(el, "innerHTML")) {\n    module.fail("Element is missing innerHTML property");\n  }\n\n  var textNode = document.createTextNode("test");\n  if (!util.areHostMethods(textNode, ["splitText", "deleteData", "insertData", "appendData", "cloneNode"] || !util.areHostObjects(el, ["previousSibling", "nextSibling", "childNodes", "parentNode"]) || !util.areHostProperties(textNode, ["data"]))) {\n    module.fail("Incomplete Text Node implementation");\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven\'t been\n  // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that\n  // contains just the document as a single element and the value searched for is the document.\n  var arrayContains = /*Array.prototype.indexOf ?\n                      function(arr, val) {\n                      return arr.indexOf(val) > -1;\n                      }:*/\n\n  function arrayContains(arr, val) {\n    var i = arr.length;\n    while (i--) {\n      if (arr[i] === val) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI\n  function isHtmlNamespace(node) {\n    var ns;\n    return _typeof(node.namespaceURI) == UNDEF || (ns = node.namespaceURI) === null || ns == "http://www.w3.org/1999/xhtml";\n  }\n\n  function parentElement(node) {\n    var parent = node.parentNode;\n    return parent.nodeType == 1 ? parent : null;\n  }\n\n  function getNodeIndex(node) {\n    var i = 0;\n    while (node = node.previousSibling) {\n      i++;\n    }\n    return i;\n  }\n\n  function getNodeLength(node) {\n    var childNodes;\n    return isCharacterDataNode(node) ? node.length : (childNodes = node.childNodes) ? childNodes.length : 0;\n  }\n\n  function getCommonAncestor(node1, node2) {\n    var ancestors = [],\n        n;\n    for (n = node1; n; n = n.parentNode) {\n      ancestors.push(n);\n    }\n\n    for (n = node2; n; n = n.parentNode) {\n      if (arrayContains(ancestors, n)) {\n        return n;\n      }\n    }\n\n    return null;\n  }\n\n  function isAncestorOf(ancestor, descendant, selfIsAncestor) {\n    var n = selfIsAncestor ? descendant : descendant.parentNode;\n    while (n) {\n      if (n === ancestor) {\n        return true;\n      } else {\n        n = n.parentNode;\n      }\n    }\n    return false;\n  }\n\n  function getClosestAncestorIn(node, ancestor, selfIsAncestor) {\n    var p,\n        n = selfIsAncestor ? node : node.parentNode;\n    while (n) {\n      p = n.parentNode;\n      if (p === ancestor) {\n        return n;\n      }\n      n = p;\n    }\n    return null;\n  }\n\n  function isCharacterDataNode(node) {\n    var t = node.nodeType;\n    return t == 3 || t == 4 || t == 8; // Text, CDataSection or Comment\n  }\n\n  function insertAfter(node, precedingNode) {\n    var nextNode = precedingNode.nextSibling,\n        parent = precedingNode.parentNode;\n    if (nextNode) {\n      parent.insertBefore(node, nextNode);\n    } else {\n      parent.appendChild(node);\n    }\n    return node;\n  }\n\n  // Note that we cannot use splitText() because it is bugridden in IE 9.\n  function splitDataNode(node, index) {\n    var newNode = node.cloneNode(false);\n    newNode.deleteData(0, index);\n    node.deleteData(index, node.length - index);\n    insertAfter(newNode, node);\n    return newNode;\n  }\n\n  function getDocument(node) {\n    if (node.nodeType == 9) {\n      return node;\n    } else if (_typeof(node.ownerDocument) != UNDEF) {\n      return node.ownerDocument;\n    } else if (_typeof(node.document) != UNDEF) {\n      return node.document;\n    } else if (node.parentNode) {\n      return getDocument(node.parentNode);\n    } else {\n      throw new Error("getDocument: no document found for node");\n    }\n  }\n\n  function getWindow(node) {\n    var doc = getDocument(node);\n    if (_typeof(doc.defaultView) != UNDEF) {\n      return doc.defaultView;\n    } else if (_typeof(doc.parentWindow) != UNDEF) {\n      return doc.parentWindow;\n    } else {\n      throw new Error("Cannot get a window object for node");\n    }\n  }\n\n  function getIframeDocument(iframeEl) {\n    if (_typeof(iframeEl.contentDocument) != UNDEF) {\n      return iframeEl.contentDocument;\n    } else if (_typeof(iframeEl.contentWindow) != UNDEF) {\n      return iframeEl.contentWindow.document;\n    } else {\n      throw new Error("getIframeWindow: No Document object found for iframe element");\n    }\n  }\n\n  function getIframeWindow(iframeEl) {\n    if (_typeof(iframeEl.contentWindow) != UNDEF) {\n      return iframeEl.contentWindow;\n    } else if (_typeof(iframeEl.contentDocument) != UNDEF) {\n      return iframeEl.contentDocument.defaultView;\n    } else {\n      throw new Error("getIframeWindow: No Window object found for iframe element");\n    }\n  }\n\n  function getBody(doc) {\n    return util.isHostObject(doc, "body") ? doc.body : doc.getElementsByTagName("body")[0];\n  }\n\n  function getRootContainer(node) {\n    var parent;\n    while (parent = node.parentNode) {\n      node = parent;\n    }\n    return node;\n  }\n\n  function comparePoints(nodeA, offsetA, nodeB, offsetB) {\n    // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing\n    var nodeC, root, childA, childB, n;\n    if (nodeA == nodeB) {\n\n      // Case 1: nodes are the same\n      return offsetA === offsetB ? 0 : offsetA < offsetB ? -1 : 1;\n    } else if (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) {\n\n      // Case 2: node C (container B or an ancestor) is a child node of A\n      return offsetA <= getNodeIndex(nodeC) ? -1 : 1;\n    } else if (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) {\n\n      // Case 3: node C (container A or an ancestor) is a child node of B\n      return getNodeIndex(nodeC) < offsetB ? -1 : 1;\n    } else {\n\n      // Case 4: containers are siblings or descendants of siblings\n      root = getCommonAncestor(nodeA, nodeB);\n      childA = nodeA === root ? root : getClosestAncestorIn(nodeA, root, true);\n      childB = nodeB === root ? root : getClosestAncestorIn(nodeB, root, true);\n\n      if (childA === childB) {\n        // This shouldn\'t be possible\n\n        throw new Error("comparePoints got to case 4 and childA and childB are the same!");\n      } else {\n        n = root.firstChild;\n        while (n) {\n          if (n === childA) {\n            return -1;\n          } else if (n === childB) {\n            return 1;\n          }\n          n = n.nextSibling;\n        }\n        throw new Error("Should not be here!");\n      }\n    }\n  }\n\n  function fragmentFromNodeChildren(node) {\n    var fragment = getDocument(node).createDocumentFragment(),\n        child;\n    while (child = node.firstChild) {\n      fragment.appendChild(child);\n    }\n    return fragment;\n  }\n\n  function inspectNode(node) {\n    if (!node) {\n      return "[No node]";\n    }\n    if (isCharacterDataNode(node)) {\n      return \'"\' + node.data + \'"\';\n    } else if (node.nodeType == 1) {\n      var idAttr = node.id ? \' id="\' + node.id + \'"\' : "";\n      return "<" + node.nodeName + idAttr + ">[" + node.childNodes.length + "]";\n    } else {\n      return node.nodeName;\n    }\n  }\n\n  /**\n   * @constructor\n   */\n  function NodeIterator(root) {\n    this.root = root;\n    this._next = root;\n  }\n\n  NodeIterator.prototype = {\n    _current: null,\n\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n\n    next: function next() {\n      var n = this._current = this._next;\n      var child, next;\n      if (this._current) {\n        child = n.firstChild;\n        if (child) {\n          this._next = child;\n        } else {\n          next = null;\n          while (n !== this.root && !(next = n.nextSibling)) {\n            n = n.parentNode;\n          }\n          this._next = next;\n        }\n      }\n      return this._current;\n    },\n\n    detach: function detach() {\n      this._current = this._next = this.root = null;\n    }\n  };\n\n  function createIterator(root) {\n    return new NodeIterator(root);\n  }\n\n  /**\n   * @constructor\n   */\n  function DomPosition(node, offset) {\n    this.node = node;\n    this.offset = offset;\n  }\n\n  DomPosition.prototype = {\n    equals: function equals(pos) {\n      return this.node === pos.node & this.offset == pos.offset;\n    },\n\n    inspect: function inspect() {\n      return "[DomPosition(" + inspectNode(this.node) + ":" + this.offset + ")]";\n    }\n  };\n\n  /**\n   * @constructor\n   */\n  function DOMException(codeName) {\n    this.code = this[codeName];\n    this.codeName = codeName;\n    this.message = "DOMException: " + this.codeName;\n  }\n\n  DOMException.prototype = {\n    INDEX_SIZE_ERR: 1,\n    HIERARCHY_REQUEST_ERR: 3,\n    WRONG_DOCUMENT_ERR: 4,\n    NO_MODIFICATION_ALLOWED_ERR: 7,\n    NOT_FOUND_ERR: 8,\n    NOT_SUPPORTED_ERR: 9,\n    INVALID_STATE_ERR: 11\n  };\n\n  DOMException.prototype.toString = function () {\n    return this.message;\n  };\n\n  api.dom = {\n    arrayContains: arrayContains,\n    isHtmlNamespace: isHtmlNamespace,\n    parentElement: parentElement,\n    getNodeIndex: getNodeIndex,\n    getNodeLength: getNodeLength,\n    getCommonAncestor: getCommonAncestor,\n    isAncestorOf: isAncestorOf,\n    getClosestAncestorIn: getClosestAncestorIn,\n    isCharacterDataNode: isCharacterDataNode,\n    insertAfter: insertAfter,\n    splitDataNode: splitDataNode,\n    getDocument: getDocument,\n    getWindow: getWindow,\n    getIframeWindow: getIframeWindow,\n    getIframeDocument: getIframeDocument,\n    getBody: getBody,\n    getRootContainer: getRootContainer,\n    comparePoints: comparePoints,\n    inspectNode: inspectNode,\n    fragmentFromNodeChildren: fragmentFromNodeChildren,\n    createIterator: createIterator,\n    DomPosition: DomPosition\n  };\n\n  api.DOMException = DOMException;\n});rangy.createModule("DomRange", function (api, module) {\n  api.requireModules(["DomUtil"]);\n\n  var dom = api.dom;\n  var DomPosition = dom.DomPosition;\n  var DOMException = api.DOMException;\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Utility functions\n\n  function isNonTextPartiallySelected(node, range) {\n    return node.nodeType != 3 && (dom.isAncestorOf(node, range.startContainer, true) || dom.isAncestorOf(node, range.endContainer, true));\n  }\n\n  function getRangeDocument(range) {\n    return dom.getDocument(range.startContainer);\n  }\n\n  function dispatchEvent(range, type, args) {\n    var listeners = range._listeners[type];\n    if (listeners) {\n      for (var i = 0, len = listeners.length; i < len; ++i) {\n        listeners[i].call(range, { target: range, args: args });\n      }\n    }\n  }\n\n  function getBoundaryBeforeNode(node) {\n    return new DomPosition(node.parentNode, dom.getNodeIndex(node));\n  }\n\n  function getBoundaryAfterNode(node) {\n    return new DomPosition(node.parentNode, dom.getNodeIndex(node) + 1);\n  }\n\n  function insertNodeAtPosition(node, n, o) {\n    var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;\n    if (dom.isCharacterDataNode(n)) {\n      if (o == n.length) {\n        dom.insertAfter(node, n);\n      } else {\n        n.parentNode.insertBefore(node, o == 0 ? n : dom.splitDataNode(n, o));\n      }\n    } else if (o >= n.childNodes.length) {\n      n.appendChild(node);\n    } else {\n      n.insertBefore(node, n.childNodes[o]);\n    }\n    return firstNodeInserted;\n  }\n\n  function cloneSubtree(iterator) {\n    var partiallySelected;\n    for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {\n      partiallySelected = iterator.isPartiallySelectedSubtree();\n\n      node = node.cloneNode(!partiallySelected);\n      if (partiallySelected) {\n        subIterator = iterator.getSubtreeIterator();\n        node.appendChild(cloneSubtree(subIterator));\n        subIterator.detach(true);\n      }\n\n      if (node.nodeType == 10) {\n        // DocumentType\n        throw new DOMException("HIERARCHY_REQUEST_ERR");\n      }\n      frag.appendChild(node);\n    }\n    return frag;\n  }\n\n  function iterateSubtree(rangeIterator, func, iteratorState) {\n    var it, n;\n    iteratorState = iteratorState || { stop: false };\n    for (var node, subRangeIterator; node = rangeIterator.next();) {\n      //log.debug("iterateSubtree, partially selected: " + rangeIterator.isPartiallySelectedSubtree(), nodeToString(node));\n      if (rangeIterator.isPartiallySelectedSubtree()) {\n        // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of the\n        // node selected by the Range.\n        if (func(node) === false) {\n          iteratorState.stop = true;\n          return;\n        } else {\n          subRangeIterator = rangeIterator.getSubtreeIterator();\n          iterateSubtree(subRangeIterator, func, iteratorState);\n          subRangeIterator.detach(true);\n          if (iteratorState.stop) {\n            return;\n          }\n        }\n      } else {\n        // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its\n        // descendant\n        it = dom.createIterator(node);\n        while (n = it.next()) {\n          if (func(n) === false) {\n            iteratorState.stop = true;\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  function deleteSubtree(iterator) {\n    var subIterator;\n    while (iterator.next()) {\n      if (iterator.isPartiallySelectedSubtree()) {\n        subIterator = iterator.getSubtreeIterator();\n        deleteSubtree(subIterator);\n        subIterator.detach(true);\n      } else {\n        iterator.remove();\n      }\n    }\n  }\n\n  function extractSubtree(iterator) {\n\n    for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {\n\n      if (iterator.isPartiallySelectedSubtree()) {\n        node = node.cloneNode(false);\n        subIterator = iterator.getSubtreeIterator();\n        node.appendChild(extractSubtree(subIterator));\n        subIterator.detach(true);\n      } else {\n        iterator.remove();\n      }\n      if (node.nodeType == 10) {\n        // DocumentType\n        throw new DOMException("HIERARCHY_REQUEST_ERR");\n      }\n      frag.appendChild(node);\n    }\n    return frag;\n  }\n\n  function getNodesInRange(range, nodeTypes, filter) {\n    //log.info("getNodesInRange, " + nodeTypes.join(","));\n    var filterNodeTypes = !!(nodeTypes && nodeTypes.length),\n        regex;\n    var filterExists = !!filter;\n    if (filterNodeTypes) {\n      regex = new RegExp("^(" + nodeTypes.join("|") + ")$");\n    }\n\n    var nodes = [];\n    iterateSubtree(new RangeIterator(range, false), function (node) {\n      if ((!filterNodeTypes || regex.test(node.nodeType)) && (!filterExists || filter(node))) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  }\n\n  function _inspect(range) {\n    var name = typeof range.getName == "undefined" ? "Range" : range.getName();\n    return "[" + name + "(" + dom.inspectNode(range.startContainer) + ":" + range.startOffset + ", " + dom.inspectNode(range.endContainer) + ":" + range.endOffset + ")]";\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)\n\n  /**\n   * @constructor\n   */\n  function RangeIterator(range, clonePartiallySelectedTextNodes) {\n    this.range = range;\n    this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n    if (!range.collapsed) {\n      this.sc = range.startContainer;\n      this.so = range.startOffset;\n      this.ec = range.endContainer;\n      this.eo = range.endOffset;\n      var root = range.commonAncestorContainer;\n\n      if (this.sc === this.ec && dom.isCharacterDataNode(this.sc)) {\n        this.isSingleCharacterDataNode = true;\n        this._first = this._last = this._next = this.sc;\n      } else {\n        this._first = this._next = this.sc === root && !dom.isCharacterDataNode(this.sc) ? this.sc.childNodes[this.so] : dom.getClosestAncestorIn(this.sc, root, true);\n        this._last = this.ec === root && !dom.isCharacterDataNode(this.ec) ? this.ec.childNodes[this.eo - 1] : dom.getClosestAncestorIn(this.ec, root, true);\n      }\n    }\n  }\n\n  RangeIterator.prototype = {\n    _current: null,\n    _next: null,\n    _first: null,\n    _last: null,\n    isSingleCharacterDataNode: false,\n\n    reset: function reset() {\n      this._current = null;\n      this._next = this._first;\n    },\n\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n\n    next: function next() {\n      // Move to next node\n      var current = this._current = this._next;\n      if (current) {\n        this._next = current !== this._last ? current.nextSibling : null;\n\n        // Check for partially selected text nodes\n        if (dom.isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n          if (current === this.ec) {\n\n            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n          }\n          if (this._current === this.sc) {\n\n            (current = current.cloneNode(true)).deleteData(0, this.so);\n          }\n        }\n      }\n\n      return current;\n    },\n\n    remove: function remove() {\n      var current = this._current,\n          start,\n          end;\n\n      if (dom.isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {\n        start = current === this.sc ? this.so : 0;\n        end = current === this.ec ? this.eo : current.length;\n        if (start != end) {\n          current.deleteData(start, end - start);\n        }\n      } else {\n        if (current.parentNode) {\n          current.parentNode.removeChild(current);\n        } else {}\n      }\n    },\n\n    // Checks if the current node is partially selected\n    isPartiallySelectedSubtree: function isPartiallySelectedSubtree() {\n      var current = this._current;\n      return isNonTextPartiallySelected(current, this.range);\n    },\n\n    getSubtreeIterator: function getSubtreeIterator() {\n      var subRange;\n      if (this.isSingleCharacterDataNode) {\n        subRange = this.range.cloneRange();\n        subRange.collapse();\n      } else {\n        subRange = new Range(getRangeDocument(this.range));\n        var current = this._current;\n        var startContainer = current,\n            startOffset = 0,\n            endContainer = current,\n            endOffset = dom.getNodeLength(current);\n\n        if (dom.isAncestorOf(current, this.sc, true)) {\n          startContainer = this.sc;\n          startOffset = this.so;\n        }\n        if (dom.isAncestorOf(current, this.ec, true)) {\n          endContainer = this.ec;\n          endOffset = this.eo;\n        }\n\n        updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);\n      }\n      return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);\n    },\n\n    detach: function detach(detachRange) {\n      if (detachRange) {\n        this.range.detach();\n      }\n      this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;\n    }\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Exceptions\n\n  /**\n   * @constructor\n   */\n  function RangeException(codeName) {\n    this.code = this[codeName];\n    this.codeName = codeName;\n    this.message = "RangeException: " + this.codeName;\n  }\n\n  RangeException.prototype = {\n    BAD_BOUNDARYPOINTS_ERR: 1,\n    INVALID_NODE_TYPE_ERR: 2\n  };\n\n  RangeException.prototype.toString = function () {\n    return this.message;\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  /**\n   * Currently iterates through all nodes in the range on creation until I think of a decent way to do it\n   * TODO: Look into making this a proper iterator, not requiring preloading everything first\n   * @constructor\n   */\n  function RangeNodeIterator(range, nodeTypes, filter) {\n    this.nodes = getNodesInRange(range, nodeTypes, filter);\n    this._next = this.nodes[0];\n    this._position = 0;\n  }\n\n  RangeNodeIterator.prototype = {\n    _current: null,\n\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n\n    next: function next() {\n      this._current = this._next;\n      this._next = this.nodes[++this._position];\n      return this._current;\n    },\n\n    detach: function detach() {\n      this._current = this._next = this.nodes = null;\n    }\n  };\n\n  var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];\n  var rootContainerNodeTypes = [2, 9, 11];\n  var readonlyNodeTypes = [5, 6, 10, 12];\n  var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];\n  var surroundNodeTypes = [1, 3, 4, 5, 7, 8];\n\n  function createAncestorFinder(nodeTypes) {\n    return function (node, selfIsAncestor) {\n      var t,\n          n = selfIsAncestor ? node : node.parentNode;\n      while (n) {\n        t = n.nodeType;\n        if (dom.arrayContains(nodeTypes, t)) {\n          return n;\n        }\n        n = n.parentNode;\n      }\n      return null;\n    };\n  }\n\n  var getRootContainer = dom.getRootContainer;\n  var getDocumentOrFragmentContainer = createAncestorFinder([9, 11]);\n  var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);\n  var getDocTypeNotationEntityAncestor = createAncestorFinder([6, 10, 12]);\n\n  function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {\n    if (getDocTypeNotationEntityAncestor(node, allowSelf)) {\n      throw new RangeException("INVALID_NODE_TYPE_ERR");\n    }\n  }\n\n  function assertNotDetached(range) {\n    if (!range.startContainer) {\n      throw new DOMException("INVALID_STATE_ERR");\n    }\n  }\n\n  function assertValidNodeType(node, invalidTypes) {\n    if (!dom.arrayContains(invalidTypes, node.nodeType)) {\n      throw new RangeException("INVALID_NODE_TYPE_ERR");\n    }\n  }\n\n  function assertValidOffset(node, offset) {\n    if (offset < 0 || offset > (dom.isCharacterDataNode(node) ? node.length : node.childNodes.length)) {\n      throw new DOMException("INDEX_SIZE_ERR");\n    }\n  }\n\n  function assertSameDocumentOrFragment(node1, node2) {\n    if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {\n      throw new DOMException("WRONG_DOCUMENT_ERR");\n    }\n  }\n\n  function assertNodeNotReadOnly(node) {\n    if (getReadonlyAncestor(node, true)) {\n      throw new DOMException("NO_MODIFICATION_ALLOWED_ERR");\n    }\n  }\n\n  function assertNode(node, codeName) {\n    if (!node) {\n      throw new DOMException(codeName);\n    }\n  }\n\n  function isOrphan(node) {\n    return !dom.arrayContains(rootContainerNodeTypes, node.nodeType) && !getDocumentOrFragmentContainer(node, true);\n  }\n\n  function isValidOffset(node, offset) {\n    return offset <= (dom.isCharacterDataNode(node) ? node.length : node.childNodes.length);\n  }\n\n  function assertRangeValid(range) {\n    assertNotDetached(range);\n    if (isOrphan(range.startContainer) || isOrphan(range.endContainer) || !isValidOffset(range.startContainer, range.startOffset) || !isValidOffset(range.endContainer, range.endOffset)) {\n      throw new Error("Range error: Range is no longer valid after DOM mutation (" + range.inspect() + ")");\n    }\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Test the browser\'s innerHTML support to decide how to implement createContextualFragment\n  var styleEl = document.createElement("style");\n  var htmlParsingConforms = false;\n  try {\n    styleEl.innerHTML = "<b>x</b>";\n    htmlParsingConforms = styleEl.firstChild.nodeType == 3; // Opera incorrectly creates an element node\n  } catch (e) {\n    // IE 6 and 7 throw\n  }\n\n  api.features.htmlParsingConforms = htmlParsingConforms;\n\n  var createContextualFragment = htmlParsingConforms ?\n\n  // Implementation as per HTML parsing spec, trusting in the browser\'s implementation of innerHTML. See\n  // discussion and base code for this implementation at issue 67.\n  // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface\n  // Thanks to Aleks Williams.\n  function (fragmentStr) {\n    // "Let node the context object\'s start\'s node."\n    var node = this.startContainer;\n    var doc = dom.getDocument(node);\n\n    // "If the context object\'s start\'s node is null, raise an INVALID_STATE_ERR\n    // exception and abort these steps."\n    if (!node) {\n      throw new DOMException("INVALID_STATE_ERR");\n    }\n\n    // "Let element be as follows, depending on node\'s interface:"\n    // Document, Document Fragment: null\n    var el = null;\n\n    // "Element: node"\n    if (node.nodeType == 1) {\n      el = node;\n\n      // "Text, Comment: node\'s parentElement"\n    } else if (dom.isCharacterDataNode(node)) {\n      el = dom.parentElement(node);\n    }\n\n    // "If either element is null or element\'s ownerDocument is an HTML document\n    // and element\'s local name is "html" and element\'s namespace is the HTML\n    // namespace"\n    if (el === null || el.nodeName == "HTML" && dom.isHtmlNamespace(dom.getDocument(el).documentElement) && dom.isHtmlNamespace(el)) {\n\n      // "let element be a new Element with "body" as its local name and the HTML\n      // namespace as its namespace.""\n      el = doc.createElement("body");\n    } else {\n      el = el.cloneNode(false);\n    }\n\n    // "If the node\'s document is an HTML document: Invoke the HTML fragment parsing algorithm."\n    // "If the node\'s document is an XML document: Invoke the XML fragment parsing algorithm."\n    // "In either case, the algorithm must be invoked with fragment as the input\n    // and element as the context element."\n    el.innerHTML = fragmentStr;\n\n    // "If this raises an exception, then abort these steps. Otherwise, let new\n    // children be the nodes returned."\n\n    // "Let fragment be a new DocumentFragment."\n    // "Append all new children to fragment."\n    // "Return fragment."\n    return dom.fragmentFromNodeChildren(el);\n  } :\n\n  // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that\n  // previous versions of Rangy used (with the exception of using a body element rather than a div)\n  function (fragmentStr) {\n    assertNotDetached(this);\n    var doc = getRangeDocument(this);\n    var el = doc.createElement("body");\n    el.innerHTML = fragmentStr;\n\n    return dom.fragmentFromNodeChildren(el);\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  var rangeProperties = ["startContainer", "startOffset", "endContainer", "endOffset", "collapsed", "commonAncestorContainer"];\n\n  var s2s = 0,\n      s2e = 1,\n      e2e = 2,\n      e2s = 3;\n  var n_b = 0,\n      n_a = 1,\n      n_b_a = 2,\n      n_i = 3;\n\n  function RangePrototype() {}\n\n  RangePrototype.prototype = {\n    attachListener: function attachListener(type, listener) {\n      this._listeners[type].push(listener);\n    },\n\n    compareBoundaryPoints: function compareBoundaryPoints(how, range) {\n      assertRangeValid(this);\n      assertSameDocumentOrFragment(this.startContainer, range.startContainer);\n\n      var nodeA, offsetA, nodeB, offsetB;\n      var prefixA = how == e2s || how == s2s ? "start" : "end";\n      var prefixB = how == s2e || how == s2s ? "start" : "end";\n      nodeA = this[prefixA + "Container"];\n      offsetA = this[prefixA + "Offset"];\n      nodeB = range[prefixB + "Container"];\n      offsetB = range[prefixB + "Offset"];\n      return dom.comparePoints(nodeA, offsetA, nodeB, offsetB);\n    },\n\n    insertNode: function insertNode(node) {\n      assertRangeValid(this);\n      assertValidNodeType(node, insertableNodeTypes);\n      assertNodeNotReadOnly(this.startContainer);\n\n      if (dom.isAncestorOf(node, this.startContainer, true)) {\n        throw new DOMException("HIERARCHY_REQUEST_ERR");\n      }\n\n      // No check for whether the container of the start of the Range is of a type that does not allow\n      // children of the type of node: the browser\'s DOM implementation should do this for us when we attempt\n      // to add the node\n\n      var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);\n      this.setStartBefore(firstNodeInserted);\n    },\n\n    cloneContents: function cloneContents() {\n      assertRangeValid(this);\n\n      var clone, frag;\n      if (this.collapsed) {\n        return getRangeDocument(this).createDocumentFragment();\n      } else {\n        if (this.startContainer === this.endContainer && dom.isCharacterDataNode(this.startContainer)) {\n          clone = this.startContainer.cloneNode(true);\n          clone.data = clone.data.slice(this.startOffset, this.endOffset);\n          frag = getRangeDocument(this).createDocumentFragment();\n          frag.appendChild(clone);\n          return frag;\n        } else {\n          var iterator = new RangeIterator(this, true);\n          clone = cloneSubtree(iterator);\n          iterator.detach();\n        }\n        return clone;\n      }\n    },\n\n    canSurroundContents: function canSurroundContents() {\n      assertRangeValid(this);\n      assertNodeNotReadOnly(this.startContainer);\n      assertNodeNotReadOnly(this.endContainer);\n\n      // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n      // no non-text nodes.\n      var iterator = new RangeIterator(this, true);\n      var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);\n      iterator.detach();\n      return !boundariesInvalid;\n    },\n\n    surroundContents: function surroundContents(node) {\n      assertValidNodeType(node, surroundNodeTypes);\n\n      if (!this.canSurroundContents()) {\n        throw new RangeException("BAD_BOUNDARYPOINTS_ERR");\n      }\n\n      // Extract the contents\n      var content = this.extractContents();\n\n      // Clear the children of the node\n      if (node.hasChildNodes()) {\n        while (node.lastChild) {\n          node.removeChild(node.lastChild);\n        }\n      }\n\n      // Insert the new node and add the extracted contents\n      insertNodeAtPosition(node, this.startContainer, this.startOffset);\n      node.appendChild(content);\n\n      this.selectNode(node);\n    },\n\n    cloneRange: function cloneRange() {\n      assertRangeValid(this);\n      var range = new Range(getRangeDocument(this));\n      var i = rangeProperties.length,\n          prop;\n      while (i--) {\n        prop = rangeProperties[i];\n        range[prop] = this[prop];\n      }\n      return range;\n    },\n\n    toString: function toString() {\n      assertRangeValid(this);\n      var sc = this.startContainer;\n      if (sc === this.endContainer && dom.isCharacterDataNode(sc)) {\n        return sc.nodeType == 3 || sc.nodeType == 4 ? sc.data.slice(this.startOffset, this.endOffset) : "";\n      } else {\n        var textBits = [],\n            iterator = new RangeIterator(this, true);\n\n        iterateSubtree(iterator, function (node) {\n          // Accept only text or CDATA nodes, not comments\n\n          if (node.nodeType == 3 || node.nodeType == 4) {\n            textBits.push(node.data);\n          }\n        });\n        iterator.detach();\n        return textBits.join("");\n      }\n    },\n\n    // The methods below are all non-standard. The following batch were introduced by Mozilla but have since\n    // been removed from Mozilla.\n\n    compareNode: function compareNode(node) {\n      assertRangeValid(this);\n\n      var parent = node.parentNode;\n      var nodeIndex = dom.getNodeIndex(node);\n\n      if (!parent) {\n        throw new DOMException("NOT_FOUND_ERR");\n      }\n\n      var startComparison = this.comparePoint(parent, nodeIndex),\n          endComparison = this.comparePoint(parent, nodeIndex + 1);\n\n      if (startComparison < 0) {\n        // Node starts before\n        return endComparison > 0 ? n_b_a : n_b;\n      } else {\n        return endComparison > 0 ? n_a : n_i;\n      }\n    },\n\n    comparePoint: function comparePoint(node, offset) {\n      assertRangeValid(this);\n      assertNode(node, "HIERARCHY_REQUEST_ERR");\n      assertSameDocumentOrFragment(node, this.startContainer);\n\n      if (dom.comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {\n        return -1;\n      } else if (dom.comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {\n        return 1;\n      }\n      return 0;\n    },\n\n    createContextualFragment: createContextualFragment,\n\n    toHtml: function toHtml() {\n      assertRangeValid(this);\n      var container = getRangeDocument(this).createElement("div");\n      container.appendChild(this.cloneContents());\n      return container.innerHTML;\n    },\n\n    // touchingIsIntersecting determines whether this method considers a node that borders a range intersects\n    // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)\n    intersectsNode: function intersectsNode(node, touchingIsIntersecting) {\n      assertRangeValid(this);\n      assertNode(node, "NOT_FOUND_ERR");\n      if (dom.getDocument(node) !== getRangeDocument(this)) {\n        return false;\n      }\n\n      var parent = node.parentNode,\n          offset = dom.getNodeIndex(node);\n      assertNode(parent, "NOT_FOUND_ERR");\n\n      var startComparison = dom.comparePoints(parent, offset, this.endContainer, this.endOffset),\n          endComparison = dom.comparePoints(parent, offset + 1, this.startContainer, this.startOffset);\n\n      return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n    },\n\n    isPointInRange: function isPointInRange(node, offset) {\n      assertRangeValid(this);\n      assertNode(node, "HIERARCHY_REQUEST_ERR");\n      assertSameDocumentOrFragment(node, this.startContainer);\n\n      return dom.comparePoints(node, offset, this.startContainer, this.startOffset) >= 0 && dom.comparePoints(node, offset, this.endContainer, this.endOffset) <= 0;\n    },\n\n    // The methods below are non-standard and invented by me.\n\n    // Sharing a boundary start-to-end or end-to-start does not count as intersection.\n    intersectsRange: function intersectsRange(range, touchingIsIntersecting) {\n      assertRangeValid(this);\n\n      if (getRangeDocument(range) != getRangeDocument(this)) {\n        throw new DOMException("WRONG_DOCUMENT_ERR");\n      }\n\n      var startComparison = dom.comparePoints(this.startContainer, this.startOffset, range.endContainer, range.endOffset),\n          endComparison = dom.comparePoints(this.endContainer, this.endOffset, range.startContainer, range.startOffset);\n\n      return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n    },\n\n    intersection: function intersection(range) {\n      if (this.intersectsRange(range)) {\n        var startComparison = dom.comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),\n            endComparison = dom.comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);\n\n        var intersectionRange = this.cloneRange();\n\n        if (startComparison == -1) {\n          intersectionRange.setStart(range.startContainer, range.startOffset);\n        }\n        if (endComparison == 1) {\n          intersectionRange.setEnd(range.endContainer, range.endOffset);\n        }\n        return intersectionRange;\n      }\n      return null;\n    },\n\n    union: function union(range) {\n      if (this.intersectsRange(range, true)) {\n        var unionRange = this.cloneRange();\n        if (dom.comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {\n          unionRange.setStart(range.startContainer, range.startOffset);\n        }\n        if (dom.comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {\n          unionRange.setEnd(range.endContainer, range.endOffset);\n        }\n        return unionRange;\n      } else {\n        throw new RangeException("Ranges do not intersect");\n      }\n    },\n\n    containsNode: function containsNode(node, allowPartial) {\n      if (allowPartial) {\n        return this.intersectsNode(node, false);\n      } else {\n        return this.compareNode(node) == n_i;\n      }\n    },\n\n    containsNodeContents: function containsNodeContents(node) {\n      return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, dom.getNodeLength(node)) <= 0;\n    },\n\n    containsRange: function containsRange(range) {\n      return this.intersection(range).equals(range);\n    },\n\n    containsNodeText: function containsNodeText(node) {\n      var nodeRange = this.cloneRange();\n      nodeRange.selectNode(node);\n      var textNodes = nodeRange.getNodes([3]);\n      if (textNodes.length > 0) {\n        nodeRange.setStart(textNodes[0], 0);\n        var lastTextNode = textNodes.pop();\n        nodeRange.setEnd(lastTextNode, lastTextNode.length);\n        var contains = this.containsRange(nodeRange);\n        nodeRange.detach();\n        return contains;\n      } else {\n        return this.containsNodeContents(node);\n      }\n    },\n\n    createNodeIterator: function createNodeIterator(nodeTypes, filter) {\n      assertRangeValid(this);\n      return new RangeNodeIterator(this, nodeTypes, filter);\n    },\n\n    getNodes: function getNodes(nodeTypes, filter) {\n      assertRangeValid(this);\n      return getNodesInRange(this, nodeTypes, filter);\n    },\n\n    getDocument: function getDocument() {\n      return getRangeDocument(this);\n    },\n\n    collapseBefore: function collapseBefore(node) {\n      assertNotDetached(this);\n\n      this.setEndBefore(node);\n      this.collapse(false);\n    },\n\n    collapseAfter: function collapseAfter(node) {\n      assertNotDetached(this);\n\n      this.setStartAfter(node);\n      this.collapse(true);\n    },\n\n    getName: function getName() {\n      return "DomRange";\n    },\n\n    equals: function equals(range) {\n      return Range.rangesEqual(this, range);\n    },\n\n    inspect: function inspect() {\n      return _inspect(this);\n    }\n  };\n\n  function copyComparisonConstantsToObject(obj) {\n    obj.START_TO_START = s2s;\n    obj.START_TO_END = s2e;\n    obj.END_TO_END = e2e;\n    obj.END_TO_START = e2s;\n\n    obj.NODE_BEFORE = n_b;\n    obj.NODE_AFTER = n_a;\n    obj.NODE_BEFORE_AND_AFTER = n_b_a;\n    obj.NODE_INSIDE = n_i;\n  }\n\n  function copyComparisonConstants(constructor) {\n    copyComparisonConstantsToObject(constructor);\n    copyComparisonConstantsToObject(constructor.prototype);\n  }\n\n  function createRangeContentRemover(remover, boundaryUpdater) {\n    return function () {\n      assertRangeValid(this);\n\n      var sc = this.startContainer,\n          so = this.startOffset,\n          root = this.commonAncestorContainer;\n\n      var iterator = new RangeIterator(this, true);\n\n      // Work out where to position the range after content removal\n      var node, boundary;\n      if (sc !== root) {\n        node = dom.getClosestAncestorIn(sc, root, true);\n        boundary = getBoundaryAfterNode(node);\n        sc = boundary.node;\n        so = boundary.offset;\n      }\n\n      // Check none of the range is read-only\n      iterateSubtree(iterator, assertNodeNotReadOnly);\n\n      iterator.reset();\n\n      // Remove the content\n      var returnValue = remover(iterator);\n      iterator.detach();\n\n      // Move to the new position\n      boundaryUpdater(this, sc, so, sc, so);\n\n      return returnValue;\n    };\n  }\n\n  function createPrototypeRange(constructor, boundaryUpdater, detacher) {\n    function createBeforeAfterNodeSetter(isBefore, isStart) {\n      return function (node) {\n        assertNotDetached(this);\n        assertValidNodeType(node, beforeAfterNodeTypes);\n        assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);\n\n        var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);\n        (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);\n      };\n    }\n\n    function setRangeStart(range, node, offset) {\n      var ec = range.endContainer,\n          eo = range.endOffset;\n      if (node !== range.startContainer || offset !== range.startOffset) {\n        // Check the root containers of the range and the new boundary, and also check whether the new boundary\n        // is after the current end. In either case, collapse the range to the new position\n        if (getRootContainer(node) != getRootContainer(ec) || dom.comparePoints(node, offset, ec, eo) == 1) {\n          ec = node;\n          eo = offset;\n        }\n        boundaryUpdater(range, node, offset, ec, eo);\n      }\n    }\n\n    function setRangeEnd(range, node, offset) {\n      var sc = range.startContainer,\n          so = range.startOffset;\n      if (node !== range.endContainer || offset !== range.endOffset) {\n        // Check the root containers of the range and the new boundary, and also check whether the new boundary\n        // is after the current end. In either case, collapse the range to the new position\n        if (getRootContainer(node) != getRootContainer(sc) || dom.comparePoints(node, offset, sc, so) == -1) {\n          sc = node;\n          so = offset;\n        }\n        boundaryUpdater(range, sc, so, node, offset);\n      }\n    }\n\n    function setRangeStartAndEnd(range, node, offset) {\n      if (node !== range.startContainer || offset !== range.startOffset || node !== range.endContainer || offset !== range.endOffset) {\n        boundaryUpdater(range, node, offset, node, offset);\n      }\n    }\n\n    constructor.prototype = new RangePrototype();\n\n    api.util.extend(constructor.prototype, {\n      setStart: function setStart(node, offset) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n\n        setRangeStart(this, node, offset);\n      },\n\n      setEnd: function setEnd(node, offset) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n\n        setRangeEnd(this, node, offset);\n      },\n\n      setStartBefore: createBeforeAfterNodeSetter(true, true),\n      setStartAfter: createBeforeAfterNodeSetter(false, true),\n      setEndBefore: createBeforeAfterNodeSetter(true, false),\n      setEndAfter: createBeforeAfterNodeSetter(false, false),\n\n      collapse: function collapse(isStart) {\n        assertRangeValid(this);\n        if (isStart) {\n          boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);\n        } else {\n          boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);\n        }\n      },\n\n      selectNodeContents: function selectNodeContents(node) {\n        // This doesn\'t seem well specified: the spec talks only about selecting the node\'s contents, which\n        // could be taken to mean only its children. However, browsers implement this the same as selectNode for\n        // text nodes, so I shall do likewise\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n\n        boundaryUpdater(this, node, 0, node, dom.getNodeLength(node));\n      },\n\n      selectNode: function selectNode(node) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, false);\n        assertValidNodeType(node, beforeAfterNodeTypes);\n\n        var start = getBoundaryBeforeNode(node),\n            end = getBoundaryAfterNode(node);\n        boundaryUpdater(this, start.node, start.offset, end.node, end.offset);\n      },\n\n      extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),\n\n      deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),\n\n      canSurroundContents: function canSurroundContents() {\n        assertRangeValid(this);\n        assertNodeNotReadOnly(this.startContainer);\n        assertNodeNotReadOnly(this.endContainer);\n\n        // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n        // no non-text nodes.\n        var iterator = new RangeIterator(this, true);\n        var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);\n        iterator.detach();\n        return !boundariesInvalid;\n      },\n\n      detach: function detach() {\n        detacher(this);\n      },\n\n      splitBoundaries: function splitBoundaries() {\n        assertRangeValid(this);\n\n        var sc = this.startContainer,\n            so = this.startOffset,\n            ec = this.endContainer,\n            eo = this.endOffset;\n        var startEndSame = sc === ec;\n\n        if (dom.isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n          dom.splitDataNode(ec, eo);\n        }\n\n        if (dom.isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n\n          sc = dom.splitDataNode(sc, so);\n          if (startEndSame) {\n            eo -= so;\n            ec = sc;\n          } else if (ec == sc.parentNode && eo >= dom.getNodeIndex(sc)) {\n            eo++;\n          }\n          so = 0;\n        }\n        boundaryUpdater(this, sc, so, ec, eo);\n      },\n\n      normalizeBoundaries: function normalizeBoundaries() {\n        assertRangeValid(this);\n\n        var sc = this.startContainer,\n            so = this.startOffset,\n            ec = this.endContainer,\n            eo = this.endOffset;\n\n        var mergeForward = function mergeForward(node) {\n          var sibling = node.nextSibling;\n          if (sibling && sibling.nodeType == node.nodeType) {\n            ec = node;\n            eo = node.length;\n            node.appendData(sibling.data);\n            sibling.parentNode.removeChild(sibling);\n          }\n        };\n\n        var mergeBackward = function mergeBackward(node) {\n          var sibling = node.previousSibling;\n          if (sibling && sibling.nodeType == node.nodeType) {\n            sc = node;\n            var nodeLength = node.length;\n            so = sibling.length;\n            node.insertData(0, sibling.data);\n            sibling.parentNode.removeChild(sibling);\n            if (sc == ec) {\n              eo += so;\n              ec = sc;\n            } else if (ec == node.parentNode) {\n              var nodeIndex = dom.getNodeIndex(node);\n              if (eo == nodeIndex) {\n                ec = node;\n                eo = nodeLength;\n              } else if (eo > nodeIndex) {\n                eo--;\n              }\n            }\n          }\n        };\n\n        var normalizeStart = true;\n\n        if (dom.isCharacterDataNode(ec)) {\n          if (ec.length == eo) {\n            mergeForward(ec);\n          }\n        } else {\n          if (eo > 0) {\n            var endNode = ec.childNodes[eo - 1];\n            if (endNode && dom.isCharacterDataNode(endNode)) {\n              mergeForward(endNode);\n            }\n          }\n          normalizeStart = !this.collapsed;\n        }\n\n        if (normalizeStart) {\n          if (dom.isCharacterDataNode(sc)) {\n            if (so == 0) {\n              mergeBackward(sc);\n            }\n          } else {\n            if (so < sc.childNodes.length) {\n              var startNode = sc.childNodes[so];\n              if (startNode && dom.isCharacterDataNode(startNode)) {\n                mergeBackward(startNode);\n              }\n            }\n          }\n        } else {\n          sc = ec;\n          so = eo;\n        }\n\n        boundaryUpdater(this, sc, so, ec, eo);\n      },\n\n      collapseToPoint: function collapseToPoint(node, offset) {\n        assertNotDetached(this);\n\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n\n        setRangeStartAndEnd(this, node, offset);\n      }\n    });\n\n    copyComparisonConstants(constructor);\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Updates commonAncestorContainer and collapsed after boundary change\n  function updateCollapsedAndCommonAncestor(range) {\n    range.collapsed = range.startContainer === range.endContainer && range.startOffset === range.endOffset;\n    range.commonAncestorContainer = range.collapsed ? range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);\n  }\n\n  function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {\n    var startMoved = range.startContainer !== startContainer || range.startOffset !== startOffset;\n    var endMoved = range.endContainer !== endContainer || range.endOffset !== endOffset;\n\n    range.startContainer = startContainer;\n    range.startOffset = startOffset;\n    range.endContainer = endContainer;\n    range.endOffset = endOffset;\n\n    updateCollapsedAndCommonAncestor(range);\n    dispatchEvent(range, "boundarychange", { startMoved: startMoved, endMoved: endMoved });\n  }\n\n  function detach(range) {\n    assertNotDetached(range);\n    range.startContainer = range.startOffset = range.endContainer = range.endOffset = null;\n    range.collapsed = range.commonAncestorContainer = null;\n    dispatchEvent(range, "detach", null);\n    range._listeners = null;\n  }\n\n  /**\n   * @constructor\n   */\n  function Range(doc) {\n    this.startContainer = doc;\n    this.startOffset = 0;\n    this.endContainer = doc;\n    this.endOffset = 0;\n    this._listeners = {\n      boundarychange: [],\n      detach: []\n    };\n    updateCollapsedAndCommonAncestor(this);\n  }\n\n  createPrototypeRange(Range, updateBoundaries, detach);\n\n  api.rangePrototype = RangePrototype.prototype;\n\n  Range.rangeProperties = rangeProperties;\n  Range.RangeIterator = RangeIterator;\n  Range.copyComparisonConstants = copyComparisonConstants;\n  Range.createPrototypeRange = createPrototypeRange;\n  Range.inspect = _inspect;\n  Range.getRangeDocument = getRangeDocument;\n  Range.rangesEqual = function (r1, r2) {\n    return r1.startContainer === r2.startContainer && r1.startOffset === r2.startOffset && r1.endContainer === r2.endContainer && r1.endOffset === r2.endOffset;\n  };\n\n  api.DomRange = Range;\n  api.RangeException = RangeException;\n});rangy.createModule("WrappedRange", function (api, module) {\n  api.requireModules(["DomUtil", "DomRange"]);\n\n  /**\n   * @constructor\n   */\n  var WrappedRange;\n  var dom = api.dom;\n  var DomPosition = dom.DomPosition;\n  var DomRange = api.DomRange;\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  /*\n  This is a workaround for a bug where IE returns the wrong container element from the TextRange\'s parentElement()\n  method. For example, in the following (where pipes denote the selection boundaries):\n   <ul id="ul"><li id="a">| a </li><li id="b"> b |</li></ul>\n   var range = document.selection.createRange();\n  alert(range.parentElement().id); // Should alert "ul" but alerts "b"\n   This method returns the common ancestor node of the following:\n  - the parentElement() of the textRange\n  - the parentElement() of the textRange after calling collapse(true)\n  - the parentElement() of the textRange after calling collapse(false)\n   */\n  function getTextRangeContainerElement(textRange) {\n    var parentEl = textRange.parentElement();\n\n    var range = textRange.duplicate();\n    range.collapse(true);\n    var startEl = range.parentElement();\n    range = textRange.duplicate();\n    range.collapse(false);\n    var endEl = range.parentElement();\n    var startEndContainer = startEl == endEl ? startEl : dom.getCommonAncestor(startEl, endEl);\n\n    return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);\n  }\n\n  function textRangeIsCollapsed(textRange) {\n    return textRange.compareEndPoints("StartToEnd", textRange) == 0;\n  }\n\n  // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started out as\n  // an improved version of code found in Tim Cameron Ryan\'s IERange (http://code.google.com/p/ierange/) but has\n  // grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange bugs, handling\n  // for inputs and images, plus optimizations.\n  function getTextRangeBoundaryPosition(textRange, wholeRangeContainerElement, isStart, isCollapsed) {\n    var workingRange = textRange.duplicate();\n\n    workingRange.collapse(isStart);\n    var containerElement = workingRange.parentElement();\n\n    // Sometimes collapsing a TextRange that\'s at the start of a text node can move it into the previous node, so\n    // check for that\n    // TODO: Find out when. Workaround for wholeRangeContainerElement may break this\n    if (!dom.isAncestorOf(wholeRangeContainerElement, containerElement, true)) {\n      containerElement = wholeRangeContainerElement;\n    }\n\n    // Deal with nodes that cannot "contain rich HTML markup". In practice, this means form inputs, images and\n    // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx\n    if (!containerElement.canHaveHTML) {\n      return new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));\n    }\n\n    var workingNode = dom.getDocument(containerElement).createElement("span");\n    var comparison,\n        workingComparisonType = isStart ? "StartToStart" : "StartToEnd";\n    var previousNode, nextNode, boundaryPosition, boundaryNode;\n\n    // Move the working range through the container\'s children, starting at the end and working backwards, until the\n    // working range reaches or goes past the boundary we\'re interested in\n    do {\n      containerElement.insertBefore(workingNode, workingNode.previousSibling);\n      workingRange.moveToElementText(workingNode);\n    } while ((comparison = workingRange.compareEndPoints(workingComparisonType, textRange)) > 0 && workingNode.previousSibling);\n\n    // We\'ve now reached or gone past the boundary of the text range we\'re interested in\n    // so have identified the node we want\n    boundaryNode = workingNode.nextSibling;\n\n    if (comparison == -1 && boundaryNode && dom.isCharacterDataNode(boundaryNode)) {\n      // This is a character data node (text, comment, cdata). The working range is collapsed at the start of the\n      // node containing the text range\'s boundary, so we move the end of the working range to the boundary point\n      // and measure the length of its text to get the boundary\'s offset within the node.\n      workingRange.setEndPoint(isStart ? "EndToStart" : "EndToEnd", textRange);\n\n      var offset;\n\n      if (/[\\r\\n]/.test(boundaryNode.data)) {\n        /*\n        For the particular case of a boundary within a text node containing line breaks (within a <pre> element,\n        for example), we need a slightly complicated approach to get the boundary\'s offset in IE. The facts:\n         - Each line break is represented as \\r in the text node\'s data/nodeValue properties\n        - Each line break is represented as \\r\\n in the TextRange\'s \'text\' property\n        - The \'text\' property of the TextRange does not contain trailing line breaks\n         To get round the problem presented by the final fact above, we can use the fact that TextRange\'s\n        moveStart() and moveEnd() methods return the actual number of characters moved, which is not necessarily\n        the same as the number of characters it was instructed to move. The simplest approach is to use this to\n        store the characters moved when moving both the start and end of the range to the start of the document\n        body and subtracting the start offset from the end offset (the "move-negative-gazillion" method).\n        However, this is extremely slow when the document is large and the range is near the end of it. Clearly\n        doing the mirror image (i.e. moving the range boundaries to the end of the document) has the same\n        problem.\n         Another approach that works is to use moveStart() to move the start boundary of the range up to the end\n        boundary one character at a time and incrementing a counter with the value returned by the moveStart()\n        call. However, the check for whether the start boundary has reached the end boundary is expensive, so\n        this method is slow (although unlike "move-negative-gazillion" is largely unaffected by the location of\n        the range within the document).\n         The method below is a hybrid of the two methods above. It uses the fact that a string containing the\n        TextRange\'s \'text\' property with each \\r\\n converted to a single \\r character cannot be longer than the\n        text of the TextRange, so the start of the range is moved that length initially and then a character at\n        a time to make up for any trailing line breaks not contained in the \'text\' property. This has good\n        performance in most situations compared to the previous two methods.\n        */\n        var tempRange = workingRange.duplicate();\n        var rangeLength = tempRange.text.replace(/\\r\\n/g, "\\r").length;\n\n        offset = tempRange.moveStart("character", rangeLength);\n        while ((comparison = tempRange.compareEndPoints("StartToEnd", tempRange)) == -1) {\n          offset++;\n          tempRange.moveStart("character", 1);\n        }\n      } else {\n        offset = workingRange.text.length;\n      }\n      boundaryPosition = new DomPosition(boundaryNode, offset);\n    } else {\n\n      // If the boundary immediately follows a character data node and this is the end boundary, we should favour\n      // a position within that, and likewise for a start boundary preceding a character data node\n      previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;\n      nextNode = (isCollapsed || isStart) && workingNode.nextSibling;\n\n      if (nextNode && dom.isCharacterDataNode(nextNode)) {\n        boundaryPosition = new DomPosition(nextNode, 0);\n      } else if (previousNode && dom.isCharacterDataNode(previousNode)) {\n        boundaryPosition = new DomPosition(previousNode, previousNode.length);\n      } else {\n        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));\n      }\n    }\n\n    // Clean up\n    workingNode.parentNode.removeChild(workingNode);\n\n    return boundaryPosition;\n  }\n\n  // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that node.\n  // This function started out as an optimized version of code found in Tim Cameron Ryan\'s IERange\n  // (http://code.google.com/p/ierange/)\n  function createBoundaryTextRange(boundaryPosition, isStart) {\n    var boundaryNode,\n        boundaryParent,\n        boundaryOffset = boundaryPosition.offset;\n    var doc = dom.getDocument(boundaryPosition.node);\n    var workingNode,\n        childNodes,\n        workingRange = doc.body.createTextRange();\n    var nodeIsDataNode = dom.isCharacterDataNode(boundaryPosition.node);\n\n    if (nodeIsDataNode) {\n      boundaryNode = boundaryPosition.node;\n      boundaryParent = boundaryNode.parentNode;\n    } else {\n      childNodes = boundaryPosition.node.childNodes;\n      boundaryNode = boundaryOffset < childNodes.length ? childNodes[boundaryOffset] : null;\n      boundaryParent = boundaryPosition.node;\n    }\n\n    // Position the range immediately before the node containing the boundary\n    workingNode = doc.createElement("span");\n\n    // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within the\n    // element rather than immediately before or after it, which is what we want\n    workingNode.innerHTML = "&#feff;";\n\n    // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report\n    // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12\n    if (boundaryNode) {\n      boundaryParent.insertBefore(workingNode, boundaryNode);\n    } else {\n      boundaryParent.appendChild(workingNode);\n    }\n\n    workingRange.moveToElementText(workingNode);\n    workingRange.collapse(!isStart);\n\n    // Clean up\n    boundaryParent.removeChild(workingNode);\n\n    // Move the working range to the text offset, if required\n    if (nodeIsDataNode) {\n      workingRange[isStart ? "moveStart" : "moveEnd"]("character", boundaryOffset);\n    }\n\n    return workingRange;\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  if (api.features.implementsDomRange && (!api.features.implementsTextRange || !api.config.preferTextRange)) {\n    // This is a wrapper around the browser\'s native DOM Range. It has two aims:\n    // - Provide workarounds for specific browser bugs\n    // - provide convenient extensions, which are inherited from Rangy\'s DomRange\n\n    (function () {\n      var rangeProto;\n      var rangeProperties = DomRange.rangeProperties;\n      var canSetRangeStartAfterEnd;\n\n      function updateRangeProperties(range) {\n        var i = rangeProperties.length,\n            prop;\n        while (i--) {\n          prop = rangeProperties[i];\n          range[prop] = range.nativeRange[prop];\n        }\n      }\n\n      function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {\n        var startMoved = range.startContainer !== startContainer || range.startOffset != startOffset;\n        var endMoved = range.endContainer !== endContainer || range.endOffset != endOffset;\n\n        // Always set both boundaries for the benefit of IE9 (see issue 35)\n        if (startMoved || endMoved) {\n          range.setEnd(endContainer, endOffset);\n          range.setStart(startContainer, startOffset);\n        }\n      }\n\n      function detach(range) {\n        range.nativeRange.detach();\n        range.detached = true;\n        var i = rangeProperties.length,\n            prop;\n        while (i--) {\n          prop = rangeProperties[i];\n          range[prop] = null;\n        }\n      }\n\n      var createBeforeAfterNodeSetter;\n\n      WrappedRange = function WrappedRange(range) {\n        if (!range) {\n          throw new Error("Range must be specified");\n        }\n        this.nativeRange = range;\n        updateRangeProperties(this);\n      };\n\n      DomRange.createPrototypeRange(WrappedRange, updateNativeRange, detach);\n\n      rangeProto = WrappedRange.prototype;\n\n      rangeProto.selectNode = function (node) {\n        this.nativeRange.selectNode(node);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.deleteContents = function () {\n        this.nativeRange.deleteContents();\n        updateRangeProperties(this);\n      };\n\n      rangeProto.extractContents = function () {\n        var frag = this.nativeRange.extractContents();\n        updateRangeProperties(this);\n        return frag;\n      };\n\n      rangeProto.cloneContents = function () {\n        return this.nativeRange.cloneContents();\n      };\n\n      // TODO: Until I can find a way to programmatically trigger the Firefox bug (apparently long-standing, still\n      // present in 3.6.8) that throws "Index or size is negative or greater than the allowed amount" for\n      // insertNode in some circumstances, all browsers will have to use the Rangy\'s own implementation of\n      // insertNode, which works but is almost certainly slower than the native implementation.\n      /*\n                  rangeProto.insertNode = function(node) {\n                      this.nativeRange.insertNode(node);\n                      updateRangeProperties(this);\n                  };\n      */\n\n      rangeProto.surroundContents = function (node) {\n        this.nativeRange.surroundContents(node);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.collapse = function (isStart) {\n        this.nativeRange.collapse(isStart);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.cloneRange = function () {\n        return new WrappedRange(this.nativeRange.cloneRange());\n      };\n\n      rangeProto.refresh = function () {\n        updateRangeProperties(this);\n      };\n\n      rangeProto.toString = function () {\n        return this.nativeRange.toString();\n      };\n\n      // Create test range and node for feature detection\n\n      var testTextNode = document.createTextNode("test");\n      dom.getBody(document).appendChild(testTextNode);\n      var range = document.createRange();\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and\n      // correct for it\n\n      range.setStart(testTextNode, 0);\n      range.setEnd(testTextNode, 0);\n\n      try {\n        range.setStart(testTextNode, 1);\n        canSetRangeStartAfterEnd = true;\n\n        rangeProto.setStart = function (node, offset) {\n          this.nativeRange.setStart(node, offset);\n          updateRangeProperties(this);\n        };\n\n        rangeProto.setEnd = function (node, offset) {\n          this.nativeRange.setEnd(node, offset);\n          updateRangeProperties(this);\n        };\n\n        createBeforeAfterNodeSetter = function createBeforeAfterNodeSetter(name) {\n          return function (node) {\n            this.nativeRange[name](node);\n            updateRangeProperties(this);\n          };\n        };\n      } catch (ex) {\n\n        canSetRangeStartAfterEnd = false;\n\n        rangeProto.setStart = function (node, offset) {\n          try {\n            this.nativeRange.setStart(node, offset);\n          } catch (ex) {\n            this.nativeRange.setEnd(node, offset);\n            this.nativeRange.setStart(node, offset);\n          }\n          updateRangeProperties(this);\n        };\n\n        rangeProto.setEnd = function (node, offset) {\n          try {\n            this.nativeRange.setEnd(node, offset);\n          } catch (ex) {\n            this.nativeRange.setStart(node, offset);\n            this.nativeRange.setEnd(node, offset);\n          }\n          updateRangeProperties(this);\n        };\n\n        createBeforeAfterNodeSetter = function createBeforeAfterNodeSetter(name, oppositeName) {\n          return function (node) {\n            try {\n              this.nativeRange[name](node);\n            } catch (ex) {\n              this.nativeRange[oppositeName](node);\n              this.nativeRange[name](node);\n            }\n            updateRangeProperties(this);\n          };\n        };\n      }\n\n      rangeProto.setStartBefore = createBeforeAfterNodeSetter("setStartBefore", "setEndBefore");\n      rangeProto.setStartAfter = createBeforeAfterNodeSetter("setStartAfter", "setEndAfter");\n      rangeProto.setEndBefore = createBeforeAfterNodeSetter("setEndBefore", "setStartBefore");\n      rangeProto.setEndAfter = createBeforeAfterNodeSetter("setEndAfter", "setStartAfter");\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for and correct Firefox 2 behaviour with selectNodeContents on text nodes: it collapses the range to\n      // the 0th character of the text node\n      range.selectNodeContents(testTextNode);\n      if (range.startContainer == testTextNode && range.endContainer == testTextNode && range.startOffset == 0 && range.endOffset == testTextNode.length) {\n        rangeProto.selectNodeContents = function (node) {\n          this.nativeRange.selectNodeContents(node);\n          updateRangeProperties(this);\n        };\n      } else {\n        rangeProto.selectNodeContents = function (node) {\n          this.setStart(node, 0);\n          this.setEnd(node, DomRange.getEndOffset(node));\n        };\n      }\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for WebKit bug that has the beahviour of compareBoundaryPoints round the wrong way for constants\n      // START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738\n\n      range.selectNodeContents(testTextNode);\n      range.setEnd(testTextNode, 3);\n\n      var range2 = document.createRange();\n      range2.selectNodeContents(testTextNode);\n      range2.setEnd(testTextNode, 4);\n      range2.setStart(testTextNode, 2);\n\n      if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 & range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {\n        // This is the wrong way round, so correct for it\n\n\n        rangeProto.compareBoundaryPoints = function (type, range) {\n          range = range.nativeRange || range;\n          if (type == range.START_TO_END) {\n            type = range.END_TO_START;\n          } else if (type == range.END_TO_START) {\n            type = range.START_TO_END;\n          }\n          return this.nativeRange.compareBoundaryPoints(type, range);\n        };\n      } else {\n        rangeProto.compareBoundaryPoints = function (type, range) {\n          return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);\n        };\n      }\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for existence of createContextualFragment and delegate to it if it exists\n      if (api.util.isHostMethod(range, "createContextualFragment")) {\n        rangeProto.createContextualFragment = function (fragmentStr) {\n          return this.nativeRange.createContextualFragment(fragmentStr);\n        };\n      }\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Clean up\n      dom.getBody(document).removeChild(testTextNode);\n      range.detach();\n      range2.detach();\n    })();\n\n    api.createNativeRange = function (doc) {\n      doc = doc || document;\n      return doc.createRange();\n    };\n  } else if (api.features.implementsTextRange) {\n    // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy\'s DomRange as a\n    // prototype\n\n    WrappedRange = function WrappedRange(textRange) {\n      this.textRange = textRange;\n      this.refresh();\n    };\n\n    WrappedRange.prototype = new DomRange(document);\n\n    WrappedRange.prototype.refresh = function () {\n      var start, end;\n\n      // TextRange\'s parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.\n      var rangeContainerElement = getTextRangeContainerElement(this.textRange);\n\n      if (textRangeIsCollapsed(this.textRange)) {\n        end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, true);\n      } else {\n\n        start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);\n        end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false);\n      }\n\n      this.setStart(start.node, start.offset);\n      this.setEnd(end.node, end.offset);\n    };\n\n    DomRange.copyComparisonConstants(WrappedRange);\n\n    // Add WrappedRange as the Range property of the global object to allow expression like Range.END_TO_END to work\n    var globalObj = function () {\n      return this;\n    }();\n    if (typeof globalObj.Range == "undefined") {\n      globalObj.Range = WrappedRange;\n    }\n\n    api.createNativeRange = function (doc) {\n      doc = doc || document;\n      return doc.body.createTextRange();\n    };\n  }\n\n  if (api.features.implementsTextRange) {\n    WrappedRange.rangeToTextRange = function (range) {\n      if (range.collapsed) {\n        var tr = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n\n        return tr;\n\n        //return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n      } else {\n        var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n        var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);\n        var textRange = dom.getDocument(range.startContainer).body.createTextRange();\n        textRange.setEndPoint("StartToStart", startRange);\n        textRange.setEndPoint("EndToEnd", endRange);\n        return textRange;\n      }\n    };\n  }\n\n  WrappedRange.prototype.getName = function () {\n    return "WrappedRange";\n  };\n\n  api.WrappedRange = WrappedRange;\n\n  api.createRange = function (doc) {\n    doc = doc || document;\n    return new WrappedRange(api.createNativeRange(doc));\n  };\n\n  api.createRangyRange = function (doc) {\n    doc = doc || document;\n    return new DomRange(doc);\n  };\n\n  api.createIframeRange = function (iframeEl) {\n    return api.createRange(dom.getIframeDocument(iframeEl));\n  };\n\n  api.createIframeRangyRange = function (iframeEl) {\n    return api.createRangyRange(dom.getIframeDocument(iframeEl));\n  };\n\n  api.addCreateMissingNativeApiListener(function (win) {\n    var doc = win.document;\n    if (typeof doc.createRange == "undefined") {\n      doc.createRange = function () {\n        return api.createRange(this);\n      };\n    }\n    doc = win = null;\n  });\n});rangy.createModule("WrappedSelection", function (api, module) {\n  // This will create a selection object wrapper that follows the Selection object found in the WHATWG draft DOM Range\n  // spec (http://html5.org/specs/dom-range.html)\n\n  api.requireModules(["DomUtil", "DomRange", "WrappedRange"]);\n\n  api.config.checkSelectionRanges = true;\n\n  var BOOLEAN = "boolean",\n      windowPropertyName = "_rangySelection",\n      dom = api.dom,\n      util = api.util,\n      DomRange = api.DomRange,\n      WrappedRange = api.WrappedRange,\n      DOMException = api.DOMException,\n      DomPosition = dom.DomPosition,\n      getSelection,\n      selectionIsCollapsed,\n      CONTROL = "Control";\n\n  function getWinSelection(winParam) {\n    return (winParam || window).getSelection();\n  }\n\n  function getDocSelection(winParam) {\n    return (winParam || window).document.selection;\n  }\n\n  // Test for the Range/TextRange and Selection features required\n  // Test for ability to retrieve selection\n  var implementsWinGetSelection = api.util.isHostMethod(window, "getSelection"),\n      implementsDocSelection = api.util.isHostObject(document, "selection");\n\n  var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);\n\n  if (useDocumentSelection) {\n    getSelection = getDocSelection;\n    api.isSelectionValid = function (winParam) {\n      var doc = (winParam || window).document,\n          nativeSel = doc.selection;\n\n      // Check whether the selection TextRange is actually contained within the correct document\n      return nativeSel.type != "None" || dom.getDocument(nativeSel.createRange().parentElement()) == doc;\n    };\n  } else if (implementsWinGetSelection) {\n    getSelection = getWinSelection;\n    api.isSelectionValid = function () {\n      return true;\n    };\n  } else {\n    module.fail("Neither document.selection or window.getSelection() detected.");\n  }\n\n  api.getNativeSelection = getSelection;\n\n  var testSelection = getSelection();\n  var testRange = api.createNativeRange(document);\n  var body = dom.getBody(document);\n\n  // Obtaining a range from a selection\n  var selectionHasAnchorAndFocus = util.areHostObjects(testSelection, ["anchorNode", "focusNode"] && util.areHostProperties(testSelection, ["anchorOffset", "focusOffset"]));\n  api.features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;\n\n  // Test for existence of native selection extend() method\n  var selectionHasExtend = util.isHostMethod(testSelection, "extend");\n  api.features.selectionHasExtend = selectionHasExtend;\n\n  // Test if rangeCount exists\n  var selectionHasRangeCount = typeof testSelection.rangeCount == "number";\n  api.features.selectionHasRangeCount = selectionHasRangeCount;\n\n  var selectionSupportsMultipleRanges = false;\n  var collapsedNonEditableSelectionsSupported = true;\n\n  if (util.areHostMethods(testSelection, ["addRange", "getRangeAt", "removeAllRanges"]) && typeof testSelection.rangeCount == "number" && api.features.implementsDomRange) {\n\n    (function () {\n      var iframe = document.createElement("iframe");\n      body.appendChild(iframe);\n\n      var iframeDoc = dom.getIframeDocument(iframe);\n      iframeDoc.open();\n      iframeDoc.write("<html><head></head><body>12</body></html>");\n      iframeDoc.close();\n\n      var sel = dom.getIframeWindow(iframe).getSelection();\n      var docEl = iframeDoc.documentElement;\n      var iframeBody = docEl.lastChild,\n          textNode = iframeBody.firstChild;\n\n      // Test whether the native selection will allow a collapsed selection within a non-editable element\n      var r1 = iframeDoc.createRange();\n      r1.setStart(textNode, 1);\n      r1.collapse(true);\n      sel.addRange(r1);\n      collapsedNonEditableSelectionsSupported = sel.rangeCount == 1;\n      sel.removeAllRanges();\n\n      // Test whether the native selection is capable of supporting multiple ranges\n      var r2 = r1.cloneRange();\n      r1.setStart(textNode, 0);\n      r2.setEnd(textNode, 2);\n      sel.addRange(r1);\n      sel.addRange(r2);\n\n      selectionSupportsMultipleRanges = sel.rangeCount == 2;\n\n      // Clean up\n      r1.detach();\n      r2.detach();\n\n      body.removeChild(iframe);\n    })();\n  }\n\n  api.features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;\n  api.features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;\n\n  // ControlRanges\n  var implementsControlRange = false,\n      testControlRange;\n\n  if (body && util.isHostMethod(body, "createControlRange")) {\n    testControlRange = body.createControlRange();\n    if (util.areHostProperties(testControlRange, ["item", "add"])) {\n      implementsControlRange = true;\n    }\n  }\n  api.features.implementsControlRange = implementsControlRange;\n\n  // Selection collapsedness\n  if (selectionHasAnchorAndFocus) {\n    selectionIsCollapsed = function selectionIsCollapsed(sel) {\n      return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;\n    };\n  } else {\n    selectionIsCollapsed = function selectionIsCollapsed(sel) {\n      return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;\n    };\n  }\n\n  function updateAnchorAndFocusFromRange(sel, range, backwards) {\n    var anchorPrefix = backwards ? "end" : "start",\n        focusPrefix = backwards ? "start" : "end";\n    sel.anchorNode = range[anchorPrefix + "Container"];\n    sel.anchorOffset = range[anchorPrefix + "Offset"];\n    sel.focusNode = range[focusPrefix + "Container"];\n    sel.focusOffset = range[focusPrefix + "Offset"];\n  }\n\n  function updateAnchorAndFocusFromNativeSelection(sel) {\n    var nativeSel = sel.nativeSelection;\n    sel.anchorNode = nativeSel.anchorNode;\n    sel.anchorOffset = nativeSel.anchorOffset;\n    sel.focusNode = nativeSel.focusNode;\n    sel.focusOffset = nativeSel.focusOffset;\n  }\n\n  function updateEmptySelection(sel) {\n    sel.anchorNode = sel.focusNode = null;\n    sel.anchorOffset = sel.focusOffset = 0;\n    sel.rangeCount = 0;\n    sel.isCollapsed = true;\n    sel._ranges.length = 0;\n  }\n\n  function getNativeRange(range) {\n    var nativeRange;\n    if (range instanceof DomRange) {\n      nativeRange = range._selectionNativeRange;\n      if (!nativeRange) {\n        nativeRange = api.createNativeRange(dom.getDocument(range.startContainer));\n        nativeRange.setEnd(range.endContainer, range.endOffset);\n        nativeRange.setStart(range.startContainer, range.startOffset);\n        range._selectionNativeRange = nativeRange;\n        range.attachListener("detach", function () {\n\n          this._selectionNativeRange = null;\n        });\n      }\n    } else if (range instanceof WrappedRange) {\n      nativeRange = range.nativeRange;\n    } else if (api.features.implementsDomRange && range instanceof dom.getWindow(range.startContainer).Range) {\n      nativeRange = range;\n    }\n    return nativeRange;\n  }\n\n  function rangeContainsSingleElement(rangeNodes) {\n    if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {\n      return false;\n    }\n    for (var i = 1, len = rangeNodes.length; i < len; ++i) {\n      if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function getSingleElementFromRange(range) {\n    var nodes = range.getNodes();\n    if (!rangeContainsSingleElement(nodes)) {\n      throw new Error("getSingleElementFromRange: range " + range.inspect() + " did not consist of a single element");\n    }\n    return nodes[0];\n  }\n\n  function isTextRange(range) {\n    return !!range && typeof range.text != "undefined";\n  }\n\n  function updateFromTextRange(sel, range) {\n    // Create a Range from the selected TextRange\n    var wrappedRange = new WrappedRange(range);\n    sel._ranges = [wrappedRange];\n\n    updateAnchorAndFocusFromRange(sel, wrappedRange, false);\n    sel.rangeCount = 1;\n    sel.isCollapsed = wrappedRange.collapsed;\n  }\n\n  function updateControlSelection(sel) {\n    // Update the wrapped selection based on what\'s now in the native selection\n    sel._ranges.length = 0;\n    if (sel.docSelection.type == "None") {\n      updateEmptySelection(sel);\n    } else {\n      var controlRange = sel.docSelection.createRange();\n      if (isTextRange(controlRange)) {\n        // This case (where the selection type is "Control" and calling createRange() on the selection returns\n        // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected\n        // ControlRange have been removed from the ControlRange and removed from the document.\n        updateFromTextRange(sel, controlRange);\n      } else {\n        sel.rangeCount = controlRange.length;\n        var range,\n            doc = dom.getDocument(controlRange.item(0));\n        for (var i = 0; i < sel.rangeCount; ++i) {\n          range = api.createRange(doc);\n          range.selectNode(controlRange.item(i));\n          sel._ranges.push(range);\n        }\n        sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;\n        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);\n      }\n    }\n  }\n\n  function addRangeToControlSelection(sel, range) {\n    var controlRange = sel.docSelection.createRange();\n    var rangeElement = getSingleElementFromRange(range);\n\n    // Create a new ControlRange containing all the elements in the selected ControlRange plus the element\n    // contained by the supplied range\n    var doc = dom.getDocument(controlRange.item(0));\n    var newControlRange = dom.getBody(doc).createControlRange();\n    for (var i = 0, len = controlRange.length; i < len; ++i) {\n      newControlRange.add(controlRange.item(i));\n    }\n    try {\n      newControlRange.add(rangeElement);\n    } catch (ex) {\n      throw new Error("addRange(): Element within the specified Range could not be added to control selection (does it have layout?)");\n    }\n    newControlRange.select();\n\n    // Update the wrapped selection based on what\'s now in the native selection\n    updateControlSelection(sel);\n  }\n\n  var getSelectionRangeAt;\n\n  if (util.isHostMethod(testSelection, "getRangeAt")) {\n    getSelectionRangeAt = function getSelectionRangeAt(sel, index) {\n      try {\n        return sel.getRangeAt(index);\n      } catch (ex) {\n        return null;\n      }\n    };\n  } else if (selectionHasAnchorAndFocus) {\n    getSelectionRangeAt = function getSelectionRangeAt(sel) {\n      var doc = dom.getDocument(sel.anchorNode);\n      var range = api.createRange(doc);\n      range.setStart(sel.anchorNode, sel.anchorOffset);\n      range.setEnd(sel.focusNode, sel.focusOffset);\n\n      // Handle the case when the selection was selected backwards (from the end to the start in the\n      // document)\n      if (range.collapsed !== this.isCollapsed) {\n        range.setStart(sel.focusNode, sel.focusOffset);\n        range.setEnd(sel.anchorNode, sel.anchorOffset);\n      }\n\n      return range;\n    };\n  }\n\n  /**\n   * @constructor\n   */\n  function WrappedSelection(selection, docSelection, win) {\n    this.nativeSelection = selection;\n    this.docSelection = docSelection;\n    this._ranges = [];\n    this.win = win;\n    this.refresh();\n  }\n\n  api.getSelection = function (win) {\n    win = win || window;\n    var sel = win[windowPropertyName];\n    var nativeSel = getSelection(win),\n        docSel = implementsDocSelection ? getDocSelection(win) : null;\n    if (sel) {\n      sel.nativeSelection = nativeSel;\n      sel.docSelection = docSel;\n      sel.refresh(win);\n    } else {\n      sel = new WrappedSelection(nativeSel, docSel, win);\n      win[windowPropertyName] = sel;\n    }\n    return sel;\n  };\n\n  api.getIframeSelection = function (iframeEl) {\n    return api.getSelection(dom.getIframeWindow(iframeEl));\n  };\n\n  var selProto = WrappedSelection.prototype;\n\n  function createControlSelection(sel, ranges) {\n    // Ensure that the selection becomes of type "Control"\n    var doc = dom.getDocument(ranges[0].startContainer);\n    var controlRange = dom.getBody(doc).createControlRange();\n    for (var i = 0, el; i < rangeCount; ++i) {\n      el = getSingleElementFromRange(ranges[i]);\n      try {\n        controlRange.add(el);\n      } catch (ex) {\n        throw new Error("setRanges(): Element within the one of the specified Ranges could not be added to control selection (does it have layout?)");\n      }\n    }\n    controlRange.select();\n\n    // Update the wrapped selection based on what\'s now in the native selection\n    updateControlSelection(sel);\n  }\n\n  // Selecting a range\n  if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, ["removeAllRanges", "addRange"])) {\n    selProto.removeAllRanges = function () {\n      this.nativeSelection.removeAllRanges();\n      updateEmptySelection(this);\n    };\n\n    var addRangeBackwards = function addRangeBackwards(sel, range) {\n      var doc = DomRange.getRangeDocument(range);\n      var endRange = api.createRange(doc);\n      endRange.collapseToPoint(range.endContainer, range.endOffset);\n      sel.nativeSelection.addRange(getNativeRange(endRange));\n      sel.nativeSelection.extend(range.startContainer, range.startOffset);\n      sel.refresh();\n    };\n\n    if (selectionHasRangeCount) {\n      selProto.addRange = function (range, backwards) {\n        if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n          addRangeToControlSelection(this, range);\n        } else {\n          if (backwards && selectionHasExtend) {\n            addRangeBackwards(this, range);\n          } else {\n            var previousRangeCount;\n            if (selectionSupportsMultipleRanges) {\n              previousRangeCount = this.rangeCount;\n            } else {\n              this.removeAllRanges();\n              previousRangeCount = 0;\n            }\n            this.nativeSelection.addRange(getNativeRange(range));\n\n            // Check whether adding the range was successful\n            this.rangeCount = this.nativeSelection.rangeCount;\n\n            if (this.rangeCount == previousRangeCount + 1) {\n              // The range was added successfully\n\n              // Check whether the range that we added to the selection is reflected in the last range extracted from\n              // the selection\n              if (api.config.checkSelectionRanges) {\n                var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);\n                if (nativeRange && !DomRange.rangesEqual(nativeRange, range)) {\n                  // Happens in WebKit with, for example, a selection placed at the start of a text node\n                  range = new WrappedRange(nativeRange);\n                }\n              }\n              this._ranges[this.rangeCount - 1] = range;\n              updateAnchorAndFocusFromRange(this, range, selectionIsBackwards(this.nativeSelection));\n              this.isCollapsed = selectionIsCollapsed(this);\n            } else {\n              // The range was not added successfully. The simplest thing is to refresh\n              this.refresh();\n            }\n          }\n        }\n      };\n    } else {\n      selProto.addRange = function (range, backwards) {\n        if (backwards && selectionHasExtend) {\n          addRangeBackwards(this, range);\n        } else {\n          this.nativeSelection.addRange(getNativeRange(range));\n          this.refresh();\n        }\n      };\n    }\n\n    selProto.setRanges = function (ranges) {\n      if (implementsControlRange && ranges.length > 1) {\n        createControlSelection(this, ranges);\n      } else {\n        this.removeAllRanges();\n        for (var i = 0, len = ranges.length; i < len; ++i) {\n          this.addRange(ranges[i]);\n        }\n      }\n    };\n  } else if (util.isHostMethod(testSelection, "empty") && util.isHostMethod(testRange, "select") && implementsControlRange && useDocumentSelection) {\n\n    selProto.removeAllRanges = function () {\n      // Added try/catch as fix for issue #21\n      try {\n        this.docSelection.empty();\n\n        // Check for empty() not working (issue #24)\n        if (this.docSelection.type != "None") {\n          // Work around failure to empty a control selection by instead selecting a TextRange and then\n          // calling empty()\n          var doc;\n          if (this.anchorNode) {\n            doc = dom.getDocument(this.anchorNode);\n          } else if (this.docSelection.type == CONTROL) {\n            var controlRange = this.docSelection.createRange();\n            if (controlRange.length) {\n              doc = dom.getDocument(controlRange.item(0)).body.createTextRange();\n            }\n          }\n          if (doc) {\n            var textRange = doc.body.createTextRange();\n            textRange.select();\n            this.docSelection.empty();\n          }\n        }\n      } catch (ex) {}\n      updateEmptySelection(this);\n    };\n\n    selProto.addRange = function (range) {\n      if (this.docSelection.type == CONTROL) {\n        addRangeToControlSelection(this, range);\n      } else {\n        WrappedRange.rangeToTextRange(range).select();\n        this._ranges[0] = range;\n        this.rangeCount = 1;\n        this.isCollapsed = this._ranges[0].collapsed;\n        updateAnchorAndFocusFromRange(this, range, false);\n      }\n    };\n\n    selProto.setRanges = function (ranges) {\n      this.removeAllRanges();\n      var rangeCount = ranges.length;\n      if (rangeCount > 1) {\n        createControlSelection(this, ranges);\n      } else if (rangeCount) {\n        this.addRange(ranges[0]);\n      }\n    };\n  } else {\n    module.fail("No means of selecting a Range or TextRange was found");\n    return false;\n  }\n\n  selProto.getRangeAt = function (index) {\n    if (index < 0 || index >= this.rangeCount) {\n      throw new DOMException("INDEX_SIZE_ERR");\n    } else {\n      return this._ranges[index];\n    }\n  };\n\n  var refreshSelection;\n\n  if (useDocumentSelection) {\n    refreshSelection = function refreshSelection(sel) {\n      var range;\n      if (api.isSelectionValid(sel.win)) {\n        range = sel.docSelection.createRange();\n      } else {\n        range = dom.getBody(sel.win.document).createTextRange();\n        range.collapse(true);\n      }\n\n      if (sel.docSelection.type == CONTROL) {\n        updateControlSelection(sel);\n      } else if (isTextRange(range)) {\n        updateFromTextRange(sel, range);\n      } else {\n        updateEmptySelection(sel);\n      }\n    };\n  } else if (util.isHostMethod(testSelection, "getRangeAt") && typeof testSelection.rangeCount == "number") {\n    refreshSelection = function refreshSelection(sel) {\n      if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {\n        updateControlSelection(sel);\n      } else {\n        sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;\n        if (sel.rangeCount) {\n          for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));\n          }\n          updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackwards(sel.nativeSelection));\n          sel.isCollapsed = selectionIsCollapsed(sel);\n        } else {\n          updateEmptySelection(sel);\n        }\n      }\n    };\n  } else if (selectionHasAnchorAndFocus && _typeof(testSelection.isCollapsed) == BOOLEAN && _typeof(testRange.collapsed) == BOOLEAN && api.features.implementsDomRange) {\n    refreshSelection = function refreshSelection(sel) {\n      var range,\n          nativeSel = sel.nativeSelection;\n      if (nativeSel.anchorNode) {\n        range = getSelectionRangeAt(nativeSel, 0);\n        sel._ranges = [range];\n        sel.rangeCount = 1;\n        updateAnchorAndFocusFromNativeSelection(sel);\n        sel.isCollapsed = selectionIsCollapsed(sel);\n      } else {\n        updateEmptySelection(sel);\n      }\n    };\n  } else {\n    module.fail("No means of obtaining a Range or TextRange from the user\'s selection was found");\n    return false;\n  }\n\n  selProto.refresh = function (checkForChanges) {\n    var oldRanges = checkForChanges ? this._ranges.slice(0) : null;\n    refreshSelection(this);\n    if (checkForChanges) {\n      var i = oldRanges.length;\n      if (i != this._ranges.length) {\n        return false;\n      }\n      while (i--) {\n        if (!DomRange.rangesEqual(oldRanges[i], this._ranges[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  };\n\n  // Removal of a single range\n  var removeRangeManually = function removeRangeManually(sel, range) {\n    var ranges = sel.getAllRanges(),\n        removed = false;\n    sel.removeAllRanges();\n    for (var i = 0, len = ranges.length; i < len; ++i) {\n      if (removed || range !== ranges[i]) {\n        sel.addRange(ranges[i]);\n      } else {\n        // According to the draft WHATWG Range spec, the same range may be added to the selection multiple\n        // times. removeRange should only remove the first instance, so the following ensures only the first\n        // instance is removed\n        removed = true;\n      }\n    }\n    if (!sel.rangeCount) {\n      updateEmptySelection(sel);\n    }\n  };\n\n  if (implementsControlRange) {\n    selProto.removeRange = function (range) {\n      if (this.docSelection.type == CONTROL) {\n        var controlRange = this.docSelection.createRange();\n        var rangeElement = getSingleElementFromRange(range);\n\n        // Create a new ControlRange containing all the elements in the selected ControlRange minus the\n        // element contained by the supplied range\n        var doc = dom.getDocument(controlRange.item(0));\n        var newControlRange = dom.getBody(doc).createControlRange();\n        var el,\n            removed = false;\n        for (var i = 0, len = controlRange.length; i < len; ++i) {\n          el = controlRange.item(i);\n          if (el !== rangeElement || removed) {\n            newControlRange.add(controlRange.item(i));\n          } else {\n            removed = true;\n          }\n        }\n        newControlRange.select();\n\n        // Update the wrapped selection based on what\'s now in the native selection\n        updateControlSelection(this);\n      } else {\n        removeRangeManually(this, range);\n      }\n    };\n  } else {\n    selProto.removeRange = function (range) {\n      removeRangeManually(this, range);\n    };\n  }\n\n  // Detecting if a selection is backwards\n  var selectionIsBackwards;\n  if (!useDocumentSelection && selectionHasAnchorAndFocus && api.features.implementsDomRange) {\n    selectionIsBackwards = function selectionIsBackwards(sel) {\n      var backwards = false;\n      if (sel.anchorNode) {\n        backwards = dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1;\n      }\n      return backwards;\n    };\n\n    selProto.isBackwards = function () {\n      return selectionIsBackwards(this);\n    };\n  } else {\n    selectionIsBackwards = selProto.isBackwards = function () {\n      return false;\n    };\n  }\n\n  // Selection text\n  // This is conformant to the new WHATWG DOM Range draft spec but differs from WebKit and Mozilla\'s implementation\n  selProto.toString = function () {\n\n    var rangeTexts = [];\n    for (var i = 0, len = this.rangeCount; i < len; ++i) {\n      rangeTexts[i] = "" + this._ranges[i];\n    }\n    return rangeTexts.join("");\n  };\n\n  function assertNodeInSameDocument(sel, node) {\n    if (sel.anchorNode && dom.getDocument(sel.anchorNode) !== dom.getDocument(node)) {\n      throw new DOMException("WRONG_DOCUMENT_ERR");\n    }\n  }\n\n  // No current browsers conform fully to the HTML 5 draft spec for this method, so Rangy\'s own method is always used\n  selProto.collapse = function (node, offset) {\n    assertNodeInSameDocument(this, node);\n    var range = api.createRange(dom.getDocument(node));\n    range.collapseToPoint(node, offset);\n    this.removeAllRanges();\n    this.addRange(range);\n    this.isCollapsed = true;\n  };\n\n  selProto.collapseToStart = function () {\n    if (this.rangeCount) {\n      var range = this._ranges[0];\n      this.collapse(range.startContainer, range.startOffset);\n    } else {\n      throw new DOMException("INVALID_STATE_ERR");\n    }\n  };\n\n  selProto.collapseToEnd = function () {\n    if (this.rangeCount) {\n      var range = this._ranges[this.rangeCount - 1];\n      this.collapse(range.endContainer, range.endOffset);\n    } else {\n      throw new DOMException("INVALID_STATE_ERR");\n    }\n  };\n\n  // The HTML 5 spec is very specific on how selectAllChildren should be implemented so the native implementation is\n  // never used by Rangy.\n  selProto.selectAllChildren = function (node) {\n    assertNodeInSameDocument(this, node);\n    var range = api.createRange(dom.getDocument(node));\n    range.selectNodeContents(node);\n    this.removeAllRanges();\n    this.addRange(range);\n  };\n\n  selProto.deleteFromDocument = function () {\n    // Sepcial behaviour required for Control selections\n    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n      var controlRange = this.docSelection.createRange();\n      var element;\n      while (controlRange.length) {\n        element = controlRange.item(0);\n        controlRange.remove(element);\n        element.parentNode.removeChild(element);\n      }\n      this.refresh();\n    } else if (this.rangeCount) {\n      var ranges = this.getAllRanges();\n      this.removeAllRanges();\n      for (var i = 0, len = ranges.length; i < len; ++i) {\n        ranges[i].deleteContents();\n      }\n      // The HTML5 spec says nothing about what the selection should contain after calling deleteContents on each\n      // range. Firefox moves the selection to where the final selected range was, so we emulate that\n      this.addRange(ranges[len - 1]);\n    }\n  };\n\n  // The following are non-standard extensions\n  selProto.getAllRanges = function () {\n    return this._ranges.slice(0);\n  };\n\n  selProto.setSingleRange = function (range) {\n    this.setRanges([range]);\n  };\n\n  selProto.containsNode = function (node, allowPartial) {\n    for (var i = 0, len = this._ranges.length; i < len; ++i) {\n      if (this._ranges[i].containsNode(node, allowPartial)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  selProto.toHtml = function () {\n    var html = "";\n    if (this.rangeCount) {\n      var container = DomRange.getRangeDocument(this._ranges[0]).createElement("div");\n      for (var i = 0, len = this._ranges.length; i < len; ++i) {\n        container.appendChild(this._ranges[i].cloneContents());\n      }\n      html = container.innerHTML;\n    }\n    return html;\n  };\n\n  function inspect(sel) {\n    var rangeInspects = [];\n    var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);\n    var focus = new DomPosition(sel.focusNode, sel.focusOffset);\n    var name = typeof sel.getName == "function" ? sel.getName() : "Selection";\n\n    if (typeof sel.rangeCount != "undefined") {\n      for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n        rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));\n      }\n    }\n    return "[" + name + "(Ranges: " + rangeInspects.join(", ") + ")(anchor: " + anchor.inspect() + ", focus: " + focus.inspect() + "]";\n  }\n\n  selProto.getName = function () {\n    return "WrappedSelection";\n  };\n\n  selProto.inspect = function () {\n    return inspect(this);\n  };\n\n  selProto.detach = function () {\n    this.win[windowPropertyName] = null;\n    this.win = this.anchorNode = this.focusNode = null;\n  };\n\n  WrappedSelection.inspect = inspect;\n\n  api.Selection = WrappedSelection;\n\n  api.selectionPrototype = selProto;\n\n  api.addCreateMissingNativeApiListener(function (win) {\n    if (typeof win.getSelection == "undefined") {\n      win.getSelection = function () {\n        return api.getSelection(this);\n      };\n    }\n    win = null;\n  });\n});\n/*\n\tBase.js, version 1.1a\n\tCopyright 2006-2010, Dean Edwards\n\tLicense: http://www.opensource.org/licenses/mit-license.php\n*/\n\nvar Base = function Base() {\n  // dummy\n};\n\nBase.extend = function (_instance, _static) {\n  // subclass\n  var extend = Base.prototype.extend;\n\n  // build the prototype\n  Base._prototyping = true;\n  var proto = new this();\n  extend.call(proto, _instance);\n  proto.base = function () {\n    // call this method from any other method to invoke that method\'s ancestor\n  };\n  delete Base._prototyping;\n\n  // create the wrapper for the constructor function\n  //var constructor = proto.constructor.valueOf(); //-dean\n  var constructor = proto.constructor;\n  var klass = proto.constructor = function () {\n    if (!Base._prototyping) {\n      if (this._constructing || this.constructor == klass) {\n        // instantiation\n        this._constructing = true;\n        constructor.apply(this, arguments);\n        delete this._constructing;\n      } else if (arguments[0] != null) {\n        // casting\n        return (arguments[0].extend || extend).call(arguments[0], proto);\n      }\n    }\n  };\n\n  // build the class interface\n  klass.ancestor = this;\n  klass.extend = this.extend;\n  klass.forEach = this.forEach;\n  klass.implement = this.implement;\n  klass.prototype = proto;\n  klass.toString = this.toString;\n  klass.valueOf = function (type) {\n    //return (type == "object") ? klass : constructor; //-dean\n    return type == "object" ? klass : constructor.valueOf();\n  };\n  extend.call(klass, _static);\n  // class initialisation\n  if (typeof klass.init == "function") klass.init();\n  return klass;\n};\n\nBase.prototype = {\n  extend: function extend(source, value) {\n    if (arguments.length > 1) {\n      // extending with a name/value pair\n      var ancestor = this[source];\n      if (ancestor && typeof value == "function" && ( // overriding a method?\n      // the valueOf() comparison is to avoid circular references\n      !ancestor.valueOf || ancestor.valueOf() != value.valueOf()) && /\\bbase\\b/.test(value)) {\n        // get the underlying method\n        var method = value.valueOf();\n        // override\n        value = function value() {\n          var previous = this.base || Base.prototype.base;\n          this.base = ancestor;\n          var returnValue = method.apply(this, arguments);\n          this.base = previous;\n          return returnValue;\n        };\n        // point to the underlying method\n        value.valueOf = function (type) {\n          return type == "object" ? value : method;\n        };\n        value.toString = Base.toString;\n      }\n      this[source] = value;\n    } else if (source) {\n      // extending with an object literal\n      var extend = Base.prototype.extend;\n      // if this object has a customised extend method then use it\n      if (!Base._prototyping && typeof this != "function") {\n        extend = this.extend || extend;\n      }\n      var proto = { toSource: null };\n      // do the "toString" and other methods manually\n      var hidden = ["constructor", "toString", "valueOf"];\n      // if we are prototyping then include the constructor\n      var i = Base._prototyping ? 0 : 1;\n      while (key = hidden[i++]) {\n        if (source[key] != proto[key]) {\n          extend.call(this, key, source[key]);\n        }\n      }\n      // copy each of the source object\'s properties to this object\n      for (var key in source) {\n        if (!proto[key]) extend.call(this, key, source[key]);\n      }\n    }\n    return this;\n  }\n};\n\n// initialise\nBase = Base.extend({\n  constructor: function constructor() {\n    this.extend(arguments[0]);\n  }\n}, {\n  ancestor: Object,\n  version: "1.1",\n\n  forEach: function forEach(object, block, context) {\n    for (var key in object) {\n      if (this.prototype[key] === undefined) {\n        block.call(context, object[key], key, object);\n      }\n    }\n  },\n\n  implement: function implement() {\n    for (var i = 0; i < arguments.length; i++) {\n      if (typeof arguments[i] == "function") {\n        // if it\'s a function, call it\n        arguments[i](this.prototype);\n      } else {\n        // add the interface using the extend method\n        this.prototype.extend(arguments[i]);\n      }\n    }\n    return this;\n  },\n\n  toString: function toString() {\n    return String(this.valueOf());\n  }\n}); /**\n    * Detect browser support for specific features\n    */\nwysihtml5.browser = function () {\n  var userAgent = navigator.userAgent,\n      testElement = document.createElement("div"),\n\n\n  // Browser sniffing is unfortunately needed since some behaviors are impossible to feature detect\n  isIE = userAgent.indexOf("MSIE") !== -1 && userAgent.indexOf("Opera") === -1,\n      isGecko = userAgent.indexOf("Gecko") !== -1 && userAgent.indexOf("KHTML") === -1,\n      isWebKit = userAgent.indexOf("AppleWebKit/") !== -1,\n      isChrome = userAgent.indexOf("Chrome/") !== -1,\n      isOpera = userAgent.indexOf("Opera/") !== -1;\n\n  function iosVersion(userAgent) {\n    return (/ipad|iphone|ipod/.test(userAgent) && userAgent.match(/ os (\\d+).+? like mac os x/) || [, 0])[1];\n  }\n\n  return {\n    // Static variable needed, publicly accessible, to be able override it in unit tests\n    USER_AGENT: userAgent,\n\n    /**\n     * Exclude browsers that are not capable of displaying and handling\n     * contentEditable as desired:\n     *    - iPhone, iPad (tested iOS 4.2.2) and Android (tested 2.2) refuse to make contentEditables focusable\n     *    - IE < 8 create invalid markup and crash randomly from time to time\n     *\n     * @return {Boolean}\n     */\n    supported: function supported() {\n      var userAgent = this.USER_AGENT.toLowerCase(),\n\n\n      // Essential for making html elements editable\n      hasContentEditableSupport = "contentEditable" in testElement,\n\n\n      // Following methods are needed in order to interact with the contentEditable area\n      hasEditingApiSupport = document.execCommand && document.queryCommandSupported && document.queryCommandState,\n\n\n      // document selector apis are only supported by IE 8+, Safari 4+, Chrome and Firefox 3.5+\n      hasQuerySelectorSupport = document.querySelector && document.querySelectorAll,\n\n\n      // contentEditable is unusable in mobile browsers (tested iOS 4.2.2, Android 2.2, Opera Mobile, WebOS 3.05)\n      isIncompatibleMobileBrowser = this.isIos() && iosVersion(userAgent) < 5 || userAgent.indexOf("opera mobi") !== -1 || userAgent.indexOf("hpwos/") !== -1;\n\n      return hasContentEditableSupport && hasEditingApiSupport && hasQuerySelectorSupport && !isIncompatibleMobileBrowser;\n    },\n\n    isTouchDevice: function isTouchDevice() {\n      return this.supportsEvent("touchmove");\n    },\n\n    isIos: function isIos() {\n      var userAgent = this.USER_AGENT.toLowerCase();\n      return userAgent.indexOf("webkit") !== -1 && userAgent.indexOf("mobile") !== -1;\n    },\n\n    /**\n     * Whether the browser supports sandboxed iframes\n     * Currently only IE 6+ offers such feature <iframe security="restricted">\n     *\n     * http://msdn.microsoft.com/en-us/library/ms534622(v=vs.85).aspx\n     * http://blogs.msdn.com/b/ie/archive/2008/01/18/using-frames-more-securely.aspx\n     *\n     * HTML5 sandboxed iframes are still buggy and their DOM is not reachable from the outside (except when using postMessage)\n     */\n    supportsSandboxedIframes: function supportsSandboxedIframes() {\n      return isIE;\n    },\n\n    /**\n     * IE6+7 throw a mixed content warning when the src of an iframe\n     * is empty/unset or about:blank\n     * window.querySelector is implemented as of IE8\n     */\n    throwsMixedContentWarningWhenIframeSrcIsEmpty: function throwsMixedContentWarningWhenIframeSrcIsEmpty() {\n      return !("querySelector" in document);\n    },\n\n    /**\n     * Whether the caret is correctly displayed in contentEditable elements\n     * Firefox sometimes shows a huge caret in the beginning after focusing\n     */\n    displaysCaretInEmptyContentEditableCorrectly: function displaysCaretInEmptyContentEditableCorrectly() {\n      return !isGecko;\n    },\n\n    /**\n     * Opera and IE are the only browsers who offer the css value\n     * in the original unit, thx to the currentStyle object\n     * All other browsers provide the computed style in px via window.getComputedStyle\n     */\n    hasCurrentStyleProperty: function hasCurrentStyleProperty() {\n      return "currentStyle" in testElement;\n    },\n\n    /**\n     * Whether the browser inserts a <br> when pressing enter in a contentEditable element\n     */\n    insertsLineBreaksOnReturn: function insertsLineBreaksOnReturn() {\n      return isGecko;\n    },\n\n    supportsPlaceholderAttributeOn: function supportsPlaceholderAttributeOn(element) {\n      return "placeholder" in element;\n    },\n\n    supportsEvent: function supportsEvent(eventName) {\n      return "on" + eventName in testElement || function () {\n        testElement.setAttribute("on" + eventName, "return;");\n        return typeof testElement["on" + eventName] === "function";\n      }();\n    },\n\n    /**\n     * Opera doesn\'t correctly fire focus/blur events when clicking in- and outside of iframe\n     */\n    supportsEventsInIframeCorrectly: function supportsEventsInIframeCorrectly() {\n      return !isOpera;\n    },\n\n    /**\n     * Chrome & Safari only fire the ondrop/ondragend/... events when the ondragover event is cancelled\n     * with event.preventDefault\n     * Firefox 3.6 fires those events anyway, but the mozilla doc says that the dragover/dragenter event needs\n     * to be cancelled\n     */\n    firesOnDropOnlyWhenOnDragOverIsCancelled: function firesOnDropOnlyWhenOnDragOverIsCancelled() {\n      return isWebKit || isGecko;\n    },\n\n    /**\n     * Whether the browser supports the event.dataTransfer property in a proper way\n     */\n    supportsDataTransfer: function supportsDataTransfer() {\n      try {\n        // Firefox doesn\'t support dataTransfer in a safe way, it doesn\'t strip script code in the html payload (like Chrome does)\n        return isWebKit && (window.Clipboard || window.DataTransfer).prototype.getData;\n      } catch (e) {\n        return false;\n      }\n    },\n\n    /**\n     * Everything below IE9 doesn\'t know how to treat HTML5 tags\n     *\n     * @param {Object} context The document object on which to check HTML5 support\n     *\n     * @example\n     *    wysihtml5.browser.supportsHTML5Tags(document);\n     */\n    supportsHTML5Tags: function supportsHTML5Tags(context) {\n      var element = context.createElement("div"),\n          html5 = "<article>foo</article>";\n      element.innerHTML = html5;\n      return element.innerHTML.toLowerCase() === html5;\n    },\n\n    /**\n     * Checks whether a document supports a certain queryCommand\n     * In particular, Opera needs a reference to a document that has a contentEditable in it\'s dom tree\n     * in oder to report correct results\n     *\n     * @param {Object} doc Document object on which to check for a query command\n     * @param {String} command The query command to check for\n     * @return {Boolean}\n     *\n     * @example\n     *    wysihtml5.browser.supportsCommand(document, "bold");\n     */\n    supportsCommand: function () {\n      // Following commands are supported but contain bugs in some browsers\n      var buggyCommands = {\n        // formatBlock fails with some tags (eg. <blockquote>)\n        "formatBlock": isIE,\n        // When inserting unordered or ordered lists in Firefox, Chrome or Safari, the current selection or line gets\n        // converted into a list (<ul><li>...</li></ul>, <ol><li>...</li></ol>)\n        // IE and Opera act a bit different here as they convert the entire content of the current block element into a list\n        "insertUnorderedList": isIE || isOpera || isWebKit,\n        "insertOrderedList": isIE || isOpera || isWebKit\n      };\n\n      // Firefox throws errors for queryCommandSupported, so we have to build up our own object of supported commands\n      var supported = {\n        "insertHTML": isGecko\n      };\n\n      return function (doc, command) {\n        var isBuggy = buggyCommands[command];\n        if (!isBuggy) {\n          // Firefox throws errors when invoking queryCommandSupported or queryCommandEnabled\n          try {\n            return doc.queryCommandSupported(command);\n          } catch (e1) {}\n\n          try {\n            return doc.queryCommandEnabled(command);\n          } catch (e2) {\n            return !!supported[command];\n          }\n        }\n        return false;\n      };\n    }(),\n\n    /**\n     * IE: URLs starting with:\n     *    www., http://, https://, ftp://, gopher://, mailto:, new:, snews:, telnet:, wasis:, file://,\n     *    nntp://, newsrc:, ldap://, ldaps://, outlook:, mic:// and url:\n     * will automatically be auto-linked when either the user inserts them via copy&paste or presses the\n     * space bar when the caret is directly after such an url.\n     * This behavior cannot easily be avoided in IE < 9 since the logic is hardcoded in the mshtml.dll\n     * (related blog post on msdn\n     * http://blogs.msdn.com/b/ieinternals/archive/2009/09/17/prevent-automatic-hyperlinking-in-contenteditable-html.aspx).\n     */\n    doesAutoLinkingInContentEditable: function doesAutoLinkingInContentEditable() {\n      return isIE;\n    },\n\n    /**\n     * As stated above, IE auto links urls typed into contentEditable elements\n     * Since IE9 it\'s possible to prevent this behavior\n     */\n    canDisableAutoLinking: function canDisableAutoLinking() {\n      return this.supportsCommand(document, "AutoUrlDetect");\n    },\n\n    /**\n     * IE leaves an empty paragraph in the contentEditable element after clearing it\n     * Chrome/Safari sometimes an empty <div>\n     */\n    clearsContentEditableCorrectly: function clearsContentEditableCorrectly() {\n      return isGecko || isOpera || isWebKit;\n    },\n\n    /**\n     * IE gives wrong results for getAttribute\n     */\n    supportsGetAttributeCorrectly: function supportsGetAttributeCorrectly() {\n      var td = document.createElement("td");\n      return td.getAttribute("rowspan") != "1";\n    },\n\n    /**\n     * When clicking on images in IE, Opera and Firefox, they are selected, which makes it easy to interact with them.\n     * Chrome and Safari both don\'t support this\n     */\n    canSelectImagesInContentEditable: function canSelectImagesInContentEditable() {\n      return isGecko || isIE || isOpera;\n    },\n\n    /**\n     * When the caret is in an empty list (<ul><li>|</li></ul>) which is the first child in an contentEditable container\n     * pressing backspace doesn\'t remove the entire list as done in other browsers\n     */\n    clearsListsInContentEditableCorrectly: function clearsListsInContentEditableCorrectly() {\n      return isGecko || isIE || isWebKit;\n    },\n\n    /**\n     * All browsers except Safari and Chrome automatically scroll the range/caret position into view\n     */\n    autoScrollsToCaret: function autoScrollsToCaret() {\n      return !isWebKit;\n    },\n\n    /**\n     * Check whether the browser automatically closes tags that don\'t need to be opened\n     */\n    autoClosesUnclosedTags: function autoClosesUnclosedTags() {\n      var clonedTestElement = testElement.cloneNode(false),\n          returnValue,\n          innerHTML;\n\n      clonedTestElement.innerHTML = "<p><div></div>";\n      innerHTML = clonedTestElement.innerHTML.toLowerCase();\n      returnValue = innerHTML === "<p></p><div></div>" || innerHTML === "<p><div></div></p>";\n\n      // Cache result by overwriting current function\n      this.autoClosesUnclosedTags = function () {\n        return returnValue;\n      };\n\n      return returnValue;\n    },\n\n    /**\n     * Whether the browser supports the native document.getElementsByClassName which returns live NodeLists\n     */\n    supportsNativeGetElementsByClassName: function supportsNativeGetElementsByClassName() {\n      return String(document.getElementsByClassName).indexOf("[native code]") !== -1;\n    },\n\n    /**\n     * As of now (19.04.2011) only supported by Firefox 4 and Chrome\n     * See https://developer.mozilla.org/en/DOM/Selection/modify\n     */\n    supportsSelectionModify: function supportsSelectionModify() {\n      return "getSelection" in window && "modify" in window.getSelection();\n    },\n\n    /**\n     * Whether the browser supports the classList object for fast className manipulation\n     * See https://developer.mozilla.org/en/DOM/element.classList\n     */\n    supportsClassList: function supportsClassList() {\n      return "classList" in testElement;\n    },\n\n    /**\n     * Opera needs a white space after a <br> in order to position the caret correctly\n     */\n    needsSpaceAfterLineBreak: function needsSpaceAfterLineBreak() {\n      return isOpera;\n    },\n\n    /**\n     * Whether the browser supports the speech api on the given element\n     * See http://mikepultz.com/2011/03/accessing-google-speech-api-chrome-11/\n     *\n     * @example\n     *    var input = document.createElement("input");\n     *    if (wysihtml5.browser.supportsSpeechApiOn(input)) {\n     *      // ...\n     *    }\n     */\n    supportsSpeechApiOn: function supportsSpeechApiOn(input) {\n      var chromeVersion = userAgent.match(/Chrome\\/(\\d+)/) || [, 0];\n      return chromeVersion[1] >= 11 && ("onwebkitspeechchange" in input || "speech" in input);\n    },\n\n    /**\n     * IE9 crashes when setting a getter via Object.defineProperty on XMLHttpRequest or XDomainRequest\n     * See https://connect.microsoft.com/ie/feedback/details/650112\n     * or try the POC http://tifftiff.de/ie9_crash/\n     */\n    crashesWhenDefineProperty: function crashesWhenDefineProperty(property) {\n      return isIE && (property === "XMLHttpRequest" || property === "XDomainRequest");\n    },\n\n    /**\n     * IE is the only browser who fires the "focus" event not immediately when .focus() is called on an element\n     */\n    doesAsyncFocus: function doesAsyncFocus() {\n      return isIE;\n    },\n\n    /**\n     * In IE it\'s impssible for the user and for the selection library to set the caret after an <img> when it\'s the lastChild in the document\n     */\n    hasProblemsSettingCaretAfterImg: function hasProblemsSettingCaretAfterImg() {\n      return isIE;\n    },\n\n    hasUndoInContextMenu: function hasUndoInContextMenu() {\n      return isGecko || isChrome || isOpera;\n    }\n  };\n}();wysihtml5.lang.array = function (arr) {\n  return {\n    /**\n     * Check whether a given object exists in an array\n     *\n     * @example\n     *    wysihtml5.lang.array([1, 2]).contains(1);\n     *    // => true\n     */\n    contains: function contains(needle) {\n      if (arr.indexOf) {\n        return arr.indexOf(needle) !== -1;\n      } else {\n        for (var i = 0, length = arr.length; i < length; i++) {\n          if (arr[i] === needle) {\n            return true;\n          }\n        }\n        return false;\n      }\n    },\n\n    /**\n     * Substract one array from another\n     *\n     * @example\n     *    wysihtml5.lang.array([1, 2, 3, 4]).without([3, 4]);\n     *    // => [1, 2]\n     */\n    without: function without(arrayToSubstract) {\n      arrayToSubstract = wysihtml5.lang.array(arrayToSubstract);\n      var newArr = [],\n          i = 0,\n          length = arr.length;\n      for (; i < length; i++) {\n        if (!arrayToSubstract.contains(arr[i])) {\n          newArr.push(arr[i]);\n        }\n      }\n      return newArr;\n    },\n\n    /**\n     * Return a clean native array\n     * \n     * Following will convert a Live NodeList to a proper Array\n     * @example\n     *    var childNodes = wysihtml5.lang.array(document.body.childNodes).get();\n     */\n    get: function get() {\n      var i = 0,\n          length = arr.length,\n          newArray = [];\n      for (; i < length; i++) {\n        newArray.push(arr[i]);\n      }\n      return newArray;\n    }\n  };\n};wysihtml5.lang.Dispatcher = Base.extend(\n/** @scope wysihtml5.lang.Dialog.prototype */{\n  observe: function observe(eventName, handler) {\n    this.events = this.events || {};\n    this.events[eventName] = this.events[eventName] || [];\n    this.events[eventName].push(handler);\n    return this;\n  },\n\n  on: function on() {\n    return this.observe.apply(this, wysihtml5.lang.array(arguments).get());\n  },\n\n  fire: function fire(eventName, payload) {\n    this.events = this.events || {};\n    var handlers = this.events[eventName] || [],\n        i = 0;\n    for (; i < handlers.length; i++) {\n      handlers[i].call(this, payload);\n    }\n    return this;\n  },\n\n  stopObserving: function stopObserving(eventName, handler) {\n    this.events = this.events || {};\n    var i = 0,\n        handlers,\n        newHandlers;\n    if (eventName) {\n      handlers = this.events[eventName] || [], newHandlers = [];\n      for (; i < handlers.length; i++) {\n        if (handlers[i] !== handler && handler) {\n          newHandlers.push(handlers[i]);\n        }\n      }\n      this.events[eventName] = newHandlers;\n    } else {\n      // Clean up all events\n      this.events = {};\n    }\n    return this;\n  }\n});wysihtml5.lang.object = function (obj) {\n  return {\n    /**\n     * @example\n     *    wysihtml5.lang.object({ foo: 1, bar: 1 }).merge({ bar: 2, baz: 3 }).get();\n     *    // => { foo: 1, bar: 2, baz: 3 }\n     */\n    merge: function merge(otherObj) {\n      for (var i in otherObj) {\n        obj[i] = otherObj[i];\n      }\n      return this;\n    },\n\n    get: function get() {\n      return obj;\n    },\n\n    /**\n     * @example\n     *    wysihtml5.lang.object({ foo: 1 }).clone();\n     *    // => { foo: 1 }\n     */\n    clone: function clone() {\n      var newObj = {},\n          i;\n      for (i in obj) {\n        newObj[i] = obj[i];\n      }\n      return newObj;\n    },\n\n    /**\n     * @example\n     *    wysihtml5.lang.object([]).isArray();\n     *    // => true\n     */\n    isArray: function isArray() {\n      return Object.prototype.toString.call(obj) === "[object Array]";\n    }\n  };\n};(function () {\n  var WHITE_SPACE_START = /^\\s+/,\n      WHITE_SPACE_END = /\\s+$/;\n  wysihtml5.lang.string = function (str) {\n    str = String(str);\n    return {\n      /**\n       * @example\n       *    wysihtml5.lang.string("   foo   ").trim();\n       *    // => "foo"\n       */\n      trim: function trim() {\n        return str.replace(WHITE_SPACE_START, "").replace(WHITE_SPACE_END, "");\n      },\n\n      /**\n       * @example\n       *    wysihtml5.lang.string("Hello #{name}").interpolate({ name: "Christopher" });\n       *    // => "Hello Christopher"\n       */\n      interpolate: function interpolate(vars) {\n        for (var i in vars) {\n          str = this.replace("#{" + i + "}").by(vars[i]);\n        }\n        return str;\n      },\n\n      /**\n       * @example\n       *    wysihtml5.lang.string("Hello Tom").replace("Tom").with("Hans");\n       *    // => "Hello Hans"\n       */\n      replace: function replace(search) {\n        return {\n          by: function by(replace) {\n            return str.split(search).join(replace);\n          }\n        };\n      }\n    };\n  };\n})(); /**\n      * Find urls in descendant text nodes of an element and auto-links them\n      * Inspired by http://james.padolsey.com/javascript/find-and-replace-text-with-javascript/\n      *\n      * @param {Element} element Container element in which to search for urls\n      *\n      * @example\n      *    <div id="text-container">Please click here: www.google.com</div>\n      *    <script>wysihtml5.dom.autoLink(document.getElementById("text-container"));<\/script>\n      */\n(function (wysihtml5) {\n  var /**\n       * Don\'t auto-link urls that are contained in the following elements:\n       */\n  IGNORE_URLS_IN = wysihtml5.lang.array(["CODE", "PRE", "A", "SCRIPT", "HEAD", "TITLE", "STYLE"]),\n\n\n  /**\n   * revision 1:\n   *    /(\\S+\\.{1}[^\\s\\,\\.\\!]+)/g\n   *\n   * revision 2:\n   *    /(\\b(((https?|ftp):\\/\\/)|(www\\.))[-A-Z0-9+&@#\\/%?=~_|!:,.;\\[\\]]*[-A-Z0-9+&@#\\/%=~_|])/gim\n   *\n   * put this in the beginning if you don\'t wan\'t to match within a word\n   *    (^|[\\>\\(\\{\\[\\s\\>])\n   */\n  URL_REG_EXP = /((https?:\\/\\/|www\\.)[^\\s<]{3,})/gi,\n      TRAILING_CHAR_REG_EXP = /([^\\w\\/\\-](,?))$/i,\n      MAX_DISPLAY_LENGTH = 100,\n      BRACKETS = { ")": "(", "]": "[", "}": "{" };\n\n  function autoLink(element) {\n    if (_hasParentThatShouldBeIgnored(element)) {\n      return element;\n    }\n\n    if (element === element.ownerDocument.documentElement) {\n      element = element.ownerDocument.body;\n    }\n\n    return _parseNode(element);\n  }\n\n  /**\n   * This is basically a rebuild of\n   * the rails auto_link_urls text helper\n   */\n  function _convertUrlsToLinks(str) {\n    return str.replace(URL_REG_EXP, function (match, url) {\n      var punctuation = (url.match(TRAILING_CHAR_REG_EXP) || [])[1] || "",\n          opening = BRACKETS[punctuation];\n      url = url.replace(TRAILING_CHAR_REG_EXP, "");\n\n      if (url.split(opening).length > url.split(punctuation).length) {\n        url = url + punctuation;\n        punctuation = "";\n      }\n      var realUrl = url,\n          displayUrl = url;\n      if (url.length > MAX_DISPLAY_LENGTH) {\n        displayUrl = displayUrl.substr(0, MAX_DISPLAY_LENGTH) + "...";\n      }\n      // Add http prefix if necessary\n      if (realUrl.substr(0, 4) === "www.") {\n        realUrl = "http://" + realUrl;\n      }\n\n      return \'<a href="\' + realUrl + \'">\' + realUrl + \'</a>\' + punctuation;\n    });\n  }\n\n  /**\n   * Creates or (if already cached) returns a temp element\n   * for the given document object\n   */\n  function _getTempElement(context) {\n    var tempElement = context._wysihtml5_tempElement;\n    if (!tempElement) {\n      tempElement = context._wysihtml5_tempElement = context.createElement("div");\n    }\n    return tempElement;\n  }\n\n  /**\n   * Replaces the original text nodes with the newly auto-linked dom tree\n   */\n  function _wrapMatchesInNode(textNode) {\n    var parentNode = textNode.parentNode,\n        tempElement = _getTempElement(parentNode.ownerDocument);\n\n    // We need to insert an empty/temporary <span /> to fix IE quirks\n    // Elsewise IE would strip white space in the beginning\n    tempElement.innerHTML = "<span></span>" + _convertUrlsToLinks(textNode.data);\n    tempElement.removeChild(tempElement.firstChild);\n\n    while (tempElement.firstChild) {\n      // inserts tempElement.firstChild before textNode\n      parentNode.insertBefore(tempElement.firstChild, textNode);\n    }\n    parentNode.removeChild(textNode);\n  }\n\n  function _hasParentThatShouldBeIgnored(node) {\n    var nodeName;\n    while (node.parentNode) {\n      node = node.parentNode;\n      nodeName = node.nodeName;\n      if (IGNORE_URLS_IN.contains(nodeName)) {\n        return true;\n      } else if (nodeName === "body") {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  function _parseNode(element) {\n    if (IGNORE_URLS_IN.contains(element.nodeName)) {\n      return;\n    }\n\n    if (element.nodeType === wysihtml5.TEXT_NODE && element.data.match(URL_REG_EXP)) {\n      _wrapMatchesInNode(element);\n      return;\n    }\n\n    var childNodes = wysihtml5.lang.array(element.childNodes).get(),\n        childNodesLength = childNodes.length,\n        i = 0;\n\n    for (; i < childNodesLength; i++) {\n      _parseNode(childNodes[i]);\n    }\n\n    return element;\n  }\n\n  wysihtml5.dom.autoLink = autoLink;\n\n  // Reveal url reg exp to the outside\n  wysihtml5.dom.autoLink.URL_REG_EXP = URL_REG_EXP;\n})(wysihtml5);(function (wysihtml5) {\n  var supportsClassList = wysihtml5.browser.supportsClassList(),\n      api = wysihtml5.dom;\n\n  api.addClass = function (element, className) {\n    if (supportsClassList) {\n      return element.classList.add(className);\n    }\n    if (api.hasClass(element, className)) {\n      return;\n    }\n    element.className += " " + className;\n  };\n\n  api.removeClass = function (element, className) {\n    if (supportsClassList) {\n      return element.classList.remove(className);\n    }\n\n    element.className = element.className.replace(new RegExp("(^|\\\\s+)" + className + "(\\\\s+|$)"), " ");\n  };\n\n  api.hasClass = function (element, className) {\n    if (supportsClassList) {\n      return element.classList.contains(className);\n    }\n\n    var elementClassName = element.className;\n    return elementClassName.length > 0 && (elementClassName == className || new RegExp("(^|\\\\s)" + className + "(\\\\s|$)").test(elementClassName));\n  };\n})(wysihtml5);\nwysihtml5.dom.contains = function () {\n  var documentElement = document.documentElement;\n  if (documentElement.contains) {\n    return function (container, element) {\n      if (element.nodeType !== wysihtml5.ELEMENT_NODE) {\n        element = element.parentNode;\n      }\n      return container !== element && container.contains(element);\n    };\n  } else if (documentElement.compareDocumentPosition) {\n    return function (container, element) {\n      // https://developer.mozilla.org/en/DOM/Node.compareDocumentPosition\n      return !!(container.compareDocumentPosition(element) & 16);\n    };\n  }\n}(); /**\n     * Converts an HTML fragment/element into a unordered/ordered list\n     *\n     * @param {Element} element The element which should be turned into a list\n     * @param {String} listType The list type in which to convert the tree (either "ul" or "ol")\n     * @return {Element} The created list\n     *\n     * @example\n     *    \x3c!-- Assume the following dom: --\x3e\n     *    <span id="pseudo-list">\n     *      eminem<br>\n     *      dr. dre\n     *      <div>50 Cent</div>\n     *    </span>\n     *\n     *    <script>\n     *      wysihtml5.dom.convertToList(document.getElementById("pseudo-list"), "ul");\n     *    <\/script>\n     *\n     *    \x3c!-- Will result in: --\x3e\n     *    <ul>\n     *      <li>eminem</li>\n     *      <li>dr. dre</li>\n     *      <li>50 Cent</li>\n     *    </ul>\n     */\nwysihtml5.dom.convertToList = function () {\n  function _createListItem(doc, list) {\n    var listItem = doc.createElement("li");\n    list.appendChild(listItem);\n    return listItem;\n  }\n\n  function _createList(doc, type) {\n    return doc.createElement(type);\n  }\n\n  function convertToList(element, listType) {\n    if (element.nodeName === "UL" || element.nodeName === "OL" || element.nodeName === "MENU") {\n      // Already a list\n      return element;\n    }\n\n    var doc = element.ownerDocument,\n        list = _createList(doc, listType),\n        lineBreaks = element.querySelectorAll("br"),\n        lineBreaksLength = lineBreaks.length,\n        childNodes,\n        childNodesLength,\n        childNode,\n        lineBreak,\n        parentNode,\n        isBlockElement,\n        isLineBreak,\n        currentListItem,\n        i;\n\n    // First find <br> at the end of inline elements and move them behind them\n    for (i = 0; i < lineBreaksLength; i++) {\n      lineBreak = lineBreaks[i];\n      while ((parentNode = lineBreak.parentNode) && parentNode !== element && parentNode.lastChild === lineBreak) {\n        if (wysihtml5.dom.getStyle("display").from(parentNode) === "block") {\n          parentNode.removeChild(lineBreak);\n          break;\n        }\n        wysihtml5.dom.insert(lineBreak).after(lineBreak.parentNode);\n      }\n    }\n\n    childNodes = wysihtml5.lang.array(element.childNodes).get();\n    childNodesLength = childNodes.length;\n\n    for (i = 0; i < childNodesLength; i++) {\n      currentListItem = currentListItem || _createListItem(doc, list);\n      childNode = childNodes[i];\n      isBlockElement = wysihtml5.dom.getStyle("display").from(childNode) === "block";\n      isLineBreak = childNode.nodeName === "BR";\n\n      if (isBlockElement) {\n        // Append blockElement to current <li> if empty, otherwise create a new one\n        currentListItem = currentListItem.firstChild ? _createListItem(doc, list) : currentListItem;\n        currentListItem.appendChild(childNode);\n        currentListItem = null;\n        continue;\n      }\n\n      if (isLineBreak) {\n        // Only create a new list item in the next iteration when the current one has already content\n        currentListItem = currentListItem.firstChild ? null : currentListItem;\n        continue;\n      }\n\n      currentListItem.appendChild(childNode);\n    }\n\n    element.parentNode.replaceChild(list, element);\n    return list;\n  }\n\n  return convertToList;\n}(); /**\n     * Copy a set of attributes from one element to another\n     *\n     * @param {Array} attributesToCopy List of attributes which should be copied\n     * @return {Object} Returns an object which offers the "from" method which can be invoked with the element where to\n     *    copy the attributes from., this again returns an object which provides a method named "to" which can be invoked \n     *    with the element where to copy the attributes to (see example)\n     *\n     * @example\n     *    var textarea    = document.querySelector("textarea"),\n     *        div         = document.querySelector("div[contenteditable=true]"),\n     *        anotherDiv  = document.querySelector("div.preview");\n     *    wysihtml5.dom.copyAttributes(["spellcheck", "value", "placeholder"]).from(textarea).to(div).andTo(anotherDiv);\n     *\n     */\nwysihtml5.dom.copyAttributes = function (attributesToCopy) {\n  return {\n    from: function from(elementToCopyFrom) {\n      return {\n        to: function to(elementToCopyTo) {\n          var attribute,\n              i = 0,\n              length = attributesToCopy.length;\n          for (; i < length; i++) {\n            attribute = attributesToCopy[i];\n            if (typeof elementToCopyFrom[attribute] !== "undefined" && elementToCopyFrom[attribute] !== "") {\n              elementToCopyTo[attribute] = elementToCopyFrom[attribute];\n            }\n          }\n          return { andTo: arguments.callee };\n        }\n      };\n    }\n  };\n}; /**\n   * Copy a set of styles from one element to another\n   * Please note that this only works properly across browsers when the element from which to copy the styles\n   * is in the dom\n   *\n   * Interesting article on how to copy styles\n   *\n   * @param {Array} stylesToCopy List of styles which should be copied\n   * @return {Object} Returns an object which offers the "from" method which can be invoked with the element where to\n   *    copy the styles from., this again returns an object which provides a method named "to" which can be invoked \n   *    with the element where to copy the styles to (see example)\n   *\n   * @example\n   *    var textarea    = document.querySelector("textarea"),\n   *        div         = document.querySelector("div[contenteditable=true]"),\n   *        anotherDiv  = document.querySelector("div.preview");\n   *    wysihtml5.dom.copyStyles(["overflow-y", "width", "height"]).from(textarea).to(div).andTo(anotherDiv);\n   *\n   */\n(function (dom) {\n\n  /**\n   * Mozilla, WebKit and Opera recalculate the computed width when box-sizing: boder-box; is set\n   * So if an element has "width: 200px; -moz-box-sizing: border-box; border: 1px;" then \n   * its computed css width will be 198px\n   */\n  var BOX_SIZING_PROPERTIES = ["-webkit-box-sizing", "-moz-box-sizing", "-ms-box-sizing", "box-sizing"];\n\n  var shouldIgnoreBoxSizingBorderBox = function shouldIgnoreBoxSizingBorderBox(element) {\n    if (hasBoxSizingBorderBox(element)) {\n      return parseInt(dom.getStyle("width").from(element), 10) < element.offsetWidth;\n    }\n    return false;\n  };\n\n  var hasBoxSizingBorderBox = function hasBoxSizingBorderBox(element) {\n    var i = 0,\n        length = BOX_SIZING_PROPERTIES.length;\n    for (; i < length; i++) {\n      if (dom.getStyle(BOX_SIZING_PROPERTIES[i]).from(element) === "border-box") {\n        return BOX_SIZING_PROPERTIES[i];\n      }\n    }\n  };\n\n  dom.copyStyles = function (stylesToCopy) {\n    return {\n      from: function from(element) {\n        if (shouldIgnoreBoxSizingBorderBox(element)) {\n          stylesToCopy = wysihtml5.lang.array(stylesToCopy).without(BOX_SIZING_PROPERTIES);\n        }\n\n        var cssText = "",\n            length = stylesToCopy.length,\n            i = 0,\n            property;\n        for (; i < length; i++) {\n          property = stylesToCopy[i];\n          cssText += property + ":" + dom.getStyle(property).from(element) + ";";\n        }\n\n        return {\n          to: function to(element) {\n            var height_r = /\\;height\\:/;\n            if (cssText.match(height_r) && element) {\n              list = cssText.split(height_r);\n              height = parseInt(list[1], 10);\n              if (element.offsetHeight > height) {\n                cssText = list[0] + \'height:\' + element.offsetHeight + \'px;\';\n              }\n            }\n            dom.setStyles(cssText).on(element);\n            return { andTo: arguments.callee };\n          }\n        };\n      }\n    };\n  };\n})(wysihtml5.dom); /**\n                   * Event Delegation\n                   *\n                   * @example\n                   *    wysihtml5.dom.delegate(document.body, "a", "click", function() {\n                   *      // foo\n                   *    });\n                   */\n(function (wysihtml5) {\n\n  wysihtml5.dom.delegate = function (container, selector, eventName, handler) {\n    return wysihtml5.dom.observe(container, eventName, function (event) {\n      var target = event.target,\n          match = wysihtml5.lang.array(container.querySelectorAll(selector));\n\n      while (target && target !== container) {\n        if (match.contains(target)) {\n          handler.call(target, event);\n          break;\n        }\n        target = target.parentNode;\n      }\n    });\n  };\n})(wysihtml5); /**\n               * Returns the given html wrapped in a div element\n               *\n               * Fixing IE\'s inability to treat unknown elements (HTML5 section, article, ...) correctly\n               * when inserted via innerHTML\n               * \n               * @param {String} html The html which should be wrapped in a dom element\n               * @param {Obejct} [context] Document object of the context the html belongs to\n               *\n               * @example\n               *    wysihtml5.dom.getAsDom("<article>foo</article>");\n               */\nwysihtml5.dom.getAsDom = function () {\n\n  var _innerHTMLShiv = function _innerHTMLShiv(html, context) {\n    var tempElement = context.createElement("div");\n    tempElement.style.display = "none";\n    context.body.appendChild(tempElement);\n    // IE throws an exception when trying to insert <frameset></frameset> via innerHTML\n    try {\n      tempElement.innerHTML = html;\n    } catch (e) {}\n    context.body.removeChild(tempElement);\n    return tempElement;\n  };\n\n  /**\n   * Make sure IE supports HTML5 tags, which is accomplished by simply creating one instance of each element\n   */\n  var _ensureHTML5Compatibility = function _ensureHTML5Compatibility(context) {\n    if (context._wysihtml5_supportsHTML5Tags) {\n      return;\n    }\n    for (var i = 0, length = HTML5_ELEMENTS.length; i < length; i++) {\n      context.createElement(HTML5_ELEMENTS[i]);\n    }\n    context._wysihtml5_supportsHTML5Tags = true;\n  };\n\n  /**\n   * List of html5 tags\n   * taken from http://simon.html5.org/html5-elements\n   */\n  var HTML5_ELEMENTS = ["abbr", "article", "aside", "audio", "bdi", "canvas", "command", "datalist", "details", "figcaption", "figure", "footer", "header", "hgroup", "keygen", "mark", "meter", "nav", "output", "progress", "rp", "rt", "ruby", "svg", "section", "source", "summary", "time", "track", "video", "wbr"];\n\n  return function (html, context) {\n    context = context || document;\n    var tempElement;\n    if ((typeof html === "undefined" ? "undefined" : _typeof(html)) === "object" && html.nodeType) {\n      tempElement = context.createElement("div");\n      tempElement.appendChild(html);\n    } else if (wysihtml5.browser.supportsHTML5Tags(context)) {\n      tempElement = context.createElement("div");\n      tempElement.innerHTML = html;\n    } else {\n      _ensureHTML5Compatibility(context);\n      tempElement = _innerHTMLShiv(html, context);\n    }\n    return tempElement;\n  };\n}(); /**\n     * Walks the dom tree from the given node up until it finds a match\n     * Designed for optimal performance.\n     *\n     * @param {Element} node The from which to check the parent nodes\n     * @param {Object} matchingSet Object to match against (possible properties: nodeName, className, classRegExp)\n     * @param {Number} [levels] How many parents should the function check up from the current node (defaults to 50)\n     * @return {null|Element} Returns the first element that matched the desiredNodeName(s)\n     * @example\n     *    var listElement = wysihtml5.dom.getParentElement(document.querySelector("li"), { nodeName: ["MENU", "UL", "OL"] });\n     *    // ... or ...\n     *    var unorderedListElement = wysihtml5.dom.getParentElement(document.querySelector("li"), { nodeName: "UL" });\n     *    // ... or ...\n     *    var coloredElement = wysihtml5.dom.getParentElement(myTextNode, { nodeName: "SPAN", className: "wysiwyg-color-red", classRegExp: /wysiwyg-color-[a-z]/g });\n     */\nwysihtml5.dom.getParentElement = function () {\n\n  function _isSameNodeName(nodeName, desiredNodeNames) {\n    if (!desiredNodeNames || !desiredNodeNames.length) {\n      return true;\n    }\n\n    if (typeof desiredNodeNames === "string") {\n      return nodeName === desiredNodeNames;\n    } else {\n      return wysihtml5.lang.array(desiredNodeNames).contains(nodeName);\n    }\n  }\n\n  function _isElement(node) {\n    return node.nodeType === wysihtml5.ELEMENT_NODE;\n  }\n\n  function _hasClassName(element, className, classRegExp) {\n    var classNames = (element.className || "").match(classRegExp) || [];\n    if (!className) {\n      return !!classNames.length;\n    }\n    return classNames[classNames.length - 1] === className;\n  }\n\n  function _getParentElementWithNodeName(node, nodeName, levels) {\n    while (levels-- && node && node.nodeName !== "BODY") {\n      if (_isSameNodeName(node.nodeName, nodeName)) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n    return null;\n  }\n\n  function _getParentElementWithNodeNameAndClassName(node, nodeName, className, classRegExp, levels) {\n    while (levels-- && node && node.nodeName !== "BODY") {\n      if (_isElement(node) && _isSameNodeName(node.nodeName, nodeName) && _hasClassName(node, className, classRegExp)) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n    return null;\n  }\n\n  return function (node, matchingSet, levels) {\n    levels = levels || 50; // Go max 50 nodes upwards from current node\n    if (matchingSet.className || matchingSet.classRegExp) {\n      return _getParentElementWithNodeNameAndClassName(node, matchingSet.nodeName, matchingSet.className, matchingSet.classRegExp, levels);\n    } else {\n      return _getParentElementWithNodeName(node, matchingSet.nodeName, levels);\n    }\n  };\n}();\n/**\n * Get element\'s style for a specific css property\n *\n * @param {Element} element The element on which to retrieve the style\n * @param {String} property The CSS property to retrieve ("float", "display", "text-align", ...)\n *\n * @example\n *    wysihtml5.dom.getStyle("display").from(document.body);\n *    // => "block"\n */\nwysihtml5.dom.getStyle = function () {\n  var stylePropertyMapping = {\n    "float": "styleFloat" in document.createElement("div").style ? "styleFloat" : "cssFloat"\n  },\n      REG_EXP_CAMELIZE = /\\-[a-z]/g;\n\n  function camelize(str) {\n    return str.replace(REG_EXP_CAMELIZE, function (match) {\n      return match.charAt(1).toUpperCase();\n    });\n  }\n\n  return function (property) {\n    return {\n      from: function from(element) {\n        if (element.nodeType !== wysihtml5.ELEMENT_NODE) {\n          return;\n        }\n\n        var doc = element.ownerDocument,\n            camelizedProperty = stylePropertyMapping[property] || camelize(property),\n            style = element.style,\n            currentStyle = element.currentStyle,\n            styleValue = style[camelizedProperty];\n        if (styleValue) {\n          return styleValue;\n        }\n\n        // currentStyle is no standard and only supported by Opera and IE but it has one important advantage over the standard-compliant\n        // window.getComputedStyle, since it returns css property values in their original unit:\n        // If you set an elements width to "50%", window.getComputedStyle will give you it\'s current width in px while currentStyle\n        // gives you the original "50%".\n        // Opera supports both, currentStyle and window.getComputedStyle, that\'s why checking for currentStyle should have higher prio\n        if (currentStyle) {\n          try {\n            return currentStyle[camelizedProperty];\n          } catch (e) {\n            //ie will occasionally fail for unknown reasons. swallowing exception\n          }\n        }\n\n        var win = doc.defaultView || doc.parentWindow,\n            needsOverflowReset = (property === "height" || property === "width") && element.nodeName === "TEXTAREA",\n            originalOverflow,\n            returnValue;\n\n        if (win.getComputedStyle) {\n          // Chrome and Safari both calculate a wrong width and height for textareas when they have scroll bars\n          // therfore we remove and restore the scrollbar and calculate the value in between\n          if (needsOverflowReset) {\n            originalOverflow = style.overflow;\n            style.overflow = "hidden";\n          }\n          returnValue = win.getComputedStyle(element, null).getPropertyValue(property);\n          if (needsOverflowReset) {\n            style.overflow = originalOverflow || "";\n          }\n          return returnValue;\n        }\n      }\n    };\n  };\n}(); /**\n     * High performant way to check whether an element with a specific tag name is in the given document\n     * Optimized for being heavily executed\n     * Unleashes the power of live node lists\n     *\n     * @param {Object} doc The document object of the context where to check\n     * @param {String} tagName Upper cased tag name\n     * @example\n     *    wysihtml5.dom.hasElementWithTagName(document, "IMG");\n     */\nwysihtml5.dom.hasElementWithTagName = function () {\n  var LIVE_CACHE = {},\n      DOCUMENT_IDENTIFIER = 1;\n\n  function _getDocumentIdentifier(doc) {\n    return doc._wysihtml5_identifier || (doc._wysihtml5_identifier = DOCUMENT_IDENTIFIER++);\n  }\n\n  return function (doc, tagName) {\n    var key = _getDocumentIdentifier(doc) + ":" + tagName,\n        cacheEntry = LIVE_CACHE[key];\n    if (!cacheEntry) {\n      cacheEntry = LIVE_CACHE[key] = doc.getElementsByTagName(tagName);\n    }\n\n    return cacheEntry.length > 0;\n  };\n}(); /**\n     * High performant way to check whether an element with a specific class name is in the given document\n     * Optimized for being heavily executed\n     * Unleashes the power of live node lists\n     *\n     * @param {Object} doc The document object of the context where to check\n     * @param {String} tagName Upper cased tag name\n     * @example\n     *    wysihtml5.dom.hasElementWithClassName(document, "foobar");\n     */\n(function (wysihtml5) {\n  var LIVE_CACHE = {},\n      DOCUMENT_IDENTIFIER = 1;\n\n  function _getDocumentIdentifier(doc) {\n    return doc._wysihtml5_identifier || (doc._wysihtml5_identifier = DOCUMENT_IDENTIFIER++);\n  }\n\n  wysihtml5.dom.hasElementWithClassName = function (doc, className) {\n    // getElementsByClassName is not supported by IE<9\n    // but is sometimes mocked via library code (which then doesn\'t return live node lists)\n    if (!wysihtml5.browser.supportsNativeGetElementsByClassName()) {\n      return !!doc.querySelector("." + className);\n    }\n\n    var key = _getDocumentIdentifier(doc) + ":" + className,\n        cacheEntry = LIVE_CACHE[key];\n    if (!cacheEntry) {\n      cacheEntry = LIVE_CACHE[key] = doc.getElementsByClassName(className);\n    }\n\n    return cacheEntry.length > 0;\n  };\n})(wysihtml5);\nwysihtml5.dom.insert = function (elementToInsert) {\n  return {\n    after: function after(element) {\n      element.parentNode.insertBefore(elementToInsert, element.nextSibling);\n    },\n\n    before: function before(element) {\n      element.parentNode.insertBefore(elementToInsert, element);\n    },\n\n    into: function into(element) {\n      element.appendChild(elementToInsert);\n    }\n  };\n};wysihtml5.dom.insertCSS = function (rules) {\n  rules = rules.join("\\n");\n\n  return {\n    into: function into(doc) {\n      var head = doc.head || doc.getElementsByTagName("head")[0],\n          styleElement = doc.createElement("style");\n\n      styleElement.type = "text/css";\n\n      if (styleElement.styleSheet) {\n        styleElement.styleSheet.cssText = rules;\n      } else {\n        styleElement.appendChild(doc.createTextNode(rules));\n      }\n\n      if (head) {\n        head.appendChild(styleElement);\n      }\n    }\n  };\n}; /**\n   * Method to set dom events\n   *\n   * @example\n   *    wysihtml5.dom.observe(iframe.contentWindow.document.body, ["focus", "blur"], function() { ... });\n   */\nwysihtml5.dom.observe = function (element, eventNames, handler) {\n  eventNames = typeof eventNames === "string" ? [eventNames] : eventNames;\n\n  var handlerWrapper,\n      eventName,\n      i = 0,\n      length = eventNames.length;\n\n  for (; i < length; i++) {\n    eventName = eventNames[i];\n    if (element.addEventListener) {\n      element.addEventListener(eventName, handler, false);\n    } else {\n      handlerWrapper = function handlerWrapper(event) {\n        if (!("target" in event)) {\n          event.target = event.srcElement;\n        }\n        event.preventDefault = event.preventDefault || function () {\n          this.returnValue = false;\n        };\n        event.stopPropagation = event.stopPropagation || function () {\n          this.cancelBubble = true;\n        };\n        handler.call(element, event);\n      };\n      element.attachEvent("on" + eventName, handlerWrapper);\n    }\n  }\n\n  return {\n    stop: function stop() {\n      var eventName,\n          i = 0,\n          length = eventNames.length;\n      for (; i < length; i++) {\n        eventName = eventNames[i];\n        if (element.removeEventListener) {\n          element.removeEventListener(eventName, handler, false);\n        } else {\n          element.detachEvent("on" + eventName, handlerWrapper);\n        }\n      }\n    }\n  };\n};\n/**\n * HTML Sanitizer\n * Rewrites the HTML based on given rules\n *\n * @param {Element|String} elementOrHtml HTML String to be sanitized OR element whose content should be sanitized\n * @param {Object} [rules] List of rules for rewriting the HTML, if there\'s no rule for an element it will\n *    be converted to a "span". Each rule is a key/value pair where key is the tag to convert, and value the\n *    desired substitution.\n * @param {Object} context Document object in which to parse the html, needed to sandbox the parsing\n *\n * @return {Element|String} Depends on the elementOrHtml parameter. When html then the sanitized html as string elsewise the element.\n *\n * @example\n *    var userHTML = \'<div id="foo" onclick="alert(1);"><p><font color="red">foo</font><script>alert(1);<\/script></p></div>\';\n *    wysihtml5.dom.parse(userHTML, {\n *      tags {\n *        p:      "div",      // Rename p tags to div tags\n *        font:   "span"      // Rename font tags to span tags\n *        div:    true,       // Keep them, also possible (same result when passing: "div" or true)\n *        script: undefined   // Remove script elements\n *      }\n *    });\n *    // => <div><div><span>foo bar</span></div></div>\n *\n *    var userHTML = \'<table><tbody><tr><td>I\'m a table!</td></tr></tbody></table>\';\n *    wysihtml5.dom.parse(userHTML);\n *    // => \'<span><span><span><span>I\'m a table!</span></span></span></span>\'\n *\n *    var userHTML = \'<div>foobar<br>foobar</div>\';\n *    wysihtml5.dom.parse(userHTML, {\n *      tags: {\n *        div: undefined,\n *        br:  true\n *      }\n *    });\n *    // => \'\'\n *\n *    var userHTML = \'<div class="red">foo</div><div class="pink">bar</div>\';\n *    wysihtml5.dom.parse(userHTML, {\n *      classes: {\n *        red:    1,\n *        green:  1\n *      },\n *      tags: {\n *        div: {\n *          rename_tag:     "p"\n *        }\n *      }\n *    });\n *    // => \'<p class="red">foo</p><p>bar</p>\'\n */\nwysihtml5.dom.parse = function () {\n\n  /**\n   * It\'s not possible to use a XMLParser/DOMParser as HTML5 is not always well-formed XML\n   * new DOMParser().parseFromString(\'<img src="foo.gif">\') will cause a parseError since the\n   * node isn\'t closed\n   *\n   * Therefore we\'ve to use the browser\'s ordinary HTML parser invoked by setting innerHTML.\n   */\n  var NODE_TYPE_MAPPING = {\n    "1": _handleElement,\n    "3": _handleText\n  },\n\n\n  // Rename unknown tags to this\n  DEFAULT_NODE_NAME = "span",\n      WHITE_SPACE_REG_EXP = /\\s+/,\n      defaultRules = { tags: {}, classes: {} },\n      currentRules = {};\n\n  /**\n   * Iterates over all childs of the element, recreates them, appends them into a document fragment\n   * which later replaces the entire body content\n   */\n  function parse(elementOrHtml, rules, context, cleanUp) {\n    wysihtml5.lang.object(currentRules).merge(defaultRules).merge(rules).get();\n\n    context = context || elementOrHtml.ownerDocument || document;\n    var fragment = context.createDocumentFragment(),\n        isString = typeof elementOrHtml === "string",\n        element,\n        newNode,\n        firstChild;\n\n    if (isString) {\n      element = wysihtml5.dom.getAsDom(elementOrHtml, context);\n    } else {\n      element = elementOrHtml;\n    }\n\n    while (element.firstChild) {\n      firstChild = element.firstChild;\n      element.removeChild(firstChild);\n      newNode = _convert(firstChild, cleanUp);\n      if (newNode) {\n        fragment.appendChild(newNode);\n      }\n    }\n\n    // Clear element contents\n    element.innerHTML = "";\n\n    // Insert new DOM tree\n    element.appendChild(fragment);\n\n    return isString ? wysihtml5.quirks.getCorrectInnerHTML(element) : element;\n  }\n\n  function _convert(oldNode, cleanUp) {\n    var oldNodeType = oldNode.nodeType,\n        oldChilds = oldNode.childNodes,\n        oldChildsLength = oldChilds.length,\n        newNode,\n        method = NODE_TYPE_MAPPING[oldNodeType],\n        i = 0;\n\n    newNode = method && method(oldNode);\n\n    if (!newNode) {\n      return null;\n    }\n\n    for (i = 0; i < oldChildsLength; i++) {\n      newChild = _convert(oldChilds[i], cleanUp);\n      if (newChild) {\n        newNode.appendChild(newChild);\n      }\n    }\n\n    // Cleanup senseless <span> elements\n    if (cleanUp && newNode.childNodes.length <= 1 && newNode.nodeName.toLowerCase() === DEFAULT_NODE_NAME && !newNode.attributes.length) {\n      return newNode.firstChild;\n    }\n\n    return newNode;\n  }\n\n  function _handleElement(oldNode) {\n    var rule,\n        newNode,\n        endTag,\n        tagRules = currentRules.tags,\n        nodeName = oldNode.nodeName.toLowerCase(),\n        scopeName = oldNode.scopeName;\n\n    /**\n     * We already parsed that element\n     * ignore it! (yes, this sometimes happens in IE8 when the html is invalid)\n     */\n    if (oldNode._wysihtml5) {\n      return null;\n    }\n    oldNode._wysihtml5 = 1;\n\n    if (oldNode.className === "wysihtml5-temp") {\n      return null;\n    }\n\n    /**\n     * IE is the only browser who doesn\'t include the namespace in the\n     * nodeName, that\'s why we have to prepend it by ourselves\n     * scopeName is a proprietary IE feature\n     * read more here http://msdn.microsoft.com/en-us/library/ms534388(v=vs.85).aspx\n     */\n    if (scopeName && scopeName != "HTML") {\n      nodeName = scopeName + ":" + nodeName;\n    }\n\n    /**\n     * Repair node\n     * IE is a bit bitchy when it comes to invalid nested markup which includes unclosed tags\n     * A <p> doesn\'t need to be closed according HTML4-5 spec, we simply replace it with a <div> to preserve its content and layout\n     */\n    if ("outerHTML" in oldNode) {\n      if (!wysihtml5.browser.autoClosesUnclosedTags() && oldNode.nodeName === "P" && oldNode.outerHTML.slice(-4).toLowerCase() !== "</p>") {\n        nodeName = "div";\n      }\n    }\n\n    if (nodeName in tagRules) {\n      rule = tagRules[nodeName];\n      if (!rule || rule.remove) {\n        return null;\n      }\n\n      rule = typeof rule === "string" ? { rename_tag: rule } : rule;\n    } else if (oldNode.firstChild) {\n      rule = { rename_tag: DEFAULT_NODE_NAME };\n    } else {\n      // Remove empty unknown elements\n      return null;\n    }\n\n    newNode = oldNode.ownerDocument.createElement(rule.rename_tag || nodeName);\n    _handleAttributes(oldNode, newNode, rule);\n\n    oldNode = null;\n    return newNode;\n  }\n\n  function _handleAttributes(oldNode, newNode, rule) {\n    var attributes = {},\n\n    // fresh new set of attributes to set on newNode\n    setClass = rule.set_class,\n\n    // classes to set\n    addClass = rule.add_class,\n\n    // add classes based on existing attributes\n    setAttributes = rule.set_attributes,\n\n    // attributes to set on the current node\n    checkAttributes = rule.check_attributes,\n\n    // check/convert values of attributes\n    allowedClasses = currentRules.classes,\n        i = 0,\n        classes = [],\n        newClasses = [],\n        newUniqueClasses = [],\n        oldClasses = [],\n        classesLength,\n        newClassesLength,\n        currentClass,\n        newClass,\n        attributeName,\n        newAttributeValue,\n        method;\n\n    if (setAttributes) {\n      attributes = wysihtml5.lang.object(setAttributes).clone();\n    }\n\n    if (checkAttributes) {\n      for (attributeName in checkAttributes) {\n        method = attributeCheckMethods[checkAttributes[attributeName]];\n        if (!method) {\n          continue;\n        }\n        newAttributeValue = method(_getAttribute(oldNode, attributeName));\n        if (typeof newAttributeValue === "string") {\n          attributes[attributeName] = newAttributeValue;\n        }\n      }\n    }\n\n    if (setClass) {\n      classes.push(setClass);\n    }\n\n    if (addClass) {\n      for (attributeName in addClass) {\n        method = addClassMethods[addClass[attributeName]];\n        if (!method) {\n          continue;\n        }\n        newClass = method(_getAttribute(oldNode, attributeName));\n        if (typeof newClass === "string") {\n          classes.push(newClass);\n        }\n      }\n    }\n\n    // make sure that wysihtml5 temp class doesn\'t get stripped out\n    allowedClasses["_wysihtml5-temp-placeholder"] = 1;\n\n    // add old classes last\n    oldClasses = oldNode.getAttribute("class");\n    if (oldClasses) {\n      classes = classes.concat(oldClasses.split(WHITE_SPACE_REG_EXP));\n    }\n    classesLength = classes.length;\n    for (; i < classesLength; i++) {\n      currentClass = classes[i];\n      if (allowedClasses[currentClass]) {\n        newClasses.push(currentClass);\n      }\n    }\n\n    // remove duplicate entries and preserve class specificity\n    newClassesLength = newClasses.length;\n    while (newClassesLength--) {\n      currentClass = newClasses[newClassesLength];\n      if (!wysihtml5.lang.array(newUniqueClasses).contains(currentClass)) {\n        newUniqueClasses.unshift(currentClass);\n      }\n    }\n\n    if (newUniqueClasses.length) {\n      attributes["class"] = newUniqueClasses.join(" ");\n    }\n\n    // set attributes on newNode\n    for (attributeName in attributes) {\n      // Setting attributes can cause a js error in IE under certain circumstances\n      // eg. on a <img> under https when it\'s new attribute value is non-https\n      // TODO: Investigate this further and check for smarter handling\n      try {\n        newNode.setAttribute(attributeName, attributes[attributeName]);\n      } catch (e) {}\n    }\n\n    // IE8 sometimes loses the width/height attributes when those are set before the "src"\n    // so we make sure to set them again\n    if (attributes.src) {\n      if (typeof attributes.width !== "undefined") {\n        newNode.setAttribute("width", attributes.width);\n      }\n      if (typeof attributes.height !== "undefined") {\n        newNode.setAttribute("height", attributes.height);\n      }\n    }\n  }\n\n  /**\n   * IE gives wrong results for hasAttribute/getAttribute, for example:\n   *    var td = document.createElement("td");\n   *    td.getAttribute("rowspan"); // => "1" in IE\n   *\n   * Therefore we have to check the element\'s outerHTML for the attribute\n   */\n  var HAS_GET_ATTRIBUTE_BUG = !wysihtml5.browser.supportsGetAttributeCorrectly();\n  function _getAttribute(node, attributeName) {\n    attributeName = attributeName.toLowerCase();\n    var nodeName = node.nodeName;\n    if (nodeName == "IMG" && attributeName == "src" && _isLoadedImage(node) === true) {\n      // Get \'src\' attribute value via object property since this will always contain the\n      // full absolute url (http://...)\n      // this fixes a very annoying bug in firefox (ver 3.6 & 4) and IE 8 where images copied from the same host\n      // will have relative paths, which the sanitizer strips out (see attributeCheckMethods.url)\n      return node.src;\n    } else if (HAS_GET_ATTRIBUTE_BUG && "outerHTML" in node) {\n      // Don\'t trust getAttribute/hasAttribute in IE 6-8, instead check the element\'s outerHTML\n      var outerHTML = node.outerHTML.toLowerCase(),\n\n\n      // TODO: This might not work for attributes without value: <input disabled>\n      hasAttribute = outerHTML.indexOf(" " + attributeName + "=") != -1;\n\n      return hasAttribute ? node.getAttribute(attributeName) : null;\n    } else {\n      return node.getAttribute(attributeName);\n    }\n  }\n\n  /**\n   * Check whether the given node is a proper loaded image\n   * FIXME: Returns undefined when unknown (Chrome, Safari)\n   */\n  function _isLoadedImage(node) {\n    try {\n      return node.complete && !node.mozMatchesSelector(":-moz-broken");\n    } catch (e) {\n      if (node.complete && node.readyState === "complete") {\n        return true;\n      }\n    }\n  }\n\n  function _handleText(oldNode) {\n    return oldNode.ownerDocument.createTextNode(oldNode.data);\n  }\n\n  // ------------ attribute checks ------------ \\\\\n  var attributeCheckMethods = {\n    url: function () {\n      var REG_EXP = /^https?:\\/\\//i;\n      return function (attributeValue) {\n        if (!attributeValue || !attributeValue.match(REG_EXP)) {\n          return null;\n        }\n        return attributeValue.replace(REG_EXP, function (match) {\n          return match.toLowerCase();\n        });\n      };\n    }(),\n\n    alt: function () {\n      var REG_EXP = /[^ a-z0-9_\\-]/gi;\n      return function (attributeValue) {\n        if (!attributeValue) {\n          return "";\n        }\n        return attributeValue.replace(REG_EXP, "");\n      };\n    }(),\n\n    numbers: function () {\n      var REG_EXP = /\\D/g;\n      return function (attributeValue) {\n        attributeValue = (attributeValue || "").replace(REG_EXP, "");\n        return attributeValue || null;\n      };\n    }()\n  };\n\n  // ------------ class converter (converts an html attribute to a class name) ------------ \\\\\n  var addClassMethods = {\n    align_img: function () {\n      var mapping = {\n        left: "wysiwyg-float-left",\n        right: "wysiwyg-float-right"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).toLowerCase()];\n      };\n    }(),\n\n    align_text: function () {\n      var mapping = {\n        left: "wysiwyg-text-align-left",\n        right: "wysiwyg-text-align-right",\n        center: "wysiwyg-text-align-center",\n        justify: "wysiwyg-text-align-justify"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).toLowerCase()];\n      };\n    }(),\n\n    clear_br: function () {\n      var mapping = {\n        left: "wysiwyg-clear-left",\n        right: "wysiwyg-clear-right",\n        both: "wysiwyg-clear-both",\n        all: "wysiwyg-clear-both"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).toLowerCase()];\n      };\n    }(),\n\n    size_font: function () {\n      var mapping = {\n        "1": "wysiwyg-font-size-xx-small",\n        "2": "wysiwyg-font-size-small",\n        "3": "wysiwyg-font-size-medium",\n        "4": "wysiwyg-font-size-large",\n        "5": "wysiwyg-font-size-x-large",\n        "6": "wysiwyg-font-size-xx-large",\n        "7": "wysiwyg-font-size-xx-large",\n        "-": "wysiwyg-font-size-smaller",\n        "+": "wysiwyg-font-size-larger"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).charAt(0)];\n      };\n    }()\n  };\n\n  return parse;\n}(); /**\n     * Checks for empty text node childs and removes them\n     *\n     * @param {Element} node The element in which to cleanup\n     * @example\n     *    wysihtml5.dom.removeEmptyTextNodes(element);\n     */\nwysihtml5.dom.removeEmptyTextNodes = function (node) {\n  var childNode,\n      childNodes = wysihtml5.lang.array(node.childNodes).get(),\n      childNodesLength = childNodes.length,\n      i = 0;\n  for (; i < childNodesLength; i++) {\n    childNode = childNodes[i];\n    if (childNode.nodeType === wysihtml5.TEXT_NODE && childNode.data === "") {\n      childNode.parentNode.removeChild(childNode);\n    }\n  }\n};\n/**\n * Renames an element (eg. a <div> to a <p>) and keeps its childs\n *\n * @param {Element} element The list element which should be renamed\n * @param {Element} newNodeName The desired tag name\n *\n * @example\n *    \x3c!-- Assume the following dom: --\x3e\n *    <ul id="list">\n *      <li>eminem</li>\n *      <li>dr. dre</li>\n *      <li>50 Cent</li>\n *    </ul>\n *\n *    <script>\n *      wysihtml5.dom.renameElement(document.getElementById("list"), "ol");\n *    <\/script>\n *\n *    \x3c!-- Will result in: --\x3e\n *    <ol>\n *      <li>eminem</li>\n *      <li>dr. dre</li>\n *      <li>50 Cent</li>\n *    </ol>\n */\nwysihtml5.dom.renameElement = function (element, newNodeName) {\n  var newElement = element.ownerDocument.createElement(newNodeName),\n      firstChild;\n  while (firstChild = element.firstChild) {\n    newElement.appendChild(firstChild);\n  }\n  wysihtml5.dom.copyAttributes(["align", "className"]).from(element).to(newElement);\n  element.parentNode.replaceChild(newElement, element);\n  return newElement;\n}; /**\n   * Takes an element, removes it and replaces it with it\'s childs\n   * \n   * @param {Object} node The node which to replace with it\'s child nodes\n   * @example\n   *    <div id="foo">\n   *      <span>hello</span>\n   *    </div>\n   *    <script>\n   *      // Remove #foo and replace with it\'s children\n   *      wysihtml5.dom.replaceWithChildNodes(document.getElementById("foo"));\n   *    <\/script>\n   */\nwysihtml5.dom.replaceWithChildNodes = function (node) {\n  if (!node.parentNode) {\n    return;\n  }\n\n  if (!node.firstChild) {\n    node.parentNode.removeChild(node);\n    return;\n  }\n\n  var fragment = node.ownerDocument.createDocumentFragment();\n  while (node.firstChild) {\n    fragment.appendChild(node.firstChild);\n  }\n  node.parentNode.replaceChild(fragment, node);\n  node = fragment = null;\n};\n/**\n * Unwraps an unordered/ordered list\n *\n * @param {Element} element The list element which should be unwrapped\n *\n * @example\n *    \x3c!-- Assume the following dom: --\x3e\n *    <ul id="list">\n *      <li>eminem</li>\n *      <li>dr. dre</li>\n *      <li>50 Cent</li>\n *    </ul>\n *\n *    <script>\n *      wysihtml5.dom.resolveList(document.getElementById("list"));\n *    <\/script>\n *\n *    \x3c!-- Will result in: --\x3e\n *    eminem<br>\n *    dr. dre<br>\n *    50 Cent<br>\n */\n(function (dom) {\n  function _isBlockElement(node) {\n    return dom.getStyle("display").from(node) === "block";\n  }\n\n  function _isLineBreak(node) {\n    return node.nodeName === "BR";\n  }\n\n  function _appendLineBreak(element) {\n    var lineBreak = element.ownerDocument.createElement("br");\n    element.appendChild(lineBreak);\n  }\n\n  function resolveList(list) {\n    if (list.nodeName !== "MENU" && list.nodeName !== "UL" && list.nodeName !== "OL") {\n      return;\n    }\n\n    var doc = list.ownerDocument,\n        fragment = doc.createDocumentFragment(),\n        previousSibling = list.previousElementSibling || list.previousSibling,\n        firstChild,\n        lastChild,\n        isLastChild,\n        shouldAppendLineBreak,\n        listItem;\n\n    if (previousSibling && !_isBlockElement(previousSibling)) {\n      _appendLineBreak(fragment);\n    }\n\n    while (listItem = list.firstChild) {\n      lastChild = listItem.lastChild;\n      while (firstChild = listItem.firstChild) {\n        isLastChild = firstChild === lastChild;\n        // This needs to be done before appending it to the fragment, as it otherwise will loose style information\n        shouldAppendLineBreak = isLastChild && !_isBlockElement(firstChild) && !_isLineBreak(firstChild);\n        fragment.appendChild(firstChild);\n        if (shouldAppendLineBreak) {\n          _appendLineBreak(fragment);\n        }\n      }\n\n      listItem.parentNode.removeChild(listItem);\n    }\n    list.parentNode.replaceChild(fragment, list);\n  }\n\n  dom.resolveList = resolveList;\n})(wysihtml5.dom); /**\n                   * Sandbox for executing javascript, parsing css styles and doing dom operations in a secure way\n                   *\n                   * Browser Compatibility:\n                   *  - Secure in MSIE 6+, but only when the user hasn\'t made changes to his security level "restricted"\n                   *  - Partially secure in other browsers (Firefox, Opera, Safari, Chrome, ...)\n                   *\n                   * Please note that this class can\'t benefit from the HTML5 sandbox attribute for the following reasons:\n                   *    - sandboxing doesn\'t work correctly with inlined content (src="javascript:\'<html>...</html>\'")\n                   *    - sandboxing of physical documents causes that the dom isn\'t accessible anymore from the outside (iframe.contentWindow, ...)\n                   *    - setting the "allow-same-origin" flag would fix that, but then still javascript and dom events refuse to fire\n                   *    - therefore the "allow-scripts" flag is needed, which then would deactivate any security, as the js executed inside the iframe\n                   *      can do anything as if the sandbox attribute wasn\'t set\n                   *\n                   * @param {Function} [readyCallback] Method that gets invoked when the sandbox is ready\n                   * @param {Object} [config] Optional parameters\n                   *\n                   * @example\n                   *    new wysihtml5.dom.Sandbox(function(sandbox) {\n                   *      sandbox.getWindow().document.body.innerHTML = \'<img src=foo.gif onerror="alert(document.cookie)">\';\n                   *    });\n                   */\n(function (wysihtml5) {\n  var /**\n       * Default configuration\n       */\n  doc = document,\n\n\n  /**\n   * Properties to unset/protect on the window object\n   */\n  windowProperties = ["parent", "top", "opener", "frameElement", "frames", "localStorage", "globalStorage", "sessionStorage", "indexedDB"],\n\n\n  /**\n   * Properties on the window object which are set to an empty function\n   */\n  windowProperties2 = ["open", "close", "openDialog", "showModalDialog", "alert", "confirm", "prompt", "openDatabase", "postMessage", "XMLHttpRequest", "XDomainRequest"],\n\n\n  /**\n   * Properties to unset/protect on the document object\n   */\n  documentProperties = ["referrer", "write", "open", "close"];\n\n  wysihtml5.dom.Sandbox = Base.extend(\n  /** @scope wysihtml5.dom.Sandbox.prototype */{\n\n    constructor: function constructor(readyCallback, config) {\n      this.callback = readyCallback || wysihtml5.EMPTY_FUNCTION;\n      this.config = wysihtml5.lang.object({}).merge(config).get();\n      this.iframe = this._createIframe();\n    },\n\n    insertInto: function insertInto(element) {\n      if (typeof element === "string") {\n        element = doc.getElementById(element);\n      }\n\n      element.appendChild(this.iframe);\n    },\n\n    getIframe: function getIframe() {\n      return this.iframe;\n    },\n\n    getWindow: function getWindow() {\n      this._readyError();\n    },\n\n    getDocument: function getDocument() {\n      this._readyError();\n    },\n\n    destroy: function destroy() {\n      var iframe = this.getIframe();\n      iframe.parentNode.removeChild(iframe);\n    },\n\n    _readyError: function _readyError() {\n      throw new Error("wysihtml5.Sandbox: Sandbox iframe isn\'t loaded yet");\n    },\n\n    /**\n     * Creates the sandbox iframe\n     *\n     * Some important notes:\n     *  - We can\'t use HTML5 sandbox for now:\n     *    setting it causes that the iframe\'s dom can\'t be accessed from the outside\n     *    Therefore we need to set the "allow-same-origin" flag which enables accessing the iframe\'s dom\n     *    But then there\'s another problem, DOM events (focus, blur, change, keypress, ...) aren\'t fired.\n     *    In order to make this happen we need to set the "allow-scripts" flag.\n     *    A combination of allow-scripts and allow-same-origin is almost the same as setting no sandbox attribute at all.\n     *  - Chrome & Safari, doesn\'t seem to support sandboxing correctly when the iframe\'s html is inlined (no physical document)\n     *  - IE needs to have the security="restricted" attribute set before the iframe is \n     *    inserted into the dom tree\n     *  - Believe it or not but in IE "security" in document.createElement("iframe") is false, even\n     *    though it supports it\n     *  - When an iframe has security="restricted", in IE eval() & execScript() don\'t work anymore\n     *  - IE doesn\'t fire the onload event when the content is inlined in the src attribute, therefore we rely\n     *    on the onreadystatechange event\n     */\n    _createIframe: function _createIframe() {\n      var that = this,\n          iframe = doc.createElement("iframe");\n      iframe.className = "wysihtml5-sandbox";\n      wysihtml5.dom.setAttributes({\n        "security": "restricted",\n        "allowtransparency": "true",\n        "frameborder": 0,\n        "width": 0,\n        "height": 0,\n        "marginwidth": 0,\n        "marginheight": 0\n      }).on(iframe);\n\n      // Setting the src like this prevents ssl warnings in IE6\n      if (wysihtml5.browser.throwsMixedContentWarningWhenIframeSrcIsEmpty()) {\n        iframe.src = "javascript:\'<html></html>\'";\n      }\n\n      iframe.onload = function () {\n        iframe.onreadystatechange = iframe.onload = null;\n        that._onLoadIframe(iframe);\n      };\n\n      iframe.onreadystatechange = function () {\n        if (/loaded|complete/.test(iframe.readyState)) {\n          iframe.onreadystatechange = iframe.onload = null;\n          that._onLoadIframe(iframe);\n        }\n      };\n\n      return iframe;\n    },\n\n    /**\n     * Callback for when the iframe has finished loading\n     */\n    _onLoadIframe: function _onLoadIframe(iframe) {\n      // don\'t resume when the iframe got unloaded (eg. by removing it from the dom)\n      if (!wysihtml5.dom.contains(doc.documentElement, iframe)) {\n        return;\n      }\n\n      var that = this,\n          iframeWindow = iframe.contentWindow,\n          iframeDocument = iframe.contentWindow.document,\n          charset = doc.characterSet || doc.charset || "utf-8",\n          sandboxHtml = this._getHtml({\n        charset: charset,\n        stylesheets: this.config.stylesheets\n      });\n\n      // Create the basic dom tree including proper DOCTYPE and charset\n      iframeDocument.open("text/html", "replace");\n      iframeDocument.write(sandboxHtml);\n      iframeDocument.close();\n\n      this.getWindow = function () {\n        return iframe.contentWindow;\n      };\n      this.getDocument = function () {\n        return iframe.contentWindow.document;\n      };\n\n      // Catch js errors and pass them to the parent\'s onerror event\n      // addEventListener("error") doesn\'t work properly in some browsers\n      // TODO: apparently this doesn\'t work in IE9!\n      iframeWindow.onerror = function (errorMessage, fileName, lineNumber) {\n        throw new Error("wysihtml5.Sandbox: " + errorMessage, fileName, lineNumber);\n      };\n\n      if (!wysihtml5.browser.supportsSandboxedIframes()) {\n        // Unset a bunch of sensitive variables\n        // Please note: This isn\'t hack safe!  \n        // It more or less just takes care of basic attacks and prevents accidental theft of sensitive information\n        // IE is secure though, which is the most important thing, since IE is the only browser, who\n        // takes over scripts & styles into contentEditable elements when copied from external websites\n        // or applications (Microsoft Word, ...)\n        var i, length;\n        for (i = 0, length = windowProperties.length; i < length; i++) {\n          this._unset(iframeWindow, windowProperties[i]);\n        }\n        for (i = 0, length = windowProperties2.length; i < length; i++) {\n          this._unset(iframeWindow, windowProperties2[i], wysihtml5.EMPTY_FUNCTION);\n        }\n        for (i = 0, length = documentProperties.length; i < length; i++) {\n          this._unset(iframeDocument, documentProperties[i]);\n        }\n        // This doesn\'t work in Safari 5 \n        // See http://stackoverflow.com/questions/992461/is-it-possible-to-override-document-cookie-in-webkit\n        this._unset(iframeDocument, "cookie", "", true);\n      }\n\n      this.loaded = true;\n\n      // Trigger the callback\n      setTimeout(function () {\n        that.callback(that);\n      }, 0);\n    },\n\n    _getHtml: function _getHtml(templateVars) {\n      var stylesheets = templateVars.stylesheets,\n          html = "",\n          i = 0,\n          length;\n      stylesheets = typeof stylesheets === "string" ? [stylesheets] : stylesheets;\n      if (stylesheets) {\n        length = stylesheets.length;\n        for (; i < length; i++) {\n          html += \'<link rel="stylesheet" href="\' + stylesheets[i] + \'">\';\n        }\n      }\n      templateVars.stylesheets = html;\n\n      return wysihtml5.lang.string(\'<!DOCTYPE html><html><head>\' + \'<meta charset="#{charset}">#{stylesheets}</head>\' + \'<body></body></html>\').interpolate(templateVars);\n    },\n\n    /**\n     * Method to unset/override existing variables\n     * @example\n     *    // Make cookie unreadable and unwritable\n     *    this._unset(document, "cookie", "", true);\n     */\n    _unset: function _unset(object, property, value, setter) {\n      try {\n        object[property] = value;\n      } catch (e) {}\n\n      try {\n        object.__defineGetter__(property, function () {\n          return value;\n        });\n      } catch (e) {}\n      if (setter) {\n        try {\n          object.__defineSetter__(property, function () {});\n        } catch (e) {}\n      }\n\n      if (!wysihtml5.browser.crashesWhenDefineProperty(property)) {\n        try {\n          var config = {\n            get: function get() {\n              return value;\n            }\n          };\n          if (setter) {\n            config.set = function () {};\n          }\n          Object.defineProperty(object, property, config);\n        } catch (e) {}\n      }\n    }\n  });\n})(wysihtml5);\n(function () {\n  var mapping = {\n    "className": "class"\n  };\n  wysihtml5.dom.setAttributes = function (attributes) {\n    return {\n      on: function on(element) {\n        for (var i in attributes) {\n          element.setAttribute(mapping[i] || i, attributes[i]);\n        }\n      }\n    };\n  };\n})();wysihtml5.dom.setStyles = function (styles) {\n  return {\n    on: function on(element) {\n      var style = element.style;\n      if (typeof styles === "string") {\n        style.cssText += ";" + styles;\n        return;\n      }\n      for (var i in styles) {\n        if (i === "float") {\n          style.cssFloat = styles[i];\n          style.styleFloat = styles[i];\n        } else {\n          style[i] = styles[i];\n        }\n      }\n    }\n  };\n}; /**\n   * Simulate HTML5 placeholder attribute\n   *\n   * Needed since\n   *    - div[contentEditable] elements don\'t support it\n   *    - older browsers (such as IE8 and Firefox 3.6) don\'t support it at all\n   *\n   * @param {Object} parent Instance of main wysihtml5.Editor class\n   * @param {Element} view Instance of wysihtml5.views.* class\n   * @param {String} placeholderText\n   *\n   * @example\n   *    wysihtml.dom.simulatePlaceholder(this, composer, "Foobar");\n   */\n(function (dom) {\n  dom.simulatePlaceholder = function (editor, view, placeholderText) {\n    var CLASS_NAME = "placeholder",\n        unset = function unset() {\n      if (view.hasPlaceholderSet()) {\n        view.clear();\n      }\n      dom.removeClass(view.element, CLASS_NAME);\n    },\n        set = function set() {\n      if (view.isEmpty()) {\n        view.setValue(placeholderText);\n        dom.addClass(view.element, CLASS_NAME);\n      }\n    };\n\n    editor.observe("set_placeholder", set).observe("unset_placeholder", unset).observe("focus:composer", unset).observe("paste:composer", unset).observe("blur:composer", set);\n\n    set();\n  };\n})(wysihtml5.dom);\n(function (dom) {\n  var documentElement = document.documentElement;\n  if ("textContent" in documentElement) {\n    dom.setTextContent = function (element, text) {\n      element.textContent = text;\n    };\n\n    dom.getTextContent = function (element) {\n      return element.textContent;\n    };\n  } else if ("innerText" in documentElement) {\n    dom.setTextContent = function (element, text) {\n      element.innerText = text;\n    };\n\n    dom.getTextContent = function (element) {\n      return element.innerText;\n    };\n  } else {\n    dom.setTextContent = function (element, text) {\n      element.nodeValue = text;\n    };\n\n    dom.getTextContent = function (element) {\n      return element.nodeValue;\n    };\n  }\n})(wysihtml5.dom);\n\n/**\n * Fix most common html formatting misbehaviors of browsers implementation when inserting\n * content via copy & paste contentEditable\n *\n * @author Christopher Blum\n */\nwysihtml5.quirks.cleanPastedHTML = function () {\n  // TODO: We probably need more rules here\n  var defaultRules = {\n    // When pasting underlined links <a> into a contentEditable, IE thinks, it has to insert <u> to keep the styling\n    "a u": wysihtml5.dom.replaceWithChildNodes\n  };\n\n  function cleanPastedHTML(elementOrHtml, rules, context) {\n    rules = rules || defaultRules;\n    context = context || elementOrHtml.ownerDocument || document;\n\n    var element,\n        isString = typeof elementOrHtml === "string",\n        method,\n        matches,\n        matchesLength,\n        i,\n        j = 0;\n    if (isString) {\n      element = wysihtml5.dom.getAsDom(elementOrHtml, context);\n    } else {\n      element = elementOrHtml;\n    }\n    if (element.querySelectorAll) {\n      element.innerHTML = element.innerHTML.replace(/\\n/g, \'</br>\');\n      var els = element.querySelectorAll(\'style\');\n      for (var i = 0; i < els.length; i++) {\n        var el = els[i];\n        el.parentElement.removeChild(el);\n      }\n      var divs = element.querySelectorAll(\'div\');\n      for (var i = 0; i < divs.length; i++) {\n        var div = divs[i];\n        var new_div = document.createElement(\'p\');\n        new_div.innerText = div.innerText;\n        div.replaceWith(new_div);\n      }\n      var p_els = element.querySelectorAll(\'p\');\n      for (var i = 0; i < p_els.length; i++) {\n        var el = p_els[i];\n        if (!$.trim(el.innerText).length) {\n          el.parentElement.removeChild(el);\n        }\n      }\n      var br_els = element.querySelectorAll(\'br\');\n      var i = 0;\n      while (i < br_els.length - 1) {\n        var br = br_els[i];\n        while (br.nextSibling == br_els[i + 1]) {\n          var el = br_els[i + 1];\n          el.parentElement.removeChild(el);\n          i++;\n        }\n        i++;\n      }\n      for (var i = 0; i < br_els.length - 1; i++) {\n        br_els[i];\n      }\n    }\n\n    for (i in rules) {\n      matches = element.querySelectorAll(i);\n      method = rules[i];\n      matchesLength = matches.length;\n      for (; j < matchesLength; j++) {\n        method(matches[j]);\n      }\n    }\n\n    matches = elementOrHtml = rules = null;\n\n    return isString ? element.innerHTML : element;\n  }\n\n  return cleanPastedHTML;\n}(); /**\n     * IE and Opera leave an empty paragraph in the contentEditable element after clearing it\n     *\n     * @param {Object} contentEditableElement The contentEditable element to observe for clearing events\n     * @exaple\n     *    wysihtml5.quirks.ensureProperClearing(myContentEditableElement);\n     */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom;\n\n  wysihtml5.quirks.ensureProperClearing = function () {\n    var clearIfNecessary = function clearIfNecessary(event) {\n      var element = this;\n      setTimeout(function () {\n        var innerHTML = element.innerHTML.toLowerCase();\n        if (innerHTML == "<p>&nbsp;</p>" || innerHTML == "<p>&nbsp;</p><p>&nbsp;</p>") {\n          element.innerHTML = "";\n        }\n      }, 0);\n    };\n\n    return function (composer) {\n      dom.observe(composer.element, ["cut", "keydown"], clearIfNecessary);\n    };\n  }();\n\n  /**\n   * In Opera when the caret is in the first and only item of a list (<ul><li>|</li></ul>) and the list is the first child of the contentEditable element, it\'s impossible to delete the list by hitting backspace\n   *\n   * @param {Object} contentEditableElement The contentEditable element to observe for clearing events\n   * @exaple\n   *    wysihtml5.quirks.ensureProperClearing(myContentEditableElement);\n   */\n  wysihtml5.quirks.ensureProperClearingOfLists = function () {\n    var ELEMENTS_THAT_CONTAIN_LI = ["OL", "UL", "MENU"];\n\n    var clearIfNecessary = function clearIfNecessary(element, contentEditableElement) {\n      if (!contentEditableElement.firstChild || !wysihtml5.lang.array(ELEMENTS_THAT_CONTAIN_LI).contains(contentEditableElement.firstChild.nodeName)) {\n        return;\n      }\n\n      var list = dom.getParentElement(element, { nodeName: ELEMENTS_THAT_CONTAIN_LI });\n      if (!list) {\n        return;\n      }\n\n      var listIsFirstChildOfContentEditable = list == contentEditableElement.firstChild;\n      if (!listIsFirstChildOfContentEditable) {\n        return;\n      }\n\n      var hasOnlyOneListItem = list.childNodes.length <= 1;\n      if (!hasOnlyOneListItem) {\n        return;\n      }\n\n      var onlyListItemIsEmpty = list.firstChild ? list.firstChild.innerHTML === "" : true;\n      if (!onlyListItemIsEmpty) {\n        return;\n      }\n\n      list.parentNode.removeChild(list);\n    };\n\n    return function (composer) {\n      dom.observe(composer.element, "keydown", function (event) {\n        if (event.keyCode !== wysihtml5.BACKSPACE_KEY) {\n          return;\n        }\n\n        var element = composer.selection.getSelectedNode();\n        clearIfNecessary(element, composer.element);\n      });\n    };\n  }();\n})(wysihtml5);\n// See https://bugzilla.mozilla.org/show_bug.cgi?id=664398\n//\n// In Firefox this:\n//      var d = document.createElement("div");\n//      d.innerHTML =\'<a href="~"></a>\';\n//      d.innerHTML;\n// will result in:\n//      <a href="%7E"></a>\n// which is wrong\n(function (wysihtml5) {\n  var TILDE_ESCAPED = "%7E";\n  wysihtml5.quirks.getCorrectInnerHTML = function (element) {\n    var innerHTML = element.innerHTML;\n    if (innerHTML.indexOf(TILDE_ESCAPED) === -1) {\n      return innerHTML;\n    }\n\n    var elementsWithTilde = element.querySelectorAll("[href*=\'~\'], [src*=\'~\']"),\n        url,\n        urlToSearch,\n        length,\n        i;\n    for (i = 0, length = elementsWithTilde.length; i < length; i++) {\n      url = elementsWithTilde[i].href || elementsWithTilde[i].src;\n      urlToSearch = wysihtml5.lang.string(url).replace("~").by(TILDE_ESCAPED);\n      innerHTML = wysihtml5.lang.string(innerHTML).replace(urlToSearch).by(url);\n    }\n    return innerHTML;\n  };\n})(wysihtml5); /**\n               * Some browsers don\'t insert line breaks when hitting return in a contentEditable element\n               *    - Opera & IE insert new <p> on return\n               *    - Chrome & Safari insert new <div> on return\n               *    - Firefox inserts <br> on return (yippie!)\n               *\n               * @param {Element} element\n               *\n               * @example\n               *    wysihtml5.quirks.insertLineBreakOnReturn(element);\n               */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      USE_NATIVE_LINE_BREAK_WHEN_CARET_INSIDE_TAGS = ["LI", "P", "H1", "H2", "H3", "H4", "H5", "H6"],\n      LIST_TAGS = ["UL", "OL", "MENU"];\n\n  wysihtml5.quirks.insertLineBreakOnReturn = function (composer) {\n    function unwrap(selectedNode) {\n      var parentElement = dom.getParentElement(selectedNode, { nodeName: ["P", "DIV"] }, 2);\n      if (!parentElement) {\n        return;\n      }\n\n      var invisibleSpace = document.createTextNode(wysihtml5.INVISIBLE_SPACE);\n      dom.insert(invisibleSpace).before(parentElement);\n      dom.replaceWithChildNodes(parentElement);\n      composer.selection.selectNode(invisibleSpace);\n    }\n\n    function keyDown(event) {\n      var keyCode = event.keyCode;\n      if (event.shiftKey || keyCode !== wysihtml5.ENTER_KEY && keyCode !== wysihtml5.BACKSPACE_KEY) {\n        return;\n      }\n\n      var element = event.target,\n          selectedNode = composer.selection.getSelectedNode(),\n          blockElement = dom.getParentElement(selectedNode, { nodeName: USE_NATIVE_LINE_BREAK_WHEN_CARET_INSIDE_TAGS }, 4);\n      if (blockElement) {\n        // Some browsers create <p> elements after leaving a list\n        // check after keydown of backspace and return whether a <p> got inserted and unwrap it\n        if (blockElement.nodeName === "LI" && (keyCode === wysihtml5.ENTER_KEY || keyCode === wysihtml5.BACKSPACE_KEY)) {\n          setTimeout(function () {\n            var selectedNode = composer.selection.getSelectedNode(),\n                list,\n                div;\n            if (!selectedNode) {\n              return;\n            }\n\n            list = dom.getParentElement(selectedNode, {\n              nodeName: LIST_TAGS\n            }, 2);\n\n            if (list) {\n              return;\n            }\n\n            unwrap(selectedNode);\n          }, 0);\n        } else if (blockElement.nodeName.match(/H[1-6]/) && keyCode === wysihtml5.ENTER_KEY) {\n          setTimeout(function () {\n            unwrap(composer.selection.getSelectedNode());\n          }, 0);\n        }\n        return;\n      }\n\n      if (keyCode === wysihtml5.ENTER_KEY && !wysihtml5.browser.insertsLineBreaksOnReturn()) {\n        composer.commands.exec("insertLineBreak");\n        event.preventDefault();\n      }\n    }\n\n    // keypress doesn\'t fire when you hit backspace\n    dom.observe(composer.element.ownerDocument, "keydown", keyDown);\n  };\n})(wysihtml5); /**\n               * Force rerendering of a given element\n               * Needed to fix display misbehaviors of IE\n               *\n               * @param {Element} element The element object which needs to be rerendered\n               * @example\n               *    wysihtml5.quirks.redraw(document.body);\n               */\n(function (wysihtml5) {\n  var CLASS_NAME = "wysihtml5-quirks-redraw";\n\n  wysihtml5.quirks.redraw = function (element) {\n    wysihtml5.dom.addClass(element, CLASS_NAME);\n    wysihtml5.dom.removeClass(element, CLASS_NAME);\n\n    // Following hack is needed for firefox to make sure that image resize handles are properly removed\n    try {\n      var doc = element.ownerDocument;\n      doc.execCommand("italic", false, null);\n      doc.execCommand("italic", false, null);\n    } catch (e) {}\n  };\n})(wysihtml5); /**\n               * Selection API\n               *\n               * @example\n               *    var selection = new wysihtml5.Selection(editor);\n               */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom;\n\n  function _getCumulativeOffsetTop(element) {\n    var top = 0;\n    if (element.parentNode) {\n      do {\n        top += element.offsetTop || 0;\n        element = element.offsetParent;\n      } while (element);\n    }\n    return top;\n  }\n\n  wysihtml5.Selection = Base.extend(\n  /** @scope wysihtml5.Selection.prototype */{\n    constructor: function constructor(editor) {\n      // Make sure that our external range library is initialized\n      window.rangy.init();\n\n      this.editor = editor;\n      this.composer = editor.composer;\n      this.doc = this.composer.doc;\n    },\n\n    /**\n     * Get the current selection as a bookmark to be able to later restore it\n     *\n     * @return {Object} An object that represents the current selection\n     */\n    getBookmark: function getBookmark() {\n      var range = this.getRange();\n      return range && range.cloneRange();\n    },\n\n    /**\n     * Restore a selection retrieved via wysihtml5.Selection.prototype.getBookmark\n     *\n     * @param {Object} bookmark An object that represents the current selection\n     */\n    setBookmark: function setBookmark(bookmark) {\n      if (!bookmark) {\n        return;\n      }\n\n      this.setSelection(bookmark);\n    },\n\n    /**\n     * Set the caret in front of the given node\n     *\n     * @param {Object} node The element or text node where to position the caret in front of\n     * @example\n     *    selection.setBefore(myElement);\n     */\n    setBefore: function setBefore(node) {\n      var range = rangy.createRange(this.doc);\n      range.setStartBefore(node);\n      range.setEndBefore(node);\n      return this.setSelection(range);\n    },\n\n    /**\n     * Set the caret after the given node\n     *\n     * @param {Object} node The element or text node where to position the caret in front of\n     * @example\n     *    selection.setBefore(myElement);\n     */\n    setAfter: function setAfter(node) {\n      var range = rangy.createRange(this.doc);\n      range.setStartAfter(node);\n      range.setEndAfter(node);\n      return this.setSelection(range);\n    },\n\n    /**\n     * Ability to select/mark nodes\n     *\n     * @param {Element} node The node/element to select\n     * @example\n     *    selection.selectNode(document.getElementById("my-image"));\n     */\n    selectNode: function selectNode(node) {\n      var range = rangy.createRange(this.doc),\n          isElement = node.nodeType === wysihtml5.ELEMENT_NODE,\n          canHaveHTML = "canHaveHTML" in node ? node.canHaveHTML : node.nodeName !== "IMG",\n          content = isElement ? node.innerHTML : node.data,\n          isEmpty = content === "" || content === wysihtml5.INVISIBLE_SPACE,\n          displayStyle = dom.getStyle("display").from(node),\n          isBlockElement = displayStyle === "block" || displayStyle === "list-item";\n\n      if (isEmpty && isElement && canHaveHTML) {\n        // Make sure that caret is visible in node by inserting a zero width no breaking space\n        try {\n          node.innerHTML = wysihtml5.INVISIBLE_SPACE;\n        } catch (e) {}\n      }\n\n      if (canHaveHTML) {\n        range.selectNodeContents(node);\n      } else {\n        range.selectNode(node);\n      }\n\n      if (canHaveHTML && isEmpty && isElement) {\n        range.collapse(isBlockElement);\n      } else if (canHaveHTML && isEmpty) {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n\n      this.setSelection(range);\n    },\n\n    /**\n     * Get the node which contains the selection\n     *\n     * @param {Boolean} [controlRange] (only IE) Whether it should return the selected ControlRange element when the selection type is a "ControlRange"\n     * @return {Object} The node that contains the caret\n     * @example\n     *    var nodeThatContainsCaret = selection.getSelectedNode();\n     */\n    getSelectedNode: function getSelectedNode(controlRange) {\n      var selection, range;\n\n      if (controlRange && this.doc.selection && this.doc.selection.type === "Control") {\n        range = this.doc.selection.createRange();\n        if (range && range.length) {\n          return range.item(0);\n        }\n      }\n\n      selection = this.getSelection(this.doc);\n      if (selection.focusNode === selection.anchorNode) {\n        return selection.focusNode;\n      } else {\n        range = this.getRange(this.doc);\n        return range ? range.commonAncestorContainer : this.doc.body;\n      }\n    },\n\n    executeAndRestore: function executeAndRestore(method, restoreScrollPosition) {\n      var body = this.doc.body,\n          oldScrollTop = restoreScrollPosition && body.scrollTop,\n          oldScrollLeft = restoreScrollPosition && body.scrollLeft,\n          className = "_wysihtml5-temp-placeholder",\n          placeholderHTML = \'<span class="\' + className + \'">\' + wysihtml5.INVISIBLE_SPACE + \'</span>\',\n          range = this.getRange(this.doc),\n          newRange;\n\n      // Nothing selected, execute and say goodbye\n      if (!range) {\n        method(body, body);\n        return;\n      }\n\n      var node = range.createContextualFragment(placeholderHTML);\n      range.insertNode(node);\n\n      // Make sure that a potential error doesn\'t cause our placeholder element to be left as a placeholder\n      try {\n        method(range.startContainer, range.endContainer);\n      } catch (e3) {\n        setTimeout(function () {\n          throw e3;\n        }, 0);\n      }\n\n      caretPlaceholder = this.doc.querySelector("." + className);\n      if (caretPlaceholder) {\n        newRange = rangy.createRange(this.doc);\n        newRange.selectNode(caretPlaceholder);\n        newRange.deleteContents();\n        this.setSelection(newRange);\n      } else {\n        // fallback for when all hell breaks loose\n        body.focus();\n      }\n\n      if (restoreScrollPosition) {\n        body.scrollTop = oldScrollTop;\n        body.scrollLeft = oldScrollLeft;\n      }\n\n      // Remove it again, just to make sure that the placeholder is definitely out of the dom tree\n      try {\n        caretPlaceholder.parentNode.removeChild(caretPlaceholder);\n      } catch (e4) {}\n    },\n\n    /**\n     * Different approach of preserving the selection (doesn\'t modify the dom)\n     * Takes all text nodes in the selection and saves the selection position in the first and last one\n     */\n    executeAndRestoreSimple: function executeAndRestoreSimple(method) {\n      var range = this.getRange(),\n          body = this.doc.body,\n          newRange,\n          firstNode,\n          lastNode,\n          textNodes,\n          rangeBackup;\n\n      // Nothing selected, execute and say goodbye\n      if (!range) {\n        method(body, body);\n        return;\n      }\n\n      textNodes = range.getNodes([3]);\n      firstNode = textNodes[0] || range.startContainer;\n      lastNode = textNodes[textNodes.length - 1] || range.endContainer;\n\n      rangeBackup = {\n        collapsed: range.collapsed,\n        startContainer: firstNode,\n        startOffset: firstNode === range.startContainer ? range.startOffset : 0,\n        endContainer: lastNode,\n        endOffset: lastNode === range.endContainer ? range.endOffset : lastNode.length\n      };\n\n      try {\n        method(range.startContainer, range.endContainer);\n      } catch (e) {\n        setTimeout(function () {\n          throw e;\n        }, 0);\n      }\n\n      newRange = rangy.createRange(this.doc);\n      try {\n        newRange.setStart(rangeBackup.startContainer, rangeBackup.startOffset);\n      } catch (e1) {}\n      try {\n        newRange.setEnd(rangeBackup.endContainer, rangeBackup.endOffset);\n      } catch (e2) {}\n      try {\n        this.setSelection(newRange);\n      } catch (e3) {}\n    },\n\n    /**\n     * Insert html at the caret position and move the cursor after the inserted html\n     *\n     * @param {String} html HTML string to insert\n     * @example\n     *    selection.insertHTML("<p>foobar</p>");\n     */\n    insertHTML: function insertHTML(html) {\n      var range = rangy.createRange(this.doc),\n          node = range.createContextualFragment(html),\n          lastChild = node.lastChild;\n      this.insertNode(node);\n      if (lastChild) {\n        this.setAfter(lastChild);\n      }\n    },\n\n    /**\n     * Insert a node at the caret position and move the cursor behind it\n     *\n     * @param {Object} node HTML string to insert\n     * @example\n     *    selection.insertNode(document.createTextNode("foobar"));\n     */\n    insertNode: function insertNode(node) {\n      var range = this.getRange();\n      if (range) {\n        range.insertNode(node);\n      }\n    },\n\n    /**\n     * Wraps current selection with the given node\n     *\n     * @param {Object} node The node to surround the selected elements with\n     */\n    surround: function surround(node) {\n      var range = this.getRange();\n      if (!range) {\n        return;\n      }\n\n      try {\n        // This only works when the range boundaries are not overlapping other elements\n        range.surroundContents(node);\n        this.selectNode(node);\n      } catch (e) {\n        // fallback\n        node.appendChild(range.extractContents());\n        range.insertNode(node);\n      }\n    },\n\n    /**\n     * Scroll the current caret position into the view\n     * FIXME: This is a bit hacky, there might be a smarter way of doing this\n     *\n     * @example\n     *    selection.scrollIntoView();\n     */\n    scrollIntoView: function scrollIntoView() {\n      var doc = this.doc,\n          hasScrollBars = doc.documentElement.scrollHeight > doc.documentElement.offsetHeight,\n          tempElement = doc._wysihtml5ScrollIntoViewElement = doc._wysihtml5ScrollIntoViewElement || function () {\n        var element = doc.createElement("span");\n        // The element needs content in order to be able to calculate it\'s position properly\n        element.innerHTML = wysihtml5.INVISIBLE_SPACE;\n        return element;\n      }(),\n          offsetTop;\n\n      if (hasScrollBars) {\n        this.insertNode(tempElement);\n        offsetTop = _getCumulativeOffsetTop(tempElement);\n        tempElement.parentNode.removeChild(tempElement);\n        if (offsetTop > doc.body.scrollTop) {\n          doc.body.scrollTop = offsetTop;\n        }\n      }\n    },\n\n    /**\n     * Select line where the caret is in\n     */\n    selectLine: function selectLine() {\n      if (wysihtml5.browser.supportsSelectionModify()) {\n        this._selectLine_W3C();\n      } else if (this.doc.selection) {\n        this._selectLine_MSIE();\n      }\n    },\n\n    /**\n     * See https://developer.mozilla.org/en/DOM/Selection/modify\n     */\n    _selectLine_W3C: function _selectLine_W3C() {\n      var win = this.doc.defaultView,\n          selection = win.getSelection();\n      selection.modify("extend", "left", "lineboundary");\n      selection.modify("extend", "right", "lineboundary");\n    },\n\n    _selectLine_MSIE: function _selectLine_MSIE() {\n      var range = this.doc.selection.createRange(),\n          rangeTop = range.boundingTop,\n          rangeHeight = range.boundingHeight,\n          scrollWidth = this.doc.body.scrollWidth,\n          rangeBottom,\n          rangeEnd,\n          measureNode,\n          i,\n          j;\n\n      if (!range.moveToPoint) {\n        return;\n      }\n\n      if (rangeTop === 0) {\n        // Don\'t know why, but when the selection ends at the end of a line\n        // range.boundingTop is 0\n        measureNode = this.doc.createElement("span");\n        this.insertNode(measureNode);\n        rangeTop = measureNode.offsetTop;\n        measureNode.parentNode.removeChild(measureNode);\n      }\n\n      rangeTop += 1;\n\n      for (i = -10; i < scrollWidth; i += 2) {\n        try {\n          range.moveToPoint(i, rangeTop);\n          break;\n        } catch (e1) {}\n      }\n\n      // Investigate the following in order to handle multi line selections\n      // rangeBottom = rangeTop + (rangeHeight ? (rangeHeight - 1) : 0);\n      rangeBottom = rangeTop;\n      rangeEnd = this.doc.selection.createRange();\n      for (j = scrollWidth; j >= 0; j--) {\n        try {\n          rangeEnd.moveToPoint(j, rangeBottom);\n          break;\n        } catch (e2) {}\n      }\n\n      range.setEndPoint("EndToEnd", rangeEnd);\n      range.select();\n    },\n\n    getText: function getText() {\n      var selection = this.getSelection();\n      return selection ? selection.toString() : "";\n    },\n\n    getNodes: function getNodes(nodeType, filter) {\n      var range = this.getRange();\n      if (range) {\n        return range.getNodes([nodeType], filter);\n      } else {\n        return [];\n      }\n    },\n\n    getRange: function getRange() {\n      var selection = this.getSelection();\n      return selection && selection.rangeCount && selection.getRangeAt(0);\n    },\n\n    getSelection: function getSelection() {\n      return rangy.getSelection(this.doc.defaultView || this.doc.parentWindow);\n    },\n\n    setSelection: function setSelection(range) {\n      var win = this.doc.defaultView || this.doc.parentWindow,\n          selection = rangy.getSelection(win);\n      return selection.setSingleRange(range);\n    }\n  });\n})(wysihtml5);\n/**\n * Inspired by the rangy CSS Applier module written by Tim Down and licensed under the MIT license.\n * http://code.google.com/p/rangy/\n *\n * changed in order to be able ...\n *    - to use custom tags\n *    - to detect and replace similar css classes via reg exp\n */\n(function (wysihtml5, rangy) {\n  var defaultTagName = "span";\n\n  var REG_EXP_WHITE_SPACE = /\\s+/g;\n\n  function hasClass(el, cssClass, regExp) {\n    if (!el.className) {\n      return false;\n    }\n\n    var matchingClassNames = el.className.match(regExp) || [];\n    return matchingClassNames[matchingClassNames.length - 1] === cssClass;\n  }\n\n  function addClass(el, cssClass, regExp) {\n    if (el.className) {\n      removeClass(el, regExp);\n      el.className += " " + cssClass;\n    } else {\n      el.className = cssClass;\n    }\n  }\n\n  function removeClass(el, regExp) {\n    if (el.className) {\n      el.className = el.className.replace(regExp, "");\n    }\n  }\n\n  function hasSameClasses(el1, el2) {\n    return el1.className.replace(REG_EXP_WHITE_SPACE, " ") == el2.className.replace(REG_EXP_WHITE_SPACE, " ");\n  }\n\n  function replaceWithOwnChildren(el) {\n    var parent = el.parentNode;\n    while (el.firstChild) {\n      parent.insertBefore(el.firstChild, el);\n    }\n    parent.removeChild(el);\n  }\n\n  function elementsHaveSameNonClassAttributes(el1, el2) {\n    if (el1.attributes.length != el2.attributes.length) {\n      return false;\n    }\n    for (var i = 0, len = el1.attributes.length, attr1, attr2, name; i < len; ++i) {\n      attr1 = el1.attributes[i];\n      name = attr1.name;\n      if (name != "class") {\n        attr2 = el2.attributes.getNamedItem(name);\n        if (attr1.specified != attr2.specified) {\n          return false;\n        }\n        if (attr1.specified && attr1.nodeValue !== attr2.nodeValue) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  function isSplitPoint(node, offset) {\n    if (rangy.dom.isCharacterDataNode(node)) {\n      if (offset == 0) {\n        return !!node.previousSibling;\n      } else if (offset == node.length) {\n        return !!node.nextSibling;\n      } else {\n        return true;\n      }\n    }\n\n    return offset > 0 && offset < node.childNodes.length;\n  }\n\n  function splitNodeAt(node, descendantNode, descendantOffset) {\n    var newNode;\n    if (rangy.dom.isCharacterDataNode(descendantNode)) {\n      if (descendantOffset == 0) {\n        descendantOffset = rangy.dom.getNodeIndex(descendantNode);\n        descendantNode = descendantNode.parentNode;\n      } else if (descendantOffset == descendantNode.length) {\n        descendantOffset = rangy.dom.getNodeIndex(descendantNode) + 1;\n        descendantNode = descendantNode.parentNode;\n      } else {\n        newNode = rangy.dom.splitDataNode(descendantNode, descendantOffset);\n      }\n    }\n    if (!newNode) {\n      newNode = descendantNode.cloneNode(false);\n      if (newNode.id) {\n        newNode.removeAttribute("id");\n      }\n      var child;\n      while (child = descendantNode.childNodes[descendantOffset]) {\n        newNode.appendChild(child);\n      }\n      rangy.dom.insertAfter(newNode, descendantNode);\n    }\n    return descendantNode == node ? newNode : splitNodeAt(node, newNode.parentNode, rangy.dom.getNodeIndex(newNode));\n  }\n\n  function Merge(firstNode) {\n    this.isElementMerge = firstNode.nodeType == wysihtml5.ELEMENT_NODE;\n    this.firstTextNode = this.isElementMerge ? firstNode.lastChild : firstNode;\n    this.textNodes = [this.firstTextNode];\n  }\n\n  Merge.prototype = {\n    doMerge: function doMerge() {\n      var textBits = [],\n          textNode,\n          parent,\n          text;\n      for (var i = 0, len = this.textNodes.length; i < len; ++i) {\n        textNode = this.textNodes[i];\n        parent = textNode.parentNode;\n        textBits[i] = textNode.data;\n        if (i) {\n          parent.removeChild(textNode);\n          if (!parent.hasChildNodes()) {\n            parent.parentNode.removeChild(parent);\n          }\n        }\n      }\n      this.firstTextNode.data = text = textBits.join("");\n      return text;\n    },\n\n    getLength: function getLength() {\n      var i = this.textNodes.length,\n          len = 0;\n      while (i--) {\n        len += this.textNodes[i].length;\n      }\n      return len;\n    },\n\n    toString: function toString() {\n      var textBits = [];\n      for (var i = 0, len = this.textNodes.length; i < len; ++i) {\n        textBits[i] = "\'" + this.textNodes[i].data + "\'";\n      }\n      return "[Merge(" + textBits.join(",") + ")]";\n    }\n  };\n\n  function HTMLApplier(tagNames, cssClass, similarClassRegExp, normalize) {\n    this.tagNames = tagNames || [defaultTagName];\n    this.cssClass = cssClass || "";\n    this.similarClassRegExp = similarClassRegExp;\n    this.normalize = normalize;\n    this.applyToAnyTagName = false;\n  }\n\n  HTMLApplier.prototype = {\n    getAncestorWithClass: function getAncestorWithClass(node) {\n      var cssClassMatch;\n      while (node) {\n        cssClassMatch = this.cssClass ? hasClass(node, this.cssClass, this.similarClassRegExp) : true;\n        if (node.nodeType == wysihtml5.ELEMENT_NODE && rangy.dom.arrayContains(this.tagNames, node.tagName.toLowerCase()) && cssClassMatch) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return false;\n    },\n\n    // Normalizes nodes after applying a CSS class to a Range.\n    postApply: function postApply(textNodes, range) {\n      var firstNode = textNodes[0],\n          lastNode = textNodes[textNodes.length - 1];\n\n      var merges = [],\n          currentMerge;\n\n      var rangeStartNode = firstNode,\n          rangeEndNode = lastNode;\n      var rangeStartOffset = 0,\n          rangeEndOffset = lastNode.length;\n\n      var textNode, precedingTextNode;\n\n      for (var i = 0, len = textNodes.length; i < len; ++i) {\n        textNode = textNodes[i];\n        precedingTextNode = this.getAdjacentMergeableTextNode(textNode.parentNode, false);\n        if (precedingTextNode) {\n          if (!currentMerge) {\n            currentMerge = new Merge(precedingTextNode);\n            merges.push(currentMerge);\n          }\n          currentMerge.textNodes.push(textNode);\n          if (textNode === firstNode) {\n            rangeStartNode = currentMerge.firstTextNode;\n            rangeStartOffset = rangeStartNode.length;\n          }\n          if (textNode === lastNode) {\n            rangeEndNode = currentMerge.firstTextNode;\n            rangeEndOffset = currentMerge.getLength();\n          }\n        } else {\n          currentMerge = null;\n        }\n      }\n\n      // Test whether the first node after the range needs merging\n      var nextTextNode = this.getAdjacentMergeableTextNode(lastNode.parentNode, true);\n      if (nextTextNode) {\n        if (!currentMerge) {\n          currentMerge = new Merge(lastNode);\n          merges.push(currentMerge);\n        }\n        currentMerge.textNodes.push(nextTextNode);\n      }\n\n      // Do the merges\n      if (merges.length) {\n        for (i = 0, len = merges.length; i < len; ++i) {\n          merges[i].doMerge();\n        }\n        // Set the range boundaries\n        range.setStart(rangeStartNode, rangeStartOffset);\n        range.setEnd(rangeEndNode, rangeEndOffset);\n      }\n    },\n\n    getAdjacentMergeableTextNode: function getAdjacentMergeableTextNode(node, forward) {\n      var isTextNode = node.nodeType == wysihtml5.TEXT_NODE;\n      var el = isTextNode ? node.parentNode : node;\n      var adjacentNode;\n      var propName = forward ? "nextSibling" : "previousSibling";\n      if (isTextNode) {\n        // Can merge if the node\'s previous/next sibling is a text node\n        adjacentNode = node[propName];\n        if (adjacentNode && adjacentNode.nodeType == wysihtml5.TEXT_NODE) {\n          return adjacentNode;\n        }\n      } else {\n        // Compare element with its sibling\n        adjacentNode = el[propName];\n        if (adjacentNode && this.areElementsMergeable(node, adjacentNode)) {\n          return adjacentNode[forward ? "firstChild" : "lastChild"];\n        }\n      }\n      return null;\n    },\n\n    areElementsMergeable: function areElementsMergeable(el1, el2) {\n      return rangy.dom.arrayContains(this.tagNames, (el1.tagName || "").toLowerCase()) && rangy.dom.arrayContains(this.tagNames, (el2.tagName || "").toLowerCase()) && hasSameClasses(el1, el2) && elementsHaveSameNonClassAttributes(el1, el2);\n    },\n\n    createContainer: function createContainer(doc) {\n      var el = doc.createElement(this.tagNames[0]);\n      if (this.cssClass) {\n        el.className = this.cssClass;\n      }\n      return el;\n    },\n\n    applyToTextNode: function applyToTextNode(textNode) {\n      var parent = textNode.parentNode;\n      if (parent.childNodes.length == 1 && rangy.dom.arrayContains(this.tagNames, parent.tagName.toLowerCase())) {\n        if (this.cssClass) {\n          addClass(parent, this.cssClass, this.similarClassRegExp);\n        }\n      } else {\n        var el = this.createContainer(rangy.dom.getDocument(textNode));\n        textNode.parentNode.insertBefore(el, textNode);\n        el.appendChild(textNode);\n      }\n    },\n\n    isRemovable: function isRemovable(el) {\n      return rangy.dom.arrayContains(this.tagNames, el.tagName.toLowerCase()) && wysihtml5.lang.string(el.className).trim() == this.cssClass;\n    },\n\n    undoToTextNode: function undoToTextNode(textNode, range, ancestorWithClass) {\n      if (!range.containsNode(ancestorWithClass)) {\n        // Split out the portion of the ancestor from which we can remove the CSS class\n        var ancestorRange = range.cloneRange();\n        ancestorRange.selectNode(ancestorWithClass);\n\n        if (ancestorRange.isPointInRange(range.endContainer, range.endOffset) && isSplitPoint(range.endContainer, range.endOffset)) {\n          splitNodeAt(ancestorWithClass, range.endContainer, range.endOffset);\n          range.setEndAfter(ancestorWithClass);\n        }\n        if (ancestorRange.isPointInRange(range.startContainer, range.startOffset) && isSplitPoint(range.startContainer, range.startOffset)) {\n          ancestorWithClass = splitNodeAt(ancestorWithClass, range.startContainer, range.startOffset);\n        }\n      }\n\n      if (this.similarClassRegExp) {\n        removeClass(ancestorWithClass, this.similarClassRegExp);\n      }\n      if (this.isRemovable(ancestorWithClass)) {\n        replaceWithOwnChildren(ancestorWithClass);\n      }\n    },\n\n    applyToRange: function applyToRange(range) {\n      var textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n      if (!textNodes.length) {\n        try {\n          var node = this.createContainer(range.endContainer.ownerDocument);\n          range.surroundContents(node);\n          this.selectNode(range, node);\n          return;\n        } catch (e) {}\n      }\n\n      range.splitBoundaries();\n      textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n\n      if (textNodes.length) {\n        var textNode;\n\n        for (var i = 0, len = textNodes.length; i < len; ++i) {\n          textNode = textNodes[i];\n          if (!this.getAncestorWithClass(textNode)) {\n            this.applyToTextNode(textNode);\n          }\n        }\n\n        range.setStart(textNodes[0], 0);\n        textNode = textNodes[textNodes.length - 1];\n        range.setEnd(textNode, textNode.length);\n\n        if (this.normalize) {\n          this.postApply(textNodes, range);\n        }\n      }\n    },\n\n    undoToRange: function undoToRange(range) {\n      var textNodes = range.getNodes([wysihtml5.TEXT_NODE]),\n          textNode,\n          ancestorWithClass;\n      if (textNodes.length) {\n        range.splitBoundaries();\n        textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n      } else {\n        var doc = range.endContainer.ownerDocument,\n            node = doc.createTextNode(wysihtml5.INVISIBLE_SPACE);\n        range.insertNode(node);\n        range.selectNode(node);\n        textNodes = [node];\n      }\n\n      for (var i = 0, len = textNodes.length; i < len; ++i) {\n        textNode = textNodes[i];\n        ancestorWithClass = this.getAncestorWithClass(textNode);\n        if (ancestorWithClass) {\n          this.undoToTextNode(textNode, range, ancestorWithClass);\n        }\n      }\n\n      if (len == 1) {\n        this.selectNode(range, textNodes[0]);\n      } else {\n        range.setStart(textNodes[0], 0);\n        textNode = textNodes[textNodes.length - 1];\n        range.setEnd(textNode, textNode.length);\n\n        if (this.normalize) {\n          this.postApply(textNodes, range);\n        }\n      }\n    },\n\n    selectNode: function selectNode(range, node) {\n      var isElement = node.nodeType === wysihtml5.ELEMENT_NODE,\n          canHaveHTML = "canHaveHTML" in node ? node.canHaveHTML : true,\n          content = isElement ? node.innerHTML : node.data,\n          isEmpty = content === "" || content === wysihtml5.INVISIBLE_SPACE;\n\n      if (isEmpty && isElement && canHaveHTML) {\n        // Make sure that caret is visible in node by inserting a zero width no breaking space\n        try {\n          node.innerHTML = wysihtml5.INVISIBLE_SPACE;\n        } catch (e) {}\n      }\n      range.selectNodeContents(node);\n      if (isEmpty && isElement) {\n        range.collapse(false);\n      } else if (isEmpty) {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n    },\n\n    getTextSelectedByRange: function getTextSelectedByRange(textNode, range) {\n      var textRange = range.cloneRange();\n      textRange.selectNodeContents(textNode);\n\n      var intersectionRange = textRange.intersection(range);\n      var text = intersectionRange ? intersectionRange.toString() : "";\n      textRange.detach();\n\n      return text;\n    },\n\n    isAppliedToRange: function isAppliedToRange(range) {\n      var ancestors = [],\n          ancestor,\n          textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n      if (!textNodes.length) {\n        ancestor = this.getAncestorWithClass(range.startContainer);\n        return ancestor ? [ancestor] : false;\n      }\n\n      for (var i = 0, len = textNodes.length, selectedText; i < len; ++i) {\n        selectedText = this.getTextSelectedByRange(textNodes[i], range);\n        ancestor = this.getAncestorWithClass(textNodes[i]);\n        if (selectedText != "" && !ancestor) {\n          return false;\n        } else {\n          ancestors.push(ancestor);\n        }\n      }\n      return ancestors;\n    },\n\n    toggleRange: function toggleRange(range) {\n      if (this.isAppliedToRange(range)) {\n        this.undoToRange(range);\n      } else {\n        this.applyToRange(range);\n      }\n    }\n  };\n\n  wysihtml5.selection.HTMLApplier = HTMLApplier;\n})(wysihtml5, rangy); /**\n                      * Rich Text Query/Formatting Commands\n                      * \n                      * @example\n                      *    var commands = new wysihtml5.Commands(editor);\n                      */\nwysihtml5.Commands = Base.extend(\n/** @scope wysihtml5.Commands.prototype */{\n  constructor: function constructor(editor) {\n    this.editor = editor;\n    this.composer = editor.composer;\n    this.doc = this.composer.doc;\n  },\n\n  /**\n   * Check whether the browser supports the given command\n   *\n   * @param {String} command The command string which to check (eg. "bold", "italic", "insertUnorderedList")\n   * @example\n   *    commands.supports("createLink");\n   */\n  support: function support(command) {\n    return wysihtml5.browser.supportsCommand(this.doc, command);\n  },\n\n  /**\n   * Check whether the browser supports the given command\n   *\n   * @param {String} command The command string which to execute (eg. "bold", "italic", "insertUnorderedList")\n   * @param {String} [value] The command value parameter, needed for some commands ("createLink", "insertImage", ...), optional for commands that don\'t require one ("bold", "underline", ...)\n   * @example\n   *    commands.exec("insertImage", "http://a1.twimg.com/profile_images/113868655/schrei_twitter_reasonably_small.jpg");\n   */\n  exec: function exec(command, value) {\n    var obj = wysihtml5.commands[command],\n        args = wysihtml5.lang.array(arguments).get(),\n        method = obj && obj.exec,\n        result = null;\n\n    this.editor.fire("beforecommand:composer");\n\n    if (method) {\n      args.unshift(this.composer);\n      result = method.apply(obj, args);\n    } else {\n      try {\n        // try/catch for buggy firefox\n        result = this.doc.execCommand(command, false, value);\n      } catch (e) {}\n    }\n\n    this.editor.fire("aftercommand:composer");\n    return result;\n  },\n\n  /**\n   * Check whether the current command is active\n   * If the caret is within a bold text, then calling this with command "bold" should return true\n   *\n   * @param {String} command The command string which to check (eg. "bold", "italic", "insertUnorderedList")\n   * @param {String} [commandValue] The command value parameter (eg. for "insertImage" the image src)\n   * @return {Boolean} Whether the command is active\n   * @example\n   *    var isCurrentSelectionBold = commands.state("bold");\n   */\n  state: function state(command, commandValue) {\n    var obj = wysihtml5.commands[command],\n        args = wysihtml5.lang.array(arguments).get(),\n        method = obj && obj.state;\n    if (method) {\n      args.unshift(this.composer);\n      return method.apply(obj, args);\n    } else {\n      try {\n        // try/catch for buggy firefox\n        return this.doc.queryCommandState(command);\n      } catch (e) {\n        return false;\n      }\n    }\n  },\n\n  /**\n   * Get the current command\'s value\n   *\n   * @param {String} command The command string which to check (eg. "formatBlock")\n   * @return {String} The command value\n   * @example\n   *    var currentBlockElement = commands.value("formatBlock");\n   */\n  value: function value(command) {\n    var obj = wysihtml5.commands[command],\n        method = obj && obj.value;\n    if (method) {\n      return method.call(obj, this.composer, command);\n    } else {\n      try {\n        // try/catch for buggy firefox\n        return this.doc.queryCommandValue(command);\n      } catch (e) {\n        return null;\n      }\n    }\n  }\n});\n(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.bold = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatInline.exec(composer, command, "b");\n    },\n\n    state: function state(composer, command, color) {\n      // element.ownerDocument.queryCommandState("bold") results:\n      // firefox: only <b>\n      // chrome:  <b>, <strong>, <h1>, <h2>, ...\n      // ie:      <b>, <strong>\n      // opera:   <b>, <strong>\n      return wysihtml5.commands.formatInline.state(composer, command, "b");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);\n\n(function (wysihtml5) {\n  var undef,\n      NODE_NAME = "A",\n      dom = wysihtml5.dom;\n\n  function _removeFormat(composer, anchors) {\n    var length = anchors.length,\n        i = 0,\n        anchor,\n        codeElement,\n        textContent;\n    for (; i < length; i++) {\n      anchor = anchors[i];\n      codeElement = dom.getParentElement(anchor, { nodeName: "code" });\n      textContent = dom.getTextContent(anchor);\n\n      // if <a> contains url-like text content, rename it to <code> to prevent re-autolinking\n      // else replace <a> with its childNodes\n      if (textContent.match(dom.autoLink.URL_REG_EXP) && !codeElement) {\n        // <code> element is used to prevent later auto-linking of the content\n        codeElement = dom.renameElement(anchor, "code");\n      } else {\n        dom.replaceWithChildNodes(anchor);\n      }\n    }\n  }\n\n  function _format(composer, attributes) {\n    var doc = composer.doc,\n        tempClass = "_wysihtml5-temp-" + +new Date(),\n        tempClassRegExp = /non-matching-class/g,\n        i = 0,\n        length,\n        anchors,\n        anchor,\n        hasElementChild,\n        isEmpty,\n        elementToSetCaretAfter,\n        textContent,\n        whiteSpace,\n        j;\n    wysihtml5.commands.formatInline.exec(composer, undef, NODE_NAME, tempClass, tempClassRegExp);\n    anchors = doc.querySelectorAll(NODE_NAME + "." + tempClass);\n    length = anchors.length;\n    for (; i < length; i++) {\n      anchor = anchors[i];\n      anchor.removeAttribute("class");\n      for (j in attributes) {\n        anchor.setAttribute(j, attributes[j]);\n      }\n    }\n\n    elementToSetCaretAfter = anchor;\n    if (length === 1) {\n      textContent = dom.getTextContent(anchor);\n      hasElementChild = !!anchor.querySelector("*");\n      isEmpty = textContent === "" || textContent === wysihtml5.INVISIBLE_SPACE;\n      if (!hasElementChild && isEmpty) {\n        dom.setTextContent(anchor, attributes.text || anchor.href);\n        whiteSpace = doc.createTextNode(" ");\n        composer.selection.setAfter(anchor);\n        composer.selection.insertNode(whiteSpace);\n        elementToSetCaretAfter = whiteSpace;\n      }\n    }\n    composer.selection.setAfter(elementToSetCaretAfter);\n  }\n\n  wysihtml5.commands.createLink = {\n    /**\n     * TODO: Use HTMLApplier or formatInline here\n     *\n     * Turns selection into a link\n     * If selection is already a link, it removes the link and wraps it with a <code> element\n     * The <code> element is needed to avoid auto linking\n     * \n     * @example\n     *    // either ...\n     *    wysihtml5.commands.createLink.exec(composer, "createLink", "http://www.google.de");\n     *    // ... or ...\n     *    wysihtml5.commands.createLink.exec(composer, "createLink", { href: "http://www.google.de", target: "_blank" });\n     */\n    exec: function exec(composer, command, value) {\n      var anchors = this.state(composer, command);\n      if (anchors) {\n        // Selection contains links\n        composer.selection.executeAndRestore(function () {\n          _removeFormat(composer, anchors);\n        });\n      } else {\n        // Create links\n        value = (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" ? value : { href: value };\n        _format(composer, value);\n      }\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatInline.state(composer, command, "A");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5); /**\n               * document.execCommand("fontSize") will create either inline styles (firefox, chrome) or use font tags\n               * which we don\'t want\n               * Instead we set a css class\n               */\n(function (wysihtml5) {\n  var undef,\n      REG_EXP = /wysiwyg-font-size-[a-z\\-]+/g;\n\n  wysihtml5.commands.fontSize = {\n    exec: function exec(composer, command, size) {\n      return wysihtml5.commands.formatInline.exec(composer, command, "span", "wysiwyg-font-size-" + size, REG_EXP);\n    },\n\n    state: function state(composer, command, size) {\n      return wysihtml5.commands.formatInline.state(composer, command, "span", "wysiwyg-font-size-" + size, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);\n/**\n * document.execCommand("foreColor") will create either inline styles (firefox, chrome) or use font tags\n * which we don\'t want\n * Instead we set a css class\n */\n(function (wysihtml5) {\n  var undef,\n      REG_EXP = /wysiwyg-color-[a-z]+/g;\n\n  wysihtml5.commands.foreColor = {\n    exec: function exec(composer, command, color) {\n      return wysihtml5.commands.formatInline.exec(composer, command, "span", "wysiwyg-color-" + color, REG_EXP);\n    },\n\n    state: function state(composer, command, color) {\n      return wysihtml5.commands.formatInline.state(composer, command, "span", "wysiwyg-color-" + color, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      dom = wysihtml5.dom,\n      DEFAULT_NODE_NAME = "DIV",\n\n\n  // Following elements are grouped\n  // when the caret is within a H1 and the H4 is invoked, the H1 should turn into H4\n  // instead of creating a H4 within a H1 which would result in semantically invalid html\n  BLOCK_ELEMENTS_GROUP = ["H1", "H2", "H3", "H4", "H5", "H6", "P", "BLOCKQUOTE", DEFAULT_NODE_NAME];\n\n  /**\n   * Remove similiar classes (based on classRegExp)\n   * and add the desired class name\n   */\n  function _addClass(element, className, classRegExp) {\n    if (element.className) {\n      _removeClass(element, classRegExp);\n      element.className += " " + className;\n    } else {\n      element.className = className;\n    }\n  }\n\n  function _removeClass(element, classRegExp) {\n    element.className = element.className.replace(classRegExp, "");\n  }\n\n  /**\n   * Check whether given node is a text node and whether it\'s empty\n   */\n  function _isBlankTextNode(node) {\n    return node.nodeType === wysihtml5.TEXT_NODE && !wysihtml5.lang.string(node.data).trim();\n  }\n\n  /**\n   * Returns previous sibling node that is not a blank text node\n   */\n  function _getPreviousSiblingThatIsNotBlank(node) {\n    var previousSibling = node.previousSibling;\n    while (previousSibling && _isBlankTextNode(previousSibling)) {\n      previousSibling = previousSibling.previousSibling;\n    }\n    return previousSibling;\n  }\n\n  /**\n   * Returns next sibling node that is not a blank text node\n   */\n  function _getNextSiblingThatIsNotBlank(node) {\n    var nextSibling = node.nextSibling;\n    while (nextSibling && _isBlankTextNode(nextSibling)) {\n      nextSibling = nextSibling.nextSibling;\n    }\n    return nextSibling;\n  }\n\n  /**\n   * Adds line breaks before and after the given node if the previous and next siblings\n   * aren\'t already causing a visual line break (block element or <br>)\n   */\n  function _addLineBreakBeforeAndAfter(node) {\n    var doc = node.ownerDocument,\n        nextSibling = _getNextSiblingThatIsNotBlank(node),\n        previousSibling = _getPreviousSiblingThatIsNotBlank(node);\n\n    if (nextSibling && !_isLineBreakOrBlockElement(nextSibling)) {\n      node.parentNode.insertBefore(doc.createElement("br"), nextSibling);\n    }\n    if (previousSibling && !_isLineBreakOrBlockElement(previousSibling)) {\n      node.parentNode.insertBefore(doc.createElement("br"), node);\n    }\n  }\n\n  /**\n   * Removes line breaks before and after the given node\n   */\n  function _removeLineBreakBeforeAndAfter(node) {\n    var nextSibling = _getNextSiblingThatIsNotBlank(node),\n        previousSibling = _getPreviousSiblingThatIsNotBlank(node);\n\n    if (nextSibling && _isLineBreak(nextSibling)) {\n      nextSibling.parentNode.removeChild(nextSibling);\n    }\n    if (previousSibling && _isLineBreak(previousSibling)) {\n      previousSibling.parentNode.removeChild(previousSibling);\n    }\n  }\n\n  function _removeLastChildIfLineBreak(node) {\n    var lastChild = node.lastChild;\n    if (lastChild && _isLineBreak(lastChild)) {\n      lastChild.parentNode.removeChild(lastChild);\n    }\n  }\n\n  function _isLineBreak(node) {\n    return node.nodeName === "BR";\n  }\n\n  /**\n   * Checks whether the elment causes a visual line break\n   * (<br> or block elements)\n   */\n  function _isLineBreakOrBlockElement(element) {\n    if (_isLineBreak(element)) {\n      return true;\n    }\n\n    if (dom.getStyle("display").from(element) === "block") {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Execute native query command\n   * and if necessary modify the inserted node\'s className\n   */\n  function _execCommand(doc, command, nodeName, className) {\n    if (className) {\n      var eventListener = dom.observe(doc, "DOMNodeInserted", function (event) {\n        var target = event.target,\n            displayStyle;\n        if (target.nodeType !== wysihtml5.ELEMENT_NODE) {\n          return;\n        }\n        displayStyle = dom.getStyle("display").from(target);\n        if (displayStyle.substr(0, 6) !== "inline") {\n          // Make sure that only block elements receive the given class\n          target.className += " " + className;\n        }\n      });\n    }\n    doc.execCommand(command, false, nodeName);\n    if (eventListener) {\n      eventListener.stop();\n    }\n  }\n\n  function _selectLineAndWrap(composer, element) {\n    composer.selection.selectLine();\n    composer.selection.surround(element);\n    _removeLineBreakBeforeAndAfter(element);\n    _removeLastChildIfLineBreak(element);\n    composer.selection.selectNode(element);\n  }\n\n  function _hasClasses(element) {\n    return !!wysihtml5.lang.string(element.className).trim();\n  }\n\n  wysihtml5.commands.formatBlock = {\n    exec: function exec(composer, command, nodeName, className, classRegExp) {\n      var doc = composer.doc,\n          blockElement = this.state(composer, command, nodeName, className, classRegExp),\n          selectedNode;\n\n      nodeName = typeof nodeName === "string" ? nodeName.toUpperCase() : nodeName;\n\n      if (blockElement) {\n        composer.selection.executeAndRestoreSimple(function () {\n          if (classRegExp) {\n            _removeClass(blockElement, classRegExp);\n          }\n          var hasClasses = _hasClasses(blockElement);\n          if (!hasClasses && blockElement.nodeName === (nodeName || DEFAULT_NODE_NAME)) {\n            // Insert a line break afterwards and beforewards when there are siblings\n            // that are not of type line break or block element\n            _addLineBreakBeforeAndAfter(blockElement);\n            dom.replaceWithChildNodes(blockElement);\n          } else if (hasClasses) {\n            // Make sure that styling is kept by renaming the element to <div> and copying over the class name\n            dom.renameElement(blockElement, DEFAULT_NODE_NAME);\n          }\n        });\n        return;\n      }\n\n      // Find similiar block element and rename it (<h2 class="foo"></h2>  =>  <h1 class="foo"></h1>)\n      if (nodeName === null || wysihtml5.lang.array(BLOCK_ELEMENTS_GROUP).contains(nodeName)) {\n        selectedNode = composer.selection.getSelectedNode();\n        blockElement = dom.getParentElement(selectedNode, {\n          nodeName: BLOCK_ELEMENTS_GROUP\n        });\n\n        if (blockElement) {\n          composer.selection.executeAndRestoreSimple(function () {\n            // Rename current block element to new block element and add class\n            if (nodeName) {\n              blockElement = dom.renameElement(blockElement, nodeName);\n            }\n            if (className) {\n              _addClass(blockElement, className, classRegExp);\n            }\n          });\n          return;\n        }\n      }\n\n      if (composer.commands.support(command)) {\n        _execCommand(doc, command, nodeName || DEFAULT_NODE_NAME, className);\n        return;\n      }\n\n      blockElement = doc.createElement(nodeName || DEFAULT_NODE_NAME);\n      if (className) {\n        blockElement.className = className;\n      }\n      _selectLineAndWrap(composer, blockElement);\n    },\n\n    state: function state(composer, command, nodeName, className, classRegExp) {\n      nodeName = typeof nodeName === "string" ? nodeName.toUpperCase() : nodeName;\n      var selectedNode = composer.selection.getSelectedNode();\n      return dom.getParentElement(selectedNode, {\n        nodeName: nodeName,\n        className: className,\n        classRegExp: classRegExp\n      });\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5); /**\n               * formatInline scenarios for tag "B" (| = caret, |foo| = selected text)\n               *\n               *   #1 caret in unformatted text:\n               *      abcdefg|\n               *   output:\n               *      abcdefg<b>|</b>\n               *   \n               *   #2 unformatted text selected:\n               *      abc|deg|h\n               *   output:\n               *      abc<b>|deg|</b>h\n               *   \n               *   #3 unformatted text selected across boundaries:\n               *      ab|c <span>defg|h</span>\n               *   output:\n               *      ab<b>|c </b><span><b>defg</b>|h</span>\n               *\n               *   #4 formatted text entirely selected\n               *      <b>|abc|</b>\n               *   output:\n               *      |abc|\n               *\n               *   #5 formatted text partially selected\n               *      <b>ab|c|</b>\n               *   output:\n               *      <b>ab</b>|c|\n               *\n               *   #6 formatted text selected across boundaries\n               *      <span>ab|c</span> <b>de|fgh</b>\n               *   output:\n               *      <span>ab|c</span> de|<b>fgh</b>\n               */\n(function (wysihtml5) {\n  var undef,\n\n\n  // Treat <b> as <strong> and vice versa\n  ALIAS_MAPPING = {\n    "strong": "b",\n    "em": "i",\n    "b": "strong",\n    "i": "em"\n  },\n      htmlApplier = {};\n\n  function _getTagNames(tagName) {\n    var alias = ALIAS_MAPPING[tagName];\n    return alias ? [tagName.toLowerCase(), alias.toLowerCase()] : [tagName.toLowerCase()];\n  }\n\n  function _formatClear(range) {\n    body = $(range.endContainer.ownerDocument.body);\n    $.each(body.children(\'font\'), function () {\n      font_el = $(this);\n      font_el.replaceWith(\'<span>\' + font_el.html() + \'</span>\');\n    });\n\n    $.each(body.children(\'span\'), function () {\n      span_el = $(this);\n      reduced_dimension(span_el);\n    });\n    not_span_list = $(\'tbody:first > tr\').not(\'td\').toArray();\n    while (not_span_list.length) {\n      not_span_list_item = not_span_list.pop();\n      $.each(not_span_list_item.children(), function () {\n        new_el = $(this);\n        if (new_el.is(\'span\')) {\n          reduced_dimension(new_el);\n        } else {\n          not_span_list.push(new_el);\n        }\n      });\n    }\n    $.each(body.find(\'span\'), function () {\n      el = $(this);\n      if (!$.trim(el.text()).length) {\n        el.remove();\n      }\n    });\n    range.endContainer.ownerDocument.getSelection().empty();\n  }\n\n  // make <span class=\'a\'>123<span class=\'b\'>4</span>5</span> become\n  // <span class=\'a\'>123</span> <span class=\'b\'>4</span> <span class=\'a\'>5</span>\n  function reduced_dimension(span) {\n    if (span.children(\'span\').length) {\n      class_name = $.trim(span.get(0).className);\n      for (var i = 0; i < span.children(\'span\').length; i++) {\n        child_span = $(span.children(\'span\')[i]);\n        reduced_dimension(child_span);\n      }\n\n      console.log(span.parents(\'span\').length);\n      html_text = span.html();\n      if (!class_name.length) {\n        class_name = \'wysiwyg-color-clear\';\n      }\n      html_text = html_text.replace(/<span\\ /, \'</span><span \');\n      html_text = html_text.replace(/<\\/span>(?![\\s\\S]*<\\/span>[\\s\\S]*$)/i, "</span><span class=\'" + class_name + "\'>");\n      html_text = "<span class=\'" + class_name + "\'>" + html_text + "</span>";\n      span.replaceWith(html_text);\n    } else {\n      return;\n    }\n  }\n\n  function _getApplier(tagName, className, classRegExp) {\n    var identifier = tagName + ":" + className;\n    if (!htmlApplier[identifier]) {\n      htmlApplier[identifier] = new wysihtml5.selection.HTMLApplier(_getTagNames(tagName), className, classRegExp, true);\n    }\n    return htmlApplier[identifier];\n  }\n\n  wysihtml5.commands.formatInline = {\n    exec: function exec(composer, command, tagName, className, classRegExp) {\n      var range = composer.selection.getRange();\n      if (!range) {\n        return false;\n      }\n      _getApplier(tagName, className, classRegExp).toggleRange(range);\n      composer.selection.setSelection(range);\n      _formatClear(range);\n    },\n\n    state: function state(composer, command, tagName, className, classRegExp) {\n      var doc = composer.doc,\n          aliasTagName = ALIAS_MAPPING[tagName] || tagName,\n          range;\n\n      // Check whether the document contains a node with the desired tagName\n      if (!wysihtml5.dom.hasElementWithTagName(doc, tagName) && !wysihtml5.dom.hasElementWithTagName(doc, aliasTagName)) {\n        return false;\n      }\n\n      // Check whether the document contains a node with the desired className\n      if (className && !wysihtml5.dom.hasElementWithClassName(doc, className)) {\n        return false;\n      }\n\n      range = composer.selection.getRange();\n      if (!range) {\n        return false;\n      }\n\n      return _getApplier(tagName, className, classRegExp).isAppliedToRange(range);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.insertHTML = {\n    exec: function exec(composer, command, html) {\n      if (composer.commands.support(command)) {\n        composer.doc.execCommand(command, false, html);\n      } else {\n        composer.selection.insertHTML(html);\n      }\n    },\n\n    state: function state() {\n      return false;\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var NODE_NAME = "IMG";\n\n  wysihtml5.commands.insertImage = {\n    /**\n     * Inserts an <img>\n     * If selection is already an image link, it removes it\n     * \n     * @example\n     *    // either ...\n     *    wysihtml5.commands.insertImage.exec(composer, "insertImage", "http://www.google.de/logo.jpg");\n     *    // ... or ...\n     *    wysihtml5.commands.insertImage.exec(composer, "insertImage", { src: "http://www.google.de/logo.jpg", title: "foo" });\n     */\n    exec: function exec(composer, command, value) {\n      value = (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" ? value : { src: value };\n\n      var doc = composer.doc,\n          image = this.state(composer),\n          textNode,\n          i,\n          parent;\n\n      if (image) {\n        // Image already selected, set the caret before it and delete it\n        composer.selection.setBefore(image);\n        parent = image.parentNode;\n        parent.removeChild(image);\n\n        // and it\'s parent <a> too if it hasn\'t got any other relevant child nodes\n        wysihtml5.dom.removeEmptyTextNodes(parent);\n        if (parent.nodeName === "A" && !parent.firstChild) {\n          composer.selection.setAfter(parent);\n          parent.parentNode.removeChild(parent);\n        }\n\n        // firefox and ie sometimes don\'t remove the image handles, even though the image got removed\n        wysihtml5.quirks.redraw(composer.element);\n        return;\n      }\n\n      image = doc.createElement(NODE_NAME);\n\n      for (i in value) {\n        image[i] = value[i];\n      }\n\n      composer.selection.insertNode(image);\n      if (wysihtml5.browser.hasProblemsSettingCaretAfterImg()) {\n        textNode = doc.createTextNode(wysihtml5.INVISIBLE_SPACE);\n        composer.selection.insertNode(textNode);\n        composer.selection.setAfter(textNode);\n      } else {\n        composer.selection.setAfter(image);\n      }\n    },\n\n    state: function state(composer) {\n      var doc = composer.doc,\n          selectedNode,\n          text,\n          imagesInSelection;\n\n      if (!wysihtml5.dom.hasElementWithTagName(doc, NODE_NAME)) {\n        return false;\n      }\n\n      selectedNode = composer.selection.getSelectedNode();\n      if (!selectedNode) {\n        return false;\n      }\n\n      if (selectedNode.nodeName === NODE_NAME) {\n        // This works perfectly in IE\n        return selectedNode;\n      }\n\n      if (selectedNode.nodeType !== wysihtml5.ELEMENT_NODE) {\n        return false;\n      }\n\n      text = composer.selection.getText();\n      text = wysihtml5.lang.string(text).trim();\n      if (text) {\n        return false;\n      }\n\n      imagesInSelection = composer.selection.getNodes(wysihtml5.ELEMENT_NODE, function (node) {\n        return node.nodeName === "IMG";\n      });\n\n      if (imagesInSelection.length !== 1) {\n        return false;\n      }\n\n      return imagesInSelection[0];\n    },\n\n    value: function value(composer) {\n      var image = this.state(composer);\n      return image && image.src;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      LINE_BREAK = "<br>" + (wysihtml5.browser.needsSpaceAfterLineBreak() ? " " : "");\n\n  wysihtml5.commands.insertLineBreak = {\n    exec: function exec(composer, command) {\n      if (composer.commands.support(command)) {\n        composer.doc.execCommand(command, false, null);\n        if (!wysihtml5.browser.autoScrollsToCaret()) {\n          composer.selection.scrollIntoView();\n        }\n      } else {\n        composer.commands.exec("insertHTML", LINE_BREAK);\n      }\n    },\n\n    state: function state() {\n      return false;\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n  //\n  // function _removeFormat(composer, anchors) {\n  //   var length  = anchors.length,\n  //       i       = 0,\n  //       anchor,\n  //       codeElement,\n  //       textContent;\n  //   for (; i<length; i++) {\n  //     anchor      = anchors[i];\n  //     codeElement = dom.getParentElement(anchor, { nodeName: "code" });\n  //     textContent = dom.getTextContent(anchor);\n  //\n  //     // if <a> contains url-like text content, rename it to <code> to prevent re-autolinking\n  //     // else replace <a> with its childNodes\n  //     if (textContent.match(dom.autoLink.URL_REG_EXP) && !codeElement) {\n  //       // <code> element is used to prevent later auto-linking of the content\n  //       codeElement = dom.renameElement(anchor, "code");\n  //     } else {\n  //       dom.replaceWithChildNodes(anchor);\n  //     }\n  //   }\n  // }\n  //\n  //\n  wysihtml5.commands.clear = {\n    exec: function exec(composer, command) {\n      composer.doc.execCommand(\'removeFormat\');\n      REG_EXP = /wysiwyg-color-[a-z]+/g;\n      wysihtml5.commands.formatInline.exec(composer, command, "span", "", REG_EXP);\n    }\n  };\n  wysihtml5.commands.insertOrderedList = {\n    exec: function exec(composer, command) {\n      var doc = composer.doc,\n          selectedNode = composer.selection.getSelectedNode(),\n          list = wysihtml5.dom.getParentElement(selectedNode, { nodeName: "OL" }),\n          otherList = wysihtml5.dom.getParentElement(selectedNode, { nodeName: "UL" }),\n          tempClassName = "_wysihtml5-temp-" + new Date().getTime(),\n          isEmpty,\n          tempElement;\n\n      if (composer.commands.support(command)) {\n        doc.execCommand(command, false, null);\n        return;\n      }\n\n      if (list) {\n        // Unwrap list\n        // <ol><li>foo</li><li>bar</li></ol>\n        // becomes:\n        // foo<br>bar<br>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.resolveList(list);\n        });\n      } else if (otherList) {\n        // Turn an unordered list into an ordered list\n        // <ul><li>foo</li><li>bar</li></ul>\n        // becomes:\n        // <ol><li>foo</li><li>bar</li></ol>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.renameElement(otherList, "ol");\n        });\n      } else {\n        // Create list\n        composer.commands.exec("formatBlock", "div", tempClassName);\n        tempElement = doc.querySelector("." + tempClassName);\n        isEmpty = tempElement.innerHTML === "" || tempElement.innerHTML === wysihtml5.INVISIBLE_SPACE;\n        composer.selection.executeAndRestoreSimple(function () {\n          list = wysihtml5.dom.convertToList(tempElement, "ol");\n        });\n        if (isEmpty) {\n          composer.selection.selectNode(list.querySelector("li"));\n        }\n      }\n    },\n\n    state: function state(composer) {\n      var selectedNode = composer.selection.getSelectedNode();\n      return wysihtml5.dom.getParentElement(selectedNode, { nodeName: "OL" });\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.insertUnorderedList = {\n    exec: function exec(composer, command) {\n      var doc = composer.doc,\n          selectedNode = composer.selection.getSelectedNode(),\n          list = wysihtml5.dom.getParentElement(selectedNode, { nodeName: "UL" }),\n          otherList = wysihtml5.dom.getParentElement(selectedNode, { nodeName: "OL" }),\n          tempClassName = "_wysihtml5-temp-" + new Date().getTime(),\n          isEmpty,\n          tempElement;\n\n      if (composer.commands.support(command)) {\n        doc.execCommand(command, false, null);\n        return;\n      }\n\n      if (list) {\n        // Unwrap list\n        // <ul><li>foo</li><li>bar</li></ul>\n        // becomes:\n        // foo<br>bar<br>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.resolveList(list);\n        });\n      } else if (otherList) {\n        // Turn an ordered list into an unordered list\n        // <ol><li>foo</li><li>bar</li></ol>\n        // becomes:\n        // <ul><li>foo</li><li>bar</li></ul>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.renameElement(otherList, "ul");\n        });\n      } else {\n        // Create list\n        composer.commands.exec("formatBlock", "div", tempClassName);\n        tempElement = doc.querySelector("." + tempClassName);\n        isEmpty = tempElement.innerHTML === "" || tempElement.innerHTML === wysihtml5.INVISIBLE_SPACE;\n        composer.selection.executeAndRestoreSimple(function () {\n          list = wysihtml5.dom.convertToList(tempElement, "ul");\n        });\n        if (isEmpty) {\n          composer.selection.selectNode(list.querySelector("li"));\n        }\n      }\n    },\n\n    state: function state(composer) {\n      var selectedNode = composer.selection.getSelectedNode();\n      return wysihtml5.dom.getParentElement(selectedNode, { nodeName: "UL" });\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.italic = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatInline.exec(composer, command, "i");\n    },\n\n    state: function state(composer, command, color) {\n      // element.ownerDocument.queryCommandState("italic") results:\n      // firefox: only <i>\n      // chrome:  <i>, <em>, <blockquote>, ...\n      // ie:      <i>, <em>\n      // opera:   only <i>\n      return wysihtml5.commands.formatInline.state(composer, command, "i");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      CLASS_NAME = "wysiwyg-text-align-center",\n      REG_EXP = /wysiwyg-text-align-[a-z]+/g;\n\n  wysihtml5.commands.justifyCenter = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      CLASS_NAME = "wysiwyg-text-align-left",\n      REG_EXP = /wysiwyg-text-align-[a-z]+/g;\n\n  wysihtml5.commands.justifyLeft = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      CLASS_NAME = "wysiwyg-text-align-right",\n      REG_EXP = /wysiwyg-text-align-[a-z]+/g;\n\n  wysihtml5.commands.justifyRight = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatBlock.exec(composer, "formatBlock", null, CLASS_NAME, REG_EXP);\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatBlock.state(composer, "formatBlock", null, CLASS_NAME, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n  wysihtml5.commands.underline = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatInline.exec(composer, command, "u");\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatInline.state(composer, command, "u");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5); /**\n               * Undo Manager for wysihtml5\n               * slightly inspired by http://rniwa.com/editing/undomanager.html#the-undomanager-interface\n               */\n(function (wysihtml5) {\n  var Z_KEY = 90,\n      Y_KEY = 89,\n      BACKSPACE_KEY = 8,\n      DELETE_KEY = 46,\n      MAX_HISTORY_ENTRIES = 40,\n      UNDO_HTML = \'<span id="_wysihtml5-undo" class="_wysihtml5-temp">\' + wysihtml5.INVISIBLE_SPACE + \'</span>\',\n      REDO_HTML = \'<span id="_wysihtml5-redo" class="_wysihtml5-temp">\' + wysihtml5.INVISIBLE_SPACE + \'</span>\',\n      dom = wysihtml5.dom;\n\n  function cleanTempElements(doc) {\n    var tempElement;\n    while (tempElement = doc.querySelector("._wysihtml5-temp")) {\n      tempElement.parentNode.removeChild(tempElement);\n    }\n  }\n\n  wysihtml5.UndoManager = wysihtml5.lang.Dispatcher.extend(\n  /** @scope wysihtml5.UndoManager.prototype */{\n    constructor: function constructor(editor) {\n      this.editor = editor;\n      this.composer = editor.composer;\n      this.element = this.composer.element;\n      this.history = [this.composer.getValue()];\n      this.position = 1;\n\n      // Undo manager currently only supported in browsers who have the insertHTML command (not IE)\n      if (this.composer.commands.support("insertHTML")) {\n        this._observe();\n      }\n    },\n\n    _observe: function _observe() {\n      var that = this,\n          doc = this.composer.sandbox.getDocument(),\n          lastKey;\n\n      // Catch CTRL+Z and CTRL+Y\n      dom.observe(this.element, "keydown", function (event) {\n        if (event.altKey || !event.ctrlKey && !event.metaKey) {\n          return;\n        }\n\n        var keyCode = event.keyCode,\n            isUndo = keyCode === Z_KEY && !event.shiftKey,\n            isRedo = keyCode === Z_KEY && event.shiftKey || keyCode === Y_KEY;\n\n        if (isUndo) {\n          that.undo();\n          event.preventDefault();\n        } else if (isRedo) {\n          that.redo();\n          event.preventDefault();\n        }\n      });\n\n      // Catch delete and backspace\n      dom.observe(this.element, "keydown", function (event) {\n        var keyCode = event.keyCode;\n        if (keyCode === lastKey) {\n          return;\n        }\n\n        lastKey = keyCode;\n\n        if (keyCode === BACKSPACE_KEY || keyCode === DELETE_KEY) {\n          that.transact();\n        }\n      });\n\n      // Now this is very hacky:\n      // These days browsers don\'t offer a undo/redo event which we could hook into\n      // to be notified when the user hits undo/redo in the contextmenu.\n      // Therefore we simply insert two elements as soon as the contextmenu gets opened.\n      // The last element being inserted will be immediately be removed again by a exexCommand("undo")\n      //  => When the second element appears in the dom tree then we know the user clicked "redo" in the context menu\n      //  => When the first element disappears from the dom tree then we know the user clicked "undo" in the context menu\n      if (wysihtml5.browser.hasUndoInContextMenu()) {\n        var interval,\n            observed,\n            cleanUp = function cleanUp() {\n          cleanTempElements(doc);\n          clearInterval(interval);\n        };\n\n        dom.observe(this.element, "contextmenu", function () {\n          cleanUp();\n          that.composer.selection.executeAndRestoreSimple(function () {\n            if (that.element.lastChild) {\n              that.composer.selection.setAfter(that.element.lastChild);\n            }\n\n            // enable undo button in context menu\n            doc.execCommand("insertHTML", false, UNDO_HTML);\n            // enable redo button in context menu\n            doc.execCommand("insertHTML", false, REDO_HTML);\n            doc.execCommand("undo", false, null);\n          });\n\n          interval = setInterval(function () {\n            if (doc.getElementById("_wysihtml5-redo")) {\n              cleanUp();\n              that.redo();\n            }\n          }, 400);\n\n          if (!observed) {\n            observed = true;\n            dom.observe(document, "mousedown", cleanUp);\n            dom.observe(doc, ["mousedown", "paste", "cut", "copy"], cleanUp);\n          }\n        });\n      }\n\n      this.editor.observe("newword:composer", function () {\n        that.transact();\n      }).observe("beforecommand:composer", function () {\n        that.transact();\n      });\n    },\n\n    transact: function transact() {\n      var previousHtml = this.history[this.position - 1],\n          currentHtml = this.composer.getValue();\n\n      if (currentHtml == previousHtml) {\n        return;\n      }\n\n      var length = this.history.length = this.position;\n      if (length > MAX_HISTORY_ENTRIES) {\n        this.history.shift();\n        this.position--;\n      }\n\n      this.position++;\n      this.history.push(currentHtml);\n    },\n\n    undo: function undo() {\n      this.transact();\n\n      if (this.position <= 1) {\n        return;\n      }\n\n      this.set(this.history[--this.position - 1]);\n      this.editor.fire("undo:composer");\n    },\n\n    redo: function redo() {\n      if (this.position >= this.history.length) {\n        return;\n      }\n\n      this.set(this.history[++this.position - 1]);\n      this.editor.fire("redo:composer");\n    },\n\n    set: function set(html) {\n      this.composer.setValue(html);\n      this.editor.focus(true);\n    }\n  });\n})(wysihtml5);\n/**\n * TODO: the following methods still need unit test coverage\n */\nwysihtml5.views.View = Base.extend(\n/** @scope wysihtml5.views.View.prototype */{\n  constructor: function constructor(parent, textareaElement, config) {\n    this.parent = parent;\n    this.element = textareaElement;\n    this.config = config;\n\n    this._observeViewChange();\n  },\n\n  _observeViewChange: function _observeViewChange() {\n    var that = this;\n    this.parent.observe("beforeload", function () {\n      that.parent.observe("change_view", function (view) {\n        if (view === that.name) {\n          that.parent.currentView = that;\n          that.show();\n          // Using tiny delay here to make sure that the placeholder is set before focusing\n          setTimeout(function () {\n            that.focus();\n          }, 0);\n        } else {\n          that.hide();\n        }\n      });\n    });\n  },\n\n  focus: function focus() {\n    if (this.element.ownerDocument.querySelector(":focus") === this.element) {\n      return;\n    }\n\n    try {\n      this.element.focus();\n    } catch (e) {}\n  },\n\n  hide: function hide() {\n    this.element.style.display = "none";\n  },\n\n  show: function show() {\n    this.element.style.display = "";\n  },\n\n  disable: function disable() {\n    this.element.setAttribute("disabled", "disabled");\n  },\n\n  enable: function enable() {\n    this.element.removeAttribute("disabled");\n  }\n});(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      browser = wysihtml5.browser;\n\n  wysihtml5.views.Composer = wysihtml5.views.View.extend(\n  /** @scope wysihtml5.views.Composer.prototype */{\n    name: "composer",\n\n    // Needed for firefox in order to display a proper caret in an empty contentEditable\n    CARET_HACK: "<br>",\n\n    constructor: function constructor(parent, textareaElement, config) {\n      this.base(parent, textareaElement, config);\n      this.textarea = this.parent.textarea;\n      this._initSandbox();\n    },\n\n    clear: function clear() {\n      this.element.innerHTML = browser.displaysCaretInEmptyContentEditableCorrectly() ? "" : this.CARET_HACK;\n    },\n\n    getValue: function getValue(parse) {\n      var value = this.isEmpty() ? "" : wysihtml5.quirks.getCorrectInnerHTML(this.element);\n\n      if (parse) {\n        value = this.parent.parse(value);\n      }\n\n      // Replace all "zero width no breaking space" chars\n      // which are used as hacks to enable some functionalities\n      // Also remove all CARET hacks that somehow got left\n      value = wysihtml5.lang.string(value).replace(wysihtml5.INVISIBLE_SPACE).by("");\n\n      return value;\n    },\n\n    setValue: function setValue(html, parse) {\n      if (parse) {\n        html = this.parent.parse(html);\n      }\n      this.element.innerHTML = html;\n    },\n\n    show: function show() {\n      this.iframe.style.display = this._displayStyle || "";\n\n      // Firefox needs this, otherwise contentEditable becomes uneditable\n      this.disable();\n      this.enable();\n    },\n\n    hide: function hide() {\n      this._displayStyle = dom.getStyle("display").from(this.iframe);\n      if (this._displayStyle === "none") {\n        this._displayStyle = null;\n      }\n      this.iframe.style.display = "none";\n    },\n\n    disable: function disable() {\n      this.element.removeAttribute("contentEditable");\n      this.base();\n    },\n\n    enable: function enable() {\n      this.element.setAttribute("contentEditable", "true");\n      this.base();\n    },\n\n    focus: function focus(setToEnd) {\n      // IE 8 fires the focus event after .focus()\n      // This is needed by our simulate_placeholder.js to work\n      // therefore we clear it ourselves this time\n      if (wysihtml5.browser.doesAsyncFocus() && this.hasPlaceholderSet()) {\n        this.clear();\n      }\n\n      this.base();\n\n      var lastChild = this.element.lastChild;\n      if (setToEnd && lastChild) {\n        if (lastChild.nodeName === "BR") {\n          this.selection.setBefore(this.element.lastChild);\n        } else {\n          this.selection.setAfter(this.element.lastChild);\n        }\n      }\n    },\n\n    getTextContent: function getTextContent() {\n      return dom.getTextContent(this.element);\n    },\n\n    hasPlaceholderSet: function hasPlaceholderSet() {\n      return this.getTextContent() == this.textarea.element.getAttribute("placeholder");\n    },\n\n    isEmpty: function isEmpty() {\n      var innerHTML = this.element.innerHTML,\n          elementsWithVisualValue = "blockquote, ul, ol, img, embed, object, table, iframe, svg, video, audio, button, input, select, textarea";\n      return innerHTML === "" || innerHTML === this.CARET_HACK || this.hasPlaceholderSet() || this.getTextContent() === "" && !this.element.querySelector(elementsWithVisualValue);\n    },\n\n    _initSandbox: function _initSandbox() {\n      var that = this;\n\n      this.sandbox = new dom.Sandbox(function () {\n        that._create();\n      }, {\n        stylesheets: this.config.stylesheets\n      });\n      this.iframe = this.sandbox.getIframe();\n\n      // Create hidden field which tells the server after submit, that the user used an wysiwyg editor\n      var hiddenField = document.createElement("input");\n      hiddenField.type = "hidden";\n      hiddenField.name = "_wysihtml5_mode";\n      hiddenField.value = 1;\n\n      // Store reference to current wysihtml5 instance on the textarea element\n      var textareaElement = this.textarea.element;\n      dom.insert(this.iframe).after(textareaElement);\n      dom.insert(hiddenField).after(textareaElement);\n    },\n\n    _create: function _create() {\n      var that = this;\n\n      this.doc = this.sandbox.getDocument();\n      this.element = this.doc.body;\n      this.textarea = this.parent.textarea;\n      this.element.innerHTML = this.textarea.getValue(true);\n      this.enable();\n\n      // Make sure our selection handler is ready\n      this.selection = new wysihtml5.Selection(this.parent);\n\n      // Make sure commands dispatcher is ready\n      this.commands = new wysihtml5.Commands(this.parent);\n\n      dom.copyAttributes(["className", "spellcheck", "title", "lang", "dir", "accessKey"]).from(this.textarea.element).to(this.element);\n\n      dom.addClass(this.element, this.config.composerClassName);\n\n      // Make the editor look like the original textarea, by syncing styles\n      if (this.config.style) {\n        this.style();\n      }\n\n      this.observe();\n\n      var name = this.config.name;\n      if (name) {\n        dom.addClass(this.element, name);\n        dom.addClass(this.iframe, name);\n      }\n\n      // Simulate html5 placeholder attribute on contentEditable element\n      var placeholderText = typeof this.config.placeholder === "string" ? this.config.placeholder : this.textarea.element.getAttribute("placeholder");\n      if (placeholderText) {\n        dom.simulatePlaceholder(this.parent, this, placeholderText);\n      }\n\n      // Make sure that the browser avoids using inline styles whenever possible\n      this.commands.exec("styleWithCSS", false);\n\n      this._initAutoLinking();\n      this._initObjectResizing();\n      this._initUndoManager();\n\n      // Simulate html5 autofocus on contentEditable element\n      if (this.textarea.element.hasAttribute("autofocus") || document.querySelector(":focus") == this.textarea.element) {\n        setTimeout(function () {\n          that.focus();\n        }, 100);\n      }\n\n      wysihtml5.quirks.insertLineBreakOnReturn(this);\n\n      // IE sometimes leaves a single paragraph, which can\'t be removed by the user\n      if (!browser.clearsContentEditableCorrectly()) {\n        wysihtml5.quirks.ensureProperClearing(this);\n      }\n\n      if (!browser.clearsListsInContentEditableCorrectly()) {\n        wysihtml5.quirks.ensureProperClearingOfLists(this);\n      }\n\n      // Set up a sync that makes sure that textarea and editor have the same content\n      if (this.initSync && this.config.sync) {\n        this.initSync();\n      }\n\n      // Okay hide the textarea, we are ready to go\n      this.textarea.hide();\n\n      // Fire global (before-)load event\n      this.parent.fire("beforeload").fire("load");\n    },\n\n    _initAutoLinking: function _initAutoLinking() {\n      var that = this,\n          supportsDisablingOfAutoLinking = browser.canDisableAutoLinking(),\n          supportsAutoLinking = browser.doesAutoLinkingInContentEditable();\n      if (supportsDisablingOfAutoLinking) {\n        this.commands.exec("autoUrlDetect", false);\n      }\n\n      if (!this.config.autoLink) {\n        return;\n      }\n\n      // Only do the auto linking by ourselves when the browser doesn\'t support auto linking\n      // OR when he supports auto linking but we were able to turn it off (IE9+)\n      if (!supportsAutoLinking || supportsAutoLinking && supportsDisablingOfAutoLinking) {\n        this.parent.observe("newword:composer", function () {\n          that.selection.executeAndRestore(function (startContainer, endContainer) {\n            dom.autoLink(endContainer.parentNode);\n          });\n        });\n      }\n\n      // Assuming we have the following:\n      //  <a href="http://www.google.de">http://www.google.de</a>\n      // If a user now changes the url in the innerHTML we want to make sure that\n      // it\'s synchronized with the href attribute (as long as the innerHTML is still a url)\n      var // Use a live NodeList to check whether there are any links in the document\n      links = this.sandbox.getDocument().getElementsByTagName("a"),\n\n\n      // The autoLink helper method reveals a reg exp to detect correct urls\n      urlRegExp = dom.autoLink.URL_REG_EXP,\n          getTextContent = function getTextContent(element) {\n        var textContent = wysihtml5.lang.string(dom.getTextContent(element)).trim();\n        if (textContent.substr(0, 4) === "www.") {\n          textContent = "http://" + textContent;\n        }\n        return textContent;\n      };\n\n      dom.observe(this.element, "keydown", function (event) {\n        if (!links.length) {\n          return;\n        }\n\n        var selectedNode = that.selection.getSelectedNode(event.target.ownerDocument),\n            link = dom.getParentElement(selectedNode, { nodeName: "A" }, 4),\n            textContent;\n\n        if (!link) {\n          return;\n        }\n\n        textContent = getTextContent(link);\n        // keydown is fired before the actual content is changed\n        // therefore we set a timeout to change the href\n        setTimeout(function () {\n          var newTextContent = getTextContent(link);\n          if (newTextContent === textContent) {\n            return;\n          }\n\n          // Only set href when new href looks like a valid url\n          if (newTextContent.match(urlRegExp)) {\n            link.setAttribute("href", newTextContent);\n          }\n        }, 0);\n      });\n    },\n\n    _initObjectResizing: function _initObjectResizing() {\n      var properties = ["width", "height"],\n          propertiesLength = properties.length,\n          element = this.element;\n\n      this.commands.exec("enableObjectResizing", this.config.allowObjectResizing);\n\n      if (this.config.allowObjectResizing) {\n        // IE sets inline styles after resizing objects\n        // The following lines make sure that the width/height css properties\n        // are copied over to the width/height attributes\n        if (browser.supportsEvent("resizeend")) {\n          dom.observe(element, "resizeend", function (event) {\n            var target = event.target || event.srcElement,\n                style = target.style,\n                i = 0,\n                property;\n            for (; i < propertiesLength; i++) {\n              property = properties[i];\n              if (style[property]) {\n                target.setAttribute(property, parseInt(style[property], 10));\n                style[property] = "";\n              }\n            }\n            // After resizing IE sometimes forgets to remove the old resize handles\n            wysihtml5.quirks.redraw(element);\n          });\n        }\n      } else {\n        if (browser.supportsEvent("resizestart")) {\n          dom.observe(element, "resizestart", function (event) {\n            event.preventDefault();\n          });\n        }\n      }\n    },\n\n    _initUndoManager: function _initUndoManager() {\n      new wysihtml5.UndoManager(this.parent);\n    }\n  });\n})(wysihtml5);(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      doc = document,\n      win = window,\n      HOST_TEMPLATE = doc.createElement("div"),\n\n\n  /**\n   * Styles to copy from textarea to the composer element\n   */\n  TEXT_FORMATTING = ["background-color", "color", "cursor", "font-family", "font-size", "font-style", "font-variant", "font-weight", "line-height", "letter-spacing", "text-align", "text-decoration", "text-indent", "text-rendering", "word-break", "word-wrap", "word-spacing"],\n\n\n  /**\n   * Styles to copy from textarea to the iframe\n   */\n  BOX_FORMATTING = ["background-color", "border-collapse", "border-bottom-color", "border-bottom-style", "border-bottom-width", "border-left-color", "border-left-style", "border-left-width", "border-right-color", "border-right-style", "border-right-width", "border-top-color", "border-top-style", "border-top-width", "clear", "display", "float", "margin-bottom", "margin-left", "margin-right", "margin-top", "outline-color", "outline-offset", "outline-width", "outline-style", "padding-left", "padding-right", "padding-top", "padding-bottom", "position", "top", "left", "right", "bottom", "z-index", "vertical-align", "text-align", "-webkit-box-sizing", "-moz-box-sizing", "-ms-box-sizing", "box-sizing", "-webkit-box-shadow", "-moz-box-shadow", "-ms-box-shadow", "box-shadow", "-webkit-border-top-right-radius", "-moz-border-radius-topright", "border-top-right-radius", "-webkit-border-bottom-right-radius", "-moz-border-radius-bottomright", "border-bottom-right-radius", "-webkit-border-bottom-left-radius", "-moz-border-radius-bottomleft", "border-bottom-left-radius", "-webkit-border-top-left-radius", "-moz-border-radius-topleft", "border-top-left-radius", "width", "height"],\n\n\n  /**\n   * Styles to sync while the window gets resized\n   */\n  RESIZE_STYLE = ["width", "height", "top", "left", "right", "bottom"],\n      ADDITIONAL_CSS_RULES = ["html             { height: 100%; }", "body             { min-height: 100%; padding: 0; margin: 0; margin-top: -1px; padding-top: 1px; white-space: pre-wrap; }", "._wysihtml5-temp { display: none; }", wysihtml5.browser.isGecko ? "body.placeholder { color: graytext !important; }" : "body.placeholder { color: #a9a9a9 !important; }", "body[disabled]   { background-color: #eee !important; color: #999 !important; cursor: default !important; }",\n  // Ensure that user see\'s broken images and can delete them\n  "img:-moz-broken  { -moz-force-broken-image-icon: 1; height: 24px; width: 24px; }"];\n\n  /**\n   * With "setActive" IE offers a smart way of focusing elements without scrolling them into view:\n   * http://msdn.microsoft.com/en-us/library/ms536738(v=vs.85).aspx\n   *\n   * Other browsers need a more hacky way: (pssst don\'t tell my mama)\n   * In order to prevent the element being scrolled into view when focusing it, we simply\n   * move it out of the scrollable area, focus it, and reset it\'s position\n   */\n  var focusWithoutScrolling = function focusWithoutScrolling(element) {\n    if (element.setActive) {\n      // Following line could cause a js error when the textarea is invisible\n      // See https://github.com/xing/wysihtml5/issues/9\n      try {\n        element.setActive();\n      } catch (e) {}\n    } else {\n      var elementStyle = element.style,\n          originalScrollTop = doc.documentElement.scrollTop || doc.body.scrollTop,\n          originalScrollLeft = doc.documentElement.scrollLeft || doc.body.scrollLeft,\n          originalStyles = {\n        position: elementStyle.position,\n        top: elementStyle.top,\n        left: elementStyle.left,\n        WebkitUserSelect: elementStyle.WebkitUserSelect\n      };\n\n      dom.setStyles({\n        position: "absolute",\n        top: "-99999px",\n        left: "-99999px",\n        // Don\'t ask why but temporarily setting -webkit-user-select to none makes the whole thing performing smoother\n        WebkitUserSelect: "none"\n      }).on(element);\n\n      element.focus();\n\n      dom.setStyles(originalStyles).on(element);\n\n      if (win.scrollTo) {\n        // Some browser extensions unset this method to prevent annoyances\n        // "Better PopUp Blocker" for Chrome http://code.google.com/p/betterpopupblocker/source/browse/trunk/blockStart.js#100\n        // Issue: http://code.google.com/p/betterpopupblocker/issues/detail?id=1\n        win.scrollTo(originalScrollLeft, originalScrollTop);\n      }\n    }\n  };\n\n  wysihtml5.views.Composer.prototype.style = function () {\n    var that = this,\n        originalActiveElement = doc.querySelector(":focus"),\n        textareaElement = this.textarea.element,\n        hasPlaceholder = textareaElement.hasAttribute("placeholder"),\n        originalPlaceholder = hasPlaceholder && textareaElement.getAttribute("placeholder");\n    this.focusStylesHost = this.focusStylesHost || HOST_TEMPLATE.cloneNode(false);\n    this.blurStylesHost = this.blurStylesHost || HOST_TEMPLATE.cloneNode(false);\n\n    // Remove placeholder before copying (as the placeholder has an affect on the computed style)\n    if (hasPlaceholder) {\n      textareaElement.removeAttribute("placeholder");\n    }\n\n    if (textareaElement === originalActiveElement) {\n      textareaElement.blur();\n    }\n\n    // --------- iframe styles (has to be set before editor styles, otherwise IE9 sets wrong fontFamily on blurStylesHost) ---------\n    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.iframe).andTo(this.blurStylesHost);\n\n    // --------- editor styles ---------\n    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.element).andTo(this.blurStylesHost);\n\n    // --------- apply standard rules ---------\n    dom.insertCSS(ADDITIONAL_CSS_RULES).into(this.element.ownerDocument);\n\n    // --------- :focus styles ---------\n    focusWithoutScrolling(textareaElement);\n    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.focusStylesHost);\n    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.focusStylesHost);\n\n    // Make sure that we don\'t change the display style of the iframe when copying styles oblur/onfocus\n    // this is needed for when the change_view event is fired where the iframe is hidden and then\n    // the blur event fires and re-displays it\n    var boxFormattingStyles = wysihtml5.lang.array(BOX_FORMATTING).without(["display"]);\n\n    // --------- restore focus ---------\n    if (originalActiveElement) {\n      originalActiveElement.focus();\n    } else {\n      textareaElement.blur();\n    }\n\n    // --------- restore placeholder ---------\n    if (hasPlaceholder) {\n      textareaElement.setAttribute("placeholder", originalPlaceholder);\n    }\n\n    // When copying styles, we only get the computed style which is never returned in percent unit\n    // Therefore we\'ve to recalculate style onresize\n    if (!wysihtml5.browser.hasCurrentStyleProperty()) {\n      var winObserver = dom.observe(win, "resize", function () {\n        // Remove event listener if composer doesn\'t exist anymore\n        if (!dom.contains(document.documentElement, that.iframe)) {\n          winObserver.stop();\n          return;\n        }\n        var originalTextareaDisplayStyle = dom.getStyle("display").from(textareaElement),\n            originalComposerDisplayStyle = dom.getStyle("display").from(that.iframe);\n        textareaElement.style.display = "";\n        that.iframe.style.display = "none";\n        dom.copyStyles(RESIZE_STYLE).from(textareaElement).to(that.iframe).andTo(that.focusStylesHost).andTo(that.blurStylesHost);\n        that.iframe.style.display = originalComposerDisplayStyle;\n        textareaElement.style.display = originalTextareaDisplayStyle;\n      });\n    }\n\n    // --------- Sync focus/blur styles ---------\n    this.parent.observe("focus:composer", function () {\n      dom.copyStyles(boxFormattingStyles).from(that.focusStylesHost).to(that.iframe);\n      dom.copyStyles(TEXT_FORMATTING).from(that.focusStylesHost).to(that.element);\n    });\n\n    this.parent.observe("blur:composer", function () {\n      dom.copyStyles(boxFormattingStyles).from(that.blurStylesHost).to(that.iframe);\n      dom.copyStyles(TEXT_FORMATTING).from(that.blurStylesHost).to(that.element);\n    });\n\n    return this;\n  };\n})(wysihtml5); /**\n               * Taking care of events\n               *  - Simulating \'change\' event on contentEditable element\n               *  - Handling drag & drop logic\n               *  - Catch paste events\n               *  - Dispatch proprietary newword:composer event\n               *  - Keyboard shortcuts\n               */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      browser = wysihtml5.browser,\n\n\n  /**\n   * Map keyCodes to query commands\n   */\n  shortcuts = {\n    "66": "bold", // B\n    "73": "italic", // I\n    "85": "underline" // U\n  };\n\n  wysihtml5.views.Composer.prototype.observe = function () {\n    var that = this,\n        state = this.getValue(),\n        iframe = this.sandbox.getIframe(),\n        element = this.element,\n        focusBlurElement = browser.supportsEventsInIframeCorrectly() ? element : this.sandbox.getWindow(),\n\n\n    // Firefox < 3.5 doesn\'t support the drop event, instead it supports a so called "dragdrop" event which behaves almost the same\n    pasteEvents = browser.supportsEvent("drop") ? ["drop", "paste"] : ["dragdrop", "paste"];\n\n    // --------- destroy:composer event ---------\n    dom.observe(iframe, "DOMNodeRemoved", function () {\n      clearInterval(domNodeRemovedInterval);\n      that.parent.fire("destroy:composer");\n    });\n\n    // DOMNodeRemoved event is not supported in IE 8\n    var domNodeRemovedInterval = setInterval(function () {\n      if (!dom.contains(document.documentElement, iframe)) {\n        clearInterval(domNodeRemovedInterval);\n        that.parent.fire("destroy:composer");\n      }\n    }, 250);\n\n    // --------- Focus & blur logic ---------\n    dom.observe(focusBlurElement, "focus", function () {\n      that.parent.fire("focus").fire("focus:composer");\n\n      // Delay storing of state until all focus handler are fired\n      // especially the one which resets the placeholder\n      setTimeout(function () {\n        state = that.getValue();\n      }, 0);\n    });\n\n    dom.observe(focusBlurElement, "blur", function () {\n      if (state !== that.getValue()) {\n        that.parent.fire("change").fire("change:composer");\n      }\n      that.parent.fire("blur").fire("blur:composer");\n    });\n\n    if (wysihtml5.browser.isIos()) {\n      // When on iPad/iPhone/IPod after clicking outside of editor, the editor loses focus\n      // but the UI still acts as if the editor has focus (blinking caret and onscreen keyboard visible)\n      // We prevent that by focusing a temporary input element which immediately loses focus\n      dom.observe(element, "blur", function () {\n        var input = element.ownerDocument.createElement("input"),\n            originalScrollTop = document.documentElement.scrollTop || document.body.scrollTop,\n            originalScrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n        try {\n          that.selection.insertNode(input);\n        } catch (e) {\n          element.appendChild(input);\n        }\n        input.focus();\n        input.parentNode.removeChild(input);\n\n        window.scrollTo(originalScrollLeft, originalScrollTop);\n      });\n    }\n\n    // --------- Drag & Drop logic ---------\n    dom.observe(element, "dragenter", function () {\n      that.parent.fire("unset_placeholder");\n    });\n\n    if (browser.firesOnDropOnlyWhenOnDragOverIsCancelled()) {\n      dom.observe(element, ["dragover", "dragenter"], function (event) {\n        event.preventDefault();\n      });\n    }\n\n    dom.observe(element, pasteEvents, function (event) {\n      var dataTransfer = event.dataTransfer,\n          data;\n\n      if (dataTransfer && browser.supportsDataTransfer()) {\n        data = dataTransfer.getData("text/html") || dataTransfer.getData("text/plain");\n      }\n      if (data) {\n        element.focus();\n        that.commands.exec("insertHTML", data);\n        that.parent.fire("paste").fire("paste:composer");\n        event.stopPropagation();\n        event.preventDefault();\n      } else {\n        setTimeout(function () {\n          that.parent.fire("paste").fire("paste:composer");\n        }, 0);\n      }\n    });\n\n    // --------- neword event ------+---\n    dom.observe(element, "keyup", function (event) {\n      var keyCode = event.keyCode;\n      if (keyCode === wysihtml5.ENTER_KEY) {\n        that.parent.fire("newword:composer");\n      }\n    });\n\n    this.parent.observe("paste:composer", function () {\n      setTimeout(function () {\n        that.parent.fire("newword:composer");\n      }, 0);\n    });\n\n    // --------- Make sure that images are selected when clicking on them ---------\n    if (!browser.canSelectImagesInContentEditable()) {\n      dom.observe(element, "mousedown", function (event) {\n        var target = event.target;\n        if (target.nodeName === "IMG") {\n          that.selection.selectNode(target);\n          event.preventDefault();\n        }\n      });\n    }\n\n    // --------- Shortcut logic ---------\n    dom.observe(element, "keydown", function (event) {\n      var keyCode = event.keyCode,\n          command = shortcuts[keyCode];\n      if ((event.ctrlKey || event.metaKey) && !event.altKey && command) {\n        that.commands.exec(command);\n        event.preventDefault();\n      }\n    });\n\n    // --------- Make sure that when pressing backspace/delete on selected images deletes the image and it\'s anchor ---------\n    dom.observe(element, "keydown", function (event) {\n      var target = that.selection.getSelectedNode(true),\n          keyCode = event.keyCode,\n          parent;\n      if (target && target.nodeName === "IMG" && (keyCode === wysihtml5.BACKSPACE_KEY || keyCode === wysihtml5.DELETE_KEY)) {\n        // 8 => backspace, 46 => delete\n        parent = target.parentNode;\n        // delete the <img>\n        parent.removeChild(target);\n        // and it\'s parent <a> too if it hasn\'t got any other child nodes\n        if (parent.nodeName === "A" && !parent.firstChild) {\n          parent.parentNode.removeChild(parent);\n        }\n\n        setTimeout(function () {\n          wysihtml5.quirks.redraw(element);\n        }, 0);\n        event.preventDefault();\n      }\n    });\n\n    // --------- Show url in tooltip when hovering links or images ---------\n    var titlePrefixes = {\n      IMG: "Image: ",\n      A: "Link: "\n    };\n\n    dom.observe(element, "mouseover", function (event) {\n      var target = event.target,\n          nodeName = target.nodeName,\n          title;\n      if (nodeName !== "A" && nodeName !== "IMG") {\n        return;\n      }\n      var hasTitle = target.hasAttribute("title");\n      if (!hasTitle) {\n        title = titlePrefixes[nodeName] + (target.getAttribute("href") || target.getAttribute("src"));\n        target.setAttribute("title", title);\n      }\n    });\n  };\n})(wysihtml5); /**\n               * Class that takes care that the value of the composer and the textarea is always in sync\n               */\n(function (wysihtml5) {\n  var INTERVAL = 400;\n\n  wysihtml5.views.Synchronizer = Base.extend(\n  /** @scope wysihtml5.views.Synchronizer.prototype */{\n\n    constructor: function constructor(editor, textarea, composer) {\n      this.editor = editor;\n      this.textarea = textarea;\n      this.composer = composer;\n\n      this._observe();\n    },\n\n    /**\n     * Sync html from composer to textarea\n     * Takes care of placeholders\n     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the textarea\n     */\n    fromComposerToTextarea: function fromComposerToTextarea(shouldParseHtml) {\n      this.textarea.setValue(wysihtml5.lang.string(this.composer.getValue()).trim(), shouldParseHtml);\n    },\n\n    /**\n     * Sync value of textarea to composer\n     * Takes care of placeholders\n     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the composer\n     */\n    fromTextareaToComposer: function fromTextareaToComposer(shouldParseHtml) {\n      var textareaValue = this.textarea.getValue();\n      if (textareaValue) {\n        this.composer.setValue(textareaValue, shouldParseHtml);\n      } else {\n        this.composer.clear();\n        this.editor.fire("set_placeholder");\n      }\n    },\n\n    /**\n     * Invoke syncing based on view state\n     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the composer/textarea\n     */\n    sync: function sync(shouldParseHtml) {\n      if (this.editor.currentView.name === "textarea") {\n        this.fromTextareaToComposer(shouldParseHtml);\n      } else {\n        this.fromComposerToTextarea(shouldParseHtml);\n      }\n    },\n\n    /**\n     * Initializes interval-based syncing\n     * also makes sure that on-submit the composer\'s content is synced with the textarea\n     * immediately when the form gets submitted\n     */\n    _observe: function _observe() {\n      var interval,\n          that = this,\n          form = this.textarea.element.form,\n          startInterval = function startInterval() {\n        interval = setInterval(function () {\n          that.fromComposerToTextarea();\n        }, INTERVAL);\n      },\n          stopInterval = function stopInterval() {\n        clearInterval(interval);\n        interval = null;\n      };\n\n      startInterval();\n\n      if (form) {\n        // If the textarea is in a form make sure that after onreset and onsubmit the composer\n        // has the correct state\n        wysihtml5.dom.observe(form, "submit", function () {\n          that.sync(true);\n        });\n        wysihtml5.dom.observe(form, "reset", function () {\n          setTimeout(function () {\n            that.fromTextareaToComposer();\n          }, 0);\n        });\n      }\n\n      this.editor.observe("change_view", function (view) {\n        if (view === "composer" && !interval) {\n          that.fromTextareaToComposer(true);\n          startInterval();\n        } else if (view === "textarea") {\n          that.fromComposerToTextarea(true);\n          stopInterval();\n        }\n      });\n\n      this.editor.observe("destroy:composer", stopInterval);\n    }\n  });\n})(wysihtml5);\nwysihtml5.views.Textarea = wysihtml5.views.View.extend(\n/** @scope wysihtml5.views.Textarea.prototype */{\n  name: "textarea",\n\n  constructor: function constructor(parent, textareaElement, config) {\n    this.base(parent, textareaElement, config);\n\n    this._observe();\n  },\n\n  clear: function clear() {\n    this.element.value = "";\n  },\n\n  getValue: function getValue(parse) {\n    var value = this.isEmpty() ? "" : this.element.value;\n    if (parse) {\n      value = this.parent.parse(value);\n    }\n    return value;\n  },\n\n  setValue: function setValue(html, parse) {\n    if (parse) {\n      html = this.parent.parse(html);\n    }\n    this.element.value = html;\n  },\n\n  hasPlaceholderSet: function hasPlaceholderSet() {\n    var supportsPlaceholder = wysihtml5.browser.supportsPlaceholderAttributeOn(this.element),\n        placeholderText = this.element.getAttribute("placeholder") || null,\n        value = this.element.value,\n        isEmpty = !value;\n    return supportsPlaceholder && isEmpty || value === placeholderText;\n  },\n\n  isEmpty: function isEmpty() {\n    return !wysihtml5.lang.string(this.element.value).trim() || this.hasPlaceholderSet();\n  },\n\n  _observe: function _observe() {\n    var element = this.element,\n        parent = this.parent,\n        eventMapping = {\n      focusin: "focus",\n      focusout: "blur"\n    },\n\n\n    /**\n     * Calling focus() or blur() on an element doesn\'t synchronously trigger the attached focus/blur events\n     * This is the case for focusin and focusout, so let\'s use them whenever possible, kkthxbai\n     */\n    events = wysihtml5.browser.supportsEvent("focusin") ? ["focusin", "focusout", "change"] : ["focus", "blur", "change"];\n\n    parent.observe("beforeload", function () {\n      wysihtml5.dom.observe(element, events, function (event) {\n        var eventName = eventMapping[event.type] || event.type;\n        parent.fire(eventName).fire(eventName + ":textarea");\n      });\n\n      wysihtml5.dom.observe(element, ["paste", "drop"], function () {\n        setTimeout(function () {\n          parent.fire("paste").fire("paste:textarea");\n        }, 0);\n      });\n    });\n  }\n}); /**\n    * Toolbar Dialog\n    *\n    * @param {Element} link The toolbar link which causes the dialog to show up\n    * @param {Element} container The dialog container\n    *\n    * @example\n    *    \x3c!-- Toolbar link --\x3e\n    *    <a data-wysihtml5-command="insertImage">insert an image</a>\n    *\n    *    \x3c!-- Dialog --\x3e\n    *    <div data-wysihtml5-dialog="insertImage" style="display: none;">\n    *      <label>\n    *        URL: <input data-wysihtml5-dialog-field="src" value="http://">\n    *      </label>\n    *      <label>\n    *        Alternative text: <input data-wysihtml5-dialog-field="alt" value="">\n    *      </label>\n    *    </div>\n    *\n    *    <script>\n    *      var dialog = new wysihtml5.toolbar.Dialog(\n    *        document.querySelector("[data-wysihtml5-command=\'insertImage\']"),\n    *        document.querySelector("[data-wysihtml5-dialog=\'insertImage\']")\n    *      );\n    *      dialog.observe("save", function(attributes) {\n    *        // do something\n    *      });\n    *    <\/script>\n    */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      CLASS_NAME_OPENED = "wysihtml5-command-dialog-opened",\n      SELECTOR_FORM_ELEMENTS = "input, select, textarea",\n      SELECTOR_FIELDS = "[data-wysihtml5-dialog-field]",\n      ATTRIBUTE_FIELDS = "data-wysihtml5-dialog-field";\n\n  wysihtml5.toolbar.Dialog = wysihtml5.lang.Dispatcher.extend(\n  /** @scope wysihtml5.toolbar.Dialog.prototype */{\n    constructor: function constructor(link, container) {\n      this.link = link;\n      this.container = container;\n    },\n\n    _observe: function _observe() {\n      if (this._observed) {\n        return;\n      }\n\n      var that = this,\n          callbackWrapper = function callbackWrapper(event) {\n        var attributes = that._serialize();\n        if (attributes == that.elementToChange) {\n          that.fire("edit", attributes);\n        } else {\n          that.fire("save", attributes);\n        }\n        that.hide();\n        event.preventDefault();\n        event.stopPropagation();\n      };\n\n      dom.observe(that.link, "click", function (event) {\n        if (dom.hasClass(that.link, CLASS_NAME_OPENED)) {\n          setTimeout(function () {\n            that.hide();\n          }, 0);\n        }\n      });\n\n      dom.observe(this.container, "keydown", function (event) {\n        var keyCode = event.keyCode;\n        if (keyCode === wysihtml5.ENTER_KEY) {\n          callbackWrapper(event);\n        }\n        if (keyCode === wysihtml5.ESCAPE_KEY) {\n          // that.hide();\n        }\n      });\n\n      dom.delegate(this.container, "[data-wysihtml5-dialog-action=save]", "click", callbackWrapper);\n\n      dom.delegate(this.container, "[data-wysihtml5-dialog-action=cancel]", "click", function (event) {\n        that.fire("cancel");\n        that.hide();\n        event.preventDefault();\n        event.stopPropagation();\n      });\n\n      var formElements = this.container.querySelectorAll(SELECTOR_FORM_ELEMENTS),\n          i = 0,\n          length = formElements.length,\n          _clearInterval = function _clearInterval() {\n        clearInterval(that.interval);\n      };\n      for (; i < length; i++) {\n        dom.observe(formElements[i], "change", _clearInterval);\n      }\n\n      this._observed = true;\n    },\n\n    /**\n     * Grabs all fields in the dialog and puts them in key=>value style in an object which\n     * then gets returned\n     */\n    _serialize: function _serialize() {\n      var data = this.elementToChange || {},\n          fields = this.container.querySelectorAll(SELECTOR_FIELDS),\n          length = fields.length,\n          i = 0;\n      for (; i < length; i++) {\n        data[fields[i].getAttribute(ATTRIBUTE_FIELDS)] = fields[i].value;\n      }\n      return data;\n    },\n\n    /**\n     * Takes the attributes of the "elementToChange"\n     * and inserts them in their corresponding dialog input fields\n     * \n     * Assume the "elementToChange" looks like this:\n     *    <a href="http://www.google.com" target="_blank">foo</a>\n     *\n     * and we have the following dialog:\n     *    <input type="text" data-wysihtml5-dialog-field="href" value="">\n     *    <input type="text" data-wysihtml5-dialog-field="target" value="">\n     * \n     * after calling _interpolate() the dialog will look like this\n     *    <input type="text" data-wysihtml5-dialog-field="href" value="http://www.google.com">\n     *    <input type="text" data-wysihtml5-dialog-field="target" value="_blank">\n     *\n     * Basically it adopted the attribute values into the corresponding input fields\n     *\n     */\n    _interpolate: function _interpolate(avoidHiddenFields) {\n      var field,\n          fieldName,\n          newValue,\n          focusedElement = document.querySelector(":focus"),\n          fields = this.container.querySelectorAll(SELECTOR_FIELDS),\n          length = fields.length,\n          i = 0;\n      for (; i < length; i++) {\n        field = fields[i];\n\n        // Never change elements where the user is currently typing in\n        if (field === focusedElement) {\n          continue;\n        }\n\n        // Don\'t update hidden fields\n        // See https://github.com/xing/wysihtml5/pull/14\n        if (avoidHiddenFields && field.type === "hidden") {\n          continue;\n        }\n\n        fieldName = field.getAttribute(ATTRIBUTE_FIELDS);\n        newValue = this.elementToChange ? this.elementToChange[fieldName] || "" : field.defaultValue;\n        field.value = newValue;\n      }\n    },\n\n    /**\n     * Show the dialog element\n     */\n    show: function show(elementToChange) {\n      var that = this,\n          firstField = this.container.querySelector(SELECTOR_FORM_ELEMENTS);\n      this.elementToChange = elementToChange;\n      this._observe();\n      this._interpolate();\n      if (elementToChange) {\n        this.interval = setInterval(function () {\n          that._interpolate(true);\n        }, 500);\n      }\n      dom.addClass(this.link, CLASS_NAME_OPENED);\n      this.container.style.display = "";\n      this.fire("show");\n      if (firstField && !elementToChange) {\n        try {\n          firstField.focus();\n        } catch (e) {}\n      }\n    },\n\n    /**\n     * Hide the dialog element\n     */\n    hide: function hide() {\n      clearInterval(this.interval);\n      this.elementToChange = null;\n      dom.removeClass(this.link, CLASS_NAME_OPENED);\n      this.container.style.display = "none";\n      this.fire("hide");\n    }\n  });\n})(wysihtml5);\n/**\n * Converts speech-to-text and inserts this into the editor\n * As of now (2011/03/25) this only is supported in Chrome >= 11\n *\n * Note that it sends the recorded audio to the google speech recognition api:\n * http://stackoverflow.com/questions/4361826/does-chrome-have-buil-in-speech-recognition-for-input-type-text-x-webkit-speec\n *\n * Current HTML5 draft can be found here\n * http://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Feb/att-0020/api-draft.html\n * \n * "Accessing Google Speech API Chrome 11"\n * http://mikepultz.com/2011/03/accessing-google-speech-api-chrome-11/\n */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom;\n\n  var linkStyles = {\n    position: "relative"\n  };\n\n  var wrapperStyles = {\n    left: 0,\n    margin: 0,\n    opacity: 0,\n    overflow: "hidden",\n    padding: 0,\n    position: "absolute",\n    top: 0,\n    zIndex: 1\n  };\n\n  var inputStyles = {\n    cursor: "inherit",\n    fontSize: "50px",\n    height: "50px",\n    marginTop: "-25px",\n    outline: 0,\n    padding: 0,\n    position: "absolute",\n    right: "-4px",\n    top: "50%"\n  };\n\n  var inputAttributes = {\n    "x-webkit-speech": "",\n    "speech": ""\n  };\n\n  wysihtml5.toolbar.Speech = function (parent, link) {\n    var input = document.createElement("input");\n    if (!wysihtml5.browser.supportsSpeechApiOn(input)) {\n      link.style.display = "none";\n      return;\n    }\n\n    var wrapper = document.createElement("div");\n\n    wysihtml5.lang.object(wrapperStyles).merge({\n      width: link.offsetWidth + "px",\n      height: link.offsetHeight + "px"\n    });\n\n    dom.insert(input).into(wrapper);\n    dom.insert(wrapper).into(link);\n\n    dom.setStyles(inputStyles).on(input);\n    dom.setAttributes(inputAttributes).on(input);\n\n    dom.setStyles(wrapperStyles).on(wrapper);\n    dom.setStyles(linkStyles).on(link);\n\n    var eventName = "onwebkitspeechchange" in input ? "webkitspeechchange" : "speechchange";\n    dom.observe(input, eventName, function () {\n      parent.execCommand("insertText", input.value);\n      input.value = "";\n    });\n\n    dom.observe(input, "click", function (event) {\n      if (dom.hasClass(link, "wysihtml5-command-disabled")) {\n        event.preventDefault();\n      }\n\n      event.stopPropagation();\n    });\n  };\n})(wysihtml5); /**\n               * Toolbar\n               *\n               * @param {Object} parent Reference to instance of Editor instance\n               * @param {Element} container Reference to the toolbar container element\n               *\n               * @example\n               *    <div id="toolbar">\n               *      <a data-wysihtml5-command="createLink">insert link</a>\n               *      <a data-wysihtml5-command="formatBlock" data-wysihtml5-command-value="h1">insert h1</a>\n               *    </div>\n               *\n               *    <script>\n               *      var toolbar = new wysihtml5.toolbar.Toolbar(editor, document.getElementById("toolbar"));\n               *    <\/script>\n               */\n(function (wysihtml5) {\n  var CLASS_NAME_COMMAND_DISABLED = "wysihtml5-command-disabled",\n      CLASS_NAME_COMMANDS_DISABLED = "wysihtml5-commands-disabled",\n      CLASS_NAME_COMMAND_ACTIVE = "wysihtml5-command-active",\n      CLASS_NAME_ACTION_ACTIVE = "wysihtml5-action-active",\n      dom = wysihtml5.dom;\n\n  wysihtml5.toolbar.Toolbar = Base.extend(\n  /** @scope wysihtml5.toolbar.Toolbar.prototype */{\n    constructor: function constructor(editor, container) {\n      this.editor = editor;\n      this.container = typeof container === "string" ? document.getElementById(container) : container;\n      this.composer = editor.composer;\n\n      this._getLinks("command");\n      this._getLinks("action");\n\n      this._observe();\n      this.show();\n\n      var speechInputLinks = this.container.querySelectorAll("[data-wysihtml5-command=insertSpeech]"),\n          length = speechInputLinks.length,\n          i = 0;\n      for (; i < length; i++) {\n        new wysihtml5.toolbar.Speech(this, speechInputLinks[i]);\n      }\n    },\n\n    _getLinks: function _getLinks(type) {\n      var links = this[type + "Links"] = wysihtml5.lang.array(this.container.querySelectorAll("[data-wysihtml5-" + type + "]")).get(),\n          length = links.length,\n          i = 0,\n          mapping = this[type + "Mapping"] = {},\n          link,\n          group,\n          name,\n          value,\n          dialog;\n      for (; i < length; i++) {\n        link = links[i];\n        name = link.getAttribute("data-wysihtml5-" + type);\n        value = link.getAttribute("data-wysihtml5-" + type + "-value");\n        group = this.container.querySelector("[data-wysihtml5-" + type + "-group=\'" + name + "\']");\n        dialog = this._getDialog(link, name);\n\n        mapping[name + ":" + value] = {\n          link: link,\n          group: group,\n          name: name,\n          value: value,\n          dialog: dialog,\n          state: false\n        };\n      }\n    },\n\n    _getDialog: function _getDialog(link, command) {\n      var that = this,\n          dialogElement = this.container.querySelector("[data-wysihtml5-dialog=\'" + command + "\']"),\n          dialog,\n          caretBookmark;\n\n      if (dialogElement) {\n        dialog = new wysihtml5.toolbar.Dialog(link, dialogElement);\n\n        dialog.observe("show", function () {\n          caretBookmark = that.composer.selection.getBookmark();\n\n          that.editor.fire("show:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });\n        });\n\n        dialog.observe("save", function (attributes) {\n          if (caretBookmark) {\n            that.composer.selection.setBookmark(caretBookmark);\n          }\n          that._execCommand(command, attributes);\n\n          that.editor.fire("save:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });\n        });\n\n        dialog.observe("cancel", function () {\n          that.editor.focus(false);\n          that.editor.fire("cancel:dialog", { command: command, dialogContainer: dialogElement, commandLink: link });\n        });\n      }\n      return dialog;\n    },\n\n    /**\n     * @example\n     *    var toolbar = new wysihtml5.Toolbar();\n     *    // Insert a <blockquote> element or wrap current selection in <blockquote>\n     *    toolbar.execCommand("formatBlock", "blockquote");\n     */\n    execCommand: function execCommand(command, commandValue) {\n      if (this.commandsDisabled) {\n        return;\n      }\n\n      var commandObj = this.commandMapping[command + ":" + commandValue];\n\n      // Show dialog when available\n      if (commandObj && commandObj.dialog && !commandObj.state) {\n        commandObj.dialog.show();\n      } else {\n        this._execCommand(command, commandValue);\n      }\n    },\n\n    _execCommand: function _execCommand(command, commandValue) {\n      // Make sure that composer is focussed (false => don\'t move caret to the end)\n      this.editor.focus(false);\n\n      this.composer.commands.exec(command, commandValue);\n      this._updateLinkStates();\n    },\n\n    execAction: function execAction(action) {\n      var editor = this.editor;\n      switch (action) {\n        case "change_view":\n          if (editor.currentView === editor.textarea) {\n            editor.fire("change_view", "composer");\n          } else {\n            editor.fire("change_view", "textarea");\n          }\n          break;\n      }\n    },\n\n    _observe: function _observe() {\n      var that = this,\n          editor = this.editor,\n          container = this.container,\n          links = this.commandLinks.concat(this.actionLinks),\n          length = links.length,\n          i = 0;\n\n      for (; i < length; i++) {\n        // \'javascript:;\' and unselectable=on Needed for IE, but done in all browsers to make sure that all get the same css applied\n        // (you know, a:link { ... } doesn\'t match anchors with missing href attribute)\n        dom.setAttributes({\n          href: "javascript:;",\n          unselectable: "on"\n        }).on(links[i]);\n      }\n\n      // Needed for opera\n      dom.delegate(container, "[data-wysihtml5-command]", "mousedown", function (event) {\n        event.preventDefault();\n      });\n\n      dom.delegate(container, "[data-wysihtml5-command]", "click", function (event) {\n        var link = this,\n            command = link.getAttribute("data-wysihtml5-command"),\n            commandValue = link.getAttribute("data-wysihtml5-command-value");\n        that.execCommand(command, commandValue);\n        event.preventDefault();\n      });\n\n      dom.delegate(container, "[data-wysihtml5-action]", "click", function (event) {\n        var action = this.getAttribute("data-wysihtml5-action");\n        that.execAction(action);\n        event.preventDefault();\n      });\n\n      editor.observe("focus:composer", function () {\n        that.bookmark = null;\n        clearInterval(that.interval);\n        that.interval = setInterval(function () {\n          that._updateLinkStates();\n        }, 500);\n      });\n\n      editor.observe("blur:composer", function () {\n        clearInterval(that.interval);\n      });\n\n      editor.observe("destroy:composer", function () {\n        clearInterval(that.interval);\n      });\n\n      editor.observe("change_view", function (currentView) {\n        // Set timeout needed in order to let the blur event fire first\n        setTimeout(function () {\n          that.commandsDisabled = currentView !== "composer";\n          that._updateLinkStates();\n          if (that.commandsDisabled) {\n            dom.addClass(container, CLASS_NAME_COMMANDS_DISABLED);\n          } else {\n            dom.removeClass(container, CLASS_NAME_COMMANDS_DISABLED);\n          }\n        }, 0);\n      });\n    },\n\n    _updateLinkStates: function _updateLinkStates() {\n      var element = this.composer.element,\n          commandMapping = this.commandMapping,\n          actionMapping = this.actionMapping,\n          i,\n          state,\n          action,\n          command;\n      // every millisecond counts... this is executed quite often\n      for (i in commandMapping) {\n        command = commandMapping[i];\n        if (this.commandsDisabled) {\n          state = false;\n          dom.removeClass(command.link, CLASS_NAME_COMMAND_ACTIVE);\n          if (command.group) {\n            dom.removeClass(command.group, CLASS_NAME_COMMAND_ACTIVE);\n          }\n          if (command.dialog) {\n            command.dialog.hide();\n          }\n        } else {\n          state = this.composer.commands.state(command.name, command.value);\n          if (wysihtml5.lang.object(state).isArray()) {\n            // Grab first and only object/element in state array, otherwise convert state into boolean\n            // to avoid showing a dialog for multiple selected elements which may have different attributes\n            // eg. when two links with different href are selected, the state will be an array consisting of both link elements\n            // but the dialog interface can only update one\n            state = state.length === 1 ? state[0] : true;\n          }\n          dom.removeClass(command.link, CLASS_NAME_COMMAND_DISABLED);\n          if (command.group) {\n            dom.removeClass(command.group, CLASS_NAME_COMMAND_DISABLED);\n          }\n        }\n\n        if (command.state === state) {\n          continue;\n        }\n\n        command.state = state;\n        if (state) {\n          dom.addClass(command.link, CLASS_NAME_COMMAND_ACTIVE);\n          if (command.group) {\n            dom.addClass(command.group, CLASS_NAME_COMMAND_ACTIVE);\n          }\n          if (command.dialog) {\n            if ((typeof state === "undefined" ? "undefined" : _typeof(state)) === "object") {\n              command.dialog.show(state);\n            } else {\n              command.dialog.hide();\n            }\n          }\n        } else {\n          dom.removeClass(command.link, CLASS_NAME_COMMAND_ACTIVE);\n          if (command.group) {\n            dom.removeClass(command.group, CLASS_NAME_COMMAND_ACTIVE);\n          }\n          if (command.dialog) {\n            command.dialog.hide();\n          }\n        }\n      }\n\n      for (i in actionMapping) {\n        action = actionMapping[i];\n\n        if (action.name === "change_view") {\n          action.state = this.editor.currentView === this.editor.textarea;\n          if (action.state) {\n            dom.addClass(action.link, CLASS_NAME_ACTION_ACTIVE);\n          } else {\n            dom.removeClass(action.link, CLASS_NAME_ACTION_ACTIVE);\n          }\n        }\n      }\n    },\n\n    show: function show() {\n      this.container.style.display = "";\n    },\n\n    hide: function hide() {\n      this.container.style.display = "none";\n    }\n  });\n})(wysihtml5);\n/**\n * WYSIHTML5 Editor\n *\n * @param {Element} textareaElement Reference to the textarea which should be turned into a rich text interface\n * @param {Object} [config] See defaultConfig object below for explanation of each individual config option\n *\n * @events\n *    load\n *    beforeload (for internal use only)\n *    focus\n *    focus:composer\n *    focus:textarea\n *    blur\n *    blur:composer\n *    blur:textarea\n *    change\n *    change:composer\n *    change:textarea\n *    paste\n *    paste:composer\n *    paste:textarea\n *    newword:composer\n *    destroy:composer\n *    undo:composer\n *    redo:composer\n *    beforecommand:composer\n *    aftercommand:composer\n *    change_view\n */\n(function (wysihtml5) {\n  var undef;\n\n  var defaultConfig = {\n    // Give the editor a name, the name will also be set as class name on the iframe and on the iframe\'s body \n    name: undef,\n    // Whether the editor should look like the textarea (by adopting styles)\n    style: true,\n    // Id of the toolbar element, pass falsey value if you don\'t want any toolbar logic\n    toolbar: undef,\n    // Whether urls, entered by the user should automatically become clickable-links\n    autoLink: true,\n    // Object which includes parser rules to apply when html gets inserted via copy & paste\n    // See parser_rules/*.js for examples\n    parserRules: { tags: { br: {}, span: {}, div: {}, p: {} }, classes: {} },\n    // Parser method to use when the user inserts content via copy & paste\n    parser: wysihtml5.dom.parse,\n    // Class name which should be set on the contentEditable element in the created sandbox iframe, can be styled via the \'stylesheets\' option\n    composerClassName: "wysihtml5-editor",\n    // Class name to add to the body when the wysihtml5 editor is supported\n    bodyClassName: "wysihtml5-supported",\n    // Array (or single string) of stylesheet urls to be loaded in the editor\'s iframe\n    stylesheets: [],\n    // Placeholder text to use, defaults to the placeholder attribute on the textarea element\n    placeholderText: undef,\n    // Whether the composer should allow the user to manually resize images, tables etc.\n    allowObjectResizing: true,\n    // Whether the rich text editor should be rendered on touch devices (wysihtml5 >= 0.3.0 comes with basic support for iOS 5)\n    supportTouchDevices: true\n  };\n\n  wysihtml5.Editor = wysihtml5.lang.Dispatcher.extend(\n  /** @scope wysihtml5.Editor.prototype */{\n    constructor: function constructor(textareaElement, config) {\n      this.textareaElement = typeof textareaElement === "string" ? document.getElementById(textareaElement) : textareaElement;\n      this.config = wysihtml5.lang.object({}).merge(defaultConfig).merge(config).get();\n      this.textarea = new wysihtml5.views.Textarea(this, this.textareaElement, this.config);\n      this.currentView = this.textarea;\n      this._isCompatible = wysihtml5.browser.supported();\n\n      // Sort out unsupported/unwanted browsers here\n      if (!this._isCompatible || !this.config.supportTouchDevices && wysihtml5.browser.isTouchDevice()) {\n        var that = this;\n        setTimeout(function () {\n          that.fire("beforeload").fire("load");\n        }, 0);\n        return;\n      }\n\n      // Add class name to body, to indicate that the editor is supported\n      wysihtml5.dom.addClass(document.body, this.config.bodyClassName);\n\n      this.composer = new wysihtml5.views.Composer(this, this.textareaElement, this.config);\n      this.currentView = this.composer;\n\n      if (typeof this.config.parser === "function") {\n        this._initParser();\n      }\n\n      this.observe("beforeload", function () {\n        this.synchronizer = new wysihtml5.views.Synchronizer(this, this.textarea, this.composer);\n        if (this.config.toolbar) {\n          this.toolbar = new wysihtml5.toolbar.Toolbar(this, this.config.toolbar);\n        }\n      });\n\n      try {\n        console.log("Heya! This page is using wysihtml5 for rich text editing. Check out https://github.com/xing/wysihtml5");\n      } catch (e) {}\n    },\n\n    isCompatible: function isCompatible() {\n      return this._isCompatible;\n    },\n\n    clear: function clear() {\n      this.currentView.clear();\n      return this;\n    },\n\n    getValue: function getValue(parse) {\n      return this.currentView.getValue(parse);\n    },\n\n    setValue: function setValue(html, parse) {\n      if (!html) {\n        return this.clear();\n      }\n      this.currentView.setValue(html, parse);\n      return this;\n    },\n\n    focus: function focus(setToEnd) {\n      this.currentView.focus(setToEnd);\n      return this;\n    },\n\n    /**\n     * Deactivate editor (make it readonly)\n     */\n    disable: function disable() {\n      this.currentView.disable();\n      return this;\n    },\n\n    /**\n     * Activate editor\n     */\n    enable: function enable() {\n      this.currentView.enable();\n      return this;\n    },\n\n    isEmpty: function isEmpty() {\n      return this.currentView.isEmpty();\n    },\n\n    hasPlaceholderSet: function hasPlaceholderSet() {\n      return this.currentView.hasPlaceholderSet();\n    },\n\n    parse: function parse(htmlOrElement) {\n      var returnValue = this.config.parser(htmlOrElement, this.config.parserRules, this.composer.sandbox.getDocument(), true);\n      if ((typeof htmlOrElement === "undefined" ? "undefined" : _typeof(htmlOrElement)) === "object") {\n        wysihtml5.quirks.redraw(htmlOrElement);\n      }\n      return returnValue;\n    },\n\n    /**\n     * Prepare html parser logic\n     *  - Observes for paste and drop\n     */\n    _initParser: function _initParser() {\n      this.observe("paste:composer", function () {\n        var keepScrollPosition = true,\n            that = this;\n        that.composer.selection.executeAndRestore(function () {\n          wysihtml5.quirks.cleanPastedHTML(that.composer.element);\n          that.parse(that.composer.element);\n        }, keepScrollPosition);\n      });\n\n      this.observe("paste:textarea", function () {\n        var value = this.textarea.getValue(),\n            newValue;\n        newValue = this.parse(value);\n        this.textarea.setValue(newValue);\n      });\n    }\n  });\n})(wysihtml5);\n/**\nBootstrap wysihtml5 editor. Based on [bootstrap-wysihtml5](https://github.com/jhollingworth/bootstrap-wysihtml5).  \nYou should include **manually** distributives of `wysihtml5` and `bootstrap-wysihtml5`:\n\n    <link href="js/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/bootstrap-wysihtml5-0.0.2.css" rel="stylesheet" type="text/css"></link>  \n    <script src="js/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/wysihtml5-0.3.0.min.js"><\/script>  \n    <script src="js/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/bootstrap-wysihtml5-0.0.2.min.js"><\/script>\n    \nAnd also include `wysihtml5.js` from `inputs-ext` directory of x-editable:\n      \n    <script src="js/inputs-ext/wysihtml5/wysihtml5.js"><\/script>  \n\n**Note:** It\'s better to use fresh bootstrap-wysihtml5 from it\'s [master branch](https://github.com/jhollingworth/bootstrap-wysihtml5/tree/master/src) as there is update for correct image insertion.    \n    \n@class wysihtml5\n@extends abstractinput\n@final\n@since 1.4.0\n@example\n<div id="comments" data-type="wysihtml5" data-pk="1"><h2>awesome</h2> comment!</div>\n<script>\n$(function(){\n    $(\'#comments\').editable({\n        url: \'/post\',\n        title: \'Enter comments\'\n    });\n});\n<\/script>\n**/\n(function ($) {\n\n  window.Wysihtml5 = function Wysihtml5(options) {\n    this.init(\'wysihtml5\', options, Wysihtml5.defaults);\n\n    //extend wysihtml5 manually as $.extend not recursive \n    this.options.wysihtml5 = $.extend({}, Wysihtml5.defaults.wysihtml5, options.wysihtml5);\n  };\n\n  window.$.fn.editableutils.inherit(Wysihtml5, window.$.fn.editabletypes.abstractinput);\n\n  $.extend(Wysihtml5.prototype, {\n    render: function render() {\n      var deferred = $.Deferred(),\n          msieOld;\n\n      //generate unique id as it required for wysihtml5\n      this.$input.attr(\'id\', \'textarea_\' + new Date().getTime());\n\n      this.setClass();\n      this.setAttr(\'placeholder\');\n\n      //resolve deffered when widget loaded\n      $.extend(this.options.wysihtml5, {\n        events: {\n          load: function load() {\n            deferred.resolve();\n          }\n        }\n      });\n\n      this.$input.wysihtml5(this.options.wysihtml5);\n\n      /*\n       In IE8 wysihtml5 iframe stays on the same line with buttons toolbar (inside popover).\n       The only solution I found is to add <br>. If you fine better way, please send PR.   \n      */\n      msieOld = /msie\\s*(8|7|6)/.test(navigator.userAgent.toLowerCase());\n      if (msieOld) {\n        this.$input.before(\'<br><br>\');\n      }\n\n      return deferred.promise();\n    },\n\n    value2html: function value2html(value, element) {\n      $(element).html(value);\n    },\n\n    html2value: function html2value(html) {\n      return html;\n    },\n\n    value2input: function value2input(value) {\n      this.$input.data("wysihtml5").editor.setValue(value, true);\n    },\n\n    activate: function activate() {\n      this.$input.data("wysihtml5").editor.focus();\n    },\n\n    isEmpty: function isEmpty($element) {\n      if ($.trim($element.html()) === \'\') {\n        return true;\n      } else if ($.trim($element.text()) !== \'\') {\n        return false;\n      } else {\n        //e.g. \'<img>\', \'<br>\', \'<p></p>\'\n        return !$element.height() || !$element.width();\n      }\n    }\n  });\n\n  Wysihtml5.defaults = $.extend({}, window.$.fn.editabletypes.abstractinput.defaults, {\n    /**\n    @property tpl\n    @default <textarea></textarea>\n    **/\n    tpl: \'<textarea></textarea>\',\n    /**\n    @property inputclass\n    @default editable-wysihtml5\n    **/\n    inputclass: \'editable-wysihtml5\',\n    /**\n    Placeholder attribute of input. Shown when input is empty.\n     @property placeholder\n    @type string\n    @default null\n    **/\n    placeholder: null,\n    /**\n    Wysihtml5 default options.  \n    See https://github.com/jhollingworth/bootstrap-wysihtml5#options\n     @property wysihtml5\n    @type object\n    @default {stylesheets: false}\n    **/\n    wysihtml5: {\n      stylesheets: false\n    }\n  });\n\n  window.$.fn.editabletypes.wysihtml5 = Wysihtml5;\n})(window.jQuery);\n\n!function ($, wysi) {\n\n  var tpl = {\n    "font-styles": function fontStyles(locale, options) {\n      var size = options && options.size ? \' btn-\' + options.size : \'\';\n      return "<li class=\'dropdown\'>" + "<a class=\'btn btn-default dropdown-toggle" + size + "\' data-toggle=\'dropdown\' href=\'#\'>" + "<i class=\'fa fa-font\'></i>&nbsp;<span class=\'current-font\'>" + locale.font_styles.normal + "</span>&nbsp;<b class=\'caret\'></b>" + "</a>" + "<ul class=\'dropdown-menu\'>" + "<li><a data-wysihtml5-command=\'formatBlock\' data-wysihtml5-command-value=\'div\' tabindex=\'-1\'>" + locale.font_styles.normal + "</a></li>" + "<li><a data-wysihtml5-command=\'formatBlock\' data-wysihtml5-command-value=\'h1\' tabindex=\'-1\'>" + locale.font_styles.h1 + "</a></li>" + "<li><a data-wysihtml5-command=\'formatBlock\' data-wysihtml5-command-value=\'h2\' tabindex=\'-1\'>" + locale.font_styles.h2 + "</a></li>" + "<li><a data-wysihtml5-command=\'formatBlock\' data-wysihtml5-command-value=\'h3\' tabindex=\'-1\'>" + locale.font_styles.h3 + "</a></li>" + "</ul>" + "</li>";\n    },\n\n    "emphasis": function emphasis(locale, options) {\n      var size = options && options.size ? \' btn-\' + options.size : \'\';\n      return "<li>" + "<div class=\'btn-group\'>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'bold\' title=\'CTRL+B\' tabindex=\'-1\'>" + locale.emphasis.bold + "</a>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'italic\' title=\'CTRL+I\' tabindex=\'-1\'>" + locale.emphasis.italic + "</a>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'underline\' title=\'CTRL+U\' tabindex=\'-1\'>" + locale.emphasis.underline + "</a>" + "</div>" + "</li>";\n    },\n\n    "lists": function lists(locale, options) {\n      var size = options && options.size ? \' btn-\' + options.size : \'\';\n      return "<li>" + "<div class=\'btn-group\'>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'insertUnorderedList\' title=\'" + locale.lists.unordered + "\' tabindex=\'-1\'><i class=\'fa fa-list\'></i></a>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'insertOrderedList\' title=\'" + locale.lists.ordered + "\' tabindex=\'-1\'><i class=\'fa fa-th-list\'></i></a>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'clear\' title=\'ban\' tabindex=\'-1\'><i class=\'fa fa-ban\'></i></a>" + "</div>" + "</li>";\n    },\n\n    "link": function link(locale, options) {\n      var size = options && options.size ? \' btn-\' + options.size : \'\';\n      return "<li>" + "<div class=\'bootstrap-wysihtml5-insert-link-modal modal hide fade\'>" + "<div class=\'modal-header\'>" + "<a class=\'close\' data-dismiss=\'modal\'>&times;</a>" + "<h3>" + locale.link.insert + "</h3>" + "</div>" + "<div class=\'modal-body\'>" + "<input value=\'http://\' class=\'bootstrap-wysihtml5-insert-link-url input-xlarge\'>" + "</div>" + "<div class=\'modal-footer\'>" + "<a href=\'#\' class=\'btn btn-default\' data-dismiss=\'modal\'>" + locale.link.cancel + "</a>" + "<a href=\'#\' class=\'btn btn-primary\' data-dismiss=\'modal\'>" + locale.link.insert + "</a>" + "</div>" + "</div>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'createLink\' title=\'" + locale.link.insert + "\' tabindex=\'-1\'><i class=\'fa fa-share\'></i></a>" + "</li>";\n    },\n\n    "image": function image(locale, options) {\n      var size = options && options.size ? \' btn-\' + options.size : \'\';\n      return "<li>" + "<div class=\'bootstrap-wysihtml5-insert-image-modal modal hide fade\'>" + "<div class=\'modal-header\'>" + "<a class=\'close\' data-dismiss=\'modal\'>&times;</a>" + "<h3>" + locale.image.insert + "</h3>" + "</div>" + "<div class=\'modal-body\'>" + "<input value=\'http://\' class=\'bootstrap-wysihtml5-insert-image-url input-xlarge\'>" + "</div>" + "<div class=\'modal-footer\'>" + "<a href=\'#\' class=\'btn btn-default\' data-dismiss=\'modal\'>" + locale.image.cancel + "</a>" + "<a href=\'#\' class=\'btn btn-primary\' data-dismiss=\'modal\'>" + locale.image.insert + "</a>" + "</div>" + "</div>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-command=\'insertImage\' title=\'" + locale.image.insert + "\' tabindex=\'-1\'><i class=\'fa fa-picture\'></i></a>" + "</li>";\n    },\n\n    "html": function html(locale, options) {\n      var size = options && options.size ? \' btn-\' + options.size : \'\';\n      return "<li>" + "<div class=\'btn-group\'>" + "<a class=\'btn btn-default" + size + "\' data-wysihtml5-action=\'change_view\' title=\'" + locale.html.edit + "\' tabindex=\'-1\'><i class=\'fa fa-pencil\'></i></a>" + "</div>" + "</li>";\n    },\n\n    "color": function color(locale, options) {\n      var size = options && options.size ? \' btn-\' + options.size : \'\';\n      return "<li class=\'dropdown\'>" + "<a class=\'btn btn-default dropdown-toggle" + size + "\' data-toggle=\'dropdown\' href=\'#\' tabindex=\'-1\'>" + "<span class=\'current-color\'>原色</span>&nbsp;<b class=\'caret\'></b>" + "</a>" + "<ul class=\'dropdown-menu\'>" + "<li><div class=\'wysihtml5-colors\' data-wysihtml5-command-value=\'clear\'></div><a class=\'wysihtml5-colors-title\' data-wysihtml5-command=\'foreColor\' data-wysihtml5-command-value=\'clear\'>" + locale.colours.clear + "</a></li>" + "<li><div class=\'wysihtml5-colors\' data-wysihtml5-command-value=\'first\'></div><a class=\'wysihtml5-colors-title\' data-wysihtml5-command=\'foreColor\' data-wysihtml5-command-value=\'first\'>" + locale.colours.first + "</a></li>" + "<li><div class=\'wysihtml5-colors\' data-wysihtml5-command-value=\'second\'></div><a class=\'wysihtml5-colors-title\' data-wysihtml5-command=\'foreColor\' data-wysihtml5-command-value=\'second\'>" + locale.colours.second + "</a></li>" + "<li><div class=\'wysihtml5-colors\' data-wysihtml5-command-value=\'three\'></div><a class=\'wysihtml5-colors-title\' data-wysihtml5-command=\'foreColor\' data-wysihtml5-command-value=\'three\'>" + locale.colours.three + "</a></li>" + "</ul>" + "</li>";\n    }\n  };\n\n  var templates = function templates(key, locale, options) {\n    return tpl[key](locale, options);\n  };\n\n  var Wysihtml5 = function Wysihtml5(el, options) {\n    this.el = el;\n    var toolbarOpts = options || defaultOptions;\n    for (var t in toolbarOpts.customTemplates) {\n      tpl[t] = toolbarOpts.customTemplates[t];\n    }\n    this.toolbar = this.createToolbar(el, toolbarOpts);\n    this.editor = this.createEditor(options);\n\n    window.editor = this.editor;\n\n    $(\'iframe.wysihtml5-sandbox\').each(function (i, el) {\n      $(el.contentWindow).off(\'focus.wysihtml5\').on({\n        \'focus.wysihtml5\': function focusWysihtml5() {\n          $(\'li.dropdown\').removeClass(\'open\');\n        }\n      });\n    });\n  };\n\n  Wysihtml5.prototype = {\n\n    constructor: Wysihtml5,\n\n    createEditor: function createEditor(options) {\n      options = options || {};\n\n      // Add the toolbar to a clone of the options object so multiple instances\n      // of the WYISYWG don\'t break because "toolbar" is already defined\n      options = $.extend(true, {}, options);\n      options.toolbar = this.toolbar[0];\n\n      var editor = new wysihtml5.Editor(this.el[0], options);\n\n      if (options && options.events) {\n        for (var eventName in options.events) {\n          editor.on(eventName, options.events[eventName]);\n        }\n      }\n      return editor;\n    },\n\n    createToolbar: function createToolbar(el, options) {\n      var self = this;\n      var toolbar = $("<ul/>", {\n        \'class\': "wysihtml5-toolbar",\n        \'style\': "display:none"\n      });\n      var culture = options.locale || defaultOptions.locale || "en";\n      for (var key in window.$.fn.wysihtml5.defaultOptions) {\n        var value = false;\n\n        if (options[key] !== undefined) {\n          if (options[key] === true) {\n            value = true;\n          }\n        } else {\n          value = defaultOptions[key];\n        }\n\n        if (value === true) {\n          toolbar.append(templates(key, locale[culture], options));\n\n          if (key === "html") {\n            this.initHtml(toolbar);\n          }\n\n          if (key === "link") {\n            this.initInsertLink(toolbar);\n          }\n\n          if (key === "image") {\n            this.initInsertImage(toolbar);\n          }\n        }\n      }\n\n      if (options.toolbar) {\n        for (key in options.toolbar) {\n          toolbar.append(options.toolbar[key]);\n        }\n      }\n\n      toolbar.find("a[data-wysihtml5-command=\'formatBlock\']").click(function (e) {\n        var target = e.target || e.srcElement;\n        var el = $(target);\n        self.toolbar.find(\'.current-font\').text(el.html());\n      });\n\n      toolbar.find("a[data-wysihtml5-command=\'foreColor\']").click(function (e) {\n        var target = e.target || e.srcElement;\n        var el = $(target);\n        self.toolbar.find(\'.current-color\').text(el.html());\n      });\n\n      this.el.before(toolbar);\n\n      return toolbar;\n    },\n\n    initHtml: function initHtml(toolbar) {\n      var changeViewSelector = "a[data-wysihtml5-action=\'change_view\']";\n      toolbar.find(changeViewSelector).click(function (e) {\n        toolbar.find(\'a.btn\').not(changeViewSelector).toggleClass(\'disabled\');\n      });\n    },\n\n    initInsertImage: function initInsertImage(toolbar) {\n      var self = this;\n      var insertImageModal = toolbar.find(\'.bootstrap-wysihtml5-insert-image-modal\');\n      var urlInput = insertImageModal.find(\'.bootstrap-wysihtml5-insert-image-url\');\n      var insertButton = insertImageModal.find(\'a.btn-primary\');\n      var initialValue = urlInput.val();\n      var caretBookmark;\n\n      var insertImage = function insertImage() {\n        var url = urlInput.val();\n        urlInput.val(initialValue);\n        self.editor.currentView.element.focus();\n        if (caretBookmark) {\n          self.editor.composer.selection.setBookmark(caretBookmark);\n          caretBookmark = null;\n        }\n        self.editor.composer.commands.exec("insertImage", url);\n      };\n\n      urlInput.keypress(function (e) {\n        if (e.which == 13) {\n          insertImage();\n          insertImageModal.modal(\'hide\');\n        }\n      });\n\n      insertButton.click(insertImage);\n\n      insertImageModal.on(\'shown\', function () {\n        urlInput.focus();\n      });\n\n      insertImageModal.on(\'hide\', function () {\n        self.editor.currentView.element.focus();\n      });\n\n      toolbar.find(\'a[data-wysihtml5-command=insertImage]\').click(function () {\n        var activeButton = $(this).hasClass("wysihtml5-command-active");\n\n        if (!activeButton) {\n          self.editor.currentView.element.focus(false);\n          caretBookmark = self.editor.composer.selection.getBookmark();\n          insertImageModal.appendTo(\'body\').modal(\'show\');\n          insertImageModal.on(\'click.dismiss.modal\', \'[data-dismiss="modal"]\', function (e) {\n            e.stopPropagation();\n          });\n          return false;\n        } else {\n          return true;\n        }\n      });\n    },\n\n    initInsertLink: function initInsertLink(toolbar) {\n      var self = this;\n      var insertLinkModal = toolbar.find(\'.bootstrap-wysihtml5-insert-link-modal\');\n      var urlInput = insertLinkModal.find(\'.bootstrap-wysihtml5-insert-link-url\');\n      var insertButton = insertLinkModal.find(\'a.btn-primary\');\n      var initialValue = urlInput.val();\n      var caretBookmark;\n\n      var insertLink = function insertLink() {\n        var url = urlInput.val();\n        urlInput.val(initialValue);\n        self.editor.currentView.element.focus();\n        if (caretBookmark) {\n          self.editor.composer.selection.setBookmark(caretBookmark);\n          caretBookmark = null;\n        }\n        self.editor.composer.commands.exec("createLink", {\n          href: url,\n          target: "_blank",\n          rel: "nofollow"\n        });\n      };\n      var pressedEnter = false;\n\n      urlInput.keypress(function (e) {\n        if (e.which == 13) {\n          insertLink();\n          insertLinkModal.modal(\'hide\');\n        }\n      });\n\n      insertButton.click(insertLink);\n\n      insertLinkModal.on(\'shown\', function () {\n        urlInput.focus();\n      });\n\n      insertLinkModal.on(\'hide\', function () {\n        self.editor.currentView.element.focus();\n      });\n\n      toolbar.find(\'a[data-wysihtml5-command=createLink]\').click(function () {\n        var activeButton = $(this).hasClass("wysihtml5-command-active");\n\n        if (!activeButton) {\n          self.editor.currentView.element.focus(false);\n          caretBookmark = self.editor.composer.selection.getBookmark();\n          insertLinkModal.appendTo(\'body\').modal(\'show\');\n          insertLinkModal.on(\'click.dismiss.modal\', \'[data-dismiss="modal"]\', function (e) {\n            e.stopPropagation();\n          });\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n  };\n\n  // these define our public api\n  var methods = {\n    resetDefaults: function resetDefaults() {\n      window.$.fn.wysihtml5.defaultOptions = $.extend(true, {}, window.$.fn.wysihtml5.defaultOptionsCache);\n    },\n    bypassDefaults: function bypassDefaults(options) {\n      return this.each(function () {\n        var $this = $(this);\n        $this.data(\'wysihtml5\', new Wysihtml5($this, options));\n      });\n    },\n    shallowExtend: function shallowExtend(options) {\n      var settings = $.extend({}, window.$.fn.wysihtml5.defaultOptions, options || {});\n      var that = this;\n      return methods.bypassDefaults.apply(that, [settings]);\n    },\n    deepExtend: function deepExtend(options) {\n      var settings = $.extend(true, {}, window.$.fn.wysihtml5.defaultOptions, options || {});\n      var that = this;\n      return methods.bypassDefaults.apply(that, [settings]);\n    },\n    init: function init(options) {\n      var that = this;\n      return methods.shallowExtend.apply(that, [options]);\n    }\n  };\n\n  window.$.fn.wysihtml5 = function (method) {\n    if (methods[method]) {\n      return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n    } else if ((typeof method === "undefined" ? "undefined" : _typeof(method)) === \'object\' || !method) {\n      return methods.init.apply(this, arguments);\n    } else {\n      $.error(\'Method \' + method + \' does not exist on jQuery.wysihtml5\');\n    }\n  };\n\n  window.$.fn.wysihtml5.Constructor = Wysihtml5;\n\n  window.$.fn.wysihtml5.defaultOptions = {\n    "font-styles": true,\n    "color": false,\n    "emphasis": true,\n    "lists": true,\n    "html": false,\n    "link": true,\n    "image": true,\n    events: {},\n    parserRules: {\n      classes: {\n        // (path_to_project/lib/css/wysiwyg-color.css)\n        "wysiwyg-color-clear": 1,\n        "wysiwyg-color-first": 1,\n        "wysiwyg-color-second": 1,\n        "wysiwyg-color-three": 1\n      },\n      tags: {\n        "b": {},\n        "i": {},\n        "br": {},\n        "ol": {},\n        "ul": {},\n        "li": {},\n        "h1": {},\n        "h2": {},\n        "h3": {},\n        "blockquote": {},\n        "u": 1,\n        "img": {\n          "check_attributes": {\n            "width": "numbers",\n            "alt": "alt",\n            "src": "url",\n            "height": "numbers"\n          }\n        },\n        "a": {\n          set_attributes: {\n            target: "_blank",\n            rel: "nofollow"\n          },\n          check_attributes: {\n            href: "url" // important to avoid XSS\n          }\n        },\n        "span": 1,\n        "div": 1,\n        // to allow save and edit files with code tag hacks\n        "code": 1,\n        "pre": 1\n      }\n    },\n    stylesheets: ["./lib/css/wysiwyg-color.css"], // (path_to_project/lib/css/wysiwyg-color.css)\n    locale: "en"\n  };\n\n  if (typeof window.$.fn.wysihtml5.defaultOptionsCache === \'undefined\') {\n    window.$.fn.wysihtml5.defaultOptionsCache = $.extend(true, {}, window.$.fn.wysihtml5.defaultOptions);\n  }\n\n  var locale = window.$.fn.wysihtml5.locale = {\n    en: {\n      font_styles: {\n        normal: "Normal text",\n        h1: "Heading 1",\n        h2: "Heading 2",\n        h3: "Heading 3"\n      },\n      emphasis: {\n        bold: "Bold",\n        italic: "Italic",\n        underline: "Underline"\n      },\n      lists: {\n        unordered: "Unordered list",\n        ordered: "Ordered list",\n        outdent: "Outdent",\n        indent: "Indent"\n      },\n      link: {\n        insert: "Insert link",\n        cancel: "Cancel"\n      },\n      image: {\n        insert: "Insert image",\n        cancel: "Cancel"\n      },\n      html: {\n        edit: "Edit HTML"\n      },\n      colours: {\n        clear: "Clear",\n        first: "首选",\n        second: "次选",\n        three: "备选",\n        black: "Black",\n        silver: "Silver",\n        gray: "Grey",\n        maroon: "Maroon",\n        red: "Red",\n        purple: "Purple",\n        green: "Green",\n        olive: "Olive",\n        navy: "Navy",\n        blue: "Blue",\n        orange: "Orange"\n      }\n    }\n  };\n}(window.jQuery, window.wysihtml5);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvanMvd3lzaWh0bWw1LmpzPzJiYjYiXSwibmFtZXMiOlsiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwib2JqIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJ3eXNpaHRtbDUiLCJ2ZXJzaW9uIiwiY29tbWFuZHMiLCJkb20iLCJxdWlya3MiLCJ0b29sYmFyIiwibGFuZyIsInNlbGVjdGlvbiIsInZpZXdzIiwiSU5WSVNJQkxFX1NQQUNFIiwiRU1QVFlfRlVOQ1RJT04iLCJFTEVNRU5UX05PREUiLCJURVhUX05PREUiLCJCQUNLU1BBQ0VfS0VZIiwiRU5URVJfS0VZIiwiRVNDQVBFX0tFWSIsIlNQQUNFX0tFWSIsIkRFTEVURV9LRVkiLCJ3aW5kb3ciLCJPQkpFQ1QiLCJGVU5DVElPTiIsIlVOREVGSU5FRCIsImRvbVJhbmdlUHJvcGVydGllcyIsImRvbVJhbmdlTWV0aG9kcyIsInRleHRSYW5nZVByb3BlcnRpZXMiLCJ0ZXh0UmFuZ2VNZXRob2RzIiwiaXNIb3N0TWV0aG9kIiwibyIsInAiLCJ0IiwiaXNIb3N0T2JqZWN0IiwiaXNIb3N0UHJvcGVydHkiLCJjcmVhdGVNdWx0aXBsZVByb3BlcnR5VGVzdCIsInRlc3RGdW5jIiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiYXJlSG9zdE1ldGhvZHMiLCJhcmVIb3N0T2JqZWN0cyIsImFyZUhvc3RQcm9wZXJ0aWVzIiwiaXNUZXh0UmFuZ2UiLCJyYW5nZSIsImFwaSIsImluaXRpYWxpemVkIiwic3VwcG9ydGVkIiwidXRpbCIsImZlYXR1cmVzIiwibW9kdWxlcyIsImNvbmZpZyIsImFsZXJ0T25XYXJuIiwicHJlZmVyVGV4dFJhbmdlIiwiZmFpbCIsInJlYXNvbiIsImFsZXJ0Iiwid2FybiIsIm1zZyIsIndhcm5pbmdNZXNzYWdlIiwiY29uc29sZSIsImxvZyIsImhhc093blByb3BlcnR5IiwiZXh0ZW5kIiwiaW5pdExpc3RlbmVycyIsIm1vZHVsZUluaXRpYWxpemVycyIsImluaXQiLCJ0ZXN0UmFuZ2UiLCJpbXBsZW1lbnRzRG9tUmFuZ2UiLCJpbXBsZW1lbnRzVGV4dFJhbmdlIiwiZG9jdW1lbnQiLCJjcmVhdGVSYW5nZSIsImRldGFjaCIsImJvZHkiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNyZWF0ZVRleHRSYW5nZSIsImFsbExpc3RlbmVycyIsImNvbmNhdCIsImxlbiIsImV4IiwiYWRkSW5pdExpc3RlbmVyIiwibGlzdGVuZXIiLCJwdXNoIiwiY3JlYXRlTWlzc2luZ05hdGl2ZUFwaUxpc3RlbmVycyIsImFkZENyZWF0ZU1pc3NpbmdOYXRpdmVBcGlMaXN0ZW5lciIsImNyZWF0ZU1pc3NpbmdOYXRpdmVBcGkiLCJ3aW4iLCJNb2R1bGUiLCJuYW1lIiwiRXJyb3IiLCJjcmVhdGVFcnJvciIsImNyZWF0ZU1vZHVsZSIsImluaXRGdW5jIiwibW9kdWxlIiwicmVxdWlyZU1vZHVsZXMiLCJtb2R1bGVOYW1lIiwiZG9jUmVhZHkiLCJsb2FkSGFuZGxlciIsImUiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJyYW5neSIsIlVOREVGIiwiZWwiLCJjcmVhdGVFbGVtZW50IiwidGV4dE5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsImFycmF5Q29udGFpbnMiLCJhcnIiLCJ2YWwiLCJpc0h0bWxOYW1lc3BhY2UiLCJub2RlIiwibnMiLCJuYW1lc3BhY2VVUkkiLCJwYXJlbnRFbGVtZW50IiwicGFyZW50IiwicGFyZW50Tm9kZSIsIm5vZGVUeXBlIiwiZ2V0Tm9kZUluZGV4IiwicHJldmlvdXNTaWJsaW5nIiwiZ2V0Tm9kZUxlbmd0aCIsImNoaWxkTm9kZXMiLCJpc0NoYXJhY3RlckRhdGFOb2RlIiwiZ2V0Q29tbW9uQW5jZXN0b3IiLCJub2RlMSIsIm5vZGUyIiwiYW5jZXN0b3JzIiwibiIsImlzQW5jZXN0b3JPZiIsImFuY2VzdG9yIiwiZGVzY2VuZGFudCIsInNlbGZJc0FuY2VzdG9yIiwiZ2V0Q2xvc2VzdEFuY2VzdG9ySW4iLCJpbnNlcnRBZnRlciIsInByZWNlZGluZ05vZGUiLCJuZXh0Tm9kZSIsIm5leHRTaWJsaW5nIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJzcGxpdERhdGFOb2RlIiwiaW5kZXgiLCJuZXdOb2RlIiwiY2xvbmVOb2RlIiwiZGVsZXRlRGF0YSIsImdldERvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsImdldFdpbmRvdyIsImRvYyIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwiZ2V0SWZyYW1lRG9jdW1lbnQiLCJpZnJhbWVFbCIsImNvbnRlbnREb2N1bWVudCIsImNvbnRlbnRXaW5kb3ciLCJnZXRJZnJhbWVXaW5kb3ciLCJnZXRCb2R5IiwiZ2V0Um9vdENvbnRhaW5lciIsImNvbXBhcmVQb2ludHMiLCJub2RlQSIsIm9mZnNldEEiLCJub2RlQiIsIm9mZnNldEIiLCJub2RlQyIsInJvb3QiLCJjaGlsZEEiLCJjaGlsZEIiLCJmaXJzdENoaWxkIiwiZnJhZ21lbnRGcm9tTm9kZUNoaWxkcmVuIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiY2hpbGQiLCJpbnNwZWN0Tm9kZSIsImRhdGEiLCJpZEF0dHIiLCJpZCIsIm5vZGVOYW1lIiwiTm9kZUl0ZXJhdG9yIiwiX25leHQiLCJfY3VycmVudCIsImhhc05leHQiLCJuZXh0IiwiY3JlYXRlSXRlcmF0b3IiLCJEb21Qb3NpdGlvbiIsIm9mZnNldCIsImVxdWFscyIsInBvcyIsImluc3BlY3QiLCJET01FeGNlcHRpb24iLCJjb2RlTmFtZSIsImNvZGUiLCJtZXNzYWdlIiwiSU5ERVhfU0laRV9FUlIiLCJISUVSQVJDSFlfUkVRVUVTVF9FUlIiLCJXUk9OR19ET0NVTUVOVF9FUlIiLCJOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlIiLCJOT1RfRk9VTkRfRVJSIiwiTk9UX1NVUFBPUlRFRF9FUlIiLCJJTlZBTElEX1NUQVRFX0VSUiIsInRvU3RyaW5nIiwiaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQiLCJzdGFydENvbnRhaW5lciIsImVuZENvbnRhaW5lciIsImdldFJhbmdlRG9jdW1lbnQiLCJkaXNwYXRjaEV2ZW50IiwidHlwZSIsImFyZ3MiLCJsaXN0ZW5lcnMiLCJfbGlzdGVuZXJzIiwiY2FsbCIsInRhcmdldCIsImdldEJvdW5kYXJ5QmVmb3JlTm9kZSIsImdldEJvdW5kYXJ5QWZ0ZXJOb2RlIiwiaW5zZXJ0Tm9kZUF0UG9zaXRpb24iLCJmaXJzdE5vZGVJbnNlcnRlZCIsImNsb25lU3VidHJlZSIsInBhcnRpYWxseVNlbGVjdGVkIiwiZnJhZyIsInN1Ykl0ZXJhdG9yIiwiaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUiLCJnZXRTdWJ0cmVlSXRlcmF0b3IiLCJpdGVyYXRlU3VidHJlZSIsInJhbmdlSXRlcmF0b3IiLCJmdW5jIiwiaXRlcmF0b3JTdGF0ZSIsIml0Iiwic3RvcCIsInN1YlJhbmdlSXRlcmF0b3IiLCJkZWxldGVTdWJ0cmVlIiwicmVtb3ZlIiwiZXh0cmFjdFN1YnRyZWUiLCJnZXROb2Rlc0luUmFuZ2UiLCJub2RlVHlwZXMiLCJmaWx0ZXIiLCJmaWx0ZXJOb2RlVHlwZXMiLCJyZWdleCIsImZpbHRlckV4aXN0cyIsIlJlZ0V4cCIsImpvaW4iLCJub2RlcyIsIlJhbmdlSXRlcmF0b3IiLCJ0ZXN0IiwiX2luc3BlY3QiLCJnZXROYW1lIiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJjbG9uZVBhcnRpYWxseVNlbGVjdGVkVGV4dE5vZGVzIiwiY29sbGFwc2VkIiwic2MiLCJzbyIsImVjIiwiZW8iLCJjb21tb25BbmNlc3RvckNvbnRhaW5lciIsImlzU2luZ2xlQ2hhcmFjdGVyRGF0YU5vZGUiLCJfZmlyc3QiLCJfbGFzdCIsInJlc2V0IiwiY3VycmVudCIsInN0YXJ0IiwiZW5kIiwicmVtb3ZlQ2hpbGQiLCJzdWJSYW5nZSIsImNsb25lUmFuZ2UiLCJjb2xsYXBzZSIsIlJhbmdlIiwidXBkYXRlQm91bmRhcmllcyIsImRldGFjaFJhbmdlIiwiUmFuZ2VFeGNlcHRpb24iLCJCQURfQk9VTkRBUllQT0lOVFNfRVJSIiwiSU5WQUxJRF9OT0RFX1RZUEVfRVJSIiwiUmFuZ2VOb2RlSXRlcmF0b3IiLCJfcG9zaXRpb24iLCJiZWZvcmVBZnRlck5vZGVUeXBlcyIsInJvb3RDb250YWluZXJOb2RlVHlwZXMiLCJyZWFkb25seU5vZGVUeXBlcyIsImluc2VydGFibGVOb2RlVHlwZXMiLCJzdXJyb3VuZE5vZGVUeXBlcyIsImNyZWF0ZUFuY2VzdG9yRmluZGVyIiwiZ2V0RG9jdW1lbnRPckZyYWdtZW50Q29udGFpbmVyIiwiZ2V0UmVhZG9ubHlBbmNlc3RvciIsImdldERvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yIiwiYXNzZXJ0Tm9Eb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3RvciIsImFsbG93U2VsZiIsImFzc2VydE5vdERldGFjaGVkIiwiYXNzZXJ0VmFsaWROb2RlVHlwZSIsImludmFsaWRUeXBlcyIsImFzc2VydFZhbGlkT2Zmc2V0IiwiYXNzZXJ0U2FtZURvY3VtZW50T3JGcmFnbWVudCIsImFzc2VydE5vZGVOb3RSZWFkT25seSIsImFzc2VydE5vZGUiLCJpc09ycGhhbiIsImlzVmFsaWRPZmZzZXQiLCJhc3NlcnRSYW5nZVZhbGlkIiwic3R5bGVFbCIsImh0bWxQYXJzaW5nQ29uZm9ybXMiLCJpbm5lckhUTUwiLCJjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQiLCJmcmFnbWVudFN0ciIsImRvY3VtZW50RWxlbWVudCIsInJhbmdlUHJvcGVydGllcyIsInMycyIsInMyZSIsImUyZSIsImUycyIsIm5fYiIsIm5fYSIsIm5fYl9hIiwibl9pIiwiUmFuZ2VQcm90b3R5cGUiLCJhdHRhY2hMaXN0ZW5lciIsImNvbXBhcmVCb3VuZGFyeVBvaW50cyIsImhvdyIsInByZWZpeEEiLCJwcmVmaXhCIiwiaW5zZXJ0Tm9kZSIsInNldFN0YXJ0QmVmb3JlIiwiY2xvbmVDb250ZW50cyIsImNsb25lIiwic2xpY2UiLCJjYW5TdXJyb3VuZENvbnRlbnRzIiwiYm91bmRhcmllc0ludmFsaWQiLCJzdXJyb3VuZENvbnRlbnRzIiwiY29udGVudCIsImV4dHJhY3RDb250ZW50cyIsImhhc0NoaWxkTm9kZXMiLCJsYXN0Q2hpbGQiLCJzZWxlY3ROb2RlIiwicHJvcCIsInRleHRCaXRzIiwiY29tcGFyZU5vZGUiLCJub2RlSW5kZXgiLCJzdGFydENvbXBhcmlzb24iLCJjb21wYXJlUG9pbnQiLCJlbmRDb21wYXJpc29uIiwidG9IdG1sIiwiY29udGFpbmVyIiwiaW50ZXJzZWN0c05vZGUiLCJ0b3VjaGluZ0lzSW50ZXJzZWN0aW5nIiwiaXNQb2ludEluUmFuZ2UiLCJpbnRlcnNlY3RzUmFuZ2UiLCJpbnRlcnNlY3Rpb24iLCJpbnRlcnNlY3Rpb25SYW5nZSIsInNldFN0YXJ0Iiwic2V0RW5kIiwidW5pb24iLCJ1bmlvblJhbmdlIiwiY29udGFpbnNOb2RlIiwiYWxsb3dQYXJ0aWFsIiwiY29udGFpbnNOb2RlQ29udGVudHMiLCJjb250YWluc1JhbmdlIiwiY29udGFpbnNOb2RlVGV4dCIsIm5vZGVSYW5nZSIsInRleHROb2RlcyIsImdldE5vZGVzIiwibGFzdFRleHROb2RlIiwicG9wIiwiY29udGFpbnMiLCJjcmVhdGVOb2RlSXRlcmF0b3IiLCJjb2xsYXBzZUJlZm9yZSIsInNldEVuZEJlZm9yZSIsImNvbGxhcHNlQWZ0ZXIiLCJzZXRTdGFydEFmdGVyIiwicmFuZ2VzRXF1YWwiLCJjb3B5Q29tcGFyaXNvbkNvbnN0YW50c1RvT2JqZWN0IiwiU1RBUlRfVE9fU1RBUlQiLCJTVEFSVF9UT19FTkQiLCJFTkRfVE9fRU5EIiwiRU5EX1RPX1NUQVJUIiwiTk9ERV9CRUZPUkUiLCJOT0RFX0FGVEVSIiwiTk9ERV9CRUZPUkVfQU5EX0FGVEVSIiwiTk9ERV9JTlNJREUiLCJjb3B5Q29tcGFyaXNvbkNvbnN0YW50cyIsImNyZWF0ZVJhbmdlQ29udGVudFJlbW92ZXIiLCJyZW1vdmVyIiwiYm91bmRhcnlVcGRhdGVyIiwiYm91bmRhcnkiLCJyZXR1cm5WYWx1ZSIsImNyZWF0ZVByb3RvdHlwZVJhbmdlIiwiZGV0YWNoZXIiLCJjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIiLCJpc0JlZm9yZSIsImlzU3RhcnQiLCJzZXRSYW5nZVN0YXJ0Iiwic2V0UmFuZ2VFbmQiLCJzZXRSYW5nZVN0YXJ0QW5kRW5kIiwic2V0RW5kQWZ0ZXIiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJkZWxldGVDb250ZW50cyIsInNwbGl0Qm91bmRhcmllcyIsInN0YXJ0RW5kU2FtZSIsIm5vcm1hbGl6ZUJvdW5kYXJpZXMiLCJtZXJnZUZvcndhcmQiLCJzaWJsaW5nIiwiYXBwZW5kRGF0YSIsIm1lcmdlQmFja3dhcmQiLCJub2RlTGVuZ3RoIiwiaW5zZXJ0RGF0YSIsIm5vcm1hbGl6ZVN0YXJ0IiwiZW5kTm9kZSIsInN0YXJ0Tm9kZSIsImNvbGxhcHNlVG9Qb2ludCIsInVwZGF0ZUNvbGxhcHNlZEFuZENvbW1vbkFuY2VzdG9yIiwic3RhcnRNb3ZlZCIsImVuZE1vdmVkIiwiYm91bmRhcnljaGFuZ2UiLCJyYW5nZVByb3RvdHlwZSIsInIxIiwicjIiLCJEb21SYW5nZSIsIldyYXBwZWRSYW5nZSIsImdldFRleHRSYW5nZUNvbnRhaW5lckVsZW1lbnQiLCJ0ZXh0UmFuZ2UiLCJwYXJlbnRFbCIsImR1cGxpY2F0ZSIsInN0YXJ0RWwiLCJlbmRFbCIsInN0YXJ0RW5kQ29udGFpbmVyIiwidGV4dFJhbmdlSXNDb2xsYXBzZWQiLCJjb21wYXJlRW5kUG9pbnRzIiwiZ2V0VGV4dFJhbmdlQm91bmRhcnlQb3NpdGlvbiIsIndob2xlUmFuZ2VDb250YWluZXJFbGVtZW50IiwiaXNDb2xsYXBzZWQiLCJ3b3JraW5nUmFuZ2UiLCJjb250YWluZXJFbGVtZW50IiwiY2FuSGF2ZUhUTUwiLCJ3b3JraW5nTm9kZSIsImNvbXBhcmlzb24iLCJ3b3JraW5nQ29tcGFyaXNvblR5cGUiLCJwcmV2aW91c05vZGUiLCJib3VuZGFyeVBvc2l0aW9uIiwiYm91bmRhcnlOb2RlIiwibW92ZVRvRWxlbWVudFRleHQiLCJzZXRFbmRQb2ludCIsInRlbXBSYW5nZSIsInJhbmdlTGVuZ3RoIiwidGV4dCIsInJlcGxhY2UiLCJtb3ZlU3RhcnQiLCJjcmVhdGVCb3VuZGFyeVRleHRSYW5nZSIsImJvdW5kYXJ5UGFyZW50IiwiYm91bmRhcnlPZmZzZXQiLCJub2RlSXNEYXRhTm9kZSIsInJhbmdlUHJvdG8iLCJjYW5TZXRSYW5nZVN0YXJ0QWZ0ZXJFbmQiLCJ1cGRhdGVSYW5nZVByb3BlcnRpZXMiLCJuYXRpdmVSYW5nZSIsInVwZGF0ZU5hdGl2ZVJhbmdlIiwiZGV0YWNoZWQiLCJyZWZyZXNoIiwidGVzdFRleHROb2RlIiwib3Bwb3NpdGVOYW1lIiwiZ2V0RW5kT2Zmc2V0IiwicmFuZ2UyIiwiY3JlYXRlTmF0aXZlUmFuZ2UiLCJyYW5nZUNvbnRhaW5lckVsZW1lbnQiLCJnbG9iYWxPYmoiLCJyYW5nZVRvVGV4dFJhbmdlIiwidHIiLCJzdGFydFJhbmdlIiwiZW5kUmFuZ2UiLCJjcmVhdGVSYW5neVJhbmdlIiwiY3JlYXRlSWZyYW1lUmFuZ2UiLCJjcmVhdGVJZnJhbWVSYW5neVJhbmdlIiwiY2hlY2tTZWxlY3Rpb25SYW5nZXMiLCJCT09MRUFOIiwid2luZG93UHJvcGVydHlOYW1lIiwiZ2V0U2VsZWN0aW9uIiwic2VsZWN0aW9uSXNDb2xsYXBzZWQiLCJDT05UUk9MIiwiZ2V0V2luU2VsZWN0aW9uIiwid2luUGFyYW0iLCJnZXREb2NTZWxlY3Rpb24iLCJpbXBsZW1lbnRzV2luR2V0U2VsZWN0aW9uIiwiaW1wbGVtZW50c0RvY1NlbGVjdGlvbiIsInVzZURvY3VtZW50U2VsZWN0aW9uIiwiaXNTZWxlY3Rpb25WYWxpZCIsIm5hdGl2ZVNlbCIsImdldE5hdGl2ZVNlbGVjdGlvbiIsInRlc3RTZWxlY3Rpb24iLCJzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cyIsInNlbGVjdGlvbkhhc0V4dGVuZCIsInNlbGVjdGlvbkhhc1JhbmdlQ291bnQiLCJyYW5nZUNvdW50Iiwic2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcyIsImNvbGxhcHNlZE5vbkVkaXRhYmxlU2VsZWN0aW9uc1N1cHBvcnRlZCIsImlmcmFtZSIsImlmcmFtZURvYyIsIm9wZW4iLCJ3cml0ZSIsImNsb3NlIiwic2VsIiwiZG9jRWwiLCJpZnJhbWVCb2R5IiwiYWRkUmFuZ2UiLCJyZW1vdmVBbGxSYW5nZXMiLCJpbXBsZW1lbnRzQ29udHJvbFJhbmdlIiwidGVzdENvbnRyb2xSYW5nZSIsImNyZWF0ZUNvbnRyb2xSYW5nZSIsImFuY2hvck5vZGUiLCJmb2N1c05vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c09mZnNldCIsImdldFJhbmdlQXQiLCJ1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZSIsImJhY2t3YXJkcyIsImFuY2hvclByZWZpeCIsImZvY3VzUHJlZml4IiwidXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tTmF0aXZlU2VsZWN0aW9uIiwibmF0aXZlU2VsZWN0aW9uIiwidXBkYXRlRW1wdHlTZWxlY3Rpb24iLCJfcmFuZ2VzIiwiZ2V0TmF0aXZlUmFuZ2UiLCJfc2VsZWN0aW9uTmF0aXZlUmFuZ2UiLCJyYW5nZUNvbnRhaW5zU2luZ2xlRWxlbWVudCIsInJhbmdlTm9kZXMiLCJnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlIiwidXBkYXRlRnJvbVRleHRSYW5nZSIsIndyYXBwZWRSYW5nZSIsInVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24iLCJkb2NTZWxlY3Rpb24iLCJjb250cm9sUmFuZ2UiLCJpdGVtIiwiYWRkUmFuZ2VUb0NvbnRyb2xTZWxlY3Rpb24iLCJyYW5nZUVsZW1lbnQiLCJuZXdDb250cm9sUmFuZ2UiLCJhZGQiLCJzZWxlY3QiLCJnZXRTZWxlY3Rpb25SYW5nZUF0IiwiV3JhcHBlZFNlbGVjdGlvbiIsImRvY1NlbCIsImdldElmcmFtZVNlbGVjdGlvbiIsInNlbFByb3RvIiwiY3JlYXRlQ29udHJvbFNlbGVjdGlvbiIsInJhbmdlcyIsImFkZFJhbmdlQmFja3dhcmRzIiwicHJldmlvdXNSYW5nZUNvdW50Iiwic2VsZWN0aW9uSXNCYWNrd2FyZHMiLCJzZXRSYW5nZXMiLCJlbXB0eSIsInJlZnJlc2hTZWxlY3Rpb24iLCJjaGVja0ZvckNoYW5nZXMiLCJvbGRSYW5nZXMiLCJyZW1vdmVSYW5nZU1hbnVhbGx5IiwiZ2V0QWxsUmFuZ2VzIiwicmVtb3ZlZCIsInJlbW92ZVJhbmdlIiwiaXNCYWNrd2FyZHMiLCJyYW5nZVRleHRzIiwiYXNzZXJ0Tm9kZUluU2FtZURvY3VtZW50IiwiY29sbGFwc2VUb1N0YXJ0IiwiY29sbGFwc2VUb0VuZCIsInNlbGVjdEFsbENoaWxkcmVuIiwiZGVsZXRlRnJvbURvY3VtZW50IiwiZWxlbWVudCIsInNldFNpbmdsZVJhbmdlIiwiaHRtbCIsInJhbmdlSW5zcGVjdHMiLCJhbmNob3IiLCJmb2N1cyIsIlNlbGVjdGlvbiIsInNlbGVjdGlvblByb3RvdHlwZSIsIkJhc2UiLCJfaW5zdGFuY2UiLCJfc3RhdGljIiwiX3Byb3RvdHlwaW5nIiwicHJvdG8iLCJiYXNlIiwia2xhc3MiLCJfY29uc3RydWN0aW5nIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiaW1wbGVtZW50IiwidmFsdWVPZiIsInNvdXJjZSIsInZhbHVlIiwibWV0aG9kIiwicHJldmlvdXMiLCJ0b1NvdXJjZSIsImhpZGRlbiIsImtleSIsIk9iamVjdCIsIm9iamVjdCIsImJsb2NrIiwiY29udGV4dCIsInVuZGVmaW5lZCIsIlN0cmluZyIsImJyb3dzZXIiLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJ0ZXN0RWxlbWVudCIsImlzSUUiLCJpbmRleE9mIiwiaXNHZWNrbyIsImlzV2ViS2l0IiwiaXNDaHJvbWUiLCJpc09wZXJhIiwiaW9zVmVyc2lvbiIsIm1hdGNoIiwiVVNFUl9BR0VOVCIsInRvTG93ZXJDYXNlIiwiaGFzQ29udGVudEVkaXRhYmxlU3VwcG9ydCIsImhhc0VkaXRpbmdBcGlTdXBwb3J0IiwiZXhlY0NvbW1hbmQiLCJxdWVyeUNvbW1hbmRTdXBwb3J0ZWQiLCJxdWVyeUNvbW1hbmRTdGF0ZSIsImhhc1F1ZXJ5U2VsZWN0b3JTdXBwb3J0IiwicXVlcnlTZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpc0luY29tcGF0aWJsZU1vYmlsZUJyb3dzZXIiLCJpc0lvcyIsImlzVG91Y2hEZXZpY2UiLCJzdXBwb3J0c0V2ZW50Iiwic3VwcG9ydHNTYW5kYm94ZWRJZnJhbWVzIiwidGhyb3dzTWl4ZWRDb250ZW50V2FybmluZ1doZW5JZnJhbWVTcmNJc0VtcHR5IiwiZGlzcGxheXNDYXJldEluRW1wdHlDb250ZW50RWRpdGFibGVDb3JyZWN0bHkiLCJoYXNDdXJyZW50U3R5bGVQcm9wZXJ0eSIsImluc2VydHNMaW5lQnJlYWtzT25SZXR1cm4iLCJzdXBwb3J0c1BsYWNlaG9sZGVyQXR0cmlidXRlT24iLCJldmVudE5hbWUiLCJzZXRBdHRyaWJ1dGUiLCJzdXBwb3J0c0V2ZW50c0luSWZyYW1lQ29ycmVjdGx5IiwiZmlyZXNPbkRyb3BPbmx5V2hlbk9uRHJhZ092ZXJJc0NhbmNlbGxlZCIsInN1cHBvcnRzRGF0YVRyYW5zZmVyIiwiQ2xpcGJvYXJkIiwiRGF0YVRyYW5zZmVyIiwiZ2V0RGF0YSIsInN1cHBvcnRzSFRNTDVUYWdzIiwiaHRtbDUiLCJzdXBwb3J0c0NvbW1hbmQiLCJidWdneUNvbW1hbmRzIiwiY29tbWFuZCIsImlzQnVnZ3kiLCJlMSIsInF1ZXJ5Q29tbWFuZEVuYWJsZWQiLCJlMiIsImRvZXNBdXRvTGlua2luZ0luQ29udGVudEVkaXRhYmxlIiwiY2FuRGlzYWJsZUF1dG9MaW5raW5nIiwiY2xlYXJzQ29udGVudEVkaXRhYmxlQ29ycmVjdGx5Iiwic3VwcG9ydHNHZXRBdHRyaWJ1dGVDb3JyZWN0bHkiLCJ0ZCIsImdldEF0dHJpYnV0ZSIsImNhblNlbGVjdEltYWdlc0luQ29udGVudEVkaXRhYmxlIiwiY2xlYXJzTGlzdHNJbkNvbnRlbnRFZGl0YWJsZUNvcnJlY3RseSIsImF1dG9TY3JvbGxzVG9DYXJldCIsImF1dG9DbG9zZXNVbmNsb3NlZFRhZ3MiLCJjbG9uZWRUZXN0RWxlbWVudCIsInN1cHBvcnRzTmF0aXZlR2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJzdXBwb3J0c1NlbGVjdGlvbk1vZGlmeSIsInN1cHBvcnRzQ2xhc3NMaXN0IiwibmVlZHNTcGFjZUFmdGVyTGluZUJyZWFrIiwic3VwcG9ydHNTcGVlY2hBcGlPbiIsImlucHV0IiwiY2hyb21lVmVyc2lvbiIsImNyYXNoZXNXaGVuRGVmaW5lUHJvcGVydHkiLCJwcm9wZXJ0eSIsImRvZXNBc3luY0ZvY3VzIiwiaGFzUHJvYmxlbXNTZXR0aW5nQ2FyZXRBZnRlckltZyIsImhhc1VuZG9JbkNvbnRleHRNZW51IiwiYXJyYXkiLCJuZWVkbGUiLCJ3aXRob3V0IiwiYXJyYXlUb1N1YnN0cmFjdCIsIm5ld0FyciIsImdldCIsIm5ld0FycmF5IiwiRGlzcGF0Y2hlciIsIm9ic2VydmUiLCJoYW5kbGVyIiwiZXZlbnRzIiwib24iLCJmaXJlIiwicGF5bG9hZCIsImhhbmRsZXJzIiwic3RvcE9ic2VydmluZyIsIm5ld0hhbmRsZXJzIiwibWVyZ2UiLCJvdGhlck9iaiIsIm5ld09iaiIsImlzQXJyYXkiLCJXSElURV9TUEFDRV9TVEFSVCIsIldISVRFX1NQQUNFX0VORCIsInN0cmluZyIsInN0ciIsInRyaW0iLCJpbnRlcnBvbGF0ZSIsInZhcnMiLCJieSIsInNlYXJjaCIsInNwbGl0IiwiSUdOT1JFX1VSTFNfSU4iLCJVUkxfUkVHX0VYUCIsIlRSQUlMSU5HX0NIQVJfUkVHX0VYUCIsIk1BWF9ESVNQTEFZX0xFTkdUSCIsIkJSQUNLRVRTIiwiYXV0b0xpbmsiLCJfaGFzUGFyZW50VGhhdFNob3VsZEJlSWdub3JlZCIsIl9wYXJzZU5vZGUiLCJfY29udmVydFVybHNUb0xpbmtzIiwidXJsIiwicHVuY3R1YXRpb24iLCJvcGVuaW5nIiwicmVhbFVybCIsImRpc3BsYXlVcmwiLCJzdWJzdHIiLCJfZ2V0VGVtcEVsZW1lbnQiLCJ0ZW1wRWxlbWVudCIsIl93eXNpaHRtbDVfdGVtcEVsZW1lbnQiLCJfd3JhcE1hdGNoZXNJbk5vZGUiLCJjaGlsZE5vZGVzTGVuZ3RoIiwiYWRkQ2xhc3MiLCJjbGFzc05hbWUiLCJjbGFzc0xpc3QiLCJoYXNDbGFzcyIsInJlbW92ZUNsYXNzIiwiZWxlbWVudENsYXNzTmFtZSIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiY29udmVydFRvTGlzdCIsIl9jcmVhdGVMaXN0SXRlbSIsImxpc3QiLCJsaXN0SXRlbSIsIl9jcmVhdGVMaXN0IiwibGlzdFR5cGUiLCJsaW5lQnJlYWtzIiwibGluZUJyZWFrc0xlbmd0aCIsImNoaWxkTm9kZSIsImxpbmVCcmVhayIsImlzQmxvY2tFbGVtZW50IiwiaXNMaW5lQnJlYWsiLCJjdXJyZW50TGlzdEl0ZW0iLCJnZXRTdHlsZSIsImZyb20iLCJpbnNlcnQiLCJhZnRlciIsInJlcGxhY2VDaGlsZCIsImNvcHlBdHRyaWJ1dGVzIiwiYXR0cmlidXRlc1RvQ29weSIsImVsZW1lbnRUb0NvcHlGcm9tIiwidG8iLCJlbGVtZW50VG9Db3B5VG8iLCJhdHRyaWJ1dGUiLCJhbmRUbyIsImNhbGxlZSIsIkJPWF9TSVpJTkdfUFJPUEVSVElFUyIsInNob3VsZElnbm9yZUJveFNpemluZ0JvcmRlckJveCIsImhhc0JveFNpemluZ0JvcmRlckJveCIsInBhcnNlSW50Iiwib2Zmc2V0V2lkdGgiLCJjb3B5U3R5bGVzIiwic3R5bGVzVG9Db3B5IiwiY3NzVGV4dCIsImhlaWdodF9yIiwiaGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0Iiwic2V0U3R5bGVzIiwiZGVsZWdhdGUiLCJzZWxlY3RvciIsImV2ZW50IiwiZ2V0QXNEb20iLCJfaW5uZXJIVE1MU2hpdiIsInN0eWxlIiwiZGlzcGxheSIsIl9lbnN1cmVIVE1MNUNvbXBhdGliaWxpdHkiLCJfd3lzaWh0bWw1X3N1cHBvcnRzSFRNTDVUYWdzIiwiSFRNTDVfRUxFTUVOVFMiLCJnZXRQYXJlbnRFbGVtZW50IiwiX2lzU2FtZU5vZGVOYW1lIiwiZGVzaXJlZE5vZGVOYW1lcyIsIl9pc0VsZW1lbnQiLCJfaGFzQ2xhc3NOYW1lIiwiY2xhc3NSZWdFeHAiLCJjbGFzc05hbWVzIiwiX2dldFBhcmVudEVsZW1lbnRXaXRoTm9kZU5hbWUiLCJsZXZlbHMiLCJfZ2V0UGFyZW50RWxlbWVudFdpdGhOb2RlTmFtZUFuZENsYXNzTmFtZSIsIm1hdGNoaW5nU2V0Iiwic3R5bGVQcm9wZXJ0eU1hcHBpbmciLCJSRUdfRVhQX0NBTUVMSVpFIiwiY2FtZWxpemUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsImNhbWVsaXplZFByb3BlcnR5IiwiY3VycmVudFN0eWxlIiwic3R5bGVWYWx1ZSIsIm5lZWRzT3ZlcmZsb3dSZXNldCIsIm9yaWdpbmFsT3ZlcmZsb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3ciLCJnZXRQcm9wZXJ0eVZhbHVlIiwiaGFzRWxlbWVudFdpdGhUYWdOYW1lIiwiTElWRV9DQUNIRSIsIkRPQ1VNRU5UX0lERU5USUZJRVIiLCJfZ2V0RG9jdW1lbnRJZGVudGlmaWVyIiwiX3d5c2lodG1sNV9pZGVudGlmaWVyIiwidGFnTmFtZSIsImNhY2hlRW50cnkiLCJoYXNFbGVtZW50V2l0aENsYXNzTmFtZSIsImVsZW1lbnRUb0luc2VydCIsImJlZm9yZSIsImludG8iLCJpbnNlcnRDU1MiLCJydWxlcyIsImhlYWQiLCJzdHlsZUVsZW1lbnQiLCJzdHlsZVNoZWV0IiwiZXZlbnROYW1lcyIsImhhbmRsZXJXcmFwcGVyIiwic3JjRWxlbWVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FuY2VsQnViYmxlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaEV2ZW50IiwicGFyc2UiLCJOT0RFX1RZUEVfTUFQUElORyIsIl9oYW5kbGVFbGVtZW50IiwiX2hhbmRsZVRleHQiLCJERUZBVUxUX05PREVfTkFNRSIsIldISVRFX1NQQUNFX1JFR19FWFAiLCJkZWZhdWx0UnVsZXMiLCJ0YWdzIiwiY2xhc3NlcyIsImN1cnJlbnRSdWxlcyIsImVsZW1lbnRPckh0bWwiLCJjbGVhblVwIiwiaXNTdHJpbmciLCJfY29udmVydCIsImdldENvcnJlY3RJbm5lckhUTUwiLCJvbGROb2RlIiwib2xkTm9kZVR5cGUiLCJvbGRDaGlsZHMiLCJvbGRDaGlsZHNMZW5ndGgiLCJuZXdDaGlsZCIsImF0dHJpYnV0ZXMiLCJydWxlIiwiZW5kVGFnIiwidGFnUnVsZXMiLCJzY29wZU5hbWUiLCJfd3lzaWh0bWw1Iiwib3V0ZXJIVE1MIiwicmVuYW1lX3RhZyIsIl9oYW5kbGVBdHRyaWJ1dGVzIiwic2V0Q2xhc3MiLCJzZXRfY2xhc3MiLCJhZGRfY2xhc3MiLCJzZXRBdHRyaWJ1dGVzIiwic2V0X2F0dHJpYnV0ZXMiLCJjaGVja0F0dHJpYnV0ZXMiLCJjaGVja19hdHRyaWJ1dGVzIiwiYWxsb3dlZENsYXNzZXMiLCJuZXdDbGFzc2VzIiwibmV3VW5pcXVlQ2xhc3NlcyIsIm9sZENsYXNzZXMiLCJjbGFzc2VzTGVuZ3RoIiwibmV3Q2xhc3Nlc0xlbmd0aCIsImN1cnJlbnRDbGFzcyIsIm5ld0NsYXNzIiwiYXR0cmlidXRlTmFtZSIsIm5ld0F0dHJpYnV0ZVZhbHVlIiwiYXR0cmlidXRlQ2hlY2tNZXRob2RzIiwiX2dldEF0dHJpYnV0ZSIsImFkZENsYXNzTWV0aG9kcyIsInVuc2hpZnQiLCJzcmMiLCJ3aWR0aCIsIkhBU19HRVRfQVRUUklCVVRFX0JVRyIsIl9pc0xvYWRlZEltYWdlIiwiaGFzQXR0cmlidXRlIiwiY29tcGxldGUiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJyZWFkeVN0YXRlIiwiUkVHX0VYUCIsImF0dHJpYnV0ZVZhbHVlIiwiYWx0IiwibnVtYmVycyIsImFsaWduX2ltZyIsIm1hcHBpbmciLCJsZWZ0IiwicmlnaHQiLCJhbGlnbl90ZXh0IiwiY2VudGVyIiwianVzdGlmeSIsImNsZWFyX2JyIiwiYm90aCIsImFsbCIsInNpemVfZm9udCIsInJlbW92ZUVtcHR5VGV4dE5vZGVzIiwicmVuYW1lRWxlbWVudCIsIm5ld05vZGVOYW1lIiwibmV3RWxlbWVudCIsInJlcGxhY2VXaXRoQ2hpbGROb2RlcyIsIl9pc0Jsb2NrRWxlbWVudCIsIl9pc0xpbmVCcmVhayIsIl9hcHBlbmRMaW5lQnJlYWsiLCJyZXNvbHZlTGlzdCIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJpc0xhc3RDaGlsZCIsInNob3VsZEFwcGVuZExpbmVCcmVhayIsIndpbmRvd1Byb3BlcnRpZXMiLCJ3aW5kb3dQcm9wZXJ0aWVzMiIsImRvY3VtZW50UHJvcGVydGllcyIsIlNhbmRib3giLCJyZWFkeUNhbGxiYWNrIiwiY2FsbGJhY2siLCJfY3JlYXRlSWZyYW1lIiwiaW5zZXJ0SW50byIsImdldEVsZW1lbnRCeUlkIiwiZ2V0SWZyYW1lIiwiX3JlYWR5RXJyb3IiLCJkZXN0cm95IiwidGhhdCIsIm9ubG9hZCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsIl9vbkxvYWRJZnJhbWUiLCJpZnJhbWVXaW5kb3ciLCJpZnJhbWVEb2N1bWVudCIsImNoYXJzZXQiLCJjaGFyYWN0ZXJTZXQiLCJzYW5kYm94SHRtbCIsIl9nZXRIdG1sIiwic3R5bGVzaGVldHMiLCJvbmVycm9yIiwiZXJyb3JNZXNzYWdlIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiX3Vuc2V0IiwibG9hZGVkIiwic2V0VGltZW91dCIsInRlbXBsYXRlVmFycyIsInNldHRlciIsIl9fZGVmaW5lR2V0dGVyX18iLCJfX2RlZmluZVNldHRlcl9fIiwic2V0IiwiZGVmaW5lUHJvcGVydHkiLCJzdHlsZXMiLCJjc3NGbG9hdCIsInN0eWxlRmxvYXQiLCJzaW11bGF0ZVBsYWNlaG9sZGVyIiwiZWRpdG9yIiwidmlldyIsInBsYWNlaG9sZGVyVGV4dCIsIkNMQVNTX05BTUUiLCJ1bnNldCIsImhhc1BsYWNlaG9sZGVyU2V0IiwiY2xlYXIiLCJpc0VtcHR5Iiwic2V0VmFsdWUiLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50IiwiZ2V0VGV4dENvbnRlbnQiLCJpbm5lclRleHQiLCJub2RlVmFsdWUiLCJjbGVhblBhc3RlZEhUTUwiLCJtYXRjaGVzIiwibWF0Y2hlc0xlbmd0aCIsImoiLCJlbHMiLCJkaXZzIiwiZGl2IiwibmV3X2RpdiIsInJlcGxhY2VXaXRoIiwicF9lbHMiLCIkIiwiYnJfZWxzIiwiYnIiLCJlbnN1cmVQcm9wZXJDbGVhcmluZyIsImNsZWFySWZOZWNlc3NhcnkiLCJjb21wb3NlciIsImVuc3VyZVByb3BlckNsZWFyaW5nT2ZMaXN0cyIsIkVMRU1FTlRTX1RIQVRfQ09OVEFJTl9MSSIsImNvbnRlbnRFZGl0YWJsZUVsZW1lbnQiLCJsaXN0SXNGaXJzdENoaWxkT2ZDb250ZW50RWRpdGFibGUiLCJoYXNPbmx5T25lTGlzdEl0ZW0iLCJvbmx5TGlzdEl0ZW1Jc0VtcHR5Iiwia2V5Q29kZSIsImdldFNlbGVjdGVkTm9kZSIsIlRJTERFX0VTQ0FQRUQiLCJlbGVtZW50c1dpdGhUaWxkZSIsInVybFRvU2VhcmNoIiwiaHJlZiIsIlVTRV9OQVRJVkVfTElORV9CUkVBS19XSEVOX0NBUkVUX0lOU0lERV9UQUdTIiwiTElTVF9UQUdTIiwiaW5zZXJ0TGluZUJyZWFrT25SZXR1cm4iLCJ1bndyYXAiLCJzZWxlY3RlZE5vZGUiLCJpbnZpc2libGVTcGFjZSIsImtleURvd24iLCJzaGlmdEtleSIsImJsb2NrRWxlbWVudCIsImV4ZWMiLCJyZWRyYXciLCJfZ2V0Q3VtdWxhdGl2ZU9mZnNldFRvcCIsInRvcCIsIm9mZnNldFRvcCIsIm9mZnNldFBhcmVudCIsImdldEJvb2ttYXJrIiwiZ2V0UmFuZ2UiLCJzZXRCb29rbWFyayIsImJvb2ttYXJrIiwic2V0U2VsZWN0aW9uIiwic2V0QmVmb3JlIiwic2V0QWZ0ZXIiLCJpc0VsZW1lbnQiLCJkaXNwbGF5U3R5bGUiLCJleGVjdXRlQW5kUmVzdG9yZSIsInJlc3RvcmVTY3JvbGxQb3NpdGlvbiIsIm9sZFNjcm9sbFRvcCIsInNjcm9sbFRvcCIsIm9sZFNjcm9sbExlZnQiLCJzY3JvbGxMZWZ0IiwicGxhY2Vob2xkZXJIVE1MIiwibmV3UmFuZ2UiLCJlMyIsImNhcmV0UGxhY2Vob2xkZXIiLCJlNCIsImV4ZWN1dGVBbmRSZXN0b3JlU2ltcGxlIiwiZmlyc3ROb2RlIiwibGFzdE5vZGUiLCJyYW5nZUJhY2t1cCIsImluc2VydEhUTUwiLCJzdXJyb3VuZCIsInNjcm9sbEludG9WaWV3IiwiaGFzU2Nyb2xsQmFycyIsInNjcm9sbEhlaWdodCIsIl93eXNpaHRtbDVTY3JvbGxJbnRvVmlld0VsZW1lbnQiLCJzZWxlY3RMaW5lIiwiX3NlbGVjdExpbmVfVzNDIiwiX3NlbGVjdExpbmVfTVNJRSIsIm1vZGlmeSIsInJhbmdlVG9wIiwiYm91bmRpbmdUb3AiLCJyYW5nZUhlaWdodCIsImJvdW5kaW5nSGVpZ2h0Iiwic2Nyb2xsV2lkdGgiLCJyYW5nZUJvdHRvbSIsInJhbmdlRW5kIiwibWVhc3VyZU5vZGUiLCJtb3ZlVG9Qb2ludCIsImdldFRleHQiLCJkZWZhdWx0VGFnTmFtZSIsIlJFR19FWFBfV0hJVEVfU1BBQ0UiLCJjc3NDbGFzcyIsInJlZ0V4cCIsIm1hdGNoaW5nQ2xhc3NOYW1lcyIsImhhc1NhbWVDbGFzc2VzIiwiZWwxIiwiZWwyIiwicmVwbGFjZVdpdGhPd25DaGlsZHJlbiIsImVsZW1lbnRzSGF2ZVNhbWVOb25DbGFzc0F0dHJpYnV0ZXMiLCJhdHRyMSIsImF0dHIyIiwiZ2V0TmFtZWRJdGVtIiwic3BlY2lmaWVkIiwiaXNTcGxpdFBvaW50Iiwic3BsaXROb2RlQXQiLCJkZXNjZW5kYW50Tm9kZSIsImRlc2NlbmRhbnRPZmZzZXQiLCJyZW1vdmVBdHRyaWJ1dGUiLCJNZXJnZSIsImlzRWxlbWVudE1lcmdlIiwiZmlyc3RUZXh0Tm9kZSIsImRvTWVyZ2UiLCJnZXRMZW5ndGgiLCJIVE1MQXBwbGllciIsInRhZ05hbWVzIiwic2ltaWxhckNsYXNzUmVnRXhwIiwibm9ybWFsaXplIiwiYXBwbHlUb0FueVRhZ05hbWUiLCJnZXRBbmNlc3RvcldpdGhDbGFzcyIsImNzc0NsYXNzTWF0Y2giLCJwb3N0QXBwbHkiLCJtZXJnZXMiLCJjdXJyZW50TWVyZ2UiLCJyYW5nZVN0YXJ0Tm9kZSIsInJhbmdlRW5kTm9kZSIsInJhbmdlU3RhcnRPZmZzZXQiLCJyYW5nZUVuZE9mZnNldCIsInByZWNlZGluZ1RleHROb2RlIiwiZ2V0QWRqYWNlbnRNZXJnZWFibGVUZXh0Tm9kZSIsIm5leHRUZXh0Tm9kZSIsImZvcndhcmQiLCJpc1RleHROb2RlIiwiYWRqYWNlbnROb2RlIiwicHJvcE5hbWUiLCJhcmVFbGVtZW50c01lcmdlYWJsZSIsImNyZWF0ZUNvbnRhaW5lciIsImFwcGx5VG9UZXh0Tm9kZSIsImlzUmVtb3ZhYmxlIiwidW5kb1RvVGV4dE5vZGUiLCJhbmNlc3RvcldpdGhDbGFzcyIsImFuY2VzdG9yUmFuZ2UiLCJhcHBseVRvUmFuZ2UiLCJ1bmRvVG9SYW5nZSIsImdldFRleHRTZWxlY3RlZEJ5UmFuZ2UiLCJpc0FwcGxpZWRUb1JhbmdlIiwic2VsZWN0ZWRUZXh0IiwidG9nZ2xlUmFuZ2UiLCJDb21tYW5kcyIsInN1cHBvcnQiLCJyZXN1bHQiLCJzdGF0ZSIsImNvbW1hbmRWYWx1ZSIsInF1ZXJ5Q29tbWFuZFZhbHVlIiwidW5kZWYiLCJib2xkIiwiZm9ybWF0SW5saW5lIiwiY29sb3IiLCJOT0RFX05BTUUiLCJfcmVtb3ZlRm9ybWF0IiwiYW5jaG9ycyIsImNvZGVFbGVtZW50IiwiX2Zvcm1hdCIsInRlbXBDbGFzcyIsIkRhdGUiLCJ0ZW1wQ2xhc3NSZWdFeHAiLCJoYXNFbGVtZW50Q2hpbGQiLCJlbGVtZW50VG9TZXRDYXJldEFmdGVyIiwid2hpdGVTcGFjZSIsImNyZWF0ZUxpbmsiLCJmb250U2l6ZSIsInNpemUiLCJmb3JlQ29sb3IiLCJCTE9DS19FTEVNRU5UU19HUk9VUCIsIl9hZGRDbGFzcyIsIl9yZW1vdmVDbGFzcyIsIl9pc0JsYW5rVGV4dE5vZGUiLCJfZ2V0UHJldmlvdXNTaWJsaW5nVGhhdElzTm90QmxhbmsiLCJfZ2V0TmV4dFNpYmxpbmdUaGF0SXNOb3RCbGFuayIsIl9hZGRMaW5lQnJlYWtCZWZvcmVBbmRBZnRlciIsIl9pc0xpbmVCcmVha09yQmxvY2tFbGVtZW50IiwiX3JlbW92ZUxpbmVCcmVha0JlZm9yZUFuZEFmdGVyIiwiX3JlbW92ZUxhc3RDaGlsZElmTGluZUJyZWFrIiwiX2V4ZWNDb21tYW5kIiwiZXZlbnRMaXN0ZW5lciIsIl9zZWxlY3RMaW5lQW5kV3JhcCIsIl9oYXNDbGFzc2VzIiwiZm9ybWF0QmxvY2siLCJoYXNDbGFzc2VzIiwiQUxJQVNfTUFQUElORyIsImh0bWxBcHBsaWVyIiwiX2dldFRhZ05hbWVzIiwiYWxpYXMiLCJfZm9ybWF0Q2xlYXIiLCJlYWNoIiwiY2hpbGRyZW4iLCJmb250X2VsIiwic3Bhbl9lbCIsInJlZHVjZWRfZGltZW5zaW9uIiwibm90X3NwYW5fbGlzdCIsIm5vdCIsInRvQXJyYXkiLCJub3Rfc3Bhbl9saXN0X2l0ZW0iLCJuZXdfZWwiLCJpcyIsImZpbmQiLCJzcGFuIiwiY2xhc3NfbmFtZSIsImNoaWxkX3NwYW4iLCJwYXJlbnRzIiwiaHRtbF90ZXh0IiwiX2dldEFwcGxpZXIiLCJpZGVudGlmaWVyIiwiYWxpYXNUYWdOYW1lIiwiaW5zZXJ0SW1hZ2UiLCJpbWFnZSIsImltYWdlc0luU2VsZWN0aW9uIiwiTElORV9CUkVBSyIsImluc2VydExpbmVCcmVhayIsImluc2VydE9yZGVyZWRMaXN0Iiwib3RoZXJMaXN0IiwidGVtcENsYXNzTmFtZSIsImdldFRpbWUiLCJpbnNlcnRVbm9yZGVyZWRMaXN0IiwiaXRhbGljIiwianVzdGlmeUNlbnRlciIsImp1c3RpZnlMZWZ0IiwianVzdGlmeVJpZ2h0IiwidW5kZXJsaW5lIiwiWl9LRVkiLCJZX0tFWSIsIk1BWF9ISVNUT1JZX0VOVFJJRVMiLCJVTkRPX0hUTUwiLCJSRURPX0hUTUwiLCJjbGVhblRlbXBFbGVtZW50cyIsIlVuZG9NYW5hZ2VyIiwiaGlzdG9yeSIsImdldFZhbHVlIiwicG9zaXRpb24iLCJfb2JzZXJ2ZSIsInNhbmRib3giLCJsYXN0S2V5IiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJpc1VuZG8iLCJpc1JlZG8iLCJ1bmRvIiwicmVkbyIsInRyYW5zYWN0IiwiaW50ZXJ2YWwiLCJvYnNlcnZlZCIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInByZXZpb3VzSHRtbCIsImN1cnJlbnRIdG1sIiwic2hpZnQiLCJWaWV3IiwidGV4dGFyZWFFbGVtZW50IiwiX29ic2VydmVWaWV3Q2hhbmdlIiwiY3VycmVudFZpZXciLCJzaG93IiwiaGlkZSIsImRpc2FibGUiLCJlbmFibGUiLCJDb21wb3NlciIsIkNBUkVUX0hBQ0siLCJ0ZXh0YXJlYSIsIl9pbml0U2FuZGJveCIsIl9kaXNwbGF5U3R5bGUiLCJzZXRUb0VuZCIsImVsZW1lbnRzV2l0aFZpc3VhbFZhbHVlIiwiX2NyZWF0ZSIsImhpZGRlbkZpZWxkIiwiY29tcG9zZXJDbGFzc05hbWUiLCJwbGFjZWhvbGRlciIsIl9pbml0QXV0b0xpbmtpbmciLCJfaW5pdE9iamVjdFJlc2l6aW5nIiwiX2luaXRVbmRvTWFuYWdlciIsImluaXRTeW5jIiwic3luYyIsInN1cHBvcnRzRGlzYWJsaW5nT2ZBdXRvTGlua2luZyIsInN1cHBvcnRzQXV0b0xpbmtpbmciLCJsaW5rcyIsInVybFJlZ0V4cCIsImxpbmsiLCJuZXdUZXh0Q29udGVudCIsInByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzTGVuZ3RoIiwiYWxsb3dPYmplY3RSZXNpemluZyIsIkhPU1RfVEVNUExBVEUiLCJURVhUX0ZPUk1BVFRJTkciLCJCT1hfRk9STUFUVElORyIsIlJFU0laRV9TVFlMRSIsIkFERElUSU9OQUxfQ1NTX1JVTEVTIiwiZm9jdXNXaXRob3V0U2Nyb2xsaW5nIiwic2V0QWN0aXZlIiwiZWxlbWVudFN0eWxlIiwib3JpZ2luYWxTY3JvbGxUb3AiLCJvcmlnaW5hbFNjcm9sbExlZnQiLCJvcmlnaW5hbFN0eWxlcyIsIldlYmtpdFVzZXJTZWxlY3QiLCJzY3JvbGxUbyIsIm9yaWdpbmFsQWN0aXZlRWxlbWVudCIsImhhc1BsYWNlaG9sZGVyIiwib3JpZ2luYWxQbGFjZWhvbGRlciIsImZvY3VzU3R5bGVzSG9zdCIsImJsdXJTdHlsZXNIb3N0IiwiYmx1ciIsImJveEZvcm1hdHRpbmdTdHlsZXMiLCJ3aW5PYnNlcnZlciIsIm9yaWdpbmFsVGV4dGFyZWFEaXNwbGF5U3R5bGUiLCJvcmlnaW5hbENvbXBvc2VyRGlzcGxheVN0eWxlIiwic2hvcnRjdXRzIiwiZm9jdXNCbHVyRWxlbWVudCIsInBhc3RlRXZlbnRzIiwiZG9tTm9kZVJlbW92ZWRJbnRlcnZhbCIsImRhdGFUcmFuc2ZlciIsInRpdGxlUHJlZml4ZXMiLCJJTUciLCJBIiwidGl0bGUiLCJoYXNUaXRsZSIsIklOVEVSVkFMIiwiU3luY2hyb25pemVyIiwiZnJvbUNvbXBvc2VyVG9UZXh0YXJlYSIsInNob3VsZFBhcnNlSHRtbCIsImZyb21UZXh0YXJlYVRvQ29tcG9zZXIiLCJ0ZXh0YXJlYVZhbHVlIiwiZm9ybSIsInN0YXJ0SW50ZXJ2YWwiLCJzdG9wSW50ZXJ2YWwiLCJUZXh0YXJlYSIsInN1cHBvcnRzUGxhY2Vob2xkZXIiLCJldmVudE1hcHBpbmciLCJmb2N1c2luIiwiZm9jdXNvdXQiLCJDTEFTU19OQU1FX09QRU5FRCIsIlNFTEVDVE9SX0ZPUk1fRUxFTUVOVFMiLCJTRUxFQ1RPUl9GSUVMRFMiLCJBVFRSSUJVVEVfRklFTERTIiwiRGlhbG9nIiwiX29ic2VydmVkIiwiY2FsbGJhY2tXcmFwcGVyIiwiX3NlcmlhbGl6ZSIsImVsZW1lbnRUb0NoYW5nZSIsImZvcm1FbGVtZW50cyIsIl9jbGVhckludGVydmFsIiwiZmllbGRzIiwiX2ludGVycG9sYXRlIiwiYXZvaWRIaWRkZW5GaWVsZHMiLCJmaWVsZCIsImZpZWxkTmFtZSIsIm5ld1ZhbHVlIiwiZm9jdXNlZEVsZW1lbnQiLCJkZWZhdWx0VmFsdWUiLCJmaXJzdEZpZWxkIiwibGlua1N0eWxlcyIsIndyYXBwZXJTdHlsZXMiLCJtYXJnaW4iLCJvcGFjaXR5IiwicGFkZGluZyIsInpJbmRleCIsImlucHV0U3R5bGVzIiwiY3Vyc29yIiwibWFyZ2luVG9wIiwib3V0bGluZSIsImlucHV0QXR0cmlidXRlcyIsIlNwZWVjaCIsIndyYXBwZXIiLCJDTEFTU19OQU1FX0NPTU1BTkRfRElTQUJMRUQiLCJDTEFTU19OQU1FX0NPTU1BTkRTX0RJU0FCTEVEIiwiQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSIsIkNMQVNTX05BTUVfQUNUSU9OX0FDVElWRSIsIlRvb2xiYXIiLCJfZ2V0TGlua3MiLCJzcGVlY2hJbnB1dExpbmtzIiwiZ3JvdXAiLCJkaWFsb2ciLCJfZ2V0RGlhbG9nIiwiZGlhbG9nRWxlbWVudCIsImNhcmV0Qm9va21hcmsiLCJkaWFsb2dDb250YWluZXIiLCJjb21tYW5kTGluayIsImNvbW1hbmRzRGlzYWJsZWQiLCJjb21tYW5kT2JqIiwiY29tbWFuZE1hcHBpbmciLCJfdXBkYXRlTGlua1N0YXRlcyIsImV4ZWNBY3Rpb24iLCJhY3Rpb24iLCJjb21tYW5kTGlua3MiLCJhY3Rpb25MaW5rcyIsInVuc2VsZWN0YWJsZSIsImFjdGlvbk1hcHBpbmciLCJkZWZhdWx0Q29uZmlnIiwicGFyc2VyUnVsZXMiLCJwYXJzZXIiLCJib2R5Q2xhc3NOYW1lIiwic3VwcG9ydFRvdWNoRGV2aWNlcyIsIkVkaXRvciIsIl9pc0NvbXBhdGlibGUiLCJfaW5pdFBhcnNlciIsInN5bmNocm9uaXplciIsImlzQ29tcGF0aWJsZSIsImh0bWxPckVsZW1lbnQiLCJrZWVwU2Nyb2xsUG9zaXRpb24iLCJXeXNpaHRtbDUiLCJvcHRpb25zIiwiZGVmYXVsdHMiLCJmbiIsImVkaXRhYmxldXRpbHMiLCJpbmhlcml0IiwiZWRpdGFibGV0eXBlcyIsImFic3RyYWN0aW5wdXQiLCJyZW5kZXIiLCJkZWZlcnJlZCIsIkRlZmVycmVkIiwibXNpZU9sZCIsIiRpbnB1dCIsImF0dHIiLCJzZXRBdHRyIiwibG9hZCIsInJlc29sdmUiLCJwcm9taXNlIiwidmFsdWUyaHRtbCIsImh0bWwydmFsdWUiLCJ2YWx1ZTJpbnB1dCIsImFjdGl2YXRlIiwiJGVsZW1lbnQiLCJ0cGwiLCJpbnB1dGNsYXNzIiwialF1ZXJ5Iiwid3lzaSIsImZvbnRTdHlsZXMiLCJsb2NhbGUiLCJmb250X3N0eWxlcyIsIm5vcm1hbCIsImgxIiwiaDIiLCJoMyIsImVtcGhhc2lzIiwibGlzdHMiLCJ1bm9yZGVyZWQiLCJvcmRlcmVkIiwiY2FuY2VsIiwiZWRpdCIsImNvbG91cnMiLCJmaXJzdCIsInNlY29uZCIsInRocmVlIiwidGVtcGxhdGVzIiwidG9vbGJhck9wdHMiLCJkZWZhdWx0T3B0aW9ucyIsImN1c3RvbVRlbXBsYXRlcyIsImNyZWF0ZVRvb2xiYXIiLCJjcmVhdGVFZGl0b3IiLCJvZmYiLCJmb2N1c1d5c2lodG1sNSIsInNlbGYiLCJjdWx0dXJlIiwiYXBwZW5kIiwiaW5pdEh0bWwiLCJpbml0SW5zZXJ0TGluayIsImluaXRJbnNlcnRJbWFnZSIsImNsaWNrIiwiY2hhbmdlVmlld1NlbGVjdG9yIiwidG9nZ2xlQ2xhc3MiLCJpbnNlcnRJbWFnZU1vZGFsIiwidXJsSW5wdXQiLCJpbnNlcnRCdXR0b24iLCJpbml0aWFsVmFsdWUiLCJrZXlwcmVzcyIsIndoaWNoIiwibW9kYWwiLCJhY3RpdmVCdXR0b24iLCJhcHBlbmRUbyIsImluc2VydExpbmtNb2RhbCIsImluc2VydExpbmsiLCJyZWwiLCJwcmVzc2VkRW50ZXIiLCJtZXRob2RzIiwicmVzZXREZWZhdWx0cyIsImRlZmF1bHRPcHRpb25zQ2FjaGUiLCJieXBhc3NEZWZhdWx0cyIsIiR0aGlzIiwic2hhbGxvd0V4dGVuZCIsInNldHRpbmdzIiwiZGVlcEV4dGVuZCIsIkFycmF5IiwiZXJyb3IiLCJDb25zdHJ1Y3RvciIsImVuIiwib3V0ZGVudCIsImluZGVudCIsImJsYWNrIiwic2lsdmVyIiwiZ3JheSIsIm1hcm9vbiIsInJlZCIsInB1cnBsZSIsImdyZWVuIiwib2xpdmUiLCJuYXZ5IiwiYmx1ZSIsIm9yYW5nZSJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJQSxVQUFVLE9BQU9DLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsU0FBT0EsT0FBT0MsUUFBZCxNQUEyQixRQUEzRCxHQUFzRSxVQUFVQyxHQUFWLEVBQWU7QUFBRSxnQkFBY0EsR0FBZCwwQ0FBY0EsR0FBZDtBQUFvQixDQUEzRyxHQUE4RyxVQUFVQSxHQUFWLEVBQWU7QUFBRSxTQUFPQSxPQUFPLE9BQU9GLE1BQVAsS0FBa0IsVUFBekIsSUFBdUNFLElBQUlDLFdBQUosS0FBb0JILE1BQTNELElBQXFFRSxRQUFRRixPQUFPSSxTQUFwRixHQUFnRyxRQUFoRyxVQUFrSEYsR0FBbEgsMENBQWtIQSxHQUFsSCxDQUFQO0FBQStILENBQTVROztBQUVBLElBQUlHLFlBQVk7QUFDZEMsV0FBUyxPQURLOztBQUdkO0FBQ0FDLFlBQVUsRUFKSTtBQUtkQyxPQUFLLEVBTFM7QUFNZEMsVUFBUSxFQU5NO0FBT2RDLFdBQVMsRUFQSztBQVFkQyxRQUFNLEVBUlE7QUFTZEMsYUFBVyxFQVRHO0FBVWRDLFNBQU8sRUFWTzs7QUFZZEMsbUJBQWlCLFFBWkg7O0FBY2RDLGtCQUFnQixTQUFTQSxjQUFULEdBQTBCLENBQUUsQ0FkOUI7O0FBZ0JkQyxnQkFBYyxDQWhCQTtBQWlCZEMsYUFBVyxDQWpCRzs7QUFtQmRDLGlCQUFlLENBbkJEO0FBb0JkQyxhQUFXLEVBcEJHO0FBcUJkQyxjQUFZLEVBckJFO0FBc0JkQyxhQUFXLEVBdEJHO0FBdUJkQyxjQUFZO0FBdkJFLENBQWhCLEMsQ0F3Qkc7Ozs7Ozs7OztBQVNIQyxPQUFPLE9BQVAsSUFBa0IsWUFBWTs7QUFFNUIsTUFBSUMsU0FBUyxRQUFiO0FBQUEsTUFDSUMsV0FBVyxVQURmO0FBQUEsTUFFSUMsWUFBWSxXQUZoQjs7QUFJQSxNQUFJQyxxQkFBcUIsQ0FBQyxnQkFBRCxFQUFtQixhQUFuQixFQUFrQyxjQUFsQyxFQUFrRCxXQUFsRCxFQUErRCxXQUEvRCxFQUE0RSx5QkFBNUUsRUFBdUcsZ0JBQXZHLEVBQXlILGNBQXpILEVBQXlJLGNBQXpJLEVBQXlKLFlBQXpKLENBQXpCOztBQUVBLE1BQUlDLGtCQUFrQixDQUFDLFVBQUQsRUFBYSxnQkFBYixFQUErQixlQUEvQixFQUFnRCxRQUFoRCxFQUEwRCxjQUExRCxFQUEwRSxhQUExRSxFQUF5RixVQUF6RixFQUFxRyxZQUFyRyxFQUFtSCxvQkFBbkgsRUFBeUksdUJBQXpJLEVBQWtLLGdCQUFsSyxFQUFvTCxpQkFBcEwsRUFBdU0sZUFBdk0sRUFBd04sWUFBeE4sRUFBc08sa0JBQXRPLEVBQTBQLFlBQTFQLEVBQXdRLFVBQXhRLEVBQW9SLFFBQXBSLENBQXRCOztBQUVBLE1BQUlDLHNCQUFzQixDQUFDLGdCQUFELEVBQW1CLGNBQW5CLEVBQW1DLGFBQW5DLEVBQWtELGVBQWxELEVBQW1FLFVBQW5FLEVBQStFLE1BQS9FLENBQTFCOztBQUVBO0FBQ0EsTUFBSUMsbUJBQW1CLENBQUMsVUFBRCxFQUFhLGtCQUFiLEVBQWlDLFdBQWpDLEVBQThDLGFBQTlDLEVBQTZELGdCQUE3RCxFQUErRSxtQkFBL0UsRUFBb0csZUFBcEcsRUFBcUgsV0FBckgsRUFBa0ksUUFBbEksRUFBNEksYUFBNUksRUFBMkosdUJBQTNKLENBQXZCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFTQyxZQUFULENBQXNCQyxDQUF0QixFQUF5QkMsQ0FBekIsRUFBNEI7QUFDMUIsUUFBSUMsSUFBSW5DLFFBQVFpQyxFQUFFQyxDQUFGLENBQVIsQ0FBUjtBQUNBLFdBQU9DLEtBQUtULFFBQUwsSUFBaUIsQ0FBQyxFQUFFUyxLQUFLVixNQUFMLElBQWVRLEVBQUVDLENBQUYsQ0FBakIsQ0FBbEIsSUFBNENDLEtBQUssU0FBeEQ7QUFDRDs7QUFFRCxXQUFTQyxZQUFULENBQXNCSCxDQUF0QixFQUF5QkMsQ0FBekIsRUFBNEI7QUFDMUIsV0FBTyxDQUFDLEVBQUVsQyxRQUFRaUMsRUFBRUMsQ0FBRixDQUFSLEtBQWlCVCxNQUFqQixJQUEyQlEsRUFBRUMsQ0FBRixDQUE3QixDQUFSO0FBQ0Q7O0FBRUQsV0FBU0csY0FBVCxDQUF3QkosQ0FBeEIsRUFBMkJDLENBQTNCLEVBQThCO0FBQzVCLFdBQU9sQyxRQUFRaUMsRUFBRUMsQ0FBRixDQUFSLEtBQWlCUCxTQUF4QjtBQUNEOztBQUVEO0FBQ0EsV0FBU1csMEJBQVQsQ0FBb0NDLFFBQXBDLEVBQThDO0FBQzVDLFdBQU8sVUFBVU4sQ0FBVixFQUFhTyxLQUFiLEVBQW9CO0FBQ3pCLFVBQUlDLElBQUlELE1BQU1FLE1BQWQ7QUFDQSxhQUFPRCxHQUFQLEVBQVk7QUFDVixZQUFJLENBQUNGLFNBQVNOLENBQVQsRUFBWU8sTUFBTUMsQ0FBTixDQUFaLENBQUwsRUFBNEI7QUFDMUIsaUJBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRCxhQUFPLElBQVA7QUFDRCxLQVJEO0FBU0Q7O0FBRUQ7QUFDQSxNQUFJRSxpQkFBaUJMLDJCQUEyQk4sWUFBM0IsQ0FBckI7QUFDQSxNQUFJWSxpQkFBaUJOLDJCQUEyQkYsWUFBM0IsQ0FBckI7QUFDQSxNQUFJUyxvQkFBb0JQLDJCQUEyQkQsY0FBM0IsQ0FBeEI7O0FBRUEsV0FBU1MsV0FBVCxDQUFxQkMsS0FBckIsRUFBNEI7QUFDMUIsV0FBT0EsU0FBU0osZUFBZUksS0FBZixFQUFzQmhCLGdCQUF0QixDQUFULElBQW9EYyxrQkFBa0JFLEtBQWxCLEVBQXlCakIsbUJBQXpCLENBQTNEO0FBQ0Q7O0FBRUQsTUFBSWtCLE1BQU07QUFDUnpDLGFBQVMsT0FERDtBQUVSMEMsaUJBQWEsS0FGTDtBQUdSQyxlQUFXLElBSEg7O0FBS1JDLFVBQU07QUFDSm5CLG9CQUFjQSxZQURWO0FBRUpJLG9CQUFjQSxZQUZWO0FBR0pDLHNCQUFnQkEsY0FIWjtBQUlKTSxzQkFBZ0JBLGNBSlo7QUFLSkMsc0JBQWdCQSxjQUxaO0FBTUpDLHlCQUFtQkEsaUJBTmY7QUFPSkMsbUJBQWFBO0FBUFQsS0FMRTs7QUFlUk0sY0FBVSxFQWZGOztBQWlCUkMsYUFBUyxFQWpCRDtBQWtCUkMsWUFBUTtBQUNOQyxtQkFBYSxLQURQO0FBRU5DLHVCQUFpQjtBQUZYO0FBbEJBLEdBQVY7O0FBd0JBLFdBQVNDLElBQVQsQ0FBY0MsTUFBZCxFQUFzQjtBQUNwQmxDLFdBQU9tQyxLQUFQLENBQWEsa0RBQWtERCxNQUEvRDtBQUNBVixRQUFJQyxXQUFKLEdBQWtCLElBQWxCO0FBQ0FELFFBQUlFLFNBQUosR0FBZ0IsS0FBaEI7QUFDRDs7QUFFREYsTUFBSVMsSUFBSixHQUFXQSxJQUFYOztBQUVBLFdBQVNHLElBQVQsQ0FBY0MsR0FBZCxFQUFtQjtBQUNqQixRQUFJQyxpQkFBaUIsb0JBQW9CRCxHQUF6QztBQUNBLFFBQUliLElBQUlNLE1BQUosQ0FBV0MsV0FBZixFQUE0QjtBQUMxQi9CLGFBQU9tQyxLQUFQLENBQWFHLGNBQWI7QUFDRCxLQUZELE1BRU8sSUFBSTlELFFBQVF3QixPQUFPdUMsT0FBZixLQUEyQnBDLFNBQTNCLElBQXdDM0IsUUFBUXdCLE9BQU91QyxPQUFQLENBQWVDLEdBQXZCLEtBQStCckMsU0FBM0UsRUFBc0Y7QUFDM0ZILGFBQU91QyxPQUFQLENBQWVDLEdBQWYsQ0FBbUJGLGNBQW5CO0FBQ0Q7QUFDRjs7QUFFRGQsTUFBSVksSUFBSixHQUFXQSxJQUFYOztBQUVBLE1BQUksR0FBR0ssY0FBUCxFQUF1QjtBQUNyQmpCLFFBQUlHLElBQUosQ0FBU2UsTUFBVCxHQUFrQixVQUFVakMsQ0FBVixFQUFhTyxLQUFiLEVBQW9CO0FBQ3BDLFdBQUssSUFBSUMsQ0FBVCxJQUFjRCxLQUFkLEVBQXFCO0FBQ25CLFlBQUlBLE1BQU15QixjQUFOLENBQXFCeEIsQ0FBckIsQ0FBSixFQUE2QjtBQUMzQlIsWUFBRVEsQ0FBRixJQUFPRCxNQUFNQyxDQUFOLENBQVA7QUFDRDtBQUNGO0FBQ0YsS0FORDtBQU9ELEdBUkQsTUFRTztBQUNMZ0IsU0FBSyw4QkFBTDtBQUNEOztBQUVELE1BQUlVLGdCQUFnQixFQUFwQjtBQUNBLE1BQUlDLHFCQUFxQixFQUF6Qjs7QUFFQTtBQUNBLFdBQVNDLElBQVQsR0FBZ0I7QUFDZCxRQUFJckIsSUFBSUMsV0FBUixFQUFxQjtBQUNuQjtBQUNEO0FBQ0QsUUFBSXFCLFNBQUo7QUFDQSxRQUFJQyxxQkFBcUIsS0FBekI7QUFBQSxRQUNJQyxzQkFBc0IsS0FEMUI7O0FBR0E7O0FBRUEsUUFBSXhDLGFBQWF5QyxRQUFiLEVBQXVCLGFBQXZCLENBQUosRUFBMkM7QUFDekNILGtCQUFZRyxTQUFTQyxXQUFULEVBQVo7QUFDQSxVQUFJL0IsZUFBZTJCLFNBQWYsRUFBMEJ6QyxlQUExQixLQUE4Q2dCLGtCQUFrQnlCLFNBQWxCLEVBQTZCMUMsa0JBQTdCLENBQWxELEVBQW9HO0FBQ2xHMkMsNkJBQXFCLElBQXJCO0FBQ0Q7QUFDREQsZ0JBQVVLLE1BQVY7QUFDRDs7QUFFRCxRQUFJQyxPQUFPeEMsYUFBYXFDLFFBQWIsRUFBdUIsTUFBdkIsSUFBaUNBLFNBQVNHLElBQTFDLEdBQWlESCxTQUFTSSxvQkFBVCxDQUE4QixNQUE5QixFQUFzQyxDQUF0QyxDQUE1RDs7QUFFQSxRQUFJRCxRQUFRNUMsYUFBYTRDLElBQWIsRUFBbUIsaUJBQW5CLENBQVosRUFBbUQ7QUFDakROLGtCQUFZTSxLQUFLRSxlQUFMLEVBQVo7QUFDQSxVQUFJaEMsWUFBWXdCLFNBQVosQ0FBSixFQUE0QjtBQUMxQkUsOEJBQXNCLElBQXRCO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJLENBQUNELGtCQUFELElBQXVCLENBQUNDLG1CQUE1QixFQUFpRDtBQUMvQ2YsV0FBSyw2Q0FBTDtBQUNEOztBQUVEVCxRQUFJQyxXQUFKLEdBQWtCLElBQWxCO0FBQ0FELFFBQUlJLFFBQUosR0FBZTtBQUNibUIsMEJBQW9CQSxrQkFEUDtBQUViQywyQkFBcUJBO0FBRlIsS0FBZjs7QUFLQTtBQUNBLFFBQUlPLGVBQWVYLG1CQUFtQlksTUFBbkIsQ0FBMEJiLGFBQTFCLENBQW5CO0FBQ0EsU0FBSyxJQUFJMUIsSUFBSSxDQUFSLEVBQVd3QyxNQUFNRixhQUFhckMsTUFBbkMsRUFBMkNELElBQUl3QyxHQUEvQyxFQUFvRCxFQUFFeEMsQ0FBdEQsRUFBeUQ7QUFDdkQsVUFBSTtBQUNGc0MscUJBQWF0QyxDQUFiLEVBQWdCTyxHQUFoQjtBQUNELE9BRkQsQ0FFRSxPQUFPa0MsRUFBUCxFQUFXO0FBQ1gsWUFBSTlDLGFBQWFaLE1BQWIsRUFBcUIsU0FBckIsS0FBbUNRLGFBQWFSLE9BQU91QyxPQUFwQixFQUE2QixLQUE3QixDQUF2QyxFQUE0RTtBQUMxRXZDLGlCQUFPdUMsT0FBUCxDQUFlQyxHQUFmLENBQW1CLCtDQUFuQixFQUFvRWtCLEVBQXBFO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQWxDLE1BQUlxQixJQUFKLEdBQVdBLElBQVg7O0FBRUE7QUFDQXJCLE1BQUltQyxlQUFKLEdBQXNCLFVBQVVDLFFBQVYsRUFBb0I7QUFDeEMsUUFBSXBDLElBQUlDLFdBQVIsRUFBcUI7QUFDbkJtQyxlQUFTcEMsR0FBVDtBQUNELEtBRkQsTUFFTztBQUNMbUIsb0JBQWNrQixJQUFkLENBQW1CRCxRQUFuQjtBQUNEO0FBQ0YsR0FORDs7QUFRQSxNQUFJRSxrQ0FBa0MsRUFBdEM7O0FBRUF0QyxNQUFJdUMsaUNBQUosR0FBd0MsVUFBVUgsUUFBVixFQUFvQjtBQUMxREUsb0NBQWdDRCxJQUFoQyxDQUFxQ0QsUUFBckM7QUFDRCxHQUZEOztBQUlBLFdBQVNJLHNCQUFULENBQWdDQyxHQUFoQyxFQUFxQztBQUNuQ0EsVUFBTUEsT0FBT2pFLE1BQWI7QUFDQTZDOztBQUVBO0FBQ0EsU0FBSyxJQUFJNUIsSUFBSSxDQUFSLEVBQVd3QyxNQUFNSyxnQ0FBZ0M1QyxNQUF0RCxFQUE4REQsSUFBSXdDLEdBQWxFLEVBQXVFLEVBQUV4QyxDQUF6RSxFQUE0RTtBQUMxRTZDLHNDQUFnQzdDLENBQWhDLEVBQW1DZ0QsR0FBbkM7QUFDRDtBQUNGOztBQUVEekMsTUFBSXdDLHNCQUFKLEdBQTZCQSxzQkFBN0I7O0FBRUE7OztBQUdBLFdBQVNFLE1BQVQsQ0FBZ0JDLElBQWhCLEVBQXNCO0FBQ3BCLFNBQUtBLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUsxQyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0EsU0FBS0MsU0FBTCxHQUFpQixLQUFqQjtBQUNEOztBQUVEd0MsU0FBT3JGLFNBQVAsQ0FBaUJvRCxJQUFqQixHQUF3QixVQUFVQyxNQUFWLEVBQWtCO0FBQ3hDLFNBQUtULFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxTQUFLQyxTQUFMLEdBQWlCLEtBQWpCOztBQUVBLFVBQU0sSUFBSTBDLEtBQUosQ0FBVSxhQUFhLEtBQUtELElBQWxCLEdBQXlCLG9CQUF6QixHQUFnRGpDLE1BQTFELENBQU47QUFDRCxHQUxEOztBQU9BZ0MsU0FBT3JGLFNBQVAsQ0FBaUJ1RCxJQUFqQixHQUF3QixVQUFVQyxHQUFWLEVBQWU7QUFDckNiLFFBQUlZLElBQUosQ0FBUyxZQUFZLEtBQUsrQixJQUFqQixHQUF3QixJQUF4QixHQUErQjlCLEdBQXhDO0FBQ0QsR0FGRDs7QUFJQTZCLFNBQU9yRixTQUFQLENBQWlCd0YsV0FBakIsR0FBK0IsVUFBVWhDLEdBQVYsRUFBZTtBQUM1QyxXQUFPLElBQUkrQixLQUFKLENBQVUsb0JBQW9CLEtBQUtELElBQXpCLEdBQWdDLFdBQWhDLEdBQThDOUIsR0FBeEQsQ0FBUDtBQUNELEdBRkQ7O0FBSUFiLE1BQUk4QyxZQUFKLEdBQW1CLFVBQVVILElBQVYsRUFBZ0JJLFFBQWhCLEVBQTBCO0FBQzNDLFFBQUlDLFNBQVMsSUFBSU4sTUFBSixDQUFXQyxJQUFYLENBQWI7QUFDQTNDLFFBQUlLLE9BQUosQ0FBWXNDLElBQVosSUFBb0JLLE1BQXBCOztBQUVBNUIsdUJBQW1CaUIsSUFBbkIsQ0FBd0IsVUFBVXJDLEdBQVYsRUFBZTtBQUNyQytDLGVBQVMvQyxHQUFULEVBQWNnRCxNQUFkO0FBQ0FBLGFBQU8vQyxXQUFQLEdBQXFCLElBQXJCO0FBQ0ErQyxhQUFPOUMsU0FBUCxHQUFtQixJQUFuQjtBQUNELEtBSkQ7QUFLRCxHQVREOztBQVdBRixNQUFJaUQsY0FBSixHQUFxQixVQUFVNUMsT0FBVixFQUFtQjtBQUN0QyxTQUFLLElBQUlaLElBQUksQ0FBUixFQUFXd0MsTUFBTTVCLFFBQVFYLE1BQXpCLEVBQWlDc0QsTUFBakMsRUFBeUNFLFVBQTlDLEVBQTBEekQsSUFBSXdDLEdBQTlELEVBQW1FLEVBQUV4QyxDQUFyRSxFQUF3RTtBQUN0RXlELG1CQUFhN0MsUUFBUVosQ0FBUixDQUFiO0FBQ0F1RCxlQUFTaEQsSUFBSUssT0FBSixDQUFZNkMsVUFBWixDQUFUO0FBQ0EsVUFBSSxDQUFDRixNQUFELElBQVcsRUFBRUEsa0JBQWtCTixNQUFwQixDQUFmLEVBQTRDO0FBQzFDLGNBQU0sSUFBSUUsS0FBSixDQUFVLGFBQWFNLFVBQWIsR0FBMEIsYUFBcEMsQ0FBTjtBQUNEO0FBQ0QsVUFBSSxDQUFDRixPQUFPOUMsU0FBWixFQUF1QjtBQUNyQixjQUFNLElBQUkwQyxLQUFKLENBQVUsYUFBYU0sVUFBYixHQUEwQixpQkFBcEMsQ0FBTjtBQUNEO0FBQ0Y7QUFDRixHQVhEOztBQWFBOztBQUVBOztBQUVBLE1BQUlDLFdBQVcsS0FBZjs7QUFFQSxNQUFJQyxjQUFjLFNBQVNBLFdBQVQsQ0FBcUJDLENBQXJCLEVBQXdCOztBQUV4QyxRQUFJLENBQUNGLFFBQUwsRUFBZTtBQUNiQSxpQkFBVyxJQUFYO0FBQ0EsVUFBSSxDQUFDbkQsSUFBSUMsV0FBVCxFQUFzQjtBQUNwQm9CO0FBQ0Q7QUFDRjtBQUNGLEdBUkQ7O0FBVUE7QUFDQSxNQUFJLENBQUMsT0FBTzdDLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0MsV0FBaEMsR0FBOEN4QixRQUFRd0IsTUFBUixDQUEvQyxLQUFtRUcsU0FBdkUsRUFBa0Y7QUFDaEY4QixTQUFLLGlCQUFMO0FBQ0E7QUFDRDtBQUNELE1BQUksQ0FBQyxPQUFPZ0IsUUFBUCxLQUFvQixXQUFwQixHQUFrQyxXQUFsQyxHQUFnRHpFLFFBQVF5RSxRQUFSLENBQWpELEtBQXVFOUMsU0FBM0UsRUFBc0Y7QUFDcEY4QixTQUFLLG1CQUFMO0FBQ0E7QUFDRDs7QUFFRCxNQUFJekIsYUFBYXlDLFFBQWIsRUFBdUIsa0JBQXZCLENBQUosRUFBZ0Q7QUFDOUNBLGFBQVM2QixnQkFBVCxDQUEwQixrQkFBMUIsRUFBOENGLFdBQTlDLEVBQTJELEtBQTNEO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJcEUsYUFBYVIsTUFBYixFQUFxQixrQkFBckIsQ0FBSixFQUE4QztBQUM1Q0EsV0FBTzhFLGdCQUFQLENBQXdCLE1BQXhCLEVBQWdDRixXQUFoQyxFQUE2QyxLQUE3QztBQUNELEdBRkQsTUFFTyxJQUFJcEUsYUFBYVIsTUFBYixFQUFxQixhQUFyQixDQUFKLEVBQXlDO0FBQzlDQSxXQUFPK0UsV0FBUCxDQUFtQixRQUFuQixFQUE2QkgsV0FBN0I7QUFDRCxHQUZNLE1BRUE7QUFDTDNDLFNBQUssc0VBQUw7QUFDRDs7QUFFRCxTQUFPVCxHQUFQO0FBQ0QsQ0F6UmlCLEVBQWxCO0FBMFJBd0QsTUFBTVYsWUFBTixDQUFtQixTQUFuQixFQUE4QixVQUFVOUMsR0FBVixFQUFlZ0QsTUFBZixFQUF1Qjs7QUFFbkQsTUFBSVMsUUFBUSxXQUFaO0FBQ0EsTUFBSXRELE9BQU9ILElBQUlHLElBQWY7O0FBRUE7QUFDQSxNQUFJLENBQUNBLEtBQUtSLGNBQUwsQ0FBb0I4QixRQUFwQixFQUE4QixDQUFDLHdCQUFELEVBQTJCLGVBQTNCLEVBQTRDLGdCQUE1QyxDQUE5QixDQUFMLEVBQW1HO0FBQ2pHdUIsV0FBT3ZDLElBQVAsQ0FBWSx5Q0FBWjtBQUNEOztBQUVELE1BQUksQ0FBQ04sS0FBS25CLFlBQUwsQ0FBa0J5QyxRQUFsQixFQUE0QixzQkFBNUIsQ0FBTCxFQUEwRDtBQUN4RHVCLFdBQU92QyxJQUFQLENBQVksOENBQVo7QUFDRDs7QUFFRCxNQUFJaUQsS0FBS2pDLFNBQVNrQyxhQUFULENBQXVCLEtBQXZCLENBQVQ7QUFDQSxNQUFJLENBQUN4RCxLQUFLUixjQUFMLENBQW9CK0QsRUFBcEIsRUFBd0IsQ0FBQyxjQUFELEVBQWlCLGFBQWpCLEVBQWdDLFdBQWhDLEtBQWdELENBQUN2RCxLQUFLUCxjQUFMLENBQW9COEQsRUFBcEIsRUFBd0IsQ0FBQyxpQkFBRCxFQUFvQixhQUFwQixFQUFtQyxZQUFuQyxFQUFpRCxZQUFqRCxDQUF4QixDQUF6RSxDQUFMLEVBQXdLO0FBQ3RLVixXQUFPdkMsSUFBUCxDQUFZLG1DQUFaO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJLENBQUNOLEtBQUtkLGNBQUwsQ0FBb0JxRSxFQUFwQixFQUF3QixXQUF4QixDQUFMLEVBQTJDO0FBQ3pDVixXQUFPdkMsSUFBUCxDQUFZLHVDQUFaO0FBQ0Q7O0FBRUQsTUFBSW1ELFdBQVduQyxTQUFTb0MsY0FBVCxDQUF3QixNQUF4QixDQUFmO0FBQ0EsTUFBSSxDQUFDMUQsS0FBS1IsY0FBTCxDQUFvQmlFLFFBQXBCLEVBQThCLENBQUMsV0FBRCxFQUFjLFlBQWQsRUFBNEIsWUFBNUIsRUFBMEMsWUFBMUMsRUFBd0QsV0FBeEQsS0FBd0UsQ0FBQ3pELEtBQUtQLGNBQUwsQ0FBb0I4RCxFQUFwQixFQUF3QixDQUFDLGlCQUFELEVBQW9CLGFBQXBCLEVBQW1DLFlBQW5DLEVBQWlELFlBQWpELENBQXhCLENBQXpFLElBQW9LLENBQUN2RCxLQUFLTixpQkFBTCxDQUF1QitELFFBQXZCLEVBQWlDLENBQUMsTUFBRCxDQUFqQyxDQUFuTSxDQUFMLEVBQXFQO0FBQ25QWixXQUFPdkMsSUFBUCxDQUFZLHFDQUFaO0FBQ0Q7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSXFELGdCQUFnQjs7Ozs7QUFLcEIsV0FBU0EsYUFBVCxDQUF1QkMsR0FBdkIsRUFBNEJDLEdBQTVCLEVBQWlDO0FBQy9CLFFBQUl2RSxJQUFJc0UsSUFBSXJFLE1BQVo7QUFDQSxXQUFPRCxHQUFQLEVBQVk7QUFDVixVQUFJc0UsSUFBSXRFLENBQUosTUFBV3VFLEdBQWYsRUFBb0I7QUFDbEIsZUFBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNELFdBQU8sS0FBUDtBQUNELEdBYkQ7O0FBZUE7QUFDQSxXQUFTQyxlQUFULENBQXlCQyxJQUF6QixFQUErQjtBQUM3QixRQUFJQyxFQUFKO0FBQ0EsV0FBT25ILFFBQVFrSCxLQUFLRSxZQUFiLEtBQThCWCxLQUE5QixJQUF1QyxDQUFDVSxLQUFLRCxLQUFLRSxZQUFYLE1BQTZCLElBQXBFLElBQTRFRCxNQUFNLDhCQUF6RjtBQUNEOztBQUVELFdBQVNFLGFBQVQsQ0FBdUJILElBQXZCLEVBQTZCO0FBQzNCLFFBQUlJLFNBQVNKLEtBQUtLLFVBQWxCO0FBQ0EsV0FBT0QsT0FBT0UsUUFBUCxJQUFtQixDQUFuQixHQUF1QkYsTUFBdkIsR0FBZ0MsSUFBdkM7QUFDRDs7QUFFRCxXQUFTRyxZQUFULENBQXNCUCxJQUF0QixFQUE0QjtBQUMxQixRQUFJekUsSUFBSSxDQUFSO0FBQ0EsV0FBT3lFLE9BQU9BLEtBQUtRLGVBQW5CLEVBQW9DO0FBQ2xDakY7QUFDRDtBQUNELFdBQU9BLENBQVA7QUFDRDs7QUFFRCxXQUFTa0YsYUFBVCxDQUF1QlQsSUFBdkIsRUFBNkI7QUFDM0IsUUFBSVUsVUFBSjtBQUNBLFdBQU9DLG9CQUFvQlgsSUFBcEIsSUFBNEJBLEtBQUt4RSxNQUFqQyxHQUEwQyxDQUFDa0YsYUFBYVYsS0FBS1UsVUFBbkIsSUFBaUNBLFdBQVdsRixNQUE1QyxHQUFxRCxDQUF0RztBQUNEOztBQUVELFdBQVNvRixpQkFBVCxDQUEyQkMsS0FBM0IsRUFBa0NDLEtBQWxDLEVBQXlDO0FBQ3ZDLFFBQUlDLFlBQVksRUFBaEI7QUFBQSxRQUNJQyxDQURKO0FBRUEsU0FBS0EsSUFBSUgsS0FBVCxFQUFnQkcsQ0FBaEIsRUFBbUJBLElBQUlBLEVBQUVYLFVBQXpCLEVBQXFDO0FBQ25DVSxnQkFBVTVDLElBQVYsQ0FBZTZDLENBQWY7QUFDRDs7QUFFRCxTQUFLQSxJQUFJRixLQUFULEVBQWdCRSxDQUFoQixFQUFtQkEsSUFBSUEsRUFBRVgsVUFBekIsRUFBcUM7QUFDbkMsVUFBSVQsY0FBY21CLFNBQWQsRUFBeUJDLENBQXpCLENBQUosRUFBaUM7QUFDL0IsZUFBT0EsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsV0FBU0MsWUFBVCxDQUFzQkMsUUFBdEIsRUFBZ0NDLFVBQWhDLEVBQTRDQyxjQUE1QyxFQUE0RDtBQUMxRCxRQUFJSixJQUFJSSxpQkFBaUJELFVBQWpCLEdBQThCQSxXQUFXZCxVQUFqRDtBQUNBLFdBQU9XLENBQVAsRUFBVTtBQUNSLFVBQUlBLE1BQU1FLFFBQVYsRUFBb0I7QUFDbEIsZUFBTyxJQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0xGLFlBQUlBLEVBQUVYLFVBQU47QUFDRDtBQUNGO0FBQ0QsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsV0FBU2dCLG9CQUFULENBQThCckIsSUFBOUIsRUFBb0NrQixRQUFwQyxFQUE4Q0UsY0FBOUMsRUFBOEQ7QUFDNUQsUUFBSXBHLENBQUo7QUFBQSxRQUNJZ0csSUFBSUksaUJBQWlCcEIsSUFBakIsR0FBd0JBLEtBQUtLLFVBRHJDO0FBRUEsV0FBT1csQ0FBUCxFQUFVO0FBQ1JoRyxVQUFJZ0csRUFBRVgsVUFBTjtBQUNBLFVBQUlyRixNQUFNa0csUUFBVixFQUFvQjtBQUNsQixlQUFPRixDQUFQO0FBQ0Q7QUFDREEsVUFBSWhHLENBQUo7QUFDRDtBQUNELFdBQU8sSUFBUDtBQUNEOztBQUVELFdBQVMyRixtQkFBVCxDQUE2QlgsSUFBN0IsRUFBbUM7QUFDakMsUUFBSS9FLElBQUkrRSxLQUFLTSxRQUFiO0FBQ0EsV0FBT3JGLEtBQUssQ0FBTCxJQUFVQSxLQUFLLENBQWYsSUFBb0JBLEtBQUssQ0FBaEMsQ0FGaUMsQ0FFRTtBQUNwQzs7QUFFRCxXQUFTcUcsV0FBVCxDQUFxQnRCLElBQXJCLEVBQTJCdUIsYUFBM0IsRUFBMEM7QUFDeEMsUUFBSUMsV0FBV0QsY0FBY0UsV0FBN0I7QUFBQSxRQUNJckIsU0FBU21CLGNBQWNsQixVQUQzQjtBQUVBLFFBQUltQixRQUFKLEVBQWM7QUFDWnBCLGFBQU9zQixZQUFQLENBQW9CMUIsSUFBcEIsRUFBMEJ3QixRQUExQjtBQUNELEtBRkQsTUFFTztBQUNMcEIsYUFBT3VCLFdBQVAsQ0FBbUIzQixJQUFuQjtBQUNEO0FBQ0QsV0FBT0EsSUFBUDtBQUNEOztBQUVEO0FBQ0EsV0FBUzRCLGFBQVQsQ0FBdUI1QixJQUF2QixFQUE2QjZCLEtBQTdCLEVBQW9DO0FBQ2xDLFFBQUlDLFVBQVU5QixLQUFLK0IsU0FBTCxDQUFlLEtBQWYsQ0FBZDtBQUNBRCxZQUFRRSxVQUFSLENBQW1CLENBQW5CLEVBQXNCSCxLQUF0QjtBQUNBN0IsU0FBS2dDLFVBQUwsQ0FBZ0JILEtBQWhCLEVBQXVCN0IsS0FBS3hFLE1BQUwsR0FBY3FHLEtBQXJDO0FBQ0FQLGdCQUFZUSxPQUFaLEVBQXFCOUIsSUFBckI7QUFDQSxXQUFPOEIsT0FBUDtBQUNEOztBQUVELFdBQVNHLFdBQVQsQ0FBcUJqQyxJQUFyQixFQUEyQjtBQUN6QixRQUFJQSxLQUFLTSxRQUFMLElBQWlCLENBQXJCLEVBQXdCO0FBQ3RCLGFBQU9OLElBQVA7QUFDRCxLQUZELE1BRU8sSUFBSWxILFFBQVFrSCxLQUFLa0MsYUFBYixLQUErQjNDLEtBQW5DLEVBQTBDO0FBQy9DLGFBQU9TLEtBQUtrQyxhQUFaO0FBQ0QsS0FGTSxNQUVBLElBQUlwSixRQUFRa0gsS0FBS3pDLFFBQWIsS0FBMEJnQyxLQUE5QixFQUFxQztBQUMxQyxhQUFPUyxLQUFLekMsUUFBWjtBQUNELEtBRk0sTUFFQSxJQUFJeUMsS0FBS0ssVUFBVCxFQUFxQjtBQUMxQixhQUFPNEIsWUFBWWpDLEtBQUtLLFVBQWpCLENBQVA7QUFDRCxLQUZNLE1BRUE7QUFDTCxZQUFNLElBQUkzQixLQUFKLENBQVUseUNBQVYsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsV0FBU3lELFNBQVQsQ0FBbUJuQyxJQUFuQixFQUF5QjtBQUN2QixRQUFJb0MsTUFBTUgsWUFBWWpDLElBQVosQ0FBVjtBQUNBLFFBQUlsSCxRQUFRc0osSUFBSUMsV0FBWixLQUE0QjlDLEtBQWhDLEVBQXVDO0FBQ3JDLGFBQU82QyxJQUFJQyxXQUFYO0FBQ0QsS0FGRCxNQUVPLElBQUl2SixRQUFRc0osSUFBSUUsWUFBWixLQUE2Qi9DLEtBQWpDLEVBQXdDO0FBQzdDLGFBQU82QyxJQUFJRSxZQUFYO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsWUFBTSxJQUFJNUQsS0FBSixDQUFVLHFDQUFWLENBQU47QUFDRDtBQUNGOztBQUVELFdBQVM2RCxpQkFBVCxDQUEyQkMsUUFBM0IsRUFBcUM7QUFDbkMsUUFBSTFKLFFBQVEwSixTQUFTQyxlQUFqQixLQUFxQ2xELEtBQXpDLEVBQWdEO0FBQzlDLGFBQU9pRCxTQUFTQyxlQUFoQjtBQUNELEtBRkQsTUFFTyxJQUFJM0osUUFBUTBKLFNBQVNFLGFBQWpCLEtBQW1DbkQsS0FBdkMsRUFBOEM7QUFDbkQsYUFBT2lELFNBQVNFLGFBQVQsQ0FBdUJuRixRQUE5QjtBQUNELEtBRk0sTUFFQTtBQUNMLFlBQU0sSUFBSW1CLEtBQUosQ0FBVSw4REFBVixDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTaUUsZUFBVCxDQUF5QkgsUUFBekIsRUFBbUM7QUFDakMsUUFBSTFKLFFBQVEwSixTQUFTRSxhQUFqQixLQUFtQ25ELEtBQXZDLEVBQThDO0FBQzVDLGFBQU9pRCxTQUFTRSxhQUFoQjtBQUNELEtBRkQsTUFFTyxJQUFJNUosUUFBUTBKLFNBQVNDLGVBQWpCLEtBQXFDbEQsS0FBekMsRUFBZ0Q7QUFDckQsYUFBT2lELFNBQVNDLGVBQVQsQ0FBeUJKLFdBQWhDO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsWUFBTSxJQUFJM0QsS0FBSixDQUFVLDREQUFWLENBQU47QUFDRDtBQUNGOztBQUVELFdBQVNrRSxPQUFULENBQWlCUixHQUFqQixFQUFzQjtBQUNwQixXQUFPbkcsS0FBS2YsWUFBTCxDQUFrQmtILEdBQWxCLEVBQXVCLE1BQXZCLElBQWlDQSxJQUFJMUUsSUFBckMsR0FBNEMwRSxJQUFJekUsb0JBQUosQ0FBeUIsTUFBekIsRUFBaUMsQ0FBakMsQ0FBbkQ7QUFDRDs7QUFFRCxXQUFTa0YsZ0JBQVQsQ0FBMEI3QyxJQUExQixFQUFnQztBQUM5QixRQUFJSSxNQUFKO0FBQ0EsV0FBT0EsU0FBU0osS0FBS0ssVUFBckIsRUFBaUM7QUFDL0JMLGFBQU9JLE1BQVA7QUFDRDtBQUNELFdBQU9KLElBQVA7QUFDRDs7QUFFRCxXQUFTOEMsYUFBVCxDQUF1QkMsS0FBdkIsRUFBOEJDLE9BQTlCLEVBQXVDQyxLQUF2QyxFQUE4Q0MsT0FBOUMsRUFBdUQ7QUFDckQ7QUFDQSxRQUFJQyxLQUFKLEVBQVdDLElBQVgsRUFBaUJDLE1BQWpCLEVBQXlCQyxNQUF6QixFQUFpQ3RDLENBQWpDO0FBQ0EsUUFBSStCLFNBQVNFLEtBQWIsRUFBb0I7O0FBRWxCO0FBQ0EsYUFBT0QsWUFBWUUsT0FBWixHQUFzQixDQUF0QixHQUEwQkYsVUFBVUUsT0FBVixHQUFvQixDQUFDLENBQXJCLEdBQXlCLENBQTFEO0FBQ0QsS0FKRCxNQUlPLElBQUlDLFFBQVE5QixxQkFBcUI0QixLQUFyQixFQUE0QkYsS0FBNUIsRUFBbUMsSUFBbkMsQ0FBWixFQUFzRDs7QUFFM0Q7QUFDQSxhQUFPQyxXQUFXekMsYUFBYTRDLEtBQWIsQ0FBWCxHQUFpQyxDQUFDLENBQWxDLEdBQXNDLENBQTdDO0FBQ0QsS0FKTSxNQUlBLElBQUlBLFFBQVE5QixxQkFBcUIwQixLQUFyQixFQUE0QkUsS0FBNUIsRUFBbUMsSUFBbkMsQ0FBWixFQUFzRDs7QUFFM0Q7QUFDQSxhQUFPMUMsYUFBYTRDLEtBQWIsSUFBc0JELE9BQXRCLEdBQWdDLENBQUMsQ0FBakMsR0FBcUMsQ0FBNUM7QUFDRCxLQUpNLE1BSUE7O0FBRUw7QUFDQUUsYUFBT3hDLGtCQUFrQm1DLEtBQWxCLEVBQXlCRSxLQUF6QixDQUFQO0FBQ0FJLGVBQVNOLFVBQVVLLElBQVYsR0FBaUJBLElBQWpCLEdBQXdCL0IscUJBQXFCMEIsS0FBckIsRUFBNEJLLElBQTVCLEVBQWtDLElBQWxDLENBQWpDO0FBQ0FFLGVBQVNMLFVBQVVHLElBQVYsR0FBaUJBLElBQWpCLEdBQXdCL0IscUJBQXFCNEIsS0FBckIsRUFBNEJHLElBQTVCLEVBQWtDLElBQWxDLENBQWpDOztBQUVBLFVBQUlDLFdBQVdDLE1BQWYsRUFBdUI7QUFDckI7O0FBRUEsY0FBTSxJQUFJNUUsS0FBSixDQUFVLGlFQUFWLENBQU47QUFDRCxPQUpELE1BSU87QUFDTHNDLFlBQUlvQyxLQUFLRyxVQUFUO0FBQ0EsZUFBT3ZDLENBQVAsRUFBVTtBQUNSLGNBQUlBLE1BQU1xQyxNQUFWLEVBQWtCO0FBQ2hCLG1CQUFPLENBQUMsQ0FBUjtBQUNELFdBRkQsTUFFTyxJQUFJckMsTUFBTXNDLE1BQVYsRUFBa0I7QUFDdkIsbUJBQU8sQ0FBUDtBQUNEO0FBQ0R0QyxjQUFJQSxFQUFFUyxXQUFOO0FBQ0Q7QUFDRCxjQUFNLElBQUkvQyxLQUFKLENBQVUscUJBQVYsQ0FBTjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxXQUFTOEUsd0JBQVQsQ0FBa0N4RCxJQUFsQyxFQUF3QztBQUN0QyxRQUFJeUQsV0FBV3hCLFlBQVlqQyxJQUFaLEVBQWtCMEQsc0JBQWxCLEVBQWY7QUFBQSxRQUNJQyxLQURKO0FBRUEsV0FBT0EsUUFBUTNELEtBQUt1RCxVQUFwQixFQUFnQztBQUM5QkUsZUFBUzlCLFdBQVQsQ0FBcUJnQyxLQUFyQjtBQUNEO0FBQ0QsV0FBT0YsUUFBUDtBQUNEOztBQUVELFdBQVNHLFdBQVQsQ0FBcUI1RCxJQUFyQixFQUEyQjtBQUN6QixRQUFJLENBQUNBLElBQUwsRUFBVztBQUNULGFBQU8sV0FBUDtBQUNEO0FBQ0QsUUFBSVcsb0JBQW9CWCxJQUFwQixDQUFKLEVBQStCO0FBQzdCLGFBQU8sTUFBTUEsS0FBSzZELElBQVgsR0FBa0IsR0FBekI7QUFDRCxLQUZELE1BRU8sSUFBSTdELEtBQUtNLFFBQUwsSUFBaUIsQ0FBckIsRUFBd0I7QUFDN0IsVUFBSXdELFNBQVM5RCxLQUFLK0QsRUFBTCxHQUFVLFVBQVUvRCxLQUFLK0QsRUFBZixHQUFvQixHQUE5QixHQUFvQyxFQUFqRDtBQUNBLGFBQU8sTUFBTS9ELEtBQUtnRSxRQUFYLEdBQXNCRixNQUF0QixHQUErQixJQUEvQixHQUFzQzlELEtBQUtVLFVBQUwsQ0FBZ0JsRixNQUF0RCxHQUErRCxHQUF0RTtBQUNELEtBSE0sTUFHQTtBQUNMLGFBQU93RSxLQUFLZ0UsUUFBWjtBQUNEO0FBQ0Y7O0FBRUQ7OztBQUdBLFdBQVNDLFlBQVQsQ0FBc0JiLElBQXRCLEVBQTRCO0FBQzFCLFNBQUtBLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUtjLEtBQUwsR0FBYWQsSUFBYjtBQUNEOztBQUVEYSxlQUFhOUssU0FBYixHQUF5QjtBQUN2QmdMLGNBQVUsSUFEYTs7QUFHdkJDLGFBQVMsU0FBU0EsT0FBVCxHQUFtQjtBQUMxQixhQUFPLENBQUMsQ0FBQyxLQUFLRixLQUFkO0FBQ0QsS0FMc0I7O0FBT3ZCRyxVQUFNLFNBQVNBLElBQVQsR0FBZ0I7QUFDcEIsVUFBSXJELElBQUksS0FBS21ELFFBQUwsR0FBZ0IsS0FBS0QsS0FBN0I7QUFDQSxVQUFJUCxLQUFKLEVBQVdVLElBQVg7QUFDQSxVQUFJLEtBQUtGLFFBQVQsRUFBbUI7QUFDakJSLGdCQUFRM0MsRUFBRXVDLFVBQVY7QUFDQSxZQUFJSSxLQUFKLEVBQVc7QUFDVCxlQUFLTyxLQUFMLEdBQWFQLEtBQWI7QUFDRCxTQUZELE1BRU87QUFDTFUsaUJBQU8sSUFBUDtBQUNBLGlCQUFPckQsTUFBTSxLQUFLb0MsSUFBWCxJQUFtQixFQUFFaUIsT0FBT3JELEVBQUVTLFdBQVgsQ0FBMUIsRUFBbUQ7QUFDakRULGdCQUFJQSxFQUFFWCxVQUFOO0FBQ0Q7QUFDRCxlQUFLNkQsS0FBTCxHQUFhRyxJQUFiO0FBQ0Q7QUFDRjtBQUNELGFBQU8sS0FBS0YsUUFBWjtBQUNELEtBdkJzQjs7QUF5QnZCMUcsWUFBUSxTQUFTQSxNQUFULEdBQWtCO0FBQ3hCLFdBQUswRyxRQUFMLEdBQWdCLEtBQUtELEtBQUwsR0FBYSxLQUFLZCxJQUFMLEdBQVksSUFBekM7QUFDRDtBQTNCc0IsR0FBekI7O0FBOEJBLFdBQVNrQixjQUFULENBQXdCbEIsSUFBeEIsRUFBOEI7QUFDNUIsV0FBTyxJQUFJYSxZQUFKLENBQWlCYixJQUFqQixDQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBLFdBQVNtQixXQUFULENBQXFCdkUsSUFBckIsRUFBMkJ3RSxNQUEzQixFQUFtQztBQUNqQyxTQUFLeEUsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS3dFLE1BQUwsR0FBY0EsTUFBZDtBQUNEOztBQUVERCxjQUFZcEwsU0FBWixHQUF3QjtBQUN0QnNMLFlBQVEsU0FBU0EsTUFBVCxDQUFnQkMsR0FBaEIsRUFBcUI7QUFDM0IsYUFBTyxLQUFLMUUsSUFBTCxLQUFjMEUsSUFBSTFFLElBQWxCLEdBQXlCLEtBQUt3RSxNQUFMLElBQWVFLElBQUlGLE1BQW5EO0FBQ0QsS0FIcUI7O0FBS3RCRyxhQUFTLFNBQVNBLE9BQVQsR0FBbUI7QUFDMUIsYUFBTyxrQkFBa0JmLFlBQVksS0FBSzVELElBQWpCLENBQWxCLEdBQTJDLEdBQTNDLEdBQWlELEtBQUt3RSxNQUF0RCxHQUErRCxJQUF0RTtBQUNEO0FBUHFCLEdBQXhCOztBQVVBOzs7QUFHQSxXQUFTSSxZQUFULENBQXNCQyxRQUF0QixFQUFnQztBQUM5QixTQUFLQyxJQUFMLEdBQVksS0FBS0QsUUFBTCxDQUFaO0FBQ0EsU0FBS0EsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxTQUFLRSxPQUFMLEdBQWUsbUJBQW1CLEtBQUtGLFFBQXZDO0FBQ0Q7O0FBRURELGVBQWF6TCxTQUFiLEdBQXlCO0FBQ3ZCNkwsb0JBQWdCLENBRE87QUFFdkJDLDJCQUF1QixDQUZBO0FBR3ZCQyx3QkFBb0IsQ0FIRztBQUl2QkMsaUNBQTZCLENBSk47QUFLdkJDLG1CQUFlLENBTFE7QUFNdkJDLHVCQUFtQixDQU5JO0FBT3ZCQyx1QkFBbUI7QUFQSSxHQUF6Qjs7QUFVQVYsZUFBYXpMLFNBQWIsQ0FBdUJvTSxRQUF2QixHQUFrQyxZQUFZO0FBQzVDLFdBQU8sS0FBS1IsT0FBWjtBQUNELEdBRkQ7O0FBSUFqSixNQUFJdkMsR0FBSixHQUFVO0FBQ1JxRyxtQkFBZUEsYUFEUDtBQUVSRyxxQkFBaUJBLGVBRlQ7QUFHUkksbUJBQWVBLGFBSFA7QUFJUkksa0JBQWNBLFlBSk47QUFLUkUsbUJBQWVBLGFBTFA7QUFNUkcsdUJBQW1CQSxpQkFOWDtBQU9SSyxrQkFBY0EsWUFQTjtBQVFSSSwwQkFBc0JBLG9CQVJkO0FBU1JWLHlCQUFxQkEsbUJBVGI7QUFVUlcsaUJBQWFBLFdBVkw7QUFXUk0sbUJBQWVBLGFBWFA7QUFZUkssaUJBQWFBLFdBWkw7QUFhUkUsZUFBV0EsU0FiSDtBQWNSUSxxQkFBaUJBLGVBZFQ7QUFlUkosdUJBQW1CQSxpQkFmWDtBQWdCUkssYUFBU0EsT0FoQkQ7QUFpQlJDLHNCQUFrQkEsZ0JBakJWO0FBa0JSQyxtQkFBZUEsYUFsQlA7QUFtQlJjLGlCQUFhQSxXQW5CTDtBQW9CUkosOEJBQTBCQSx3QkFwQmxCO0FBcUJSYyxvQkFBZ0JBLGNBckJSO0FBc0JSQyxpQkFBYUE7QUF0QkwsR0FBVjs7QUF5QkF6SSxNQUFJOEksWUFBSixHQUFtQkEsWUFBbkI7QUFDRCxDQWpYRCxFQWlYR3RGLE1BQU1WLFlBQU4sQ0FBbUIsVUFBbkIsRUFBK0IsVUFBVTlDLEdBQVYsRUFBZWdELE1BQWYsRUFBdUI7QUFDdkRoRCxNQUFJaUQsY0FBSixDQUFtQixDQUFDLFNBQUQsQ0FBbkI7O0FBRUEsTUFBSXhGLE1BQU11QyxJQUFJdkMsR0FBZDtBQUNBLE1BQUlnTCxjQUFjaEwsSUFBSWdMLFdBQXRCO0FBQ0EsTUFBSUssZUFBZTlJLElBQUk4SSxZQUF2Qjs7QUFFQTs7QUFFQTs7QUFFQSxXQUFTWSwwQkFBVCxDQUFvQ3hGLElBQXBDLEVBQTBDbkUsS0FBMUMsRUFBaUQ7QUFDL0MsV0FBT21FLEtBQUtNLFFBQUwsSUFBaUIsQ0FBakIsS0FBdUIvRyxJQUFJMEgsWUFBSixDQUFpQmpCLElBQWpCLEVBQXVCbkUsTUFBTTRKLGNBQTdCLEVBQTZDLElBQTdDLEtBQXNEbE0sSUFBSTBILFlBQUosQ0FBaUJqQixJQUFqQixFQUF1Qm5FLE1BQU02SixZQUE3QixFQUEyQyxJQUEzQyxDQUE3RSxDQUFQO0FBQ0Q7O0FBRUQsV0FBU0MsZ0JBQVQsQ0FBMEI5SixLQUExQixFQUFpQztBQUMvQixXQUFPdEMsSUFBSTBJLFdBQUosQ0FBZ0JwRyxNQUFNNEosY0FBdEIsQ0FBUDtBQUNEOztBQUVELFdBQVNHLGFBQVQsQ0FBdUIvSixLQUF2QixFQUE4QmdLLElBQTlCLEVBQW9DQyxJQUFwQyxFQUEwQztBQUN4QyxRQUFJQyxZQUFZbEssTUFBTW1LLFVBQU4sQ0FBaUJILElBQWpCLENBQWhCO0FBQ0EsUUFBSUUsU0FBSixFQUFlO0FBQ2IsV0FBSyxJQUFJeEssSUFBSSxDQUFSLEVBQVd3QyxNQUFNZ0ksVUFBVXZLLE1BQWhDLEVBQXdDRCxJQUFJd0MsR0FBNUMsRUFBaUQsRUFBRXhDLENBQW5ELEVBQXNEO0FBQ3BEd0ssa0JBQVV4SyxDQUFWLEVBQWEwSyxJQUFiLENBQWtCcEssS0FBbEIsRUFBeUIsRUFBRXFLLFFBQVFySyxLQUFWLEVBQWlCaUssTUFBTUEsSUFBdkIsRUFBekI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsV0FBU0sscUJBQVQsQ0FBK0JuRyxJQUEvQixFQUFxQztBQUNuQyxXQUFPLElBQUl1RSxXQUFKLENBQWdCdkUsS0FBS0ssVUFBckIsRUFBaUM5RyxJQUFJZ0gsWUFBSixDQUFpQlAsSUFBakIsQ0FBakMsQ0FBUDtBQUNEOztBQUVELFdBQVNvRyxvQkFBVCxDQUE4QnBHLElBQTlCLEVBQW9DO0FBQ2xDLFdBQU8sSUFBSXVFLFdBQUosQ0FBZ0J2RSxLQUFLSyxVQUFyQixFQUFpQzlHLElBQUlnSCxZQUFKLENBQWlCUCxJQUFqQixJQUF5QixDQUExRCxDQUFQO0FBQ0Q7O0FBRUQsV0FBU3FHLG9CQUFULENBQThCckcsSUFBOUIsRUFBb0NnQixDQUFwQyxFQUF1Q2pHLENBQXZDLEVBQTBDO0FBQ3hDLFFBQUl1TCxvQkFBb0J0RyxLQUFLTSxRQUFMLElBQWlCLEVBQWpCLEdBQXNCTixLQUFLdUQsVUFBM0IsR0FBd0N2RCxJQUFoRTtBQUNBLFFBQUl6RyxJQUFJb0gsbUJBQUosQ0FBd0JLLENBQXhCLENBQUosRUFBZ0M7QUFDOUIsVUFBSWpHLEtBQUtpRyxFQUFFeEYsTUFBWCxFQUFtQjtBQUNqQmpDLFlBQUkrSCxXQUFKLENBQWdCdEIsSUFBaEIsRUFBc0JnQixDQUF0QjtBQUNELE9BRkQsTUFFTztBQUNMQSxVQUFFWCxVQUFGLENBQWFxQixZQUFiLENBQTBCMUIsSUFBMUIsRUFBZ0NqRixLQUFLLENBQUwsR0FBU2lHLENBQVQsR0FBYXpILElBQUlxSSxhQUFKLENBQWtCWixDQUFsQixFQUFxQmpHLENBQXJCLENBQTdDO0FBQ0Q7QUFDRixLQU5ELE1BTU8sSUFBSUEsS0FBS2lHLEVBQUVOLFVBQUYsQ0FBYWxGLE1BQXRCLEVBQThCO0FBQ25Dd0YsUUFBRVcsV0FBRixDQUFjM0IsSUFBZDtBQUNELEtBRk0sTUFFQTtBQUNMZ0IsUUFBRVUsWUFBRixDQUFlMUIsSUFBZixFQUFxQmdCLEVBQUVOLFVBQUYsQ0FBYTNGLENBQWIsQ0FBckI7QUFDRDtBQUNELFdBQU91TCxpQkFBUDtBQUNEOztBQUVELFdBQVNDLFlBQVQsQ0FBc0J2TixRQUF0QixFQUFnQztBQUM5QixRQUFJd04saUJBQUo7QUFDQSxTQUFLLElBQUl4RyxJQUFKLEVBQVV5RyxPQUFPZCxpQkFBaUIzTSxTQUFTNkMsS0FBMUIsRUFBaUM2SCxzQkFBakMsRUFBakIsRUFBNEVnRCxXQUFqRixFQUE4RjFHLE9BQU9oSCxTQUFTcUwsSUFBVCxFQUFyRyxHQUF1SDtBQUNySG1DLDBCQUFvQnhOLFNBQVMyTiwwQkFBVCxFQUFwQjs7QUFFQTNHLGFBQU9BLEtBQUsrQixTQUFMLENBQWUsQ0FBQ3lFLGlCQUFoQixDQUFQO0FBQ0EsVUFBSUEsaUJBQUosRUFBdUI7QUFDckJFLHNCQUFjMU4sU0FBUzROLGtCQUFULEVBQWQ7QUFDQTVHLGFBQUsyQixXQUFMLENBQWlCNEUsYUFBYUcsV0FBYixDQUFqQjtBQUNBQSxvQkFBWWpKLE1BQVosQ0FBbUIsSUFBbkI7QUFDRDs7QUFFRCxVQUFJdUMsS0FBS00sUUFBTCxJQUFpQixFQUFyQixFQUF5QjtBQUN2QjtBQUNBLGNBQU0sSUFBSXNFLFlBQUosQ0FBaUIsdUJBQWpCLENBQU47QUFDRDtBQUNENkIsV0FBSzlFLFdBQUwsQ0FBaUIzQixJQUFqQjtBQUNEO0FBQ0QsV0FBT3lHLElBQVA7QUFDRDs7QUFFRCxXQUFTSSxjQUFULENBQXdCQyxhQUF4QixFQUF1Q0MsSUFBdkMsRUFBNkNDLGFBQTdDLEVBQTREO0FBQzFELFFBQUlDLEVBQUosRUFBUWpHLENBQVI7QUFDQWdHLG9CQUFnQkEsaUJBQWlCLEVBQUVFLE1BQU0sS0FBUixFQUFqQztBQUNBLFNBQUssSUFBSWxILElBQUosRUFBVW1ILGdCQUFmLEVBQWlDbkgsT0FBTzhHLGNBQWN6QyxJQUFkLEVBQXhDLEdBQStEO0FBQzdEO0FBQ0EsVUFBSXlDLGNBQWNILDBCQUFkLEVBQUosRUFBZ0Q7QUFDOUM7QUFDQTtBQUNBLFlBQUlJLEtBQUsvRyxJQUFMLE1BQWUsS0FBbkIsRUFBMEI7QUFDeEJnSCx3QkFBY0UsSUFBZCxHQUFxQixJQUFyQjtBQUNBO0FBQ0QsU0FIRCxNQUdPO0FBQ0xDLDZCQUFtQkwsY0FBY0Ysa0JBQWQsRUFBbkI7QUFDQUMseUJBQWVNLGdCQUFmLEVBQWlDSixJQUFqQyxFQUF1Q0MsYUFBdkM7QUFDQUcsMkJBQWlCMUosTUFBakIsQ0FBd0IsSUFBeEI7QUFDQSxjQUFJdUosY0FBY0UsSUFBbEIsRUFBd0I7QUFDdEI7QUFDRDtBQUNGO0FBQ0YsT0FkRCxNQWNPO0FBQ0w7QUFDQTtBQUNBRCxhQUFLMU4sSUFBSStLLGNBQUosQ0FBbUJ0RSxJQUFuQixDQUFMO0FBQ0EsZUFBT2dCLElBQUlpRyxHQUFHNUMsSUFBSCxFQUFYLEVBQXNCO0FBQ3BCLGNBQUkwQyxLQUFLL0YsQ0FBTCxNQUFZLEtBQWhCLEVBQXVCO0FBQ3JCZ0csMEJBQWNFLElBQWQsR0FBcUIsSUFBckI7QUFDQTtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsV0FBU0UsYUFBVCxDQUF1QnBPLFFBQXZCLEVBQWlDO0FBQy9CLFFBQUkwTixXQUFKO0FBQ0EsV0FBTzFOLFNBQVNxTCxJQUFULEVBQVAsRUFBd0I7QUFDdEIsVUFBSXJMLFNBQVMyTiwwQkFBVCxFQUFKLEVBQTJDO0FBQ3pDRCxzQkFBYzFOLFNBQVM0TixrQkFBVCxFQUFkO0FBQ0FRLHNCQUFjVixXQUFkO0FBQ0FBLG9CQUFZakosTUFBWixDQUFtQixJQUFuQjtBQUNELE9BSkQsTUFJTztBQUNMekUsaUJBQVNxTyxNQUFUO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFdBQVNDLGNBQVQsQ0FBd0J0TyxRQUF4QixFQUFrQzs7QUFFaEMsU0FBSyxJQUFJZ0gsSUFBSixFQUFVeUcsT0FBT2QsaUJBQWlCM00sU0FBUzZDLEtBQTFCLEVBQWlDNkgsc0JBQWpDLEVBQWpCLEVBQTRFZ0QsV0FBakYsRUFBOEYxRyxPQUFPaEgsU0FBU3FMLElBQVQsRUFBckcsR0FBdUg7O0FBRXJILFVBQUlyTCxTQUFTMk4sMEJBQVQsRUFBSixFQUEyQztBQUN6QzNHLGVBQU9BLEtBQUsrQixTQUFMLENBQWUsS0FBZixDQUFQO0FBQ0EyRSxzQkFBYzFOLFNBQVM0TixrQkFBVCxFQUFkO0FBQ0E1RyxhQUFLMkIsV0FBTCxDQUFpQjJGLGVBQWVaLFdBQWYsQ0FBakI7QUFDQUEsb0JBQVlqSixNQUFaLENBQW1CLElBQW5CO0FBQ0QsT0FMRCxNQUtPO0FBQ0x6RSxpQkFBU3FPLE1BQVQ7QUFDRDtBQUNELFVBQUlySCxLQUFLTSxRQUFMLElBQWlCLEVBQXJCLEVBQXlCO0FBQ3ZCO0FBQ0EsY0FBTSxJQUFJc0UsWUFBSixDQUFpQix1QkFBakIsQ0FBTjtBQUNEO0FBQ0Q2QixXQUFLOUUsV0FBTCxDQUFpQjNCLElBQWpCO0FBQ0Q7QUFDRCxXQUFPeUcsSUFBUDtBQUNEOztBQUVELFdBQVNjLGVBQVQsQ0FBeUIxTCxLQUF6QixFQUFnQzJMLFNBQWhDLEVBQTJDQyxNQUEzQyxFQUFtRDtBQUNqRDtBQUNBLFFBQUlDLGtCQUFrQixDQUFDLEVBQUVGLGFBQWFBLFVBQVVoTSxNQUF6QixDQUF2QjtBQUFBLFFBQ0ltTSxLQURKO0FBRUEsUUFBSUMsZUFBZSxDQUFDLENBQUNILE1BQXJCO0FBQ0EsUUFBSUMsZUFBSixFQUFxQjtBQUNuQkMsY0FBUSxJQUFJRSxNQUFKLENBQVcsT0FBT0wsVUFBVU0sSUFBVixDQUFlLEdBQWYsQ0FBUCxHQUE2QixJQUF4QyxDQUFSO0FBQ0Q7O0FBRUQsUUFBSUMsUUFBUSxFQUFaO0FBQ0FsQixtQkFBZSxJQUFJbUIsYUFBSixDQUFrQm5NLEtBQWxCLEVBQXlCLEtBQXpCLENBQWYsRUFBZ0QsVUFBVW1FLElBQVYsRUFBZ0I7QUFDOUQsVUFBSSxDQUFDLENBQUMwSCxlQUFELElBQW9CQyxNQUFNTSxJQUFOLENBQVdqSSxLQUFLTSxRQUFoQixDQUFyQixNQUFvRCxDQUFDc0gsWUFBRCxJQUFpQkgsT0FBT3pILElBQVAsQ0FBckUsQ0FBSixFQUF3RjtBQUN0RitILGNBQU01SixJQUFOLENBQVc2QixJQUFYO0FBQ0Q7QUFDRixLQUpEO0FBS0EsV0FBTytILEtBQVA7QUFDRDs7QUFFRCxXQUFTRyxRQUFULENBQWtCck0sS0FBbEIsRUFBeUI7QUFDdkIsUUFBSTRDLE9BQU8sT0FBTzVDLE1BQU1zTSxPQUFiLElBQXdCLFdBQXhCLEdBQXNDLE9BQXRDLEdBQWdEdE0sTUFBTXNNLE9BQU4sRUFBM0Q7QUFDQSxXQUFPLE1BQU0xSixJQUFOLEdBQWEsR0FBYixHQUFtQmxGLElBQUlxSyxXQUFKLENBQWdCL0gsTUFBTTRKLGNBQXRCLENBQW5CLEdBQTJELEdBQTNELEdBQWlFNUosTUFBTXVNLFdBQXZFLEdBQXFGLElBQXJGLEdBQTRGN08sSUFBSXFLLFdBQUosQ0FBZ0IvSCxNQUFNNkosWUFBdEIsQ0FBNUYsR0FBa0ksR0FBbEksR0FBd0k3SixNQUFNd00sU0FBOUksR0FBMEosSUFBaks7QUFDRDs7QUFFRDs7QUFFQTs7QUFFQTs7O0FBR0EsV0FBU0wsYUFBVCxDQUF1Qm5NLEtBQXZCLEVBQThCeU0sK0JBQTlCLEVBQStEO0FBQzdELFNBQUt6TSxLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFLeU0sK0JBQUwsR0FBdUNBLCtCQUF2Qzs7QUFFQSxRQUFJLENBQUN6TSxNQUFNME0sU0FBWCxFQUFzQjtBQUNwQixXQUFLQyxFQUFMLEdBQVUzTSxNQUFNNEosY0FBaEI7QUFDQSxXQUFLZ0QsRUFBTCxHQUFVNU0sTUFBTXVNLFdBQWhCO0FBQ0EsV0FBS00sRUFBTCxHQUFVN00sTUFBTTZKLFlBQWhCO0FBQ0EsV0FBS2lELEVBQUwsR0FBVTlNLE1BQU13TSxTQUFoQjtBQUNBLFVBQUlqRixPQUFPdkgsTUFBTStNLHVCQUFqQjs7QUFFQSxVQUFJLEtBQUtKLEVBQUwsS0FBWSxLQUFLRSxFQUFqQixJQUF1Qm5QLElBQUlvSCxtQkFBSixDQUF3QixLQUFLNkgsRUFBN0IsQ0FBM0IsRUFBNkQ7QUFDM0QsYUFBS0sseUJBQUwsR0FBaUMsSUFBakM7QUFDQSxhQUFLQyxNQUFMLEdBQWMsS0FBS0MsS0FBTCxHQUFhLEtBQUs3RSxLQUFMLEdBQWEsS0FBS3NFLEVBQTdDO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsYUFBS00sTUFBTCxHQUFjLEtBQUs1RSxLQUFMLEdBQWEsS0FBS3NFLEVBQUwsS0FBWXBGLElBQVosSUFBb0IsQ0FBQzdKLElBQUlvSCxtQkFBSixDQUF3QixLQUFLNkgsRUFBN0IsQ0FBckIsR0FBd0QsS0FBS0EsRUFBTCxDQUFROUgsVUFBUixDQUFtQixLQUFLK0gsRUFBeEIsQ0FBeEQsR0FBc0ZsUCxJQUFJOEgsb0JBQUosQ0FBeUIsS0FBS21ILEVBQTlCLEVBQWtDcEYsSUFBbEMsRUFBd0MsSUFBeEMsQ0FBakg7QUFDQSxhQUFLMkYsS0FBTCxHQUFhLEtBQUtMLEVBQUwsS0FBWXRGLElBQVosSUFBb0IsQ0FBQzdKLElBQUlvSCxtQkFBSixDQUF3QixLQUFLK0gsRUFBN0IsQ0FBckIsR0FBd0QsS0FBS0EsRUFBTCxDQUFRaEksVUFBUixDQUFtQixLQUFLaUksRUFBTCxHQUFVLENBQTdCLENBQXhELEdBQTBGcFAsSUFBSThILG9CQUFKLENBQXlCLEtBQUtxSCxFQUE5QixFQUFrQ3RGLElBQWxDLEVBQXdDLElBQXhDLENBQXZHO0FBQ0Q7QUFDRjtBQUNGOztBQUVENEUsZ0JBQWM3TyxTQUFkLEdBQTBCO0FBQ3hCZ0wsY0FBVSxJQURjO0FBRXhCRCxXQUFPLElBRmlCO0FBR3hCNEUsWUFBUSxJQUhnQjtBQUl4QkMsV0FBTyxJQUppQjtBQUt4QkYsK0JBQTJCLEtBTEg7O0FBT3hCRyxXQUFPLFNBQVNBLEtBQVQsR0FBaUI7QUFDdEIsV0FBSzdFLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxXQUFLRCxLQUFMLEdBQWEsS0FBSzRFLE1BQWxCO0FBQ0QsS0FWdUI7O0FBWXhCMUUsYUFBUyxTQUFTQSxPQUFULEdBQW1CO0FBQzFCLGFBQU8sQ0FBQyxDQUFDLEtBQUtGLEtBQWQ7QUFDRCxLQWR1Qjs7QUFnQnhCRyxVQUFNLFNBQVNBLElBQVQsR0FBZ0I7QUFDcEI7QUFDQSxVQUFJNEUsVUFBVSxLQUFLOUUsUUFBTCxHQUFnQixLQUFLRCxLQUFuQztBQUNBLFVBQUkrRSxPQUFKLEVBQWE7QUFDWCxhQUFLL0UsS0FBTCxHQUFhK0UsWUFBWSxLQUFLRixLQUFqQixHQUF5QkUsUUFBUXhILFdBQWpDLEdBQStDLElBQTVEOztBQUVBO0FBQ0EsWUFBSWxJLElBQUlvSCxtQkFBSixDQUF3QnNJLE9BQXhCLEtBQW9DLEtBQUtYLCtCQUE3QyxFQUE4RTtBQUM1RSxjQUFJVyxZQUFZLEtBQUtQLEVBQXJCLEVBQXlCOztBQUV2QixhQUFDTyxVQUFVQSxRQUFRbEgsU0FBUixDQUFrQixJQUFsQixDQUFYLEVBQW9DQyxVQUFwQyxDQUErQyxLQUFLMkcsRUFBcEQsRUFBd0RNLFFBQVF6TixNQUFSLEdBQWlCLEtBQUttTixFQUE5RTtBQUNEO0FBQ0QsY0FBSSxLQUFLeEUsUUFBTCxLQUFrQixLQUFLcUUsRUFBM0IsRUFBK0I7O0FBRTdCLGFBQUNTLFVBQVVBLFFBQVFsSCxTQUFSLENBQWtCLElBQWxCLENBQVgsRUFBb0NDLFVBQXBDLENBQStDLENBQS9DLEVBQWtELEtBQUt5RyxFQUF2RDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxhQUFPUSxPQUFQO0FBQ0QsS0FwQ3VCOztBQXNDeEI1QixZQUFRLFNBQVNBLE1BQVQsR0FBa0I7QUFDeEIsVUFBSTRCLFVBQVUsS0FBSzlFLFFBQW5CO0FBQUEsVUFDSStFLEtBREo7QUFBQSxVQUVJQyxHQUZKOztBQUlBLFVBQUk1UCxJQUFJb0gsbUJBQUosQ0FBd0JzSSxPQUF4QixNQUFxQ0EsWUFBWSxLQUFLVCxFQUFqQixJQUF1QlMsWUFBWSxLQUFLUCxFQUE3RSxDQUFKLEVBQXNGO0FBQ3BGUSxnQkFBUUQsWUFBWSxLQUFLVCxFQUFqQixHQUFzQixLQUFLQyxFQUEzQixHQUFnQyxDQUF4QztBQUNBVSxjQUFNRixZQUFZLEtBQUtQLEVBQWpCLEdBQXNCLEtBQUtDLEVBQTNCLEdBQWdDTSxRQUFRek4sTUFBOUM7QUFDQSxZQUFJME4sU0FBU0MsR0FBYixFQUFrQjtBQUNoQkYsa0JBQVFqSCxVQUFSLENBQW1Ca0gsS0FBbkIsRUFBMEJDLE1BQU1ELEtBQWhDO0FBQ0Q7QUFDRixPQU5ELE1BTU87QUFDTCxZQUFJRCxRQUFRNUksVUFBWixFQUF3QjtBQUN0QjRJLGtCQUFRNUksVUFBUixDQUFtQitJLFdBQW5CLENBQStCSCxPQUEvQjtBQUNELFNBRkQsTUFFTyxDQUFFO0FBQ1Y7QUFDRixLQXREdUI7O0FBd0R4QjtBQUNBdEMsZ0NBQTRCLFNBQVNBLDBCQUFULEdBQXNDO0FBQ2hFLFVBQUlzQyxVQUFVLEtBQUs5RSxRQUFuQjtBQUNBLGFBQU9xQiwyQkFBMkJ5RCxPQUEzQixFQUFvQyxLQUFLcE4sS0FBekMsQ0FBUDtBQUNELEtBNUR1Qjs7QUE4RHhCK0ssd0JBQW9CLFNBQVNBLGtCQUFULEdBQThCO0FBQ2hELFVBQUl5QyxRQUFKO0FBQ0EsVUFBSSxLQUFLUix5QkFBVCxFQUFvQztBQUNsQ1EsbUJBQVcsS0FBS3hOLEtBQUwsQ0FBV3lOLFVBQVgsRUFBWDtBQUNBRCxpQkFBU0UsUUFBVDtBQUNELE9BSEQsTUFHTztBQUNMRixtQkFBVyxJQUFJRyxLQUFKLENBQVU3RCxpQkFBaUIsS0FBSzlKLEtBQXRCLENBQVYsQ0FBWDtBQUNBLFlBQUlvTixVQUFVLEtBQUs5RSxRQUFuQjtBQUNBLFlBQUlzQixpQkFBaUJ3RCxPQUFyQjtBQUFBLFlBQ0liLGNBQWMsQ0FEbEI7QUFBQSxZQUVJMUMsZUFBZXVELE9BRm5CO0FBQUEsWUFHSVosWUFBWTlPLElBQUlrSCxhQUFKLENBQWtCd0ksT0FBbEIsQ0FIaEI7O0FBS0EsWUFBSTFQLElBQUkwSCxZQUFKLENBQWlCZ0ksT0FBakIsRUFBMEIsS0FBS1QsRUFBL0IsRUFBbUMsSUFBbkMsQ0FBSixFQUE4QztBQUM1Qy9DLDJCQUFpQixLQUFLK0MsRUFBdEI7QUFDQUosd0JBQWMsS0FBS0ssRUFBbkI7QUFDRDtBQUNELFlBQUlsUCxJQUFJMEgsWUFBSixDQUFpQmdJLE9BQWpCLEVBQTBCLEtBQUtQLEVBQS9CLEVBQW1DLElBQW5DLENBQUosRUFBOEM7QUFDNUNoRCx5QkFBZSxLQUFLZ0QsRUFBcEI7QUFDQUwsc0JBQVksS0FBS00sRUFBakI7QUFDRDs7QUFFRGMseUJBQWlCSixRQUFqQixFQUEyQjVELGNBQTNCLEVBQTJDMkMsV0FBM0MsRUFBd0QxQyxZQUF4RCxFQUFzRTJDLFNBQXRFO0FBQ0Q7QUFDRCxhQUFPLElBQUlMLGFBQUosQ0FBa0JxQixRQUFsQixFQUE0QixLQUFLZiwrQkFBakMsQ0FBUDtBQUNELEtBdkZ1Qjs7QUF5RnhCN0ssWUFBUSxTQUFTQSxNQUFULENBQWdCaU0sV0FBaEIsRUFBNkI7QUFDbkMsVUFBSUEsV0FBSixFQUFpQjtBQUNmLGFBQUs3TixLQUFMLENBQVc0QixNQUFYO0FBQ0Q7QUFDRCxXQUFLNUIsS0FBTCxHQUFhLEtBQUtzSSxRQUFMLEdBQWdCLEtBQUtELEtBQUwsR0FBYSxLQUFLNEUsTUFBTCxHQUFjLEtBQUtDLEtBQUwsR0FBYSxLQUFLUCxFQUFMLEdBQVUsS0FBS0MsRUFBTCxHQUFVLEtBQUtDLEVBQUwsR0FBVSxLQUFLQyxFQUFMLEdBQVUsSUFBN0c7QUFDRDtBQTlGdUIsR0FBMUI7O0FBaUdBOztBQUVBOztBQUVBOzs7QUFHQSxXQUFTZ0IsY0FBVCxDQUF3QjlFLFFBQXhCLEVBQWtDO0FBQ2hDLFNBQUtDLElBQUwsR0FBWSxLQUFLRCxRQUFMLENBQVo7QUFDQSxTQUFLQSxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFNBQUtFLE9BQUwsR0FBZSxxQkFBcUIsS0FBS0YsUUFBekM7QUFDRDs7QUFFRDhFLGlCQUFleFEsU0FBZixHQUEyQjtBQUN6QnlRLDRCQUF3QixDQURDO0FBRXpCQywyQkFBdUI7QUFGRSxHQUEzQjs7QUFLQUYsaUJBQWV4USxTQUFmLENBQXlCb00sUUFBekIsR0FBb0MsWUFBWTtBQUM5QyxXQUFPLEtBQUtSLE9BQVo7QUFDRCxHQUZEOztBQUlBOztBQUVBOzs7OztBQUtBLFdBQVMrRSxpQkFBVCxDQUEyQmpPLEtBQTNCLEVBQWtDMkwsU0FBbEMsRUFBNkNDLE1BQTdDLEVBQXFEO0FBQ25ELFNBQUtNLEtBQUwsR0FBYVIsZ0JBQWdCMUwsS0FBaEIsRUFBdUIyTCxTQUF2QixFQUFrQ0MsTUFBbEMsQ0FBYjtBQUNBLFNBQUt2RCxLQUFMLEdBQWEsS0FBSzZELEtBQUwsQ0FBVyxDQUFYLENBQWI7QUFDQSxTQUFLZ0MsU0FBTCxHQUFpQixDQUFqQjtBQUNEOztBQUVERCxvQkFBa0IzUSxTQUFsQixHQUE4QjtBQUM1QmdMLGNBQVUsSUFEa0I7O0FBRzVCQyxhQUFTLFNBQVNBLE9BQVQsR0FBbUI7QUFDMUIsYUFBTyxDQUFDLENBQUMsS0FBS0YsS0FBZDtBQUNELEtBTDJCOztBQU81QkcsVUFBTSxTQUFTQSxJQUFULEdBQWdCO0FBQ3BCLFdBQUtGLFFBQUwsR0FBZ0IsS0FBS0QsS0FBckI7QUFDQSxXQUFLQSxLQUFMLEdBQWEsS0FBSzZELEtBQUwsQ0FBVyxFQUFFLEtBQUtnQyxTQUFsQixDQUFiO0FBQ0EsYUFBTyxLQUFLNUYsUUFBWjtBQUNELEtBWDJCOztBQWE1QjFHLFlBQVEsU0FBU0EsTUFBVCxHQUFrQjtBQUN4QixXQUFLMEcsUUFBTCxHQUFnQixLQUFLRCxLQUFMLEdBQWEsS0FBSzZELEtBQUwsR0FBYSxJQUExQztBQUNEO0FBZjJCLEdBQTlCOztBQWtCQSxNQUFJaUMsdUJBQXVCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsRUFBbkIsQ0FBM0I7QUFDQSxNQUFJQyx5QkFBeUIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLEVBQVAsQ0FBN0I7QUFDQSxNQUFJQyxvQkFBb0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLEVBQVAsRUFBVyxFQUFYLENBQXhCO0FBQ0EsTUFBSUMsc0JBQXNCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsRUFBbkIsRUFBdUIsRUFBdkIsQ0FBMUI7QUFDQSxNQUFJQyxvQkFBb0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUF4Qjs7QUFFQSxXQUFTQyxvQkFBVCxDQUE4QjdDLFNBQTlCLEVBQXlDO0FBQ3ZDLFdBQU8sVUFBVXhILElBQVYsRUFBZ0JvQixjQUFoQixFQUFnQztBQUNyQyxVQUFJbkcsQ0FBSjtBQUFBLFVBQ0krRixJQUFJSSxpQkFBaUJwQixJQUFqQixHQUF3QkEsS0FBS0ssVUFEckM7QUFFQSxhQUFPVyxDQUFQLEVBQVU7QUFDUi9GLFlBQUkrRixFQUFFVixRQUFOO0FBQ0EsWUFBSS9HLElBQUlxRyxhQUFKLENBQWtCNEgsU0FBbEIsRUFBNkJ2TSxDQUE3QixDQUFKLEVBQXFDO0FBQ25DLGlCQUFPK0YsQ0FBUDtBQUNEO0FBQ0RBLFlBQUlBLEVBQUVYLFVBQU47QUFDRDtBQUNELGFBQU8sSUFBUDtBQUNELEtBWEQ7QUFZRDs7QUFFRCxNQUFJd0MsbUJBQW1CdEosSUFBSXNKLGdCQUEzQjtBQUNBLE1BQUl5SCxpQ0FBaUNELHFCQUFxQixDQUFDLENBQUQsRUFBSSxFQUFKLENBQXJCLENBQXJDO0FBQ0EsTUFBSUUsc0JBQXNCRixxQkFBcUJILGlCQUFyQixDQUExQjtBQUNBLE1BQUlNLG1DQUFtQ0gscUJBQXFCLENBQUMsQ0FBRCxFQUFJLEVBQUosRUFBUSxFQUFSLENBQXJCLENBQXZDOztBQUVBLFdBQVNJLHFDQUFULENBQStDekssSUFBL0MsRUFBcUQwSyxTQUFyRCxFQUFnRTtBQUM5RCxRQUFJRixpQ0FBaUN4SyxJQUFqQyxFQUF1QzBLLFNBQXZDLENBQUosRUFBdUQ7QUFDckQsWUFBTSxJQUFJZixjQUFKLENBQW1CLHVCQUFuQixDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTZ0IsaUJBQVQsQ0FBMkI5TyxLQUEzQixFQUFrQztBQUNoQyxRQUFJLENBQUNBLE1BQU00SixjQUFYLEVBQTJCO0FBQ3pCLFlBQU0sSUFBSWIsWUFBSixDQUFpQixtQkFBakIsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsV0FBU2dHLG1CQUFULENBQTZCNUssSUFBN0IsRUFBbUM2SyxZQUFuQyxFQUFpRDtBQUMvQyxRQUFJLENBQUN0UixJQUFJcUcsYUFBSixDQUFrQmlMLFlBQWxCLEVBQWdDN0ssS0FBS00sUUFBckMsQ0FBTCxFQUFxRDtBQUNuRCxZQUFNLElBQUlxSixjQUFKLENBQW1CLHVCQUFuQixDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTbUIsaUJBQVQsQ0FBMkI5SyxJQUEzQixFQUFpQ3dFLE1BQWpDLEVBQXlDO0FBQ3ZDLFFBQUlBLFNBQVMsQ0FBVCxJQUFjQSxVQUFVakwsSUFBSW9ILG1CQUFKLENBQXdCWCxJQUF4QixJQUFnQ0EsS0FBS3hFLE1BQXJDLEdBQThDd0UsS0FBS1UsVUFBTCxDQUFnQmxGLE1BQXhFLENBQWxCLEVBQW1HO0FBQ2pHLFlBQU0sSUFBSW9KLFlBQUosQ0FBaUIsZ0JBQWpCLENBQU47QUFDRDtBQUNGOztBQUVELFdBQVNtRyw0QkFBVCxDQUFzQ2xLLEtBQXRDLEVBQTZDQyxLQUE3QyxFQUFvRDtBQUNsRCxRQUFJd0osK0JBQStCekosS0FBL0IsRUFBc0MsSUFBdEMsTUFBZ0R5SiwrQkFBK0J4SixLQUEvQixFQUFzQyxJQUF0QyxDQUFwRCxFQUFpRztBQUMvRixZQUFNLElBQUk4RCxZQUFKLENBQWlCLG9CQUFqQixDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTb0cscUJBQVQsQ0FBK0JoTCxJQUEvQixFQUFxQztBQUNuQyxRQUFJdUssb0JBQW9CdkssSUFBcEIsRUFBMEIsSUFBMUIsQ0FBSixFQUFxQztBQUNuQyxZQUFNLElBQUk0RSxZQUFKLENBQWlCLDZCQUFqQixDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTcUcsVUFBVCxDQUFvQmpMLElBQXBCLEVBQTBCNkUsUUFBMUIsRUFBb0M7QUFDbEMsUUFBSSxDQUFDN0UsSUFBTCxFQUFXO0FBQ1QsWUFBTSxJQUFJNEUsWUFBSixDQUFpQkMsUUFBakIsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsV0FBU3FHLFFBQVQsQ0FBa0JsTCxJQUFsQixFQUF3QjtBQUN0QixXQUFPLENBQUN6RyxJQUFJcUcsYUFBSixDQUFrQnFLLHNCQUFsQixFQUEwQ2pLLEtBQUtNLFFBQS9DLENBQUQsSUFBNkQsQ0FBQ2dLLCtCQUErQnRLLElBQS9CLEVBQXFDLElBQXJDLENBQXJFO0FBQ0Q7O0FBRUQsV0FBU21MLGFBQVQsQ0FBdUJuTCxJQUF2QixFQUE2QndFLE1BQTdCLEVBQXFDO0FBQ25DLFdBQU9BLFdBQVdqTCxJQUFJb0gsbUJBQUosQ0FBd0JYLElBQXhCLElBQWdDQSxLQUFLeEUsTUFBckMsR0FBOEN3RSxLQUFLVSxVQUFMLENBQWdCbEYsTUFBekUsQ0FBUDtBQUNEOztBQUVELFdBQVM0UCxnQkFBVCxDQUEwQnZQLEtBQTFCLEVBQWlDO0FBQy9COE8sc0JBQWtCOU8sS0FBbEI7QUFDQSxRQUFJcVAsU0FBU3JQLE1BQU00SixjQUFmLEtBQWtDeUYsU0FBU3JQLE1BQU02SixZQUFmLENBQWxDLElBQWtFLENBQUN5RixjQUFjdFAsTUFBTTRKLGNBQXBCLEVBQW9DNUosTUFBTXVNLFdBQTFDLENBQW5FLElBQTZILENBQUMrQyxjQUFjdFAsTUFBTTZKLFlBQXBCLEVBQWtDN0osTUFBTXdNLFNBQXhDLENBQWxJLEVBQXNMO0FBQ3BMLFlBQU0sSUFBSTNKLEtBQUosQ0FBVSwrREFBK0Q3QyxNQUFNOEksT0FBTixFQUEvRCxHQUFpRixHQUEzRixDQUFOO0FBQ0Q7QUFDRjs7QUFFRDs7QUFFQTtBQUNBLE1BQUkwRyxVQUFVOU4sU0FBU2tDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBZDtBQUNBLE1BQUk2TCxzQkFBc0IsS0FBMUI7QUFDQSxNQUFJO0FBQ0ZELFlBQVFFLFNBQVIsR0FBb0IsVUFBcEI7QUFDQUQsMEJBQXNCRCxRQUFROUgsVUFBUixDQUFtQmpELFFBQW5CLElBQStCLENBQXJELENBRkUsQ0FFc0Q7QUFDekQsR0FIRCxDQUdFLE9BQU9uQixDQUFQLEVBQVU7QUFDVjtBQUNEOztBQUVEckQsTUFBSUksUUFBSixDQUFhb1AsbUJBQWIsR0FBbUNBLG1CQUFuQzs7QUFFQSxNQUFJRSwyQkFBMkJGOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVVHLFdBQVYsRUFBdUI7QUFDckI7QUFDQSxRQUFJekwsT0FBTyxLQUFLeUYsY0FBaEI7QUFDQSxRQUFJckQsTUFBTTdJLElBQUkwSSxXQUFKLENBQWdCakMsSUFBaEIsQ0FBVjs7QUFFQTtBQUNBO0FBQ0EsUUFBSSxDQUFDQSxJQUFMLEVBQVc7QUFDVCxZQUFNLElBQUk0RSxZQUFKLENBQWlCLG1CQUFqQixDQUFOO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFFBQUlwRixLQUFLLElBQVQ7O0FBRUE7QUFDQSxRQUFJUSxLQUFLTSxRQUFMLElBQWlCLENBQXJCLEVBQXdCO0FBQ3RCZCxXQUFLUSxJQUFMOztBQUVBO0FBQ0QsS0FKRCxNQUlPLElBQUl6RyxJQUFJb0gsbUJBQUosQ0FBd0JYLElBQXhCLENBQUosRUFBbUM7QUFDeENSLFdBQUtqRyxJQUFJNEcsYUFBSixDQUFrQkgsSUFBbEIsQ0FBTDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFFBQUlSLE9BQU8sSUFBUCxJQUFlQSxHQUFHd0UsUUFBSCxJQUFlLE1BQWYsSUFBeUJ6SyxJQUFJd0csZUFBSixDQUFvQnhHLElBQUkwSSxXQUFKLENBQWdCekMsRUFBaEIsRUFBb0JrTSxlQUF4QyxDQUF6QixJQUFxRm5TLElBQUl3RyxlQUFKLENBQW9CUCxFQUFwQixDQUF4RyxFQUFpSTs7QUFFL0g7QUFDQTtBQUNBQSxXQUFLNEMsSUFBSTNDLGFBQUosQ0FBa0IsTUFBbEIsQ0FBTDtBQUNELEtBTEQsTUFLTztBQUNMRCxXQUFLQSxHQUFHdUMsU0FBSCxDQUFhLEtBQWIsQ0FBTDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0F2QyxPQUFHK0wsU0FBSCxHQUFlRSxXQUFmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBT2xTLElBQUlpSyx3QkFBSixDQUE2QmhFLEVBQTdCLENBQVA7QUFDRCxHQXZEOEI7O0FBeUQvQjtBQUNBO0FBQ0EsWUFBVWlNLFdBQVYsRUFBdUI7QUFDckJkLHNCQUFrQixJQUFsQjtBQUNBLFFBQUl2SSxNQUFNdUQsaUJBQWlCLElBQWpCLENBQVY7QUFDQSxRQUFJbkcsS0FBSzRDLElBQUkzQyxhQUFKLENBQWtCLE1BQWxCLENBQVQ7QUFDQUQsT0FBRytMLFNBQUgsR0FBZUUsV0FBZjs7QUFFQSxXQUFPbFMsSUFBSWlLLHdCQUFKLENBQTZCaEUsRUFBN0IsQ0FBUDtBQUNELEdBbEVEOztBQW9FQTs7QUFFQSxNQUFJbU0sa0JBQWtCLENBQUMsZ0JBQUQsRUFBbUIsYUFBbkIsRUFBa0MsY0FBbEMsRUFBa0QsV0FBbEQsRUFBK0QsV0FBL0QsRUFBNEUseUJBQTVFLENBQXRCOztBQUVBLE1BQUlDLE1BQU0sQ0FBVjtBQUFBLE1BQ0lDLE1BQU0sQ0FEVjtBQUFBLE1BRUlDLE1BQU0sQ0FGVjtBQUFBLE1BR0lDLE1BQU0sQ0FIVjtBQUlBLE1BQUlDLE1BQU0sQ0FBVjtBQUFBLE1BQ0lDLE1BQU0sQ0FEVjtBQUFBLE1BRUlDLFFBQVEsQ0FGWjtBQUFBLE1BR0lDLE1BQU0sQ0FIVjs7QUFLQSxXQUFTQyxjQUFULEdBQTBCLENBQUU7O0FBRTVCQSxpQkFBZWpULFNBQWYsR0FBMkI7QUFDekJrVCxvQkFBZ0IsU0FBU0EsY0FBVCxDQUF3QnhHLElBQXhCLEVBQThCM0gsUUFBOUIsRUFBd0M7QUFDdEQsV0FBSzhILFVBQUwsQ0FBZ0JILElBQWhCLEVBQXNCMUgsSUFBdEIsQ0FBMkJELFFBQTNCO0FBQ0QsS0FId0I7O0FBS3pCb08sMkJBQXVCLFNBQVNBLHFCQUFULENBQStCQyxHQUEvQixFQUFvQzFRLEtBQXBDLEVBQTJDO0FBQ2hFdVAsdUJBQWlCLElBQWpCO0FBQ0FMLG1DQUE2QixLQUFLdEYsY0FBbEMsRUFBa0Q1SixNQUFNNEosY0FBeEQ7O0FBRUEsVUFBSTFDLEtBQUosRUFBV0MsT0FBWCxFQUFvQkMsS0FBcEIsRUFBMkJDLE9BQTNCO0FBQ0EsVUFBSXNKLFVBQVVELE9BQU9SLEdBQVAsSUFBY1EsT0FBT1gsR0FBckIsR0FBMkIsT0FBM0IsR0FBcUMsS0FBbkQ7QUFDQSxVQUFJYSxVQUFVRixPQUFPVixHQUFQLElBQWNVLE9BQU9YLEdBQXJCLEdBQTJCLE9BQTNCLEdBQXFDLEtBQW5EO0FBQ0E3SSxjQUFRLEtBQUt5SixVQUFVLFdBQWYsQ0FBUjtBQUNBeEosZ0JBQVUsS0FBS3dKLFVBQVUsUUFBZixDQUFWO0FBQ0F2SixjQUFRcEgsTUFBTTRRLFVBQVUsV0FBaEIsQ0FBUjtBQUNBdkosZ0JBQVVySCxNQUFNNFEsVUFBVSxRQUFoQixDQUFWO0FBQ0EsYUFBT2xULElBQUl1SixhQUFKLENBQWtCQyxLQUFsQixFQUF5QkMsT0FBekIsRUFBa0NDLEtBQWxDLEVBQXlDQyxPQUF6QyxDQUFQO0FBQ0QsS0FqQndCOztBQW1CekJ3SixnQkFBWSxTQUFTQSxVQUFULENBQW9CMU0sSUFBcEIsRUFBMEI7QUFDcENvTCx1QkFBaUIsSUFBakI7QUFDQVIsMEJBQW9CNUssSUFBcEIsRUFBMEJtSyxtQkFBMUI7QUFDQWEsNEJBQXNCLEtBQUt2RixjQUEzQjs7QUFFQSxVQUFJbE0sSUFBSTBILFlBQUosQ0FBaUJqQixJQUFqQixFQUF1QixLQUFLeUYsY0FBNUIsRUFBNEMsSUFBNUMsQ0FBSixFQUF1RDtBQUNyRCxjQUFNLElBQUliLFlBQUosQ0FBaUIsdUJBQWpCLENBQU47QUFDRDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEsVUFBSTBCLG9CQUFvQkQscUJBQXFCckcsSUFBckIsRUFBMkIsS0FBS3lGLGNBQWhDLEVBQWdELEtBQUsyQyxXQUFyRCxDQUF4QjtBQUNBLFdBQUt1RSxjQUFMLENBQW9CckcsaUJBQXBCO0FBQ0QsS0FsQ3dCOztBQW9DekJzRyxtQkFBZSxTQUFTQSxhQUFULEdBQXlCO0FBQ3RDeEIsdUJBQWlCLElBQWpCOztBQUVBLFVBQUl5QixLQUFKLEVBQVdwRyxJQUFYO0FBQ0EsVUFBSSxLQUFLOEIsU0FBVCxFQUFvQjtBQUNsQixlQUFPNUMsaUJBQWlCLElBQWpCLEVBQXVCakMsc0JBQXZCLEVBQVA7QUFDRCxPQUZELE1BRU87QUFDTCxZQUFJLEtBQUsrQixjQUFMLEtBQXdCLEtBQUtDLFlBQTdCLElBQTZDbk0sSUFBSW9ILG1CQUFKLENBQXdCLEtBQUs4RSxjQUE3QixDQUFqRCxFQUErRjtBQUM3Rm9ILGtCQUFRLEtBQUtwSCxjQUFMLENBQW9CMUQsU0FBcEIsQ0FBOEIsSUFBOUIsQ0FBUjtBQUNBOEssZ0JBQU1oSixJQUFOLEdBQWFnSixNQUFNaEosSUFBTixDQUFXaUosS0FBWCxDQUFpQixLQUFLMUUsV0FBdEIsRUFBbUMsS0FBS0MsU0FBeEMsQ0FBYjtBQUNBNUIsaUJBQU9kLGlCQUFpQixJQUFqQixFQUF1QmpDLHNCQUF2QixFQUFQO0FBQ0ErQyxlQUFLOUUsV0FBTCxDQUFpQmtMLEtBQWpCO0FBQ0EsaUJBQU9wRyxJQUFQO0FBQ0QsU0FORCxNQU1PO0FBQ0wsY0FBSXpOLFdBQVcsSUFBSWdQLGFBQUosQ0FBa0IsSUFBbEIsRUFBd0IsSUFBeEIsQ0FBZjtBQUNBNkUsa0JBQVF0RyxhQUFhdk4sUUFBYixDQUFSO0FBQ0FBLG1CQUFTeUUsTUFBVDtBQUNEO0FBQ0QsZUFBT29QLEtBQVA7QUFDRDtBQUNGLEtBeER3Qjs7QUEwRHpCRSx5QkFBcUIsU0FBU0EsbUJBQVQsR0FBK0I7QUFDbEQzQix1QkFBaUIsSUFBakI7QUFDQUosNEJBQXNCLEtBQUt2RixjQUEzQjtBQUNBdUYsNEJBQXNCLEtBQUt0RixZQUEzQjs7QUFFQTtBQUNBO0FBQ0EsVUFBSTFNLFdBQVcsSUFBSWdQLGFBQUosQ0FBa0IsSUFBbEIsRUFBd0IsSUFBeEIsQ0FBZjtBQUNBLFVBQUlnRixvQkFBb0JoVSxTQUFTOFAsTUFBVCxJQUFtQnRELDJCQUEyQnhNLFNBQVM4UCxNQUFwQyxFQUE0QyxJQUE1QyxDQUFuQixJQUF3RTlQLFNBQVMrUCxLQUFULElBQWtCdkQsMkJBQTJCeE0sU0FBUytQLEtBQXBDLEVBQTJDLElBQTNDLENBQWxIO0FBQ0EvUCxlQUFTeUUsTUFBVDtBQUNBLGFBQU8sQ0FBQ3VQLGlCQUFSO0FBQ0QsS0FyRXdCOztBQXVFekJDLHNCQUFrQixTQUFTQSxnQkFBVCxDQUEwQmpOLElBQTFCLEVBQWdDO0FBQ2hENEssMEJBQW9CNUssSUFBcEIsRUFBMEJvSyxpQkFBMUI7O0FBRUEsVUFBSSxDQUFDLEtBQUsyQyxtQkFBTCxFQUFMLEVBQWlDO0FBQy9CLGNBQU0sSUFBSXBELGNBQUosQ0FBbUIsd0JBQW5CLENBQU47QUFDRDs7QUFFRDtBQUNBLFVBQUl1RCxVQUFVLEtBQUtDLGVBQUwsRUFBZDs7QUFFQTtBQUNBLFVBQUluTixLQUFLb04sYUFBTCxFQUFKLEVBQTBCO0FBQ3hCLGVBQU9wTixLQUFLcU4sU0FBWixFQUF1QjtBQUNyQnJOLGVBQUtvSixXQUFMLENBQWlCcEosS0FBS3FOLFNBQXRCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBaEgsMkJBQXFCckcsSUFBckIsRUFBMkIsS0FBS3lGLGNBQWhDLEVBQWdELEtBQUsyQyxXQUFyRDtBQUNBcEksV0FBSzJCLFdBQUwsQ0FBaUJ1TCxPQUFqQjs7QUFFQSxXQUFLSSxVQUFMLENBQWdCdE4sSUFBaEI7QUFDRCxLQTdGd0I7O0FBK0Z6QnNKLGdCQUFZLFNBQVNBLFVBQVQsR0FBc0I7QUFDaEM4Qix1QkFBaUIsSUFBakI7QUFDQSxVQUFJdlAsUUFBUSxJQUFJMk4sS0FBSixDQUFVN0QsaUJBQWlCLElBQWpCLENBQVYsQ0FBWjtBQUNBLFVBQUlwSyxJQUFJb1EsZ0JBQWdCblEsTUFBeEI7QUFBQSxVQUNJK1IsSUFESjtBQUVBLGFBQU9oUyxHQUFQLEVBQVk7QUFDVmdTLGVBQU81QixnQkFBZ0JwUSxDQUFoQixDQUFQO0FBQ0FNLGNBQU0wUixJQUFOLElBQWMsS0FBS0EsSUFBTCxDQUFkO0FBQ0Q7QUFDRCxhQUFPMVIsS0FBUDtBQUNELEtBekd3Qjs7QUEyR3pCMEosY0FBVSxTQUFTQSxRQUFULEdBQW9CO0FBQzVCNkYsdUJBQWlCLElBQWpCO0FBQ0EsVUFBSTVDLEtBQUssS0FBSy9DLGNBQWQ7QUFDQSxVQUFJK0MsT0FBTyxLQUFLOUMsWUFBWixJQUE0Qm5NLElBQUlvSCxtQkFBSixDQUF3QjZILEVBQXhCLENBQWhDLEVBQTZEO0FBQzNELGVBQU9BLEdBQUdsSSxRQUFILElBQWUsQ0FBZixJQUFvQmtJLEdBQUdsSSxRQUFILElBQWUsQ0FBbkMsR0FBdUNrSSxHQUFHM0UsSUFBSCxDQUFRaUosS0FBUixDQUFjLEtBQUsxRSxXQUFuQixFQUFnQyxLQUFLQyxTQUFyQyxDQUF2QyxHQUF5RixFQUFoRztBQUNELE9BRkQsTUFFTztBQUNMLFlBQUltRixXQUFXLEVBQWY7QUFBQSxZQUNJeFUsV0FBVyxJQUFJZ1AsYUFBSixDQUFrQixJQUFsQixFQUF3QixJQUF4QixDQURmOztBQUdBbkIsdUJBQWU3TixRQUFmLEVBQXlCLFVBQVVnSCxJQUFWLEVBQWdCO0FBQ3ZDOztBQUVBLGNBQUlBLEtBQUtNLFFBQUwsSUFBaUIsQ0FBakIsSUFBc0JOLEtBQUtNLFFBQUwsSUFBaUIsQ0FBM0MsRUFBOEM7QUFDNUNrTixxQkFBU3JQLElBQVQsQ0FBYzZCLEtBQUs2RCxJQUFuQjtBQUNEO0FBQ0YsU0FORDtBQU9BN0ssaUJBQVN5RSxNQUFUO0FBQ0EsZUFBTytQLFNBQVMxRixJQUFULENBQWMsRUFBZCxDQUFQO0FBQ0Q7QUFDRixLQTlId0I7O0FBZ0l6QjtBQUNBOztBQUVBMkYsaUJBQWEsU0FBU0EsV0FBVCxDQUFxQnpOLElBQXJCLEVBQTJCO0FBQ3RDb0wsdUJBQWlCLElBQWpCOztBQUVBLFVBQUloTCxTQUFTSixLQUFLSyxVQUFsQjtBQUNBLFVBQUlxTixZQUFZblUsSUFBSWdILFlBQUosQ0FBaUJQLElBQWpCLENBQWhCOztBQUVBLFVBQUksQ0FBQ0ksTUFBTCxFQUFhO0FBQ1gsY0FBTSxJQUFJd0UsWUFBSixDQUFpQixlQUFqQixDQUFOO0FBQ0Q7O0FBRUQsVUFBSStJLGtCQUFrQixLQUFLQyxZQUFMLENBQWtCeE4sTUFBbEIsRUFBMEJzTixTQUExQixDQUF0QjtBQUFBLFVBQ0lHLGdCQUFnQixLQUFLRCxZQUFMLENBQWtCeE4sTUFBbEIsRUFBMEJzTixZQUFZLENBQXRDLENBRHBCOztBQUdBLFVBQUlDLGtCQUFrQixDQUF0QixFQUF5QjtBQUN2QjtBQUNBLGVBQU9FLGdCQUFnQixDQUFoQixHQUFvQjNCLEtBQXBCLEdBQTRCRixHQUFuQztBQUNELE9BSEQsTUFHTztBQUNMLGVBQU82QixnQkFBZ0IsQ0FBaEIsR0FBb0I1QixHQUFwQixHQUEwQkUsR0FBakM7QUFDRDtBQUNGLEtBdEp3Qjs7QUF3SnpCeUIsa0JBQWMsU0FBU0EsWUFBVCxDQUFzQjVOLElBQXRCLEVBQTRCd0UsTUFBNUIsRUFBb0M7QUFDaEQ0Ryx1QkFBaUIsSUFBakI7QUFDQUgsaUJBQVdqTCxJQUFYLEVBQWlCLHVCQUFqQjtBQUNBK0ssbUNBQTZCL0ssSUFBN0IsRUFBbUMsS0FBS3lGLGNBQXhDOztBQUVBLFVBQUlsTSxJQUFJdUosYUFBSixDQUFrQjlDLElBQWxCLEVBQXdCd0UsTUFBeEIsRUFBZ0MsS0FBS2lCLGNBQXJDLEVBQXFELEtBQUsyQyxXQUExRCxJQUF5RSxDQUE3RSxFQUFnRjtBQUM5RSxlQUFPLENBQUMsQ0FBUjtBQUNELE9BRkQsTUFFTyxJQUFJN08sSUFBSXVKLGFBQUosQ0FBa0I5QyxJQUFsQixFQUF3QndFLE1BQXhCLEVBQWdDLEtBQUtrQixZQUFyQyxFQUFtRCxLQUFLMkMsU0FBeEQsSUFBcUUsQ0FBekUsRUFBNEU7QUFDakYsZUFBTyxDQUFQO0FBQ0Q7QUFDRCxhQUFPLENBQVA7QUFDRCxLQW5Ld0I7O0FBcUt6Qm1ELDhCQUEwQkEsd0JBcktEOztBQXVLekJzQyxZQUFRLFNBQVNBLE1BQVQsR0FBa0I7QUFDeEIxQyx1QkFBaUIsSUFBakI7QUFDQSxVQUFJMkMsWUFBWXBJLGlCQUFpQixJQUFqQixFQUF1QmxHLGFBQXZCLENBQXFDLEtBQXJDLENBQWhCO0FBQ0FzTyxnQkFBVXBNLFdBQVYsQ0FBc0IsS0FBS2lMLGFBQUwsRUFBdEI7QUFDQSxhQUFPbUIsVUFBVXhDLFNBQWpCO0FBQ0QsS0E1S3dCOztBQThLekI7QUFDQTtBQUNBeUMsb0JBQWdCLFNBQVNBLGNBQVQsQ0FBd0JoTyxJQUF4QixFQUE4QmlPLHNCQUE5QixFQUFzRDtBQUNwRTdDLHVCQUFpQixJQUFqQjtBQUNBSCxpQkFBV2pMLElBQVgsRUFBaUIsZUFBakI7QUFDQSxVQUFJekcsSUFBSTBJLFdBQUosQ0FBZ0JqQyxJQUFoQixNQUEwQjJGLGlCQUFpQixJQUFqQixDQUE5QixFQUFzRDtBQUNwRCxlQUFPLEtBQVA7QUFDRDs7QUFFRCxVQUFJdkYsU0FBU0osS0FBS0ssVUFBbEI7QUFBQSxVQUNJbUUsU0FBU2pMLElBQUlnSCxZQUFKLENBQWlCUCxJQUFqQixDQURiO0FBRUFpTCxpQkFBVzdLLE1BQVgsRUFBbUIsZUFBbkI7O0FBRUEsVUFBSXVOLGtCQUFrQnBVLElBQUl1SixhQUFKLENBQWtCMUMsTUFBbEIsRUFBMEJvRSxNQUExQixFQUFrQyxLQUFLa0IsWUFBdkMsRUFBcUQsS0FBSzJDLFNBQTFELENBQXRCO0FBQUEsVUFDSXdGLGdCQUFnQnRVLElBQUl1SixhQUFKLENBQWtCMUMsTUFBbEIsRUFBMEJvRSxTQUFTLENBQW5DLEVBQXNDLEtBQUtpQixjQUEzQyxFQUEyRCxLQUFLMkMsV0FBaEUsQ0FEcEI7O0FBR0EsYUFBTzZGLHlCQUF5Qk4sbUJBQW1CLENBQW5CLElBQXdCRSxpQkFBaUIsQ0FBbEUsR0FBc0VGLGtCQUFrQixDQUFsQixJQUF1QkUsZ0JBQWdCLENBQXBIO0FBQ0QsS0EvTHdCOztBQWlNekJLLG9CQUFnQixTQUFTQSxjQUFULENBQXdCbE8sSUFBeEIsRUFBOEJ3RSxNQUE5QixFQUFzQztBQUNwRDRHLHVCQUFpQixJQUFqQjtBQUNBSCxpQkFBV2pMLElBQVgsRUFBaUIsdUJBQWpCO0FBQ0ErSyxtQ0FBNkIvSyxJQUE3QixFQUFtQyxLQUFLeUYsY0FBeEM7O0FBRUEsYUFBT2xNLElBQUl1SixhQUFKLENBQWtCOUMsSUFBbEIsRUFBd0J3RSxNQUF4QixFQUFnQyxLQUFLaUIsY0FBckMsRUFBcUQsS0FBSzJDLFdBQTFELEtBQTBFLENBQTFFLElBQStFN08sSUFBSXVKLGFBQUosQ0FBa0I5QyxJQUFsQixFQUF3QndFLE1BQXhCLEVBQWdDLEtBQUtrQixZQUFyQyxFQUFtRCxLQUFLMkMsU0FBeEQsS0FBc0UsQ0FBNUo7QUFDRCxLQXZNd0I7O0FBeU16Qjs7QUFFQTtBQUNBOEYscUJBQWlCLFNBQVNBLGVBQVQsQ0FBeUJ0UyxLQUF6QixFQUFnQ29TLHNCQUFoQyxFQUF3RDtBQUN2RTdDLHVCQUFpQixJQUFqQjs7QUFFQSxVQUFJekYsaUJBQWlCOUosS0FBakIsS0FBMkI4SixpQkFBaUIsSUFBakIsQ0FBL0IsRUFBdUQ7QUFDckQsY0FBTSxJQUFJZixZQUFKLENBQWlCLG9CQUFqQixDQUFOO0FBQ0Q7O0FBRUQsVUFBSStJLGtCQUFrQnBVLElBQUl1SixhQUFKLENBQWtCLEtBQUsyQyxjQUF2QixFQUF1QyxLQUFLMkMsV0FBNUMsRUFBeUR2TSxNQUFNNkosWUFBL0QsRUFBNkU3SixNQUFNd00sU0FBbkYsQ0FBdEI7QUFBQSxVQUNJd0YsZ0JBQWdCdFUsSUFBSXVKLGFBQUosQ0FBa0IsS0FBSzRDLFlBQXZCLEVBQXFDLEtBQUsyQyxTQUExQyxFQUFxRHhNLE1BQU00SixjQUEzRCxFQUEyRTVKLE1BQU11TSxXQUFqRixDQURwQjs7QUFHQSxhQUFPNkYseUJBQXlCTixtQkFBbUIsQ0FBbkIsSUFBd0JFLGlCQUFpQixDQUFsRSxHQUFzRUYsa0JBQWtCLENBQWxCLElBQXVCRSxnQkFBZ0IsQ0FBcEg7QUFDRCxLQXZOd0I7O0FBeU56Qk8sa0JBQWMsU0FBU0EsWUFBVCxDQUFzQnZTLEtBQXRCLEVBQTZCO0FBQ3pDLFVBQUksS0FBS3NTLGVBQUwsQ0FBcUJ0UyxLQUFyQixDQUFKLEVBQWlDO0FBQy9CLFlBQUk4UixrQkFBa0JwVSxJQUFJdUosYUFBSixDQUFrQixLQUFLMkMsY0FBdkIsRUFBdUMsS0FBSzJDLFdBQTVDLEVBQXlEdk0sTUFBTTRKLGNBQS9ELEVBQStFNUosTUFBTXVNLFdBQXJGLENBQXRCO0FBQUEsWUFDSXlGLGdCQUFnQnRVLElBQUl1SixhQUFKLENBQWtCLEtBQUs0QyxZQUF2QixFQUFxQyxLQUFLMkMsU0FBMUMsRUFBcUR4TSxNQUFNNkosWUFBM0QsRUFBeUU3SixNQUFNd00sU0FBL0UsQ0FEcEI7O0FBR0EsWUFBSWdHLG9CQUFvQixLQUFLL0UsVUFBTCxFQUF4Qjs7QUFFQSxZQUFJcUUsbUJBQW1CLENBQUMsQ0FBeEIsRUFBMkI7QUFDekJVLDRCQUFrQkMsUUFBbEIsQ0FBMkJ6UyxNQUFNNEosY0FBakMsRUFBaUQ1SixNQUFNdU0sV0FBdkQ7QUFDRDtBQUNELFlBQUl5RixpQkFBaUIsQ0FBckIsRUFBd0I7QUFDdEJRLDRCQUFrQkUsTUFBbEIsQ0FBeUIxUyxNQUFNNkosWUFBL0IsRUFBNkM3SixNQUFNd00sU0FBbkQ7QUFDRDtBQUNELGVBQU9nRyxpQkFBUDtBQUNEO0FBQ0QsYUFBTyxJQUFQO0FBQ0QsS0F6T3dCOztBQTJPekJHLFdBQU8sU0FBU0EsS0FBVCxDQUFlM1MsS0FBZixFQUFzQjtBQUMzQixVQUFJLEtBQUtzUyxlQUFMLENBQXFCdFMsS0FBckIsRUFBNEIsSUFBNUIsQ0FBSixFQUF1QztBQUNyQyxZQUFJNFMsYUFBYSxLQUFLbkYsVUFBTCxFQUFqQjtBQUNBLFlBQUkvUCxJQUFJdUosYUFBSixDQUFrQmpILE1BQU00SixjQUF4QixFQUF3QzVKLE1BQU11TSxXQUE5QyxFQUEyRCxLQUFLM0MsY0FBaEUsRUFBZ0YsS0FBSzJDLFdBQXJGLEtBQXFHLENBQUMsQ0FBMUcsRUFBNkc7QUFDM0dxRyxxQkFBV0gsUUFBWCxDQUFvQnpTLE1BQU00SixjQUExQixFQUEwQzVKLE1BQU11TSxXQUFoRDtBQUNEO0FBQ0QsWUFBSTdPLElBQUl1SixhQUFKLENBQWtCakgsTUFBTTZKLFlBQXhCLEVBQXNDN0osTUFBTXdNLFNBQTVDLEVBQXVELEtBQUszQyxZQUE1RCxFQUEwRSxLQUFLMkMsU0FBL0UsS0FBNkYsQ0FBakcsRUFBb0c7QUFDbEdvRyxxQkFBV0YsTUFBWCxDQUFrQjFTLE1BQU02SixZQUF4QixFQUFzQzdKLE1BQU13TSxTQUE1QztBQUNEO0FBQ0QsZUFBT29HLFVBQVA7QUFDRCxPQVRELE1BU087QUFDTCxjQUFNLElBQUk5RSxjQUFKLENBQW1CLHlCQUFuQixDQUFOO0FBQ0Q7QUFDRixLQXhQd0I7O0FBMFB6QitFLGtCQUFjLFNBQVNBLFlBQVQsQ0FBc0IxTyxJQUF0QixFQUE0QjJPLFlBQTVCLEVBQTBDO0FBQ3RELFVBQUlBLFlBQUosRUFBa0I7QUFDaEIsZUFBTyxLQUFLWCxjQUFMLENBQW9CaE8sSUFBcEIsRUFBMEIsS0FBMUIsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU8sS0FBS3lOLFdBQUwsQ0FBaUJ6TixJQUFqQixLQUEwQm1NLEdBQWpDO0FBQ0Q7QUFDRixLQWhRd0I7O0FBa1F6QnlDLDBCQUFzQixTQUFTQSxvQkFBVCxDQUE4QjVPLElBQTlCLEVBQW9DO0FBQ3hELGFBQU8sS0FBSzROLFlBQUwsQ0FBa0I1TixJQUFsQixFQUF3QixDQUF4QixLQUE4QixDQUE5QixJQUFtQyxLQUFLNE4sWUFBTCxDQUFrQjVOLElBQWxCLEVBQXdCekcsSUFBSWtILGFBQUosQ0FBa0JULElBQWxCLENBQXhCLEtBQW9ELENBQTlGO0FBQ0QsS0FwUXdCOztBQXNRekI2TyxtQkFBZSxTQUFTQSxhQUFULENBQXVCaFQsS0FBdkIsRUFBOEI7QUFDM0MsYUFBTyxLQUFLdVMsWUFBTCxDQUFrQnZTLEtBQWxCLEVBQXlCNEksTUFBekIsQ0FBZ0M1SSxLQUFoQyxDQUFQO0FBQ0QsS0F4UXdCOztBQTBRekJpVCxzQkFBa0IsU0FBU0EsZ0JBQVQsQ0FBMEI5TyxJQUExQixFQUFnQztBQUNoRCxVQUFJK08sWUFBWSxLQUFLekYsVUFBTCxFQUFoQjtBQUNBeUYsZ0JBQVV6QixVQUFWLENBQXFCdE4sSUFBckI7QUFDQSxVQUFJZ1AsWUFBWUQsVUFBVUUsUUFBVixDQUFtQixDQUFDLENBQUQsQ0FBbkIsQ0FBaEI7QUFDQSxVQUFJRCxVQUFVeFQsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN4QnVULGtCQUFVVCxRQUFWLENBQW1CVSxVQUFVLENBQVYsQ0FBbkIsRUFBaUMsQ0FBakM7QUFDQSxZQUFJRSxlQUFlRixVQUFVRyxHQUFWLEVBQW5CO0FBQ0FKLGtCQUFVUixNQUFWLENBQWlCVyxZQUFqQixFQUErQkEsYUFBYTFULE1BQTVDO0FBQ0EsWUFBSTRULFdBQVcsS0FBS1AsYUFBTCxDQUFtQkUsU0FBbkIsQ0FBZjtBQUNBQSxrQkFBVXRSLE1BQVY7QUFDQSxlQUFPMlIsUUFBUDtBQUNELE9BUEQsTUFPTztBQUNMLGVBQU8sS0FBS1Isb0JBQUwsQ0FBMEI1TyxJQUExQixDQUFQO0FBQ0Q7QUFDRixLQXhSd0I7O0FBMFJ6QnFQLHdCQUFvQixTQUFTQSxrQkFBVCxDQUE0QjdILFNBQTVCLEVBQXVDQyxNQUF2QyxFQUErQztBQUNqRTJELHVCQUFpQixJQUFqQjtBQUNBLGFBQU8sSUFBSXRCLGlCQUFKLENBQXNCLElBQXRCLEVBQTRCdEMsU0FBNUIsRUFBdUNDLE1BQXZDLENBQVA7QUFDRCxLQTdSd0I7O0FBK1J6QndILGNBQVUsU0FBU0EsUUFBVCxDQUFrQnpILFNBQWxCLEVBQTZCQyxNQUE3QixFQUFxQztBQUM3QzJELHVCQUFpQixJQUFqQjtBQUNBLGFBQU83RCxnQkFBZ0IsSUFBaEIsRUFBc0JDLFNBQXRCLEVBQWlDQyxNQUFqQyxDQUFQO0FBQ0QsS0FsU3dCOztBQW9TekJ4RixpQkFBYSxTQUFTQSxXQUFULEdBQXVCO0FBQ2xDLGFBQU8wRCxpQkFBaUIsSUFBakIsQ0FBUDtBQUNELEtBdFN3Qjs7QUF3U3pCMkosb0JBQWdCLFNBQVNBLGNBQVQsQ0FBd0J0UCxJQUF4QixFQUE4QjtBQUM1QzJLLHdCQUFrQixJQUFsQjs7QUFFQSxXQUFLNEUsWUFBTCxDQUFrQnZQLElBQWxCO0FBQ0EsV0FBS3VKLFFBQUwsQ0FBYyxLQUFkO0FBQ0QsS0E3U3dCOztBQStTekJpRyxtQkFBZSxTQUFTQSxhQUFULENBQXVCeFAsSUFBdkIsRUFBNkI7QUFDMUMySyx3QkFBa0IsSUFBbEI7O0FBRUEsV0FBSzhFLGFBQUwsQ0FBbUJ6UCxJQUFuQjtBQUNBLFdBQUt1SixRQUFMLENBQWMsSUFBZDtBQUNELEtBcFR3Qjs7QUFzVHpCcEIsYUFBUyxTQUFTQSxPQUFULEdBQW1CO0FBQzFCLGFBQU8sVUFBUDtBQUNELEtBeFR3Qjs7QUEwVHpCMUQsWUFBUSxTQUFTQSxNQUFULENBQWdCNUksS0FBaEIsRUFBdUI7QUFDN0IsYUFBTzJOLE1BQU1rRyxXQUFOLENBQWtCLElBQWxCLEVBQXdCN1QsS0FBeEIsQ0FBUDtBQUNELEtBNVR3Qjs7QUE4VHpCOEksYUFBUyxTQUFTQSxPQUFULEdBQW1CO0FBQzFCLGFBQU91RCxTQUFTLElBQVQsQ0FBUDtBQUNEO0FBaFV3QixHQUEzQjs7QUFtVUEsV0FBU3lILCtCQUFULENBQXlDMVcsR0FBekMsRUFBOEM7QUFDNUNBLFFBQUkyVyxjQUFKLEdBQXFCaEUsR0FBckI7QUFDQTNTLFFBQUk0VyxZQUFKLEdBQW1CaEUsR0FBbkI7QUFDQTVTLFFBQUk2VyxVQUFKLEdBQWlCaEUsR0FBakI7QUFDQTdTLFFBQUk4VyxZQUFKLEdBQW1CaEUsR0FBbkI7O0FBRUE5UyxRQUFJK1csV0FBSixHQUFrQmhFLEdBQWxCO0FBQ0EvUyxRQUFJZ1gsVUFBSixHQUFpQmhFLEdBQWpCO0FBQ0FoVCxRQUFJaVgscUJBQUosR0FBNEJoRSxLQUE1QjtBQUNBalQsUUFBSWtYLFdBQUosR0FBa0JoRSxHQUFsQjtBQUNEOztBQUVELFdBQVNpRSx1QkFBVCxDQUFpQ2xYLFdBQWpDLEVBQThDO0FBQzVDeVcsb0NBQWdDelcsV0FBaEM7QUFDQXlXLG9DQUFnQ3pXLFlBQVlDLFNBQTVDO0FBQ0Q7O0FBRUQsV0FBU2tYLHlCQUFULENBQW1DQyxPQUFuQyxFQUE0Q0MsZUFBNUMsRUFBNkQ7QUFDM0QsV0FBTyxZQUFZO0FBQ2pCbkYsdUJBQWlCLElBQWpCOztBQUVBLFVBQUk1QyxLQUFLLEtBQUsvQyxjQUFkO0FBQUEsVUFDSWdELEtBQUssS0FBS0wsV0FEZDtBQUFBLFVBRUloRixPQUFPLEtBQUt3Rix1QkFGaEI7O0FBSUEsVUFBSTVQLFdBQVcsSUFBSWdQLGFBQUosQ0FBa0IsSUFBbEIsRUFBd0IsSUFBeEIsQ0FBZjs7QUFFQTtBQUNBLFVBQUloSSxJQUFKLEVBQVV3USxRQUFWO0FBQ0EsVUFBSWhJLE9BQU9wRixJQUFYLEVBQWlCO0FBQ2ZwRCxlQUFPekcsSUFBSThILG9CQUFKLENBQXlCbUgsRUFBekIsRUFBNkJwRixJQUE3QixFQUFtQyxJQUFuQyxDQUFQO0FBQ0FvTixtQkFBV3BLLHFCQUFxQnBHLElBQXJCLENBQVg7QUFDQXdJLGFBQUtnSSxTQUFTeFEsSUFBZDtBQUNBeUksYUFBSytILFNBQVNoTSxNQUFkO0FBQ0Q7O0FBRUQ7QUFDQXFDLHFCQUFlN04sUUFBZixFQUF5QmdTLHFCQUF6Qjs7QUFFQWhTLGVBQVNnUSxLQUFUOztBQUVBO0FBQ0EsVUFBSXlILGNBQWNILFFBQVF0WCxRQUFSLENBQWxCO0FBQ0FBLGVBQVN5RSxNQUFUOztBQUVBO0FBQ0E4UyxzQkFBZ0IsSUFBaEIsRUFBc0IvSCxFQUF0QixFQUEwQkMsRUFBMUIsRUFBOEJELEVBQTlCLEVBQWtDQyxFQUFsQzs7QUFFQSxhQUFPZ0ksV0FBUDtBQUNELEtBL0JEO0FBZ0NEOztBQUVELFdBQVNDLG9CQUFULENBQThCeFgsV0FBOUIsRUFBMkNxWCxlQUEzQyxFQUE0REksUUFBNUQsRUFBc0U7QUFDcEUsYUFBU0MsMkJBQVQsQ0FBcUNDLFFBQXJDLEVBQStDQyxPQUEvQyxFQUF3RDtBQUN0RCxhQUFPLFVBQVU5USxJQUFWLEVBQWdCO0FBQ3JCMkssMEJBQWtCLElBQWxCO0FBQ0FDLDRCQUFvQjVLLElBQXBCLEVBQTBCZ0ssb0JBQTFCO0FBQ0FZLDRCQUFvQi9ILGlCQUFpQjdDLElBQWpCLENBQXBCLEVBQTRDaUssc0JBQTVDOztBQUVBLFlBQUl1RyxXQUFXLENBQUNLLFdBQVcxSyxxQkFBWCxHQUFtQ0Msb0JBQXBDLEVBQTBEcEcsSUFBMUQsQ0FBZjtBQUNBLFNBQUM4USxVQUFVQyxhQUFWLEdBQTBCQyxXQUEzQixFQUF3QyxJQUF4QyxFQUE4Q1IsU0FBU3hRLElBQXZELEVBQTZEd1EsU0FBU2hNLE1BQXRFO0FBQ0QsT0FQRDtBQVFEOztBQUVELGFBQVN1TSxhQUFULENBQXVCbFYsS0FBdkIsRUFBOEJtRSxJQUE5QixFQUFvQ3dFLE1BQXBDLEVBQTRDO0FBQzFDLFVBQUlrRSxLQUFLN00sTUFBTTZKLFlBQWY7QUFBQSxVQUNJaUQsS0FBSzlNLE1BQU13TSxTQURmO0FBRUEsVUFBSXJJLFNBQVNuRSxNQUFNNEosY0FBZixJQUFpQ2pCLFdBQVczSSxNQUFNdU0sV0FBdEQsRUFBbUU7QUFDakU7QUFDQTtBQUNBLFlBQUl2RixpQkFBaUI3QyxJQUFqQixLQUEwQjZDLGlCQUFpQjZGLEVBQWpCLENBQTFCLElBQWtEblAsSUFBSXVKLGFBQUosQ0FBa0I5QyxJQUFsQixFQUF3QndFLE1BQXhCLEVBQWdDa0UsRUFBaEMsRUFBb0NDLEVBQXBDLEtBQTJDLENBQWpHLEVBQW9HO0FBQ2xHRCxlQUFLMUksSUFBTDtBQUNBMkksZUFBS25FLE1BQUw7QUFDRDtBQUNEK0wsd0JBQWdCMVUsS0FBaEIsRUFBdUJtRSxJQUF2QixFQUE2QndFLE1BQTdCLEVBQXFDa0UsRUFBckMsRUFBeUNDLEVBQXpDO0FBQ0Q7QUFDRjs7QUFFRCxhQUFTcUksV0FBVCxDQUFxQm5WLEtBQXJCLEVBQTRCbUUsSUFBNUIsRUFBa0N3RSxNQUFsQyxFQUEwQztBQUN4QyxVQUFJZ0UsS0FBSzNNLE1BQU00SixjQUFmO0FBQUEsVUFDSWdELEtBQUs1TSxNQUFNdU0sV0FEZjtBQUVBLFVBQUlwSSxTQUFTbkUsTUFBTTZKLFlBQWYsSUFBK0JsQixXQUFXM0ksTUFBTXdNLFNBQXBELEVBQStEO0FBQzdEO0FBQ0E7QUFDQSxZQUFJeEYsaUJBQWlCN0MsSUFBakIsS0FBMEI2QyxpQkFBaUIyRixFQUFqQixDQUExQixJQUFrRGpQLElBQUl1SixhQUFKLENBQWtCOUMsSUFBbEIsRUFBd0J3RSxNQUF4QixFQUFnQ2dFLEVBQWhDLEVBQW9DQyxFQUFwQyxLQUEyQyxDQUFDLENBQWxHLEVBQXFHO0FBQ25HRCxlQUFLeEksSUFBTDtBQUNBeUksZUFBS2pFLE1BQUw7QUFDRDtBQUNEK0wsd0JBQWdCMVUsS0FBaEIsRUFBdUIyTSxFQUF2QixFQUEyQkMsRUFBM0IsRUFBK0J6SSxJQUEvQixFQUFxQ3dFLE1BQXJDO0FBQ0Q7QUFDRjs7QUFFRCxhQUFTeU0sbUJBQVQsQ0FBNkJwVixLQUE3QixFQUFvQ21FLElBQXBDLEVBQTBDd0UsTUFBMUMsRUFBa0Q7QUFDaEQsVUFBSXhFLFNBQVNuRSxNQUFNNEosY0FBZixJQUFpQ2pCLFdBQVczSSxNQUFNdU0sV0FBbEQsSUFBaUVwSSxTQUFTbkUsTUFBTTZKLFlBQWhGLElBQWdHbEIsV0FBVzNJLE1BQU13TSxTQUFySCxFQUFnSTtBQUM5SGtJLHdCQUFnQjFVLEtBQWhCLEVBQXVCbUUsSUFBdkIsRUFBNkJ3RSxNQUE3QixFQUFxQ3hFLElBQXJDLEVBQTJDd0UsTUFBM0M7QUFDRDtBQUNGOztBQUVEdEwsZ0JBQVlDLFNBQVosR0FBd0IsSUFBSWlULGNBQUosRUFBeEI7O0FBRUF0USxRQUFJRyxJQUFKLENBQVNlLE1BQVQsQ0FBZ0I5RCxZQUFZQyxTQUE1QixFQUF1QztBQUNyQ21WLGdCQUFVLFNBQVNBLFFBQVQsQ0FBa0J0TyxJQUFsQixFQUF3QndFLE1BQXhCLEVBQWdDO0FBQ3hDbUcsMEJBQWtCLElBQWxCO0FBQ0FGLDhDQUFzQ3pLLElBQXRDLEVBQTRDLElBQTVDO0FBQ0E4SywwQkFBa0I5SyxJQUFsQixFQUF3QndFLE1BQXhCOztBQUVBdU0sc0JBQWMsSUFBZCxFQUFvQi9RLElBQXBCLEVBQTBCd0UsTUFBMUI7QUFDRCxPQVBvQzs7QUFTckMrSixjQUFRLFNBQVNBLE1BQVQsQ0FBZ0J2TyxJQUFoQixFQUFzQndFLE1BQXRCLEVBQThCO0FBQ3BDbUcsMEJBQWtCLElBQWxCO0FBQ0FGLDhDQUFzQ3pLLElBQXRDLEVBQTRDLElBQTVDO0FBQ0E4SywwQkFBa0I5SyxJQUFsQixFQUF3QndFLE1BQXhCOztBQUVBd00sb0JBQVksSUFBWixFQUFrQmhSLElBQWxCLEVBQXdCd0UsTUFBeEI7QUFDRCxPQWZvQzs7QUFpQnJDbUksc0JBQWdCaUUsNEJBQTRCLElBQTVCLEVBQWtDLElBQWxDLENBakJxQjtBQWtCckNuQixxQkFBZW1CLDRCQUE0QixLQUE1QixFQUFtQyxJQUFuQyxDQWxCc0I7QUFtQnJDckIsb0JBQWNxQiw0QkFBNEIsSUFBNUIsRUFBa0MsS0FBbEMsQ0FuQnVCO0FBb0JyQ00sbUJBQWFOLDRCQUE0QixLQUE1QixFQUFtQyxLQUFuQyxDQXBCd0I7O0FBc0JyQ3JILGdCQUFVLFNBQVNBLFFBQVQsQ0FBa0J1SCxPQUFsQixFQUEyQjtBQUNuQzFGLHlCQUFpQixJQUFqQjtBQUNBLFlBQUkwRixPQUFKLEVBQWE7QUFDWFAsMEJBQWdCLElBQWhCLEVBQXNCLEtBQUs5SyxjQUEzQixFQUEyQyxLQUFLMkMsV0FBaEQsRUFBNkQsS0FBSzNDLGNBQWxFLEVBQWtGLEtBQUsyQyxXQUF2RjtBQUNELFNBRkQsTUFFTztBQUNMbUksMEJBQWdCLElBQWhCLEVBQXNCLEtBQUs3SyxZQUEzQixFQUF5QyxLQUFLMkMsU0FBOUMsRUFBeUQsS0FBSzNDLFlBQTlELEVBQTRFLEtBQUsyQyxTQUFqRjtBQUNEO0FBQ0YsT0E3Qm9DOztBQStCckM4SSwwQkFBb0IsU0FBU0Esa0JBQVQsQ0FBNEJuUixJQUE1QixFQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTJLLDBCQUFrQixJQUFsQjtBQUNBRiw4Q0FBc0N6SyxJQUF0QyxFQUE0QyxJQUE1Qzs7QUFFQXVRLHdCQUFnQixJQUFoQixFQUFzQnZRLElBQXRCLEVBQTRCLENBQTVCLEVBQStCQSxJQUEvQixFQUFxQ3pHLElBQUlrSCxhQUFKLENBQWtCVCxJQUFsQixDQUFyQztBQUNELE9BdkNvQzs7QUF5Q3JDc04sa0JBQVksU0FBU0EsVUFBVCxDQUFvQnROLElBQXBCLEVBQTBCO0FBQ3BDMkssMEJBQWtCLElBQWxCO0FBQ0FGLDhDQUFzQ3pLLElBQXRDLEVBQTRDLEtBQTVDO0FBQ0E0Syw0QkFBb0I1SyxJQUFwQixFQUEwQmdLLG9CQUExQjs7QUFFQSxZQUFJZCxRQUFRL0Msc0JBQXNCbkcsSUFBdEIsQ0FBWjtBQUFBLFlBQ0ltSixNQUFNL0MscUJBQXFCcEcsSUFBckIsQ0FEVjtBQUVBdVEsd0JBQWdCLElBQWhCLEVBQXNCckgsTUFBTWxKLElBQTVCLEVBQWtDa0osTUFBTTFFLE1BQXhDLEVBQWdEMkUsSUFBSW5KLElBQXBELEVBQTBEbUosSUFBSTNFLE1BQTlEO0FBQ0QsT0FqRG9DOztBQW1EckMySSx1QkFBaUJrRCwwQkFBMEIvSSxjQUExQixFQUEwQ2lKLGVBQTFDLENBbkRvQjs7QUFxRHJDYSxzQkFBZ0JmLDBCQUEwQmpKLGFBQTFCLEVBQXlDbUosZUFBekMsQ0FyRHFCOztBQXVEckN4RCwyQkFBcUIsU0FBU0EsbUJBQVQsR0FBK0I7QUFDbEQzQix5QkFBaUIsSUFBakI7QUFDQUosOEJBQXNCLEtBQUt2RixjQUEzQjtBQUNBdUYsOEJBQXNCLEtBQUt0RixZQUEzQjs7QUFFQTtBQUNBO0FBQ0EsWUFBSTFNLFdBQVcsSUFBSWdQLGFBQUosQ0FBa0IsSUFBbEIsRUFBd0IsSUFBeEIsQ0FBZjtBQUNBLFlBQUlnRixvQkFBb0JoVSxTQUFTOFAsTUFBVCxJQUFtQnRELDJCQUEyQnhNLFNBQVM4UCxNQUFwQyxFQUE0QyxJQUE1QyxDQUFuQixJQUF3RTlQLFNBQVMrUCxLQUFULElBQWtCdkQsMkJBQTJCeE0sU0FBUytQLEtBQXBDLEVBQTJDLElBQTNDLENBQWxIO0FBQ0EvUCxpQkFBU3lFLE1BQVQ7QUFDQSxlQUFPLENBQUN1UCxpQkFBUjtBQUNELE9BbEVvQzs7QUFvRXJDdlAsY0FBUSxTQUFTQSxNQUFULEdBQWtCO0FBQ3hCa1QsaUJBQVMsSUFBVDtBQUNELE9BdEVvQzs7QUF3RXJDVSx1QkFBaUIsU0FBU0EsZUFBVCxHQUEyQjtBQUMxQ2pHLHlCQUFpQixJQUFqQjs7QUFFQSxZQUFJNUMsS0FBSyxLQUFLL0MsY0FBZDtBQUFBLFlBQ0lnRCxLQUFLLEtBQUtMLFdBRGQ7QUFBQSxZQUVJTSxLQUFLLEtBQUtoRCxZQUZkO0FBQUEsWUFHSWlELEtBQUssS0FBS04sU0FIZDtBQUlBLFlBQUlpSixlQUFlOUksT0FBT0UsRUFBMUI7O0FBRUEsWUFBSW5QLElBQUlvSCxtQkFBSixDQUF3QitILEVBQXhCLEtBQStCQyxLQUFLLENBQXBDLElBQXlDQSxLQUFLRCxHQUFHbE4sTUFBckQsRUFBNkQ7QUFDM0RqQyxjQUFJcUksYUFBSixDQUFrQjhHLEVBQWxCLEVBQXNCQyxFQUF0QjtBQUNEOztBQUVELFlBQUlwUCxJQUFJb0gsbUJBQUosQ0FBd0I2SCxFQUF4QixLQUErQkMsS0FBSyxDQUFwQyxJQUF5Q0EsS0FBS0QsR0FBR2hOLE1BQXJELEVBQTZEOztBQUUzRGdOLGVBQUtqUCxJQUFJcUksYUFBSixDQUFrQjRHLEVBQWxCLEVBQXNCQyxFQUF0QixDQUFMO0FBQ0EsY0FBSTZJLFlBQUosRUFBa0I7QUFDaEIzSSxrQkFBTUYsRUFBTjtBQUNBQyxpQkFBS0YsRUFBTDtBQUNELFdBSEQsTUFHTyxJQUFJRSxNQUFNRixHQUFHbkksVUFBVCxJQUF1QnNJLE1BQU1wUCxJQUFJZ0gsWUFBSixDQUFpQmlJLEVBQWpCLENBQWpDLEVBQXVEO0FBQzVERztBQUNEO0FBQ0RGLGVBQUssQ0FBTDtBQUNEO0FBQ0Q4SCx3QkFBZ0IsSUFBaEIsRUFBc0IvSCxFQUF0QixFQUEwQkMsRUFBMUIsRUFBOEJDLEVBQTlCLEVBQWtDQyxFQUFsQztBQUNELE9BakdvQzs7QUFtR3JDNEksMkJBQXFCLFNBQVNBLG1CQUFULEdBQStCO0FBQ2xEbkcseUJBQWlCLElBQWpCOztBQUVBLFlBQUk1QyxLQUFLLEtBQUsvQyxjQUFkO0FBQUEsWUFDSWdELEtBQUssS0FBS0wsV0FEZDtBQUFBLFlBRUlNLEtBQUssS0FBS2hELFlBRmQ7QUFBQSxZQUdJaUQsS0FBSyxLQUFLTixTQUhkOztBQUtBLFlBQUltSixlQUFlLFNBQVNBLFlBQVQsQ0FBc0J4UixJQUF0QixFQUE0QjtBQUM3QyxjQUFJeVIsVUFBVXpSLEtBQUt5QixXQUFuQjtBQUNBLGNBQUlnUSxXQUFXQSxRQUFRblIsUUFBUixJQUFvQk4sS0FBS00sUUFBeEMsRUFBa0Q7QUFDaERvSSxpQkFBSzFJLElBQUw7QUFDQTJJLGlCQUFLM0ksS0FBS3hFLE1BQVY7QUFDQXdFLGlCQUFLMFIsVUFBTCxDQUFnQkQsUUFBUTVOLElBQXhCO0FBQ0E0TixvQkFBUXBSLFVBQVIsQ0FBbUIrSSxXQUFuQixDQUErQnFJLE9BQS9CO0FBQ0Q7QUFDRixTQVJEOztBQVVBLFlBQUlFLGdCQUFnQixTQUFTQSxhQUFULENBQXVCM1IsSUFBdkIsRUFBNkI7QUFDL0MsY0FBSXlSLFVBQVV6UixLQUFLUSxlQUFuQjtBQUNBLGNBQUlpUixXQUFXQSxRQUFRblIsUUFBUixJQUFvQk4sS0FBS00sUUFBeEMsRUFBa0Q7QUFDaERrSSxpQkFBS3hJLElBQUw7QUFDQSxnQkFBSTRSLGFBQWE1UixLQUFLeEUsTUFBdEI7QUFDQWlOLGlCQUFLZ0osUUFBUWpXLE1BQWI7QUFDQXdFLGlCQUFLNlIsVUFBTCxDQUFnQixDQUFoQixFQUFtQkosUUFBUTVOLElBQTNCO0FBQ0E0TixvQkFBUXBSLFVBQVIsQ0FBbUIrSSxXQUFuQixDQUErQnFJLE9BQS9CO0FBQ0EsZ0JBQUlqSixNQUFNRSxFQUFWLEVBQWM7QUFDWkMsb0JBQU1GLEVBQU47QUFDQUMsbUJBQUtGLEVBQUw7QUFDRCxhQUhELE1BR08sSUFBSUUsTUFBTTFJLEtBQUtLLFVBQWYsRUFBMkI7QUFDaEMsa0JBQUlxTixZQUFZblUsSUFBSWdILFlBQUosQ0FBaUJQLElBQWpCLENBQWhCO0FBQ0Esa0JBQUkySSxNQUFNK0UsU0FBVixFQUFxQjtBQUNuQmhGLHFCQUFLMUksSUFBTDtBQUNBMkkscUJBQUtpSixVQUFMO0FBQ0QsZUFIRCxNQUdPLElBQUlqSixLQUFLK0UsU0FBVCxFQUFvQjtBQUN6Qi9FO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsU0FyQkQ7O0FBdUJBLFlBQUltSixpQkFBaUIsSUFBckI7O0FBRUEsWUFBSXZZLElBQUlvSCxtQkFBSixDQUF3QitILEVBQXhCLENBQUosRUFBaUM7QUFDL0IsY0FBSUEsR0FBR2xOLE1BQUgsSUFBYW1OLEVBQWpCLEVBQXFCO0FBQ25CNkkseUJBQWE5SSxFQUFiO0FBQ0Q7QUFDRixTQUpELE1BSU87QUFDTCxjQUFJQyxLQUFLLENBQVQsRUFBWTtBQUNWLGdCQUFJb0osVUFBVXJKLEdBQUdoSSxVQUFILENBQWNpSSxLQUFLLENBQW5CLENBQWQ7QUFDQSxnQkFBSW9KLFdBQVd4WSxJQUFJb0gsbUJBQUosQ0FBd0JvUixPQUF4QixDQUFmLEVBQWlEO0FBQy9DUCwyQkFBYU8sT0FBYjtBQUNEO0FBQ0Y7QUFDREQsMkJBQWlCLENBQUMsS0FBS3ZKLFNBQXZCO0FBQ0Q7O0FBRUQsWUFBSXVKLGNBQUosRUFBb0I7QUFDbEIsY0FBSXZZLElBQUlvSCxtQkFBSixDQUF3QjZILEVBQXhCLENBQUosRUFBaUM7QUFDL0IsZ0JBQUlDLE1BQU0sQ0FBVixFQUFhO0FBQ1hrSiw0QkFBY25KLEVBQWQ7QUFDRDtBQUNGLFdBSkQsTUFJTztBQUNMLGdCQUFJQyxLQUFLRCxHQUFHOUgsVUFBSCxDQUFjbEYsTUFBdkIsRUFBK0I7QUFDN0Isa0JBQUl3VyxZQUFZeEosR0FBRzlILFVBQUgsQ0FBYytILEVBQWQsQ0FBaEI7QUFDQSxrQkFBSXVKLGFBQWF6WSxJQUFJb0gsbUJBQUosQ0FBd0JxUixTQUF4QixDQUFqQixFQUFxRDtBQUNuREwsOEJBQWNLLFNBQWQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRixTQWJELE1BYU87QUFDTHhKLGVBQUtFLEVBQUw7QUFDQUQsZUFBS0UsRUFBTDtBQUNEOztBQUVENEgsd0JBQWdCLElBQWhCLEVBQXNCL0gsRUFBdEIsRUFBMEJDLEVBQTFCLEVBQThCQyxFQUE5QixFQUFrQ0MsRUFBbEM7QUFDRCxPQS9Lb0M7O0FBaUxyQ3NKLHVCQUFpQixTQUFTQSxlQUFULENBQXlCalMsSUFBekIsRUFBK0J3RSxNQUEvQixFQUF1QztBQUN0RG1HLDBCQUFrQixJQUFsQjs7QUFFQUYsOENBQXNDekssSUFBdEMsRUFBNEMsSUFBNUM7QUFDQThLLDBCQUFrQjlLLElBQWxCLEVBQXdCd0UsTUFBeEI7O0FBRUF5TSw0QkFBb0IsSUFBcEIsRUFBMEJqUixJQUExQixFQUFnQ3dFLE1BQWhDO0FBQ0Q7QUF4TG9DLEtBQXZDOztBQTJMQTRMLDRCQUF3QmxYLFdBQXhCO0FBQ0Q7O0FBRUQ7O0FBRUE7QUFDQSxXQUFTZ1osZ0NBQVQsQ0FBMENyVyxLQUExQyxFQUFpRDtBQUMvQ0EsVUFBTTBNLFNBQU4sR0FBa0IxTSxNQUFNNEosY0FBTixLQUF5QjVKLE1BQU02SixZQUEvQixJQUErQzdKLE1BQU11TSxXQUFOLEtBQXNCdk0sTUFBTXdNLFNBQTdGO0FBQ0F4TSxVQUFNK00sdUJBQU4sR0FBZ0MvTSxNQUFNME0sU0FBTixHQUFrQjFNLE1BQU00SixjQUF4QixHQUF5Q2xNLElBQUlxSCxpQkFBSixDQUFzQi9FLE1BQU00SixjQUE1QixFQUE0QzVKLE1BQU02SixZQUFsRCxDQUF6RTtBQUNEOztBQUVELFdBQVMrRCxnQkFBVCxDQUEwQjVOLEtBQTFCLEVBQWlDNEosY0FBakMsRUFBaUQyQyxXQUFqRCxFQUE4RDFDLFlBQTlELEVBQTRFMkMsU0FBNUUsRUFBdUY7QUFDckYsUUFBSThKLGFBQWF0VyxNQUFNNEosY0FBTixLQUF5QkEsY0FBekIsSUFBMkM1SixNQUFNdU0sV0FBTixLQUFzQkEsV0FBbEY7QUFDQSxRQUFJZ0ssV0FBV3ZXLE1BQU02SixZQUFOLEtBQXVCQSxZQUF2QixJQUF1QzdKLE1BQU13TSxTQUFOLEtBQW9CQSxTQUExRTs7QUFFQXhNLFVBQU00SixjQUFOLEdBQXVCQSxjQUF2QjtBQUNBNUosVUFBTXVNLFdBQU4sR0FBb0JBLFdBQXBCO0FBQ0F2TSxVQUFNNkosWUFBTixHQUFxQkEsWUFBckI7QUFDQTdKLFVBQU13TSxTQUFOLEdBQWtCQSxTQUFsQjs7QUFFQTZKLHFDQUFpQ3JXLEtBQWpDO0FBQ0ErSixrQkFBYy9KLEtBQWQsRUFBcUIsZ0JBQXJCLEVBQXVDLEVBQUVzVyxZQUFZQSxVQUFkLEVBQTBCQyxVQUFVQSxRQUFwQyxFQUF2QztBQUNEOztBQUVELFdBQVMzVSxNQUFULENBQWdCNUIsS0FBaEIsRUFBdUI7QUFDckI4TyxzQkFBa0I5TyxLQUFsQjtBQUNBQSxVQUFNNEosY0FBTixHQUF1QjVKLE1BQU11TSxXQUFOLEdBQW9Cdk0sTUFBTTZKLFlBQU4sR0FBcUI3SixNQUFNd00sU0FBTixHQUFrQixJQUFsRjtBQUNBeE0sVUFBTTBNLFNBQU4sR0FBa0IxTSxNQUFNK00sdUJBQU4sR0FBZ0MsSUFBbEQ7QUFDQWhELGtCQUFjL0osS0FBZCxFQUFxQixRQUFyQixFQUErQixJQUEvQjtBQUNBQSxVQUFNbUssVUFBTixHQUFtQixJQUFuQjtBQUNEOztBQUVEOzs7QUFHQSxXQUFTd0QsS0FBVCxDQUFlcEgsR0FBZixFQUFvQjtBQUNsQixTQUFLcUQsY0FBTCxHQUFzQnJELEdBQXRCO0FBQ0EsU0FBS2dHLFdBQUwsR0FBbUIsQ0FBbkI7QUFDQSxTQUFLMUMsWUFBTCxHQUFvQnRELEdBQXBCO0FBQ0EsU0FBS2lHLFNBQUwsR0FBaUIsQ0FBakI7QUFDQSxTQUFLckMsVUFBTCxHQUFrQjtBQUNoQnFNLHNCQUFnQixFQURBO0FBRWhCNVUsY0FBUTtBQUZRLEtBQWxCO0FBSUF5VSxxQ0FBaUMsSUFBakM7QUFDRDs7QUFFRHhCLHVCQUFxQmxILEtBQXJCLEVBQTRCQyxnQkFBNUIsRUFBOENoTSxNQUE5Qzs7QUFFQTNCLE1BQUl3VyxjQUFKLEdBQXFCbEcsZUFBZWpULFNBQXBDOztBQUVBcVEsUUFBTW1DLGVBQU4sR0FBd0JBLGVBQXhCO0FBQ0FuQyxRQUFNeEIsYUFBTixHQUFzQkEsYUFBdEI7QUFDQXdCLFFBQU00Ryx1QkFBTixHQUFnQ0EsdUJBQWhDO0FBQ0E1RyxRQUFNa0gsb0JBQU4sR0FBNkJBLG9CQUE3QjtBQUNBbEgsUUFBTTdFLE9BQU4sR0FBZ0J1RCxRQUFoQjtBQUNBc0IsUUFBTTdELGdCQUFOLEdBQXlCQSxnQkFBekI7QUFDQTZELFFBQU1rRyxXQUFOLEdBQW9CLFVBQVU2QyxFQUFWLEVBQWNDLEVBQWQsRUFBa0I7QUFDcEMsV0FBT0QsR0FBRzlNLGNBQUgsS0FBc0IrTSxHQUFHL00sY0FBekIsSUFBMkM4TSxHQUFHbkssV0FBSCxLQUFtQm9LLEdBQUdwSyxXQUFqRSxJQUFnRm1LLEdBQUc3TSxZQUFILEtBQW9COE0sR0FBRzlNLFlBQXZHLElBQXVINk0sR0FBR2xLLFNBQUgsS0FBaUJtSyxHQUFHbkssU0FBbEo7QUFDRCxHQUZEOztBQUlBdk0sTUFBSTJXLFFBQUosR0FBZWpKLEtBQWY7QUFDQTFOLE1BQUk2TixjQUFKLEdBQXFCQSxjQUFyQjtBQUNELENBMXFDRSxFQTBxQ0FySyxNQUFNVixZQUFOLENBQW1CLGNBQW5CLEVBQW1DLFVBQVU5QyxHQUFWLEVBQWVnRCxNQUFmLEVBQXVCO0FBQzNEaEQsTUFBSWlELGNBQUosQ0FBbUIsQ0FBQyxTQUFELEVBQVksVUFBWixDQUFuQjs7QUFFQTs7O0FBR0EsTUFBSTJULFlBQUo7QUFDQSxNQUFJblosTUFBTXVDLElBQUl2QyxHQUFkO0FBQ0EsTUFBSWdMLGNBQWNoTCxJQUFJZ0wsV0FBdEI7QUFDQSxNQUFJa08sV0FBVzNXLElBQUkyVyxRQUFuQjs7QUFFQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxXQUFTRSw0QkFBVCxDQUFzQ0MsU0FBdEMsRUFBaUQ7QUFDL0MsUUFBSUMsV0FBV0QsVUFBVXpTLGFBQVYsRUFBZjs7QUFFQSxRQUFJdEUsUUFBUStXLFVBQVVFLFNBQVYsRUFBWjtBQUNBalgsVUFBTTBOLFFBQU4sQ0FBZSxJQUFmO0FBQ0EsUUFBSXdKLFVBQVVsWCxNQUFNc0UsYUFBTixFQUFkO0FBQ0F0RSxZQUFRK1csVUFBVUUsU0FBVixFQUFSO0FBQ0FqWCxVQUFNME4sUUFBTixDQUFlLEtBQWY7QUFDQSxRQUFJeUosUUFBUW5YLE1BQU1zRSxhQUFOLEVBQVo7QUFDQSxRQUFJOFMsb0JBQW9CRixXQUFXQyxLQUFYLEdBQW1CRCxPQUFuQixHQUE2QnhaLElBQUlxSCxpQkFBSixDQUFzQm1TLE9BQXRCLEVBQStCQyxLQUEvQixDQUFyRDs7QUFFQSxXQUFPQyxxQkFBcUJKLFFBQXJCLEdBQWdDSSxpQkFBaEMsR0FBb0QxWixJQUFJcUgsaUJBQUosQ0FBc0JpUyxRQUF0QixFQUFnQ0ksaUJBQWhDLENBQTNEO0FBQ0Q7O0FBRUQsV0FBU0Msb0JBQVQsQ0FBOEJOLFNBQTlCLEVBQXlDO0FBQ3ZDLFdBQU9BLFVBQVVPLGdCQUFWLENBQTJCLFlBQTNCLEVBQXlDUCxTQUF6QyxLQUF1RCxDQUE5RDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBU1EsNEJBQVQsQ0FBc0NSLFNBQXRDLEVBQWlEUywwQkFBakQsRUFBNkV2QyxPQUE3RSxFQUFzRndDLFdBQXRGLEVBQW1HO0FBQ2pHLFFBQUlDLGVBQWVYLFVBQVVFLFNBQVYsRUFBbkI7O0FBRUFTLGlCQUFhaEssUUFBYixDQUFzQnVILE9BQXRCO0FBQ0EsUUFBSTBDLG1CQUFtQkQsYUFBYXBULGFBQWIsRUFBdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBSSxDQUFDNUcsSUFBSTBILFlBQUosQ0FBaUJvUywwQkFBakIsRUFBNkNHLGdCQUE3QyxFQUErRCxJQUEvRCxDQUFMLEVBQTJFO0FBQ3pFQSx5QkFBbUJILDBCQUFuQjtBQUNEOztBQUVEO0FBQ0E7QUFDQSxRQUFJLENBQUNHLGlCQUFpQkMsV0FBdEIsRUFBbUM7QUFDakMsYUFBTyxJQUFJbFAsV0FBSixDQUFnQmlQLGlCQUFpQm5ULFVBQWpDLEVBQTZDOUcsSUFBSWdILFlBQUosQ0FBaUJpVCxnQkFBakIsQ0FBN0MsQ0FBUDtBQUNEOztBQUVELFFBQUlFLGNBQWNuYSxJQUFJMEksV0FBSixDQUFnQnVSLGdCQUFoQixFQUFrQy9ULGFBQWxDLENBQWdELE1BQWhELENBQWxCO0FBQ0EsUUFBSWtVLFVBQUo7QUFBQSxRQUNJQyx3QkFBd0I5QyxVQUFVLGNBQVYsR0FBMkIsWUFEdkQ7QUFFQSxRQUFJK0MsWUFBSixFQUFrQnJTLFFBQWxCLEVBQTRCc1MsZ0JBQTVCLEVBQThDQyxZQUE5Qzs7QUFFQTtBQUNBO0FBQ0EsT0FBRztBQUNEUCx1QkFBaUI5UixZQUFqQixDQUE4QmdTLFdBQTlCLEVBQTJDQSxZQUFZbFQsZUFBdkQ7QUFDQStTLG1CQUFhUyxpQkFBYixDQUErQk4sV0FBL0I7QUFDRCxLQUhELFFBR1MsQ0FBQ0MsYUFBYUosYUFBYUosZ0JBQWIsQ0FBOEJTLHFCQUE5QixFQUFxRGhCLFNBQXJELENBQWQsSUFBaUYsQ0FBakYsSUFBc0ZjLFlBQVlsVCxlQUgzRzs7QUFLQTtBQUNBO0FBQ0F1VCxtQkFBZUwsWUFBWWpTLFdBQTNCOztBQUVBLFFBQUlrUyxjQUFjLENBQUMsQ0FBZixJQUFvQkksWUFBcEIsSUFBb0N4YSxJQUFJb0gsbUJBQUosQ0FBd0JvVCxZQUF4QixDQUF4QyxFQUErRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQVIsbUJBQWFVLFdBQWIsQ0FBeUJuRCxVQUFVLFlBQVYsR0FBeUIsVUFBbEQsRUFBOEQ4QixTQUE5RDs7QUFFQSxVQUFJcE8sTUFBSjs7QUFFQSxVQUFJLFNBQVN5RCxJQUFULENBQWM4TCxhQUFhbFEsSUFBM0IsQ0FBSixFQUFzQztBQUNwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxZQUFJcVEsWUFBWVgsYUFBYVQsU0FBYixFQUFoQjtBQUNBLFlBQUlxQixjQUFjRCxVQUFVRSxJQUFWLENBQWVDLE9BQWYsQ0FBdUIsT0FBdkIsRUFBZ0MsSUFBaEMsRUFBc0M3WSxNQUF4RDs7QUFFQWdKLGlCQUFTMFAsVUFBVUksU0FBVixDQUFvQixXQUFwQixFQUFpQ0gsV0FBakMsQ0FBVDtBQUNBLGVBQU8sQ0FBQ1IsYUFBYU8sVUFBVWYsZ0JBQVYsQ0FBMkIsWUFBM0IsRUFBeUNlLFNBQXpDLENBQWQsS0FBc0UsQ0FBQyxDQUE5RSxFQUFpRjtBQUMvRTFQO0FBQ0EwUCxvQkFBVUksU0FBVixDQUFvQixXQUFwQixFQUFpQyxDQUFqQztBQUNEO0FBQ0YsT0FsQ0QsTUFrQ087QUFDTDlQLGlCQUFTK08sYUFBYWEsSUFBYixDQUFrQjVZLE1BQTNCO0FBQ0Q7QUFDRHNZLHlCQUFtQixJQUFJdlAsV0FBSixDQUFnQndQLFlBQWhCLEVBQThCdlAsTUFBOUIsQ0FBbkI7QUFDRCxLQTlDRCxNQThDTzs7QUFFTDtBQUNBO0FBQ0FxUCxxQkFBZSxDQUFDUCxlQUFlLENBQUN4QyxPQUFqQixLQUE2QjRDLFlBQVlsVCxlQUF4RDtBQUNBZ0IsaUJBQVcsQ0FBQzhSLGVBQWV4QyxPQUFoQixLQUE0QjRDLFlBQVlqUyxXQUFuRDs7QUFFQSxVQUFJRCxZQUFZakksSUFBSW9ILG1CQUFKLENBQXdCYSxRQUF4QixDQUFoQixFQUFtRDtBQUNqRHNTLDJCQUFtQixJQUFJdlAsV0FBSixDQUFnQi9DLFFBQWhCLEVBQTBCLENBQTFCLENBQW5CO0FBQ0QsT0FGRCxNQUVPLElBQUlxUyxnQkFBZ0J0YSxJQUFJb0gsbUJBQUosQ0FBd0JrVCxZQUF4QixDQUFwQixFQUEyRDtBQUNoRUMsMkJBQW1CLElBQUl2UCxXQUFKLENBQWdCc1AsWUFBaEIsRUFBOEJBLGFBQWFyWSxNQUEzQyxDQUFuQjtBQUNELE9BRk0sTUFFQTtBQUNMc1ksMkJBQW1CLElBQUl2UCxXQUFKLENBQWdCaVAsZ0JBQWhCLEVBQWtDamEsSUFBSWdILFlBQUosQ0FBaUJtVCxXQUFqQixDQUFsQyxDQUFuQjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQUEsZ0JBQVlyVCxVQUFaLENBQXVCK0ksV0FBdkIsQ0FBbUNzSyxXQUFuQzs7QUFFQSxXQUFPSSxnQkFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVNTLHVCQUFULENBQWlDVCxnQkFBakMsRUFBbURoRCxPQUFuRCxFQUE0RDtBQUMxRCxRQUFJaUQsWUFBSjtBQUFBLFFBQ0lTLGNBREo7QUFBQSxRQUVJQyxpQkFBaUJYLGlCQUFpQnRQLE1BRnRDO0FBR0EsUUFBSXBDLE1BQU03SSxJQUFJMEksV0FBSixDQUFnQjZSLGlCQUFpQjlULElBQWpDLENBQVY7QUFDQSxRQUFJMFQsV0FBSjtBQUFBLFFBQ0loVCxVQURKO0FBQUEsUUFFSTZTLGVBQWVuUixJQUFJMUUsSUFBSixDQUFTRSxlQUFULEVBRm5CO0FBR0EsUUFBSThXLGlCQUFpQm5iLElBQUlvSCxtQkFBSixDQUF3Qm1ULGlCQUFpQjlULElBQXpDLENBQXJCOztBQUVBLFFBQUkwVSxjQUFKLEVBQW9CO0FBQ2xCWCxxQkFBZUQsaUJBQWlCOVQsSUFBaEM7QUFDQXdVLHVCQUFpQlQsYUFBYTFULFVBQTlCO0FBQ0QsS0FIRCxNQUdPO0FBQ0xLLG1CQUFhb1QsaUJBQWlCOVQsSUFBakIsQ0FBc0JVLFVBQW5DO0FBQ0FxVCxxQkFBZVUsaUJBQWlCL1QsV0FBV2xGLE1BQTVCLEdBQXFDa0YsV0FBVytULGNBQVgsQ0FBckMsR0FBa0UsSUFBakY7QUFDQUQsdUJBQWlCVixpQkFBaUI5VCxJQUFsQztBQUNEOztBQUVEO0FBQ0EwVCxrQkFBY3RSLElBQUkzQyxhQUFKLENBQWtCLE1BQWxCLENBQWQ7O0FBRUE7QUFDQTtBQUNBaVUsZ0JBQVluSSxTQUFaLEdBQXdCLFNBQXhCOztBQUVBO0FBQ0E7QUFDQSxRQUFJd0ksWUFBSixFQUFrQjtBQUNoQlMscUJBQWU5UyxZQUFmLENBQTRCZ1MsV0FBNUIsRUFBeUNLLFlBQXpDO0FBQ0QsS0FGRCxNQUVPO0FBQ0xTLHFCQUFlN1MsV0FBZixDQUEyQitSLFdBQTNCO0FBQ0Q7O0FBRURILGlCQUFhUyxpQkFBYixDQUErQk4sV0FBL0I7QUFDQUgsaUJBQWFoSyxRQUFiLENBQXNCLENBQUN1SCxPQUF2Qjs7QUFFQTtBQUNBMEQsbUJBQWVwTCxXQUFmLENBQTJCc0ssV0FBM0I7O0FBRUE7QUFDQSxRQUFJZ0IsY0FBSixFQUFvQjtBQUNsQm5CLG1CQUFhekMsVUFBVSxXQUFWLEdBQXdCLFNBQXJDLEVBQWdELFdBQWhELEVBQTZEMkQsY0FBN0Q7QUFDRDs7QUFFRCxXQUFPbEIsWUFBUDtBQUNEOztBQUVEOztBQUVBLE1BQUl6WCxJQUFJSSxRQUFKLENBQWFtQixrQkFBYixLQUFvQyxDQUFDdkIsSUFBSUksUUFBSixDQUFhb0IsbUJBQWQsSUFBcUMsQ0FBQ3hCLElBQUlNLE1BQUosQ0FBV0UsZUFBckYsQ0FBSixFQUEyRztBQUN6RztBQUNBO0FBQ0E7O0FBRUEsS0FBQyxZQUFZO0FBQ1gsVUFBSXFZLFVBQUo7QUFDQSxVQUFJaEosa0JBQWtCOEcsU0FBUzlHLGVBQS9CO0FBQ0EsVUFBSWlKLHdCQUFKOztBQUVBLGVBQVNDLHFCQUFULENBQStCaFosS0FBL0IsRUFBc0M7QUFDcEMsWUFBSU4sSUFBSW9RLGdCQUFnQm5RLE1BQXhCO0FBQUEsWUFDSStSLElBREo7QUFFQSxlQUFPaFMsR0FBUCxFQUFZO0FBQ1ZnUyxpQkFBTzVCLGdCQUFnQnBRLENBQWhCLENBQVA7QUFDQU0sZ0JBQU0wUixJQUFOLElBQWMxUixNQUFNaVosV0FBTixDQUFrQnZILElBQWxCLENBQWQ7QUFDRDtBQUNGOztBQUVELGVBQVN3SCxpQkFBVCxDQUEyQmxaLEtBQTNCLEVBQWtDNEosY0FBbEMsRUFBa0QyQyxXQUFsRCxFQUErRDFDLFlBQS9ELEVBQTZFMkMsU0FBN0UsRUFBd0Y7QUFDdEYsWUFBSThKLGFBQWF0VyxNQUFNNEosY0FBTixLQUF5QkEsY0FBekIsSUFBMkM1SixNQUFNdU0sV0FBTixJQUFxQkEsV0FBakY7QUFDQSxZQUFJZ0ssV0FBV3ZXLE1BQU02SixZQUFOLEtBQXVCQSxZQUF2QixJQUF1QzdKLE1BQU13TSxTQUFOLElBQW1CQSxTQUF6RTs7QUFFQTtBQUNBLFlBQUk4SixjQUFjQyxRQUFsQixFQUE0QjtBQUMxQnZXLGdCQUFNMFMsTUFBTixDQUFhN0ksWUFBYixFQUEyQjJDLFNBQTNCO0FBQ0F4TSxnQkFBTXlTLFFBQU4sQ0FBZTdJLGNBQWYsRUFBK0IyQyxXQUEvQjtBQUNEO0FBQ0Y7O0FBRUQsZUFBUzNLLE1BQVQsQ0FBZ0I1QixLQUFoQixFQUF1QjtBQUNyQkEsY0FBTWlaLFdBQU4sQ0FBa0JyWCxNQUFsQjtBQUNBNUIsY0FBTW1aLFFBQU4sR0FBaUIsSUFBakI7QUFDQSxZQUFJelosSUFBSW9RLGdCQUFnQm5RLE1BQXhCO0FBQUEsWUFDSStSLElBREo7QUFFQSxlQUFPaFMsR0FBUCxFQUFZO0FBQ1ZnUyxpQkFBTzVCLGdCQUFnQnBRLENBQWhCLENBQVA7QUFDQU0sZ0JBQU0wUixJQUFOLElBQWMsSUFBZDtBQUNEO0FBQ0Y7O0FBRUQsVUFBSXFELDJCQUFKOztBQUVBOEIscUJBQWUsU0FBU0EsWUFBVCxDQUFzQjdXLEtBQXRCLEVBQTZCO0FBQzFDLFlBQUksQ0FBQ0EsS0FBTCxFQUFZO0FBQ1YsZ0JBQU0sSUFBSTZDLEtBQUosQ0FBVSx5QkFBVixDQUFOO0FBQ0Q7QUFDRCxhQUFLb1csV0FBTCxHQUFtQmpaLEtBQW5CO0FBQ0FnWiw4QkFBc0IsSUFBdEI7QUFDRCxPQU5EOztBQVFBcEMsZUFBUy9CLG9CQUFULENBQThCZ0MsWUFBOUIsRUFBNENxQyxpQkFBNUMsRUFBK0R0WCxNQUEvRDs7QUFFQWtYLG1CQUFhakMsYUFBYXZaLFNBQTFCOztBQUVBd2IsaUJBQVdySCxVQUFYLEdBQXdCLFVBQVV0TixJQUFWLEVBQWdCO0FBQ3RDLGFBQUs4VSxXQUFMLENBQWlCeEgsVUFBakIsQ0FBNEJ0TixJQUE1QjtBQUNBNlUsOEJBQXNCLElBQXRCO0FBQ0QsT0FIRDs7QUFLQUYsaUJBQVd2RCxjQUFYLEdBQTRCLFlBQVk7QUFDdEMsYUFBSzBELFdBQUwsQ0FBaUIxRCxjQUFqQjtBQUNBeUQsOEJBQXNCLElBQXRCO0FBQ0QsT0FIRDs7QUFLQUYsaUJBQVd4SCxlQUFYLEdBQTZCLFlBQVk7QUFDdkMsWUFBSTFHLE9BQU8sS0FBS3FPLFdBQUwsQ0FBaUIzSCxlQUFqQixFQUFYO0FBQ0EwSCw4QkFBc0IsSUFBdEI7QUFDQSxlQUFPcE8sSUFBUDtBQUNELE9BSkQ7O0FBTUFrTyxpQkFBVy9ILGFBQVgsR0FBMkIsWUFBWTtBQUNyQyxlQUFPLEtBQUtrSSxXQUFMLENBQWlCbEksYUFBakIsRUFBUDtBQUNELE9BRkQ7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BK0gsaUJBQVcxSCxnQkFBWCxHQUE4QixVQUFVak4sSUFBVixFQUFnQjtBQUM1QyxhQUFLOFUsV0FBTCxDQUFpQjdILGdCQUFqQixDQUFrQ2pOLElBQWxDO0FBQ0E2VSw4QkFBc0IsSUFBdEI7QUFDRCxPQUhEOztBQUtBRixpQkFBV3BMLFFBQVgsR0FBc0IsVUFBVXVILE9BQVYsRUFBbUI7QUFDdkMsYUFBS2dFLFdBQUwsQ0FBaUJ2TCxRQUFqQixDQUEwQnVILE9BQTFCO0FBQ0ErRCw4QkFBc0IsSUFBdEI7QUFDRCxPQUhEOztBQUtBRixpQkFBV3JMLFVBQVgsR0FBd0IsWUFBWTtBQUNsQyxlQUFPLElBQUlvSixZQUFKLENBQWlCLEtBQUtvQyxXQUFMLENBQWlCeEwsVUFBakIsRUFBakIsQ0FBUDtBQUNELE9BRkQ7O0FBSUFxTCxpQkFBV00sT0FBWCxHQUFxQixZQUFZO0FBQy9CSiw4QkFBc0IsSUFBdEI7QUFDRCxPQUZEOztBQUlBRixpQkFBV3BQLFFBQVgsR0FBc0IsWUFBWTtBQUNoQyxlQUFPLEtBQUt1UCxXQUFMLENBQWlCdlAsUUFBakIsRUFBUDtBQUNELE9BRkQ7O0FBSUE7O0FBRUEsVUFBSTJQLGVBQWUzWCxTQUFTb0MsY0FBVCxDQUF3QixNQUF4QixDQUFuQjtBQUNBcEcsVUFBSXFKLE9BQUosQ0FBWXJGLFFBQVosRUFBc0JvRSxXQUF0QixDQUFrQ3VULFlBQWxDO0FBQ0EsVUFBSXJaLFFBQVEwQixTQUFTQyxXQUFULEVBQVo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTNCLFlBQU15UyxRQUFOLENBQWU0RyxZQUFmLEVBQTZCLENBQTdCO0FBQ0FyWixZQUFNMFMsTUFBTixDQUFhMkcsWUFBYixFQUEyQixDQUEzQjs7QUFFQSxVQUFJO0FBQ0ZyWixjQUFNeVMsUUFBTixDQUFlNEcsWUFBZixFQUE2QixDQUE3QjtBQUNBTixtQ0FBMkIsSUFBM0I7O0FBRUFELG1CQUFXckcsUUFBWCxHQUFzQixVQUFVdE8sSUFBVixFQUFnQndFLE1BQWhCLEVBQXdCO0FBQzVDLGVBQUtzUSxXQUFMLENBQWlCeEcsUUFBakIsQ0FBMEJ0TyxJQUExQixFQUFnQ3dFLE1BQWhDO0FBQ0FxUSxnQ0FBc0IsSUFBdEI7QUFDRCxTQUhEOztBQUtBRixtQkFBV3BHLE1BQVgsR0FBb0IsVUFBVXZPLElBQVYsRUFBZ0J3RSxNQUFoQixFQUF3QjtBQUMxQyxlQUFLc1EsV0FBTCxDQUFpQnZHLE1BQWpCLENBQXdCdk8sSUFBeEIsRUFBOEJ3RSxNQUE5QjtBQUNBcVEsZ0NBQXNCLElBQXRCO0FBQ0QsU0FIRDs7QUFLQWpFLHNDQUE4QixTQUFTQSwyQkFBVCxDQUFxQ25TLElBQXJDLEVBQTJDO0FBQ3ZFLGlCQUFPLFVBQVV1QixJQUFWLEVBQWdCO0FBQ3JCLGlCQUFLOFUsV0FBTCxDQUFpQnJXLElBQWpCLEVBQXVCdUIsSUFBdkI7QUFDQTZVLGtDQUFzQixJQUF0QjtBQUNELFdBSEQ7QUFJRCxTQUxEO0FBTUQsT0FwQkQsQ0FvQkUsT0FBTzdXLEVBQVAsRUFBVzs7QUFFWDRXLG1DQUEyQixLQUEzQjs7QUFFQUQsbUJBQVdyRyxRQUFYLEdBQXNCLFVBQVV0TyxJQUFWLEVBQWdCd0UsTUFBaEIsRUFBd0I7QUFDNUMsY0FBSTtBQUNGLGlCQUFLc1EsV0FBTCxDQUFpQnhHLFFBQWpCLENBQTBCdE8sSUFBMUIsRUFBZ0N3RSxNQUFoQztBQUNELFdBRkQsQ0FFRSxPQUFPeEcsRUFBUCxFQUFXO0FBQ1gsaUJBQUs4VyxXQUFMLENBQWlCdkcsTUFBakIsQ0FBd0J2TyxJQUF4QixFQUE4QndFLE1BQTlCO0FBQ0EsaUJBQUtzUSxXQUFMLENBQWlCeEcsUUFBakIsQ0FBMEJ0TyxJQUExQixFQUFnQ3dFLE1BQWhDO0FBQ0Q7QUFDRHFRLGdDQUFzQixJQUF0QjtBQUNELFNBUkQ7O0FBVUFGLG1CQUFXcEcsTUFBWCxHQUFvQixVQUFVdk8sSUFBVixFQUFnQndFLE1BQWhCLEVBQXdCO0FBQzFDLGNBQUk7QUFDRixpQkFBS3NRLFdBQUwsQ0FBaUJ2RyxNQUFqQixDQUF3QnZPLElBQXhCLEVBQThCd0UsTUFBOUI7QUFDRCxXQUZELENBRUUsT0FBT3hHLEVBQVAsRUFBVztBQUNYLGlCQUFLOFcsV0FBTCxDQUFpQnhHLFFBQWpCLENBQTBCdE8sSUFBMUIsRUFBZ0N3RSxNQUFoQztBQUNBLGlCQUFLc1EsV0FBTCxDQUFpQnZHLE1BQWpCLENBQXdCdk8sSUFBeEIsRUFBOEJ3RSxNQUE5QjtBQUNEO0FBQ0RxUSxnQ0FBc0IsSUFBdEI7QUFDRCxTQVJEOztBQVVBakUsc0NBQThCLFNBQVNBLDJCQUFULENBQXFDblMsSUFBckMsRUFBMkMwVyxZQUEzQyxFQUF5RDtBQUNyRixpQkFBTyxVQUFVblYsSUFBVixFQUFnQjtBQUNyQixnQkFBSTtBQUNGLG1CQUFLOFUsV0FBTCxDQUFpQnJXLElBQWpCLEVBQXVCdUIsSUFBdkI7QUFDRCxhQUZELENBRUUsT0FBT2hDLEVBQVAsRUFBVztBQUNYLG1CQUFLOFcsV0FBTCxDQUFpQkssWUFBakIsRUFBK0JuVixJQUEvQjtBQUNBLG1CQUFLOFUsV0FBTCxDQUFpQnJXLElBQWpCLEVBQXVCdUIsSUFBdkI7QUFDRDtBQUNENlUsa0NBQXNCLElBQXRCO0FBQ0QsV0FSRDtBQVNELFNBVkQ7QUFXRDs7QUFFREYsaUJBQVdoSSxjQUFYLEdBQTRCaUUsNEJBQTRCLGdCQUE1QixFQUE4QyxjQUE5QyxDQUE1QjtBQUNBK0QsaUJBQVdsRixhQUFYLEdBQTJCbUIsNEJBQTRCLGVBQTVCLEVBQTZDLGFBQTdDLENBQTNCO0FBQ0ErRCxpQkFBV3BGLFlBQVgsR0FBMEJxQiw0QkFBNEIsY0FBNUIsRUFBNEMsZ0JBQTVDLENBQTFCO0FBQ0ErRCxpQkFBV3pELFdBQVgsR0FBeUJOLDRCQUE0QixhQUE1QixFQUEyQyxlQUEzQyxDQUF6Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EvVSxZQUFNc1Ysa0JBQU4sQ0FBeUIrRCxZQUF6QjtBQUNBLFVBQUlyWixNQUFNNEosY0FBTixJQUF3QnlQLFlBQXhCLElBQXdDclosTUFBTTZKLFlBQU4sSUFBc0J3UCxZQUE5RCxJQUE4RXJaLE1BQU11TSxXQUFOLElBQXFCLENBQW5HLElBQXdHdk0sTUFBTXdNLFNBQU4sSUFBbUI2TSxhQUFhMVosTUFBNUksRUFBb0o7QUFDbEptWixtQkFBV3hELGtCQUFYLEdBQWdDLFVBQVVuUixJQUFWLEVBQWdCO0FBQzlDLGVBQUs4VSxXQUFMLENBQWlCM0Qsa0JBQWpCLENBQW9DblIsSUFBcEM7QUFDQTZVLGdDQUFzQixJQUF0QjtBQUNELFNBSEQ7QUFJRCxPQUxELE1BS087QUFDTEYsbUJBQVd4RCxrQkFBWCxHQUFnQyxVQUFVblIsSUFBVixFQUFnQjtBQUM5QyxlQUFLc08sUUFBTCxDQUFjdE8sSUFBZCxFQUFvQixDQUFwQjtBQUNBLGVBQUt1TyxNQUFMLENBQVl2TyxJQUFaLEVBQWtCeVMsU0FBUzJDLFlBQVQsQ0FBc0JwVixJQUF0QixDQUFsQjtBQUNELFNBSEQ7QUFJRDs7QUFFRDs7QUFFQTtBQUNBOztBQUVBbkUsWUFBTXNWLGtCQUFOLENBQXlCK0QsWUFBekI7QUFDQXJaLFlBQU0wUyxNQUFOLENBQWEyRyxZQUFiLEVBQTJCLENBQTNCOztBQUVBLFVBQUlHLFNBQVM5WCxTQUFTQyxXQUFULEVBQWI7QUFDQTZYLGFBQU9sRSxrQkFBUCxDQUEwQitELFlBQTFCO0FBQ0FHLGFBQU85RyxNQUFQLENBQWMyRyxZQUFkLEVBQTRCLENBQTVCO0FBQ0FHLGFBQU8vRyxRQUFQLENBQWdCNEcsWUFBaEIsRUFBOEIsQ0FBOUI7O0FBRUEsVUFBSXJaLE1BQU15USxxQkFBTixDQUE0QnpRLE1BQU1nVSxZQUFsQyxFQUFnRHdGLE1BQWhELEtBQTJELENBQUMsQ0FBNUQsR0FBZ0V4WixNQUFNeVEscUJBQU4sQ0FBNEJ6USxNQUFNa1UsWUFBbEMsRUFBZ0RzRixNQUFoRCxLQUEyRCxDQUEvSCxFQUFrSTtBQUNoSTs7O0FBR0FWLG1CQUFXckkscUJBQVgsR0FBbUMsVUFBVXpHLElBQVYsRUFBZ0JoSyxLQUFoQixFQUF1QjtBQUN4REEsa0JBQVFBLE1BQU1pWixXQUFOLElBQXFCalosS0FBN0I7QUFDQSxjQUFJZ0ssUUFBUWhLLE1BQU1nVSxZQUFsQixFQUFnQztBQUM5QmhLLG1CQUFPaEssTUFBTWtVLFlBQWI7QUFDRCxXQUZELE1BRU8sSUFBSWxLLFFBQVFoSyxNQUFNa1UsWUFBbEIsRUFBZ0M7QUFDckNsSyxtQkFBT2hLLE1BQU1nVSxZQUFiO0FBQ0Q7QUFDRCxpQkFBTyxLQUFLaUYsV0FBTCxDQUFpQnhJLHFCQUFqQixDQUF1Q3pHLElBQXZDLEVBQTZDaEssS0FBN0MsQ0FBUDtBQUNELFNBUkQ7QUFTRCxPQWJELE1BYU87QUFDTDhZLG1CQUFXckkscUJBQVgsR0FBbUMsVUFBVXpHLElBQVYsRUFBZ0JoSyxLQUFoQixFQUF1QjtBQUN4RCxpQkFBTyxLQUFLaVosV0FBTCxDQUFpQnhJLHFCQUFqQixDQUF1Q3pHLElBQXZDLEVBQTZDaEssTUFBTWlaLFdBQU4sSUFBcUJqWixLQUFsRSxDQUFQO0FBQ0QsU0FGRDtBQUdEOztBQUVEOztBQUVBO0FBQ0EsVUFBSUMsSUFBSUcsSUFBSixDQUFTbkIsWUFBVCxDQUFzQmUsS0FBdEIsRUFBNkIsMEJBQTdCLENBQUosRUFBOEQ7QUFDNUQ4WSxtQkFBV25KLHdCQUFYLEdBQXNDLFVBQVVDLFdBQVYsRUFBdUI7QUFDM0QsaUJBQU8sS0FBS3FKLFdBQUwsQ0FBaUJ0Six3QkFBakIsQ0FBMENDLFdBQTFDLENBQVA7QUFDRCxTQUZEO0FBR0Q7O0FBRUQ7O0FBRUE7QUFDQWxTLFVBQUlxSixPQUFKLENBQVlyRixRQUFaLEVBQXNCNkwsV0FBdEIsQ0FBa0M4TCxZQUFsQztBQUNBclosWUFBTTRCLE1BQU47QUFDQTRYLGFBQU81WCxNQUFQO0FBQ0QsS0FuUEQ7O0FBcVBBM0IsUUFBSXdaLGlCQUFKLEdBQXdCLFVBQVVsVCxHQUFWLEVBQWU7QUFDckNBLFlBQU1BLE9BQU83RSxRQUFiO0FBQ0EsYUFBTzZFLElBQUk1RSxXQUFKLEVBQVA7QUFDRCxLQUhEO0FBSUQsR0E5UEQsTUE4UE8sSUFBSTFCLElBQUlJLFFBQUosQ0FBYW9CLG1CQUFqQixFQUFzQztBQUMzQztBQUNBOztBQUVBb1YsbUJBQWUsU0FBU0EsWUFBVCxDQUFzQkUsU0FBdEIsRUFBaUM7QUFDOUMsV0FBS0EsU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxXQUFLcUMsT0FBTDtBQUNELEtBSEQ7O0FBS0F2QyxpQkFBYXZaLFNBQWIsR0FBeUIsSUFBSXNaLFFBQUosQ0FBYWxWLFFBQWIsQ0FBekI7O0FBRUFtVixpQkFBYXZaLFNBQWIsQ0FBdUI4YixPQUF2QixHQUFpQyxZQUFZO0FBQzNDLFVBQUkvTCxLQUFKLEVBQVdDLEdBQVg7O0FBRUE7QUFDQSxVQUFJb00sd0JBQXdCNUMsNkJBQTZCLEtBQUtDLFNBQWxDLENBQTVCOztBQUVBLFVBQUlNLHFCQUFxQixLQUFLTixTQUExQixDQUFKLEVBQTBDO0FBQ3hDekosY0FBTUQsUUFBUWtLLDZCQUE2QixLQUFLUixTQUFsQyxFQUE2QzJDLHFCQUE3QyxFQUFvRSxJQUFwRSxFQUEwRSxJQUExRSxDQUFkO0FBQ0QsT0FGRCxNQUVPOztBQUVMck0sZ0JBQVFrSyw2QkFBNkIsS0FBS1IsU0FBbEMsRUFBNkMyQyxxQkFBN0MsRUFBb0UsSUFBcEUsRUFBMEUsS0FBMUUsQ0FBUjtBQUNBcE0sY0FBTWlLLDZCQUE2QixLQUFLUixTQUFsQyxFQUE2QzJDLHFCQUE3QyxFQUFvRSxLQUFwRSxFQUEyRSxLQUEzRSxDQUFOO0FBQ0Q7O0FBRUQsV0FBS2pILFFBQUwsQ0FBY3BGLE1BQU1sSixJQUFwQixFQUEwQmtKLE1BQU0xRSxNQUFoQztBQUNBLFdBQUsrSixNQUFMLENBQVlwRixJQUFJbkosSUFBaEIsRUFBc0JtSixJQUFJM0UsTUFBMUI7QUFDRCxLQWhCRDs7QUFrQkFpTyxhQUFTckMsdUJBQVQsQ0FBaUNzQyxZQUFqQzs7QUFFQTtBQUNBLFFBQUk4QyxZQUFZLFlBQVk7QUFDMUIsYUFBTyxJQUFQO0FBQ0QsS0FGZSxFQUFoQjtBQUdBLFFBQUksT0FBT0EsVUFBVWhNLEtBQWpCLElBQTBCLFdBQTlCLEVBQTJDO0FBQ3pDZ00sZ0JBQVVoTSxLQUFWLEdBQWtCa0osWUFBbEI7QUFDRDs7QUFFRDVXLFFBQUl3WixpQkFBSixHQUF3QixVQUFVbFQsR0FBVixFQUFlO0FBQ3JDQSxZQUFNQSxPQUFPN0UsUUFBYjtBQUNBLGFBQU82RSxJQUFJMUUsSUFBSixDQUFTRSxlQUFULEVBQVA7QUFDRCxLQUhEO0FBSUQ7O0FBRUQsTUFBSTlCLElBQUlJLFFBQUosQ0FBYW9CLG1CQUFqQixFQUFzQztBQUNwQ29WLGlCQUFhK0MsZ0JBQWIsR0FBZ0MsVUFBVTVaLEtBQVYsRUFBaUI7QUFDL0MsVUFBSUEsTUFBTTBNLFNBQVYsRUFBcUI7QUFDbkIsWUFBSW1OLEtBQUtuQix3QkFBd0IsSUFBSWhRLFdBQUosQ0FBZ0IxSSxNQUFNNEosY0FBdEIsRUFBc0M1SixNQUFNdU0sV0FBNUMsQ0FBeEIsRUFBa0YsSUFBbEYsQ0FBVDs7QUFFQSxlQUFPc04sRUFBUDs7QUFFQTtBQUNELE9BTkQsTUFNTztBQUNMLFlBQUlDLGFBQWFwQix3QkFBd0IsSUFBSWhRLFdBQUosQ0FBZ0IxSSxNQUFNNEosY0FBdEIsRUFBc0M1SixNQUFNdU0sV0FBNUMsQ0FBeEIsRUFBa0YsSUFBbEYsQ0FBakI7QUFDQSxZQUFJd04sV0FBV3JCLHdCQUF3QixJQUFJaFEsV0FBSixDQUFnQjFJLE1BQU02SixZQUF0QixFQUFvQzdKLE1BQU13TSxTQUExQyxDQUF4QixFQUE4RSxLQUE5RSxDQUFmO0FBQ0EsWUFBSXVLLFlBQVlyWixJQUFJMEksV0FBSixDQUFnQnBHLE1BQU00SixjQUF0QixFQUFzQy9ILElBQXRDLENBQTJDRSxlQUEzQyxFQUFoQjtBQUNBZ1Ysa0JBQVVxQixXQUFWLENBQXNCLGNBQXRCLEVBQXNDMEIsVUFBdEM7QUFDQS9DLGtCQUFVcUIsV0FBVixDQUFzQixVQUF0QixFQUFrQzJCLFFBQWxDO0FBQ0EsZUFBT2hELFNBQVA7QUFDRDtBQUNGLEtBZkQ7QUFnQkQ7O0FBRURGLGVBQWF2WixTQUFiLENBQXVCZ1AsT0FBdkIsR0FBaUMsWUFBWTtBQUMzQyxXQUFPLGNBQVA7QUFDRCxHQUZEOztBQUlBck0sTUFBSTRXLFlBQUosR0FBbUJBLFlBQW5COztBQUVBNVcsTUFBSTBCLFdBQUosR0FBa0IsVUFBVTRFLEdBQVYsRUFBZTtBQUMvQkEsVUFBTUEsT0FBTzdFLFFBQWI7QUFDQSxXQUFPLElBQUltVixZQUFKLENBQWlCNVcsSUFBSXdaLGlCQUFKLENBQXNCbFQsR0FBdEIsQ0FBakIsQ0FBUDtBQUNELEdBSEQ7O0FBS0F0RyxNQUFJK1osZ0JBQUosR0FBdUIsVUFBVXpULEdBQVYsRUFBZTtBQUNwQ0EsVUFBTUEsT0FBTzdFLFFBQWI7QUFDQSxXQUFPLElBQUlrVixRQUFKLENBQWFyUSxHQUFiLENBQVA7QUFDRCxHQUhEOztBQUtBdEcsTUFBSWdhLGlCQUFKLEdBQXdCLFVBQVV0VCxRQUFWLEVBQW9CO0FBQzFDLFdBQU8xRyxJQUFJMEIsV0FBSixDQUFnQmpFLElBQUlnSixpQkFBSixDQUFzQkMsUUFBdEIsQ0FBaEIsQ0FBUDtBQUNELEdBRkQ7O0FBSUExRyxNQUFJaWEsc0JBQUosR0FBNkIsVUFBVXZULFFBQVYsRUFBb0I7QUFDL0MsV0FBTzFHLElBQUkrWixnQkFBSixDQUFxQnRjLElBQUlnSixpQkFBSixDQUFzQkMsUUFBdEIsQ0FBckIsQ0FBUDtBQUNELEdBRkQ7O0FBSUExRyxNQUFJdUMsaUNBQUosQ0FBc0MsVUFBVUUsR0FBVixFQUFlO0FBQ25ELFFBQUk2RCxNQUFNN0QsSUFBSWhCLFFBQWQ7QUFDQSxRQUFJLE9BQU82RSxJQUFJNUUsV0FBWCxJQUEwQixXQUE5QixFQUEyQztBQUN6QzRFLFVBQUk1RSxXQUFKLEdBQWtCLFlBQVk7QUFDNUIsZUFBTzFCLElBQUkwQixXQUFKLENBQWdCLElBQWhCLENBQVA7QUFDRCxPQUZEO0FBR0Q7QUFDRDRFLFVBQU03RCxNQUFNLElBQVo7QUFDRCxHQVJEO0FBU0QsQ0F6aUJFLEVBeWlCQWUsTUFBTVYsWUFBTixDQUFtQixrQkFBbkIsRUFBdUMsVUFBVTlDLEdBQVYsRUFBZWdELE1BQWYsRUFBdUI7QUFDL0Q7QUFDQTs7QUFFQWhELE1BQUlpRCxjQUFKLENBQW1CLENBQUMsU0FBRCxFQUFZLFVBQVosRUFBd0IsY0FBeEIsQ0FBbkI7O0FBRUFqRCxNQUFJTSxNQUFKLENBQVc0WixvQkFBWCxHQUFrQyxJQUFsQzs7QUFFQSxNQUFJQyxVQUFVLFNBQWQ7QUFBQSxNQUNJQyxxQkFBcUIsaUJBRHpCO0FBQUEsTUFFSTNjLE1BQU11QyxJQUFJdkMsR0FGZDtBQUFBLE1BR0kwQyxPQUFPSCxJQUFJRyxJQUhmO0FBQUEsTUFJSXdXLFdBQVczVyxJQUFJMlcsUUFKbkI7QUFBQSxNQUtJQyxlQUFlNVcsSUFBSTRXLFlBTHZCO0FBQUEsTUFNSTlOLGVBQWU5SSxJQUFJOEksWUFOdkI7QUFBQSxNQU9JTCxjQUFjaEwsSUFBSWdMLFdBUHRCO0FBQUEsTUFRSTRSLFlBUko7QUFBQSxNQVNJQyxvQkFUSjtBQUFBLE1BVUlDLFVBQVUsU0FWZDs7QUFZQSxXQUFTQyxlQUFULENBQXlCQyxRQUF6QixFQUFtQztBQUNqQyxXQUFPLENBQUNBLFlBQVlqYyxNQUFiLEVBQXFCNmIsWUFBckIsRUFBUDtBQUNEOztBQUVELFdBQVNLLGVBQVQsQ0FBeUJELFFBQXpCLEVBQW1DO0FBQ2pDLFdBQU8sQ0FBQ0EsWUFBWWpjLE1BQWIsRUFBcUJpRCxRQUFyQixDQUE4QjVELFNBQXJDO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLE1BQUk4Yyw0QkFBNEIzYSxJQUFJRyxJQUFKLENBQVNuQixZQUFULENBQXNCUixNQUF0QixFQUE4QixjQUE5QixDQUFoQztBQUFBLE1BQ0lvYyx5QkFBeUI1YSxJQUFJRyxJQUFKLENBQVNmLFlBQVQsQ0FBc0JxQyxRQUF0QixFQUFnQyxXQUFoQyxDQUQ3Qjs7QUFHQSxNQUFJb1osdUJBQXVCRCwyQkFBMkIsQ0FBQ0QseUJBQUQsSUFBOEIzYSxJQUFJTSxNQUFKLENBQVdFLGVBQXBFLENBQTNCOztBQUVBLE1BQUlxYSxvQkFBSixFQUEwQjtBQUN4QlIsbUJBQWVLLGVBQWY7QUFDQTFhLFFBQUk4YSxnQkFBSixHQUF1QixVQUFVTCxRQUFWLEVBQW9CO0FBQ3pDLFVBQUluVSxNQUFNLENBQUNtVSxZQUFZamMsTUFBYixFQUFxQmlELFFBQS9CO0FBQUEsVUFDSXNaLFlBQVl6VSxJQUFJekksU0FEcEI7O0FBR0E7QUFDQSxhQUFPa2QsVUFBVWhSLElBQVYsSUFBa0IsTUFBbEIsSUFBNEJ0TSxJQUFJMEksV0FBSixDQUFnQjRVLFVBQVVyWixXQUFWLEdBQXdCMkMsYUFBeEIsRUFBaEIsS0FBNERpQyxHQUEvRjtBQUNELEtBTkQ7QUFPRCxHQVRELE1BU08sSUFBSXFVLHlCQUFKLEVBQStCO0FBQ3BDTixtQkFBZUcsZUFBZjtBQUNBeGEsUUFBSThhLGdCQUFKLEdBQXVCLFlBQVk7QUFDakMsYUFBTyxJQUFQO0FBQ0QsS0FGRDtBQUdELEdBTE0sTUFLQTtBQUNMOVgsV0FBT3ZDLElBQVAsQ0FBWSwrREFBWjtBQUNEOztBQUVEVCxNQUFJZ2Isa0JBQUosR0FBeUJYLFlBQXpCOztBQUVBLE1BQUlZLGdCQUFnQlosY0FBcEI7QUFDQSxNQUFJL1ksWUFBWXRCLElBQUl3WixpQkFBSixDQUFzQi9YLFFBQXRCLENBQWhCO0FBQ0EsTUFBSUcsT0FBT25FLElBQUlxSixPQUFKLENBQVlyRixRQUFaLENBQVg7O0FBRUE7QUFDQSxNQUFJeVosNkJBQTZCL2EsS0FBS1AsY0FBTCxDQUFvQnFiLGFBQXBCLEVBQW1DLENBQUMsWUFBRCxFQUFlLFdBQWYsS0FBK0I5YSxLQUFLTixpQkFBTCxDQUF1Qm9iLGFBQXZCLEVBQXNDLENBQUMsY0FBRCxFQUFpQixhQUFqQixDQUF0QyxDQUFsRSxDQUFqQztBQUNBamIsTUFBSUksUUFBSixDQUFhOGEsMEJBQWIsR0FBMENBLDBCQUExQzs7QUFFQTtBQUNBLE1BQUlDLHFCQUFxQmhiLEtBQUtuQixZQUFMLENBQWtCaWMsYUFBbEIsRUFBaUMsUUFBakMsQ0FBekI7QUFDQWpiLE1BQUlJLFFBQUosQ0FBYSthLGtCQUFiLEdBQWtDQSxrQkFBbEM7O0FBRUE7QUFDQSxNQUFJQyx5QkFBeUIsT0FBT0gsY0FBY0ksVUFBckIsSUFBbUMsUUFBaEU7QUFDQXJiLE1BQUlJLFFBQUosQ0FBYWdiLHNCQUFiLEdBQXNDQSxzQkFBdEM7O0FBRUEsTUFBSUUsa0NBQWtDLEtBQXRDO0FBQ0EsTUFBSUMsMENBQTBDLElBQTlDOztBQUVBLE1BQUlwYixLQUFLUixjQUFMLENBQW9Cc2IsYUFBcEIsRUFBbUMsQ0FBQyxVQUFELEVBQWEsWUFBYixFQUEyQixpQkFBM0IsQ0FBbkMsS0FBcUYsT0FBT0EsY0FBY0ksVUFBckIsSUFBbUMsUUFBeEgsSUFBb0lyYixJQUFJSSxRQUFKLENBQWFtQixrQkFBckosRUFBeUs7O0FBRXZLLEtBQUMsWUFBWTtBQUNYLFVBQUlpYSxTQUFTL1osU0FBU2tDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBYjtBQUNBL0IsV0FBS2lFLFdBQUwsQ0FBaUIyVixNQUFqQjs7QUFFQSxVQUFJQyxZQUFZaGUsSUFBSWdKLGlCQUFKLENBQXNCK1UsTUFBdEIsQ0FBaEI7QUFDQUMsZ0JBQVVDLElBQVY7QUFDQUQsZ0JBQVVFLEtBQVYsQ0FBZ0IsMkNBQWhCO0FBQ0FGLGdCQUFVRyxLQUFWOztBQUVBLFVBQUlDLE1BQU1wZSxJQUFJb0osZUFBSixDQUFvQjJVLE1BQXBCLEVBQTRCbkIsWUFBNUIsRUFBVjtBQUNBLFVBQUl5QixRQUFRTCxVQUFVN0wsZUFBdEI7QUFDQSxVQUFJbU0sYUFBYUQsTUFBTXZLLFNBQXZCO0FBQUEsVUFDSTNOLFdBQVdtWSxXQUFXdFUsVUFEMUI7O0FBR0E7QUFDQSxVQUFJZ1AsS0FBS2dGLFVBQVUvWixXQUFWLEVBQVQ7QUFDQStVLFNBQUdqRSxRQUFILENBQVk1TyxRQUFaLEVBQXNCLENBQXRCO0FBQ0E2UyxTQUFHaEosUUFBSCxDQUFZLElBQVo7QUFDQW9PLFVBQUlHLFFBQUosQ0FBYXZGLEVBQWI7QUFDQThFLGdEQUEwQ00sSUFBSVIsVUFBSixJQUFrQixDQUE1RDtBQUNBUSxVQUFJSSxlQUFKOztBQUVBO0FBQ0EsVUFBSXZGLEtBQUtELEdBQUdqSixVQUFILEVBQVQ7QUFDQWlKLFNBQUdqRSxRQUFILENBQVk1TyxRQUFaLEVBQXNCLENBQXRCO0FBQ0E4UyxTQUFHakUsTUFBSCxDQUFVN08sUUFBVixFQUFvQixDQUFwQjtBQUNBaVksVUFBSUcsUUFBSixDQUFhdkYsRUFBYjtBQUNBb0YsVUFBSUcsUUFBSixDQUFhdEYsRUFBYjs7QUFFQTRFLHdDQUFrQ08sSUFBSVIsVUFBSixJQUFrQixDQUFwRDs7QUFFQTtBQUNBNUUsU0FBRzlVLE1BQUg7QUFDQStVLFNBQUcvVSxNQUFIOztBQUVBQyxXQUFLMEwsV0FBTCxDQUFpQmtPLE1BQWpCO0FBQ0QsS0FwQ0Q7QUFxQ0Q7O0FBRUR4YixNQUFJSSxRQUFKLENBQWFrYiwrQkFBYixHQUErQ0EsK0JBQS9DO0FBQ0F0YixNQUFJSSxRQUFKLENBQWFtYix1Q0FBYixHQUF1REEsdUNBQXZEOztBQUVBO0FBQ0EsTUFBSVcseUJBQXlCLEtBQTdCO0FBQUEsTUFDSUMsZ0JBREo7O0FBR0EsTUFBSXZhLFFBQVF6QixLQUFLbkIsWUFBTCxDQUFrQjRDLElBQWxCLEVBQXdCLG9CQUF4QixDQUFaLEVBQTJEO0FBQ3pEdWEsdUJBQW1CdmEsS0FBS3dhLGtCQUFMLEVBQW5CO0FBQ0EsUUFBSWpjLEtBQUtOLGlCQUFMLENBQXVCc2MsZ0JBQXZCLEVBQXlDLENBQUMsTUFBRCxFQUFTLEtBQVQsQ0FBekMsQ0FBSixFQUErRDtBQUM3REQsK0JBQXlCLElBQXpCO0FBQ0Q7QUFDRjtBQUNEbGMsTUFBSUksUUFBSixDQUFhOGIsc0JBQWIsR0FBc0NBLHNCQUF0Qzs7QUFFQTtBQUNBLE1BQUloQiwwQkFBSixFQUFnQztBQUM5QlosMkJBQXVCLFNBQVNBLG9CQUFULENBQThCdUIsR0FBOUIsRUFBbUM7QUFDeEQsYUFBT0EsSUFBSVEsVUFBSixLQUFtQlIsSUFBSVMsU0FBdkIsSUFBb0NULElBQUlVLFlBQUosS0FBcUJWLElBQUlXLFdBQXBFO0FBQ0QsS0FGRDtBQUdELEdBSkQsTUFJTztBQUNMbEMsMkJBQXVCLFNBQVNBLG9CQUFULENBQThCdUIsR0FBOUIsRUFBbUM7QUFDeEQsYUFBT0EsSUFBSVIsVUFBSixHQUFpQlEsSUFBSVksVUFBSixDQUFlWixJQUFJUixVQUFKLEdBQWlCLENBQWhDLEVBQW1DNU8sU0FBcEQsR0FBZ0UsS0FBdkU7QUFDRCxLQUZEO0FBR0Q7O0FBRUQsV0FBU2lRLDZCQUFULENBQXVDYixHQUF2QyxFQUE0QzliLEtBQTVDLEVBQW1ENGMsU0FBbkQsRUFBOEQ7QUFDNUQsUUFBSUMsZUFBZUQsWUFBWSxLQUFaLEdBQW9CLE9BQXZDO0FBQUEsUUFDSUUsY0FBY0YsWUFBWSxPQUFaLEdBQXNCLEtBRHhDO0FBRUFkLFFBQUlRLFVBQUosR0FBaUJ0YyxNQUFNNmMsZUFBZSxXQUFyQixDQUFqQjtBQUNBZixRQUFJVSxZQUFKLEdBQW1CeGMsTUFBTTZjLGVBQWUsUUFBckIsQ0FBbkI7QUFDQWYsUUFBSVMsU0FBSixHQUFnQnZjLE1BQU04YyxjQUFjLFdBQXBCLENBQWhCO0FBQ0FoQixRQUFJVyxXQUFKLEdBQWtCemMsTUFBTThjLGNBQWMsUUFBcEIsQ0FBbEI7QUFDRDs7QUFFRCxXQUFTQyx1Q0FBVCxDQUFpRGpCLEdBQWpELEVBQXNEO0FBQ3BELFFBQUlkLFlBQVljLElBQUlrQixlQUFwQjtBQUNBbEIsUUFBSVEsVUFBSixHQUFpQnRCLFVBQVVzQixVQUEzQjtBQUNBUixRQUFJVSxZQUFKLEdBQW1CeEIsVUFBVXdCLFlBQTdCO0FBQ0FWLFFBQUlTLFNBQUosR0FBZ0J2QixVQUFVdUIsU0FBMUI7QUFDQVQsUUFBSVcsV0FBSixHQUFrQnpCLFVBQVV5QixXQUE1QjtBQUNEOztBQUVELFdBQVNRLG9CQUFULENBQThCbkIsR0FBOUIsRUFBbUM7QUFDakNBLFFBQUlRLFVBQUosR0FBaUJSLElBQUlTLFNBQUosR0FBZ0IsSUFBakM7QUFDQVQsUUFBSVUsWUFBSixHQUFtQlYsSUFBSVcsV0FBSixHQUFrQixDQUFyQztBQUNBWCxRQUFJUixVQUFKLEdBQWlCLENBQWpCO0FBQ0FRLFFBQUlyRSxXQUFKLEdBQWtCLElBQWxCO0FBQ0FxRSxRQUFJb0IsT0FBSixDQUFZdmQsTUFBWixHQUFxQixDQUFyQjtBQUNEOztBQUVELFdBQVN3ZCxjQUFULENBQXdCbmQsS0FBeEIsRUFBK0I7QUFDN0IsUUFBSWlaLFdBQUo7QUFDQSxRQUFJalosaUJBQWlCNFcsUUFBckIsRUFBK0I7QUFDN0JxQyxvQkFBY2paLE1BQU1vZCxxQkFBcEI7QUFDQSxVQUFJLENBQUNuRSxXQUFMLEVBQWtCO0FBQ2hCQSxzQkFBY2haLElBQUl3WixpQkFBSixDQUFzQi9iLElBQUkwSSxXQUFKLENBQWdCcEcsTUFBTTRKLGNBQXRCLENBQXRCLENBQWQ7QUFDQXFQLG9CQUFZdkcsTUFBWixDQUFtQjFTLE1BQU02SixZQUF6QixFQUF1QzdKLE1BQU13TSxTQUE3QztBQUNBeU0sb0JBQVl4RyxRQUFaLENBQXFCelMsTUFBTTRKLGNBQTNCLEVBQTJDNUosTUFBTXVNLFdBQWpEO0FBQ0F2TSxjQUFNb2QscUJBQU4sR0FBOEJuRSxXQUE5QjtBQUNBalosY0FBTXdRLGNBQU4sQ0FBcUIsUUFBckIsRUFBK0IsWUFBWTs7QUFFekMsZUFBSzRNLHFCQUFMLEdBQTZCLElBQTdCO0FBQ0QsU0FIRDtBQUlEO0FBQ0YsS0FaRCxNQVlPLElBQUlwZCxpQkFBaUI2VyxZQUFyQixFQUFtQztBQUN4Q29DLG9CQUFjalosTUFBTWlaLFdBQXBCO0FBQ0QsS0FGTSxNQUVBLElBQUloWixJQUFJSSxRQUFKLENBQWFtQixrQkFBYixJQUFtQ3hCLGlCQUFpQnRDLElBQUk0SSxTQUFKLENBQWN0RyxNQUFNNEosY0FBcEIsRUFBb0MrRCxLQUE1RixFQUFtRztBQUN4R3NMLG9CQUFjalosS0FBZDtBQUNEO0FBQ0QsV0FBT2laLFdBQVA7QUFDRDs7QUFFRCxXQUFTb0UsMEJBQVQsQ0FBb0NDLFVBQXBDLEVBQWdEO0FBQzlDLFFBQUksQ0FBQ0EsV0FBVzNkLE1BQVosSUFBc0IyZCxXQUFXLENBQVgsRUFBYzdZLFFBQWQsSUFBMEIsQ0FBcEQsRUFBdUQ7QUFDckQsYUFBTyxLQUFQO0FBQ0Q7QUFDRCxTQUFLLElBQUkvRSxJQUFJLENBQVIsRUFBV3dDLE1BQU1vYixXQUFXM2QsTUFBakMsRUFBeUNELElBQUl3QyxHQUE3QyxFQUFrRCxFQUFFeEMsQ0FBcEQsRUFBdUQ7QUFDckQsVUFBSSxDQUFDaEMsSUFBSTBILFlBQUosQ0FBaUJrWSxXQUFXLENBQVgsQ0FBakIsRUFBZ0NBLFdBQVc1ZCxDQUFYLENBQWhDLENBQUwsRUFBcUQ7QUFDbkQsZUFBTyxLQUFQO0FBQ0Q7QUFDRjtBQUNELFdBQU8sSUFBUDtBQUNEOztBQUVELFdBQVM2ZCx5QkFBVCxDQUFtQ3ZkLEtBQW5DLEVBQTBDO0FBQ3hDLFFBQUlrTSxRQUFRbE0sTUFBTW9ULFFBQU4sRUFBWjtBQUNBLFFBQUksQ0FBQ2lLLDJCQUEyQm5SLEtBQTNCLENBQUwsRUFBd0M7QUFDdEMsWUFBTSxJQUFJckosS0FBSixDQUFVLHNDQUFzQzdDLE1BQU04SSxPQUFOLEVBQXRDLEdBQXdELHNDQUFsRSxDQUFOO0FBQ0Q7QUFDRCxXQUFPb0QsTUFBTSxDQUFOLENBQVA7QUFDRDs7QUFFRCxXQUFTbk0sV0FBVCxDQUFxQkMsS0FBckIsRUFBNEI7QUFDMUIsV0FBTyxDQUFDLENBQUNBLEtBQUYsSUFBVyxPQUFPQSxNQUFNdVksSUFBYixJQUFxQixXQUF2QztBQUNEOztBQUVELFdBQVNpRixtQkFBVCxDQUE2QjFCLEdBQTdCLEVBQWtDOWIsS0FBbEMsRUFBeUM7QUFDdkM7QUFDQSxRQUFJeWQsZUFBZSxJQUFJNUcsWUFBSixDQUFpQjdXLEtBQWpCLENBQW5CO0FBQ0E4YixRQUFJb0IsT0FBSixHQUFjLENBQUNPLFlBQUQsQ0FBZDs7QUFFQWQsa0NBQThCYixHQUE5QixFQUFtQzJCLFlBQW5DLEVBQWlELEtBQWpEO0FBQ0EzQixRQUFJUixVQUFKLEdBQWlCLENBQWpCO0FBQ0FRLFFBQUlyRSxXQUFKLEdBQWtCZ0csYUFBYS9RLFNBQS9CO0FBQ0Q7O0FBRUQsV0FBU2dSLHNCQUFULENBQWdDNUIsR0FBaEMsRUFBcUM7QUFDbkM7QUFDQUEsUUFBSW9CLE9BQUosQ0FBWXZkLE1BQVosR0FBcUIsQ0FBckI7QUFDQSxRQUFJbWMsSUFBSTZCLFlBQUosQ0FBaUIzVCxJQUFqQixJQUF5QixNQUE3QixFQUFxQztBQUNuQ2lULDJCQUFxQm5CLEdBQXJCO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsVUFBSThCLGVBQWU5QixJQUFJNkIsWUFBSixDQUFpQmhjLFdBQWpCLEVBQW5CO0FBQ0EsVUFBSTVCLFlBQVk2ZCxZQUFaLENBQUosRUFBK0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0FKLDRCQUFvQjFCLEdBQXBCLEVBQXlCOEIsWUFBekI7QUFDRCxPQUxELE1BS087QUFDTDlCLFlBQUlSLFVBQUosR0FBaUJzQyxhQUFhamUsTUFBOUI7QUFDQSxZQUFJSyxLQUFKO0FBQUEsWUFDSXVHLE1BQU03SSxJQUFJMEksV0FBSixDQUFnQndYLGFBQWFDLElBQWIsQ0FBa0IsQ0FBbEIsQ0FBaEIsQ0FEVjtBQUVBLGFBQUssSUFBSW5lLElBQUksQ0FBYixFQUFnQkEsSUFBSW9jLElBQUlSLFVBQXhCLEVBQW9DLEVBQUU1YixDQUF0QyxFQUF5QztBQUN2Q00sa0JBQVFDLElBQUkwQixXQUFKLENBQWdCNEUsR0FBaEIsQ0FBUjtBQUNBdkcsZ0JBQU15UixVQUFOLENBQWlCbU0sYUFBYUMsSUFBYixDQUFrQm5lLENBQWxCLENBQWpCO0FBQ0FvYyxjQUFJb0IsT0FBSixDQUFZNWEsSUFBWixDQUFpQnRDLEtBQWpCO0FBQ0Q7QUFDRDhiLFlBQUlyRSxXQUFKLEdBQWtCcUUsSUFBSVIsVUFBSixJQUFrQixDQUFsQixJQUF1QlEsSUFBSW9CLE9BQUosQ0FBWSxDQUFaLEVBQWV4USxTQUF4RDtBQUNBaVEsc0NBQThCYixHQUE5QixFQUFtQ0EsSUFBSW9CLE9BQUosQ0FBWXBCLElBQUlSLFVBQUosR0FBaUIsQ0FBN0IsQ0FBbkMsRUFBb0UsS0FBcEU7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsV0FBU3dDLDBCQUFULENBQW9DaEMsR0FBcEMsRUFBeUM5YixLQUF6QyxFQUFnRDtBQUM5QyxRQUFJNGQsZUFBZTlCLElBQUk2QixZQUFKLENBQWlCaGMsV0FBakIsRUFBbkI7QUFDQSxRQUFJb2MsZUFBZVIsMEJBQTBCdmQsS0FBMUIsQ0FBbkI7O0FBRUE7QUFDQTtBQUNBLFFBQUl1RyxNQUFNN0ksSUFBSTBJLFdBQUosQ0FBZ0J3WCxhQUFhQyxJQUFiLENBQWtCLENBQWxCLENBQWhCLENBQVY7QUFDQSxRQUFJRyxrQkFBa0J0Z0IsSUFBSXFKLE9BQUosQ0FBWVIsR0FBWixFQUFpQjhWLGtCQUFqQixFQUF0QjtBQUNBLFNBQUssSUFBSTNjLElBQUksQ0FBUixFQUFXd0MsTUFBTTBiLGFBQWFqZSxNQUFuQyxFQUEyQ0QsSUFBSXdDLEdBQS9DLEVBQW9ELEVBQUV4QyxDQUF0RCxFQUF5RDtBQUN2RHNlLHNCQUFnQkMsR0FBaEIsQ0FBb0JMLGFBQWFDLElBQWIsQ0FBa0JuZSxDQUFsQixDQUFwQjtBQUNEO0FBQ0QsUUFBSTtBQUNGc2Usc0JBQWdCQyxHQUFoQixDQUFvQkYsWUFBcEI7QUFDRCxLQUZELENBRUUsT0FBTzViLEVBQVAsRUFBVztBQUNYLFlBQU0sSUFBSVUsS0FBSixDQUFVLCtHQUFWLENBQU47QUFDRDtBQUNEbWIsb0JBQWdCRSxNQUFoQjs7QUFFQTtBQUNBUiwyQkFBdUI1QixHQUF2QjtBQUNEOztBQUVELE1BQUlxQyxtQkFBSjs7QUFFQSxNQUFJL2QsS0FBS25CLFlBQUwsQ0FBa0JpYyxhQUFsQixFQUFpQyxZQUFqQyxDQUFKLEVBQW9EO0FBQ2xEaUQsMEJBQXNCLFNBQVNBLG1CQUFULENBQTZCckMsR0FBN0IsRUFBa0M5VixLQUFsQyxFQUF5QztBQUM3RCxVQUFJO0FBQ0YsZUFBTzhWLElBQUlZLFVBQUosQ0FBZTFXLEtBQWYsQ0FBUDtBQUNELE9BRkQsQ0FFRSxPQUFPN0QsRUFBUCxFQUFXO0FBQ1gsZUFBTyxJQUFQO0FBQ0Q7QUFDRixLQU5EO0FBT0QsR0FSRCxNQVFPLElBQUlnWiwwQkFBSixFQUFnQztBQUNyQ2dELDBCQUFzQixTQUFTQSxtQkFBVCxDQUE2QnJDLEdBQTdCLEVBQWtDO0FBQ3RELFVBQUl2VixNQUFNN0ksSUFBSTBJLFdBQUosQ0FBZ0IwVixJQUFJUSxVQUFwQixDQUFWO0FBQ0EsVUFBSXRjLFFBQVFDLElBQUkwQixXQUFKLENBQWdCNEUsR0FBaEIsQ0FBWjtBQUNBdkcsWUFBTXlTLFFBQU4sQ0FBZXFKLElBQUlRLFVBQW5CLEVBQStCUixJQUFJVSxZQUFuQztBQUNBeGMsWUFBTTBTLE1BQU4sQ0FBYW9KLElBQUlTLFNBQWpCLEVBQTRCVCxJQUFJVyxXQUFoQzs7QUFFQTtBQUNBO0FBQ0EsVUFBSXpjLE1BQU0wTSxTQUFOLEtBQW9CLEtBQUsrSyxXQUE3QixFQUEwQztBQUN4Q3pYLGNBQU15UyxRQUFOLENBQWVxSixJQUFJUyxTQUFuQixFQUE4QlQsSUFBSVcsV0FBbEM7QUFDQXpjLGNBQU0wUyxNQUFOLENBQWFvSixJQUFJUSxVQUFqQixFQUE2QlIsSUFBSVUsWUFBakM7QUFDRDs7QUFFRCxhQUFPeGMsS0FBUDtBQUNELEtBZEQ7QUFlRDs7QUFFRDs7O0FBR0EsV0FBU29lLGdCQUFULENBQTBCdGdCLFNBQTFCLEVBQXFDNmYsWUFBckMsRUFBbURqYixHQUFuRCxFQUF3RDtBQUN0RCxTQUFLc2EsZUFBTCxHQUF1QmxmLFNBQXZCO0FBQ0EsU0FBSzZmLFlBQUwsR0FBb0JBLFlBQXBCO0FBQ0EsU0FBS1QsT0FBTCxHQUFlLEVBQWY7QUFDQSxTQUFLeGEsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsU0FBSzBXLE9BQUw7QUFDRDs7QUFFRG5aLE1BQUlxYSxZQUFKLEdBQW1CLFVBQVU1WCxHQUFWLEVBQWU7QUFDaENBLFVBQU1BLE9BQU9qRSxNQUFiO0FBQ0EsUUFBSXFkLE1BQU1wWixJQUFJMlgsa0JBQUosQ0FBVjtBQUNBLFFBQUlXLFlBQVlWLGFBQWE1WCxHQUFiLENBQWhCO0FBQUEsUUFDSTJiLFNBQVN4RCx5QkFBeUJGLGdCQUFnQmpZLEdBQWhCLENBQXpCLEdBQWdELElBRDdEO0FBRUEsUUFBSW9aLEdBQUosRUFBUztBQUNQQSxVQUFJa0IsZUFBSixHQUFzQmhDLFNBQXRCO0FBQ0FjLFVBQUk2QixZQUFKLEdBQW1CVSxNQUFuQjtBQUNBdkMsVUFBSTFDLE9BQUosQ0FBWTFXLEdBQVo7QUFDRCxLQUpELE1BSU87QUFDTG9aLFlBQU0sSUFBSXNDLGdCQUFKLENBQXFCcEQsU0FBckIsRUFBZ0NxRCxNQUFoQyxFQUF3QzNiLEdBQXhDLENBQU47QUFDQUEsVUFBSTJYLGtCQUFKLElBQTBCeUIsR0FBMUI7QUFDRDtBQUNELFdBQU9BLEdBQVA7QUFDRCxHQWREOztBQWdCQTdiLE1BQUlxZSxrQkFBSixHQUF5QixVQUFVM1gsUUFBVixFQUFvQjtBQUMzQyxXQUFPMUcsSUFBSXFhLFlBQUosQ0FBaUI1YyxJQUFJb0osZUFBSixDQUFvQkgsUUFBcEIsQ0FBakIsQ0FBUDtBQUNELEdBRkQ7O0FBSUEsTUFBSTRYLFdBQVdILGlCQUFpQjlnQixTQUFoQzs7QUFFQSxXQUFTa2hCLHNCQUFULENBQWdDMUMsR0FBaEMsRUFBcUMyQyxNQUFyQyxFQUE2QztBQUMzQztBQUNBLFFBQUlsWSxNQUFNN0ksSUFBSTBJLFdBQUosQ0FBZ0JxWSxPQUFPLENBQVAsRUFBVTdVLGNBQTFCLENBQVY7QUFDQSxRQUFJZ1UsZUFBZWxnQixJQUFJcUosT0FBSixDQUFZUixHQUFaLEVBQWlCOFYsa0JBQWpCLEVBQW5CO0FBQ0EsU0FBSyxJQUFJM2MsSUFBSSxDQUFSLEVBQVdpRSxFQUFoQixFQUFvQmpFLElBQUk0YixVQUF4QixFQUFvQyxFQUFFNWIsQ0FBdEMsRUFBeUM7QUFDdkNpRSxXQUFLNFosMEJBQTBCa0IsT0FBTy9lLENBQVAsQ0FBMUIsQ0FBTDtBQUNBLFVBQUk7QUFDRmtlLHFCQUFhSyxHQUFiLENBQWlCdGEsRUFBakI7QUFDRCxPQUZELENBRUUsT0FBT3hCLEVBQVAsRUFBVztBQUNYLGNBQU0sSUFBSVUsS0FBSixDQUFVLDRIQUFWLENBQU47QUFDRDtBQUNGO0FBQ0QrYSxpQkFBYU0sTUFBYjs7QUFFQTtBQUNBUiwyQkFBdUI1QixHQUF2QjtBQUNEOztBQUVEO0FBQ0EsTUFBSSxDQUFDaEIsb0JBQUQsSUFBeUJLLDBCQUF6QixJQUF1RC9hLEtBQUtSLGNBQUwsQ0FBb0JzYixhQUFwQixFQUFtQyxDQUFDLGlCQUFELEVBQW9CLFVBQXBCLENBQW5DLENBQTNELEVBQWdJO0FBQzlIcUQsYUFBU3JDLGVBQVQsR0FBMkIsWUFBWTtBQUNyQyxXQUFLYyxlQUFMLENBQXFCZCxlQUFyQjtBQUNBZSwyQkFBcUIsSUFBckI7QUFDRCxLQUhEOztBQUtBLFFBQUl5QixvQkFBb0IsU0FBU0EsaUJBQVQsQ0FBMkI1QyxHQUEzQixFQUFnQzliLEtBQWhDLEVBQXVDO0FBQzdELFVBQUl1RyxNQUFNcVEsU0FBUzlNLGdCQUFULENBQTBCOUosS0FBMUIsQ0FBVjtBQUNBLFVBQUkrWixXQUFXOVosSUFBSTBCLFdBQUosQ0FBZ0I0RSxHQUFoQixDQUFmO0FBQ0F3VCxlQUFTM0QsZUFBVCxDQUF5QnBXLE1BQU02SixZQUEvQixFQUE2QzdKLE1BQU13TSxTQUFuRDtBQUNBc1AsVUFBSWtCLGVBQUosQ0FBb0JmLFFBQXBCLENBQTZCa0IsZUFBZXBELFFBQWYsQ0FBN0I7QUFDQStCLFVBQUlrQixlQUFKLENBQW9CN2IsTUFBcEIsQ0FBMkJuQixNQUFNNEosY0FBakMsRUFBaUQ1SixNQUFNdU0sV0FBdkQ7QUFDQXVQLFVBQUkxQyxPQUFKO0FBQ0QsS0FQRDs7QUFTQSxRQUFJaUMsc0JBQUosRUFBNEI7QUFDMUJrRCxlQUFTdEMsUUFBVCxHQUFvQixVQUFVamMsS0FBVixFQUFpQjRjLFNBQWpCLEVBQTRCO0FBQzlDLFlBQUlULDBCQUEwQnRCLHNCQUExQixJQUFvRCxLQUFLOEMsWUFBTCxDQUFrQjNULElBQWxCLElBQTBCd1EsT0FBbEYsRUFBMkY7QUFDekZzRCxxQ0FBMkIsSUFBM0IsRUFBaUM5ZCxLQUFqQztBQUNELFNBRkQsTUFFTztBQUNMLGNBQUk0YyxhQUFheEIsa0JBQWpCLEVBQXFDO0FBQ25Dc0QsOEJBQWtCLElBQWxCLEVBQXdCMWUsS0FBeEI7QUFDRCxXQUZELE1BRU87QUFDTCxnQkFBSTJlLGtCQUFKO0FBQ0EsZ0JBQUlwRCwrQkFBSixFQUFxQztBQUNuQ29ELG1DQUFxQixLQUFLckQsVUFBMUI7QUFDRCxhQUZELE1BRU87QUFDTCxtQkFBS1ksZUFBTDtBQUNBeUMsbUNBQXFCLENBQXJCO0FBQ0Q7QUFDRCxpQkFBSzNCLGVBQUwsQ0FBcUJmLFFBQXJCLENBQThCa0IsZUFBZW5kLEtBQWYsQ0FBOUI7O0FBRUE7QUFDQSxpQkFBS3NiLFVBQUwsR0FBa0IsS0FBSzBCLGVBQUwsQ0FBcUIxQixVQUF2Qzs7QUFFQSxnQkFBSSxLQUFLQSxVQUFMLElBQW1CcUQscUJBQXFCLENBQTVDLEVBQStDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQSxrQkFBSTFlLElBQUlNLE1BQUosQ0FBVzRaLG9CQUFmLEVBQXFDO0FBQ25DLG9CQUFJbEIsY0FBY2tGLG9CQUFvQixLQUFLbkIsZUFBekIsRUFBMEMsS0FBSzFCLFVBQUwsR0FBa0IsQ0FBNUQsQ0FBbEI7QUFDQSxvQkFBSXJDLGVBQWUsQ0FBQ3JDLFNBQVMvQyxXQUFULENBQXFCb0YsV0FBckIsRUFBa0NqWixLQUFsQyxDQUFwQixFQUE4RDtBQUM1RDtBQUNBQSwwQkFBUSxJQUFJNlcsWUFBSixDQUFpQm9DLFdBQWpCLENBQVI7QUFDRDtBQUNGO0FBQ0QsbUJBQUtpRSxPQUFMLENBQWEsS0FBSzVCLFVBQUwsR0FBa0IsQ0FBL0IsSUFBb0N0YixLQUFwQztBQUNBMmMsNENBQThCLElBQTlCLEVBQW9DM2MsS0FBcEMsRUFBMkM0ZSxxQkFBcUIsS0FBSzVCLGVBQTFCLENBQTNDO0FBQ0EsbUJBQUt2RixXQUFMLEdBQW1COEMscUJBQXFCLElBQXJCLENBQW5CO0FBQ0QsYUFmRCxNQWVPO0FBQ0w7QUFDQSxtQkFBS25CLE9BQUw7QUFDRDtBQUNGO0FBQ0Y7QUFDRixPQXhDRDtBQXlDRCxLQTFDRCxNQTBDTztBQUNMbUYsZUFBU3RDLFFBQVQsR0FBb0IsVUFBVWpjLEtBQVYsRUFBaUI0YyxTQUFqQixFQUE0QjtBQUM5QyxZQUFJQSxhQUFheEIsa0JBQWpCLEVBQXFDO0FBQ25Dc0QsNEJBQWtCLElBQWxCLEVBQXdCMWUsS0FBeEI7QUFDRCxTQUZELE1BRU87QUFDTCxlQUFLZ2QsZUFBTCxDQUFxQmYsUUFBckIsQ0FBOEJrQixlQUFlbmQsS0FBZixDQUE5QjtBQUNBLGVBQUtvWixPQUFMO0FBQ0Q7QUFDRixPQVBEO0FBUUQ7O0FBRURtRixhQUFTTSxTQUFULEdBQXFCLFVBQVVKLE1BQVYsRUFBa0I7QUFDckMsVUFBSXRDLDBCQUEwQnNDLE9BQU85ZSxNQUFQLEdBQWdCLENBQTlDLEVBQWlEO0FBQy9DNmUsK0JBQXVCLElBQXZCLEVBQTZCQyxNQUE3QjtBQUNELE9BRkQsTUFFTztBQUNMLGFBQUt2QyxlQUFMO0FBQ0EsYUFBSyxJQUFJeGMsSUFBSSxDQUFSLEVBQVd3QyxNQUFNdWMsT0FBTzllLE1BQTdCLEVBQXFDRCxJQUFJd0MsR0FBekMsRUFBOEMsRUFBRXhDLENBQWhELEVBQW1EO0FBQ2pELGVBQUt1YyxRQUFMLENBQWN3QyxPQUFPL2UsQ0FBUCxDQUFkO0FBQ0Q7QUFDRjtBQUNGLEtBVEQ7QUFVRCxHQTlFRCxNQThFTyxJQUFJVSxLQUFLbkIsWUFBTCxDQUFrQmljLGFBQWxCLEVBQWlDLE9BQWpDLEtBQTZDOWEsS0FBS25CLFlBQUwsQ0FBa0JzQyxTQUFsQixFQUE2QixRQUE3QixDQUE3QyxJQUF1RjRhLHNCQUF2RixJQUFpSHJCLG9CQUFySCxFQUEySTs7QUFFaEp5RCxhQUFTckMsZUFBVCxHQUEyQixZQUFZO0FBQ3JDO0FBQ0EsVUFBSTtBQUNGLGFBQUt5QixZQUFMLENBQWtCbUIsS0FBbEI7O0FBRUE7QUFDQSxZQUFJLEtBQUtuQixZQUFMLENBQWtCM1QsSUFBbEIsSUFBMEIsTUFBOUIsRUFBc0M7QUFDcEM7QUFDQTtBQUNBLGNBQUl6RCxHQUFKO0FBQ0EsY0FBSSxLQUFLK1YsVUFBVCxFQUFxQjtBQUNuQi9WLGtCQUFNN0ksSUFBSTBJLFdBQUosQ0FBZ0IsS0FBS2tXLFVBQXJCLENBQU47QUFDRCxXQUZELE1BRU8sSUFBSSxLQUFLcUIsWUFBTCxDQUFrQjNULElBQWxCLElBQTBCd1EsT0FBOUIsRUFBdUM7QUFDNUMsZ0JBQUlvRCxlQUFlLEtBQUtELFlBQUwsQ0FBa0JoYyxXQUFsQixFQUFuQjtBQUNBLGdCQUFJaWMsYUFBYWplLE1BQWpCLEVBQXlCO0FBQ3ZCNEcsb0JBQU03SSxJQUFJMEksV0FBSixDQUFnQndYLGFBQWFDLElBQWIsQ0FBa0IsQ0FBbEIsQ0FBaEIsRUFBc0NoYyxJQUF0QyxDQUEyQ0UsZUFBM0MsRUFBTjtBQUNEO0FBQ0Y7QUFDRCxjQUFJd0UsR0FBSixFQUFTO0FBQ1AsZ0JBQUl3USxZQUFZeFEsSUFBSTFFLElBQUosQ0FBU0UsZUFBVCxFQUFoQjtBQUNBZ1Ysc0JBQVVtSCxNQUFWO0FBQ0EsaUJBQUtQLFlBQUwsQ0FBa0JtQixLQUFsQjtBQUNEO0FBQ0Y7QUFDRixPQXRCRCxDQXNCRSxPQUFPM2MsRUFBUCxFQUFXLENBQUU7QUFDZjhhLDJCQUFxQixJQUFyQjtBQUNELEtBMUJEOztBQTRCQXNCLGFBQVN0QyxRQUFULEdBQW9CLFVBQVVqYyxLQUFWLEVBQWlCO0FBQ25DLFVBQUksS0FBSzJkLFlBQUwsQ0FBa0IzVCxJQUFsQixJQUEwQndRLE9BQTlCLEVBQXVDO0FBQ3JDc0QsbUNBQTJCLElBQTNCLEVBQWlDOWQsS0FBakM7QUFDRCxPQUZELE1BRU87QUFDTDZXLHFCQUFhK0MsZ0JBQWIsQ0FBOEI1WixLQUE5QixFQUFxQ2tlLE1BQXJDO0FBQ0EsYUFBS2hCLE9BQUwsQ0FBYSxDQUFiLElBQWtCbGQsS0FBbEI7QUFDQSxhQUFLc2IsVUFBTCxHQUFrQixDQUFsQjtBQUNBLGFBQUs3RCxXQUFMLEdBQW1CLEtBQUt5RixPQUFMLENBQWEsQ0FBYixFQUFnQnhRLFNBQW5DO0FBQ0FpUSxzQ0FBOEIsSUFBOUIsRUFBb0MzYyxLQUFwQyxFQUEyQyxLQUEzQztBQUNEO0FBQ0YsS0FWRDs7QUFZQXVlLGFBQVNNLFNBQVQsR0FBcUIsVUFBVUosTUFBVixFQUFrQjtBQUNyQyxXQUFLdkMsZUFBTDtBQUNBLFVBQUlaLGFBQWFtRCxPQUFPOWUsTUFBeEI7QUFDQSxVQUFJMmIsYUFBYSxDQUFqQixFQUFvQjtBQUNsQmtELCtCQUF1QixJQUF2QixFQUE2QkMsTUFBN0I7QUFDRCxPQUZELE1BRU8sSUFBSW5ELFVBQUosRUFBZ0I7QUFDckIsYUFBS1csUUFBTCxDQUFjd0MsT0FBTyxDQUFQLENBQWQ7QUFDRDtBQUNGLEtBUkQ7QUFTRCxHQW5ETSxNQW1EQTtBQUNMeGIsV0FBT3ZDLElBQVAsQ0FBWSxzREFBWjtBQUNBLFdBQU8sS0FBUDtBQUNEOztBQUVENmQsV0FBUzdCLFVBQVQsR0FBc0IsVUFBVTFXLEtBQVYsRUFBaUI7QUFDckMsUUFBSUEsUUFBUSxDQUFSLElBQWFBLFNBQVMsS0FBS3NWLFVBQS9CLEVBQTJDO0FBQ3pDLFlBQU0sSUFBSXZTLFlBQUosQ0FBaUIsZ0JBQWpCLENBQU47QUFDRCxLQUZELE1BRU87QUFDTCxhQUFPLEtBQUttVSxPQUFMLENBQWFsWCxLQUFiLENBQVA7QUFDRDtBQUNGLEdBTkQ7O0FBUUEsTUFBSStZLGdCQUFKOztBQUVBLE1BQUlqRSxvQkFBSixFQUEwQjtBQUN4QmlFLHVCQUFtQixTQUFTQSxnQkFBVCxDQUEwQmpELEdBQTFCLEVBQStCO0FBQ2hELFVBQUk5YixLQUFKO0FBQ0EsVUFBSUMsSUFBSThhLGdCQUFKLENBQXFCZSxJQUFJcFosR0FBekIsQ0FBSixFQUFtQztBQUNqQzFDLGdCQUFROGIsSUFBSTZCLFlBQUosQ0FBaUJoYyxXQUFqQixFQUFSO0FBQ0QsT0FGRCxNQUVPO0FBQ0wzQixnQkFBUXRDLElBQUlxSixPQUFKLENBQVkrVSxJQUFJcFosR0FBSixDQUFRaEIsUUFBcEIsRUFBOEJLLGVBQTlCLEVBQVI7QUFDQS9CLGNBQU0wTixRQUFOLENBQWUsSUFBZjtBQUNEOztBQUVELFVBQUlvTyxJQUFJNkIsWUFBSixDQUFpQjNULElBQWpCLElBQXlCd1EsT0FBN0IsRUFBc0M7QUFDcENrRCwrQkFBdUI1QixHQUF2QjtBQUNELE9BRkQsTUFFTyxJQUFJL2IsWUFBWUMsS0FBWixDQUFKLEVBQXdCO0FBQzdCd2QsNEJBQW9CMUIsR0FBcEIsRUFBeUI5YixLQUF6QjtBQUNELE9BRk0sTUFFQTtBQUNMaWQsNkJBQXFCbkIsR0FBckI7QUFDRDtBQUNGLEtBaEJEO0FBaUJELEdBbEJELE1Ba0JPLElBQUkxYixLQUFLbkIsWUFBTCxDQUFrQmljLGFBQWxCLEVBQWlDLFlBQWpDLEtBQWtELE9BQU9BLGNBQWNJLFVBQXJCLElBQW1DLFFBQXpGLEVBQW1HO0FBQ3hHeUQsdUJBQW1CLFNBQVNBLGdCQUFULENBQTBCakQsR0FBMUIsRUFBK0I7QUFDaEQsVUFBSUssMEJBQTBCdEIsc0JBQTFCLElBQW9EaUIsSUFBSTZCLFlBQUosQ0FBaUIzVCxJQUFqQixJQUF5QndRLE9BQWpGLEVBQTBGO0FBQ3hGa0QsK0JBQXVCNUIsR0FBdkI7QUFDRCxPQUZELE1BRU87QUFDTEEsWUFBSW9CLE9BQUosQ0FBWXZkLE1BQVosR0FBcUJtYyxJQUFJUixVQUFKLEdBQWlCUSxJQUFJa0IsZUFBSixDQUFvQjFCLFVBQTFEO0FBQ0EsWUFBSVEsSUFBSVIsVUFBUixFQUFvQjtBQUNsQixlQUFLLElBQUk1YixJQUFJLENBQVIsRUFBV3dDLE1BQU00WixJQUFJUixVQUExQixFQUFzQzViLElBQUl3QyxHQUExQyxFQUErQyxFQUFFeEMsQ0FBakQsRUFBb0Q7QUFDbERvYyxnQkFBSW9CLE9BQUosQ0FBWXhkLENBQVosSUFBaUIsSUFBSU8sSUFBSTRXLFlBQVIsQ0FBcUJpRixJQUFJa0IsZUFBSixDQUFvQk4sVUFBcEIsQ0FBK0JoZCxDQUEvQixDQUFyQixDQUFqQjtBQUNEO0FBQ0RpZCx3Q0FBOEJiLEdBQTlCLEVBQW1DQSxJQUFJb0IsT0FBSixDQUFZcEIsSUFBSVIsVUFBSixHQUFpQixDQUE3QixDQUFuQyxFQUFvRXNELHFCQUFxQjlDLElBQUlrQixlQUF6QixDQUFwRTtBQUNBbEIsY0FBSXJFLFdBQUosR0FBa0I4QyxxQkFBcUJ1QixHQUFyQixDQUFsQjtBQUNELFNBTkQsTUFNTztBQUNMbUIsK0JBQXFCbkIsR0FBckI7QUFDRDtBQUNGO0FBQ0YsS0FmRDtBQWdCRCxHQWpCTSxNQWlCQSxJQUFJWCw4QkFBOEJsZSxRQUFRaWUsY0FBY3pELFdBQXRCLEtBQXNDMkMsT0FBcEUsSUFBK0VuZCxRQUFRc0UsVUFBVW1MLFNBQWxCLEtBQWdDME4sT0FBL0csSUFBMEhuYSxJQUFJSSxRQUFKLENBQWFtQixrQkFBM0ksRUFBK0o7QUFDcEt1ZCx1QkFBbUIsU0FBU0EsZ0JBQVQsQ0FBMEJqRCxHQUExQixFQUErQjtBQUNoRCxVQUFJOWIsS0FBSjtBQUFBLFVBQ0lnYixZQUFZYyxJQUFJa0IsZUFEcEI7QUFFQSxVQUFJaEMsVUFBVXNCLFVBQWQsRUFBMEI7QUFDeEJ0YyxnQkFBUW1lLG9CQUFvQm5ELFNBQXBCLEVBQStCLENBQS9CLENBQVI7QUFDQWMsWUFBSW9CLE9BQUosR0FBYyxDQUFDbGQsS0FBRCxDQUFkO0FBQ0E4YixZQUFJUixVQUFKLEdBQWlCLENBQWpCO0FBQ0F5QixnREFBd0NqQixHQUF4QztBQUNBQSxZQUFJckUsV0FBSixHQUFrQjhDLHFCQUFxQnVCLEdBQXJCLENBQWxCO0FBQ0QsT0FORCxNQU1PO0FBQ0xtQiw2QkFBcUJuQixHQUFyQjtBQUNEO0FBQ0YsS0FaRDtBQWFELEdBZE0sTUFjQTtBQUNMN1ksV0FBT3ZDLElBQVAsQ0FBWSxnRkFBWjtBQUNBLFdBQU8sS0FBUDtBQUNEOztBQUVENmQsV0FBU25GLE9BQVQsR0FBbUIsVUFBVTRGLGVBQVYsRUFBMkI7QUFDNUMsUUFBSUMsWUFBWUQsa0JBQWtCLEtBQUs5QixPQUFMLENBQWFqTSxLQUFiLENBQW1CLENBQW5CLENBQWxCLEdBQTBDLElBQTFEO0FBQ0E4TixxQkFBaUIsSUFBakI7QUFDQSxRQUFJQyxlQUFKLEVBQXFCO0FBQ25CLFVBQUl0ZixJQUFJdWYsVUFBVXRmLE1BQWxCO0FBQ0EsVUFBSUQsS0FBSyxLQUFLd2QsT0FBTCxDQUFhdmQsTUFBdEIsRUFBOEI7QUFDNUIsZUFBTyxLQUFQO0FBQ0Q7QUFDRCxhQUFPRCxHQUFQLEVBQVk7QUFDVixZQUFJLENBQUNrWCxTQUFTL0MsV0FBVCxDQUFxQm9MLFVBQVV2ZixDQUFWLENBQXJCLEVBQW1DLEtBQUt3ZCxPQUFMLENBQWF4ZCxDQUFiLENBQW5DLENBQUwsRUFBMEQ7QUFDeEQsaUJBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRCxhQUFPLElBQVA7QUFDRDtBQUNGLEdBZkQ7O0FBaUJBO0FBQ0EsTUFBSXdmLHNCQUFzQixTQUFTQSxtQkFBVCxDQUE2QnBELEdBQTdCLEVBQWtDOWIsS0FBbEMsRUFBeUM7QUFDakUsUUFBSXllLFNBQVMzQyxJQUFJcUQsWUFBSixFQUFiO0FBQUEsUUFDSUMsVUFBVSxLQURkO0FBRUF0RCxRQUFJSSxlQUFKO0FBQ0EsU0FBSyxJQUFJeGMsSUFBSSxDQUFSLEVBQVd3QyxNQUFNdWMsT0FBTzllLE1BQTdCLEVBQXFDRCxJQUFJd0MsR0FBekMsRUFBOEMsRUFBRXhDLENBQWhELEVBQW1EO0FBQ2pELFVBQUkwZixXQUFXcGYsVUFBVXllLE9BQU8vZSxDQUFQLENBQXpCLEVBQW9DO0FBQ2xDb2MsWUFBSUcsUUFBSixDQUFhd0MsT0FBTy9lLENBQVAsQ0FBYjtBQUNELE9BRkQsTUFFTztBQUNMO0FBQ0E7QUFDQTtBQUNBMGYsa0JBQVUsSUFBVjtBQUNEO0FBQ0Y7QUFDRCxRQUFJLENBQUN0RCxJQUFJUixVQUFULEVBQXFCO0FBQ25CMkIsMkJBQXFCbkIsR0FBckI7QUFDRDtBQUNGLEdBakJEOztBQW1CQSxNQUFJSyxzQkFBSixFQUE0QjtBQUMxQm9DLGFBQVNjLFdBQVQsR0FBdUIsVUFBVXJmLEtBQVYsRUFBaUI7QUFDdEMsVUFBSSxLQUFLMmQsWUFBTCxDQUFrQjNULElBQWxCLElBQTBCd1EsT0FBOUIsRUFBdUM7QUFDckMsWUFBSW9ELGVBQWUsS0FBS0QsWUFBTCxDQUFrQmhjLFdBQWxCLEVBQW5CO0FBQ0EsWUFBSW9jLGVBQWVSLDBCQUEwQnZkLEtBQTFCLENBQW5COztBQUVBO0FBQ0E7QUFDQSxZQUFJdUcsTUFBTTdJLElBQUkwSSxXQUFKLENBQWdCd1gsYUFBYUMsSUFBYixDQUFrQixDQUFsQixDQUFoQixDQUFWO0FBQ0EsWUFBSUcsa0JBQWtCdGdCLElBQUlxSixPQUFKLENBQVlSLEdBQVosRUFBaUI4VixrQkFBakIsRUFBdEI7QUFDQSxZQUFJMVksRUFBSjtBQUFBLFlBQ0l5YixVQUFVLEtBRGQ7QUFFQSxhQUFLLElBQUkxZixJQUFJLENBQVIsRUFBV3dDLE1BQU0wYixhQUFhamUsTUFBbkMsRUFBMkNELElBQUl3QyxHQUEvQyxFQUFvRCxFQUFFeEMsQ0FBdEQsRUFBeUQ7QUFDdkRpRSxlQUFLaWEsYUFBYUMsSUFBYixDQUFrQm5lLENBQWxCLENBQUw7QUFDQSxjQUFJaUUsT0FBT29hLFlBQVAsSUFBdUJxQixPQUEzQixFQUFvQztBQUNsQ3BCLDRCQUFnQkMsR0FBaEIsQ0FBb0JMLGFBQWFDLElBQWIsQ0FBa0JuZSxDQUFsQixDQUFwQjtBQUNELFdBRkQsTUFFTztBQUNMMGYsc0JBQVUsSUFBVjtBQUNEO0FBQ0Y7QUFDRHBCLHdCQUFnQkUsTUFBaEI7O0FBRUE7QUFDQVIsK0JBQXVCLElBQXZCO0FBQ0QsT0F0QkQsTUFzQk87QUFDTHdCLDRCQUFvQixJQUFwQixFQUEwQmxmLEtBQTFCO0FBQ0Q7QUFDRixLQTFCRDtBQTJCRCxHQTVCRCxNQTRCTztBQUNMdWUsYUFBU2MsV0FBVCxHQUF1QixVQUFVcmYsS0FBVixFQUFpQjtBQUN0Q2tmLDBCQUFvQixJQUFwQixFQUEwQmxmLEtBQTFCO0FBQ0QsS0FGRDtBQUdEOztBQUVEO0FBQ0EsTUFBSTRlLG9CQUFKO0FBQ0EsTUFBSSxDQUFDOUQsb0JBQUQsSUFBeUJLLDBCQUF6QixJQUF1RGxiLElBQUlJLFFBQUosQ0FBYW1CLGtCQUF4RSxFQUE0RjtBQUMxRm9kLDJCQUF1QixTQUFTQSxvQkFBVCxDQUE4QjlDLEdBQTlCLEVBQW1DO0FBQ3hELFVBQUljLFlBQVksS0FBaEI7QUFDQSxVQUFJZCxJQUFJUSxVQUFSLEVBQW9CO0FBQ2xCTSxvQkFBWWxmLElBQUl1SixhQUFKLENBQWtCNlUsSUFBSVEsVUFBdEIsRUFBa0NSLElBQUlVLFlBQXRDLEVBQW9EVixJQUFJUyxTQUF4RCxFQUFtRVQsSUFBSVcsV0FBdkUsS0FBdUYsQ0FBbkc7QUFDRDtBQUNELGFBQU9HLFNBQVA7QUFDRCxLQU5EOztBQVFBMkIsYUFBU2UsV0FBVCxHQUF1QixZQUFZO0FBQ2pDLGFBQU9WLHFCQUFxQixJQUFyQixDQUFQO0FBQ0QsS0FGRDtBQUdELEdBWkQsTUFZTztBQUNMQSwyQkFBdUJMLFNBQVNlLFdBQVQsR0FBdUIsWUFBWTtBQUN4RCxhQUFPLEtBQVA7QUFDRCxLQUZEO0FBR0Q7O0FBRUQ7QUFDQTtBQUNBZixXQUFTN1UsUUFBVCxHQUFvQixZQUFZOztBQUU5QixRQUFJNlYsYUFBYSxFQUFqQjtBQUNBLFNBQUssSUFBSTdmLElBQUksQ0FBUixFQUFXd0MsTUFBTSxLQUFLb1osVUFBM0IsRUFBdUM1YixJQUFJd0MsR0FBM0MsRUFBZ0QsRUFBRXhDLENBQWxELEVBQXFEO0FBQ25ENmYsaUJBQVc3ZixDQUFYLElBQWdCLEtBQUssS0FBS3dkLE9BQUwsQ0FBYXhkLENBQWIsQ0FBckI7QUFDRDtBQUNELFdBQU82ZixXQUFXdFQsSUFBWCxDQUFnQixFQUFoQixDQUFQO0FBQ0QsR0FQRDs7QUFTQSxXQUFTdVQsd0JBQVQsQ0FBa0MxRCxHQUFsQyxFQUF1QzNYLElBQXZDLEVBQTZDO0FBQzNDLFFBQUkyWCxJQUFJUSxVQUFKLElBQWtCNWUsSUFBSTBJLFdBQUosQ0FBZ0IwVixJQUFJUSxVQUFwQixNQUFvQzVlLElBQUkwSSxXQUFKLENBQWdCakMsSUFBaEIsQ0FBMUQsRUFBaUY7QUFDL0UsWUFBTSxJQUFJNEUsWUFBSixDQUFpQixvQkFBakIsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQXdWLFdBQVM3USxRQUFULEdBQW9CLFVBQVV2SixJQUFWLEVBQWdCd0UsTUFBaEIsRUFBd0I7QUFDMUM2Vyw2QkFBeUIsSUFBekIsRUFBK0JyYixJQUEvQjtBQUNBLFFBQUluRSxRQUFRQyxJQUFJMEIsV0FBSixDQUFnQmpFLElBQUkwSSxXQUFKLENBQWdCakMsSUFBaEIsQ0FBaEIsQ0FBWjtBQUNBbkUsVUFBTW9XLGVBQU4sQ0FBc0JqUyxJQUF0QixFQUE0QndFLE1BQTVCO0FBQ0EsU0FBS3VULGVBQUw7QUFDQSxTQUFLRCxRQUFMLENBQWNqYyxLQUFkO0FBQ0EsU0FBS3lYLFdBQUwsR0FBbUIsSUFBbkI7QUFDRCxHQVBEOztBQVNBOEcsV0FBU2tCLGVBQVQsR0FBMkIsWUFBWTtBQUNyQyxRQUFJLEtBQUtuRSxVQUFULEVBQXFCO0FBQ25CLFVBQUl0YixRQUFRLEtBQUtrZCxPQUFMLENBQWEsQ0FBYixDQUFaO0FBQ0EsV0FBS3hQLFFBQUwsQ0FBYzFOLE1BQU00SixjQUFwQixFQUFvQzVKLE1BQU11TSxXQUExQztBQUNELEtBSEQsTUFHTztBQUNMLFlBQU0sSUFBSXhELFlBQUosQ0FBaUIsbUJBQWpCLENBQU47QUFDRDtBQUNGLEdBUEQ7O0FBU0F3VixXQUFTbUIsYUFBVCxHQUF5QixZQUFZO0FBQ25DLFFBQUksS0FBS3BFLFVBQVQsRUFBcUI7QUFDbkIsVUFBSXRiLFFBQVEsS0FBS2tkLE9BQUwsQ0FBYSxLQUFLNUIsVUFBTCxHQUFrQixDQUEvQixDQUFaO0FBQ0EsV0FBSzVOLFFBQUwsQ0FBYzFOLE1BQU02SixZQUFwQixFQUFrQzdKLE1BQU13TSxTQUF4QztBQUNELEtBSEQsTUFHTztBQUNMLFlBQU0sSUFBSXpELFlBQUosQ0FBaUIsbUJBQWpCLENBQU47QUFDRDtBQUNGLEdBUEQ7O0FBU0E7QUFDQTtBQUNBd1YsV0FBU29CLGlCQUFULEdBQTZCLFVBQVV4YixJQUFWLEVBQWdCO0FBQzNDcWIsNkJBQXlCLElBQXpCLEVBQStCcmIsSUFBL0I7QUFDQSxRQUFJbkUsUUFBUUMsSUFBSTBCLFdBQUosQ0FBZ0JqRSxJQUFJMEksV0FBSixDQUFnQmpDLElBQWhCLENBQWhCLENBQVo7QUFDQW5FLFVBQU1zVixrQkFBTixDQUF5Qm5SLElBQXpCO0FBQ0EsU0FBSytYLGVBQUw7QUFDQSxTQUFLRCxRQUFMLENBQWNqYyxLQUFkO0FBQ0QsR0FORDs7QUFRQXVlLFdBQVNxQixrQkFBVCxHQUE4QixZQUFZO0FBQ3hDO0FBQ0EsUUFBSXpELDBCQUEwQnRCLHNCQUExQixJQUFvRCxLQUFLOEMsWUFBTCxDQUFrQjNULElBQWxCLElBQTBCd1EsT0FBbEYsRUFBMkY7QUFDekYsVUFBSW9ELGVBQWUsS0FBS0QsWUFBTCxDQUFrQmhjLFdBQWxCLEVBQW5CO0FBQ0EsVUFBSWtlLE9BQUo7QUFDQSxhQUFPakMsYUFBYWplLE1BQXBCLEVBQTRCO0FBQzFCa2dCLGtCQUFVakMsYUFBYUMsSUFBYixDQUFrQixDQUFsQixDQUFWO0FBQ0FELHFCQUFhcFMsTUFBYixDQUFvQnFVLE9BQXBCO0FBQ0FBLGdCQUFRcmIsVUFBUixDQUFtQitJLFdBQW5CLENBQStCc1MsT0FBL0I7QUFDRDtBQUNELFdBQUt6RyxPQUFMO0FBQ0QsS0FURCxNQVNPLElBQUksS0FBS2tDLFVBQVQsRUFBcUI7QUFDMUIsVUFBSW1ELFNBQVMsS0FBS1UsWUFBTCxFQUFiO0FBQ0EsV0FBS2pELGVBQUw7QUFDQSxXQUFLLElBQUl4YyxJQUFJLENBQVIsRUFBV3dDLE1BQU11YyxPQUFPOWUsTUFBN0IsRUFBcUNELElBQUl3QyxHQUF6QyxFQUE4QyxFQUFFeEMsQ0FBaEQsRUFBbUQ7QUFDakQrZSxlQUFPL2UsQ0FBUCxFQUFVNlYsY0FBVjtBQUNEO0FBQ0Q7QUFDQTtBQUNBLFdBQUswRyxRQUFMLENBQWN3QyxPQUFPdmMsTUFBTSxDQUFiLENBQWQ7QUFDRDtBQUNGLEdBckJEOztBQXVCQTtBQUNBcWMsV0FBU1ksWUFBVCxHQUF3QixZQUFZO0FBQ2xDLFdBQU8sS0FBS2pDLE9BQUwsQ0FBYWpNLEtBQWIsQ0FBbUIsQ0FBbkIsQ0FBUDtBQUNELEdBRkQ7O0FBSUFzTixXQUFTdUIsY0FBVCxHQUEwQixVQUFVOWYsS0FBVixFQUFpQjtBQUN6QyxTQUFLNmUsU0FBTCxDQUFlLENBQUM3ZSxLQUFELENBQWY7QUFDRCxHQUZEOztBQUlBdWUsV0FBUzFMLFlBQVQsR0FBd0IsVUFBVTFPLElBQVYsRUFBZ0IyTyxZQUFoQixFQUE4QjtBQUNwRCxTQUFLLElBQUlwVCxJQUFJLENBQVIsRUFBV3dDLE1BQU0sS0FBS2diLE9BQUwsQ0FBYXZkLE1BQW5DLEVBQTJDRCxJQUFJd0MsR0FBL0MsRUFBb0QsRUFBRXhDLENBQXRELEVBQXlEO0FBQ3ZELFVBQUksS0FBS3dkLE9BQUwsQ0FBYXhkLENBQWIsRUFBZ0JtVCxZQUFoQixDQUE2QjFPLElBQTdCLEVBQW1DMk8sWUFBbkMsQ0FBSixFQUFzRDtBQUNwRCxlQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0QsV0FBTyxLQUFQO0FBQ0QsR0FQRDs7QUFTQXlMLFdBQVN0TSxNQUFULEdBQWtCLFlBQVk7QUFDNUIsUUFBSThOLE9BQU8sRUFBWDtBQUNBLFFBQUksS0FBS3pFLFVBQVQsRUFBcUI7QUFDbkIsVUFBSXBKLFlBQVkwRSxTQUFTOU0sZ0JBQVQsQ0FBMEIsS0FBS29ULE9BQUwsQ0FBYSxDQUFiLENBQTFCLEVBQTJDdFosYUFBM0MsQ0FBeUQsS0FBekQsQ0FBaEI7QUFDQSxXQUFLLElBQUlsRSxJQUFJLENBQVIsRUFBV3dDLE1BQU0sS0FBS2diLE9BQUwsQ0FBYXZkLE1BQW5DLEVBQTJDRCxJQUFJd0MsR0FBL0MsRUFBb0QsRUFBRXhDLENBQXRELEVBQXlEO0FBQ3ZEd1Msa0JBQVVwTSxXQUFWLENBQXNCLEtBQUtvWCxPQUFMLENBQWF4ZCxDQUFiLEVBQWdCcVIsYUFBaEIsRUFBdEI7QUFDRDtBQUNEZ1AsYUFBTzdOLFVBQVV4QyxTQUFqQjtBQUNEO0FBQ0QsV0FBT3FRLElBQVA7QUFDRCxHQVZEOztBQVlBLFdBQVNqWCxPQUFULENBQWlCZ1QsR0FBakIsRUFBc0I7QUFDcEIsUUFBSWtFLGdCQUFnQixFQUFwQjtBQUNBLFFBQUlDLFNBQVMsSUFBSXZYLFdBQUosQ0FBZ0JvVCxJQUFJUSxVQUFwQixFQUFnQ1IsSUFBSVUsWUFBcEMsQ0FBYjtBQUNBLFFBQUkwRCxRQUFRLElBQUl4WCxXQUFKLENBQWdCb1QsSUFBSVMsU0FBcEIsRUFBK0JULElBQUlXLFdBQW5DLENBQVo7QUFDQSxRQUFJN1osT0FBTyxPQUFPa1osSUFBSXhQLE9BQVgsSUFBc0IsVUFBdEIsR0FBbUN3UCxJQUFJeFAsT0FBSixFQUFuQyxHQUFtRCxXQUE5RDs7QUFFQSxRQUFJLE9BQU93UCxJQUFJUixVQUFYLElBQXlCLFdBQTdCLEVBQTBDO0FBQ3hDLFdBQUssSUFBSTViLElBQUksQ0FBUixFQUFXd0MsTUFBTTRaLElBQUlSLFVBQTFCLEVBQXNDNWIsSUFBSXdDLEdBQTFDLEVBQStDLEVBQUV4QyxDQUFqRCxFQUFvRDtBQUNsRHNnQixzQkFBY3RnQixDQUFkLElBQW1Ca1gsU0FBUzlOLE9BQVQsQ0FBaUJnVCxJQUFJWSxVQUFKLENBQWVoZCxDQUFmLENBQWpCLENBQW5CO0FBQ0Q7QUFDRjtBQUNELFdBQU8sTUFBTWtELElBQU4sR0FBYSxXQUFiLEdBQTJCb2QsY0FBYy9ULElBQWQsQ0FBbUIsSUFBbkIsQ0FBM0IsR0FBc0QsWUFBdEQsR0FBcUVnVSxPQUFPblgsT0FBUCxFQUFyRSxHQUF3RixXQUF4RixHQUFzR29YLE1BQU1wWCxPQUFOLEVBQXRHLEdBQXdILEdBQS9IO0FBQ0Q7O0FBRUR5VixXQUFTalMsT0FBVCxHQUFtQixZQUFZO0FBQzdCLFdBQU8sa0JBQVA7QUFDRCxHQUZEOztBQUlBaVMsV0FBU3pWLE9BQVQsR0FBbUIsWUFBWTtBQUM3QixXQUFPQSxRQUFRLElBQVIsQ0FBUDtBQUNELEdBRkQ7O0FBSUF5VixXQUFTM2MsTUFBVCxHQUFrQixZQUFZO0FBQzVCLFNBQUtjLEdBQUwsQ0FBUzJYLGtCQUFULElBQStCLElBQS9CO0FBQ0EsU0FBSzNYLEdBQUwsR0FBVyxLQUFLNFosVUFBTCxHQUFrQixLQUFLQyxTQUFMLEdBQWlCLElBQTlDO0FBQ0QsR0FIRDs7QUFLQTZCLG1CQUFpQnRWLE9BQWpCLEdBQTJCQSxPQUEzQjs7QUFFQTdJLE1BQUlrZ0IsU0FBSixHQUFnQi9CLGdCQUFoQjs7QUFFQW5lLE1BQUltZ0Isa0JBQUosR0FBeUI3QixRQUF6Qjs7QUFFQXRlLE1BQUl1QyxpQ0FBSixDQUFzQyxVQUFVRSxHQUFWLEVBQWU7QUFDbkQsUUFBSSxPQUFPQSxJQUFJNFgsWUFBWCxJQUEyQixXQUEvQixFQUE0QztBQUMxQzVYLFVBQUk0WCxZQUFKLEdBQW1CLFlBQVk7QUFDN0IsZUFBT3JhLElBQUlxYSxZQUFKLENBQWlCLElBQWpCLENBQVA7QUFDRCxPQUZEO0FBR0Q7QUFDRDVYLFVBQU0sSUFBTjtBQUNELEdBUEQ7QUFRRCxDQXJ4QkU7QUFzeEJIOzs7Ozs7QUFNQSxJQUFJMmQsT0FBTyxTQUFTQSxJQUFULEdBQWdCO0FBQ3pCO0FBQ0QsQ0FGRDs7QUFJQUEsS0FBS2xmLE1BQUwsR0FBYyxVQUFVbWYsU0FBVixFQUFxQkMsT0FBckIsRUFBOEI7QUFDMUM7QUFDQSxNQUFJcGYsU0FBU2tmLEtBQUsvaUIsU0FBTCxDQUFlNkQsTUFBNUI7O0FBRUE7QUFDQWtmLE9BQUtHLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxNQUFJQyxRQUFRLElBQUksSUFBSixFQUFaO0FBQ0F0ZixTQUFPaUosSUFBUCxDQUFZcVcsS0FBWixFQUFtQkgsU0FBbkI7QUFDQUcsUUFBTUMsSUFBTixHQUFhLFlBQVk7QUFDdkI7QUFDRCxHQUZEO0FBR0EsU0FBT0wsS0FBS0csWUFBWjs7QUFFQTtBQUNBO0FBQ0EsTUFBSW5qQixjQUFjb2pCLE1BQU1wakIsV0FBeEI7QUFDQSxNQUFJc2pCLFFBQVFGLE1BQU1wakIsV0FBTixHQUFvQixZQUFZO0FBQzFDLFFBQUksQ0FBQ2dqQixLQUFLRyxZQUFWLEVBQXdCO0FBQ3RCLFVBQUksS0FBS0ksYUFBTCxJQUFzQixLQUFLdmpCLFdBQUwsSUFBb0JzakIsS0FBOUMsRUFBcUQ7QUFDbkQ7QUFDQSxhQUFLQyxhQUFMLEdBQXFCLElBQXJCO0FBQ0F2akIsb0JBQVl3akIsS0FBWixDQUFrQixJQUFsQixFQUF3QkMsU0FBeEI7QUFDQSxlQUFPLEtBQUtGLGFBQVo7QUFDRCxPQUxELE1BS08sSUFBSUUsVUFBVSxDQUFWLEtBQWdCLElBQXBCLEVBQTBCO0FBQy9CO0FBQ0EsZUFBTyxDQUFDQSxVQUFVLENBQVYsRUFBYTNmLE1BQWIsSUFBdUJBLE1BQXhCLEVBQWdDaUosSUFBaEMsQ0FBcUMwVyxVQUFVLENBQVYsQ0FBckMsRUFBbURMLEtBQW5ELENBQVA7QUFDRDtBQUNGO0FBQ0YsR0FaRDs7QUFjQTtBQUNBRSxRQUFNdGIsUUFBTixHQUFpQixJQUFqQjtBQUNBc2IsUUFBTXhmLE1BQU4sR0FBZSxLQUFLQSxNQUFwQjtBQUNBd2YsUUFBTUksT0FBTixHQUFnQixLQUFLQSxPQUFyQjtBQUNBSixRQUFNSyxTQUFOLEdBQWtCLEtBQUtBLFNBQXZCO0FBQ0FMLFFBQU1yakIsU0FBTixHQUFrQm1qQixLQUFsQjtBQUNBRSxRQUFNalgsUUFBTixHQUFpQixLQUFLQSxRQUF0QjtBQUNBaVgsUUFBTU0sT0FBTixHQUFnQixVQUFValgsSUFBVixFQUFnQjtBQUM5QjtBQUNBLFdBQU9BLFFBQVEsUUFBUixHQUFtQjJXLEtBQW5CLEdBQTJCdGpCLFlBQVk0akIsT0FBWixFQUFsQztBQUNELEdBSEQ7QUFJQTlmLFNBQU9pSixJQUFQLENBQVl1VyxLQUFaLEVBQW1CSixPQUFuQjtBQUNBO0FBQ0EsTUFBSSxPQUFPSSxNQUFNcmYsSUFBYixJQUFxQixVQUF6QixFQUFxQ3FmLE1BQU1yZixJQUFOO0FBQ3JDLFNBQU9xZixLQUFQO0FBQ0QsQ0E3Q0Q7O0FBK0NBTixLQUFLL2lCLFNBQUwsR0FBaUI7QUFDZjZELFVBQVEsU0FBU0EsTUFBVCxDQUFnQitmLE1BQWhCLEVBQXdCQyxLQUF4QixFQUErQjtBQUNyQyxRQUFJTCxVQUFVbmhCLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEI7QUFDQSxVQUFJMEYsV0FBVyxLQUFLNmIsTUFBTCxDQUFmO0FBQ0EsVUFBSTdiLFlBQVksT0FBTzhiLEtBQVAsSUFBZ0IsVUFBNUIsTUFBNEM7QUFDaEQ7QUFDQSxPQUFDOWIsU0FBUzRiLE9BQVYsSUFBcUI1YixTQUFTNGIsT0FBVCxNQUFzQkUsTUFBTUYsT0FBTixFQUZ2QyxLQUUyRCxXQUFXN1UsSUFBWCxDQUFnQitVLEtBQWhCLENBRi9ELEVBRXVGO0FBQ3JGO0FBQ0EsWUFBSUMsU0FBU0QsTUFBTUYsT0FBTixFQUFiO0FBQ0E7QUFDQUUsZ0JBQVEsU0FBU0EsS0FBVCxHQUFpQjtBQUN2QixjQUFJRSxXQUFXLEtBQUtYLElBQUwsSUFBYUwsS0FBSy9pQixTQUFMLENBQWVvakIsSUFBM0M7QUFDQSxlQUFLQSxJQUFMLEdBQVlyYixRQUFaO0FBQ0EsY0FBSXVQLGNBQWN3TSxPQUFPUCxLQUFQLENBQWEsSUFBYixFQUFtQkMsU0FBbkIsQ0FBbEI7QUFDQSxlQUFLSixJQUFMLEdBQVlXLFFBQVo7QUFDQSxpQkFBT3pNLFdBQVA7QUFDRCxTQU5EO0FBT0E7QUFDQXVNLGNBQU1GLE9BQU4sR0FBZ0IsVUFBVWpYLElBQVYsRUFBZ0I7QUFDOUIsaUJBQU9BLFFBQVEsUUFBUixHQUFtQm1YLEtBQW5CLEdBQTJCQyxNQUFsQztBQUNELFNBRkQ7QUFHQUQsY0FBTXpYLFFBQU4sR0FBaUIyVyxLQUFLM1csUUFBdEI7QUFDRDtBQUNELFdBQUt3WCxNQUFMLElBQWVDLEtBQWY7QUFDRCxLQXZCRCxNQXVCTyxJQUFJRCxNQUFKLEVBQVk7QUFDakI7QUFDQSxVQUFJL2YsU0FBU2tmLEtBQUsvaUIsU0FBTCxDQUFlNkQsTUFBNUI7QUFDQTtBQUNBLFVBQUksQ0FBQ2tmLEtBQUtHLFlBQU4sSUFBc0IsT0FBTyxJQUFQLElBQWUsVUFBekMsRUFBcUQ7QUFDbkRyZixpQkFBUyxLQUFLQSxNQUFMLElBQWVBLE1BQXhCO0FBQ0Q7QUFDRCxVQUFJc2YsUUFBUSxFQUFFYSxVQUFVLElBQVosRUFBWjtBQUNBO0FBQ0EsVUFBSUMsU0FBUyxDQUFDLGFBQUQsRUFBZ0IsVUFBaEIsRUFBNEIsU0FBNUIsQ0FBYjtBQUNBO0FBQ0EsVUFBSTdoQixJQUFJMmdCLEtBQUtHLFlBQUwsR0FBb0IsQ0FBcEIsR0FBd0IsQ0FBaEM7QUFDQSxhQUFPZ0IsTUFBTUQsT0FBTzdoQixHQUFQLENBQWIsRUFBMEI7QUFDeEIsWUFBSXdoQixPQUFPTSxHQUFQLEtBQWVmLE1BQU1lLEdBQU4sQ0FBbkIsRUFBK0I7QUFDN0JyZ0IsaUJBQU9pSixJQUFQLENBQVksSUFBWixFQUFrQm9YLEdBQWxCLEVBQXVCTixPQUFPTSxHQUFQLENBQXZCO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsV0FBSyxJQUFJQSxHQUFULElBQWdCTixNQUFoQixFQUF3QjtBQUN0QixZQUFJLENBQUNULE1BQU1lLEdBQU4sQ0FBTCxFQUFpQnJnQixPQUFPaUosSUFBUCxDQUFZLElBQVosRUFBa0JvWCxHQUFsQixFQUF1Qk4sT0FBT00sR0FBUCxDQUF2QjtBQUNsQjtBQUNGO0FBQ0QsV0FBTyxJQUFQO0FBQ0Q7QUFoRGMsQ0FBakI7O0FBbURBO0FBQ0FuQixPQUFPQSxLQUFLbGYsTUFBTCxDQUFZO0FBQ2pCOUQsZUFBYSxTQUFTQSxXQUFULEdBQXVCO0FBQ2xDLFNBQUs4RCxNQUFMLENBQVkyZixVQUFVLENBQVYsQ0FBWjtBQUNEO0FBSGdCLENBQVosRUFJSjtBQUNEemIsWUFBVW9jLE1BRFQ7QUFFRGprQixXQUFTLEtBRlI7O0FBSUR1akIsV0FBUyxTQUFTQSxPQUFULENBQWlCVyxNQUFqQixFQUF5QkMsS0FBekIsRUFBZ0NDLE9BQWhDLEVBQXlDO0FBQ2hELFNBQUssSUFBSUosR0FBVCxJQUFnQkUsTUFBaEIsRUFBd0I7QUFDdEIsVUFBSSxLQUFLcGtCLFNBQUwsQ0FBZWtrQixHQUFmLE1BQXdCSyxTQUE1QixFQUF1QztBQUNyQ0YsY0FBTXZYLElBQU4sQ0FBV3dYLE9BQVgsRUFBb0JGLE9BQU9GLEdBQVAsQ0FBcEIsRUFBaUNBLEdBQWpDLEVBQXNDRSxNQUF0QztBQUNEO0FBQ0Y7QUFDRixHQVZBOztBQVlEVixhQUFXLFNBQVNBLFNBQVQsR0FBcUI7QUFDOUIsU0FBSyxJQUFJdGhCLElBQUksQ0FBYixFQUFnQkEsSUFBSW9oQixVQUFVbmhCLE1BQTlCLEVBQXNDRCxHQUF0QyxFQUEyQztBQUN6QyxVQUFJLE9BQU9vaEIsVUFBVXBoQixDQUFWLENBQVAsSUFBdUIsVUFBM0IsRUFBdUM7QUFDckM7QUFDQW9oQixrQkFBVXBoQixDQUFWLEVBQWEsS0FBS3BDLFNBQWxCO0FBQ0QsT0FIRCxNQUdPO0FBQ0w7QUFDQSxhQUFLQSxTQUFMLENBQWU2RCxNQUFmLENBQXNCMmYsVUFBVXBoQixDQUFWLENBQXRCO0FBQ0Q7QUFDRjtBQUNELFdBQU8sSUFBUDtBQUNELEdBdkJBOztBQXlCRGdLLFlBQVUsU0FBU0EsUUFBVCxHQUFvQjtBQUM1QixXQUFPb1ksT0FBTyxLQUFLYixPQUFMLEVBQVAsQ0FBUDtBQUNEO0FBM0JBLENBSkksQ0FBUCxDLENBZ0NJOzs7QUFHSjFqQixVQUFVd2tCLE9BQVYsR0FBb0IsWUFBWTtBQUM5QixNQUFJQyxZQUFZQyxVQUFVRCxTQUExQjtBQUFBLE1BQ0lFLGNBQWN4Z0IsU0FBU2tDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FEbEI7OztBQUdBO0FBQ0F1ZSxTQUFPSCxVQUFVSSxPQUFWLENBQWtCLE1BQWxCLE1BQThCLENBQUMsQ0FBL0IsSUFBb0NKLFVBQVVJLE9BQVYsQ0FBa0IsT0FBbEIsTUFBK0IsQ0FBQyxDQUozRTtBQUFBLE1BS0lDLFVBQVVMLFVBQVVJLE9BQVYsQ0FBa0IsT0FBbEIsTUFBK0IsQ0FBQyxDQUFoQyxJQUFxQ0osVUFBVUksT0FBVixDQUFrQixPQUFsQixNQUErQixDQUFDLENBTG5GO0FBQUEsTUFNSUUsV0FBV04sVUFBVUksT0FBVixDQUFrQixjQUFsQixNQUFzQyxDQUFDLENBTnREO0FBQUEsTUFPSUcsV0FBV1AsVUFBVUksT0FBVixDQUFrQixTQUFsQixNQUFpQyxDQUFDLENBUGpEO0FBQUEsTUFRSUksVUFBVVIsVUFBVUksT0FBVixDQUFrQixRQUFsQixNQUFnQyxDQUFDLENBUi9DOztBQVVBLFdBQVNLLFVBQVQsQ0FBb0JULFNBQXBCLEVBQStCO0FBQzdCLFdBQU8sQ0FBQyxtQkFBbUI1VixJQUFuQixDQUF3QjRWLFNBQXhCLEtBQXNDQSxVQUFVVSxLQUFWLENBQWdCLDRCQUFoQixDQUF0QyxJQUF1RixHQUFHLENBQUgsQ0FBeEYsRUFBK0YsQ0FBL0YsQ0FBUDtBQUNEOztBQUVELFNBQU87QUFDTDtBQUNBQyxnQkFBWVgsU0FGUDs7QUFJTDs7Ozs7Ozs7QUFRQTdoQixlQUFXLFNBQVNBLFNBQVQsR0FBcUI7QUFDOUIsVUFBSTZoQixZQUFZLEtBQUtXLFVBQUwsQ0FBZ0JDLFdBQWhCLEVBQWhCOzs7QUFFQTtBQUNBQyxrQ0FBNEIscUJBQXFCWCxXQUhqRDs7O0FBS0E7QUFDQVksNkJBQXVCcGhCLFNBQVNxaEIsV0FBVCxJQUF3QnJoQixTQUFTc2hCLHFCQUFqQyxJQUEwRHRoQixTQUFTdWhCLGlCQU4xRjs7O0FBUUE7QUFDQUMsZ0NBQTBCeGhCLFNBQVN5aEIsYUFBVCxJQUEwQnpoQixTQUFTMGhCLGdCQVQ3RDs7O0FBV0E7QUFDQUMsb0NBQThCLEtBQUtDLEtBQUwsTUFBZ0JiLFdBQVdULFNBQVgsSUFBd0IsQ0FBeEMsSUFBNkNBLFVBQVVJLE9BQVYsQ0FBa0IsWUFBbEIsTUFBb0MsQ0FBQyxDQUFsRixJQUF1RkosVUFBVUksT0FBVixDQUFrQixRQUFsQixNQUFnQyxDQUFDLENBWnRKOztBQWNBLGFBQU9TLDZCQUE2QkMsb0JBQTdCLElBQXFESSx1QkFBckQsSUFBZ0YsQ0FBQ0csMkJBQXhGO0FBQ0QsS0E1Qkk7O0FBOEJMRSxtQkFBZSxTQUFTQSxhQUFULEdBQXlCO0FBQ3RDLGFBQU8sS0FBS0MsYUFBTCxDQUFtQixXQUFuQixDQUFQO0FBQ0QsS0FoQ0k7O0FBa0NMRixXQUFPLFNBQVNBLEtBQVQsR0FBaUI7QUFDdEIsVUFBSXRCLFlBQVksS0FBS1csVUFBTCxDQUFnQkMsV0FBaEIsRUFBaEI7QUFDQSxhQUFPWixVQUFVSSxPQUFWLENBQWtCLFFBQWxCLE1BQWdDLENBQUMsQ0FBakMsSUFBc0NKLFVBQVVJLE9BQVYsQ0FBa0IsUUFBbEIsTUFBZ0MsQ0FBQyxDQUE5RTtBQUNELEtBckNJOztBQXVDTDs7Ozs7Ozs7O0FBU0FxQiw4QkFBMEIsU0FBU0Esd0JBQVQsR0FBb0M7QUFDNUQsYUFBT3RCLElBQVA7QUFDRCxLQWxESTs7QUFvREw7Ozs7O0FBS0F1QixtREFBK0MsU0FBU0EsNkNBQVQsR0FBeUQ7QUFDdEcsYUFBTyxFQUFFLG1CQUFtQmhpQixRQUFyQixDQUFQO0FBQ0QsS0EzREk7O0FBNkRMOzs7O0FBSUFpaUIsa0RBQThDLFNBQVNBLDRDQUFULEdBQXdEO0FBQ3BHLGFBQU8sQ0FBQ3RCLE9BQVI7QUFDRCxLQW5FSTs7QUFxRUw7Ozs7O0FBS0F1Qiw2QkFBeUIsU0FBU0EsdUJBQVQsR0FBbUM7QUFDMUQsYUFBTyxrQkFBa0IxQixXQUF6QjtBQUNELEtBNUVJOztBQThFTDs7O0FBR0EyQiwrQkFBMkIsU0FBU0EseUJBQVQsR0FBcUM7QUFDOUQsYUFBT3hCLE9BQVA7QUFDRCxLQW5GSTs7QUFxRkx5QixvQ0FBZ0MsU0FBU0EsOEJBQVQsQ0FBd0NqRSxPQUF4QyxFQUFpRDtBQUMvRSxhQUFPLGlCQUFpQkEsT0FBeEI7QUFDRCxLQXZGSTs7QUF5RkwyRCxtQkFBZSxTQUFTQSxhQUFULENBQXVCTyxTQUF2QixFQUFrQztBQUMvQyxhQUFPLE9BQU9BLFNBQVAsSUFBb0I3QixXQUFwQixJQUFtQyxZQUFZO0FBQ3BEQSxvQkFBWThCLFlBQVosQ0FBeUIsT0FBT0QsU0FBaEMsRUFBMkMsU0FBM0M7QUFDQSxlQUFPLE9BQU83QixZQUFZLE9BQU82QixTQUFuQixDQUFQLEtBQXlDLFVBQWhEO0FBQ0QsT0FIeUMsRUFBMUM7QUFJRCxLQTlGSTs7QUFnR0w7OztBQUdBRSxxQ0FBaUMsU0FBU0EsK0JBQVQsR0FBMkM7QUFDMUUsYUFBTyxDQUFDekIsT0FBUjtBQUNELEtBckdJOztBQXVHTDs7Ozs7O0FBTUEwQiw4Q0FBMEMsU0FBU0Esd0NBQVQsR0FBb0Q7QUFDNUYsYUFBTzVCLFlBQVlELE9BQW5CO0FBQ0QsS0EvR0k7O0FBaUhMOzs7QUFHQThCLDBCQUFzQixTQUFTQSxvQkFBVCxHQUFnQztBQUNwRCxVQUFJO0FBQ0Y7QUFDQSxlQUFPN0IsWUFBWSxDQUFDN2pCLE9BQU8ybEIsU0FBUCxJQUFvQjNsQixPQUFPNGxCLFlBQTVCLEVBQTBDL21CLFNBQTFDLENBQW9EZ25CLE9BQXZFO0FBQ0QsT0FIRCxDQUdFLE9BQU9oaEIsQ0FBUCxFQUFVO0FBQ1YsZUFBTyxLQUFQO0FBQ0Q7QUFDRixLQTNISTs7QUE2SEw7Ozs7Ozs7O0FBUUFpaEIsdUJBQW1CLFNBQVNBLGlCQUFULENBQTJCM0MsT0FBM0IsRUFBb0M7QUFDckQsVUFBSS9CLFVBQVUrQixRQUFRaGUsYUFBUixDQUFzQixLQUF0QixDQUFkO0FBQUEsVUFDSTRnQixRQUFRLHdCQURaO0FBRUEzRSxjQUFRblEsU0FBUixHQUFvQjhVLEtBQXBCO0FBQ0EsYUFBTzNFLFFBQVFuUSxTQUFSLENBQWtCa1QsV0FBbEIsT0FBb0M0QixLQUEzQztBQUNELEtBMUlJOztBQTRJTDs7Ozs7Ozs7Ozs7O0FBWUFDLHFCQUFpQixZQUFZO0FBQzNCO0FBQ0EsVUFBSUMsZ0JBQWdCO0FBQ2xCO0FBQ0EsdUJBQWV2QyxJQUZHO0FBR2xCO0FBQ0E7QUFDQTtBQUNBLCtCQUF1QkEsUUFBUUssT0FBUixJQUFtQkYsUUFOeEI7QUFPbEIsNkJBQXFCSCxRQUFRSyxPQUFSLElBQW1CRjtBQVB0QixPQUFwQjs7QUFVQTtBQUNBLFVBQUluaUIsWUFBWTtBQUNkLHNCQUFja2lCO0FBREEsT0FBaEI7O0FBSUEsYUFBTyxVQUFVOWIsR0FBVixFQUFlb2UsT0FBZixFQUF3QjtBQUM3QixZQUFJQyxVQUFVRixjQUFjQyxPQUFkLENBQWQ7QUFDQSxZQUFJLENBQUNDLE9BQUwsRUFBYztBQUNaO0FBQ0EsY0FBSTtBQUNGLG1CQUFPcmUsSUFBSXljLHFCQUFKLENBQTBCMkIsT0FBMUIsQ0FBUDtBQUNELFdBRkQsQ0FFRSxPQUFPRSxFQUFQLEVBQVcsQ0FBRTs7QUFFZixjQUFJO0FBQ0YsbUJBQU90ZSxJQUFJdWUsbUJBQUosQ0FBd0JILE9BQXhCLENBQVA7QUFDRCxXQUZELENBRUUsT0FBT0ksRUFBUCxFQUFXO0FBQ1gsbUJBQU8sQ0FBQyxDQUFDNWtCLFVBQVV3a0IsT0FBVixDQUFUO0FBQ0Q7QUFDRjtBQUNELGVBQU8sS0FBUDtBQUNELE9BZkQ7QUFnQkQsS0FqQ2dCLEVBeEpaOztBQTJMTDs7Ozs7Ozs7OztBQVVBSyxzQ0FBa0MsU0FBU0EsZ0NBQVQsR0FBNEM7QUFDNUUsYUFBTzdDLElBQVA7QUFDRCxLQXZNSTs7QUF5TUw7Ozs7QUFJQThDLDJCQUF1QixTQUFTQSxxQkFBVCxHQUFpQztBQUN0RCxhQUFPLEtBQUtSLGVBQUwsQ0FBcUIvaUIsUUFBckIsRUFBK0IsZUFBL0IsQ0FBUDtBQUNELEtBL01JOztBQWlOTDs7OztBQUlBd2pCLG9DQUFnQyxTQUFTQSw4QkFBVCxHQUEwQztBQUN4RSxhQUFPN0MsV0FBV0csT0FBWCxJQUFzQkYsUUFBN0I7QUFDRCxLQXZOSTs7QUF5Tkw7OztBQUdBNkMsbUNBQStCLFNBQVNBLDZCQUFULEdBQXlDO0FBQ3RFLFVBQUlDLEtBQUsxakIsU0FBU2tDLGFBQVQsQ0FBdUIsSUFBdkIsQ0FBVDtBQUNBLGFBQU93aEIsR0FBR0MsWUFBSCxDQUFnQixTQUFoQixLQUE4QixHQUFyQztBQUNELEtBL05JOztBQWlPTDs7OztBQUlBQyxzQ0FBa0MsU0FBU0EsZ0NBQVQsR0FBNEM7QUFDNUUsYUFBT2pELFdBQVdGLElBQVgsSUFBbUJLLE9BQTFCO0FBQ0QsS0F2T0k7O0FBeU9MOzs7O0FBSUErQywyQ0FBdUMsU0FBU0EscUNBQVQsR0FBaUQ7QUFDdEYsYUFBT2xELFdBQVdGLElBQVgsSUFBbUJHLFFBQTFCO0FBQ0QsS0EvT0k7O0FBaVBMOzs7QUFHQWtELHdCQUFvQixTQUFTQSxrQkFBVCxHQUE4QjtBQUNoRCxhQUFPLENBQUNsRCxRQUFSO0FBQ0QsS0F0UEk7O0FBd1BMOzs7QUFHQW1ELDRCQUF3QixTQUFTQSxzQkFBVCxHQUFrQztBQUN4RCxVQUFJQyxvQkFBb0J4RCxZQUFZaGMsU0FBWixDQUFzQixLQUF0QixDQUF4QjtBQUFBLFVBQ0kwTyxXQURKO0FBQUEsVUFFSWxGLFNBRko7O0FBSUFnVyx3QkFBa0JoVyxTQUFsQixHQUE4QixnQkFBOUI7QUFDQUEsa0JBQVlnVyxrQkFBa0JoVyxTQUFsQixDQUE0QmtULFdBQTVCLEVBQVo7QUFDQWhPLG9CQUFjbEYsY0FBYyxvQkFBZCxJQUFzQ0EsY0FBYyxvQkFBbEU7O0FBRUE7QUFDQSxXQUFLK1Ysc0JBQUwsR0FBOEIsWUFBWTtBQUN4QyxlQUFPN1EsV0FBUDtBQUNELE9BRkQ7O0FBSUEsYUFBT0EsV0FBUDtBQUNELEtBMVFJOztBQTRRTDs7O0FBR0ErUSwwQ0FBc0MsU0FBU0Esb0NBQVQsR0FBZ0Q7QUFDcEYsYUFBTzdELE9BQU9wZ0IsU0FBU2trQixzQkFBaEIsRUFBd0N4RCxPQUF4QyxDQUFnRCxlQUFoRCxNQUFxRSxDQUFDLENBQTdFO0FBQ0QsS0FqUkk7O0FBbVJMOzs7O0FBSUF5RCw2QkFBeUIsU0FBU0EsdUJBQVQsR0FBbUM7QUFDMUQsYUFBTyxrQkFBa0JwbkIsTUFBbEIsSUFBNEIsWUFBWUEsT0FBTzZiLFlBQVAsRUFBL0M7QUFDRCxLQXpSSTs7QUEyUkw7Ozs7QUFJQXdMLHVCQUFtQixTQUFTQSxpQkFBVCxHQUE2QjtBQUM5QyxhQUFPLGVBQWU1RCxXQUF0QjtBQUNELEtBalNJOztBQW1TTDs7O0FBR0E2RCw4QkFBMEIsU0FBU0Esd0JBQVQsR0FBb0M7QUFDNUQsYUFBT3ZELE9BQVA7QUFDRCxLQXhTSTs7QUEwU0w7Ozs7Ozs7Ozs7QUFVQXdELHlCQUFxQixTQUFTQSxtQkFBVCxDQUE2QkMsS0FBN0IsRUFBb0M7QUFDdkQsVUFBSUMsZ0JBQWdCbEUsVUFBVVUsS0FBVixDQUFnQixlQUFoQixLQUFvQyxHQUFHLENBQUgsQ0FBeEQ7QUFDQSxhQUFPd0QsY0FBYyxDQUFkLEtBQW9CLEVBQXBCLEtBQTJCLDBCQUEwQkQsS0FBMUIsSUFBbUMsWUFBWUEsS0FBMUUsQ0FBUDtBQUNELEtBdlRJOztBQXlUTDs7Ozs7QUFLQUUsK0JBQTJCLFNBQVNBLHlCQUFULENBQW1DQyxRQUFuQyxFQUE2QztBQUN0RSxhQUFPakUsU0FBU2lFLGFBQWEsZ0JBQWIsSUFBaUNBLGFBQWEsZ0JBQXZELENBQVA7QUFDRCxLQWhVSTs7QUFrVUw7OztBQUdBQyxvQkFBZ0IsU0FBU0EsY0FBVCxHQUEwQjtBQUN4QyxhQUFPbEUsSUFBUDtBQUNELEtBdlVJOztBQXlVTDs7O0FBR0FtRSxxQ0FBaUMsU0FBU0EsK0JBQVQsR0FBMkM7QUFDMUUsYUFBT25FLElBQVA7QUFDRCxLQTlVSTs7QUFnVkxvRSwwQkFBc0IsU0FBU0Esb0JBQVQsR0FBZ0M7QUFDcEQsYUFBT2xFLFdBQVdFLFFBQVgsSUFBdUJDLE9BQTlCO0FBQ0Q7QUFsVkksR0FBUDtBQW9WRCxDQW5XbUIsRUFBcEIsQ0FtV0lqbEIsVUFBVU0sSUFBVixDQUFlMm9CLEtBQWYsR0FBdUIsVUFBVXhpQixHQUFWLEVBQWU7QUFDeEMsU0FBTztBQUNMOzs7Ozs7O0FBT0F1UCxjQUFVLFNBQVNBLFFBQVQsQ0FBa0JrVCxNQUFsQixFQUEwQjtBQUNsQyxVQUFJemlCLElBQUlvZSxPQUFSLEVBQWlCO0FBQ2YsZUFBT3BlLElBQUlvZSxPQUFKLENBQVlxRSxNQUFaLE1BQXdCLENBQUMsQ0FBaEM7QUFDRCxPQUZELE1BRU87QUFDTCxhQUFLLElBQUkvbUIsSUFBSSxDQUFSLEVBQVdDLFNBQVNxRSxJQUFJckUsTUFBN0IsRUFBcUNELElBQUlDLE1BQXpDLEVBQWlERCxHQUFqRCxFQUFzRDtBQUNwRCxjQUFJc0UsSUFBSXRFLENBQUosTUFBVyttQixNQUFmLEVBQXVCO0FBQ3JCLG1CQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0QsZUFBTyxLQUFQO0FBQ0Q7QUFDRixLQW5CSTs7QUFxQkw7Ozs7Ozs7QUFPQUMsYUFBUyxTQUFTQSxPQUFULENBQWlCQyxnQkFBakIsRUFBbUM7QUFDMUNBLHlCQUFtQnBwQixVQUFVTSxJQUFWLENBQWUyb0IsS0FBZixDQUFxQkcsZ0JBQXJCLENBQW5CO0FBQ0EsVUFBSUMsU0FBUyxFQUFiO0FBQUEsVUFDSWxuQixJQUFJLENBRFI7QUFBQSxVQUVJQyxTQUFTcUUsSUFBSXJFLE1BRmpCO0FBR0EsYUFBT0QsSUFBSUMsTUFBWCxFQUFtQkQsR0FBbkIsRUFBd0I7QUFDdEIsWUFBSSxDQUFDaW5CLGlCQUFpQnBULFFBQWpCLENBQTBCdlAsSUFBSXRFLENBQUosQ0FBMUIsQ0FBTCxFQUF3QztBQUN0Q2tuQixpQkFBT3RrQixJQUFQLENBQVkwQixJQUFJdEUsQ0FBSixDQUFaO0FBQ0Q7QUFDRjtBQUNELGFBQU9rbkIsTUFBUDtBQUNELEtBdkNJOztBQXlDTDs7Ozs7OztBQU9BQyxTQUFLLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixVQUFJbm5CLElBQUksQ0FBUjtBQUFBLFVBQ0lDLFNBQVNxRSxJQUFJckUsTUFEakI7QUFBQSxVQUVJbW5CLFdBQVcsRUFGZjtBQUdBLGFBQU9wbkIsSUFBSUMsTUFBWCxFQUFtQkQsR0FBbkIsRUFBd0I7QUFDdEJvbkIsaUJBQVN4a0IsSUFBVCxDQUFjMEIsSUFBSXRFLENBQUosQ0FBZDtBQUNEO0FBQ0QsYUFBT29uQixRQUFQO0FBQ0Q7QUF4REksR0FBUDtBQTBERCxDQTNERyxDQTJERnZwQixVQUFVTSxJQUFWLENBQWVrcEIsVUFBZixHQUE0QjFHLEtBQUtsZixNQUFMO0FBQzlCLDZDQUE2QztBQUMzQzZsQixXQUFTLFNBQVNBLE9BQVQsQ0FBaUJqRCxTQUFqQixFQUE0QmtELE9BQTVCLEVBQXFDO0FBQzVDLFNBQUtDLE1BQUwsR0FBYyxLQUFLQSxNQUFMLElBQWUsRUFBN0I7QUFDQSxTQUFLQSxNQUFMLENBQVluRCxTQUFaLElBQXlCLEtBQUttRCxNQUFMLENBQVluRCxTQUFaLEtBQTBCLEVBQW5EO0FBQ0EsU0FBS21ELE1BQUwsQ0FBWW5ELFNBQVosRUFBdUJ6aEIsSUFBdkIsQ0FBNEIya0IsT0FBNUI7QUFDQSxXQUFPLElBQVA7QUFDRCxHQU4wQzs7QUFRM0NFLE1BQUksU0FBU0EsRUFBVCxHQUFjO0FBQ2hCLFdBQU8sS0FBS0gsT0FBTCxDQUFhbkcsS0FBYixDQUFtQixJQUFuQixFQUF5QnRqQixVQUFVTSxJQUFWLENBQWUyb0IsS0FBZixDQUFxQjFGLFNBQXJCLEVBQWdDK0YsR0FBaEMsRUFBekIsQ0FBUDtBQUNELEdBVjBDOztBQVkzQ08sUUFBTSxTQUFTQSxJQUFULENBQWNyRCxTQUFkLEVBQXlCc0QsT0FBekIsRUFBa0M7QUFDdEMsU0FBS0gsTUFBTCxHQUFjLEtBQUtBLE1BQUwsSUFBZSxFQUE3QjtBQUNBLFFBQUlJLFdBQVcsS0FBS0osTUFBTCxDQUFZbkQsU0FBWixLQUEwQixFQUF6QztBQUFBLFFBQ0lya0IsSUFBSSxDQURSO0FBRUEsV0FBT0EsSUFBSTRuQixTQUFTM25CLE1BQXBCLEVBQTRCRCxHQUE1QixFQUFpQztBQUMvQjRuQixlQUFTNW5CLENBQVQsRUFBWTBLLElBQVosQ0FBaUIsSUFBakIsRUFBdUJpZCxPQUF2QjtBQUNEO0FBQ0QsV0FBTyxJQUFQO0FBQ0QsR0FwQjBDOztBQXNCM0NFLGlCQUFlLFNBQVNBLGFBQVQsQ0FBdUJ4RCxTQUF2QixFQUFrQ2tELE9BQWxDLEVBQTJDO0FBQ3hELFNBQUtDLE1BQUwsR0FBYyxLQUFLQSxNQUFMLElBQWUsRUFBN0I7QUFDQSxRQUFJeG5CLElBQUksQ0FBUjtBQUFBLFFBQ0k0bkIsUUFESjtBQUFBLFFBRUlFLFdBRko7QUFHQSxRQUFJekQsU0FBSixFQUFlO0FBQ2J1RCxpQkFBVyxLQUFLSixNQUFMLENBQVluRCxTQUFaLEtBQTBCLEVBQXJDLEVBQXlDeUQsY0FBYyxFQUF2RDtBQUNBLGFBQU85bkIsSUFBSTRuQixTQUFTM25CLE1BQXBCLEVBQTRCRCxHQUE1QixFQUFpQztBQUMvQixZQUFJNG5CLFNBQVM1bkIsQ0FBVCxNQUFnQnVuQixPQUFoQixJQUEyQkEsT0FBL0IsRUFBd0M7QUFDdENPLHNCQUFZbGxCLElBQVosQ0FBaUJnbEIsU0FBUzVuQixDQUFULENBQWpCO0FBQ0Q7QUFDRjtBQUNELFdBQUt3bkIsTUFBTCxDQUFZbkQsU0FBWixJQUF5QnlELFdBQXpCO0FBQ0QsS0FSRCxNQVFPO0FBQ0w7QUFDQSxXQUFLTixNQUFMLEdBQWMsRUFBZDtBQUNEO0FBQ0QsV0FBTyxJQUFQO0FBQ0Q7QUF4QzBDLENBRGYsQ0FBNUIsQ0EwQ0MzcEIsVUFBVU0sSUFBVixDQUFlNmpCLE1BQWYsR0FBd0IsVUFBVXRrQixHQUFWLEVBQWU7QUFDeEMsU0FBTztBQUNMOzs7OztBQUtBcXFCLFdBQU8sU0FBU0EsS0FBVCxDQUFlQyxRQUFmLEVBQXlCO0FBQzlCLFdBQUssSUFBSWhvQixDQUFULElBQWNnb0IsUUFBZCxFQUF3QjtBQUN0QnRxQixZQUFJc0MsQ0FBSixJQUFTZ29CLFNBQVNob0IsQ0FBVCxDQUFUO0FBQ0Q7QUFDRCxhQUFPLElBQVA7QUFDRCxLQVhJOztBQWFMbW5CLFNBQUssU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU96cEIsR0FBUDtBQUNELEtBZkk7O0FBaUJMOzs7OztBQUtBNFQsV0FBTyxTQUFTQSxLQUFULEdBQWlCO0FBQ3RCLFVBQUkyVyxTQUFTLEVBQWI7QUFBQSxVQUNJam9CLENBREo7QUFFQSxXQUFLQSxDQUFMLElBQVV0QyxHQUFWLEVBQWU7QUFDYnVxQixlQUFPam9CLENBQVAsSUFBWXRDLElBQUlzQyxDQUFKLENBQVo7QUFDRDtBQUNELGFBQU9pb0IsTUFBUDtBQUNELEtBN0JJOztBQStCTDs7Ozs7QUFLQUMsYUFBUyxTQUFTQSxPQUFULEdBQW1CO0FBQzFCLGFBQU9uRyxPQUFPbmtCLFNBQVAsQ0FBaUJvTSxRQUFqQixDQUEwQlUsSUFBMUIsQ0FBK0JoTixHQUEvQixNQUF3QyxnQkFBL0M7QUFDRDtBQXRDSSxHQUFQO0FBd0NELENBekNFLENBeUNELENBQUMsWUFBWTtBQUNiLE1BQUl5cUIsb0JBQW9CLE1BQXhCO0FBQUEsTUFDSUMsa0JBQWtCLE1BRHRCO0FBRUF2cUIsWUFBVU0sSUFBVixDQUFla3FCLE1BQWYsR0FBd0IsVUFBVUMsR0FBVixFQUFlO0FBQ3JDQSxVQUFNbEcsT0FBT2tHLEdBQVAsQ0FBTjtBQUNBLFdBQU87QUFDTDs7Ozs7QUFLQUMsWUFBTSxTQUFTQSxJQUFULEdBQWdCO0FBQ3BCLGVBQU9ELElBQUl4UCxPQUFKLENBQVlxUCxpQkFBWixFQUErQixFQUEvQixFQUFtQ3JQLE9BQW5DLENBQTJDc1AsZUFBM0MsRUFBNEQsRUFBNUQsQ0FBUDtBQUNELE9BUkk7O0FBVUw7Ozs7O0FBS0FJLG1CQUFhLFNBQVNBLFdBQVQsQ0FBcUJDLElBQXJCLEVBQTJCO0FBQ3RDLGFBQUssSUFBSXpvQixDQUFULElBQWN5b0IsSUFBZCxFQUFvQjtBQUNsQkgsZ0JBQU0sS0FBS3hQLE9BQUwsQ0FBYSxPQUFPOVksQ0FBUCxHQUFXLEdBQXhCLEVBQTZCMG9CLEVBQTdCLENBQWdDRCxLQUFLem9CLENBQUwsQ0FBaEMsQ0FBTjtBQUNEO0FBQ0QsZUFBT3NvQixHQUFQO0FBQ0QsT0FwQkk7O0FBc0JMOzs7OztBQUtBeFAsZUFBUyxTQUFTQSxPQUFULENBQWlCNlAsTUFBakIsRUFBeUI7QUFDaEMsZUFBTztBQUNMRCxjQUFJLFNBQVNBLEVBQVQsQ0FBWTVQLE9BQVosRUFBcUI7QUFDdkIsbUJBQU93UCxJQUFJTSxLQUFKLENBQVVELE1BQVYsRUFBa0JwYyxJQUFsQixDQUF1QnVNLE9BQXZCLENBQVA7QUFDRDtBQUhJLFNBQVA7QUFLRDtBQWpDSSxLQUFQO0FBbUNELEdBckNEO0FBc0NELENBekNDLEksQ0F5Q0k7Ozs7Ozs7Ozs7QUFVTixDQUFDLFVBQVVqYixTQUFWLEVBQXFCO0FBQ3BCLE1BQUk7OztBQUdKZ3JCLG1CQUFpQmhyQixVQUFVTSxJQUFWLENBQWUyb0IsS0FBZixDQUFxQixDQUFDLE1BQUQsRUFBUyxLQUFULEVBQWdCLEdBQWhCLEVBQXFCLFFBQXJCLEVBQStCLE1BQS9CLEVBQXVDLE9BQXZDLEVBQWdELE9BQWhELENBQXJCLENBSGpCOzs7QUFLQTs7Ozs7Ozs7OztBQVVBZ0MsZ0JBQWMsbUNBZmQ7QUFBQSxNQWdCSUMsd0JBQXdCLG1CQWhCNUI7QUFBQSxNQWlCSUMscUJBQXFCLEdBakJ6QjtBQUFBLE1Ba0JJQyxXQUFXLEVBQUUsS0FBSyxHQUFQLEVBQVksS0FBSyxHQUFqQixFQUFzQixLQUFLLEdBQTNCLEVBbEJmOztBQW9CQSxXQUFTQyxRQUFULENBQWtCL0ksT0FBbEIsRUFBMkI7QUFDekIsUUFBSWdKLDhCQUE4QmhKLE9BQTlCLENBQUosRUFBNEM7QUFDMUMsYUFBT0EsT0FBUDtBQUNEOztBQUVELFFBQUlBLFlBQVlBLFFBQVF4WixhQUFSLENBQXNCd0osZUFBdEMsRUFBdUQ7QUFDckRnUSxnQkFBVUEsUUFBUXhaLGFBQVIsQ0FBc0J4RSxJQUFoQztBQUNEOztBQUVELFdBQU9pbkIsV0FBV2pKLE9BQVgsQ0FBUDtBQUNEOztBQUVEOzs7O0FBSUEsV0FBU2tKLG1CQUFULENBQTZCZixHQUE3QixFQUFrQztBQUNoQyxXQUFPQSxJQUFJeFAsT0FBSixDQUFZZ1EsV0FBWixFQUF5QixVQUFVOUYsS0FBVixFQUFpQnNHLEdBQWpCLEVBQXNCO0FBQ3BELFVBQUlDLGNBQWMsQ0FBQ0QsSUFBSXRHLEtBQUosQ0FBVStGLHFCQUFWLEtBQW9DLEVBQXJDLEVBQXlDLENBQXpDLEtBQStDLEVBQWpFO0FBQUEsVUFDSVMsVUFBVVAsU0FBU00sV0FBVCxDQURkO0FBRUFELFlBQU1BLElBQUl4USxPQUFKLENBQVlpUSxxQkFBWixFQUFtQyxFQUFuQyxDQUFOOztBQUVBLFVBQUlPLElBQUlWLEtBQUosQ0FBVVksT0FBVixFQUFtQnZwQixNQUFuQixHQUE0QnFwQixJQUFJVixLQUFKLENBQVVXLFdBQVYsRUFBdUJ0cEIsTUFBdkQsRUFBK0Q7QUFDN0RxcEIsY0FBTUEsTUFBTUMsV0FBWjtBQUNBQSxzQkFBYyxFQUFkO0FBQ0Q7QUFDRCxVQUFJRSxVQUFVSCxHQUFkO0FBQUEsVUFDSUksYUFBYUosR0FEakI7QUFFQSxVQUFJQSxJQUFJcnBCLE1BQUosR0FBYStvQixrQkFBakIsRUFBcUM7QUFDbkNVLHFCQUFhQSxXQUFXQyxNQUFYLENBQWtCLENBQWxCLEVBQXFCWCxrQkFBckIsSUFBMkMsS0FBeEQ7QUFDRDtBQUNEO0FBQ0EsVUFBSVMsUUFBUUUsTUFBUixDQUFlLENBQWYsRUFBa0IsQ0FBbEIsTUFBeUIsTUFBN0IsRUFBcUM7QUFDbkNGLGtCQUFVLFlBQVlBLE9BQXRCO0FBQ0Q7O0FBRUQsYUFBTyxjQUFjQSxPQUFkLEdBQXdCLElBQXhCLEdBQStCQSxPQUEvQixHQUF5QyxNQUF6QyxHQUFrREYsV0FBekQ7QUFDRCxLQXBCTSxDQUFQO0FBcUJEOztBQUVEOzs7O0FBSUEsV0FBU0ssZUFBVCxDQUF5QjFILE9BQXpCLEVBQWtDO0FBQ2hDLFFBQUkySCxjQUFjM0gsUUFBUTRILHNCQUExQjtBQUNBLFFBQUksQ0FBQ0QsV0FBTCxFQUFrQjtBQUNoQkEsb0JBQWMzSCxRQUFRNEgsc0JBQVIsR0FBaUM1SCxRQUFRaGUsYUFBUixDQUFzQixLQUF0QixDQUEvQztBQUNEO0FBQ0QsV0FBTzJsQixXQUFQO0FBQ0Q7O0FBRUQ7OztBQUdBLFdBQVNFLGtCQUFULENBQTRCNWxCLFFBQTVCLEVBQXNDO0FBQ3BDLFFBQUlXLGFBQWFYLFNBQVNXLFVBQTFCO0FBQUEsUUFDSStrQixjQUFjRCxnQkFBZ0I5a0IsV0FBVzZCLGFBQTNCLENBRGxCOztBQUdBO0FBQ0E7QUFDQWtqQixnQkFBWTdaLFNBQVosR0FBd0Isa0JBQWtCcVosb0JBQW9CbGxCLFNBQVNtRSxJQUE3QixDQUExQztBQUNBdWhCLGdCQUFZaGMsV0FBWixDQUF3QmdjLFlBQVk3aEIsVUFBcEM7O0FBRUEsV0FBTzZoQixZQUFZN2hCLFVBQW5CLEVBQStCO0FBQzdCO0FBQ0FsRCxpQkFBV3FCLFlBQVgsQ0FBd0IwakIsWUFBWTdoQixVQUFwQyxFQUFnRDdELFFBQWhEO0FBQ0Q7QUFDRFcsZUFBVytJLFdBQVgsQ0FBdUIxSixRQUF2QjtBQUNEOztBQUVELFdBQVNnbEIsNkJBQVQsQ0FBdUMxa0IsSUFBdkMsRUFBNkM7QUFDM0MsUUFBSWdFLFFBQUo7QUFDQSxXQUFPaEUsS0FBS0ssVUFBWixFQUF3QjtBQUN0QkwsYUFBT0EsS0FBS0ssVUFBWjtBQUNBMkQsaUJBQVdoRSxLQUFLZ0UsUUFBaEI7QUFDQSxVQUFJb2dCLGVBQWVoVixRQUFmLENBQXdCcEwsUUFBeEIsQ0FBSixFQUF1QztBQUNyQyxlQUFPLElBQVA7QUFDRCxPQUZELE1BRU8sSUFBSUEsYUFBYSxNQUFqQixFQUF5QjtBQUM5QixlQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0QsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsV0FBUzJnQixVQUFULENBQW9CakosT0FBcEIsRUFBNkI7QUFDM0IsUUFBSTBJLGVBQWVoVixRQUFmLENBQXdCc00sUUFBUTFYLFFBQWhDLENBQUosRUFBK0M7QUFDN0M7QUFDRDs7QUFFRCxRQUFJMFgsUUFBUXBiLFFBQVIsS0FBcUJsSCxVQUFVWSxTQUEvQixJQUE0QzBoQixRQUFRN1gsSUFBUixDQUFhMGEsS0FBYixDQUFtQjhGLFdBQW5CLENBQWhELEVBQWlGO0FBQy9FaUIseUJBQW1CNUosT0FBbkI7QUFDQTtBQUNEOztBQUVELFFBQUloYixhQUFhdEgsVUFBVU0sSUFBVixDQUFlMm9CLEtBQWYsQ0FBcUIzRyxRQUFRaGIsVUFBN0IsRUFBeUNnaUIsR0FBekMsRUFBakI7QUFBQSxRQUNJNkMsbUJBQW1CN2tCLFdBQVdsRixNQURsQztBQUFBLFFBRUlELElBQUksQ0FGUjs7QUFJQSxXQUFPQSxJQUFJZ3FCLGdCQUFYLEVBQTZCaHFCLEdBQTdCLEVBQWtDO0FBQ2hDb3BCLGlCQUFXamtCLFdBQVduRixDQUFYLENBQVg7QUFDRDs7QUFFRCxXQUFPbWdCLE9BQVA7QUFDRDs7QUFFRHRpQixZQUFVRyxHQUFWLENBQWNrckIsUUFBZCxHQUF5QkEsUUFBekI7O0FBRUE7QUFDQXJyQixZQUFVRyxHQUFWLENBQWNrckIsUUFBZCxDQUF1QkosV0FBdkIsR0FBcUNBLFdBQXJDO0FBQ0QsQ0FuSUQsRUFtSUdqckIsU0FuSUgsRUFtSWMsQ0FBQyxVQUFVQSxTQUFWLEVBQXFCO0FBQ2xDLE1BQUl1b0Isb0JBQW9Cdm9CLFVBQVV3a0IsT0FBVixDQUFrQitELGlCQUFsQixFQUF4QjtBQUFBLE1BQ0k3bEIsTUFBTTFDLFVBQVVHLEdBRHBCOztBQUdBdUMsTUFBSTBwQixRQUFKLEdBQWUsVUFBVTlKLE9BQVYsRUFBbUIrSixTQUFuQixFQUE4QjtBQUMzQyxRQUFJOUQsaUJBQUosRUFBdUI7QUFDckIsYUFBT2pHLFFBQVFnSyxTQUFSLENBQWtCNUwsR0FBbEIsQ0FBc0IyTCxTQUF0QixDQUFQO0FBQ0Q7QUFDRCxRQUFJM3BCLElBQUk2cEIsUUFBSixDQUFhakssT0FBYixFQUFzQitKLFNBQXRCLENBQUosRUFBc0M7QUFDcEM7QUFDRDtBQUNEL0osWUFBUStKLFNBQVIsSUFBcUIsTUFBTUEsU0FBM0I7QUFDRCxHQVJEOztBQVVBM3BCLE1BQUk4cEIsV0FBSixHQUFrQixVQUFVbEssT0FBVixFQUFtQitKLFNBQW5CLEVBQThCO0FBQzlDLFFBQUk5RCxpQkFBSixFQUF1QjtBQUNyQixhQUFPakcsUUFBUWdLLFNBQVIsQ0FBa0JyZSxNQUFsQixDQUF5Qm9lLFNBQXpCLENBQVA7QUFDRDs7QUFFRC9KLFlBQVErSixTQUFSLEdBQW9CL0osUUFBUStKLFNBQVIsQ0FBa0JwUixPQUFsQixDQUEwQixJQUFJeE0sTUFBSixDQUFXLGFBQWE0ZCxTQUFiLEdBQXlCLFVBQXBDLENBQTFCLEVBQTJFLEdBQTNFLENBQXBCO0FBQ0QsR0FORDs7QUFRQTNwQixNQUFJNnBCLFFBQUosR0FBZSxVQUFVakssT0FBVixFQUFtQitKLFNBQW5CLEVBQThCO0FBQzNDLFFBQUk5RCxpQkFBSixFQUF1QjtBQUNyQixhQUFPakcsUUFBUWdLLFNBQVIsQ0FBa0J0VyxRQUFsQixDQUEyQnFXLFNBQTNCLENBQVA7QUFDRDs7QUFFRCxRQUFJSSxtQkFBbUJuSyxRQUFRK0osU0FBL0I7QUFDQSxXQUFPSSxpQkFBaUJycUIsTUFBakIsR0FBMEIsQ0FBMUIsS0FBZ0NxcUIsb0JBQW9CSixTQUFwQixJQUFpQyxJQUFJNWQsTUFBSixDQUFXLFlBQVk0ZCxTQUFaLEdBQXdCLFNBQW5DLEVBQThDeGQsSUFBOUMsQ0FBbUQ0ZCxnQkFBbkQsQ0FBakUsQ0FBUDtBQUNELEdBUEQ7QUFRRCxDQTlCYSxFQThCWHpzQixTQTlCVztBQStCZEEsVUFBVUcsR0FBVixDQUFjNlYsUUFBZCxHQUF5QixZQUFZO0FBQ25DLE1BQUkxRCxrQkFBa0JuTyxTQUFTbU8sZUFBL0I7QUFDQSxNQUFJQSxnQkFBZ0IwRCxRQUFwQixFQUE4QjtBQUM1QixXQUFPLFVBQVVyQixTQUFWLEVBQXFCMk4sT0FBckIsRUFBOEI7QUFDbkMsVUFBSUEsUUFBUXBiLFFBQVIsS0FBcUJsSCxVQUFVVyxZQUFuQyxFQUFpRDtBQUMvQzJoQixrQkFBVUEsUUFBUXJiLFVBQWxCO0FBQ0Q7QUFDRCxhQUFPME4sY0FBYzJOLE9BQWQsSUFBeUIzTixVQUFVcUIsUUFBVixDQUFtQnNNLE9BQW5CLENBQWhDO0FBQ0QsS0FMRDtBQU1ELEdBUEQsTUFPTyxJQUFJaFEsZ0JBQWdCb2EsdUJBQXBCLEVBQTZDO0FBQ2xELFdBQU8sVUFBVS9YLFNBQVYsRUFBcUIyTixPQUFyQixFQUE4QjtBQUNuQztBQUNBLGFBQU8sQ0FBQyxFQUFFM04sVUFBVStYLHVCQUFWLENBQWtDcEssT0FBbEMsSUFBNkMsRUFBL0MsQ0FBUjtBQUNELEtBSEQ7QUFJRDtBQUNGLENBZndCLEVBQXpCLEMsQ0FlSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkx0aUIsVUFBVUcsR0FBVixDQUFjd3NCLGFBQWQsR0FBOEIsWUFBWTtBQUN4QyxXQUFTQyxlQUFULENBQXlCNWpCLEdBQXpCLEVBQThCNmpCLElBQTlCLEVBQW9DO0FBQ2xDLFFBQUlDLFdBQVc5akIsSUFBSTNDLGFBQUosQ0FBa0IsSUFBbEIsQ0FBZjtBQUNBd21CLFNBQUt0a0IsV0FBTCxDQUFpQnVrQixRQUFqQjtBQUNBLFdBQU9BLFFBQVA7QUFDRDs7QUFFRCxXQUFTQyxXQUFULENBQXFCL2pCLEdBQXJCLEVBQTBCeUQsSUFBMUIsRUFBZ0M7QUFDOUIsV0FBT3pELElBQUkzQyxhQUFKLENBQWtCb0csSUFBbEIsQ0FBUDtBQUNEOztBQUVELFdBQVNrZ0IsYUFBVCxDQUF1QnJLLE9BQXZCLEVBQWdDMEssUUFBaEMsRUFBMEM7QUFDeEMsUUFBSTFLLFFBQVExWCxRQUFSLEtBQXFCLElBQXJCLElBQTZCMFgsUUFBUTFYLFFBQVIsS0FBcUIsSUFBbEQsSUFBMEQwWCxRQUFRMVgsUUFBUixLQUFxQixNQUFuRixFQUEyRjtBQUN6RjtBQUNBLGFBQU8wWCxPQUFQO0FBQ0Q7O0FBRUQsUUFBSXRaLE1BQU1zWixRQUFReFosYUFBbEI7QUFBQSxRQUNJK2pCLE9BQU9FLFlBQVkvakIsR0FBWixFQUFpQmdrQixRQUFqQixDQURYO0FBQUEsUUFFSUMsYUFBYTNLLFFBQVF1RCxnQkFBUixDQUF5QixJQUF6QixDQUZqQjtBQUFBLFFBR0lxSCxtQkFBbUJELFdBQVc3cUIsTUFIbEM7QUFBQSxRQUlJa0YsVUFKSjtBQUFBLFFBS0k2a0IsZ0JBTEo7QUFBQSxRQU1JZ0IsU0FOSjtBQUFBLFFBT0lDLFNBUEo7QUFBQSxRQVFJbm1CLFVBUko7QUFBQSxRQVNJb21CLGNBVEo7QUFBQSxRQVVJQyxXQVZKO0FBQUEsUUFXSUMsZUFYSjtBQUFBLFFBWUlwckIsQ0FaSjs7QUFjQTtBQUNBLFNBQUtBLElBQUksQ0FBVCxFQUFZQSxJQUFJK3FCLGdCQUFoQixFQUFrQy9xQixHQUFsQyxFQUF1QztBQUNyQ2lyQixrQkFBWUgsV0FBVzlxQixDQUFYLENBQVo7QUFDQSxhQUFPLENBQUM4RSxhQUFhbW1CLFVBQVVubUIsVUFBeEIsS0FBdUNBLGVBQWVxYixPQUF0RCxJQUFpRXJiLFdBQVdnTixTQUFYLEtBQXlCbVosU0FBakcsRUFBNEc7QUFDMUcsWUFBSXB0QixVQUFVRyxHQUFWLENBQWNxdEIsUUFBZCxDQUF1QixTQUF2QixFQUFrQ0MsSUFBbEMsQ0FBdUN4bUIsVUFBdkMsTUFBdUQsT0FBM0QsRUFBb0U7QUFDbEVBLHFCQUFXK0ksV0FBWCxDQUF1Qm9kLFNBQXZCO0FBQ0E7QUFDRDtBQUNEcHRCLGtCQUFVRyxHQUFWLENBQWN1dEIsTUFBZCxDQUFxQk4sU0FBckIsRUFBZ0NPLEtBQWhDLENBQXNDUCxVQUFVbm1CLFVBQWhEO0FBQ0Q7QUFDRjs7QUFFREssaUJBQWF0SCxVQUFVTSxJQUFWLENBQWUyb0IsS0FBZixDQUFxQjNHLFFBQVFoYixVQUE3QixFQUF5Q2dpQixHQUF6QyxFQUFiO0FBQ0E2Qyx1QkFBbUI3a0IsV0FBV2xGLE1BQTlCOztBQUVBLFNBQUtELElBQUksQ0FBVCxFQUFZQSxJQUFJZ3FCLGdCQUFoQixFQUFrQ2hxQixHQUFsQyxFQUF1QztBQUNyQ29yQix3QkFBa0JBLG1CQUFtQlgsZ0JBQWdCNWpCLEdBQWhCLEVBQXFCNmpCLElBQXJCLENBQXJDO0FBQ0FNLGtCQUFZN2xCLFdBQVduRixDQUFYLENBQVo7QUFDQWtyQix1QkFBaUJydEIsVUFBVUcsR0FBVixDQUFjcXRCLFFBQWQsQ0FBdUIsU0FBdkIsRUFBa0NDLElBQWxDLENBQXVDTixTQUF2QyxNQUFzRCxPQUF2RTtBQUNBRyxvQkFBY0gsVUFBVXZpQixRQUFWLEtBQXVCLElBQXJDOztBQUVBLFVBQUl5aUIsY0FBSixFQUFvQjtBQUNsQjtBQUNBRSwwQkFBa0JBLGdCQUFnQnBqQixVQUFoQixHQUE2QnlpQixnQkFBZ0I1akIsR0FBaEIsRUFBcUI2akIsSUFBckIsQ0FBN0IsR0FBMERVLGVBQTVFO0FBQ0FBLHdCQUFnQmhsQixXQUFoQixDQUE0QjRrQixTQUE1QjtBQUNBSSwwQkFBa0IsSUFBbEI7QUFDQTtBQUNEOztBQUVELFVBQUlELFdBQUosRUFBaUI7QUFDZjtBQUNBQywwQkFBa0JBLGdCQUFnQnBqQixVQUFoQixHQUE2QixJQUE3QixHQUFvQ29qQixlQUF0RDtBQUNBO0FBQ0Q7O0FBRURBLHNCQUFnQmhsQixXQUFoQixDQUE0QjRrQixTQUE1QjtBQUNEOztBQUVEN0ssWUFBUXJiLFVBQVIsQ0FBbUIybUIsWUFBbkIsQ0FBZ0NmLElBQWhDLEVBQXNDdkssT0FBdEM7QUFDQSxXQUFPdUssSUFBUDtBQUNEOztBQUVELFNBQU9GLGFBQVA7QUFDRCxDQTFFNkIsRUFBOUIsQyxDQTBFSzs7Ozs7Ozs7Ozs7Ozs7O0FBZUwzc0IsVUFBVUcsR0FBVixDQUFjMHRCLGNBQWQsR0FBK0IsVUFBVUMsZ0JBQVYsRUFBNEI7QUFDekQsU0FBTztBQUNMTCxVQUFNLFNBQVNBLElBQVQsQ0FBY00saUJBQWQsRUFBaUM7QUFDckMsYUFBTztBQUNMQyxZQUFJLFNBQVNBLEVBQVQsQ0FBWUMsZUFBWixFQUE2QjtBQUMvQixjQUFJQyxTQUFKO0FBQUEsY0FDSS9yQixJQUFJLENBRFI7QUFBQSxjQUVJQyxTQUFTMHJCLGlCQUFpQjFyQixNQUY5QjtBQUdBLGlCQUFPRCxJQUFJQyxNQUFYLEVBQW1CRCxHQUFuQixFQUF3QjtBQUN0QityQix3QkFBWUosaUJBQWlCM3JCLENBQWpCLENBQVo7QUFDQSxnQkFBSSxPQUFPNHJCLGtCQUFrQkcsU0FBbEIsQ0FBUCxLQUF3QyxXQUF4QyxJQUF1REgsa0JBQWtCRyxTQUFsQixNQUFpQyxFQUE1RixFQUFnRztBQUM5RkQsOEJBQWdCQyxTQUFoQixJQUE2Qkgsa0JBQWtCRyxTQUFsQixDQUE3QjtBQUNEO0FBQ0Y7QUFDRCxpQkFBTyxFQUFFQyxPQUFPNUssVUFBVTZLLE1BQW5CLEVBQVA7QUFDRDtBQVpJLE9BQVA7QUFjRDtBQWhCSSxHQUFQO0FBa0JELENBbkJELEMsQ0FtQkc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkgsQ0FBQyxVQUFVanVCLEdBQVYsRUFBZTs7QUFFZDs7Ozs7QUFLQSxNQUFJa3VCLHdCQUF3QixDQUFDLG9CQUFELEVBQXVCLGlCQUF2QixFQUEwQyxnQkFBMUMsRUFBNEQsWUFBNUQsQ0FBNUI7O0FBRUEsTUFBSUMsaUNBQWlDLFNBQVNBLDhCQUFULENBQXdDaE0sT0FBeEMsRUFBaUQ7QUFDcEYsUUFBSWlNLHNCQUFzQmpNLE9BQXRCLENBQUosRUFBb0M7QUFDbEMsYUFBT2tNLFNBQVNydUIsSUFBSXF0QixRQUFKLENBQWEsT0FBYixFQUFzQkMsSUFBdEIsQ0FBMkJuTCxPQUEzQixDQUFULEVBQThDLEVBQTlDLElBQW9EQSxRQUFRbU0sV0FBbkU7QUFDRDtBQUNELFdBQU8sS0FBUDtBQUNELEdBTEQ7O0FBT0EsTUFBSUYsd0JBQXdCLFNBQVNBLHFCQUFULENBQStCak0sT0FBL0IsRUFBd0M7QUFDbEUsUUFBSW5nQixJQUFJLENBQVI7QUFBQSxRQUNJQyxTQUFTaXNCLHNCQUFzQmpzQixNQURuQztBQUVBLFdBQU9ELElBQUlDLE1BQVgsRUFBbUJELEdBQW5CLEVBQXdCO0FBQ3RCLFVBQUloQyxJQUFJcXRCLFFBQUosQ0FBYWEsc0JBQXNCbHNCLENBQXRCLENBQWIsRUFBdUNzckIsSUFBdkMsQ0FBNENuTCxPQUE1QyxNQUF5RCxZQUE3RCxFQUEyRTtBQUN6RSxlQUFPK0wsc0JBQXNCbHNCLENBQXRCLENBQVA7QUFDRDtBQUNGO0FBQ0YsR0FSRDs7QUFVQWhDLE1BQUl1dUIsVUFBSixHQUFpQixVQUFVQyxZQUFWLEVBQXdCO0FBQ3ZDLFdBQU87QUFDTGxCLFlBQU0sU0FBU0EsSUFBVCxDQUFjbkwsT0FBZCxFQUF1QjtBQUMzQixZQUFJZ00sK0JBQStCaE0sT0FBL0IsQ0FBSixFQUE2QztBQUMzQ3FNLHlCQUFlM3VCLFVBQVVNLElBQVYsQ0FBZTJvQixLQUFmLENBQXFCMEYsWUFBckIsRUFBbUN4RixPQUFuQyxDQUEyQ2tGLHFCQUEzQyxDQUFmO0FBQ0Q7O0FBRUQsWUFBSU8sVUFBVSxFQUFkO0FBQUEsWUFDSXhzQixTQUFTdXNCLGFBQWF2c0IsTUFEMUI7QUFBQSxZQUVJRCxJQUFJLENBRlI7QUFBQSxZQUdJMG1CLFFBSEo7QUFJQSxlQUFPMW1CLElBQUlDLE1BQVgsRUFBbUJELEdBQW5CLEVBQXdCO0FBQ3RCMG1CLHFCQUFXOEYsYUFBYXhzQixDQUFiLENBQVg7QUFDQXlzQixxQkFBVy9GLFdBQVcsR0FBWCxHQUFpQjFvQixJQUFJcXRCLFFBQUosQ0FBYTNFLFFBQWIsRUFBdUI0RSxJQUF2QixDQUE0Qm5MLE9BQTVCLENBQWpCLEdBQXdELEdBQW5FO0FBQ0Q7O0FBRUQsZUFBTztBQUNMMEwsY0FBSSxTQUFTQSxFQUFULENBQVkxTCxPQUFaLEVBQXFCO0FBQ3ZCLGdCQUFJdU0sV0FBVyxZQUFmO0FBQ0EsZ0JBQUlELFFBQVF6SixLQUFSLENBQWMwSixRQUFkLEtBQTJCdk0sT0FBL0IsRUFBd0M7QUFDdEN1SyxxQkFBTytCLFFBQVE3RCxLQUFSLENBQWM4RCxRQUFkLENBQVA7QUFDQUMsdUJBQVNOLFNBQVMzQixLQUFLLENBQUwsQ0FBVCxFQUFrQixFQUFsQixDQUFUO0FBQ0Esa0JBQUl2SyxRQUFReU0sWUFBUixHQUF1QkQsTUFBM0IsRUFBbUM7QUFDakNGLDBCQUFVL0IsS0FBSyxDQUFMLElBQVUsU0FBVixHQUFzQnZLLFFBQVF5TSxZQUE5QixHQUE2QyxLQUF2RDtBQUNEO0FBQ0Y7QUFDRDV1QixnQkFBSTZ1QixTQUFKLENBQWNKLE9BQWQsRUFBdUJoRixFQUF2QixDQUEwQnRILE9BQTFCO0FBQ0EsbUJBQU8sRUFBRTZMLE9BQU81SyxVQUFVNkssTUFBbkIsRUFBUDtBQUNEO0FBWkksU0FBUDtBQWNEO0FBN0JJLEtBQVA7QUErQkQsR0FoQ0Q7QUFpQ0QsQ0EzREQsRUEyREdwdUIsVUFBVUcsR0EzRGIsRSxDQTJEbUI7Ozs7Ozs7O0FBUW5CLENBQUMsVUFBVUgsU0FBVixFQUFxQjs7QUFFcEJBLFlBQVVHLEdBQVYsQ0FBYzh1QixRQUFkLEdBQXlCLFVBQVV0YSxTQUFWLEVBQXFCdWEsUUFBckIsRUFBK0IxSSxTQUEvQixFQUEwQ2tELE9BQTFDLEVBQW1EO0FBQzFFLFdBQU8xcEIsVUFBVUcsR0FBVixDQUFjc3BCLE9BQWQsQ0FBc0I5VSxTQUF0QixFQUFpQzZSLFNBQWpDLEVBQTRDLFVBQVUySSxLQUFWLEVBQWlCO0FBQ2xFLFVBQUlyaUIsU0FBU3FpQixNQUFNcmlCLE1BQW5CO0FBQUEsVUFDSXFZLFFBQVFubEIsVUFBVU0sSUFBVixDQUFlMm9CLEtBQWYsQ0FBcUJ0VSxVQUFVa1IsZ0JBQVYsQ0FBMkJxSixRQUEzQixDQUFyQixDQURaOztBQUdBLGFBQU9waUIsVUFBVUEsV0FBVzZILFNBQTVCLEVBQXVDO0FBQ3JDLFlBQUl3USxNQUFNblAsUUFBTixDQUFlbEosTUFBZixDQUFKLEVBQTRCO0FBQzFCNGMsa0JBQVE3YyxJQUFSLENBQWFDLE1BQWIsRUFBcUJxaUIsS0FBckI7QUFDQTtBQUNEO0FBQ0RyaUIsaUJBQVNBLE9BQU83RixVQUFoQjtBQUNEO0FBQ0YsS0FYTSxDQUFQO0FBWUQsR0FiRDtBQWNELENBaEJELEVBZ0JHakgsU0FoQkgsRSxDQWdCZTs7Ozs7Ozs7Ozs7O0FBWWZBLFVBQVVHLEdBQVYsQ0FBY2l2QixRQUFkLEdBQXlCLFlBQVk7O0FBRW5DLE1BQUlDLGlCQUFpQixTQUFTQSxjQUFULENBQXdCN00sSUFBeEIsRUFBOEI2QixPQUE5QixFQUF1QztBQUMxRCxRQUFJMkgsY0FBYzNILFFBQVFoZSxhQUFSLENBQXNCLEtBQXRCLENBQWxCO0FBQ0EybEIsZ0JBQVlzRCxLQUFaLENBQWtCQyxPQUFsQixHQUE0QixNQUE1QjtBQUNBbEwsWUFBUS9mLElBQVIsQ0FBYWlFLFdBQWIsQ0FBeUJ5akIsV0FBekI7QUFDQTtBQUNBLFFBQUk7QUFDRkEsa0JBQVk3WixTQUFaLEdBQXdCcVEsSUFBeEI7QUFDRCxLQUZELENBRUUsT0FBT3pjLENBQVAsRUFBVSxDQUFFO0FBQ2RzZSxZQUFRL2YsSUFBUixDQUFhMEwsV0FBYixDQUF5QmdjLFdBQXpCO0FBQ0EsV0FBT0EsV0FBUDtBQUNELEdBVkQ7O0FBWUE7OztBQUdBLE1BQUl3RCw0QkFBNEIsU0FBU0EseUJBQVQsQ0FBbUNuTCxPQUFuQyxFQUE0QztBQUMxRSxRQUFJQSxRQUFRb0wsNEJBQVosRUFBMEM7QUFDeEM7QUFDRDtBQUNELFNBQUssSUFBSXR0QixJQUFJLENBQVIsRUFBV0MsU0FBU3N0QixlQUFldHRCLE1BQXhDLEVBQWdERCxJQUFJQyxNQUFwRCxFQUE0REQsR0FBNUQsRUFBaUU7QUFDL0RraUIsY0FBUWhlLGFBQVIsQ0FBc0JxcEIsZUFBZXZ0QixDQUFmLENBQXRCO0FBQ0Q7QUFDRGtpQixZQUFRb0wsNEJBQVIsR0FBdUMsSUFBdkM7QUFDRCxHQVJEOztBQVVBOzs7O0FBSUEsTUFBSUMsaUJBQWlCLENBQUMsTUFBRCxFQUFTLFNBQVQsRUFBb0IsT0FBcEIsRUFBNkIsT0FBN0IsRUFBc0MsS0FBdEMsRUFBNkMsUUFBN0MsRUFBdUQsU0FBdkQsRUFBa0UsVUFBbEUsRUFBOEUsU0FBOUUsRUFBeUYsWUFBekYsRUFBdUcsUUFBdkcsRUFBaUgsUUFBakgsRUFBMkgsUUFBM0gsRUFBcUksUUFBckksRUFBK0ksUUFBL0ksRUFBeUosTUFBekosRUFBaUssT0FBakssRUFBMEssS0FBMUssRUFBaUwsUUFBakwsRUFBMkwsVUFBM0wsRUFBdU0sSUFBdk0sRUFBNk0sSUFBN00sRUFBbU4sTUFBbk4sRUFBMk4sS0FBM04sRUFBa08sU0FBbE8sRUFBNk8sUUFBN08sRUFBdVAsU0FBdlAsRUFBa1EsTUFBbFEsRUFBMFEsT0FBMVEsRUFBbVIsT0FBblIsRUFBNFIsS0FBNVIsQ0FBckI7O0FBRUEsU0FBTyxVQUFVbE4sSUFBVixFQUFnQjZCLE9BQWhCLEVBQXlCO0FBQzlCQSxjQUFVQSxXQUFXbGdCLFFBQXJCO0FBQ0EsUUFBSTZuQixXQUFKO0FBQ0EsUUFBSSxDQUFDLE9BQU94SixJQUFQLEtBQWdCLFdBQWhCLEdBQThCLFdBQTlCLEdBQTRDOWlCLFFBQVE4aUIsSUFBUixDQUE3QyxNQUFnRSxRQUFoRSxJQUE0RUEsS0FBS3RiLFFBQXJGLEVBQStGO0FBQzdGOGtCLG9CQUFjM0gsUUFBUWhlLGFBQVIsQ0FBc0IsS0FBdEIsQ0FBZDtBQUNBMmxCLGtCQUFZempCLFdBQVosQ0FBd0JpYSxJQUF4QjtBQUNELEtBSEQsTUFHTyxJQUFJeGlCLFVBQVV3a0IsT0FBVixDQUFrQndDLGlCQUFsQixDQUFvQzNDLE9BQXBDLENBQUosRUFBa0Q7QUFDdkQySCxvQkFBYzNILFFBQVFoZSxhQUFSLENBQXNCLEtBQXRCLENBQWQ7QUFDQTJsQixrQkFBWTdaLFNBQVosR0FBd0JxUSxJQUF4QjtBQUNELEtBSE0sTUFHQTtBQUNMZ04sZ0NBQTBCbkwsT0FBMUI7QUFDQTJILG9CQUFjcUQsZUFBZTdNLElBQWYsRUFBcUI2QixPQUFyQixDQUFkO0FBQ0Q7QUFDRCxXQUFPMkgsV0FBUDtBQUNELEdBZEQ7QUFlRCxDQWhEd0IsRUFBekIsQyxDQWdESzs7Ozs7Ozs7Ozs7Ozs7O0FBZUxoc0IsVUFBVUcsR0FBVixDQUFjd3ZCLGdCQUFkLEdBQWlDLFlBQVk7O0FBRTNDLFdBQVNDLGVBQVQsQ0FBeUJobEIsUUFBekIsRUFBbUNpbEIsZ0JBQW5DLEVBQXFEO0FBQ25ELFFBQUksQ0FBQ0EsZ0JBQUQsSUFBcUIsQ0FBQ0EsaUJBQWlCenRCLE1BQTNDLEVBQW1EO0FBQ2pELGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQUksT0FBT3l0QixnQkFBUCxLQUE0QixRQUFoQyxFQUEwQztBQUN4QyxhQUFPamxCLGFBQWFpbEIsZ0JBQXBCO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBTzd2QixVQUFVTSxJQUFWLENBQWUyb0IsS0FBZixDQUFxQjRHLGdCQUFyQixFQUF1QzdaLFFBQXZDLENBQWdEcEwsUUFBaEQsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsV0FBU2tsQixVQUFULENBQW9CbHBCLElBQXBCLEVBQTBCO0FBQ3hCLFdBQU9BLEtBQUtNLFFBQUwsS0FBa0JsSCxVQUFVVyxZQUFuQztBQUNEOztBQUVELFdBQVNvdkIsYUFBVCxDQUF1QnpOLE9BQXZCLEVBQWdDK0osU0FBaEMsRUFBMkMyRCxXQUEzQyxFQUF3RDtBQUN0RCxRQUFJQyxhQUFhLENBQUMzTixRQUFRK0osU0FBUixJQUFxQixFQUF0QixFQUEwQmxILEtBQTFCLENBQWdDNkssV0FBaEMsS0FBZ0QsRUFBakU7QUFDQSxRQUFJLENBQUMzRCxTQUFMLEVBQWdCO0FBQ2QsYUFBTyxDQUFDLENBQUM0RCxXQUFXN3RCLE1BQXBCO0FBQ0Q7QUFDRCxXQUFPNnRCLFdBQVdBLFdBQVc3dEIsTUFBWCxHQUFvQixDQUEvQixNQUFzQ2lxQixTQUE3QztBQUNEOztBQUVELFdBQVM2RCw2QkFBVCxDQUF1Q3RwQixJQUF2QyxFQUE2Q2dFLFFBQTdDLEVBQXVEdWxCLE1BQXZELEVBQStEO0FBQzdELFdBQU9BLFlBQVl2cEIsSUFBWixJQUFvQkEsS0FBS2dFLFFBQUwsS0FBa0IsTUFBN0MsRUFBcUQ7QUFDbkQsVUFBSWdsQixnQkFBZ0JocEIsS0FBS2dFLFFBQXJCLEVBQStCQSxRQUEvQixDQUFKLEVBQThDO0FBQzVDLGVBQU9oRSxJQUFQO0FBQ0Q7QUFDREEsYUFBT0EsS0FBS0ssVUFBWjtBQUNEO0FBQ0QsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsV0FBU21wQix5Q0FBVCxDQUFtRHhwQixJQUFuRCxFQUF5RGdFLFFBQXpELEVBQW1FeWhCLFNBQW5FLEVBQThFMkQsV0FBOUUsRUFBMkZHLE1BQTNGLEVBQW1HO0FBQ2pHLFdBQU9BLFlBQVl2cEIsSUFBWixJQUFvQkEsS0FBS2dFLFFBQUwsS0FBa0IsTUFBN0MsRUFBcUQ7QUFDbkQsVUFBSWtsQixXQUFXbHBCLElBQVgsS0FBb0JncEIsZ0JBQWdCaHBCLEtBQUtnRSxRQUFyQixFQUErQkEsUUFBL0IsQ0FBcEIsSUFBZ0VtbEIsY0FBY25wQixJQUFkLEVBQW9CeWxCLFNBQXBCLEVBQStCMkQsV0FBL0IsQ0FBcEUsRUFBaUg7QUFDL0csZUFBT3BwQixJQUFQO0FBQ0Q7QUFDREEsYUFBT0EsS0FBS0ssVUFBWjtBQUNEO0FBQ0QsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBTyxVQUFVTCxJQUFWLEVBQWdCeXBCLFdBQWhCLEVBQTZCRixNQUE3QixFQUFxQztBQUMxQ0EsYUFBU0EsVUFBVSxFQUFuQixDQUQwQyxDQUNuQjtBQUN2QixRQUFJRSxZQUFZaEUsU0FBWixJQUF5QmdFLFlBQVlMLFdBQXpDLEVBQXNEO0FBQ3BELGFBQU9JLDBDQUEwQ3hwQixJQUExQyxFQUFnRHlwQixZQUFZemxCLFFBQTVELEVBQXNFeWxCLFlBQVloRSxTQUFsRixFQUE2RmdFLFlBQVlMLFdBQXpHLEVBQXNIRyxNQUF0SCxDQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBT0QsOEJBQThCdHBCLElBQTlCLEVBQW9DeXBCLFlBQVl6bEIsUUFBaEQsRUFBMER1bEIsTUFBMUQsQ0FBUDtBQUNEO0FBQ0YsR0FQRDtBQVFELENBdERnQyxFQUFqQztBQXVEQTs7Ozs7Ozs7OztBQVVBbndCLFVBQVVHLEdBQVYsQ0FBY3F0QixRQUFkLEdBQXlCLFlBQVk7QUFDbkMsTUFBSThDLHVCQUF1QjtBQUN6QixhQUFTLGdCQUFnQm5zQixTQUFTa0MsYUFBVCxDQUF1QixLQUF2QixFQUE4QmlwQixLQUE5QyxHQUFzRCxZQUF0RCxHQUFxRTtBQURyRCxHQUEzQjtBQUFBLE1BR0lpQixtQkFBbUIsVUFIdkI7O0FBS0EsV0FBU0MsUUFBVCxDQUFrQi9GLEdBQWxCLEVBQXVCO0FBQ3JCLFdBQU9BLElBQUl4UCxPQUFKLENBQVlzVixnQkFBWixFQUE4QixVQUFVcEwsS0FBVixFQUFpQjtBQUNwRCxhQUFPQSxNQUFNc0wsTUFBTixDQUFhLENBQWIsRUFBZ0JDLFdBQWhCLEVBQVA7QUFDRCxLQUZNLENBQVA7QUFHRDs7QUFFRCxTQUFPLFVBQVU3SCxRQUFWLEVBQW9CO0FBQ3pCLFdBQU87QUFDTDRFLFlBQU0sU0FBU0EsSUFBVCxDQUFjbkwsT0FBZCxFQUF1QjtBQUMzQixZQUFJQSxRQUFRcGIsUUFBUixLQUFxQmxILFVBQVVXLFlBQW5DLEVBQWlEO0FBQy9DO0FBQ0Q7O0FBRUQsWUFBSXFJLE1BQU1zWixRQUFReFosYUFBbEI7QUFBQSxZQUNJNm5CLG9CQUFvQkwscUJBQXFCekgsUUFBckIsS0FBa0MySCxTQUFTM0gsUUFBVCxDQUQxRDtBQUFBLFlBRUl5RyxRQUFRaE4sUUFBUWdOLEtBRnBCO0FBQUEsWUFHSXNCLGVBQWV0TyxRQUFRc08sWUFIM0I7QUFBQSxZQUlJQyxhQUFhdkIsTUFBTXFCLGlCQUFOLENBSmpCO0FBS0EsWUFBSUUsVUFBSixFQUFnQjtBQUNkLGlCQUFPQSxVQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUlELFlBQUosRUFBa0I7QUFDaEIsY0FBSTtBQUNGLG1CQUFPQSxhQUFhRCxpQkFBYixDQUFQO0FBQ0QsV0FGRCxDQUVFLE9BQU81cUIsQ0FBUCxFQUFVO0FBQ1Y7QUFDRDtBQUNGOztBQUVELFlBQUlaLE1BQU02RCxJQUFJQyxXQUFKLElBQW1CRCxJQUFJRSxZQUFqQztBQUFBLFlBQ0k0bkIscUJBQXFCLENBQUNqSSxhQUFhLFFBQWIsSUFBeUJBLGFBQWEsT0FBdkMsS0FBbUR2RyxRQUFRMVgsUUFBUixLQUFxQixVQURqRztBQUFBLFlBRUltbUIsZ0JBRko7QUFBQSxZQUdJMVosV0FISjs7QUFLQSxZQUFJbFMsSUFBSTZyQixnQkFBUixFQUEwQjtBQUN4QjtBQUNBO0FBQ0EsY0FBSUYsa0JBQUosRUFBd0I7QUFDdEJDLCtCQUFtQnpCLE1BQU0yQixRQUF6QjtBQUNBM0Isa0JBQU0yQixRQUFOLEdBQWlCLFFBQWpCO0FBQ0Q7QUFDRDVaLHdCQUFjbFMsSUFBSTZyQixnQkFBSixDQUFxQjFPLE9BQXJCLEVBQThCLElBQTlCLEVBQW9DNE8sZ0JBQXBDLENBQXFEckksUUFBckQsQ0FBZDtBQUNBLGNBQUlpSSxrQkFBSixFQUF3QjtBQUN0QnhCLGtCQUFNMkIsUUFBTixHQUFpQkYsb0JBQW9CLEVBQXJDO0FBQ0Q7QUFDRCxpQkFBTzFaLFdBQVA7QUFDRDtBQUNGO0FBOUNJLEtBQVA7QUFnREQsR0FqREQ7QUFrREQsQ0E5RHdCLEVBQXpCLEMsQ0E4REs7Ozs7Ozs7Ozs7QUFVTHJYLFVBQVVHLEdBQVYsQ0FBY2d4QixxQkFBZCxHQUFzQyxZQUFZO0FBQ2hELE1BQUlDLGFBQWEsRUFBakI7QUFBQSxNQUNJQyxzQkFBc0IsQ0FEMUI7O0FBR0EsV0FBU0Msc0JBQVQsQ0FBZ0N0b0IsR0FBaEMsRUFBcUM7QUFDbkMsV0FBT0EsSUFBSXVvQixxQkFBSixLQUE4QnZvQixJQUFJdW9CLHFCQUFKLEdBQTRCRixxQkFBMUQsQ0FBUDtBQUNEOztBQUVELFNBQU8sVUFBVXJvQixHQUFWLEVBQWV3b0IsT0FBZixFQUF3QjtBQUM3QixRQUFJdk4sTUFBTXFOLHVCQUF1QnRvQixHQUF2QixJQUE4QixHQUE5QixHQUFvQ3dvQixPQUE5QztBQUFBLFFBQ0lDLGFBQWFMLFdBQVduTixHQUFYLENBRGpCO0FBRUEsUUFBSSxDQUFDd04sVUFBTCxFQUFpQjtBQUNmQSxtQkFBYUwsV0FBV25OLEdBQVgsSUFBa0JqYixJQUFJekUsb0JBQUosQ0FBeUJpdEIsT0FBekIsQ0FBL0I7QUFDRDs7QUFFRCxXQUFPQyxXQUFXcnZCLE1BQVgsR0FBb0IsQ0FBM0I7QUFDRCxHQVJEO0FBU0QsQ0FqQnFDLEVBQXRDLEMsQ0FpQks7Ozs7Ozs7Ozs7QUFVTCxDQUFDLFVBQVVwQyxTQUFWLEVBQXFCO0FBQ3BCLE1BQUlveEIsYUFBYSxFQUFqQjtBQUFBLE1BQ0lDLHNCQUFzQixDQUQxQjs7QUFHQSxXQUFTQyxzQkFBVCxDQUFnQ3RvQixHQUFoQyxFQUFxQztBQUNuQyxXQUFPQSxJQUFJdW9CLHFCQUFKLEtBQThCdm9CLElBQUl1b0IscUJBQUosR0FBNEJGLHFCQUExRCxDQUFQO0FBQ0Q7O0FBRURyeEIsWUFBVUcsR0FBVixDQUFjdXhCLHVCQUFkLEdBQXdDLFVBQVUxb0IsR0FBVixFQUFlcWpCLFNBQWYsRUFBMEI7QUFDaEU7QUFDQTtBQUNBLFFBQUksQ0FBQ3JzQixVQUFVd2tCLE9BQVYsQ0FBa0I0RCxvQ0FBbEIsRUFBTCxFQUErRDtBQUM3RCxhQUFPLENBQUMsQ0FBQ3BmLElBQUk0YyxhQUFKLENBQWtCLE1BQU15RyxTQUF4QixDQUFUO0FBQ0Q7O0FBRUQsUUFBSXBJLE1BQU1xTix1QkFBdUJ0b0IsR0FBdkIsSUFBOEIsR0FBOUIsR0FBb0NxakIsU0FBOUM7QUFBQSxRQUNJb0YsYUFBYUwsV0FBV25OLEdBQVgsQ0FEakI7QUFFQSxRQUFJLENBQUN3TixVQUFMLEVBQWlCO0FBQ2ZBLG1CQUFhTCxXQUFXbk4sR0FBWCxJQUFrQmpiLElBQUlxZixzQkFBSixDQUEyQmdFLFNBQTNCLENBQS9CO0FBQ0Q7O0FBRUQsV0FBT29GLFdBQVdydkIsTUFBWCxHQUFvQixDQUEzQjtBQUNELEdBZEQ7QUFlRCxDQXZCRCxFQXVCR3BDLFNBdkJIO0FBd0JBQSxVQUFVRyxHQUFWLENBQWN1dEIsTUFBZCxHQUF1QixVQUFVaUUsZUFBVixFQUEyQjtBQUNoRCxTQUFPO0FBQ0xoRSxXQUFPLFNBQVNBLEtBQVQsQ0FBZXJMLE9BQWYsRUFBd0I7QUFDN0JBLGNBQVFyYixVQUFSLENBQW1CcUIsWUFBbkIsQ0FBZ0NxcEIsZUFBaEMsRUFBaURyUCxRQUFRamEsV0FBekQ7QUFDRCxLQUhJOztBQUtMdXBCLFlBQVEsU0FBU0EsTUFBVCxDQUFnQnRQLE9BQWhCLEVBQXlCO0FBQy9CQSxjQUFRcmIsVUFBUixDQUFtQnFCLFlBQW5CLENBQWdDcXBCLGVBQWhDLEVBQWlEclAsT0FBakQ7QUFDRCxLQVBJOztBQVNMdVAsVUFBTSxTQUFTQSxJQUFULENBQWN2UCxPQUFkLEVBQXVCO0FBQzNCQSxjQUFRL1osV0FBUixDQUFvQm9wQixlQUFwQjtBQUNEO0FBWEksR0FBUDtBQWFELENBZEQsQ0FjRTN4QixVQUFVRyxHQUFWLENBQWMyeEIsU0FBZCxHQUEwQixVQUFVQyxLQUFWLEVBQWlCO0FBQzNDQSxVQUFRQSxNQUFNcmpCLElBQU4sQ0FBVyxJQUFYLENBQVI7O0FBRUEsU0FBTztBQUNMbWpCLFVBQU0sU0FBU0EsSUFBVCxDQUFjN29CLEdBQWQsRUFBbUI7QUFDdkIsVUFBSWdwQixPQUFPaHBCLElBQUlncEIsSUFBSixJQUFZaHBCLElBQUl6RSxvQkFBSixDQUF5QixNQUF6QixFQUFpQyxDQUFqQyxDQUF2QjtBQUFBLFVBQ0kwdEIsZUFBZWpwQixJQUFJM0MsYUFBSixDQUFrQixPQUFsQixDQURuQjs7QUFHQTRyQixtQkFBYXhsQixJQUFiLEdBQW9CLFVBQXBCOztBQUVBLFVBQUl3bEIsYUFBYUMsVUFBakIsRUFBNkI7QUFDM0JELHFCQUFhQyxVQUFiLENBQXdCdEQsT0FBeEIsR0FBa0NtRCxLQUFsQztBQUNELE9BRkQsTUFFTztBQUNMRSxxQkFBYTFwQixXQUFiLENBQXlCUyxJQUFJekMsY0FBSixDQUFtQndyQixLQUFuQixDQUF6QjtBQUNEOztBQUVELFVBQUlDLElBQUosRUFBVTtBQUNSQSxhQUFLenBCLFdBQUwsQ0FBaUIwcEIsWUFBakI7QUFDRDtBQUNGO0FBaEJJLEdBQVA7QUFrQkQsQ0FyQkMsQyxDQXFCQzs7Ozs7O0FBTUhqeUIsVUFBVUcsR0FBVixDQUFjc3BCLE9BQWQsR0FBd0IsVUFBVW5ILE9BQVYsRUFBbUI2UCxVQUFuQixFQUErQnpJLE9BQS9CLEVBQXdDO0FBQzlEeUksZUFBYSxPQUFPQSxVQUFQLEtBQXNCLFFBQXRCLEdBQWlDLENBQUNBLFVBQUQsQ0FBakMsR0FBZ0RBLFVBQTdEOztBQUVBLE1BQUlDLGNBQUo7QUFBQSxNQUNJNUwsU0FESjtBQUFBLE1BRUlya0IsSUFBSSxDQUZSO0FBQUEsTUFHSUMsU0FBUyt2QixXQUFXL3ZCLE1BSHhCOztBQUtBLFNBQU9ELElBQUlDLE1BQVgsRUFBbUJELEdBQW5CLEVBQXdCO0FBQ3RCcWtCLGdCQUFZMkwsV0FBV2h3QixDQUFYLENBQVo7QUFDQSxRQUFJbWdCLFFBQVF0YyxnQkFBWixFQUE4QjtBQUM1QnNjLGNBQVF0YyxnQkFBUixDQUF5QndnQixTQUF6QixFQUFvQ2tELE9BQXBDLEVBQTZDLEtBQTdDO0FBQ0QsS0FGRCxNQUVPO0FBQ0wwSSx1QkFBaUIsU0FBU0EsY0FBVCxDQUF3QmpELEtBQXhCLEVBQStCO0FBQzlDLFlBQUksRUFBRSxZQUFZQSxLQUFkLENBQUosRUFBMEI7QUFDeEJBLGdCQUFNcmlCLE1BQU4sR0FBZXFpQixNQUFNa0QsVUFBckI7QUFDRDtBQUNEbEQsY0FBTW1ELGNBQU4sR0FBdUJuRCxNQUFNbUQsY0FBTixJQUF3QixZQUFZO0FBQ3pELGVBQUtqYixXQUFMLEdBQW1CLEtBQW5CO0FBQ0QsU0FGRDtBQUdBOFgsY0FBTW9ELGVBQU4sR0FBd0JwRCxNQUFNb0QsZUFBTixJQUF5QixZQUFZO0FBQzNELGVBQUtDLFlBQUwsR0FBb0IsSUFBcEI7QUFDRCxTQUZEO0FBR0E5SSxnQkFBUTdjLElBQVIsQ0FBYXlWLE9BQWIsRUFBc0I2TSxLQUF0QjtBQUNELE9BWEQ7QUFZQTdNLGNBQVFyYyxXQUFSLENBQW9CLE9BQU91Z0IsU0FBM0IsRUFBc0M0TCxjQUF0QztBQUNEO0FBQ0Y7O0FBRUQsU0FBTztBQUNMdGtCLFVBQU0sU0FBU0EsSUFBVCxHQUFnQjtBQUNwQixVQUFJMFksU0FBSjtBQUFBLFVBQ0lya0IsSUFBSSxDQURSO0FBQUEsVUFFSUMsU0FBUyt2QixXQUFXL3ZCLE1BRnhCO0FBR0EsYUFBT0QsSUFBSUMsTUFBWCxFQUFtQkQsR0FBbkIsRUFBd0I7QUFDdEJxa0Isb0JBQVkyTCxXQUFXaHdCLENBQVgsQ0FBWjtBQUNBLFlBQUltZ0IsUUFBUW1RLG1CQUFaLEVBQWlDO0FBQy9CblEsa0JBQVFtUSxtQkFBUixDQUE0QmpNLFNBQTVCLEVBQXVDa0QsT0FBdkMsRUFBZ0QsS0FBaEQ7QUFDRCxTQUZELE1BRU87QUFDTHBILGtCQUFRb1EsV0FBUixDQUFvQixPQUFPbE0sU0FBM0IsRUFBc0M0TCxjQUF0QztBQUNEO0FBQ0Y7QUFDRjtBQWJJLEdBQVA7QUFlRCxDQTVDRDtBQTZDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbURBcHlCLFVBQVVHLEdBQVYsQ0FBY3d5QixLQUFkLEdBQXNCLFlBQVk7O0FBRWhDOzs7Ozs7O0FBT0EsTUFBSUMsb0JBQW9CO0FBQ3RCLFNBQUtDLGNBRGlCO0FBRXRCLFNBQUtDO0FBRmlCLEdBQXhCOzs7QUFLQTtBQUNBQyxzQkFBb0IsTUFOcEI7QUFBQSxNQU9JQyxzQkFBc0IsS0FQMUI7QUFBQSxNQVFJQyxlQUFlLEVBQUVDLE1BQU0sRUFBUixFQUFZQyxTQUFTLEVBQXJCLEVBUm5CO0FBQUEsTUFTSUMsZUFBZSxFQVRuQjs7QUFXQTs7OztBQUlBLFdBQVNULEtBQVQsQ0FBZVUsYUFBZixFQUE4QnRCLEtBQTlCLEVBQXFDMU4sT0FBckMsRUFBOENpUCxPQUE5QyxFQUF1RDtBQUNyRHR6QixjQUFVTSxJQUFWLENBQWU2akIsTUFBZixDQUFzQmlQLFlBQXRCLEVBQW9DbEosS0FBcEMsQ0FBMEMrSSxZQUExQyxFQUF3RC9JLEtBQXhELENBQThENkgsS0FBOUQsRUFBcUV6SSxHQUFyRTs7QUFFQWpGLGNBQVVBLFdBQVdnUCxjQUFjdnFCLGFBQXpCLElBQTBDM0UsUUFBcEQ7QUFDQSxRQUFJa0csV0FBV2dhLFFBQVEvWixzQkFBUixFQUFmO0FBQUEsUUFDSWlwQixXQUFXLE9BQU9GLGFBQVAsS0FBeUIsUUFEeEM7QUFBQSxRQUVJL1EsT0FGSjtBQUFBLFFBR0k1WixPQUhKO0FBQUEsUUFJSXlCLFVBSko7O0FBTUEsUUFBSW9wQixRQUFKLEVBQWM7QUFDWmpSLGdCQUFVdGlCLFVBQVVHLEdBQVYsQ0FBY2l2QixRQUFkLENBQXVCaUUsYUFBdkIsRUFBc0NoUCxPQUF0QyxDQUFWO0FBQ0QsS0FGRCxNQUVPO0FBQ0wvQixnQkFBVStRLGFBQVY7QUFDRDs7QUFFRCxXQUFPL1EsUUFBUW5ZLFVBQWYsRUFBMkI7QUFDekJBLG1CQUFhbVksUUFBUW5ZLFVBQXJCO0FBQ0FtWSxjQUFRdFMsV0FBUixDQUFvQjdGLFVBQXBCO0FBQ0F6QixnQkFBVThxQixTQUFTcnBCLFVBQVQsRUFBcUJtcEIsT0FBckIsQ0FBVjtBQUNBLFVBQUk1cUIsT0FBSixFQUFhO0FBQ1gyQixpQkFBUzlCLFdBQVQsQ0FBcUJHLE9BQXJCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBNFosWUFBUW5RLFNBQVIsR0FBb0IsRUFBcEI7O0FBRUE7QUFDQW1RLFlBQVEvWixXQUFSLENBQW9COEIsUUFBcEI7O0FBRUEsV0FBT2twQixXQUFXdnpCLFVBQVVJLE1BQVYsQ0FBaUJxekIsbUJBQWpCLENBQXFDblIsT0FBckMsQ0FBWCxHQUEyREEsT0FBbEU7QUFDRDs7QUFFRCxXQUFTa1IsUUFBVCxDQUFrQkUsT0FBbEIsRUFBMkJKLE9BQTNCLEVBQW9DO0FBQ2xDLFFBQUlLLGNBQWNELFFBQVF4c0IsUUFBMUI7QUFBQSxRQUNJMHNCLFlBQVlGLFFBQVFwc0IsVUFEeEI7QUFBQSxRQUVJdXNCLGtCQUFrQkQsVUFBVXh4QixNQUZoQztBQUFBLFFBR0lzRyxPQUhKO0FBQUEsUUFJSW1iLFNBQVMrTyxrQkFBa0JlLFdBQWxCLENBSmI7QUFBQSxRQUtJeHhCLElBQUksQ0FMUjs7QUFPQXVHLGNBQVVtYixVQUFVQSxPQUFPNlAsT0FBUCxDQUFwQjs7QUFFQSxRQUFJLENBQUNockIsT0FBTCxFQUFjO0FBQ1osYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBS3ZHLElBQUksQ0FBVCxFQUFZQSxJQUFJMHhCLGVBQWhCLEVBQWlDMXhCLEdBQWpDLEVBQXNDO0FBQ3BDMnhCLGlCQUFXTixTQUFTSSxVQUFVenhCLENBQVYsQ0FBVCxFQUF1Qm14QixPQUF2QixDQUFYO0FBQ0EsVUFBSVEsUUFBSixFQUFjO0FBQ1pwckIsZ0JBQVFILFdBQVIsQ0FBb0J1ckIsUUFBcEI7QUFDRDtBQUNGOztBQUVEO0FBQ0EsUUFBSVIsV0FBVzVxQixRQUFRcEIsVUFBUixDQUFtQmxGLE1BQW5CLElBQTZCLENBQXhDLElBQTZDc0csUUFBUWtDLFFBQVIsQ0FBaUJ5YSxXQUFqQixPQUFtQzBOLGlCQUFoRixJQUFxRyxDQUFDcnFCLFFBQVFxckIsVUFBUixDQUFtQjN4QixNQUE3SCxFQUFxSTtBQUNuSSxhQUFPc0csUUFBUXlCLFVBQWY7QUFDRDs7QUFFRCxXQUFPekIsT0FBUDtBQUNEOztBQUVELFdBQVNtcUIsY0FBVCxDQUF3QmEsT0FBeEIsRUFBaUM7QUFDL0IsUUFBSU0sSUFBSjtBQUFBLFFBQ0l0ckIsT0FESjtBQUFBLFFBRUl1ckIsTUFGSjtBQUFBLFFBR0lDLFdBQVdkLGFBQWFGLElBSDVCO0FBQUEsUUFJSXRvQixXQUFXOG9CLFFBQVE5b0IsUUFBUixDQUFpQnlhLFdBQWpCLEVBSmY7QUFBQSxRQUtJOE8sWUFBWVQsUUFBUVMsU0FMeEI7O0FBT0E7Ozs7QUFJQSxRQUFJVCxRQUFRVSxVQUFaLEVBQXdCO0FBQ3RCLGFBQU8sSUFBUDtBQUNEO0FBQ0RWLFlBQVFVLFVBQVIsR0FBcUIsQ0FBckI7O0FBRUEsUUFBSVYsUUFBUXJILFNBQVIsS0FBc0IsZ0JBQTFCLEVBQTRDO0FBQzFDLGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozs7QUFNQSxRQUFJOEgsYUFBYUEsYUFBYSxNQUE5QixFQUFzQztBQUNwQ3ZwQixpQkFBV3VwQixZQUFZLEdBQVosR0FBa0J2cEIsUUFBN0I7QUFDRDs7QUFFRDs7Ozs7QUFLQSxRQUFJLGVBQWU4b0IsT0FBbkIsRUFBNEI7QUFDMUIsVUFBSSxDQUFDMXpCLFVBQVV3a0IsT0FBVixDQUFrQjBELHNCQUFsQixFQUFELElBQStDd0wsUUFBUTlvQixRQUFSLEtBQXFCLEdBQXBFLElBQTJFOG9CLFFBQVFXLFNBQVIsQ0FBa0IzZ0IsS0FBbEIsQ0FBd0IsQ0FBQyxDQUF6QixFQUE0QjJSLFdBQTVCLE9BQThDLE1BQTdILEVBQXFJO0FBQ25JemEsbUJBQVcsS0FBWDtBQUNEO0FBQ0Y7O0FBRUQsUUFBSUEsWUFBWXNwQixRQUFoQixFQUEwQjtBQUN4QkYsYUFBT0UsU0FBU3RwQixRQUFULENBQVA7QUFDQSxVQUFJLENBQUNvcEIsSUFBRCxJQUFTQSxLQUFLL2xCLE1BQWxCLEVBQTBCO0FBQ3hCLGVBQU8sSUFBUDtBQUNEOztBQUVEK2xCLGFBQU8sT0FBT0EsSUFBUCxLQUFnQixRQUFoQixHQUEyQixFQUFFTSxZQUFZTixJQUFkLEVBQTNCLEdBQWtEQSxJQUF6RDtBQUNELEtBUEQsTUFPTyxJQUFJTixRQUFRdnBCLFVBQVosRUFBd0I7QUFDN0I2cEIsYUFBTyxFQUFFTSxZQUFZdkIsaUJBQWQsRUFBUDtBQUNELEtBRk0sTUFFQTtBQUNMO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRURycUIsY0FBVWdyQixRQUFRNXFCLGFBQVIsQ0FBc0J6QyxhQUF0QixDQUFvQzJ0QixLQUFLTSxVQUFMLElBQW1CMXBCLFFBQXZELENBQVY7QUFDQTJwQixzQkFBa0JiLE9BQWxCLEVBQTJCaHJCLE9BQTNCLEVBQW9Dc3JCLElBQXBDOztBQUVBTixjQUFVLElBQVY7QUFDQSxXQUFPaHJCLE9BQVA7QUFDRDs7QUFFRCxXQUFTNnJCLGlCQUFULENBQTJCYixPQUEzQixFQUFvQ2hyQixPQUFwQyxFQUE2Q3NyQixJQUE3QyxFQUFtRDtBQUNqRCxRQUFJRCxhQUFhLEVBQWpCOztBQUNJO0FBQ0pTLGVBQVdSLEtBQUtTLFNBRmhCOztBQUdJO0FBQ0pySSxlQUFXNEgsS0FBS1UsU0FKaEI7O0FBS0k7QUFDSkMsb0JBQWdCWCxLQUFLWSxjQU5yQjs7QUFPSTtBQUNKQyxzQkFBa0JiLEtBQUtjLGdCQVJ2Qjs7QUFTSTtBQUNKQyxxQkFBaUIzQixhQUFhRCxPQVY5QjtBQUFBLFFBV0loeEIsSUFBSSxDQVhSO0FBQUEsUUFZSWd4QixVQUFVLEVBWmQ7QUFBQSxRQWFJNkIsYUFBYSxFQWJqQjtBQUFBLFFBY0lDLG1CQUFtQixFQWR2QjtBQUFBLFFBZUlDLGFBQWEsRUFmakI7QUFBQSxRQWdCSUMsYUFoQko7QUFBQSxRQWlCSUMsZ0JBakJKO0FBQUEsUUFrQklDLFlBbEJKO0FBQUEsUUFtQklDLFFBbkJKO0FBQUEsUUFvQklDLGFBcEJKO0FBQUEsUUFxQklDLGlCQXJCSjtBQUFBLFFBc0JJM1IsTUF0Qko7O0FBd0JBLFFBQUk4USxhQUFKLEVBQW1CO0FBQ2pCWixtQkFBYS96QixVQUFVTSxJQUFWLENBQWU2akIsTUFBZixDQUFzQndRLGFBQXRCLEVBQXFDbGhCLEtBQXJDLEVBQWI7QUFDRDs7QUFFRCxRQUFJb2hCLGVBQUosRUFBcUI7QUFDbkIsV0FBS1UsYUFBTCxJQUFzQlYsZUFBdEIsRUFBdUM7QUFDckNoUixpQkFBUzRSLHNCQUFzQlosZ0JBQWdCVSxhQUFoQixDQUF0QixDQUFUO0FBQ0EsWUFBSSxDQUFDMVIsTUFBTCxFQUFhO0FBQ1g7QUFDRDtBQUNEMlIsNEJBQW9CM1IsT0FBTzZSLGNBQWNoQyxPQUFkLEVBQXVCNkIsYUFBdkIsQ0FBUCxDQUFwQjtBQUNBLFlBQUksT0FBT0MsaUJBQVAsS0FBNkIsUUFBakMsRUFBMkM7QUFDekN6QixxQkFBV3dCLGFBQVgsSUFBNEJDLGlCQUE1QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxRQUFJaEIsUUFBSixFQUFjO0FBQ1pyQixjQUFRcHVCLElBQVIsQ0FBYXl2QixRQUFiO0FBQ0Q7O0FBRUQsUUFBSXBJLFFBQUosRUFBYztBQUNaLFdBQUttSixhQUFMLElBQXNCbkosUUFBdEIsRUFBZ0M7QUFDOUJ2SSxpQkFBUzhSLGdCQUFnQnZKLFNBQVNtSixhQUFULENBQWhCLENBQVQ7QUFDQSxZQUFJLENBQUMxUixNQUFMLEVBQWE7QUFDWDtBQUNEO0FBQ0R5UixtQkFBV3pSLE9BQU82UixjQUFjaEMsT0FBZCxFQUF1QjZCLGFBQXZCLENBQVAsQ0FBWDtBQUNBLFlBQUksT0FBT0QsUUFBUCxLQUFvQixRQUF4QixFQUFrQztBQUNoQ25DLGtCQUFRcHVCLElBQVIsQ0FBYXV3QixRQUFiO0FBQ0Q7QUFDRjtBQUNGOztBQUVEO0FBQ0FQLG1CQUFlLDZCQUFmLElBQWdELENBQWhEOztBQUVBO0FBQ0FHLGlCQUFheEIsUUFBUTVMLFlBQVIsQ0FBcUIsT0FBckIsQ0FBYjtBQUNBLFFBQUlvTixVQUFKLEVBQWdCO0FBQ2QvQixnQkFBVUEsUUFBUXp1QixNQUFSLENBQWV3d0IsV0FBV25LLEtBQVgsQ0FBaUJpSSxtQkFBakIsQ0FBZixDQUFWO0FBQ0Q7QUFDRG1DLG9CQUFnQmhDLFFBQVEvd0IsTUFBeEI7QUFDQSxXQUFPRCxJQUFJZ3pCLGFBQVgsRUFBMEJoekIsR0FBMUIsRUFBK0I7QUFDN0JrekIscUJBQWVsQyxRQUFRaHhCLENBQVIsQ0FBZjtBQUNBLFVBQUk0eUIsZUFBZU0sWUFBZixDQUFKLEVBQWtDO0FBQ2hDTCxtQkFBV2p3QixJQUFYLENBQWdCc3dCLFlBQWhCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBRCx1QkFBbUJKLFdBQVc1eUIsTUFBOUI7QUFDQSxXQUFPZ3pCLGtCQUFQLEVBQTJCO0FBQ3pCQyxxQkFBZUwsV0FBV0ksZ0JBQVgsQ0FBZjtBQUNBLFVBQUksQ0FBQ3AxQixVQUFVTSxJQUFWLENBQWUyb0IsS0FBZixDQUFxQmdNLGdCQUFyQixFQUF1Q2pmLFFBQXZDLENBQWdEcWYsWUFBaEQsQ0FBTCxFQUFvRTtBQUNsRUoseUJBQWlCVyxPQUFqQixDQUF5QlAsWUFBekI7QUFDRDtBQUNGOztBQUVELFFBQUlKLGlCQUFpQjd5QixNQUFyQixFQUE2QjtBQUMzQjJ4QixpQkFBVyxPQUFYLElBQXNCa0IsaUJBQWlCdm1CLElBQWpCLENBQXNCLEdBQXRCLENBQXRCO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFLNm1CLGFBQUwsSUFBc0J4QixVQUF0QixFQUFrQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxVQUFJO0FBQ0ZyckIsZ0JBQVErZCxZQUFSLENBQXFCOE8sYUFBckIsRUFBb0N4QixXQUFXd0IsYUFBWCxDQUFwQztBQUNELE9BRkQsQ0FFRSxPQUFPeHZCLENBQVAsRUFBVSxDQUFFO0FBQ2Y7O0FBRUQ7QUFDQTtBQUNBLFFBQUlndUIsV0FBVzhCLEdBQWYsRUFBb0I7QUFDbEIsVUFBSSxPQUFPOUIsV0FBVytCLEtBQWxCLEtBQTRCLFdBQWhDLEVBQTZDO0FBQzNDcHRCLGdCQUFRK2QsWUFBUixDQUFxQixPQUFyQixFQUE4QnNOLFdBQVcrQixLQUF6QztBQUNEO0FBQ0QsVUFBSSxPQUFPL0IsV0FBV2pGLE1BQWxCLEtBQTZCLFdBQWpDLEVBQThDO0FBQzVDcG1CLGdCQUFRK2QsWUFBUixDQUFxQixRQUFyQixFQUErQnNOLFdBQVdqRixNQUExQztBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7OztBQU9BLE1BQUlpSCx3QkFBd0IsQ0FBQy8xQixVQUFVd2tCLE9BQVYsQ0FBa0JvRCw2QkFBbEIsRUFBN0I7QUFDQSxXQUFTOE4sYUFBVCxDQUF1Qjl1QixJQUF2QixFQUE2QjJ1QixhQUE3QixFQUE0QztBQUMxQ0Esb0JBQWdCQSxjQUFjbFEsV0FBZCxFQUFoQjtBQUNBLFFBQUl6YSxXQUFXaEUsS0FBS2dFLFFBQXBCO0FBQ0EsUUFBSUEsWUFBWSxLQUFaLElBQXFCMnFCLGlCQUFpQixLQUF0QyxJQUErQ1MsZUFBZXB2QixJQUFmLE1BQXlCLElBQTVFLEVBQWtGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBT0EsS0FBS2l2QixHQUFaO0FBQ0QsS0FORCxNQU1PLElBQUlFLHlCQUF5QixlQUFlbnZCLElBQTVDLEVBQWtEO0FBQ3ZEO0FBQ0EsVUFBSXl0QixZQUFZenRCLEtBQUt5dEIsU0FBTCxDQUFlaFAsV0FBZixFQUFoQjs7O0FBRUE7QUFDQTRRLHFCQUFlNUIsVUFBVXhQLE9BQVYsQ0FBa0IsTUFBTTBRLGFBQU4sR0FBc0IsR0FBeEMsS0FBZ0QsQ0FBQyxDQUhoRTs7QUFLQSxhQUFPVSxlQUFlcnZCLEtBQUtraEIsWUFBTCxDQUFrQnlOLGFBQWxCLENBQWYsR0FBa0QsSUFBekQ7QUFDRCxLQVJNLE1BUUE7QUFDTCxhQUFPM3VCLEtBQUtraEIsWUFBTCxDQUFrQnlOLGFBQWxCLENBQVA7QUFDRDtBQUNGOztBQUVEOzs7O0FBSUEsV0FBU1MsY0FBVCxDQUF3QnB2QixJQUF4QixFQUE4QjtBQUM1QixRQUFJO0FBQ0YsYUFBT0EsS0FBS3N2QixRQUFMLElBQWlCLENBQUN0dkIsS0FBS3V2QixrQkFBTCxDQUF3QixjQUF4QixDQUF6QjtBQUNELEtBRkQsQ0FFRSxPQUFPcHdCLENBQVAsRUFBVTtBQUNWLFVBQUlhLEtBQUtzdkIsUUFBTCxJQUFpQnR2QixLQUFLd3ZCLFVBQUwsS0FBb0IsVUFBekMsRUFBcUQ7QUFDbkQsZUFBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFdBQVN0RCxXQUFULENBQXFCWSxPQUFyQixFQUE4QjtBQUM1QixXQUFPQSxRQUFRNXFCLGFBQVIsQ0FBc0J2QyxjQUF0QixDQUFxQ210QixRQUFRanBCLElBQTdDLENBQVA7QUFDRDs7QUFFRDtBQUNBLE1BQUlnckIsd0JBQXdCO0FBQzFCaEssU0FBSyxZQUFZO0FBQ2YsVUFBSTRLLFVBQVUsZUFBZDtBQUNBLGFBQU8sVUFBVUMsY0FBVixFQUEwQjtBQUMvQixZQUFJLENBQUNBLGNBQUQsSUFBbUIsQ0FBQ0EsZUFBZW5SLEtBQWYsQ0FBcUJrUixPQUFyQixDQUF4QixFQUF1RDtBQUNyRCxpQkFBTyxJQUFQO0FBQ0Q7QUFDRCxlQUFPQyxlQUFlcmIsT0FBZixDQUF1Qm9iLE9BQXZCLEVBQWdDLFVBQVVsUixLQUFWLEVBQWlCO0FBQ3RELGlCQUFPQSxNQUFNRSxXQUFOLEVBQVA7QUFDRCxTQUZNLENBQVA7QUFHRCxPQVBEO0FBUUQsS0FWSSxFQURxQjs7QUFhMUJrUixTQUFLLFlBQVk7QUFDZixVQUFJRixVQUFVLGlCQUFkO0FBQ0EsYUFBTyxVQUFVQyxjQUFWLEVBQTBCO0FBQy9CLFlBQUksQ0FBQ0EsY0FBTCxFQUFxQjtBQUNuQixpQkFBTyxFQUFQO0FBQ0Q7QUFDRCxlQUFPQSxlQUFlcmIsT0FBZixDQUF1Qm9iLE9BQXZCLEVBQWdDLEVBQWhDLENBQVA7QUFDRCxPQUxEO0FBTUQsS0FSSSxFQWJxQjs7QUF1QjFCRyxhQUFTLFlBQVk7QUFDbkIsVUFBSUgsVUFBVSxLQUFkO0FBQ0EsYUFBTyxVQUFVQyxjQUFWLEVBQTBCO0FBQy9CQSx5QkFBaUIsQ0FBQ0Esa0JBQWtCLEVBQW5CLEVBQXVCcmIsT0FBdkIsQ0FBK0JvYixPQUEvQixFQUF3QyxFQUF4QyxDQUFqQjtBQUNBLGVBQU9DLGtCQUFrQixJQUF6QjtBQUNELE9BSEQ7QUFJRCxLQU5RO0FBdkJpQixHQUE1Qjs7QUFnQ0E7QUFDQSxNQUFJWCxrQkFBa0I7QUFDcEJjLGVBQVcsWUFBWTtBQUNyQixVQUFJQyxVQUFVO0FBQ1pDLGNBQU0sb0JBRE07QUFFWkMsZUFBTztBQUZLLE9BQWQ7QUFJQSxhQUFPLFVBQVVOLGNBQVYsRUFBMEI7QUFDL0IsZUFBT0ksUUFBUW5TLE9BQU8rUixjQUFQLEVBQXVCalIsV0FBdkIsRUFBUixDQUFQO0FBQ0QsT0FGRDtBQUdELEtBUlUsRUFEUzs7QUFXcEJ3UixnQkFBWSxZQUFZO0FBQ3RCLFVBQUlILFVBQVU7QUFDWkMsY0FBTSx5QkFETTtBQUVaQyxlQUFPLDBCQUZLO0FBR1pFLGdCQUFRLDJCQUhJO0FBSVpDLGlCQUFTO0FBSkcsT0FBZDtBQU1BLGFBQU8sVUFBVVQsY0FBVixFQUEwQjtBQUMvQixlQUFPSSxRQUFRblMsT0FBTytSLGNBQVAsRUFBdUJqUixXQUF2QixFQUFSLENBQVA7QUFDRCxPQUZEO0FBR0QsS0FWVyxFQVhROztBQXVCcEIyUixjQUFVLFlBQVk7QUFDcEIsVUFBSU4sVUFBVTtBQUNaQyxjQUFNLG9CQURNO0FBRVpDLGVBQU8scUJBRks7QUFHWkssY0FBTSxvQkFITTtBQUlaQyxhQUFLO0FBSk8sT0FBZDtBQU1BLGFBQU8sVUFBVVosY0FBVixFQUEwQjtBQUMvQixlQUFPSSxRQUFRblMsT0FBTytSLGNBQVAsRUFBdUJqUixXQUF2QixFQUFSLENBQVA7QUFDRCxPQUZEO0FBR0QsS0FWUyxFQXZCVTs7QUFtQ3BCOFIsZUFBVyxZQUFZO0FBQ3JCLFVBQUlULFVBQVU7QUFDWixhQUFLLDRCQURPO0FBRVosYUFBSyx5QkFGTztBQUdaLGFBQUssMEJBSE87QUFJWixhQUFLLHlCQUpPO0FBS1osYUFBSywyQkFMTztBQU1aLGFBQUssNEJBTk87QUFPWixhQUFLLDRCQVBPO0FBUVosYUFBSywyQkFSTztBQVNaLGFBQUs7QUFUTyxPQUFkO0FBV0EsYUFBTyxVQUFVSixjQUFWLEVBQTBCO0FBQy9CLGVBQU9JLFFBQVFuUyxPQUFPK1IsY0FBUCxFQUF1QjdGLE1BQXZCLENBQThCLENBQTlCLENBQVIsQ0FBUDtBQUNELE9BRkQ7QUFHRCxLQWZVO0FBbkNTLEdBQXRCOztBQXFEQSxTQUFPa0MsS0FBUDtBQUNELENBNVlxQixFQUF0QixDLENBNFlLOzs7Ozs7O0FBT0wzeUIsVUFBVUcsR0FBVixDQUFjaTNCLG9CQUFkLEdBQXFDLFVBQVV4d0IsSUFBVixFQUFnQjtBQUNuRCxNQUFJdW1CLFNBQUo7QUFBQSxNQUNJN2xCLGFBQWF0SCxVQUFVTSxJQUFWLENBQWUyb0IsS0FBZixDQUFxQnJpQixLQUFLVSxVQUExQixFQUFzQ2dpQixHQUF0QyxFQURqQjtBQUFBLE1BRUk2QyxtQkFBbUI3a0IsV0FBV2xGLE1BRmxDO0FBQUEsTUFHSUQsSUFBSSxDQUhSO0FBSUEsU0FBT0EsSUFBSWdxQixnQkFBWCxFQUE2QmhxQixHQUE3QixFQUFrQztBQUNoQ2dyQixnQkFBWTdsQixXQUFXbkYsQ0FBWCxDQUFaO0FBQ0EsUUFBSWdyQixVQUFVam1CLFFBQVYsS0FBdUJsSCxVQUFVWSxTQUFqQyxJQUE4Q3VzQixVQUFVMWlCLElBQVYsS0FBbUIsRUFBckUsRUFBeUU7QUFDdkUwaUIsZ0JBQVVsbUIsVUFBVixDQUFxQitJLFdBQXJCLENBQWlDbWQsU0FBakM7QUFDRDtBQUNGO0FBQ0YsQ0FYRDtBQVlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBbnRCLFVBQVVHLEdBQVYsQ0FBY2szQixhQUFkLEdBQThCLFVBQVUvVSxPQUFWLEVBQW1CZ1YsV0FBbkIsRUFBZ0M7QUFDNUQsTUFBSUMsYUFBYWpWLFFBQVF4WixhQUFSLENBQXNCekMsYUFBdEIsQ0FBb0NpeEIsV0FBcEMsQ0FBakI7QUFBQSxNQUNJbnRCLFVBREo7QUFFQSxTQUFPQSxhQUFhbVksUUFBUW5ZLFVBQTVCLEVBQXdDO0FBQ3RDb3RCLGVBQVdodkIsV0FBWCxDQUF1QjRCLFVBQXZCO0FBQ0Q7QUFDRG5LLFlBQVVHLEdBQVYsQ0FBYzB0QixjQUFkLENBQTZCLENBQUMsT0FBRCxFQUFVLFdBQVYsQ0FBN0IsRUFBcURKLElBQXJELENBQTBEbkwsT0FBMUQsRUFBbUUwTCxFQUFuRSxDQUFzRXVKLFVBQXRFO0FBQ0FqVixVQUFRcmIsVUFBUixDQUFtQjJtQixZQUFuQixDQUFnQzJKLFVBQWhDLEVBQTRDalYsT0FBNUM7QUFDQSxTQUFPaVYsVUFBUDtBQUNELENBVEQsQyxDQVNHOzs7Ozs7Ozs7Ozs7O0FBYUh2M0IsVUFBVUcsR0FBVixDQUFjcTNCLHFCQUFkLEdBQXNDLFVBQVU1d0IsSUFBVixFQUFnQjtBQUNwRCxNQUFJLENBQUNBLEtBQUtLLFVBQVYsRUFBc0I7QUFDcEI7QUFDRDs7QUFFRCxNQUFJLENBQUNMLEtBQUt1RCxVQUFWLEVBQXNCO0FBQ3BCdkQsU0FBS0ssVUFBTCxDQUFnQitJLFdBQWhCLENBQTRCcEosSUFBNUI7QUFDQTtBQUNEOztBQUVELE1BQUl5RCxXQUFXekQsS0FBS2tDLGFBQUwsQ0FBbUJ3QixzQkFBbkIsRUFBZjtBQUNBLFNBQU8xRCxLQUFLdUQsVUFBWixFQUF3QjtBQUN0QkUsYUFBUzlCLFdBQVQsQ0FBcUIzQixLQUFLdUQsVUFBMUI7QUFDRDtBQUNEdkQsT0FBS0ssVUFBTCxDQUFnQjJtQixZQUFoQixDQUE2QnZqQixRQUE3QixFQUF1Q3pELElBQXZDO0FBQ0FBLFNBQU95RCxXQUFXLElBQWxCO0FBQ0QsQ0FoQkQ7QUFpQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkEsQ0FBQyxVQUFVbEssR0FBVixFQUFlO0FBQ2QsV0FBU3MzQixlQUFULENBQXlCN3dCLElBQXpCLEVBQStCO0FBQzdCLFdBQU96RyxJQUFJcXRCLFFBQUosQ0FBYSxTQUFiLEVBQXdCQyxJQUF4QixDQUE2QjdtQixJQUE3QixNQUF1QyxPQUE5QztBQUNEOztBQUVELFdBQVM4d0IsWUFBVCxDQUFzQjl3QixJQUF0QixFQUE0QjtBQUMxQixXQUFPQSxLQUFLZ0UsUUFBTCxLQUFrQixJQUF6QjtBQUNEOztBQUVELFdBQVMrc0IsZ0JBQVQsQ0FBMEJyVixPQUExQixFQUFtQztBQUNqQyxRQUFJOEssWUFBWTlLLFFBQVF4WixhQUFSLENBQXNCekMsYUFBdEIsQ0FBb0MsSUFBcEMsQ0FBaEI7QUFDQWljLFlBQVEvWixXQUFSLENBQW9CNmtCLFNBQXBCO0FBQ0Q7O0FBRUQsV0FBU3dLLFdBQVQsQ0FBcUIvSyxJQUFyQixFQUEyQjtBQUN6QixRQUFJQSxLQUFLamlCLFFBQUwsS0FBa0IsTUFBbEIsSUFBNEJpaUIsS0FBS2ppQixRQUFMLEtBQWtCLElBQTlDLElBQXNEaWlCLEtBQUtqaUIsUUFBTCxLQUFrQixJQUE1RSxFQUFrRjtBQUNoRjtBQUNEOztBQUVELFFBQUk1QixNQUFNNmpCLEtBQUsvakIsYUFBZjtBQUFBLFFBQ0l1QixXQUFXckIsSUFBSXNCLHNCQUFKLEVBRGY7QUFBQSxRQUVJbEQsa0JBQWtCeWxCLEtBQUtnTCxzQkFBTCxJQUErQmhMLEtBQUt6bEIsZUFGMUQ7QUFBQSxRQUdJK0MsVUFISjtBQUFBLFFBSUk4SixTQUpKO0FBQUEsUUFLSTZqQixXQUxKO0FBQUEsUUFNSUMscUJBTko7QUFBQSxRQU9JakwsUUFQSjs7QUFTQSxRQUFJMWxCLG1CQUFtQixDQUFDcXdCLGdCQUFnQnJ3QixlQUFoQixDQUF4QixFQUEwRDtBQUN4RHV3Qix1QkFBaUJ0dEIsUUFBakI7QUFDRDs7QUFFRCxXQUFPeWlCLFdBQVdELEtBQUsxaUIsVUFBdkIsRUFBbUM7QUFDakM4SixrQkFBWTZZLFNBQVM3WSxTQUFyQjtBQUNBLGFBQU85SixhQUFhMmlCLFNBQVMzaUIsVUFBN0IsRUFBeUM7QUFDdkMydEIsc0JBQWMzdEIsZUFBZThKLFNBQTdCO0FBQ0E7QUFDQThqQixnQ0FBd0JELGVBQWUsQ0FBQ0wsZ0JBQWdCdHRCLFVBQWhCLENBQWhCLElBQStDLENBQUN1dEIsYUFBYXZ0QixVQUFiLENBQXhFO0FBQ0FFLGlCQUFTOUIsV0FBVCxDQUFxQjRCLFVBQXJCO0FBQ0EsWUFBSTR0QixxQkFBSixFQUEyQjtBQUN6QkosMkJBQWlCdHRCLFFBQWpCO0FBQ0Q7QUFDRjs7QUFFRHlpQixlQUFTN2xCLFVBQVQsQ0FBb0IrSSxXQUFwQixDQUFnQzhjLFFBQWhDO0FBQ0Q7QUFDREQsU0FBSzVsQixVQUFMLENBQWdCMm1CLFlBQWhCLENBQTZCdmpCLFFBQTdCLEVBQXVDd2lCLElBQXZDO0FBQ0Q7O0FBRUQxc0IsTUFBSXkzQixXQUFKLEdBQWtCQSxXQUFsQjtBQUNELENBbERELEVBa0RHNTNCLFVBQVVHLEdBbERiLEUsQ0FrRG1COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JuQixDQUFDLFVBQVVILFNBQVYsRUFBcUI7QUFDcEIsTUFBSTs7O0FBR0pnSixRQUFNN0UsUUFITjs7O0FBS0E7OztBQUdBNnpCLHFCQUFtQixDQUFDLFFBQUQsRUFBVyxLQUFYLEVBQWtCLFFBQWxCLEVBQTRCLGNBQTVCLEVBQTRDLFFBQTVDLEVBQXNELGNBQXRELEVBQXNFLGVBQXRFLEVBQXVGLGdCQUF2RixFQUF5RyxXQUF6RyxDQVJuQjs7O0FBVUE7OztBQUdBQyxzQkFBb0IsQ0FBQyxNQUFELEVBQVMsT0FBVCxFQUFrQixZQUFsQixFQUFnQyxpQkFBaEMsRUFBbUQsT0FBbkQsRUFBNEQsU0FBNUQsRUFBdUUsUUFBdkUsRUFBaUYsY0FBakYsRUFBaUcsYUFBakcsRUFBZ0gsZ0JBQWhILEVBQWtJLGdCQUFsSSxDQWJwQjs7O0FBZUE7OztBQUdBQyx1QkFBcUIsQ0FBQyxVQUFELEVBQWEsT0FBYixFQUFzQixNQUF0QixFQUE4QixPQUE5QixDQWxCckI7O0FBb0JBbDRCLFlBQVVHLEdBQVYsQ0FBY2c0QixPQUFkLEdBQXdCclYsS0FBS2xmLE1BQUw7QUFDeEIsK0NBQTZDOztBQUUzQzlELGlCQUFhLFNBQVNBLFdBQVQsQ0FBcUJzNEIsYUFBckIsRUFBb0NwMUIsTUFBcEMsRUFBNEM7QUFDdkQsV0FBS3ExQixRQUFMLEdBQWdCRCxpQkFBaUJwNEIsVUFBVVUsY0FBM0M7QUFDQSxXQUFLc0MsTUFBTCxHQUFjaEQsVUFBVU0sSUFBVixDQUFlNmpCLE1BQWYsQ0FBc0IsRUFBdEIsRUFBMEIrRixLQUExQixDQUFnQ2xuQixNQUFoQyxFQUF3Q3NtQixHQUF4QyxFQUFkO0FBQ0EsV0FBS3BMLE1BQUwsR0FBYyxLQUFLb2EsYUFBTCxFQUFkO0FBQ0QsS0FOMEM7O0FBUTNDQyxnQkFBWSxTQUFTQSxVQUFULENBQW9CalcsT0FBcEIsRUFBNkI7QUFDdkMsVUFBSSxPQUFPQSxPQUFQLEtBQW1CLFFBQXZCLEVBQWlDO0FBQy9CQSxrQkFBVXRaLElBQUl3dkIsY0FBSixDQUFtQmxXLE9BQW5CLENBQVY7QUFDRDs7QUFFREEsY0FBUS9aLFdBQVIsQ0FBb0IsS0FBSzJWLE1BQXpCO0FBQ0QsS0FkMEM7O0FBZ0IzQ3VhLGVBQVcsU0FBU0EsU0FBVCxHQUFxQjtBQUM5QixhQUFPLEtBQUt2YSxNQUFaO0FBQ0QsS0FsQjBDOztBQW9CM0NuVixlQUFXLFNBQVNBLFNBQVQsR0FBcUI7QUFDOUIsV0FBSzJ2QixXQUFMO0FBQ0QsS0F0QjBDOztBQXdCM0M3dkIsaUJBQWEsU0FBU0EsV0FBVCxHQUF1QjtBQUNsQyxXQUFLNnZCLFdBQUw7QUFDRCxLQTFCMEM7O0FBNEIzQ0MsYUFBUyxTQUFTQSxPQUFULEdBQW1CO0FBQzFCLFVBQUl6YSxTQUFTLEtBQUt1YSxTQUFMLEVBQWI7QUFDQXZhLGFBQU9qWCxVQUFQLENBQWtCK0ksV0FBbEIsQ0FBOEJrTyxNQUE5QjtBQUNELEtBL0IwQzs7QUFpQzNDd2EsaUJBQWEsU0FBU0EsV0FBVCxHQUF1QjtBQUNsQyxZQUFNLElBQUlwekIsS0FBSixDQUFVLG9EQUFWLENBQU47QUFDRCxLQW5DMEM7O0FBcUMzQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQWd6QixtQkFBZSxTQUFTQSxhQUFULEdBQXlCO0FBQ3RDLFVBQUlNLE9BQU8sSUFBWDtBQUFBLFVBQ0kxYSxTQUFTbFYsSUFBSTNDLGFBQUosQ0FBa0IsUUFBbEIsQ0FEYjtBQUVBNlgsYUFBT21PLFNBQVAsR0FBbUIsbUJBQW5CO0FBQ0Fyc0IsZ0JBQVVHLEdBQVYsQ0FBY3cwQixhQUFkLENBQTRCO0FBQzFCLG9CQUFZLFlBRGM7QUFFMUIsNkJBQXFCLE1BRks7QUFHMUIsdUJBQWUsQ0FIVztBQUkxQixpQkFBUyxDQUppQjtBQUsxQixrQkFBVSxDQUxnQjtBQU0xQix1QkFBZSxDQU5XO0FBTzFCLHdCQUFnQjtBQVBVLE9BQTVCLEVBUUcvSyxFQVJILENBUU0xTCxNQVJOOztBQVVBO0FBQ0EsVUFBSWxlLFVBQVV3a0IsT0FBVixDQUFrQjJCLDZDQUFsQixFQUFKLEVBQXVFO0FBQ3JFakksZUFBTzJYLEdBQVAsR0FBYSw0QkFBYjtBQUNEOztBQUVEM1gsYUFBTzJhLE1BQVAsR0FBZ0IsWUFBWTtBQUMxQjNhLGVBQU80YSxrQkFBUCxHQUE0QjVhLE9BQU8yYSxNQUFQLEdBQWdCLElBQTVDO0FBQ0FELGFBQUtHLGFBQUwsQ0FBbUI3YSxNQUFuQjtBQUNELE9BSEQ7O0FBS0FBLGFBQU80YSxrQkFBUCxHQUE0QixZQUFZO0FBQ3RDLFlBQUksa0JBQWtCanFCLElBQWxCLENBQXVCcVAsT0FBT2tZLFVBQTlCLENBQUosRUFBK0M7QUFDN0NsWSxpQkFBTzRhLGtCQUFQLEdBQTRCNWEsT0FBTzJhLE1BQVAsR0FBZ0IsSUFBNUM7QUFDQUQsZUFBS0csYUFBTCxDQUFtQjdhLE1BQW5CO0FBQ0Q7QUFDRixPQUxEOztBQU9BLGFBQU9BLE1BQVA7QUFDRCxLQXhGMEM7O0FBMEYzQzs7O0FBR0E2YSxtQkFBZSxTQUFTQSxhQUFULENBQXVCN2EsTUFBdkIsRUFBK0I7QUFDNUM7QUFDQSxVQUFJLENBQUNsZSxVQUFVRyxHQUFWLENBQWM2VixRQUFkLENBQXVCaE4sSUFBSXNKLGVBQTNCLEVBQTRDNEwsTUFBNUMsQ0FBTCxFQUEwRDtBQUN4RDtBQUNEOztBQUVELFVBQUkwYSxPQUFPLElBQVg7QUFBQSxVQUNJSSxlQUFlOWEsT0FBTzVVLGFBRDFCO0FBQUEsVUFFSTJ2QixpQkFBaUIvYSxPQUFPNVUsYUFBUCxDQUFxQm5GLFFBRjFDO0FBQUEsVUFHSSswQixVQUFVbHdCLElBQUltd0IsWUFBSixJQUFvQm53QixJQUFJa3dCLE9BQXhCLElBQW1DLE9BSGpEO0FBQUEsVUFJSUUsY0FBYyxLQUFLQyxRQUFMLENBQWM7QUFDOUJILGlCQUFTQSxPQURxQjtBQUU5QkkscUJBQWEsS0FBS3QyQixNQUFMLENBQVlzMkI7QUFGSyxPQUFkLENBSmxCOztBQVNBO0FBQ0FMLHFCQUFlN2EsSUFBZixDQUFvQixXQUFwQixFQUFpQyxTQUFqQztBQUNBNmEscUJBQWU1YSxLQUFmLENBQXFCK2EsV0FBckI7QUFDQUgscUJBQWUzYSxLQUFmOztBQUVBLFdBQUt2VixTQUFMLEdBQWlCLFlBQVk7QUFDM0IsZUFBT21WLE9BQU81VSxhQUFkO0FBQ0QsT0FGRDtBQUdBLFdBQUtULFdBQUwsR0FBbUIsWUFBWTtBQUM3QixlQUFPcVYsT0FBTzVVLGFBQVAsQ0FBcUJuRixRQUE1QjtBQUNELE9BRkQ7O0FBSUE7QUFDQTtBQUNBO0FBQ0E2MEIsbUJBQWFPLE9BQWIsR0FBdUIsVUFBVUMsWUFBVixFQUF3QkMsUUFBeEIsRUFBa0NDLFVBQWxDLEVBQThDO0FBQ25FLGNBQU0sSUFBSXAwQixLQUFKLENBQVUsd0JBQXdCazBCLFlBQWxDLEVBQWdEQyxRQUFoRCxFQUEwREMsVUFBMUQsQ0FBTjtBQUNELE9BRkQ7O0FBSUEsVUFBSSxDQUFDMTVCLFVBQVV3a0IsT0FBVixDQUFrQjBCLHdCQUFsQixFQUFMLEVBQW1EO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUkvakIsQ0FBSixFQUFPQyxNQUFQO0FBQ0EsYUFBS0QsSUFBSSxDQUFKLEVBQU9DLFNBQVM0MUIsaUJBQWlCNTFCLE1BQXRDLEVBQThDRCxJQUFJQyxNQUFsRCxFQUEwREQsR0FBMUQsRUFBK0Q7QUFDN0QsZUFBS3czQixNQUFMLENBQVlYLFlBQVosRUFBMEJoQixpQkFBaUI3MUIsQ0FBakIsQ0FBMUI7QUFDRDtBQUNELGFBQUtBLElBQUksQ0FBSixFQUFPQyxTQUFTNjFCLGtCQUFrQjcxQixNQUF2QyxFQUErQ0QsSUFBSUMsTUFBbkQsRUFBMkRELEdBQTNELEVBQWdFO0FBQzlELGVBQUt3M0IsTUFBTCxDQUFZWCxZQUFaLEVBQTBCZixrQkFBa0I5MUIsQ0FBbEIsQ0FBMUIsRUFBZ0RuQyxVQUFVVSxjQUExRDtBQUNEO0FBQ0QsYUFBS3lCLElBQUksQ0FBSixFQUFPQyxTQUFTODFCLG1CQUFtQjkxQixNQUF4QyxFQUFnREQsSUFBSUMsTUFBcEQsRUFBNERELEdBQTVELEVBQWlFO0FBQy9ELGVBQUt3M0IsTUFBTCxDQUFZVixjQUFaLEVBQTRCZixtQkFBbUIvMUIsQ0FBbkIsQ0FBNUI7QUFDRDtBQUNEO0FBQ0E7QUFDQSxhQUFLdzNCLE1BQUwsQ0FBWVYsY0FBWixFQUE0QixRQUE1QixFQUFzQyxFQUF0QyxFQUEwQyxJQUExQztBQUNEOztBQUVELFdBQUtXLE1BQUwsR0FBYyxJQUFkOztBQUVBO0FBQ0FDLGlCQUFXLFlBQVk7QUFDckJqQixhQUFLUCxRQUFMLENBQWNPLElBQWQ7QUFDRCxPQUZELEVBRUcsQ0FGSDtBQUdELEtBM0owQzs7QUE2SjNDUyxjQUFVLFNBQVNBLFFBQVQsQ0FBa0JTLFlBQWxCLEVBQWdDO0FBQ3hDLFVBQUlSLGNBQWNRLGFBQWFSLFdBQS9CO0FBQUEsVUFDSTlXLE9BQU8sRUFEWDtBQUFBLFVBRUlyZ0IsSUFBSSxDQUZSO0FBQUEsVUFHSUMsTUFISjtBQUlBazNCLG9CQUFjLE9BQU9BLFdBQVAsS0FBdUIsUUFBdkIsR0FBa0MsQ0FBQ0EsV0FBRCxDQUFsQyxHQUFrREEsV0FBaEU7QUFDQSxVQUFJQSxXQUFKLEVBQWlCO0FBQ2ZsM0IsaUJBQVNrM0IsWUFBWWwzQixNQUFyQjtBQUNBLGVBQU9ELElBQUlDLE1BQVgsRUFBbUJELEdBQW5CLEVBQXdCO0FBQ3RCcWdCLGtCQUFRLGtDQUFrQzhXLFlBQVluM0IsQ0FBWixDQUFsQyxHQUFtRCxJQUEzRDtBQUNEO0FBQ0Y7QUFDRDIzQixtQkFBYVIsV0FBYixHQUEyQjlXLElBQTNCOztBQUVBLGFBQU94aUIsVUFBVU0sSUFBVixDQUFla3FCLE1BQWYsQ0FBc0IsZ0NBQWdDLGtEQUFoQyxHQUFxRixzQkFBM0csRUFBbUlHLFdBQW5JLENBQStJbVAsWUFBL0ksQ0FBUDtBQUNELEtBNUswQzs7QUE4SzNDOzs7Ozs7QUFNQUgsWUFBUSxTQUFTQSxNQUFULENBQWdCeFYsTUFBaEIsRUFBd0IwRSxRQUF4QixFQUFrQ2pGLEtBQWxDLEVBQXlDbVcsTUFBekMsRUFBaUQ7QUFDdkQsVUFBSTtBQUNGNVYsZUFBTzBFLFFBQVAsSUFBbUJqRixLQUFuQjtBQUNELE9BRkQsQ0FFRSxPQUFPN2QsQ0FBUCxFQUFVLENBQUU7O0FBRWQsVUFBSTtBQUNGb2UsZUFBTzZWLGdCQUFQLENBQXdCblIsUUFBeEIsRUFBa0MsWUFBWTtBQUM1QyxpQkFBT2pGLEtBQVA7QUFDRCxTQUZEO0FBR0QsT0FKRCxDQUlFLE9BQU83ZCxDQUFQLEVBQVUsQ0FBRTtBQUNkLFVBQUlnMEIsTUFBSixFQUFZO0FBQ1YsWUFBSTtBQUNGNVYsaUJBQU84VixnQkFBUCxDQUF3QnBSLFFBQXhCLEVBQWtDLFlBQVksQ0FBRSxDQUFoRDtBQUNELFNBRkQsQ0FFRSxPQUFPOWlCLENBQVAsRUFBVSxDQUFFO0FBQ2Y7O0FBRUQsVUFBSSxDQUFDL0YsVUFBVXdrQixPQUFWLENBQWtCb0UseUJBQWxCLENBQTRDQyxRQUE1QyxDQUFMLEVBQTREO0FBQzFELFlBQUk7QUFDRixjQUFJN2xCLFNBQVM7QUFDWHNtQixpQkFBSyxTQUFTQSxHQUFULEdBQWU7QUFDbEIscUJBQU8xRixLQUFQO0FBQ0Q7QUFIVSxXQUFiO0FBS0EsY0FBSW1XLE1BQUosRUFBWTtBQUNWLzJCLG1CQUFPazNCLEdBQVAsR0FBYSxZQUFZLENBQUUsQ0FBM0I7QUFDRDtBQUNEaFcsaUJBQU9pVyxjQUFQLENBQXNCaFcsTUFBdEIsRUFBOEIwRSxRQUE5QixFQUF3QzdsQixNQUF4QztBQUNELFNBVkQsQ0FVRSxPQUFPK0MsQ0FBUCxFQUFVLENBQUU7QUFDZjtBQUNGO0FBak4wQyxHQURyQixDQUF4QjtBQW9ORCxDQXpPRCxFQXlPRy9GLFNBek9IO0FBME9BLENBQUMsWUFBWTtBQUNYLE1BQUkwMkIsVUFBVTtBQUNaLGlCQUFhO0FBREQsR0FBZDtBQUdBMTJCLFlBQVVHLEdBQVYsQ0FBY3cwQixhQUFkLEdBQThCLFVBQVVaLFVBQVYsRUFBc0I7QUFDbEQsV0FBTztBQUNMbkssVUFBSSxTQUFTQSxFQUFULENBQVl0SCxPQUFaLEVBQXFCO0FBQ3ZCLGFBQUssSUFBSW5nQixDQUFULElBQWM0eEIsVUFBZCxFQUEwQjtBQUN4QnpSLGtCQUFRbUUsWUFBUixDQUFxQmlRLFFBQVF2MEIsQ0FBUixLQUFjQSxDQUFuQyxFQUFzQzR4QixXQUFXNXhCLENBQVgsQ0FBdEM7QUFDRDtBQUNGO0FBTEksS0FBUDtBQU9ELEdBUkQ7QUFTRCxDQWJELElBYUtuQyxVQUFVRyxHQUFWLENBQWM2dUIsU0FBZCxHQUEwQixVQUFVb0wsTUFBVixFQUFrQjtBQUMvQyxTQUFPO0FBQ0x4USxRQUFJLFNBQVNBLEVBQVQsQ0FBWXRILE9BQVosRUFBcUI7QUFDdkIsVUFBSWdOLFFBQVFoTixRQUFRZ04sS0FBcEI7QUFDQSxVQUFJLE9BQU84SyxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQzlCOUssY0FBTVYsT0FBTixJQUFpQixNQUFNd0wsTUFBdkI7QUFDQTtBQUNEO0FBQ0QsV0FBSyxJQUFJajRCLENBQVQsSUFBY2k0QixNQUFkLEVBQXNCO0FBQ3BCLFlBQUlqNEIsTUFBTSxPQUFWLEVBQW1CO0FBQ2pCbXRCLGdCQUFNK0ssUUFBTixHQUFpQkQsT0FBT2o0QixDQUFQLENBQWpCO0FBQ0FtdEIsZ0JBQU1nTCxVQUFOLEdBQW1CRixPQUFPajRCLENBQVAsQ0FBbkI7QUFDRCxTQUhELE1BR087QUFDTG10QixnQkFBTW50QixDQUFOLElBQVdpNEIsT0FBT2o0QixDQUFQLENBQVg7QUFDRDtBQUNGO0FBQ0Y7QUFmSSxHQUFQO0FBaUJELENBbEJJLEMsQ0FrQkY7Ozs7Ozs7Ozs7Ozs7O0FBY0gsQ0FBQyxVQUFVaEMsR0FBVixFQUFlO0FBQ2RBLE1BQUlvNkIsbUJBQUosR0FBMEIsVUFBVUMsTUFBVixFQUFrQkMsSUFBbEIsRUFBd0JDLGVBQXhCLEVBQXlDO0FBQ2pFLFFBQUlDLGFBQWEsYUFBakI7QUFBQSxRQUNJQyxRQUFRLFNBQVNBLEtBQVQsR0FBaUI7QUFDM0IsVUFBSUgsS0FBS0ksaUJBQUwsRUFBSixFQUE4QjtBQUM1QkosYUFBS0ssS0FBTDtBQUNEO0FBQ0QzNkIsVUFBSXFzQixXQUFKLENBQWdCaU8sS0FBS25ZLE9BQXJCLEVBQThCcVksVUFBOUI7QUFDRCxLQU5EO0FBQUEsUUFPSVQsTUFBTSxTQUFTQSxHQUFULEdBQWU7QUFDdkIsVUFBSU8sS0FBS00sT0FBTCxFQUFKLEVBQW9CO0FBQ2xCTixhQUFLTyxRQUFMLENBQWNOLGVBQWQ7QUFDQXY2QixZQUFJaXNCLFFBQUosQ0FBYXFPLEtBQUtuWSxPQUFsQixFQUEyQnFZLFVBQTNCO0FBQ0Q7QUFDRixLQVpEOztBQWNBSCxXQUFPL1EsT0FBUCxDQUFlLGlCQUFmLEVBQWtDeVEsR0FBbEMsRUFBdUN6USxPQUF2QyxDQUErQyxtQkFBL0MsRUFBb0VtUixLQUFwRSxFQUEyRW5SLE9BQTNFLENBQW1GLGdCQUFuRixFQUFxR21SLEtBQXJHLEVBQTRHblIsT0FBNUcsQ0FBb0gsZ0JBQXBILEVBQXNJbVIsS0FBdEksRUFBNkluUixPQUE3SSxDQUFxSixlQUFySixFQUFzS3lRLEdBQXRLOztBQUVBQTtBQUNELEdBbEJEO0FBbUJELENBcEJELEVBb0JHbDZCLFVBQVVHLEdBcEJiO0FBcUJBLENBQUMsVUFBVUEsR0FBVixFQUFlO0FBQ2QsTUFBSW1TLGtCQUFrQm5PLFNBQVNtTyxlQUEvQjtBQUNBLE1BQUksaUJBQWlCQSxlQUFyQixFQUFzQztBQUNwQ25TLFFBQUk4NkIsY0FBSixHQUFxQixVQUFVM1ksT0FBVixFQUFtQnRILElBQW5CLEVBQXlCO0FBQzVDc0gsY0FBUTRZLFdBQVIsR0FBc0JsZ0IsSUFBdEI7QUFDRCxLQUZEOztBQUlBN2EsUUFBSWc3QixjQUFKLEdBQXFCLFVBQVU3WSxPQUFWLEVBQW1CO0FBQ3RDLGFBQU9BLFFBQVE0WSxXQUFmO0FBQ0QsS0FGRDtBQUdELEdBUkQsTUFRTyxJQUFJLGVBQWU1b0IsZUFBbkIsRUFBb0M7QUFDekNuUyxRQUFJODZCLGNBQUosR0FBcUIsVUFBVTNZLE9BQVYsRUFBbUJ0SCxJQUFuQixFQUF5QjtBQUM1Q3NILGNBQVE4WSxTQUFSLEdBQW9CcGdCLElBQXBCO0FBQ0QsS0FGRDs7QUFJQTdhLFFBQUlnN0IsY0FBSixHQUFxQixVQUFVN1ksT0FBVixFQUFtQjtBQUN0QyxhQUFPQSxRQUFROFksU0FBZjtBQUNELEtBRkQ7QUFHRCxHQVJNLE1BUUE7QUFDTGo3QixRQUFJODZCLGNBQUosR0FBcUIsVUFBVTNZLE9BQVYsRUFBbUJ0SCxJQUFuQixFQUF5QjtBQUM1Q3NILGNBQVErWSxTQUFSLEdBQW9CcmdCLElBQXBCO0FBQ0QsS0FGRDs7QUFJQTdhLFFBQUlnN0IsY0FBSixHQUFxQixVQUFVN1ksT0FBVixFQUFtQjtBQUN0QyxhQUFPQSxRQUFRK1ksU0FBZjtBQUNELEtBRkQ7QUFHRDtBQUNGLENBM0JELEVBMkJHcjdCLFVBQVVHLEdBM0JiOztBQTZCQTs7Ozs7O0FBTUFILFVBQVVJLE1BQVYsQ0FBaUJrN0IsZUFBakIsR0FBbUMsWUFBWTtBQUM3QztBQUNBLE1BQUlySSxlQUFlO0FBQ2pCO0FBQ0EsV0FBT2p6QixVQUFVRyxHQUFWLENBQWNxM0I7QUFGSixHQUFuQjs7QUFLQSxXQUFTOEQsZUFBVCxDQUF5QmpJLGFBQXpCLEVBQXdDdEIsS0FBeEMsRUFBK0MxTixPQUEvQyxFQUF3RDtBQUN0RDBOLFlBQVFBLFNBQVNrQixZQUFqQjtBQUNBNU8sY0FBVUEsV0FBV2dQLGNBQWN2cUIsYUFBekIsSUFBMEMzRSxRQUFwRDs7QUFFQSxRQUFJbWUsT0FBSjtBQUFBLFFBQ0lpUixXQUFXLE9BQU9GLGFBQVAsS0FBeUIsUUFEeEM7QUFBQSxRQUVJeFAsTUFGSjtBQUFBLFFBR0kwWCxPQUhKO0FBQUEsUUFJSUMsYUFKSjtBQUFBLFFBS0lyNUIsQ0FMSjtBQUFBLFFBTUlzNUIsSUFBSSxDQU5SO0FBT0EsUUFBSWxJLFFBQUosRUFBYztBQUNaalIsZ0JBQVV0aUIsVUFBVUcsR0FBVixDQUFjaXZCLFFBQWQsQ0FBdUJpRSxhQUF2QixFQUFzQ2hQLE9BQXRDLENBQVY7QUFDRCxLQUZELE1BRU87QUFDTC9CLGdCQUFVK1EsYUFBVjtBQUNEO0FBQ0QsUUFBSS9RLFFBQVF1RCxnQkFBWixFQUE4QjtBQUM1QnZELGNBQVFuUSxTQUFSLEdBQW9CbVEsUUFBUW5RLFNBQVIsQ0FBa0I4SSxPQUFsQixDQUEwQixLQUExQixFQUFpQyxPQUFqQyxDQUFwQjtBQUNBLFVBQUl5Z0IsTUFBTXBaLFFBQVF1RCxnQkFBUixDQUF5QixPQUF6QixDQUFWO0FBQ0EsV0FBSyxJQUFJMWpCLElBQUksQ0FBYixFQUFnQkEsSUFBSXU1QixJQUFJdDVCLE1BQXhCLEVBQWdDRCxHQUFoQyxFQUFxQztBQUNuQyxZQUFJaUUsS0FBS3MxQixJQUFJdjVCLENBQUosQ0FBVDtBQUNBaUUsV0FBR1csYUFBSCxDQUFpQmlKLFdBQWpCLENBQTZCNUosRUFBN0I7QUFDRDtBQUNELFVBQUl1MUIsT0FBT3JaLFFBQVF1RCxnQkFBUixDQUF5QixLQUF6QixDQUFYO0FBQ0EsV0FBSyxJQUFJMWpCLElBQUksQ0FBYixFQUFnQkEsSUFBSXc1QixLQUFLdjVCLE1BQXpCLEVBQWlDRCxHQUFqQyxFQUFzQztBQUNwQyxZQUFJeTVCLE1BQU1ELEtBQUt4NUIsQ0FBTCxDQUFWO0FBQ0EsWUFBSTA1QixVQUFVMTNCLFNBQVNrQyxhQUFULENBQXVCLEdBQXZCLENBQWQ7QUFDQXcxQixnQkFBUVQsU0FBUixHQUFvQlEsSUFBSVIsU0FBeEI7QUFDQVEsWUFBSUUsV0FBSixDQUFnQkQsT0FBaEI7QUFDRDtBQUNELFVBQUlFLFFBQVF6WixRQUFRdUQsZ0JBQVIsQ0FBeUIsR0FBekIsQ0FBWjtBQUNBLFdBQUssSUFBSTFqQixJQUFJLENBQWIsRUFBZ0JBLElBQUk0NUIsTUFBTTM1QixNQUExQixFQUFrQ0QsR0FBbEMsRUFBdUM7QUFDckMsWUFBSWlFLEtBQUsyMUIsTUFBTTU1QixDQUFOLENBQVQ7QUFDQSxZQUFJLENBQUM2NUIsRUFBRXRSLElBQUYsQ0FBT3RrQixHQUFHZzFCLFNBQVYsRUFBcUJoNUIsTUFBMUIsRUFBa0M7QUFDaENnRSxhQUFHVyxhQUFILENBQWlCaUosV0FBakIsQ0FBNkI1SixFQUE3QjtBQUNEO0FBQ0Y7QUFDRCxVQUFJNjFCLFNBQVMzWixRQUFRdUQsZ0JBQVIsQ0FBeUIsSUFBekIsQ0FBYjtBQUNBLFVBQUkxakIsSUFBSSxDQUFSO0FBQ0EsYUFBTUEsSUFBSTg1QixPQUFPNzVCLE1BQVAsR0FBZ0IsQ0FBMUIsRUFBNkI7QUFDM0IsWUFBSTg1QixLQUFLRCxPQUFPOTVCLENBQVAsQ0FBVDtBQUNBLGVBQU8rNUIsR0FBRzd6QixXQUFILElBQWtCNHpCLE9BQU85NUIsSUFBSSxDQUFYLENBQXpCLEVBQXdDO0FBQ3RDLGNBQUlpRSxLQUFLNjFCLE9BQU85NUIsSUFBSSxDQUFYLENBQVQ7QUFDQWlFLGFBQUdXLGFBQUgsQ0FBaUJpSixXQUFqQixDQUE2QjVKLEVBQTdCO0FBQ0FqRTtBQUNEO0FBQ0RBO0FBQ0Q7QUFDRCxXQUFLLElBQUlBLElBQUksQ0FBYixFQUFnQkEsSUFBSTg1QixPQUFPNzVCLE1BQVAsR0FBZ0IsQ0FBcEMsRUFBdUNELEdBQXZDLEVBQTRDO0FBQzFDODVCLGVBQU85NUIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBS0EsQ0FBTCxJQUFVNHZCLEtBQVYsRUFBaUI7QUFDZndKLGdCQUFValosUUFBUXVELGdCQUFSLENBQXlCMWpCLENBQXpCLENBQVY7QUFDQTBoQixlQUFTa08sTUFBTTV2QixDQUFOLENBQVQ7QUFDQXE1QixzQkFBZ0JELFFBQVFuNUIsTUFBeEI7QUFDQSxhQUFPcTVCLElBQUlELGFBQVgsRUFBMEJDLEdBQTFCLEVBQStCO0FBQzdCNVgsZUFBTzBYLFFBQVFFLENBQVIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRURGLGNBQVVsSSxnQkFBZ0J0QixRQUFRLElBQWxDOztBQUVBLFdBQU93QixXQUFXalIsUUFBUW5RLFNBQW5CLEdBQStCbVEsT0FBdEM7QUFDRDs7QUFFRCxTQUFPZ1osZUFBUDtBQUNELENBM0VrQyxFQUFuQyxDLENBMkVLOzs7Ozs7O0FBT0wsQ0FBQyxVQUFVdDdCLFNBQVYsRUFBcUI7QUFDcEIsTUFBSUcsTUFBTUgsVUFBVUcsR0FBcEI7O0FBRUFILFlBQVVJLE1BQVYsQ0FBaUIrN0Isb0JBQWpCLEdBQXdDLFlBQVk7QUFDbEQsUUFBSUMsbUJBQW1CLFNBQVNBLGdCQUFULENBQTBCak4sS0FBMUIsRUFBaUM7QUFDdEQsVUFBSTdNLFVBQVUsSUFBZDtBQUNBdVgsaUJBQVcsWUFBWTtBQUNyQixZQUFJMW5CLFlBQVltUSxRQUFRblEsU0FBUixDQUFrQmtULFdBQWxCLEVBQWhCO0FBQ0EsWUFBSWxULGFBQWEsZUFBYixJQUFnQ0EsYUFBYSw0QkFBakQsRUFBK0U7QUFDN0VtUSxrQkFBUW5RLFNBQVIsR0FBb0IsRUFBcEI7QUFDRDtBQUNGLE9BTEQsRUFLRyxDQUxIO0FBTUQsS0FSRDs7QUFVQSxXQUFPLFVBQVVrcUIsUUFBVixFQUFvQjtBQUN6Qmw4QixVQUFJc3BCLE9BQUosQ0FBWTRTLFNBQVMvWixPQUFyQixFQUE4QixDQUFDLEtBQUQsRUFBUSxTQUFSLENBQTlCLEVBQWtEOFosZ0JBQWxEO0FBQ0QsS0FGRDtBQUdELEdBZHVDLEVBQXhDOztBQWdCQTs7Ozs7OztBQU9BcDhCLFlBQVVJLE1BQVYsQ0FBaUJrOEIsMkJBQWpCLEdBQStDLFlBQVk7QUFDekQsUUFBSUMsMkJBQTJCLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxNQUFiLENBQS9COztBQUVBLFFBQUlILG1CQUFtQixTQUFTQSxnQkFBVCxDQUEwQjlaLE9BQTFCLEVBQW1Da2Esc0JBQW5DLEVBQTJEO0FBQ2hGLFVBQUksQ0FBQ0EsdUJBQXVCcnlCLFVBQXhCLElBQXNDLENBQUNuSyxVQUFVTSxJQUFWLENBQWUyb0IsS0FBZixDQUFxQnNULHdCQUFyQixFQUErQ3ZtQixRQUEvQyxDQUF3RHdtQix1QkFBdUJyeUIsVUFBdkIsQ0FBa0NTLFFBQTFGLENBQTNDLEVBQWdKO0FBQzlJO0FBQ0Q7O0FBRUQsVUFBSWlpQixPQUFPMXNCLElBQUl3dkIsZ0JBQUosQ0FBcUJyTixPQUFyQixFQUE4QixFQUFFMVgsVUFBVTJ4Qix3QkFBWixFQUE5QixDQUFYO0FBQ0EsVUFBSSxDQUFDMVAsSUFBTCxFQUFXO0FBQ1Q7QUFDRDs7QUFFRCxVQUFJNFAsb0NBQW9DNVAsUUFBUTJQLHVCQUF1QnJ5QixVQUF2RTtBQUNBLFVBQUksQ0FBQ3N5QixpQ0FBTCxFQUF3QztBQUN0QztBQUNEOztBQUVELFVBQUlDLHFCQUFxQjdQLEtBQUt2bEIsVUFBTCxDQUFnQmxGLE1BQWhCLElBQTBCLENBQW5EO0FBQ0EsVUFBSSxDQUFDczZCLGtCQUFMLEVBQXlCO0FBQ3ZCO0FBQ0Q7O0FBRUQsVUFBSUMsc0JBQXNCOVAsS0FBSzFpQixVQUFMLEdBQWtCMGlCLEtBQUsxaUIsVUFBTCxDQUFnQmdJLFNBQWhCLEtBQThCLEVBQWhELEdBQXFELElBQS9FO0FBQ0EsVUFBSSxDQUFDd3FCLG1CQUFMLEVBQTBCO0FBQ3hCO0FBQ0Q7O0FBRUQ5UCxXQUFLNWxCLFVBQUwsQ0FBZ0IrSSxXQUFoQixDQUE0QjZjLElBQTVCO0FBQ0QsS0ExQkQ7O0FBNEJBLFdBQU8sVUFBVXdQLFFBQVYsRUFBb0I7QUFDekJsOEIsVUFBSXNwQixPQUFKLENBQVk0UyxTQUFTL1osT0FBckIsRUFBOEIsU0FBOUIsRUFBeUMsVUFBVTZNLEtBQVYsRUFBaUI7QUFDeEQsWUFBSUEsTUFBTXlOLE9BQU4sS0FBa0I1OEIsVUFBVWEsYUFBaEMsRUFBK0M7QUFDN0M7QUFDRDs7QUFFRCxZQUFJeWhCLFVBQVUrWixTQUFTOTdCLFNBQVQsQ0FBbUJzOEIsZUFBbkIsRUFBZDtBQUNBVCx5QkFBaUI5WixPQUFqQixFQUEwQitaLFNBQVMvWixPQUFuQztBQUNELE9BUEQ7QUFRRCxLQVREO0FBVUQsR0F6QzhDLEVBQS9DO0FBMENELENBcEVELEVBb0VHdGlCLFNBcEVIO0FBcUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsVUFBVUEsU0FBVixFQUFxQjtBQUNwQixNQUFJODhCLGdCQUFnQixLQUFwQjtBQUNBOThCLFlBQVVJLE1BQVYsQ0FBaUJxekIsbUJBQWpCLEdBQXVDLFVBQVVuUixPQUFWLEVBQW1CO0FBQ3hELFFBQUluUSxZQUFZbVEsUUFBUW5RLFNBQXhCO0FBQ0EsUUFBSUEsVUFBVTBTLE9BQVYsQ0FBa0JpWSxhQUFsQixNQUFxQyxDQUFDLENBQTFDLEVBQTZDO0FBQzNDLGFBQU8zcUIsU0FBUDtBQUNEOztBQUVELFFBQUk0cUIsb0JBQW9CemEsUUFBUXVELGdCQUFSLENBQXlCLHlCQUF6QixDQUF4QjtBQUFBLFFBQ0k0RixHQURKO0FBQUEsUUFFSXVSLFdBRko7QUFBQSxRQUdJNTZCLE1BSEo7QUFBQSxRQUlJRCxDQUpKO0FBS0EsU0FBS0EsSUFBSSxDQUFKLEVBQU9DLFNBQVMyNkIsa0JBQWtCMzZCLE1BQXZDLEVBQStDRCxJQUFJQyxNQUFuRCxFQUEyREQsR0FBM0QsRUFBZ0U7QUFDOURzcEIsWUFBTXNSLGtCQUFrQjU2QixDQUFsQixFQUFxQjg2QixJQUFyQixJQUE2QkYsa0JBQWtCNTZCLENBQWxCLEVBQXFCMHpCLEdBQXhEO0FBQ0FtSCxvQkFBY2g5QixVQUFVTSxJQUFWLENBQWVrcUIsTUFBZixDQUFzQmlCLEdBQXRCLEVBQTJCeFEsT0FBM0IsQ0FBbUMsR0FBbkMsRUFBd0M0UCxFQUF4QyxDQUEyQ2lTLGFBQTNDLENBQWQ7QUFDQTNxQixrQkFBWW5TLFVBQVVNLElBQVYsQ0FBZWtxQixNQUFmLENBQXNCclksU0FBdEIsRUFBaUM4SSxPQUFqQyxDQUF5QytoQixXQUF6QyxFQUFzRG5TLEVBQXRELENBQXlEWSxHQUF6RCxDQUFaO0FBQ0Q7QUFDRCxXQUFPdFosU0FBUDtBQUNELEdBakJEO0FBa0JELENBcEJELEVBb0JHblMsU0FwQkgsRSxDQW9CZTs7Ozs7Ozs7Ozs7QUFXZixDQUFDLFVBQVVBLFNBQVYsRUFBcUI7QUFDcEIsTUFBSUcsTUFBTUgsVUFBVUcsR0FBcEI7QUFBQSxNQUNJKzhCLCtDQUErQyxDQUFDLElBQUQsRUFBTyxHQUFQLEVBQVksSUFBWixFQUFrQixJQUFsQixFQUF3QixJQUF4QixFQUE4QixJQUE5QixFQUFvQyxJQUFwQyxFQUEwQyxJQUExQyxDQURuRDtBQUFBLE1BRUlDLFlBQVksQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLE1BQWIsQ0FGaEI7O0FBSUFuOUIsWUFBVUksTUFBVixDQUFpQmc5Qix1QkFBakIsR0FBMkMsVUFBVWYsUUFBVixFQUFvQjtBQUM3RCxhQUFTZ0IsTUFBVCxDQUFnQkMsWUFBaEIsRUFBOEI7QUFDNUIsVUFBSXYyQixnQkFBZ0I1RyxJQUFJd3ZCLGdCQUFKLENBQXFCMk4sWUFBckIsRUFBbUMsRUFBRTF5QixVQUFVLENBQUMsR0FBRCxFQUFNLEtBQU4sQ0FBWixFQUFuQyxFQUErRCxDQUEvRCxDQUFwQjtBQUNBLFVBQUksQ0FBQzdELGFBQUwsRUFBb0I7QUFDbEI7QUFDRDs7QUFFRCxVQUFJdzJCLGlCQUFpQnA1QixTQUFTb0MsY0FBVCxDQUF3QnZHLFVBQVVTLGVBQWxDLENBQXJCO0FBQ0FOLFVBQUl1dEIsTUFBSixDQUFXNlAsY0FBWCxFQUEyQjNMLE1BQTNCLENBQWtDN3FCLGFBQWxDO0FBQ0E1RyxVQUFJcTNCLHFCQUFKLENBQTBCendCLGFBQTFCO0FBQ0FzMUIsZUFBUzk3QixTQUFULENBQW1CMlQsVUFBbkIsQ0FBOEJxcEIsY0FBOUI7QUFDRDs7QUFFRCxhQUFTQyxPQUFULENBQWlCck8sS0FBakIsRUFBd0I7QUFDdEIsVUFBSXlOLFVBQVV6TixNQUFNeU4sT0FBcEI7QUFDQSxVQUFJek4sTUFBTXNPLFFBQU4sSUFBa0JiLFlBQVk1OEIsVUFBVWMsU0FBdEIsSUFBbUM4N0IsWUFBWTU4QixVQUFVYSxhQUEvRSxFQUE4RjtBQUM1RjtBQUNEOztBQUVELFVBQUl5aEIsVUFBVTZNLE1BQU1yaUIsTUFBcEI7QUFBQSxVQUNJd3dCLGVBQWVqQixTQUFTOTdCLFNBQVQsQ0FBbUJzOEIsZUFBbkIsRUFEbkI7QUFBQSxVQUVJYSxlQUFldjlCLElBQUl3dkIsZ0JBQUosQ0FBcUIyTixZQUFyQixFQUFtQyxFQUFFMXlCLFVBQVVzeUIsNENBQVosRUFBbkMsRUFBK0YsQ0FBL0YsQ0FGbkI7QUFHQSxVQUFJUSxZQUFKLEVBQWtCO0FBQ2hCO0FBQ0E7QUFDQSxZQUFJQSxhQUFhOXlCLFFBQWIsS0FBMEIsSUFBMUIsS0FBbUNneUIsWUFBWTU4QixVQUFVYyxTQUF0QixJQUFtQzg3QixZQUFZNThCLFVBQVVhLGFBQTVGLENBQUosRUFBZ0g7QUFDOUdnNUIscUJBQVcsWUFBWTtBQUNyQixnQkFBSXlELGVBQWVqQixTQUFTOTdCLFNBQVQsQ0FBbUJzOEIsZUFBbkIsRUFBbkI7QUFBQSxnQkFDSWhRLElBREo7QUFBQSxnQkFFSStPLEdBRko7QUFHQSxnQkFBSSxDQUFDMEIsWUFBTCxFQUFtQjtBQUNqQjtBQUNEOztBQUVEelEsbUJBQU8xc0IsSUFBSXd2QixnQkFBSixDQUFxQjJOLFlBQXJCLEVBQW1DO0FBQ3hDMXlCLHdCQUFVdXlCO0FBRDhCLGFBQW5DLEVBRUosQ0FGSSxDQUFQOztBQUlBLGdCQUFJdFEsSUFBSixFQUFVO0FBQ1I7QUFDRDs7QUFFRHdRLG1CQUFPQyxZQUFQO0FBQ0QsV0FqQkQsRUFpQkcsQ0FqQkg7QUFrQkQsU0FuQkQsTUFtQk8sSUFBSUksYUFBYTl5QixRQUFiLENBQXNCdWEsS0FBdEIsQ0FBNEIsUUFBNUIsS0FBeUN5WCxZQUFZNThCLFVBQVVjLFNBQW5FLEVBQThFO0FBQ25GKzRCLHFCQUFXLFlBQVk7QUFDckJ3RCxtQkFBT2hCLFNBQVM5N0IsU0FBVCxDQUFtQnM4QixlQUFuQixFQUFQO0FBQ0QsV0FGRCxFQUVHLENBRkg7QUFHRDtBQUNEO0FBQ0Q7O0FBRUQsVUFBSUQsWUFBWTU4QixVQUFVYyxTQUF0QixJQUFtQyxDQUFDZCxVQUFVd2tCLE9BQVYsQ0FBa0I4Qix5QkFBbEIsRUFBeEMsRUFBdUY7QUFDckYrVixpQkFBU244QixRQUFULENBQWtCeTlCLElBQWxCLENBQXVCLGlCQUF2QjtBQUNBeE8sY0FBTW1ELGNBQU47QUFDRDtBQUNGOztBQUVEO0FBQ0FueUIsUUFBSXNwQixPQUFKLENBQVk0UyxTQUFTL1osT0FBVCxDQUFpQnhaLGFBQTdCLEVBQTRDLFNBQTVDLEVBQXVEMDBCLE9BQXZEO0FBQ0QsR0E1REQ7QUE2REQsQ0FsRUQsRUFrRUd4OUIsU0FsRUgsRSxDQWtFZTs7Ozs7Ozs7QUFRZixDQUFDLFVBQVVBLFNBQVYsRUFBcUI7QUFDcEIsTUFBSTI2QixhQUFhLHlCQUFqQjs7QUFFQTM2QixZQUFVSSxNQUFWLENBQWlCdzlCLE1BQWpCLEdBQTBCLFVBQVV0YixPQUFWLEVBQW1CO0FBQzNDdGlCLGNBQVVHLEdBQVYsQ0FBY2lzQixRQUFkLENBQXVCOUosT0FBdkIsRUFBZ0NxWSxVQUFoQztBQUNBMzZCLGNBQVVHLEdBQVYsQ0FBY3FzQixXQUFkLENBQTBCbEssT0FBMUIsRUFBbUNxWSxVQUFuQzs7QUFFQTtBQUNBLFFBQUk7QUFDRixVQUFJM3hCLE1BQU1zWixRQUFReFosYUFBbEI7QUFDQUUsVUFBSXdjLFdBQUosQ0FBZ0IsUUFBaEIsRUFBMEIsS0FBMUIsRUFBaUMsSUFBakM7QUFDQXhjLFVBQUl3YyxXQUFKLENBQWdCLFFBQWhCLEVBQTBCLEtBQTFCLEVBQWlDLElBQWpDO0FBQ0QsS0FKRCxDQUlFLE9BQU96ZixDQUFQLEVBQVUsQ0FBRTtBQUNmLEdBVkQ7QUFXRCxDQWRELEVBY0cvRixTQWRILEUsQ0FjZTs7Ozs7O0FBTWYsQ0FBQyxVQUFVQSxTQUFWLEVBQXFCO0FBQ3BCLE1BQUlHLE1BQU1ILFVBQVVHLEdBQXBCOztBQUVBLFdBQVMwOUIsdUJBQVQsQ0FBaUN2YixPQUFqQyxFQUEwQztBQUN4QyxRQUFJd2IsTUFBTSxDQUFWO0FBQ0EsUUFBSXhiLFFBQVFyYixVQUFaLEVBQXdCO0FBQ3RCLFNBQUc7QUFDRDYyQixlQUFPeGIsUUFBUXliLFNBQVIsSUFBcUIsQ0FBNUI7QUFDQXpiLGtCQUFVQSxRQUFRMGIsWUFBbEI7QUFDRCxPQUhELFFBR1MxYixPQUhUO0FBSUQ7QUFDRCxXQUFPd2IsR0FBUDtBQUNEOztBQUVEOTlCLFlBQVU0aUIsU0FBVixHQUFzQkUsS0FBS2xmLE1BQUw7QUFDdEIsNkNBQTJDO0FBQ3pDOUQsaUJBQWEsU0FBU0EsV0FBVCxDQUFxQjA2QixNQUFyQixFQUE2QjtBQUN4QztBQUNBdDVCLGFBQU9nRixLQUFQLENBQWFuQyxJQUFiOztBQUVBLFdBQUt5MkIsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsV0FBSzZCLFFBQUwsR0FBZ0I3QixPQUFPNkIsUUFBdkI7QUFDQSxXQUFLcnpCLEdBQUwsR0FBVyxLQUFLcXpCLFFBQUwsQ0FBY3J6QixHQUF6QjtBQUNELEtBUndDOztBQVV6Qzs7Ozs7QUFLQWkxQixpQkFBYSxTQUFTQSxXQUFULEdBQXVCO0FBQ2xDLFVBQUl4N0IsUUFBUSxLQUFLeTdCLFFBQUwsRUFBWjtBQUNBLGFBQU96N0IsU0FBU0EsTUFBTXlOLFVBQU4sRUFBaEI7QUFDRCxLQWxCd0M7O0FBb0J6Qzs7Ozs7QUFLQWl1QixpQkFBYSxTQUFTQSxXQUFULENBQXFCQyxRQUFyQixFQUErQjtBQUMxQyxVQUFJLENBQUNBLFFBQUwsRUFBZTtBQUNiO0FBQ0Q7O0FBRUQsV0FBS0MsWUFBTCxDQUFrQkQsUUFBbEI7QUFDRCxLQS9Cd0M7O0FBaUN6Qzs7Ozs7OztBQU9BRSxlQUFXLFNBQVNBLFNBQVQsQ0FBbUIxM0IsSUFBbkIsRUFBeUI7QUFDbEMsVUFBSW5FLFFBQVF5RCxNQUFNOUIsV0FBTixDQUFrQixLQUFLNEUsR0FBdkIsQ0FBWjtBQUNBdkcsWUFBTThRLGNBQU4sQ0FBcUIzTSxJQUFyQjtBQUNBbkUsWUFBTTBULFlBQU4sQ0FBbUJ2UCxJQUFuQjtBQUNBLGFBQU8sS0FBS3kzQixZQUFMLENBQWtCNTdCLEtBQWxCLENBQVA7QUFDRCxLQTdDd0M7O0FBK0N6Qzs7Ozs7OztBQU9BODdCLGNBQVUsU0FBU0EsUUFBVCxDQUFrQjMzQixJQUFsQixFQUF3QjtBQUNoQyxVQUFJbkUsUUFBUXlELE1BQU05QixXQUFOLENBQWtCLEtBQUs0RSxHQUF2QixDQUFaO0FBQ0F2RyxZQUFNNFQsYUFBTixDQUFvQnpQLElBQXBCO0FBQ0FuRSxZQUFNcVYsV0FBTixDQUFrQmxSLElBQWxCO0FBQ0EsYUFBTyxLQUFLeTNCLFlBQUwsQ0FBa0I1N0IsS0FBbEIsQ0FBUDtBQUNELEtBM0R3Qzs7QUE2RHpDOzs7Ozs7O0FBT0F5UixnQkFBWSxTQUFTQSxVQUFULENBQW9CdE4sSUFBcEIsRUFBMEI7QUFDcEMsVUFBSW5FLFFBQVF5RCxNQUFNOUIsV0FBTixDQUFrQixLQUFLNEUsR0FBdkIsQ0FBWjtBQUFBLFVBQ0l3MUIsWUFBWTUzQixLQUFLTSxRQUFMLEtBQWtCbEgsVUFBVVcsWUFENUM7QUFBQSxVQUVJMFosY0FBYyxpQkFBaUJ6VCxJQUFqQixHQUF3QkEsS0FBS3lULFdBQTdCLEdBQTJDelQsS0FBS2dFLFFBQUwsS0FBa0IsS0FGL0U7QUFBQSxVQUdJa0osVUFBVTBxQixZQUFZNTNCLEtBQUt1TCxTQUFqQixHQUE2QnZMLEtBQUs2RCxJQUhoRDtBQUFBLFVBSUlzd0IsVUFBVWpuQixZQUFZLEVBQVosSUFBa0JBLFlBQVk5VCxVQUFVUyxlQUp0RDtBQUFBLFVBS0lnK0IsZUFBZXQrQixJQUFJcXRCLFFBQUosQ0FBYSxTQUFiLEVBQXdCQyxJQUF4QixDQUE2QjdtQixJQUE3QixDQUxuQjtBQUFBLFVBTUl5bUIsaUJBQWlCb1IsaUJBQWlCLE9BQWpCLElBQTRCQSxpQkFBaUIsV0FObEU7O0FBUUEsVUFBSTFELFdBQVd5RCxTQUFYLElBQXdCbmtCLFdBQTVCLEVBQXlDO0FBQ3ZDO0FBQ0EsWUFBSTtBQUNGelQsZUFBS3VMLFNBQUwsR0FBaUJuUyxVQUFVUyxlQUEzQjtBQUNELFNBRkQsQ0FFRSxPQUFPc0YsQ0FBUCxFQUFVLENBQUU7QUFDZjs7QUFFRCxVQUFJc1UsV0FBSixFQUFpQjtBQUNmNVgsY0FBTXNWLGtCQUFOLENBQXlCblIsSUFBekI7QUFDRCxPQUZELE1BRU87QUFDTG5FLGNBQU15UixVQUFOLENBQWlCdE4sSUFBakI7QUFDRDs7QUFFRCxVQUFJeVQsZUFBZTBnQixPQUFmLElBQTBCeUQsU0FBOUIsRUFBeUM7QUFDdkMvN0IsY0FBTTBOLFFBQU4sQ0FBZWtkLGNBQWY7QUFDRCxPQUZELE1BRU8sSUFBSWhULGVBQWUwZ0IsT0FBbkIsRUFBNEI7QUFDakN0NEIsY0FBTTRULGFBQU4sQ0FBb0J6UCxJQUFwQjtBQUNBbkUsY0FBTXFWLFdBQU4sQ0FBa0JsUixJQUFsQjtBQUNEOztBQUVELFdBQUt5M0IsWUFBTCxDQUFrQjU3QixLQUFsQjtBQUNELEtBbEd3Qzs7QUFvR3pDOzs7Ozs7OztBQVFBbzZCLHFCQUFpQixTQUFTQSxlQUFULENBQXlCeGMsWUFBekIsRUFBdUM7QUFDdEQsVUFBSTlmLFNBQUosRUFBZWtDLEtBQWY7O0FBRUEsVUFBSTRkLGdCQUFnQixLQUFLclgsR0FBTCxDQUFTekksU0FBekIsSUFBc0MsS0FBS3lJLEdBQUwsQ0FBU3pJLFNBQVQsQ0FBbUJrTSxJQUFuQixLQUE0QixTQUF0RSxFQUFpRjtBQUMvRWhLLGdCQUFRLEtBQUt1RyxHQUFMLENBQVN6SSxTQUFULENBQW1CNkQsV0FBbkIsRUFBUjtBQUNBLFlBQUkzQixTQUFTQSxNQUFNTCxNQUFuQixFQUEyQjtBQUN6QixpQkFBT0ssTUFBTTZkLElBQU4sQ0FBVyxDQUFYLENBQVA7QUFDRDtBQUNGOztBQUVEL2Ysa0JBQVksS0FBS3djLFlBQUwsQ0FBa0IsS0FBSy9ULEdBQXZCLENBQVo7QUFDQSxVQUFJekksVUFBVXllLFNBQVYsS0FBd0J6ZSxVQUFVd2UsVUFBdEMsRUFBa0Q7QUFDaEQsZUFBT3hlLFVBQVV5ZSxTQUFqQjtBQUNELE9BRkQsTUFFTztBQUNMdmMsZ0JBQVEsS0FBS3k3QixRQUFMLENBQWMsS0FBS2wxQixHQUFuQixDQUFSO0FBQ0EsZUFBT3ZHLFFBQVFBLE1BQU0rTSx1QkFBZCxHQUF3QyxLQUFLeEcsR0FBTCxDQUFTMUUsSUFBeEQ7QUFDRDtBQUNGLEtBN0h3Qzs7QUErSHpDbzZCLHVCQUFtQixTQUFTQSxpQkFBVCxDQUEyQjdhLE1BQTNCLEVBQW1DOGEscUJBQW5DLEVBQTBEO0FBQzNFLFVBQUlyNkIsT0FBTyxLQUFLMEUsR0FBTCxDQUFTMUUsSUFBcEI7QUFBQSxVQUNJczZCLGVBQWVELHlCQUF5QnI2QixLQUFLdTZCLFNBRGpEO0FBQUEsVUFFSUMsZ0JBQWdCSCx5QkFBeUJyNkIsS0FBS3k2QixVQUZsRDtBQUFBLFVBR0kxUyxZQUFZLDZCQUhoQjtBQUFBLFVBSUkyUyxrQkFBa0Isa0JBQWtCM1MsU0FBbEIsR0FBOEIsSUFBOUIsR0FBcUNyc0IsVUFBVVMsZUFBL0MsR0FBaUUsU0FKdkY7QUFBQSxVQUtJZ0MsUUFBUSxLQUFLeTdCLFFBQUwsQ0FBYyxLQUFLbDFCLEdBQW5CLENBTFo7QUFBQSxVQU1JaTJCLFFBTko7O0FBUUE7QUFDQSxVQUFJLENBQUN4OEIsS0FBTCxFQUFZO0FBQ1ZvaEIsZUFBT3ZmLElBQVAsRUFBYUEsSUFBYjtBQUNBO0FBQ0Q7O0FBRUQsVUFBSXNDLE9BQU9uRSxNQUFNMlAsd0JBQU4sQ0FBK0I0c0IsZUFBL0IsQ0FBWDtBQUNBdjhCLFlBQU02USxVQUFOLENBQWlCMU0sSUFBakI7O0FBRUE7QUFDQSxVQUFJO0FBQ0ZpZCxlQUFPcGhCLE1BQU00SixjQUFiLEVBQTZCNUosTUFBTTZKLFlBQW5DO0FBQ0QsT0FGRCxDQUVFLE9BQU80eUIsRUFBUCxFQUFXO0FBQ1hyRixtQkFBVyxZQUFZO0FBQ3JCLGdCQUFNcUYsRUFBTjtBQUNELFNBRkQsRUFFRyxDQUZIO0FBR0Q7O0FBRURDLHlCQUFtQixLQUFLbjJCLEdBQUwsQ0FBUzRjLGFBQVQsQ0FBdUIsTUFBTXlHLFNBQTdCLENBQW5CO0FBQ0EsVUFBSThTLGdCQUFKLEVBQXNCO0FBQ3BCRixtQkFBVy80QixNQUFNOUIsV0FBTixDQUFrQixLQUFLNEUsR0FBdkIsQ0FBWDtBQUNBaTJCLGlCQUFTL3FCLFVBQVQsQ0FBb0JpckIsZ0JBQXBCO0FBQ0FGLGlCQUFTam5CLGNBQVQ7QUFDQSxhQUFLcW1CLFlBQUwsQ0FBa0JZLFFBQWxCO0FBQ0QsT0FMRCxNQUtPO0FBQ0w7QUFDQTM2QixhQUFLcWUsS0FBTDtBQUNEOztBQUVELFVBQUlnYyxxQkFBSixFQUEyQjtBQUN6QnI2QixhQUFLdTZCLFNBQUwsR0FBaUJELFlBQWpCO0FBQ0F0NkIsYUFBS3k2QixVQUFMLEdBQWtCRCxhQUFsQjtBQUNEOztBQUVEO0FBQ0EsVUFBSTtBQUNGSyx5QkFBaUJsNEIsVUFBakIsQ0FBNEIrSSxXQUE1QixDQUF3Q212QixnQkFBeEM7QUFDRCxPQUZELENBRUUsT0FBT0MsRUFBUCxFQUFXLENBQUU7QUFDaEIsS0E5S3dDOztBQWdMekM7Ozs7QUFJQUMsNkJBQXlCLFNBQVNBLHVCQUFULENBQWlDeGIsTUFBakMsRUFBeUM7QUFDaEUsVUFBSXBoQixRQUFRLEtBQUt5N0IsUUFBTCxFQUFaO0FBQUEsVUFDSTU1QixPQUFPLEtBQUswRSxHQUFMLENBQVMxRSxJQURwQjtBQUFBLFVBRUkyNkIsUUFGSjtBQUFBLFVBR0lLLFNBSEo7QUFBQSxVQUlJQyxRQUpKO0FBQUEsVUFLSTNwQixTQUxKO0FBQUEsVUFNSTRwQixXQU5KOztBQVFBO0FBQ0EsVUFBSSxDQUFDLzhCLEtBQUwsRUFBWTtBQUNWb2hCLGVBQU92ZixJQUFQLEVBQWFBLElBQWI7QUFDQTtBQUNEOztBQUVEc1Isa0JBQVluVCxNQUFNb1QsUUFBTixDQUFlLENBQUMsQ0FBRCxDQUFmLENBQVo7QUFDQXlwQixrQkFBWTFwQixVQUFVLENBQVYsS0FBZ0JuVCxNQUFNNEosY0FBbEM7QUFDQWt6QixpQkFBVzNwQixVQUFVQSxVQUFVeFQsTUFBVixHQUFtQixDQUE3QixLQUFtQ0ssTUFBTTZKLFlBQXBEOztBQUVBa3pCLG9CQUFjO0FBQ1pyd0IsbUJBQVcxTSxNQUFNME0sU0FETDtBQUVaOUMsd0JBQWdCaXpCLFNBRko7QUFHWnR3QixxQkFBYXN3QixjQUFjNzhCLE1BQU00SixjQUFwQixHQUFxQzVKLE1BQU11TSxXQUEzQyxHQUF5RCxDQUgxRDtBQUlaMUMsc0JBQWNpekIsUUFKRjtBQUtadHdCLG1CQUFXc3dCLGFBQWE5OEIsTUFBTTZKLFlBQW5CLEdBQWtDN0osTUFBTXdNLFNBQXhDLEdBQW9Ec3dCLFNBQVNuOUI7QUFMNUQsT0FBZDs7QUFRQSxVQUFJO0FBQ0Z5aEIsZUFBT3BoQixNQUFNNEosY0FBYixFQUE2QjVKLE1BQU02SixZQUFuQztBQUNELE9BRkQsQ0FFRSxPQUFPdkcsQ0FBUCxFQUFVO0FBQ1Y4ekIsbUJBQVcsWUFBWTtBQUNyQixnQkFBTTl6QixDQUFOO0FBQ0QsU0FGRCxFQUVHLENBRkg7QUFHRDs7QUFFRGs1QixpQkFBVy80QixNQUFNOUIsV0FBTixDQUFrQixLQUFLNEUsR0FBdkIsQ0FBWDtBQUNBLFVBQUk7QUFDRmkyQixpQkFBUy9wQixRQUFULENBQWtCc3FCLFlBQVluekIsY0FBOUIsRUFBOENtekIsWUFBWXh3QixXQUExRDtBQUNELE9BRkQsQ0FFRSxPQUFPc1ksRUFBUCxFQUFXLENBQUU7QUFDZixVQUFJO0FBQ0YyWCxpQkFBUzlwQixNQUFULENBQWdCcXFCLFlBQVlsekIsWUFBNUIsRUFBMENrekIsWUFBWXZ3QixTQUF0RDtBQUNELE9BRkQsQ0FFRSxPQUFPdVksRUFBUCxFQUFXLENBQUU7QUFDZixVQUFJO0FBQ0YsYUFBSzZXLFlBQUwsQ0FBa0JZLFFBQWxCO0FBQ0QsT0FGRCxDQUVFLE9BQU9DLEVBQVAsRUFBVyxDQUFFO0FBQ2hCLEtBak93Qzs7QUFtT3pDOzs7Ozs7O0FBT0FPLGdCQUFZLFNBQVNBLFVBQVQsQ0FBb0JqZCxJQUFwQixFQUEwQjtBQUNwQyxVQUFJL2YsUUFBUXlELE1BQU05QixXQUFOLENBQWtCLEtBQUs0RSxHQUF2QixDQUFaO0FBQUEsVUFDSXBDLE9BQU9uRSxNQUFNMlAsd0JBQU4sQ0FBK0JvUSxJQUEvQixDQURYO0FBQUEsVUFFSXZPLFlBQVlyTixLQUFLcU4sU0FGckI7QUFHQSxXQUFLWCxVQUFMLENBQWdCMU0sSUFBaEI7QUFDQSxVQUFJcU4sU0FBSixFQUFlO0FBQ2IsYUFBS3NxQixRQUFMLENBQWN0cUIsU0FBZDtBQUNEO0FBQ0YsS0FsUHdDOztBQW9QekM7Ozs7Ozs7QUFPQVgsZ0JBQVksU0FBU0EsVUFBVCxDQUFvQjFNLElBQXBCLEVBQTBCO0FBQ3BDLFVBQUluRSxRQUFRLEtBQUt5N0IsUUFBTCxFQUFaO0FBQ0EsVUFBSXo3QixLQUFKLEVBQVc7QUFDVEEsY0FBTTZRLFVBQU4sQ0FBaUIxTSxJQUFqQjtBQUNEO0FBQ0YsS0FoUXdDOztBQWtRekM7Ozs7O0FBS0E4NEIsY0FBVSxTQUFTQSxRQUFULENBQWtCOTRCLElBQWxCLEVBQXdCO0FBQ2hDLFVBQUluRSxRQUFRLEtBQUt5N0IsUUFBTCxFQUFaO0FBQ0EsVUFBSSxDQUFDejdCLEtBQUwsRUFBWTtBQUNWO0FBQ0Q7O0FBRUQsVUFBSTtBQUNGO0FBQ0FBLGNBQU1vUixnQkFBTixDQUF1QmpOLElBQXZCO0FBQ0EsYUFBS3NOLFVBQUwsQ0FBZ0J0TixJQUFoQjtBQUNELE9BSkQsQ0FJRSxPQUFPYixDQUFQLEVBQVU7QUFDVjtBQUNBYSxhQUFLMkIsV0FBTCxDQUFpQjlGLE1BQU1zUixlQUFOLEVBQWpCO0FBQ0F0UixjQUFNNlEsVUFBTixDQUFpQjFNLElBQWpCO0FBQ0Q7QUFDRixLQXRSd0M7O0FBd1J6Qzs7Ozs7OztBQU9BKzRCLG9CQUFnQixTQUFTQSxjQUFULEdBQTBCO0FBQ3hDLFVBQUkzMkIsTUFBTSxLQUFLQSxHQUFmO0FBQUEsVUFDSTQyQixnQkFBZ0I1MkIsSUFBSXNKLGVBQUosQ0FBb0J1dEIsWUFBcEIsR0FBbUM3MkIsSUFBSXNKLGVBQUosQ0FBb0J5YyxZQUQzRTtBQUFBLFVBRUkvQyxjQUFjaGpCLElBQUk4MkIsK0JBQUosR0FBc0M5MkIsSUFBSTgyQiwrQkFBSixJQUF1QyxZQUFZO0FBQ3pHLFlBQUl4ZCxVQUFVdFosSUFBSTNDLGFBQUosQ0FBa0IsTUFBbEIsQ0FBZDtBQUNBO0FBQ0FpYyxnQkFBUW5RLFNBQVIsR0FBb0JuUyxVQUFVUyxlQUE5QjtBQUNBLGVBQU82aEIsT0FBUDtBQUNELE9BTDhGLEVBRi9GO0FBQUEsVUFRSXliLFNBUko7O0FBVUEsVUFBSTZCLGFBQUosRUFBbUI7QUFDakIsYUFBS3RzQixVQUFMLENBQWdCMFksV0FBaEI7QUFDQStSLG9CQUFZRix3QkFBd0I3UixXQUF4QixDQUFaO0FBQ0FBLG9CQUFZL2tCLFVBQVosQ0FBdUIrSSxXQUF2QixDQUFtQ2djLFdBQW5DO0FBQ0EsWUFBSStSLFlBQVkvMEIsSUFBSTFFLElBQUosQ0FBU3U2QixTQUF6QixFQUFvQztBQUNsQzcxQixjQUFJMUUsSUFBSixDQUFTdTZCLFNBQVQsR0FBcUJkLFNBQXJCO0FBQ0Q7QUFDRjtBQUNGLEtBbFR3Qzs7QUFvVHpDOzs7QUFHQWdDLGdCQUFZLFNBQVNBLFVBQVQsR0FBc0I7QUFDaEMsVUFBSS8vQixVQUFVd2tCLE9BQVYsQ0FBa0I4RCx1QkFBbEIsRUFBSixFQUFpRDtBQUMvQyxhQUFLMFgsZUFBTDtBQUNELE9BRkQsTUFFTyxJQUFJLEtBQUtoM0IsR0FBTCxDQUFTekksU0FBYixFQUF3QjtBQUM3QixhQUFLMC9CLGdCQUFMO0FBQ0Q7QUFDRixLQTdUd0M7O0FBK1R6Qzs7O0FBR0FELHFCQUFpQixTQUFTQSxlQUFULEdBQTJCO0FBQzFDLFVBQUk3NkIsTUFBTSxLQUFLNkQsR0FBTCxDQUFTQyxXQUFuQjtBQUFBLFVBQ0kxSSxZQUFZNEUsSUFBSTRYLFlBQUosRUFEaEI7QUFFQXhjLGdCQUFVMi9CLE1BQVYsQ0FBaUIsUUFBakIsRUFBMkIsTUFBM0IsRUFBbUMsY0FBbkM7QUFDQTMvQixnQkFBVTIvQixNQUFWLENBQWlCLFFBQWpCLEVBQTJCLE9BQTNCLEVBQW9DLGNBQXBDO0FBQ0QsS0F2VXdDOztBQXlVekNELHNCQUFrQixTQUFTQSxnQkFBVCxHQUE0QjtBQUM1QyxVQUFJeDlCLFFBQVEsS0FBS3VHLEdBQUwsQ0FBU3pJLFNBQVQsQ0FBbUI2RCxXQUFuQixFQUFaO0FBQUEsVUFDSSs3QixXQUFXMTlCLE1BQU0yOUIsV0FEckI7QUFBQSxVQUVJQyxjQUFjNTlCLE1BQU02OUIsY0FGeEI7QUFBQSxVQUdJQyxjQUFjLEtBQUt2M0IsR0FBTCxDQUFTMUUsSUFBVCxDQUFjaThCLFdBSGhDO0FBQUEsVUFJSUMsV0FKSjtBQUFBLFVBS0lDLFFBTEo7QUFBQSxVQU1JQyxXQU5KO0FBQUEsVUFPSXYrQixDQVBKO0FBQUEsVUFRSXM1QixDQVJKOztBQVVBLFVBQUksQ0FBQ2g1QixNQUFNaytCLFdBQVgsRUFBd0I7QUFDdEI7QUFDRDs7QUFFRCxVQUFJUixhQUFhLENBQWpCLEVBQW9CO0FBQ2xCO0FBQ0E7QUFDQU8sc0JBQWMsS0FBSzEzQixHQUFMLENBQVMzQyxhQUFULENBQXVCLE1BQXZCLENBQWQ7QUFDQSxhQUFLaU4sVUFBTCxDQUFnQm90QixXQUFoQjtBQUNBUCxtQkFBV08sWUFBWTNDLFNBQXZCO0FBQ0EyQyxvQkFBWXo1QixVQUFaLENBQXVCK0ksV0FBdkIsQ0FBbUMwd0IsV0FBbkM7QUFDRDs7QUFFRFAsa0JBQVksQ0FBWjs7QUFFQSxXQUFLaCtCLElBQUksQ0FBQyxFQUFWLEVBQWNBLElBQUlvK0IsV0FBbEIsRUFBK0JwK0IsS0FBSyxDQUFwQyxFQUF1QztBQUNyQyxZQUFJO0FBQ0ZNLGdCQUFNaytCLFdBQU4sQ0FBa0J4K0IsQ0FBbEIsRUFBcUJnK0IsUUFBckI7QUFDQTtBQUNELFNBSEQsQ0FHRSxPQUFPN1ksRUFBUCxFQUFXLENBQUU7QUFDaEI7O0FBRUQ7QUFDQTtBQUNBa1osb0JBQWNMLFFBQWQ7QUFDQU0saUJBQVcsS0FBS3ozQixHQUFMLENBQVN6SSxTQUFULENBQW1CNkQsV0FBbkIsRUFBWDtBQUNBLFdBQUtxM0IsSUFBSThFLFdBQVQsRUFBc0I5RSxLQUFLLENBQTNCLEVBQThCQSxHQUE5QixFQUFtQztBQUNqQyxZQUFJO0FBQ0ZnRixtQkFBU0UsV0FBVCxDQUFxQmxGLENBQXJCLEVBQXdCK0UsV0FBeEI7QUFDQTtBQUNELFNBSEQsQ0FHRSxPQUFPaFosRUFBUCxFQUFXLENBQUU7QUFDaEI7O0FBRUQva0IsWUFBTW9ZLFdBQU4sQ0FBa0IsVUFBbEIsRUFBOEI0bEIsUUFBOUI7QUFDQWgrQixZQUFNa2UsTUFBTjtBQUNELEtBdlh3Qzs7QUF5WHpDaWdCLGFBQVMsU0FBU0EsT0FBVCxHQUFtQjtBQUMxQixVQUFJcmdDLFlBQVksS0FBS3djLFlBQUwsRUFBaEI7QUFDQSxhQUFPeGMsWUFBWUEsVUFBVTRMLFFBQVYsRUFBWixHQUFtQyxFQUExQztBQUNELEtBNVh3Qzs7QUE4WHpDMEosY0FBVSxTQUFTQSxRQUFULENBQWtCM08sUUFBbEIsRUFBNEJtSCxNQUE1QixFQUFvQztBQUM1QyxVQUFJNUwsUUFBUSxLQUFLeTdCLFFBQUwsRUFBWjtBQUNBLFVBQUl6N0IsS0FBSixFQUFXO0FBQ1QsZUFBT0EsTUFBTW9ULFFBQU4sQ0FBZSxDQUFDM08sUUFBRCxDQUFmLEVBQTJCbUgsTUFBM0IsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU8sRUFBUDtBQUNEO0FBQ0YsS0FyWXdDOztBQXVZekM2dkIsY0FBVSxTQUFTQSxRQUFULEdBQW9CO0FBQzVCLFVBQUkzOUIsWUFBWSxLQUFLd2MsWUFBTCxFQUFoQjtBQUNBLGFBQU94YyxhQUFhQSxVQUFVd2QsVUFBdkIsSUFBcUN4ZCxVQUFVNGUsVUFBVixDQUFxQixDQUFyQixDQUE1QztBQUNELEtBMVl3Qzs7QUE0WXpDcEMsa0JBQWMsU0FBU0EsWUFBVCxHQUF3QjtBQUNwQyxhQUFPN1csTUFBTTZXLFlBQU4sQ0FBbUIsS0FBSy9ULEdBQUwsQ0FBU0MsV0FBVCxJQUF3QixLQUFLRCxHQUFMLENBQVNFLFlBQXBELENBQVA7QUFDRCxLQTlZd0M7O0FBZ1p6Q20xQixrQkFBYyxTQUFTQSxZQUFULENBQXNCNTdCLEtBQXRCLEVBQTZCO0FBQ3pDLFVBQUkwQyxNQUFNLEtBQUs2RCxHQUFMLENBQVNDLFdBQVQsSUFBd0IsS0FBS0QsR0FBTCxDQUFTRSxZQUEzQztBQUFBLFVBQ0kzSSxZQUFZMkYsTUFBTTZXLFlBQU4sQ0FBbUI1WCxHQUFuQixDQURoQjtBQUVBLGFBQU81RSxVQUFVZ2lCLGNBQVYsQ0FBeUI5ZixLQUF6QixDQUFQO0FBQ0Q7QUFwWndDLEdBRHJCLENBQXRCO0FBdVpELENBcmFELEVBcWFHekMsU0FyYUg7QUFzYUE7Ozs7Ozs7O0FBUUEsQ0FBQyxVQUFVQSxTQUFWLEVBQXFCa0csS0FBckIsRUFBNEI7QUFDM0IsTUFBSTI2QixpQkFBaUIsTUFBckI7O0FBRUEsTUFBSUMsc0JBQXNCLE1BQTFCOztBQUVBLFdBQVN2VSxRQUFULENBQWtCbm1CLEVBQWxCLEVBQXNCMjZCLFFBQXRCLEVBQWdDQyxNQUFoQyxFQUF3QztBQUN0QyxRQUFJLENBQUM1NkIsR0FBR2ltQixTQUFSLEVBQW1CO0FBQ2pCLGFBQU8sS0FBUDtBQUNEOztBQUVELFFBQUk0VSxxQkFBcUI3NkIsR0FBR2ltQixTQUFILENBQWFsSCxLQUFiLENBQW1CNmIsTUFBbkIsS0FBOEIsRUFBdkQ7QUFDQSxXQUFPQyxtQkFBbUJBLG1CQUFtQjcrQixNQUFuQixHQUE0QixDQUEvQyxNQUFzRDIrQixRQUE3RDtBQUNEOztBQUVELFdBQVMzVSxRQUFULENBQWtCaG1CLEVBQWxCLEVBQXNCMjZCLFFBQXRCLEVBQWdDQyxNQUFoQyxFQUF3QztBQUN0QyxRQUFJNTZCLEdBQUdpbUIsU0FBUCxFQUFrQjtBQUNoQkcsa0JBQVlwbUIsRUFBWixFQUFnQjQ2QixNQUFoQjtBQUNBNTZCLFNBQUdpbUIsU0FBSCxJQUFnQixNQUFNMFUsUUFBdEI7QUFDRCxLQUhELE1BR087QUFDTDM2QixTQUFHaW1CLFNBQUgsR0FBZTBVLFFBQWY7QUFDRDtBQUNGOztBQUVELFdBQVN2VSxXQUFULENBQXFCcG1CLEVBQXJCLEVBQXlCNDZCLE1BQXpCLEVBQWlDO0FBQy9CLFFBQUk1NkIsR0FBR2ltQixTQUFQLEVBQWtCO0FBQ2hCam1CLFNBQUdpbUIsU0FBSCxHQUFlam1CLEdBQUdpbUIsU0FBSCxDQUFhcFIsT0FBYixDQUFxQitsQixNQUFyQixFQUE2QixFQUE3QixDQUFmO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTRSxjQUFULENBQXdCQyxHQUF4QixFQUE2QkMsR0FBN0IsRUFBa0M7QUFDaEMsV0FBT0QsSUFBSTlVLFNBQUosQ0FBY3BSLE9BQWQsQ0FBc0I2bEIsbUJBQXRCLEVBQTJDLEdBQTNDLEtBQW1ETSxJQUFJL1UsU0FBSixDQUFjcFIsT0FBZCxDQUFzQjZsQixtQkFBdEIsRUFBMkMsR0FBM0MsQ0FBMUQ7QUFDRDs7QUFFRCxXQUFTTyxzQkFBVCxDQUFnQ2o3QixFQUFoQyxFQUFvQztBQUNsQyxRQUFJWSxTQUFTWixHQUFHYSxVQUFoQjtBQUNBLFdBQU9iLEdBQUcrRCxVQUFWLEVBQXNCO0FBQ3BCbkQsYUFBT3NCLFlBQVAsQ0FBb0JsQyxHQUFHK0QsVUFBdkIsRUFBbUMvRCxFQUFuQztBQUNEO0FBQ0RZLFdBQU9nSixXQUFQLENBQW1CNUosRUFBbkI7QUFDRDs7QUFFRCxXQUFTazdCLGtDQUFULENBQTRDSCxHQUE1QyxFQUFpREMsR0FBakQsRUFBc0Q7QUFDcEQsUUFBSUQsSUFBSXBOLFVBQUosQ0FBZTN4QixNQUFmLElBQXlCZy9CLElBQUlyTixVQUFKLENBQWUzeEIsTUFBNUMsRUFBb0Q7QUFDbEQsYUFBTyxLQUFQO0FBQ0Q7QUFDRCxTQUFLLElBQUlELElBQUksQ0FBUixFQUFXd0MsTUFBTXc4QixJQUFJcE4sVUFBSixDQUFlM3hCLE1BQWhDLEVBQXdDbS9CLEtBQXhDLEVBQStDQyxLQUEvQyxFQUFzRG44QixJQUEzRCxFQUFpRWxELElBQUl3QyxHQUFyRSxFQUEwRSxFQUFFeEMsQ0FBNUUsRUFBK0U7QUFDN0VvL0IsY0FBUUosSUFBSXBOLFVBQUosQ0FBZTV4QixDQUFmLENBQVI7QUFDQWtELGFBQU9rOEIsTUFBTWw4QixJQUFiO0FBQ0EsVUFBSUEsUUFBUSxPQUFaLEVBQXFCO0FBQ25CbThCLGdCQUFRSixJQUFJck4sVUFBSixDQUFlME4sWUFBZixDQUE0QnA4QixJQUE1QixDQUFSO0FBQ0EsWUFBSWs4QixNQUFNRyxTQUFOLElBQW1CRixNQUFNRSxTQUE3QixFQUF3QztBQUN0QyxpQkFBTyxLQUFQO0FBQ0Q7QUFDRCxZQUFJSCxNQUFNRyxTQUFOLElBQW1CSCxNQUFNbEcsU0FBTixLQUFvQm1HLE1BQU1uRyxTQUFqRCxFQUE0RDtBQUMxRCxpQkFBTyxLQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsV0FBU3NHLFlBQVQsQ0FBc0IvNkIsSUFBdEIsRUFBNEJ3RSxNQUE1QixFQUFvQztBQUNsQyxRQUFJbEYsTUFBTS9GLEdBQU4sQ0FBVW9ILG1CQUFWLENBQThCWCxJQUE5QixDQUFKLEVBQXlDO0FBQ3ZDLFVBQUl3RSxVQUFVLENBQWQsRUFBaUI7QUFDZixlQUFPLENBQUMsQ0FBQ3hFLEtBQUtRLGVBQWQ7QUFDRCxPQUZELE1BRU8sSUFBSWdFLFVBQVV4RSxLQUFLeEUsTUFBbkIsRUFBMkI7QUFDaEMsZUFBTyxDQUFDLENBQUN3RSxLQUFLeUIsV0FBZDtBQUNELE9BRk0sTUFFQTtBQUNMLGVBQU8sSUFBUDtBQUNEO0FBQ0Y7O0FBRUQsV0FBTytDLFNBQVMsQ0FBVCxJQUFjQSxTQUFTeEUsS0FBS1UsVUFBTCxDQUFnQmxGLE1BQTlDO0FBQ0Q7O0FBRUQsV0FBU3cvQixXQUFULENBQXFCaDdCLElBQXJCLEVBQTJCaTdCLGNBQTNCLEVBQTJDQyxnQkFBM0MsRUFBNkQ7QUFDM0QsUUFBSXA1QixPQUFKO0FBQ0EsUUFBSXhDLE1BQU0vRixHQUFOLENBQVVvSCxtQkFBVixDQUE4QnM2QixjQUE5QixDQUFKLEVBQW1EO0FBQ2pELFVBQUlDLG9CQUFvQixDQUF4QixFQUEyQjtBQUN6QkEsMkJBQW1CNTdCLE1BQU0vRixHQUFOLENBQVVnSCxZQUFWLENBQXVCMDZCLGNBQXZCLENBQW5CO0FBQ0FBLHlCQUFpQkEsZUFBZTU2QixVQUFoQztBQUNELE9BSEQsTUFHTyxJQUFJNjZCLG9CQUFvQkQsZUFBZXovQixNQUF2QyxFQUErQztBQUNwRDAvQiwyQkFBbUI1N0IsTUFBTS9GLEdBQU4sQ0FBVWdILFlBQVYsQ0FBdUIwNkIsY0FBdkIsSUFBeUMsQ0FBNUQ7QUFDQUEseUJBQWlCQSxlQUFlNTZCLFVBQWhDO0FBQ0QsT0FITSxNQUdBO0FBQ0x5QixrQkFBVXhDLE1BQU0vRixHQUFOLENBQVVxSSxhQUFWLENBQXdCcTVCLGNBQXhCLEVBQXdDQyxnQkFBeEMsQ0FBVjtBQUNEO0FBQ0Y7QUFDRCxRQUFJLENBQUNwNUIsT0FBTCxFQUFjO0FBQ1pBLGdCQUFVbTVCLGVBQWVsNUIsU0FBZixDQUF5QixLQUF6QixDQUFWO0FBQ0EsVUFBSUQsUUFBUWlDLEVBQVosRUFBZ0I7QUFDZGpDLGdCQUFRcTVCLGVBQVIsQ0FBd0IsSUFBeEI7QUFDRDtBQUNELFVBQUl4M0IsS0FBSjtBQUNBLGFBQU9BLFFBQVFzM0IsZUFBZXY2QixVQUFmLENBQTBCdzZCLGdCQUExQixDQUFmLEVBQTREO0FBQzFEcDVCLGdCQUFRSCxXQUFSLENBQW9CZ0MsS0FBcEI7QUFDRDtBQUNEckUsWUFBTS9GLEdBQU4sQ0FBVStILFdBQVYsQ0FBc0JRLE9BQXRCLEVBQStCbTVCLGNBQS9CO0FBQ0Q7QUFDRCxXQUFPQSxrQkFBa0JqN0IsSUFBbEIsR0FBeUI4QixPQUF6QixHQUFtQ2s1QixZQUFZaDdCLElBQVosRUFBa0I4QixRQUFRekIsVUFBMUIsRUFBc0NmLE1BQU0vRixHQUFOLENBQVVnSCxZQUFWLENBQXVCdUIsT0FBdkIsQ0FBdEMsQ0FBMUM7QUFDRDs7QUFFRCxXQUFTczVCLEtBQVQsQ0FBZTFDLFNBQWYsRUFBMEI7QUFDeEIsU0FBSzJDLGNBQUwsR0FBc0IzQyxVQUFVcDRCLFFBQVYsSUFBc0JsSCxVQUFVVyxZQUF0RDtBQUNBLFNBQUt1aEMsYUFBTCxHQUFxQixLQUFLRCxjQUFMLEdBQXNCM0MsVUFBVXJyQixTQUFoQyxHQUE0Q3FyQixTQUFqRTtBQUNBLFNBQUsxcEIsU0FBTCxHQUFpQixDQUFDLEtBQUtzc0IsYUFBTixDQUFqQjtBQUNEOztBQUVERixRQUFNamlDLFNBQU4sR0FBa0I7QUFDaEJvaUMsYUFBUyxTQUFTQSxPQUFULEdBQW1CO0FBQzFCLFVBQUkvdEIsV0FBVyxFQUFmO0FBQUEsVUFDSTlOLFFBREo7QUFBQSxVQUVJVSxNQUZKO0FBQUEsVUFHSWdVLElBSEo7QUFJQSxXQUFLLElBQUk3WSxJQUFJLENBQVIsRUFBV3dDLE1BQU0sS0FBS2lSLFNBQUwsQ0FBZXhULE1BQXJDLEVBQTZDRCxJQUFJd0MsR0FBakQsRUFBc0QsRUFBRXhDLENBQXhELEVBQTJEO0FBQ3pEbUUsbUJBQVcsS0FBS3NQLFNBQUwsQ0FBZXpULENBQWYsQ0FBWDtBQUNBNkUsaUJBQVNWLFNBQVNXLFVBQWxCO0FBQ0FtTixpQkFBU2pTLENBQVQsSUFBY21FLFNBQVNtRSxJQUF2QjtBQUNBLFlBQUl0SSxDQUFKLEVBQU87QUFDTDZFLGlCQUFPZ0osV0FBUCxDQUFtQjFKLFFBQW5CO0FBQ0EsY0FBSSxDQUFDVSxPQUFPZ04sYUFBUCxFQUFMLEVBQTZCO0FBQzNCaE4sbUJBQU9DLFVBQVAsQ0FBa0IrSSxXQUFsQixDQUE4QmhKLE1BQTlCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsV0FBS2s3QixhQUFMLENBQW1CejNCLElBQW5CLEdBQTBCdVEsT0FBTzVHLFNBQVMxRixJQUFULENBQWMsRUFBZCxDQUFqQztBQUNBLGFBQU9zTSxJQUFQO0FBQ0QsS0FuQmU7O0FBcUJoQm9uQixlQUFXLFNBQVNBLFNBQVQsR0FBcUI7QUFDOUIsVUFBSWpnQyxJQUFJLEtBQUt5VCxTQUFMLENBQWV4VCxNQUF2QjtBQUFBLFVBQ0l1QyxNQUFNLENBRFY7QUFFQSxhQUFPeEMsR0FBUCxFQUFZO0FBQ1Z3QyxlQUFPLEtBQUtpUixTQUFMLENBQWV6VCxDQUFmLEVBQWtCQyxNQUF6QjtBQUNEO0FBQ0QsYUFBT3VDLEdBQVA7QUFDRCxLQTVCZTs7QUE4QmhCd0gsY0FBVSxTQUFTQSxRQUFULEdBQW9CO0FBQzVCLFVBQUlpSSxXQUFXLEVBQWY7QUFDQSxXQUFLLElBQUlqUyxJQUFJLENBQVIsRUFBV3dDLE1BQU0sS0FBS2lSLFNBQUwsQ0FBZXhULE1BQXJDLEVBQTZDRCxJQUFJd0MsR0FBakQsRUFBc0QsRUFBRXhDLENBQXhELEVBQTJEO0FBQ3pEaVMsaUJBQVNqUyxDQUFULElBQWMsTUFBTSxLQUFLeVQsU0FBTCxDQUFlelQsQ0FBZixFQUFrQnNJLElBQXhCLEdBQStCLEdBQTdDO0FBQ0Q7QUFDRCxhQUFPLFlBQVkySixTQUFTMUYsSUFBVCxDQUFjLEdBQWQsQ0FBWixHQUFpQyxJQUF4QztBQUNEO0FBcENlLEdBQWxCOztBQXVDQSxXQUFTMnpCLFdBQVQsQ0FBcUJDLFFBQXJCLEVBQStCdkIsUUFBL0IsRUFBeUN3QixrQkFBekMsRUFBNkRDLFNBQTdELEVBQXdFO0FBQ3RFLFNBQUtGLFFBQUwsR0FBZ0JBLFlBQVksQ0FBQ3pCLGNBQUQsQ0FBNUI7QUFDQSxTQUFLRSxRQUFMLEdBQWdCQSxZQUFZLEVBQTVCO0FBQ0EsU0FBS3dCLGtCQUFMLEdBQTBCQSxrQkFBMUI7QUFDQSxTQUFLQyxTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLFNBQUtDLGlCQUFMLEdBQXlCLEtBQXpCO0FBQ0Q7O0FBRURKLGNBQVl0aUMsU0FBWixHQUF3QjtBQUN0QjJpQywwQkFBc0IsU0FBU0Esb0JBQVQsQ0FBOEI5N0IsSUFBOUIsRUFBb0M7QUFDeEQsVUFBSSs3QixhQUFKO0FBQ0EsYUFBTy83QixJQUFQLEVBQWE7QUFDWCs3Qix3QkFBZ0IsS0FBSzVCLFFBQUwsR0FBZ0J4VSxTQUFTM2xCLElBQVQsRUFBZSxLQUFLbTZCLFFBQXBCLEVBQThCLEtBQUt3QixrQkFBbkMsQ0FBaEIsR0FBeUUsSUFBekY7QUFDQSxZQUFJMzdCLEtBQUtNLFFBQUwsSUFBaUJsSCxVQUFVVyxZQUEzQixJQUEyQ3VGLE1BQU0vRixHQUFOLENBQVVxRyxhQUFWLENBQXdCLEtBQUs4N0IsUUFBN0IsRUFBdUMxN0IsS0FBSzRxQixPQUFMLENBQWFuTSxXQUFiLEVBQXZDLENBQTNDLElBQWlIc2QsYUFBckgsRUFBb0k7QUFDbEksaUJBQU8vN0IsSUFBUDtBQUNEO0FBQ0RBLGVBQU9BLEtBQUtLLFVBQVo7QUFDRDtBQUNELGFBQU8sS0FBUDtBQUNELEtBWHFCOztBQWF0QjtBQUNBMjdCLGVBQVcsU0FBU0EsU0FBVCxDQUFtQmh0QixTQUFuQixFQUE4Qm5ULEtBQTlCLEVBQXFDO0FBQzlDLFVBQUk2OEIsWUFBWTFwQixVQUFVLENBQVYsQ0FBaEI7QUFBQSxVQUNJMnBCLFdBQVczcEIsVUFBVUEsVUFBVXhULE1BQVYsR0FBbUIsQ0FBN0IsQ0FEZjs7QUFHQSxVQUFJeWdDLFNBQVMsRUFBYjtBQUFBLFVBQ0lDLFlBREo7O0FBR0EsVUFBSUMsaUJBQWlCekQsU0FBckI7QUFBQSxVQUNJMEQsZUFBZXpELFFBRG5CO0FBRUEsVUFBSTBELG1CQUFtQixDQUF2QjtBQUFBLFVBQ0lDLGlCQUFpQjNELFNBQVNuOUIsTUFEOUI7O0FBR0EsVUFBSWtFLFFBQUosRUFBYzY4QixpQkFBZDs7QUFFQSxXQUFLLElBQUloaEMsSUFBSSxDQUFSLEVBQVd3QyxNQUFNaVIsVUFBVXhULE1BQWhDLEVBQXdDRCxJQUFJd0MsR0FBNUMsRUFBaUQsRUFBRXhDLENBQW5ELEVBQXNEO0FBQ3BEbUUsbUJBQVdzUCxVQUFVelQsQ0FBVixDQUFYO0FBQ0FnaEMsNEJBQW9CLEtBQUtDLDRCQUFMLENBQWtDOThCLFNBQVNXLFVBQTNDLEVBQXVELEtBQXZELENBQXBCO0FBQ0EsWUFBSWs4QixpQkFBSixFQUF1QjtBQUNyQixjQUFJLENBQUNMLFlBQUwsRUFBbUI7QUFDakJBLDJCQUFlLElBQUlkLEtBQUosQ0FBVW1CLGlCQUFWLENBQWY7QUFDQU4sbUJBQU85OUIsSUFBUCxDQUFZKzlCLFlBQVo7QUFDRDtBQUNEQSx1QkFBYWx0QixTQUFiLENBQXVCN1EsSUFBdkIsQ0FBNEJ1QixRQUE1QjtBQUNBLGNBQUlBLGFBQWFnNUIsU0FBakIsRUFBNEI7QUFDMUJ5RCw2QkFBaUJELGFBQWFaLGFBQTlCO0FBQ0FlLCtCQUFtQkYsZUFBZTNnQyxNQUFsQztBQUNEO0FBQ0QsY0FBSWtFLGFBQWFpNUIsUUFBakIsRUFBMkI7QUFDekJ5RCwyQkFBZUYsYUFBYVosYUFBNUI7QUFDQWdCLDZCQUFpQkosYUFBYVYsU0FBYixFQUFqQjtBQUNEO0FBQ0YsU0FkRCxNQWNPO0FBQ0xVLHlCQUFlLElBQWY7QUFDRDtBQUNGOztBQUVEO0FBQ0EsVUFBSU8sZUFBZSxLQUFLRCw0QkFBTCxDQUFrQzdELFNBQVN0NEIsVUFBM0MsRUFBdUQsSUFBdkQsQ0FBbkI7QUFDQSxVQUFJbzhCLFlBQUosRUFBa0I7QUFDaEIsWUFBSSxDQUFDUCxZQUFMLEVBQW1CO0FBQ2pCQSx5QkFBZSxJQUFJZCxLQUFKLENBQVV6QyxRQUFWLENBQWY7QUFDQXNELGlCQUFPOTlCLElBQVAsQ0FBWSs5QixZQUFaO0FBQ0Q7QUFDREEscUJBQWFsdEIsU0FBYixDQUF1QjdRLElBQXZCLENBQTRCcytCLFlBQTVCO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFJUixPQUFPemdDLE1BQVgsRUFBbUI7QUFDakIsYUFBS0QsSUFBSSxDQUFKLEVBQU93QyxNQUFNaytCLE9BQU96Z0MsTUFBekIsRUFBaUNELElBQUl3QyxHQUFyQyxFQUEwQyxFQUFFeEMsQ0FBNUMsRUFBK0M7QUFDN0MwZ0MsaUJBQU8xZ0MsQ0FBUCxFQUFVZ2dDLE9BQVY7QUFDRDtBQUNEO0FBQ0ExL0IsY0FBTXlTLFFBQU4sQ0FBZTZ0QixjQUFmLEVBQStCRSxnQkFBL0I7QUFDQXhnQyxjQUFNMFMsTUFBTixDQUFhNnRCLFlBQWIsRUFBMkJFLGNBQTNCO0FBQ0Q7QUFDRixLQXJFcUI7O0FBdUV0QkUsa0NBQThCLFNBQVNBLDRCQUFULENBQXNDeDhCLElBQXRDLEVBQTRDMDhCLE9BQTVDLEVBQXFEO0FBQ2pGLFVBQUlDLGFBQWEzOEIsS0FBS00sUUFBTCxJQUFpQmxILFVBQVVZLFNBQTVDO0FBQ0EsVUFBSXdGLEtBQUttOUIsYUFBYTM4QixLQUFLSyxVQUFsQixHQUErQkwsSUFBeEM7QUFDQSxVQUFJNDhCLFlBQUo7QUFDQSxVQUFJQyxXQUFXSCxVQUFVLGFBQVYsR0FBMEIsaUJBQXpDO0FBQ0EsVUFBSUMsVUFBSixFQUFnQjtBQUNkO0FBQ0FDLHVCQUFlNThCLEtBQUs2OEIsUUFBTCxDQUFmO0FBQ0EsWUFBSUQsZ0JBQWdCQSxhQUFhdDhCLFFBQWIsSUFBeUJsSCxVQUFVWSxTQUF2RCxFQUFrRTtBQUNoRSxpQkFBTzRpQyxZQUFQO0FBQ0Q7QUFDRixPQU5ELE1BTU87QUFDTDtBQUNBQSx1QkFBZXA5QixHQUFHcTlCLFFBQUgsQ0FBZjtBQUNBLFlBQUlELGdCQUFnQixLQUFLRSxvQkFBTCxDQUEwQjk4QixJQUExQixFQUFnQzQ4QixZQUFoQyxDQUFwQixFQUFtRTtBQUNqRSxpQkFBT0EsYUFBYUYsVUFBVSxZQUFWLEdBQXlCLFdBQXRDLENBQVA7QUFDRDtBQUNGO0FBQ0QsYUFBTyxJQUFQO0FBQ0QsS0ExRnFCOztBQTRGdEJJLDBCQUFzQixTQUFTQSxvQkFBVCxDQUE4QnZDLEdBQTlCLEVBQW1DQyxHQUFuQyxFQUF3QztBQUM1RCxhQUFPbDdCLE1BQU0vRixHQUFOLENBQVVxRyxhQUFWLENBQXdCLEtBQUs4N0IsUUFBN0IsRUFBdUMsQ0FBQ25CLElBQUkzUCxPQUFKLElBQWUsRUFBaEIsRUFBb0JuTSxXQUFwQixFQUF2QyxLQUE2RW5mLE1BQU0vRixHQUFOLENBQVVxRyxhQUFWLENBQXdCLEtBQUs4N0IsUUFBN0IsRUFBdUMsQ0FBQ2xCLElBQUk1UCxPQUFKLElBQWUsRUFBaEIsRUFBb0JuTSxXQUFwQixFQUF2QyxDQUE3RSxJQUEwSjZiLGVBQWVDLEdBQWYsRUFBb0JDLEdBQXBCLENBQTFKLElBQXNMRSxtQ0FBbUNILEdBQW5DLEVBQXdDQyxHQUF4QyxDQUE3TDtBQUNELEtBOUZxQjs7QUFnR3RCdUMscUJBQWlCLFNBQVNBLGVBQVQsQ0FBeUIzNkIsR0FBekIsRUFBOEI7QUFDN0MsVUFBSTVDLEtBQUs0QyxJQUFJM0MsYUFBSixDQUFrQixLQUFLaThCLFFBQUwsQ0FBYyxDQUFkLENBQWxCLENBQVQ7QUFDQSxVQUFJLEtBQUt2QixRQUFULEVBQW1CO0FBQ2pCMzZCLFdBQUdpbUIsU0FBSCxHQUFlLEtBQUswVSxRQUFwQjtBQUNEO0FBQ0QsYUFBTzM2QixFQUFQO0FBQ0QsS0F0R3FCOztBQXdHdEJ3OUIscUJBQWlCLFNBQVNBLGVBQVQsQ0FBeUJ0OUIsUUFBekIsRUFBbUM7QUFDbEQsVUFBSVUsU0FBU1YsU0FBU1csVUFBdEI7QUFDQSxVQUFJRCxPQUFPTSxVQUFQLENBQWtCbEYsTUFBbEIsSUFBNEIsQ0FBNUIsSUFBaUM4RCxNQUFNL0YsR0FBTixDQUFVcUcsYUFBVixDQUF3QixLQUFLODdCLFFBQTdCLEVBQXVDdDdCLE9BQU93cUIsT0FBUCxDQUFlbk0sV0FBZixFQUF2QyxDQUFyQyxFQUEyRztBQUN6RyxZQUFJLEtBQUswYixRQUFULEVBQW1CO0FBQ2pCM1UsbUJBQVNwbEIsTUFBVCxFQUFpQixLQUFLKzVCLFFBQXRCLEVBQWdDLEtBQUt3QixrQkFBckM7QUFDRDtBQUNGLE9BSkQsTUFJTztBQUNMLFlBQUluOEIsS0FBSyxLQUFLdTlCLGVBQUwsQ0FBcUJ6OUIsTUFBTS9GLEdBQU4sQ0FBVTBJLFdBQVYsQ0FBc0J2QyxRQUF0QixDQUFyQixDQUFUO0FBQ0FBLGlCQUFTVyxVQUFULENBQW9CcUIsWUFBcEIsQ0FBaUNsQyxFQUFqQyxFQUFxQ0UsUUFBckM7QUFDQUYsV0FBR21DLFdBQUgsQ0FBZWpDLFFBQWY7QUFDRDtBQUNGLEtBbkhxQjs7QUFxSHRCdTlCLGlCQUFhLFNBQVNBLFdBQVQsQ0FBcUJ6OUIsRUFBckIsRUFBeUI7QUFDcEMsYUFBT0YsTUFBTS9GLEdBQU4sQ0FBVXFHLGFBQVYsQ0FBd0IsS0FBSzg3QixRQUE3QixFQUF1Q2w4QixHQUFHb3JCLE9BQUgsQ0FBV25NLFdBQVgsRUFBdkMsS0FBb0VybEIsVUFBVU0sSUFBVixDQUFla3FCLE1BQWYsQ0FBc0Jwa0IsR0FBR2ltQixTQUF6QixFQUFvQzNCLElBQXBDLE1BQThDLEtBQUtxVyxRQUE5SDtBQUNELEtBdkhxQjs7QUF5SHRCK0Msb0JBQWdCLFNBQVNBLGNBQVQsQ0FBd0J4OUIsUUFBeEIsRUFBa0M3RCxLQUFsQyxFQUF5Q3NoQyxpQkFBekMsRUFBNEQ7QUFDMUUsVUFBSSxDQUFDdGhDLE1BQU02UyxZQUFOLENBQW1CeXVCLGlCQUFuQixDQUFMLEVBQTRDO0FBQzFDO0FBQ0EsWUFBSUMsZ0JBQWdCdmhDLE1BQU15TixVQUFOLEVBQXBCO0FBQ0E4ekIsc0JBQWM5dkIsVUFBZCxDQUF5QjZ2QixpQkFBekI7O0FBRUEsWUFBSUMsY0FBY2x2QixjQUFkLENBQTZCclMsTUFBTTZKLFlBQW5DLEVBQWlEN0osTUFBTXdNLFNBQXZELEtBQXFFMHlCLGFBQWFsL0IsTUFBTTZKLFlBQW5CLEVBQWlDN0osTUFBTXdNLFNBQXZDLENBQXpFLEVBQTRIO0FBQzFIMnlCLHNCQUFZbUMsaUJBQVosRUFBK0J0aEMsTUFBTTZKLFlBQXJDLEVBQW1EN0osTUFBTXdNLFNBQXpEO0FBQ0F4TSxnQkFBTXFWLFdBQU4sQ0FBa0Jpc0IsaUJBQWxCO0FBQ0Q7QUFDRCxZQUFJQyxjQUFjbHZCLGNBQWQsQ0FBNkJyUyxNQUFNNEosY0FBbkMsRUFBbUQ1SixNQUFNdU0sV0FBekQsS0FBeUUyeUIsYUFBYWwvQixNQUFNNEosY0FBbkIsRUFBbUM1SixNQUFNdU0sV0FBekMsQ0FBN0UsRUFBb0k7QUFDbEkrMEIsOEJBQW9CbkMsWUFBWW1DLGlCQUFaLEVBQStCdGhDLE1BQU00SixjQUFyQyxFQUFxRDVKLE1BQU11TSxXQUEzRCxDQUFwQjtBQUNEO0FBQ0Y7O0FBRUQsVUFBSSxLQUFLdXpCLGtCQUFULEVBQTZCO0FBQzNCL1Ysb0JBQVl1WCxpQkFBWixFQUErQixLQUFLeEIsa0JBQXBDO0FBQ0Q7QUFDRCxVQUFJLEtBQUtzQixXQUFMLENBQWlCRSxpQkFBakIsQ0FBSixFQUF5QztBQUN2QzFDLCtCQUF1QjBDLGlCQUF2QjtBQUNEO0FBQ0YsS0E5SXFCOztBQWdKdEJFLGtCQUFjLFNBQVNBLFlBQVQsQ0FBc0J4aEMsS0FBdEIsRUFBNkI7QUFDekMsVUFBSW1ULFlBQVluVCxNQUFNb1QsUUFBTixDQUFlLENBQUM3VixVQUFVWSxTQUFYLENBQWYsQ0FBaEI7QUFDQSxVQUFJLENBQUNnVixVQUFVeFQsTUFBZixFQUF1QjtBQUNyQixZQUFJO0FBQ0YsY0FBSXdFLE9BQU8sS0FBSys4QixlQUFMLENBQXFCbGhDLE1BQU02SixZQUFOLENBQW1CeEQsYUFBeEMsQ0FBWDtBQUNBckcsZ0JBQU1vUixnQkFBTixDQUF1QmpOLElBQXZCO0FBQ0EsZUFBS3NOLFVBQUwsQ0FBZ0J6UixLQUFoQixFQUF1Qm1FLElBQXZCO0FBQ0E7QUFDRCxTQUxELENBS0UsT0FBT2IsQ0FBUCxFQUFVLENBQUU7QUFDZjs7QUFFRHRELFlBQU13VixlQUFOO0FBQ0FyQyxrQkFBWW5ULE1BQU1vVCxRQUFOLENBQWUsQ0FBQzdWLFVBQVVZLFNBQVgsQ0FBZixDQUFaOztBQUVBLFVBQUlnVixVQUFVeFQsTUFBZCxFQUFzQjtBQUNwQixZQUFJa0UsUUFBSjs7QUFFQSxhQUFLLElBQUluRSxJQUFJLENBQVIsRUFBV3dDLE1BQU1pUixVQUFVeFQsTUFBaEMsRUFBd0NELElBQUl3QyxHQUE1QyxFQUFpRCxFQUFFeEMsQ0FBbkQsRUFBc0Q7QUFDcERtRSxxQkFBV3NQLFVBQVV6VCxDQUFWLENBQVg7QUFDQSxjQUFJLENBQUMsS0FBS3VnQyxvQkFBTCxDQUEwQnA4QixRQUExQixDQUFMLEVBQTBDO0FBQ3hDLGlCQUFLczlCLGVBQUwsQ0FBcUJ0OUIsUUFBckI7QUFDRDtBQUNGOztBQUVEN0QsY0FBTXlTLFFBQU4sQ0FBZVUsVUFBVSxDQUFWLENBQWYsRUFBNkIsQ0FBN0I7QUFDQXRQLG1CQUFXc1AsVUFBVUEsVUFBVXhULE1BQVYsR0FBbUIsQ0FBN0IsQ0FBWDtBQUNBSyxjQUFNMFMsTUFBTixDQUFhN08sUUFBYixFQUF1QkEsU0FBU2xFLE1BQWhDOztBQUVBLFlBQUksS0FBS29nQyxTQUFULEVBQW9CO0FBQ2xCLGVBQUtJLFNBQUwsQ0FBZWh0QixTQUFmLEVBQTBCblQsS0FBMUI7QUFDRDtBQUNGO0FBQ0YsS0FoTHFCOztBQWtMdEJ5aEMsaUJBQWEsU0FBU0EsV0FBVCxDQUFxQnpoQyxLQUFyQixFQUE0QjtBQUN2QyxVQUFJbVQsWUFBWW5ULE1BQU1vVCxRQUFOLENBQWUsQ0FBQzdWLFVBQVVZLFNBQVgsQ0FBZixDQUFoQjtBQUFBLFVBQ0kwRixRQURKO0FBQUEsVUFFSXk5QixpQkFGSjtBQUdBLFVBQUludUIsVUFBVXhULE1BQWQsRUFBc0I7QUFDcEJLLGNBQU13VixlQUFOO0FBQ0FyQyxvQkFBWW5ULE1BQU1vVCxRQUFOLENBQWUsQ0FBQzdWLFVBQVVZLFNBQVgsQ0FBZixDQUFaO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsWUFBSW9JLE1BQU12RyxNQUFNNkosWUFBTixDQUFtQnhELGFBQTdCO0FBQUEsWUFDSWxDLE9BQU9vQyxJQUFJekMsY0FBSixDQUFtQnZHLFVBQVVTLGVBQTdCLENBRFg7QUFFQWdDLGNBQU02USxVQUFOLENBQWlCMU0sSUFBakI7QUFDQW5FLGNBQU15UixVQUFOLENBQWlCdE4sSUFBakI7QUFDQWdQLG9CQUFZLENBQUNoUCxJQUFELENBQVo7QUFDRDs7QUFFRCxXQUFLLElBQUl6RSxJQUFJLENBQVIsRUFBV3dDLE1BQU1pUixVQUFVeFQsTUFBaEMsRUFBd0NELElBQUl3QyxHQUE1QyxFQUFpRCxFQUFFeEMsQ0FBbkQsRUFBc0Q7QUFDcERtRSxtQkFBV3NQLFVBQVV6VCxDQUFWLENBQVg7QUFDQTRoQyw0QkFBb0IsS0FBS3JCLG9CQUFMLENBQTBCcDhCLFFBQTFCLENBQXBCO0FBQ0EsWUFBSXk5QixpQkFBSixFQUF1QjtBQUNyQixlQUFLRCxjQUFMLENBQW9CeDlCLFFBQXBCLEVBQThCN0QsS0FBOUIsRUFBcUNzaEMsaUJBQXJDO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJcC9CLE9BQU8sQ0FBWCxFQUFjO0FBQ1osYUFBS3VQLFVBQUwsQ0FBZ0J6UixLQUFoQixFQUF1Qm1ULFVBQVUsQ0FBVixDQUF2QjtBQUNELE9BRkQsTUFFTztBQUNMblQsY0FBTXlTLFFBQU4sQ0FBZVUsVUFBVSxDQUFWLENBQWYsRUFBNkIsQ0FBN0I7QUFDQXRQLG1CQUFXc1AsVUFBVUEsVUFBVXhULE1BQVYsR0FBbUIsQ0FBN0IsQ0FBWDtBQUNBSyxjQUFNMFMsTUFBTixDQUFhN08sUUFBYixFQUF1QkEsU0FBU2xFLE1BQWhDOztBQUVBLFlBQUksS0FBS29nQyxTQUFULEVBQW9CO0FBQ2xCLGVBQUtJLFNBQUwsQ0FBZWh0QixTQUFmLEVBQTBCblQsS0FBMUI7QUFDRDtBQUNGO0FBQ0YsS0FwTnFCOztBQXNOdEJ5UixnQkFBWSxTQUFTQSxVQUFULENBQW9CelIsS0FBcEIsRUFBMkJtRSxJQUEzQixFQUFpQztBQUMzQyxVQUFJNDNCLFlBQVk1M0IsS0FBS00sUUFBTCxLQUFrQmxILFVBQVVXLFlBQTVDO0FBQUEsVUFDSTBaLGNBQWMsaUJBQWlCelQsSUFBakIsR0FBd0JBLEtBQUt5VCxXQUE3QixHQUEyQyxJQUQ3RDtBQUFBLFVBRUl2RyxVQUFVMHFCLFlBQVk1M0IsS0FBS3VMLFNBQWpCLEdBQTZCdkwsS0FBSzZELElBRmhEO0FBQUEsVUFHSXN3QixVQUFVam5CLFlBQVksRUFBWixJQUFrQkEsWUFBWTlULFVBQVVTLGVBSHREOztBQUtBLFVBQUlzNkIsV0FBV3lELFNBQVgsSUFBd0Jua0IsV0FBNUIsRUFBeUM7QUFDdkM7QUFDQSxZQUFJO0FBQ0Z6VCxlQUFLdUwsU0FBTCxHQUFpQm5TLFVBQVVTLGVBQTNCO0FBQ0QsU0FGRCxDQUVFLE9BQU9zRixDQUFQLEVBQVUsQ0FBRTtBQUNmO0FBQ0R0RCxZQUFNc1Ysa0JBQU4sQ0FBeUJuUixJQUF6QjtBQUNBLFVBQUltMEIsV0FBV3lELFNBQWYsRUFBMEI7QUFDeEIvN0IsY0FBTTBOLFFBQU4sQ0FBZSxLQUFmO0FBQ0QsT0FGRCxNQUVPLElBQUk0cUIsT0FBSixFQUFhO0FBQ2xCdDRCLGNBQU00VCxhQUFOLENBQW9CelAsSUFBcEI7QUFDQW5FLGNBQU1xVixXQUFOLENBQWtCbFIsSUFBbEI7QUFDRDtBQUNGLEtBek9xQjs7QUEyT3RCdTlCLDRCQUF3QixTQUFTQSxzQkFBVCxDQUFnQzc5QixRQUFoQyxFQUEwQzdELEtBQTFDLEVBQWlEO0FBQ3ZFLFVBQUkrVyxZQUFZL1csTUFBTXlOLFVBQU4sRUFBaEI7QUFDQXNKLGdCQUFVekIsa0JBQVYsQ0FBNkJ6UixRQUE3Qjs7QUFFQSxVQUFJMk8sb0JBQW9CdUUsVUFBVXhFLFlBQVYsQ0FBdUJ2UyxLQUF2QixDQUF4QjtBQUNBLFVBQUl1WSxPQUFPL0Ysb0JBQW9CQSxrQkFBa0I5SSxRQUFsQixFQUFwQixHQUFtRCxFQUE5RDtBQUNBcU4sZ0JBQVVuVixNQUFWOztBQUVBLGFBQU8yVyxJQUFQO0FBQ0QsS0FwUHFCOztBQXNQdEJvcEIsc0JBQWtCLFNBQVNBLGdCQUFULENBQTBCM2hDLEtBQTFCLEVBQWlDO0FBQ2pELFVBQUlrRixZQUFZLEVBQWhCO0FBQUEsVUFDSUcsUUFESjtBQUFBLFVBRUk4TixZQUFZblQsTUFBTW9ULFFBQU4sQ0FBZSxDQUFDN1YsVUFBVVksU0FBWCxDQUFmLENBRmhCO0FBR0EsVUFBSSxDQUFDZ1YsVUFBVXhULE1BQWYsRUFBdUI7QUFDckIwRixtQkFBVyxLQUFLNDZCLG9CQUFMLENBQTBCamdDLE1BQU00SixjQUFoQyxDQUFYO0FBQ0EsZUFBT3ZFLFdBQVcsQ0FBQ0EsUUFBRCxDQUFYLEdBQXdCLEtBQS9CO0FBQ0Q7O0FBRUQsV0FBSyxJQUFJM0YsSUFBSSxDQUFSLEVBQVd3QyxNQUFNaVIsVUFBVXhULE1BQTNCLEVBQW1DaWlDLFlBQXhDLEVBQXNEbGlDLElBQUl3QyxHQUExRCxFQUErRCxFQUFFeEMsQ0FBakUsRUFBb0U7QUFDbEVraUMsdUJBQWUsS0FBS0Ysc0JBQUwsQ0FBNEJ2dUIsVUFBVXpULENBQVYsQ0FBNUIsRUFBMENNLEtBQTFDLENBQWY7QUFDQXFGLG1CQUFXLEtBQUs0NkIsb0JBQUwsQ0FBMEI5c0IsVUFBVXpULENBQVYsQ0FBMUIsQ0FBWDtBQUNBLFlBQUlraUMsZ0JBQWdCLEVBQWhCLElBQXNCLENBQUN2OEIsUUFBM0IsRUFBcUM7QUFDbkMsaUJBQU8sS0FBUDtBQUNELFNBRkQsTUFFTztBQUNMSCxvQkFBVTVDLElBQVYsQ0FBZStDLFFBQWY7QUFDRDtBQUNGO0FBQ0QsYUFBT0gsU0FBUDtBQUNELEtBelFxQjs7QUEyUXRCMjhCLGlCQUFhLFNBQVNBLFdBQVQsQ0FBcUI3aEMsS0FBckIsRUFBNEI7QUFDdkMsVUFBSSxLQUFLMmhDLGdCQUFMLENBQXNCM2hDLEtBQXRCLENBQUosRUFBa0M7QUFDaEMsYUFBS3loQyxXQUFMLENBQWlCemhDLEtBQWpCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBS3doQyxZQUFMLENBQWtCeGhDLEtBQWxCO0FBQ0Q7QUFDRjtBQWpScUIsR0FBeEI7O0FBb1JBekMsWUFBVU8sU0FBVixDQUFvQjhoQyxXQUFwQixHQUFrQ0EsV0FBbEM7QUFDRCxDQWhiRCxFQWdiR3JpQyxTQWhiSCxFQWdiY2tHLEtBaGJkLEUsQ0FnYnNCOzs7Ozs7QUFNdEJsRyxVQUFVdWtDLFFBQVYsR0FBcUJ6aEIsS0FBS2xmLE1BQUw7QUFDckIsMENBQTBDO0FBQ3hDOUQsZUFBYSxTQUFTQSxXQUFULENBQXFCMDZCLE1BQXJCLEVBQTZCO0FBQ3hDLFNBQUtBLE1BQUwsR0FBY0EsTUFBZDtBQUNBLFNBQUs2QixRQUFMLEdBQWdCN0IsT0FBTzZCLFFBQXZCO0FBQ0EsU0FBS3J6QixHQUFMLEdBQVcsS0FBS3F6QixRQUFMLENBQWNyekIsR0FBekI7QUFDRCxHQUx1Qzs7QUFPeEM7Ozs7Ozs7QUFPQXc3QixXQUFTLFNBQVNBLE9BQVQsQ0FBaUJwZCxPQUFqQixFQUEwQjtBQUNqQyxXQUFPcG5CLFVBQVV3a0IsT0FBVixDQUFrQjBDLGVBQWxCLENBQWtDLEtBQUtsZSxHQUF2QyxFQUE0Q29lLE9BQTVDLENBQVA7QUFDRCxHQWhCdUM7O0FBa0J4Qzs7Ozs7Ozs7QUFRQXVXLFFBQU0sU0FBU0EsSUFBVCxDQUFjdlcsT0FBZCxFQUF1QnhELEtBQXZCLEVBQThCO0FBQ2xDLFFBQUkvakIsTUFBTUcsVUFBVUUsUUFBVixDQUFtQmtuQixPQUFuQixDQUFWO0FBQUEsUUFDSTFhLE9BQU8xTSxVQUFVTSxJQUFWLENBQWUyb0IsS0FBZixDQUFxQjFGLFNBQXJCLEVBQWdDK0YsR0FBaEMsRUFEWDtBQUFBLFFBRUl6RixTQUFTaGtCLE9BQU9BLElBQUk4OUIsSUFGeEI7QUFBQSxRQUdJOEcsU0FBUyxJQUhiOztBQUtBLFNBQUtqSyxNQUFMLENBQVkzUSxJQUFaLENBQWlCLHdCQUFqQjs7QUFFQSxRQUFJaEcsTUFBSixFQUFZO0FBQ1ZuWCxXQUFLa3BCLE9BQUwsQ0FBYSxLQUFLeUcsUUFBbEI7QUFDQW9JLGVBQVM1Z0IsT0FBT1AsS0FBUCxDQUFhempCLEdBQWIsRUFBa0I2TSxJQUFsQixDQUFUO0FBQ0QsS0FIRCxNQUdPO0FBQ0wsVUFBSTtBQUNGO0FBQ0ErM0IsaUJBQVMsS0FBS3o3QixHQUFMLENBQVN3YyxXQUFULENBQXFCNEIsT0FBckIsRUFBOEIsS0FBOUIsRUFBcUN4RCxLQUFyQyxDQUFUO0FBQ0QsT0FIRCxDQUdFLE9BQU83ZCxDQUFQLEVBQVUsQ0FBRTtBQUNmOztBQUVELFNBQUt5MEIsTUFBTCxDQUFZM1EsSUFBWixDQUFpQix1QkFBakI7QUFDQSxXQUFPNGEsTUFBUDtBQUNELEdBOUN1Qzs7QUFnRHhDOzs7Ozs7Ozs7O0FBVUFDLFNBQU8sU0FBU0EsS0FBVCxDQUFldGQsT0FBZixFQUF3QnVkLFlBQXhCLEVBQXNDO0FBQzNDLFFBQUk5a0MsTUFBTUcsVUFBVUUsUUFBVixDQUFtQmtuQixPQUFuQixDQUFWO0FBQUEsUUFDSTFhLE9BQU8xTSxVQUFVTSxJQUFWLENBQWUyb0IsS0FBZixDQUFxQjFGLFNBQXJCLEVBQWdDK0YsR0FBaEMsRUFEWDtBQUFBLFFBRUl6RixTQUFTaGtCLE9BQU9BLElBQUk2a0MsS0FGeEI7QUFHQSxRQUFJN2dCLE1BQUosRUFBWTtBQUNWblgsV0FBS2twQixPQUFMLENBQWEsS0FBS3lHLFFBQWxCO0FBQ0EsYUFBT3hZLE9BQU9QLEtBQVAsQ0FBYXpqQixHQUFiLEVBQWtCNk0sSUFBbEIsQ0FBUDtBQUNELEtBSEQsTUFHTztBQUNMLFVBQUk7QUFDRjtBQUNBLGVBQU8sS0FBSzFELEdBQUwsQ0FBUzBjLGlCQUFULENBQTJCMEIsT0FBM0IsQ0FBUDtBQUNELE9BSEQsQ0FHRSxPQUFPcmhCLENBQVAsRUFBVTtBQUNWLGVBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRixHQXpFdUM7O0FBMkV4Qzs7Ozs7Ozs7QUFRQTZkLFNBQU8sU0FBU0EsS0FBVCxDQUFld0QsT0FBZixFQUF3QjtBQUM3QixRQUFJdm5CLE1BQU1HLFVBQVVFLFFBQVYsQ0FBbUJrbkIsT0FBbkIsQ0FBVjtBQUFBLFFBQ0l2RCxTQUFTaGtCLE9BQU9BLElBQUkrakIsS0FEeEI7QUFFQSxRQUFJQyxNQUFKLEVBQVk7QUFDVixhQUFPQSxPQUFPaFgsSUFBUCxDQUFZaE4sR0FBWixFQUFpQixLQUFLdzhCLFFBQXRCLEVBQWdDalYsT0FBaEMsQ0FBUDtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUk7QUFDRjtBQUNBLGVBQU8sS0FBS3BlLEdBQUwsQ0FBUzQ3QixpQkFBVCxDQUEyQnhkLE9BQTNCLENBQVA7QUFDRCxPQUhELENBR0UsT0FBT3JoQixDQUFQLEVBQVU7QUFDVixlQUFPLElBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFoR3VDLENBRHJCLENBQXJCO0FBbUdBLENBQUMsVUFBVS9GLFNBQVYsRUFBcUI7QUFDcEIsTUFBSTZrQyxLQUFKOztBQUVBN2tDLFlBQVVFLFFBQVYsQ0FBbUI0a0MsSUFBbkIsR0FBMEI7QUFDeEJuSCxVQUFNLFNBQVNBLElBQVQsQ0FBY3RCLFFBQWQsRUFBd0JqVixPQUF4QixFQUFpQztBQUNyQyxhQUFPcG5CLFVBQVVFLFFBQVYsQ0FBbUI2a0MsWUFBbkIsQ0FBZ0NwSCxJQUFoQyxDQUFxQ3RCLFFBQXJDLEVBQStDalYsT0FBL0MsRUFBd0QsR0FBeEQsQ0FBUDtBQUNELEtBSHVCOztBQUt4QnNkLFdBQU8sU0FBU0EsS0FBVCxDQUFlckksUUFBZixFQUF5QmpWLE9BQXpCLEVBQWtDNGQsS0FBbEMsRUFBeUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQU9obEMsVUFBVUUsUUFBVixDQUFtQjZrQyxZQUFuQixDQUFnQ0wsS0FBaEMsQ0FBc0NySSxRQUF0QyxFQUFnRGpWLE9BQWhELEVBQXlELEdBQXpELENBQVA7QUFDRCxLQVp1Qjs7QUFjeEJ4RCxXQUFPLFNBQVNBLEtBQVQsR0FBaUI7QUFDdEIsYUFBT2loQixLQUFQO0FBQ0Q7QUFoQnVCLEdBQTFCO0FBa0JELENBckJELEVBcUJHN2tDLFNBckJIOztBQXVCQSxDQUFDLFVBQVVBLFNBQVYsRUFBcUI7QUFDcEIsTUFBSTZrQyxLQUFKO0FBQUEsTUFDSUksWUFBWSxHQURoQjtBQUFBLE1BRUk5a0MsTUFBTUgsVUFBVUcsR0FGcEI7O0FBSUEsV0FBUytrQyxhQUFULENBQXVCN0ksUUFBdkIsRUFBaUM4SSxPQUFqQyxFQUEwQztBQUN4QyxRQUFJL2lDLFNBQVMraUMsUUFBUS9pQyxNQUFyQjtBQUFBLFFBQ0lELElBQUksQ0FEUjtBQUFBLFFBRUl1Z0IsTUFGSjtBQUFBLFFBR0kwaUIsV0FISjtBQUFBLFFBSUlsSyxXQUpKO0FBS0EsV0FBTy80QixJQUFJQyxNQUFYLEVBQW1CRCxHQUFuQixFQUF3QjtBQUN0QnVnQixlQUFTeWlCLFFBQVFoakMsQ0FBUixDQUFUO0FBQ0FpakMsb0JBQWNqbEMsSUFBSXd2QixnQkFBSixDQUFxQmpOLE1BQXJCLEVBQTZCLEVBQUU5WCxVQUFVLE1BQVosRUFBN0IsQ0FBZDtBQUNBc3dCLG9CQUFjLzZCLElBQUlnN0IsY0FBSixDQUFtQnpZLE1BQW5CLENBQWQ7O0FBRUE7QUFDQTtBQUNBLFVBQUl3WSxZQUFZL1YsS0FBWixDQUFrQmhsQixJQUFJa3JCLFFBQUosQ0FBYUosV0FBL0IsS0FBK0MsQ0FBQ21hLFdBQXBELEVBQWlFO0FBQy9EO0FBQ0FBLHNCQUFjamxDLElBQUlrM0IsYUFBSixDQUFrQjNVLE1BQWxCLEVBQTBCLE1BQTFCLENBQWQ7QUFDRCxPQUhELE1BR087QUFDTHZpQixZQUFJcTNCLHFCQUFKLENBQTBCOVUsTUFBMUI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsV0FBUzJpQixPQUFULENBQWlCaEosUUFBakIsRUFBMkJ0SSxVQUEzQixFQUF1QztBQUNyQyxRQUFJL3FCLE1BQU1xekIsU0FBU3J6QixHQUFuQjtBQUFBLFFBQ0lzOEIsWUFBWSxxQkFBcUIsQ0FBQyxJQUFJQyxJQUFKLEVBRHRDO0FBQUEsUUFFSUMsa0JBQWtCLHFCQUZ0QjtBQUFBLFFBR0lyakMsSUFBSSxDQUhSO0FBQUEsUUFJSUMsTUFKSjtBQUFBLFFBS0kraUMsT0FMSjtBQUFBLFFBTUl6aUIsTUFOSjtBQUFBLFFBT0kraUIsZUFQSjtBQUFBLFFBUUkxSyxPQVJKO0FBQUEsUUFTSTJLLHNCQVRKO0FBQUEsUUFVSXhLLFdBVko7QUFBQSxRQVdJeUssVUFYSjtBQUFBLFFBWUlsSyxDQVpKO0FBYUF6N0IsY0FBVUUsUUFBVixDQUFtQjZrQyxZQUFuQixDQUFnQ3BILElBQWhDLENBQXFDdEIsUUFBckMsRUFBK0N3SSxLQUEvQyxFQUFzREksU0FBdEQsRUFBaUVLLFNBQWpFLEVBQTRFRSxlQUE1RTtBQUNBTCxjQUFVbjhCLElBQUk2YyxnQkFBSixDQUFxQm9mLFlBQVksR0FBWixHQUFrQkssU0FBdkMsQ0FBVjtBQUNBbGpDLGFBQVMraUMsUUFBUS9pQyxNQUFqQjtBQUNBLFdBQU9ELElBQUlDLE1BQVgsRUFBbUJELEdBQW5CLEVBQXdCO0FBQ3RCdWdCLGVBQVN5aUIsUUFBUWhqQyxDQUFSLENBQVQ7QUFDQXVnQixhQUFPcWYsZUFBUCxDQUF1QixPQUF2QjtBQUNBLFdBQUt0RyxDQUFMLElBQVUxSCxVQUFWLEVBQXNCO0FBQ3BCclIsZUFBTytELFlBQVAsQ0FBb0JnVixDQUFwQixFQUF1QjFILFdBQVcwSCxDQUFYLENBQXZCO0FBQ0Q7QUFDRjs7QUFFRGlLLDZCQUF5QmhqQixNQUF6QjtBQUNBLFFBQUl0Z0IsV0FBVyxDQUFmLEVBQWtCO0FBQ2hCODRCLG9CQUFjLzZCLElBQUlnN0IsY0FBSixDQUFtQnpZLE1BQW5CLENBQWQ7QUFDQStpQix3QkFBa0IsQ0FBQyxDQUFDL2lCLE9BQU9rRCxhQUFQLENBQXFCLEdBQXJCLENBQXBCO0FBQ0FtVixnQkFBVUcsZ0JBQWdCLEVBQWhCLElBQXNCQSxnQkFBZ0JsN0IsVUFBVVMsZUFBMUQ7QUFDQSxVQUFJLENBQUNnbEMsZUFBRCxJQUFvQjFLLE9BQXhCLEVBQWlDO0FBQy9CNTZCLFlBQUk4NkIsY0FBSixDQUFtQnZZLE1BQW5CLEVBQTJCcVIsV0FBVy9ZLElBQVgsSUFBbUIwSCxPQUFPdWEsSUFBckQ7QUFDQTBJLHFCQUFhMzhCLElBQUl6QyxjQUFKLENBQW1CLEdBQW5CLENBQWI7QUFDQTgxQixpQkFBUzk3QixTQUFULENBQW1CZytCLFFBQW5CLENBQTRCN2IsTUFBNUI7QUFDQTJaLGlCQUFTOTdCLFNBQVQsQ0FBbUIrUyxVQUFuQixDQUE4QnF5QixVQUE5QjtBQUNBRCxpQ0FBeUJDLFVBQXpCO0FBQ0Q7QUFDRjtBQUNEdEosYUFBUzk3QixTQUFULENBQW1CZytCLFFBQW5CLENBQTRCbUgsc0JBQTVCO0FBQ0Q7O0FBRUQxbEMsWUFBVUUsUUFBVixDQUFtQjBsQyxVQUFuQixHQUFnQztBQUM5Qjs7Ozs7Ozs7Ozs7OztBQWFBakksVUFBTSxTQUFTQSxJQUFULENBQWN0QixRQUFkLEVBQXdCalYsT0FBeEIsRUFBaUN4RCxLQUFqQyxFQUF3QztBQUM1QyxVQUFJdWhCLFVBQVUsS0FBS1QsS0FBTCxDQUFXckksUUFBWCxFQUFxQmpWLE9BQXJCLENBQWQ7QUFDQSxVQUFJK2QsT0FBSixFQUFhO0FBQ1g7QUFDQTlJLGlCQUFTOTdCLFNBQVQsQ0FBbUJtK0IsaUJBQW5CLENBQXFDLFlBQVk7QUFDL0N3Ryx3QkFBYzdJLFFBQWQsRUFBd0I4SSxPQUF4QjtBQUNELFNBRkQ7QUFHRCxPQUxELE1BS087QUFDTDtBQUNBdmhCLGdCQUFRLENBQUMsT0FBT0EsS0FBUCxLQUFpQixXQUFqQixHQUErQixXQUEvQixHQUE2Q2xrQixRQUFRa2tCLEtBQVIsQ0FBOUMsTUFBa0UsUUFBbEUsR0FBNkVBLEtBQTdFLEdBQXFGLEVBQUVxWixNQUFNclosS0FBUixFQUE3RjtBQUNBeWhCLGdCQUFRaEosUUFBUixFQUFrQnpZLEtBQWxCO0FBQ0Q7QUFDRixLQTFCNkI7O0FBNEI5QjhnQixXQUFPLFNBQVNBLEtBQVQsQ0FBZXJJLFFBQWYsRUFBeUJqVixPQUF6QixFQUFrQztBQUN2QyxhQUFPcG5CLFVBQVVFLFFBQVYsQ0FBbUI2a0MsWUFBbkIsQ0FBZ0NMLEtBQWhDLENBQXNDckksUUFBdEMsRUFBZ0RqVixPQUFoRCxFQUF5RCxHQUF6RCxDQUFQO0FBQ0QsS0E5QjZCOztBQWdDOUJ4RCxXQUFPLFNBQVNBLEtBQVQsR0FBaUI7QUFDdEIsYUFBT2loQixLQUFQO0FBQ0Q7QUFsQzZCLEdBQWhDO0FBb0NELENBeEdELEVBd0dHN2tDLFNBeEdILEUsQ0F3R2U7Ozs7O0FBS2YsQ0FBQyxVQUFVQSxTQUFWLEVBQXFCO0FBQ3BCLE1BQUk2a0MsS0FBSjtBQUFBLE1BQ0l4TyxVQUFVLDZCQURkOztBQUdBcjJCLFlBQVVFLFFBQVYsQ0FBbUIybEMsUUFBbkIsR0FBOEI7QUFDNUJsSSxVQUFNLFNBQVNBLElBQVQsQ0FBY3RCLFFBQWQsRUFBd0JqVixPQUF4QixFQUFpQzBlLElBQWpDLEVBQXVDO0FBQzNDLGFBQU85bEMsVUFBVUUsUUFBVixDQUFtQjZrQyxZQUFuQixDQUFnQ3BILElBQWhDLENBQXFDdEIsUUFBckMsRUFBK0NqVixPQUEvQyxFQUF3RCxNQUF4RCxFQUFnRSx1QkFBdUIwZSxJQUF2RixFQUE2RnpQLE9BQTdGLENBQVA7QUFDRCxLQUgyQjs7QUFLNUJxTyxXQUFPLFNBQVNBLEtBQVQsQ0FBZXJJLFFBQWYsRUFBeUJqVixPQUF6QixFQUFrQzBlLElBQWxDLEVBQXdDO0FBQzdDLGFBQU85bEMsVUFBVUUsUUFBVixDQUFtQjZrQyxZQUFuQixDQUFnQ0wsS0FBaEMsQ0FBc0NySSxRQUF0QyxFQUFnRGpWLE9BQWhELEVBQXlELE1BQXpELEVBQWlFLHVCQUF1QjBlLElBQXhGLEVBQThGelAsT0FBOUYsQ0FBUDtBQUNELEtBUDJCOztBQVM1QnpTLFdBQU8sU0FBU0EsS0FBVCxHQUFpQjtBQUN0QixhQUFPaWhCLEtBQVA7QUFDRDtBQVgyQixHQUE5QjtBQWFELENBakJELEVBaUJHN2tDLFNBakJIO0FBa0JBOzs7OztBQUtBLENBQUMsVUFBVUEsU0FBVixFQUFxQjtBQUNwQixNQUFJNmtDLEtBQUo7QUFBQSxNQUNJeE8sVUFBVSx1QkFEZDs7QUFHQXIyQixZQUFVRSxRQUFWLENBQW1CNmxDLFNBQW5CLEdBQStCO0FBQzdCcEksVUFBTSxTQUFTQSxJQUFULENBQWN0QixRQUFkLEVBQXdCalYsT0FBeEIsRUFBaUM0ZCxLQUFqQyxFQUF3QztBQUM1QyxhQUFPaGxDLFVBQVVFLFFBQVYsQ0FBbUI2a0MsWUFBbkIsQ0FBZ0NwSCxJQUFoQyxDQUFxQ3RCLFFBQXJDLEVBQStDalYsT0FBL0MsRUFBd0QsTUFBeEQsRUFBZ0UsbUJBQW1CNGQsS0FBbkYsRUFBMEYzTyxPQUExRixDQUFQO0FBQ0QsS0FINEI7O0FBSzdCcU8sV0FBTyxTQUFTQSxLQUFULENBQWVySSxRQUFmLEVBQXlCalYsT0FBekIsRUFBa0M0ZCxLQUFsQyxFQUF5QztBQUM5QyxhQUFPaGxDLFVBQVVFLFFBQVYsQ0FBbUI2a0MsWUFBbkIsQ0FBZ0NMLEtBQWhDLENBQXNDckksUUFBdEMsRUFBZ0RqVixPQUFoRCxFQUF5RCxNQUF6RCxFQUFpRSxtQkFBbUI0ZCxLQUFwRixFQUEyRjNPLE9BQTNGLENBQVA7QUFDRCxLQVA0Qjs7QUFTN0J6UyxXQUFPLFNBQVNBLEtBQVQsR0FBaUI7QUFDdEIsYUFBT2loQixLQUFQO0FBQ0Q7QUFYNEIsR0FBL0I7QUFhRCxDQWpCRCxFQWlCRzdrQyxTQWpCSCxFQWlCYyxDQUFDLFVBQVVBLFNBQVYsRUFBcUI7QUFDbEMsTUFBSTZrQyxLQUFKO0FBQUEsTUFDSTFrQyxNQUFNSCxVQUFVRyxHQURwQjtBQUFBLE1BRUk0eUIsb0JBQW9CLEtBRnhCOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQWlULHlCQUF1QixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixJQUFuQixFQUF5QixJQUF6QixFQUErQixJQUEvQixFQUFxQyxHQUFyQyxFQUEwQyxZQUExQyxFQUF3RGpULGlCQUF4RCxDQVB2Qjs7QUFTQTs7OztBQUlBLFdBQVNrVCxTQUFULENBQW1CM2pCLE9BQW5CLEVBQTRCK0osU0FBNUIsRUFBdUMyRCxXQUF2QyxFQUFvRDtBQUNsRCxRQUFJMU4sUUFBUStKLFNBQVosRUFBdUI7QUFDckI2WixtQkFBYTVqQixPQUFiLEVBQXNCME4sV0FBdEI7QUFDQTFOLGNBQVErSixTQUFSLElBQXFCLE1BQU1BLFNBQTNCO0FBQ0QsS0FIRCxNQUdPO0FBQ0wvSixjQUFRK0osU0FBUixHQUFvQkEsU0FBcEI7QUFDRDtBQUNGOztBQUVELFdBQVM2WixZQUFULENBQXNCNWpCLE9BQXRCLEVBQStCME4sV0FBL0IsRUFBNEM7QUFDMUMxTixZQUFRK0osU0FBUixHQUFvQi9KLFFBQVErSixTQUFSLENBQWtCcFIsT0FBbEIsQ0FBMEIrVSxXQUExQixFQUF1QyxFQUF2QyxDQUFwQjtBQUNEOztBQUVEOzs7QUFHQSxXQUFTbVcsZ0JBQVQsQ0FBMEJ2L0IsSUFBMUIsRUFBZ0M7QUFDOUIsV0FBT0EsS0FBS00sUUFBTCxLQUFrQmxILFVBQVVZLFNBQTVCLElBQXlDLENBQUNaLFVBQVVNLElBQVYsQ0FBZWtxQixNQUFmLENBQXNCNWpCLEtBQUs2RCxJQUEzQixFQUFpQ2lnQixJQUFqQyxFQUFqRDtBQUNEOztBQUVEOzs7QUFHQSxXQUFTMGIsaUNBQVQsQ0FBMkN4L0IsSUFBM0MsRUFBaUQ7QUFDL0MsUUFBSVEsa0JBQWtCUixLQUFLUSxlQUEzQjtBQUNBLFdBQU9BLG1CQUFtQisrQixpQkFBaUIvK0IsZUFBakIsQ0FBMUIsRUFBNkQ7QUFDM0RBLHdCQUFrQkEsZ0JBQWdCQSxlQUFsQztBQUNEO0FBQ0QsV0FBT0EsZUFBUDtBQUNEOztBQUVEOzs7QUFHQSxXQUFTaS9CLDZCQUFULENBQXVDei9CLElBQXZDLEVBQTZDO0FBQzNDLFFBQUl5QixjQUFjekIsS0FBS3lCLFdBQXZCO0FBQ0EsV0FBT0EsZUFBZTg5QixpQkFBaUI5OUIsV0FBakIsQ0FBdEIsRUFBcUQ7QUFDbkRBLG9CQUFjQSxZQUFZQSxXQUExQjtBQUNEO0FBQ0QsV0FBT0EsV0FBUDtBQUNEOztBQUVEOzs7O0FBSUEsV0FBU2krQiwyQkFBVCxDQUFxQzEvQixJQUFyQyxFQUEyQztBQUN6QyxRQUFJb0MsTUFBTXBDLEtBQUtrQyxhQUFmO0FBQUEsUUFDSVQsY0FBY2crQiw4QkFBOEJ6L0IsSUFBOUIsQ0FEbEI7QUFBQSxRQUVJUSxrQkFBa0JnL0Isa0NBQWtDeC9CLElBQWxDLENBRnRCOztBQUlBLFFBQUl5QixlQUFlLENBQUNrK0IsMkJBQTJCbCtCLFdBQTNCLENBQXBCLEVBQTZEO0FBQzNEekIsV0FBS0ssVUFBTCxDQUFnQnFCLFlBQWhCLENBQTZCVSxJQUFJM0MsYUFBSixDQUFrQixJQUFsQixDQUE3QixFQUFzRGdDLFdBQXREO0FBQ0Q7QUFDRCxRQUFJakIsbUJBQW1CLENBQUNtL0IsMkJBQTJCbi9CLGVBQTNCLENBQXhCLEVBQXFFO0FBQ25FUixXQUFLSyxVQUFMLENBQWdCcUIsWUFBaEIsQ0FBNkJVLElBQUkzQyxhQUFKLENBQWtCLElBQWxCLENBQTdCLEVBQXNETyxJQUF0RDtBQUNEO0FBQ0Y7O0FBRUQ7OztBQUdBLFdBQVM0L0IsOEJBQVQsQ0FBd0M1L0IsSUFBeEMsRUFBOEM7QUFDNUMsUUFBSXlCLGNBQWNnK0IsOEJBQThCei9CLElBQTlCLENBQWxCO0FBQUEsUUFDSVEsa0JBQWtCZy9CLGtDQUFrQ3gvQixJQUFsQyxDQUR0Qjs7QUFHQSxRQUFJeUIsZUFBZXF2QixhQUFhcnZCLFdBQWIsQ0FBbkIsRUFBOEM7QUFDNUNBLGtCQUFZcEIsVUFBWixDQUF1QitJLFdBQXZCLENBQW1DM0gsV0FBbkM7QUFDRDtBQUNELFFBQUlqQixtQkFBbUJzd0IsYUFBYXR3QixlQUFiLENBQXZCLEVBQXNEO0FBQ3BEQSxzQkFBZ0JILFVBQWhCLENBQTJCK0ksV0FBM0IsQ0FBdUM1SSxlQUF2QztBQUNEO0FBQ0Y7O0FBRUQsV0FBU3EvQiwyQkFBVCxDQUFxQzcvQixJQUFyQyxFQUEyQztBQUN6QyxRQUFJcU4sWUFBWXJOLEtBQUtxTixTQUFyQjtBQUNBLFFBQUlBLGFBQWF5akIsYUFBYXpqQixTQUFiLENBQWpCLEVBQTBDO0FBQ3hDQSxnQkFBVWhOLFVBQVYsQ0FBcUIrSSxXQUFyQixDQUFpQ2lFLFNBQWpDO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTeWpCLFlBQVQsQ0FBc0I5d0IsSUFBdEIsRUFBNEI7QUFDMUIsV0FBT0EsS0FBS2dFLFFBQUwsS0FBa0IsSUFBekI7QUFDRDs7QUFFRDs7OztBQUlBLFdBQVMyN0IsMEJBQVQsQ0FBb0Nqa0IsT0FBcEMsRUFBNkM7QUFDM0MsUUFBSW9WLGFBQWFwVixPQUFiLENBQUosRUFBMkI7QUFDekIsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsUUFBSW5pQixJQUFJcXRCLFFBQUosQ0FBYSxTQUFiLEVBQXdCQyxJQUF4QixDQUE2Qm5MLE9BQTdCLE1BQTBDLE9BQTlDLEVBQXVEO0FBQ3JELGFBQU8sSUFBUDtBQUNEOztBQUVELFdBQU8sS0FBUDtBQUNEOztBQUVEOzs7O0FBSUEsV0FBU29rQixZQUFULENBQXNCMTlCLEdBQXRCLEVBQTJCb2UsT0FBM0IsRUFBb0N4YyxRQUFwQyxFQUE4Q3loQixTQUE5QyxFQUF5RDtBQUN2RCxRQUFJQSxTQUFKLEVBQWU7QUFDYixVQUFJc2EsZ0JBQWdCeG1DLElBQUlzcEIsT0FBSixDQUFZemdCLEdBQVosRUFBaUIsaUJBQWpCLEVBQW9DLFVBQVVtbUIsS0FBVixFQUFpQjtBQUN2RSxZQUFJcmlCLFNBQVNxaUIsTUFBTXJpQixNQUFuQjtBQUFBLFlBQ0kyeEIsWUFESjtBQUVBLFlBQUkzeEIsT0FBTzVGLFFBQVAsS0FBb0JsSCxVQUFVVyxZQUFsQyxFQUFnRDtBQUM5QztBQUNEO0FBQ0Q4OUIsdUJBQWV0K0IsSUFBSXF0QixRQUFKLENBQWEsU0FBYixFQUF3QkMsSUFBeEIsQ0FBNkIzZ0IsTUFBN0IsQ0FBZjtBQUNBLFlBQUkyeEIsYUFBYTNTLE1BQWIsQ0FBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsTUFBOEIsUUFBbEMsRUFBNEM7QUFDMUM7QUFDQWhmLGlCQUFPdWYsU0FBUCxJQUFvQixNQUFNQSxTQUExQjtBQUNEO0FBQ0YsT0FYbUIsQ0FBcEI7QUFZRDtBQUNEcmpCLFFBQUl3YyxXQUFKLENBQWdCNEIsT0FBaEIsRUFBeUIsS0FBekIsRUFBZ0N4YyxRQUFoQztBQUNBLFFBQUkrN0IsYUFBSixFQUFtQjtBQUNqQkEsb0JBQWM3NEIsSUFBZDtBQUNEO0FBQ0Y7O0FBRUQsV0FBUzg0QixrQkFBVCxDQUE0QnZLLFFBQTVCLEVBQXNDL1osT0FBdEMsRUFBK0M7QUFDN0MrWixhQUFTOTdCLFNBQVQsQ0FBbUJ3L0IsVUFBbkI7QUFDQTFELGFBQVM5N0IsU0FBVCxDQUFtQm0vQixRQUFuQixDQUE0QnBkLE9BQTVCO0FBQ0Fra0IsbUNBQStCbGtCLE9BQS9CO0FBQ0Fta0IsZ0NBQTRCbmtCLE9BQTVCO0FBQ0ErWixhQUFTOTdCLFNBQVQsQ0FBbUIyVCxVQUFuQixDQUE4Qm9PLE9BQTlCO0FBQ0Q7O0FBRUQsV0FBU3VrQixXQUFULENBQXFCdmtCLE9BQXJCLEVBQThCO0FBQzVCLFdBQU8sQ0FBQyxDQUFDdGlCLFVBQVVNLElBQVYsQ0FBZWtxQixNQUFmLENBQXNCbEksUUFBUStKLFNBQTlCLEVBQXlDM0IsSUFBekMsRUFBVDtBQUNEOztBQUVEMXFCLFlBQVVFLFFBQVYsQ0FBbUI0bUMsV0FBbkIsR0FBaUM7QUFDL0JuSixVQUFNLFNBQVNBLElBQVQsQ0FBY3RCLFFBQWQsRUFBd0JqVixPQUF4QixFQUFpQ3hjLFFBQWpDLEVBQTJDeWhCLFNBQTNDLEVBQXNEMkQsV0FBdEQsRUFBbUU7QUFDdkUsVUFBSWhuQixNQUFNcXpCLFNBQVNyekIsR0FBbkI7QUFBQSxVQUNJMDBCLGVBQWUsS0FBS2dILEtBQUwsQ0FBV3JJLFFBQVgsRUFBcUJqVixPQUFyQixFQUE4QnhjLFFBQTlCLEVBQXdDeWhCLFNBQXhDLEVBQW1EMkQsV0FBbkQsQ0FEbkI7QUFBQSxVQUVJc04sWUFGSjs7QUFJQTF5QixpQkFBVyxPQUFPQSxRQUFQLEtBQW9CLFFBQXBCLEdBQStCQSxTQUFTOGxCLFdBQVQsRUFBL0IsR0FBd0Q5bEIsUUFBbkU7O0FBRUEsVUFBSTh5QixZQUFKLEVBQWtCO0FBQ2hCckIsaUJBQVM5N0IsU0FBVCxDQUFtQjgrQix1QkFBbkIsQ0FBMkMsWUFBWTtBQUNyRCxjQUFJclAsV0FBSixFQUFpQjtBQUNma1cseUJBQWF4SSxZQUFiLEVBQTJCMU4sV0FBM0I7QUFDRDtBQUNELGNBQUkrVyxhQUFhRixZQUFZbkosWUFBWixDQUFqQjtBQUNBLGNBQUksQ0FBQ3FKLFVBQUQsSUFBZXJKLGFBQWE5eUIsUUFBYixNQUEyQkEsWUFBWW1vQixpQkFBdkMsQ0FBbkIsRUFBOEU7QUFDNUU7QUFDQTtBQUNBdVQsd0NBQTRCNUksWUFBNUI7QUFDQXY5QixnQkFBSXEzQixxQkFBSixDQUEwQmtHLFlBQTFCO0FBQ0QsV0FMRCxNQUtPLElBQUlxSixVQUFKLEVBQWdCO0FBQ3JCO0FBQ0E1bUMsZ0JBQUlrM0IsYUFBSixDQUFrQnFHLFlBQWxCLEVBQWdDM0ssaUJBQWhDO0FBQ0Q7QUFDRixTQWREO0FBZUE7QUFDRDs7QUFFRDtBQUNBLFVBQUlub0IsYUFBYSxJQUFiLElBQXFCNUssVUFBVU0sSUFBVixDQUFlMm9CLEtBQWYsQ0FBcUIrYyxvQkFBckIsRUFBMkNod0IsUUFBM0MsQ0FBb0RwTCxRQUFwRCxDQUF6QixFQUF3RjtBQUN0RjB5Qix1QkFBZWpCLFNBQVM5N0IsU0FBVCxDQUFtQnM4QixlQUFuQixFQUFmO0FBQ0FhLHVCQUFldjlCLElBQUl3dkIsZ0JBQUosQ0FBcUIyTixZQUFyQixFQUFtQztBQUNoRDF5QixvQkFBVW83QjtBQURzQyxTQUFuQyxDQUFmOztBQUlBLFlBQUl0SSxZQUFKLEVBQWtCO0FBQ2hCckIsbUJBQVM5N0IsU0FBVCxDQUFtQjgrQix1QkFBbkIsQ0FBMkMsWUFBWTtBQUNyRDtBQUNBLGdCQUFJejBCLFFBQUosRUFBYztBQUNaOHlCLDZCQUFldjlCLElBQUlrM0IsYUFBSixDQUFrQnFHLFlBQWxCLEVBQWdDOXlCLFFBQWhDLENBQWY7QUFDRDtBQUNELGdCQUFJeWhCLFNBQUosRUFBZTtBQUNiNFosd0JBQVV2SSxZQUFWLEVBQXdCclIsU0FBeEIsRUFBbUMyRCxXQUFuQztBQUNEO0FBQ0YsV0FSRDtBQVNBO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJcU0sU0FBU244QixRQUFULENBQWtCc2tDLE9BQWxCLENBQTBCcGQsT0FBMUIsQ0FBSixFQUF3QztBQUN0Q3NmLHFCQUFhMTlCLEdBQWIsRUFBa0JvZSxPQUFsQixFQUEyQnhjLFlBQVltb0IsaUJBQXZDLEVBQTBEMUcsU0FBMUQ7QUFDQTtBQUNEOztBQUVEcVIscUJBQWUxMEIsSUFBSTNDLGFBQUosQ0FBa0J1RSxZQUFZbW9CLGlCQUE5QixDQUFmO0FBQ0EsVUFBSTFHLFNBQUosRUFBZTtBQUNicVIscUJBQWFyUixTQUFiLEdBQXlCQSxTQUF6QjtBQUNEO0FBQ0R1YSx5QkFBbUJ2SyxRQUFuQixFQUE2QnFCLFlBQTdCO0FBQ0QsS0ExRDhCOztBQTREL0JnSCxXQUFPLFNBQVNBLEtBQVQsQ0FBZXJJLFFBQWYsRUFBeUJqVixPQUF6QixFQUFrQ3hjLFFBQWxDLEVBQTRDeWhCLFNBQTVDLEVBQXVEMkQsV0FBdkQsRUFBb0U7QUFDekVwbEIsaUJBQVcsT0FBT0EsUUFBUCxLQUFvQixRQUFwQixHQUErQkEsU0FBUzhsQixXQUFULEVBQS9CLEdBQXdEOWxCLFFBQW5FO0FBQ0EsVUFBSTB5QixlQUFlakIsU0FBUzk3QixTQUFULENBQW1CczhCLGVBQW5CLEVBQW5CO0FBQ0EsYUFBTzE4QixJQUFJd3ZCLGdCQUFKLENBQXFCMk4sWUFBckIsRUFBbUM7QUFDeEMxeUIsa0JBQVVBLFFBRDhCO0FBRXhDeWhCLG1CQUFXQSxTQUY2QjtBQUd4QzJELHFCQUFhQTtBQUgyQixPQUFuQyxDQUFQO0FBS0QsS0FwRThCOztBQXNFL0JwTSxXQUFPLFNBQVNBLEtBQVQsR0FBaUI7QUFDdEIsYUFBT2loQixLQUFQO0FBQ0Q7QUF4RThCLEdBQWpDO0FBMEVELENBbE9hLEVBa09YN2tDLFNBbE9XLEUsQ0FrT0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlDZixDQUFDLFVBQVVBLFNBQVYsRUFBcUI7QUFDcEIsTUFBSTZrQyxLQUFKOzs7QUFFQTtBQUNBbUMsa0JBQWdCO0FBQ2QsY0FBVSxHQURJO0FBRWQsVUFBTSxHQUZRO0FBR2QsU0FBSyxRQUhTO0FBSWQsU0FBSztBQUpTLEdBSGhCO0FBQUEsTUFTSUMsY0FBYyxFQVRsQjs7QUFXQSxXQUFTQyxZQUFULENBQXNCMVYsT0FBdEIsRUFBK0I7QUFDN0IsUUFBSTJWLFFBQVFILGNBQWN4VixPQUFkLENBQVo7QUFDQSxXQUFPMlYsUUFBUSxDQUFDM1YsUUFBUW5NLFdBQVIsRUFBRCxFQUF3QjhoQixNQUFNOWhCLFdBQU4sRUFBeEIsQ0FBUixHQUF1RCxDQUFDbU0sUUFBUW5NLFdBQVIsRUFBRCxDQUE5RDtBQUNEOztBQUVELFdBQVMraEIsWUFBVCxDQUFzQjNrQyxLQUF0QixFQUE2QjtBQUMzQjZCLFdBQU8wM0IsRUFBRXY1QixNQUFNNkosWUFBTixDQUFtQnhELGFBQW5CLENBQWlDeEUsSUFBbkMsQ0FBUDtBQUNBMDNCLE1BQUVxTCxJQUFGLENBQU8vaUMsS0FBS2dqQyxRQUFMLENBQWMsTUFBZCxDQUFQLEVBQThCLFlBQVk7QUFDeENDLGdCQUFVdkwsRUFBRSxJQUFGLENBQVY7QUFDQXVMLGNBQVF6TCxXQUFSLENBQW9CLFdBQVd5TCxRQUFRL2tCLElBQVIsRUFBWCxHQUE0QixTQUFoRDtBQUNELEtBSEQ7O0FBS0F3WixNQUFFcUwsSUFBRixDQUFPL2lDLEtBQUtnakMsUUFBTCxDQUFjLE1BQWQsQ0FBUCxFQUE4QixZQUFZO0FBQ3hDRSxnQkFBVXhMLEVBQUUsSUFBRixDQUFWO0FBQ0F5TCx3QkFBa0JELE9BQWxCO0FBQ0QsS0FIRDtBQUlBRSxvQkFBZ0IxTCxFQUFFLGtCQUFGLEVBQXNCMkwsR0FBdEIsQ0FBMEIsSUFBMUIsRUFBZ0NDLE9BQWhDLEVBQWhCO0FBQ0EsV0FBT0YsY0FBY3RsQyxNQUFyQixFQUE2QjtBQUMzQnlsQywyQkFBcUJILGNBQWMzeEIsR0FBZCxFQUFyQjtBQUNBaW1CLFFBQUVxTCxJQUFGLENBQU9RLG1CQUFtQlAsUUFBbkIsRUFBUCxFQUFzQyxZQUFZO0FBQ2hEUSxpQkFBUzlMLEVBQUUsSUFBRixDQUFUO0FBQ0EsWUFBSThMLE9BQU9DLEVBQVAsQ0FBVSxNQUFWLENBQUosRUFBdUI7QUFDckJOLDRCQUFrQkssTUFBbEI7QUFDRCxTQUZELE1BRU87QUFDTEosd0JBQWMzaUMsSUFBZCxDQUFtQitpQyxNQUFuQjtBQUNEO0FBQ0YsT0FQRDtBQVFEO0FBQ0Q5TCxNQUFFcUwsSUFBRixDQUFPL2lDLEtBQUswakMsSUFBTCxDQUFVLE1BQVYsQ0FBUCxFQUEwQixZQUFZO0FBQ3BDNWhDLFdBQUs0MUIsRUFBRSxJQUFGLENBQUw7QUFDQSxVQUFJLENBQUNBLEVBQUV0UixJQUFGLENBQU90a0IsR0FBRzRVLElBQUgsRUFBUCxFQUFrQjVZLE1BQXZCLEVBQStCO0FBQzdCZ0UsV0FBRzZILE1BQUg7QUFDRDtBQUNGLEtBTEQ7QUFNQXhMLFVBQU02SixZQUFOLENBQW1CeEQsYUFBbkIsQ0FBaUNpVSxZQUFqQyxHQUFnRHdFLEtBQWhEO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFdBQVNrbUIsaUJBQVQsQ0FBMkJRLElBQTNCLEVBQWlDO0FBQy9CLFFBQUlBLEtBQUtYLFFBQUwsQ0FBYyxNQUFkLEVBQXNCbGxDLE1BQTFCLEVBQWtDO0FBQ2hDOGxDLG1CQUFhbE0sRUFBRXRSLElBQUYsQ0FBT3VkLEtBQUszZSxHQUFMLENBQVMsQ0FBVCxFQUFZK0MsU0FBbkIsQ0FBYjtBQUNBLFdBQUssSUFBSWxxQixJQUFJLENBQWIsRUFBZ0JBLElBQUk4bEMsS0FBS1gsUUFBTCxDQUFjLE1BQWQsRUFBc0JsbEMsTUFBMUMsRUFBa0RELEdBQWxELEVBQXVEO0FBQ3JEZ21DLHFCQUFhbk0sRUFBRWlNLEtBQUtYLFFBQUwsQ0FBYyxNQUFkLEVBQXNCbmxDLENBQXRCLENBQUYsQ0FBYjtBQUNBc2xDLDBCQUFrQlUsVUFBbEI7QUFDRDs7QUFFRDFrQyxjQUFRQyxHQUFSLENBQVl1a0MsS0FBS0csT0FBTCxDQUFhLE1BQWIsRUFBcUJobUMsTUFBakM7QUFDQWltQyxrQkFBWUosS0FBS3psQixJQUFMLEVBQVo7QUFDQSxVQUFJLENBQUMwbEIsV0FBVzlsQyxNQUFoQixFQUF3QjtBQUN0QjhsQyxxQkFBYSxxQkFBYjtBQUNEO0FBQ0RHLGtCQUFZQSxVQUFVcHRCLE9BQVYsQ0FBa0IsU0FBbEIsRUFBNkIsZUFBN0IsQ0FBWjtBQUNBb3RCLGtCQUFZQSxVQUFVcHRCLE9BQVYsQ0FBa0Isc0NBQWxCLEVBQTBELHlCQUF5Qml0QixVQUF6QixHQUFzQyxJQUFoRyxDQUFaO0FBQ0FHLGtCQUFZLGtCQUFrQkgsVUFBbEIsR0FBK0IsSUFBL0IsR0FBc0NHLFNBQXRDLEdBQWtELFNBQTlEO0FBQ0FKLFdBQUtuTSxXQUFMLENBQWlCdU0sU0FBakI7QUFDRCxLQWhCRCxNQWdCTztBQUNMO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTQyxXQUFULENBQXFCOVcsT0FBckIsRUFBOEJuRixTQUE5QixFQUF5QzJELFdBQXpDLEVBQXNEO0FBQ3BELFFBQUl1WSxhQUFhL1csVUFBVSxHQUFWLEdBQWdCbkYsU0FBakM7QUFDQSxRQUFJLENBQUM0YSxZQUFZc0IsVUFBWixDQUFMLEVBQThCO0FBQzVCdEIsa0JBQVlzQixVQUFaLElBQTBCLElBQUl2b0MsVUFBVU8sU0FBVixDQUFvQjhoQyxXQUF4QixDQUFvQzZFLGFBQWExVixPQUFiLENBQXBDLEVBQTJEbkYsU0FBM0QsRUFBc0UyRCxXQUF0RSxFQUFtRixJQUFuRixDQUExQjtBQUNEO0FBQ0QsV0FBT2lYLFlBQVlzQixVQUFaLENBQVA7QUFDRDs7QUFFRHZvQyxZQUFVRSxRQUFWLENBQW1CNmtDLFlBQW5CLEdBQWtDO0FBQ2hDcEgsVUFBTSxTQUFTQSxJQUFULENBQWN0QixRQUFkLEVBQXdCalYsT0FBeEIsRUFBaUNvSyxPQUFqQyxFQUEwQ25GLFNBQTFDLEVBQXFEMkQsV0FBckQsRUFBa0U7QUFDdEUsVUFBSXZ0QixRQUFRNDVCLFNBQVM5N0IsU0FBVCxDQUFtQjI5QixRQUFuQixFQUFaO0FBQ0EsVUFBSSxDQUFDejdCLEtBQUwsRUFBWTtBQUNWLGVBQU8sS0FBUDtBQUNEO0FBQ0Q2bEMsa0JBQVk5VyxPQUFaLEVBQXFCbkYsU0FBckIsRUFBZ0MyRCxXQUFoQyxFQUE2Q3NVLFdBQTdDLENBQXlEN2hDLEtBQXpEO0FBQ0E0NUIsZUFBUzk3QixTQUFULENBQW1CODlCLFlBQW5CLENBQWdDNTdCLEtBQWhDO0FBQ0Eya0MsbUJBQWEza0MsS0FBYjtBQUNELEtBVCtCOztBQVdoQ2lpQyxXQUFPLFNBQVNBLEtBQVQsQ0FBZXJJLFFBQWYsRUFBeUJqVixPQUF6QixFQUFrQ29LLE9BQWxDLEVBQTJDbkYsU0FBM0MsRUFBc0QyRCxXQUF0RCxFQUFtRTtBQUN4RSxVQUFJaG5CLE1BQU1xekIsU0FBU3J6QixHQUFuQjtBQUFBLFVBQ0l3L0IsZUFBZXhCLGNBQWN4VixPQUFkLEtBQTBCQSxPQUQ3QztBQUFBLFVBRUkvdUIsS0FGSjs7QUFJQTtBQUNBLFVBQUksQ0FBQ3pDLFVBQVVHLEdBQVYsQ0FBY2d4QixxQkFBZCxDQUFvQ25vQixHQUFwQyxFQUF5Q3dvQixPQUF6QyxDQUFELElBQXNELENBQUN4eEIsVUFBVUcsR0FBVixDQUFjZ3hCLHFCQUFkLENBQW9Dbm9CLEdBQXBDLEVBQXlDdy9CLFlBQXpDLENBQTNELEVBQW1IO0FBQ2pILGVBQU8sS0FBUDtBQUNEOztBQUVEO0FBQ0EsVUFBSW5jLGFBQWEsQ0FBQ3JzQixVQUFVRyxHQUFWLENBQWN1eEIsdUJBQWQsQ0FBc0Mxb0IsR0FBdEMsRUFBMkNxakIsU0FBM0MsQ0FBbEIsRUFBeUU7QUFDdkUsZUFBTyxLQUFQO0FBQ0Q7O0FBRUQ1cEIsY0FBUTQ1QixTQUFTOTdCLFNBQVQsQ0FBbUIyOUIsUUFBbkIsRUFBUjtBQUNBLFVBQUksQ0FBQ3o3QixLQUFMLEVBQVk7QUFDVixlQUFPLEtBQVA7QUFDRDs7QUFFRCxhQUFPNmxDLFlBQVk5VyxPQUFaLEVBQXFCbkYsU0FBckIsRUFBZ0MyRCxXQUFoQyxFQUE2Q29VLGdCQUE3QyxDQUE4RDNoQyxLQUE5RCxDQUFQO0FBQ0QsS0FoQytCOztBQWtDaENtaEIsV0FBTyxTQUFTQSxLQUFULEdBQWlCO0FBQ3RCLGFBQU9paEIsS0FBUDtBQUNEO0FBcEMrQixHQUFsQztBQXNDRCxDQXZIRCxFQXVIRzdrQyxTQXZISCxFQXVIYyxDQUFDLFVBQVVBLFNBQVYsRUFBcUI7QUFDbEMsTUFBSTZrQyxLQUFKOztBQUVBN2tDLFlBQVVFLFFBQVYsQ0FBbUJ1L0IsVUFBbkIsR0FBZ0M7QUFDOUI5QixVQUFNLFNBQVNBLElBQVQsQ0FBY3RCLFFBQWQsRUFBd0JqVixPQUF4QixFQUFpQzVFLElBQWpDLEVBQXVDO0FBQzNDLFVBQUk2WixTQUFTbjhCLFFBQVQsQ0FBa0Jza0MsT0FBbEIsQ0FBMEJwZCxPQUExQixDQUFKLEVBQXdDO0FBQ3RDaVYsaUJBQVNyekIsR0FBVCxDQUFhd2MsV0FBYixDQUF5QjRCLE9BQXpCLEVBQWtDLEtBQWxDLEVBQXlDNUUsSUFBekM7QUFDRCxPQUZELE1BRU87QUFDTDZaLGlCQUFTOTdCLFNBQVQsQ0FBbUJrL0IsVUFBbkIsQ0FBOEJqZCxJQUE5QjtBQUNEO0FBQ0YsS0FQNkI7O0FBUzlCa2lCLFdBQU8sU0FBU0EsS0FBVCxHQUFpQjtBQUN0QixhQUFPLEtBQVA7QUFDRCxLQVg2Qjs7QUFhOUI5Z0IsV0FBTyxTQUFTQSxLQUFULEdBQWlCO0FBQ3RCLGFBQU9paEIsS0FBUDtBQUNEO0FBZjZCLEdBQWhDO0FBaUJELENBcEJhLEVBb0JYN2tDLFNBcEJXLEVBb0JBLENBQUMsVUFBVUEsU0FBVixFQUFxQjtBQUNsQyxNQUFJaWxDLFlBQVksS0FBaEI7O0FBRUFqbEMsWUFBVUUsUUFBVixDQUFtQnVvQyxXQUFuQixHQUFpQztBQUMvQjs7Ozs7Ozs7OztBQVVBOUssVUFBTSxTQUFTQSxJQUFULENBQWN0QixRQUFkLEVBQXdCalYsT0FBeEIsRUFBaUN4RCxLQUFqQyxFQUF3QztBQUM1Q0EsY0FBUSxDQUFDLE9BQU9BLEtBQVAsS0FBaUIsV0FBakIsR0FBK0IsV0FBL0IsR0FBNkNsa0IsUUFBUWtrQixLQUFSLENBQTlDLE1BQWtFLFFBQWxFLEdBQTZFQSxLQUE3RSxHQUFxRixFQUFFaVMsS0FBS2pTLEtBQVAsRUFBN0Y7O0FBRUEsVUFBSTVhLE1BQU1xekIsU0FBU3J6QixHQUFuQjtBQUFBLFVBQ0kwL0IsUUFBUSxLQUFLaEUsS0FBTCxDQUFXckksUUFBWCxDQURaO0FBQUEsVUFFSS8xQixRQUZKO0FBQUEsVUFHSW5FLENBSEo7QUFBQSxVQUlJNkUsTUFKSjs7QUFNQSxVQUFJMGhDLEtBQUosRUFBVztBQUNUO0FBQ0FyTSxpQkFBUzk3QixTQUFULENBQW1CKzlCLFNBQW5CLENBQTZCb0ssS0FBN0I7QUFDQTFoQyxpQkFBUzBoQyxNQUFNemhDLFVBQWY7QUFDQUQsZUFBT2dKLFdBQVAsQ0FBbUIwNEIsS0FBbkI7O0FBRUE7QUFDQTFvQyxrQkFBVUcsR0FBVixDQUFjaTNCLG9CQUFkLENBQW1DcHdCLE1BQW5DO0FBQ0EsWUFBSUEsT0FBTzRELFFBQVAsS0FBb0IsR0FBcEIsSUFBMkIsQ0FBQzVELE9BQU9tRCxVQUF2QyxFQUFtRDtBQUNqRGt5QixtQkFBUzk3QixTQUFULENBQW1CZytCLFFBQW5CLENBQTRCdjNCLE1BQTVCO0FBQ0FBLGlCQUFPQyxVQUFQLENBQWtCK0ksV0FBbEIsQ0FBOEJoSixNQUE5QjtBQUNEOztBQUVEO0FBQ0FoSCxrQkFBVUksTUFBVixDQUFpQnc5QixNQUFqQixDQUF3QnZCLFNBQVMvWixPQUFqQztBQUNBO0FBQ0Q7O0FBRURvbUIsY0FBUTEvQixJQUFJM0MsYUFBSixDQUFrQjQrQixTQUFsQixDQUFSOztBQUVBLFdBQUs5aUMsQ0FBTCxJQUFVeWhCLEtBQVYsRUFBaUI7QUFDZjhrQixjQUFNdm1DLENBQU4sSUFBV3loQixNQUFNemhCLENBQU4sQ0FBWDtBQUNEOztBQUVEazZCLGVBQVM5N0IsU0FBVCxDQUFtQitTLFVBQW5CLENBQThCbzFCLEtBQTlCO0FBQ0EsVUFBSTFvQyxVQUFVd2tCLE9BQVYsQ0FBa0J1RSwrQkFBbEIsRUFBSixFQUF5RDtBQUN2RHppQixtQkFBVzBDLElBQUl6QyxjQUFKLENBQW1CdkcsVUFBVVMsZUFBN0IsQ0FBWDtBQUNBNDdCLGlCQUFTOTdCLFNBQVQsQ0FBbUIrUyxVQUFuQixDQUE4QmhOLFFBQTlCO0FBQ0ErMUIsaUJBQVM5N0IsU0FBVCxDQUFtQmcrQixRQUFuQixDQUE0Qmo0QixRQUE1QjtBQUNELE9BSkQsTUFJTztBQUNMKzFCLGlCQUFTOTdCLFNBQVQsQ0FBbUJnK0IsUUFBbkIsQ0FBNEJtSyxLQUE1QjtBQUNEO0FBQ0YsS0FwRDhCOztBQXNEL0JoRSxXQUFPLFNBQVNBLEtBQVQsQ0FBZXJJLFFBQWYsRUFBeUI7QUFDOUIsVUFBSXJ6QixNQUFNcXpCLFNBQVNyekIsR0FBbkI7QUFBQSxVQUNJczBCLFlBREo7QUFBQSxVQUVJdGlCLElBRko7QUFBQSxVQUdJMnRCLGlCQUhKOztBQUtBLFVBQUksQ0FBQzNvQyxVQUFVRyxHQUFWLENBQWNneEIscUJBQWQsQ0FBb0Nub0IsR0FBcEMsRUFBeUNpOEIsU0FBekMsQ0FBTCxFQUEwRDtBQUN4RCxlQUFPLEtBQVA7QUFDRDs7QUFFRDNILHFCQUFlakIsU0FBUzk3QixTQUFULENBQW1CczhCLGVBQW5CLEVBQWY7QUFDQSxVQUFJLENBQUNTLFlBQUwsRUFBbUI7QUFDakIsZUFBTyxLQUFQO0FBQ0Q7O0FBRUQsVUFBSUEsYUFBYTF5QixRQUFiLEtBQTBCcTZCLFNBQTlCLEVBQXlDO0FBQ3ZDO0FBQ0EsZUFBTzNILFlBQVA7QUFDRDs7QUFFRCxVQUFJQSxhQUFhcDJCLFFBQWIsS0FBMEJsSCxVQUFVVyxZQUF4QyxFQUFzRDtBQUNwRCxlQUFPLEtBQVA7QUFDRDs7QUFFRHFhLGFBQU9xaEIsU0FBUzk3QixTQUFULENBQW1CcWdDLE9BQW5CLEVBQVA7QUFDQTVsQixhQUFPaGIsVUFBVU0sSUFBVixDQUFla3FCLE1BQWYsQ0FBc0J4UCxJQUF0QixFQUE0QjBQLElBQTVCLEVBQVA7QUFDQSxVQUFJMVAsSUFBSixFQUFVO0FBQ1IsZUFBTyxLQUFQO0FBQ0Q7O0FBRUQydEIsMEJBQW9CdE0sU0FBUzk3QixTQUFULENBQW1Cc1YsUUFBbkIsQ0FBNEI3VixVQUFVVyxZQUF0QyxFQUFvRCxVQUFVaUcsSUFBVixFQUFnQjtBQUN0RixlQUFPQSxLQUFLZ0UsUUFBTCxLQUFrQixLQUF6QjtBQUNELE9BRm1CLENBQXBCOztBQUlBLFVBQUkrOUIsa0JBQWtCdm1DLE1BQWxCLEtBQTZCLENBQWpDLEVBQW9DO0FBQ2xDLGVBQU8sS0FBUDtBQUNEOztBQUVELGFBQU91bUMsa0JBQWtCLENBQWxCLENBQVA7QUFDRCxLQTdGOEI7O0FBK0YvQi9rQixXQUFPLFNBQVNBLEtBQVQsQ0FBZXlZLFFBQWYsRUFBeUI7QUFDOUIsVUFBSXFNLFFBQVEsS0FBS2hFLEtBQUwsQ0FBV3JJLFFBQVgsQ0FBWjtBQUNBLGFBQU9xTSxTQUFTQSxNQUFNN1MsR0FBdEI7QUFDRDtBQWxHOEIsR0FBakM7QUFvR0QsQ0F2R2EsRUF1R1g3MUIsU0F2R1csRUF1R0EsQ0FBQyxVQUFVQSxTQUFWLEVBQXFCO0FBQ2xDLE1BQUk2a0MsS0FBSjtBQUFBLE1BQ0krRCxhQUFhLFVBQVU1b0MsVUFBVXdrQixPQUFWLENBQWtCZ0Usd0JBQWxCLEtBQStDLEdBQS9DLEdBQXFELEVBQS9ELENBRGpCOztBQUdBeG9CLFlBQVVFLFFBQVYsQ0FBbUIyb0MsZUFBbkIsR0FBcUM7QUFDbkNsTCxVQUFNLFNBQVNBLElBQVQsQ0FBY3RCLFFBQWQsRUFBd0JqVixPQUF4QixFQUFpQztBQUNyQyxVQUFJaVYsU0FBU244QixRQUFULENBQWtCc2tDLE9BQWxCLENBQTBCcGQsT0FBMUIsQ0FBSixFQUF3QztBQUN0Q2lWLGlCQUFTcnpCLEdBQVQsQ0FBYXdjLFdBQWIsQ0FBeUI0QixPQUF6QixFQUFrQyxLQUFsQyxFQUF5QyxJQUF6QztBQUNBLFlBQUksQ0FBQ3BuQixVQUFVd2tCLE9BQVYsQ0FBa0J5RCxrQkFBbEIsRUFBTCxFQUE2QztBQUMzQ29VLG1CQUFTOTdCLFNBQVQsQ0FBbUJvL0IsY0FBbkI7QUFDRDtBQUNGLE9BTEQsTUFLTztBQUNMdEQsaUJBQVNuOEIsUUFBVCxDQUFrQnk5QixJQUFsQixDQUF1QixZQUF2QixFQUFxQ2lMLFVBQXJDO0FBQ0Q7QUFDRixLQVZrQzs7QUFZbkNsRSxXQUFPLFNBQVNBLEtBQVQsR0FBaUI7QUFDdEIsYUFBTyxLQUFQO0FBQ0QsS0Fka0M7O0FBZ0JuQzlnQixXQUFPLFNBQVNBLEtBQVQsR0FBaUI7QUFDdEIsYUFBT2loQixLQUFQO0FBQ0Q7QUFsQmtDLEdBQXJDO0FBb0JELENBeEJhLEVBd0JYN2tDLFNBeEJXLEVBd0JBLENBQUMsVUFBVUEsU0FBVixFQUFxQjtBQUNsQyxNQUFJNmtDLEtBQUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTdrQyxZQUFVRSxRQUFWLENBQW1CNDZCLEtBQW5CLEdBQTJCO0FBQ3pCNkMsVUFBTSxTQUFTQSxJQUFULENBQWN0QixRQUFkLEVBQXdCalYsT0FBeEIsRUFBaUM7QUFDckNpVixlQUFTcnpCLEdBQVQsQ0FBYXdjLFdBQWIsQ0FBeUIsY0FBekI7QUFDQTZRLGdCQUFVLHVCQUFWO0FBQ0FyMkIsZ0JBQVVFLFFBQVYsQ0FBbUI2a0MsWUFBbkIsQ0FBZ0NwSCxJQUFoQyxDQUFxQ3RCLFFBQXJDLEVBQStDalYsT0FBL0MsRUFBd0QsTUFBeEQsRUFBZ0UsRUFBaEUsRUFBb0VpUCxPQUFwRTtBQUNEO0FBTHdCLEdBQTNCO0FBT0FyMkIsWUFBVUUsUUFBVixDQUFtQjRvQyxpQkFBbkIsR0FBdUM7QUFDckNuTCxVQUFNLFNBQVNBLElBQVQsQ0FBY3RCLFFBQWQsRUFBd0JqVixPQUF4QixFQUFpQztBQUNyQyxVQUFJcGUsTUFBTXF6QixTQUFTcnpCLEdBQW5CO0FBQUEsVUFDSXMwQixlQUFlakIsU0FBUzk3QixTQUFULENBQW1CczhCLGVBQW5CLEVBRG5CO0FBQUEsVUFFSWhRLE9BQU83c0IsVUFBVUcsR0FBVixDQUFjd3ZCLGdCQUFkLENBQStCMk4sWUFBL0IsRUFBNkMsRUFBRTF5QixVQUFVLElBQVosRUFBN0MsQ0FGWDtBQUFBLFVBR0ltK0IsWUFBWS9vQyxVQUFVRyxHQUFWLENBQWN3dkIsZ0JBQWQsQ0FBK0IyTixZQUEvQixFQUE2QyxFQUFFMXlCLFVBQVUsSUFBWixFQUE3QyxDQUhoQjtBQUFBLFVBSUlvK0IsZ0JBQWdCLHFCQUFxQixJQUFJekQsSUFBSixHQUFXMEQsT0FBWCxFQUp6QztBQUFBLFVBS0lsTyxPQUxKO0FBQUEsVUFNSS9PLFdBTko7O0FBUUEsVUFBSXFRLFNBQVNuOEIsUUFBVCxDQUFrQnNrQyxPQUFsQixDQUEwQnBkLE9BQTFCLENBQUosRUFBd0M7QUFDdENwZSxZQUFJd2MsV0FBSixDQUFnQjRCLE9BQWhCLEVBQXlCLEtBQXpCLEVBQWdDLElBQWhDO0FBQ0E7QUFDRDs7QUFFRCxVQUFJeUYsSUFBSixFQUFVO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQXdQLGlCQUFTOTdCLFNBQVQsQ0FBbUI4K0IsdUJBQW5CLENBQTJDLFlBQVk7QUFDckRyL0Isb0JBQVVHLEdBQVYsQ0FBY3kzQixXQUFkLENBQTBCL0ssSUFBMUI7QUFDRCxTQUZEO0FBR0QsT0FSRCxNQVFPLElBQUlrYyxTQUFKLEVBQWU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTFNLGlCQUFTOTdCLFNBQVQsQ0FBbUI4K0IsdUJBQW5CLENBQTJDLFlBQVk7QUFDckRyL0Isb0JBQVVHLEdBQVYsQ0FBY2szQixhQUFkLENBQTRCMFIsU0FBNUIsRUFBdUMsSUFBdkM7QUFDRCxTQUZEO0FBR0QsT0FSTSxNQVFBO0FBQ0w7QUFDQTFNLGlCQUFTbjhCLFFBQVQsQ0FBa0J5OUIsSUFBbEIsQ0FBdUIsYUFBdkIsRUFBc0MsS0FBdEMsRUFBNkNxTCxhQUE3QztBQUNBaGQsc0JBQWNoakIsSUFBSTRjLGFBQUosQ0FBa0IsTUFBTW9qQixhQUF4QixDQUFkO0FBQ0FqTyxrQkFBVS9PLFlBQVk3WixTQUFaLEtBQTBCLEVBQTFCLElBQWdDNlosWUFBWTdaLFNBQVosS0FBMEJuUyxVQUFVUyxlQUE5RTtBQUNBNDdCLGlCQUFTOTdCLFNBQVQsQ0FBbUI4K0IsdUJBQW5CLENBQTJDLFlBQVk7QUFDckR4UyxpQkFBTzdzQixVQUFVRyxHQUFWLENBQWN3c0IsYUFBZCxDQUE0QlgsV0FBNUIsRUFBeUMsSUFBekMsQ0FBUDtBQUNELFNBRkQ7QUFHQSxZQUFJK08sT0FBSixFQUFhO0FBQ1hzQixtQkFBUzk3QixTQUFULENBQW1CMlQsVUFBbkIsQ0FBOEIyWSxLQUFLakgsYUFBTCxDQUFtQixJQUFuQixDQUE5QjtBQUNEO0FBQ0Y7QUFDRixLQTNDb0M7O0FBNkNyQzhlLFdBQU8sU0FBU0EsS0FBVCxDQUFlckksUUFBZixFQUF5QjtBQUM5QixVQUFJaUIsZUFBZWpCLFNBQVM5N0IsU0FBVCxDQUFtQnM4QixlQUFuQixFQUFuQjtBQUNBLGFBQU83OEIsVUFBVUcsR0FBVixDQUFjd3ZCLGdCQUFkLENBQStCMk4sWUFBL0IsRUFBNkMsRUFBRTF5QixVQUFVLElBQVosRUFBN0MsQ0FBUDtBQUNELEtBaERvQzs7QUFrRHJDZ1osV0FBTyxTQUFTQSxLQUFULEdBQWlCO0FBQ3RCLGFBQU9paEIsS0FBUDtBQUNEO0FBcERvQyxHQUF2QztBQXNERCxDQXZGYSxFQXVGWDdrQyxTQXZGVyxFQXVGQSxDQUFDLFVBQVVBLFNBQVYsRUFBcUI7QUFDbEMsTUFBSTZrQyxLQUFKOztBQUVBN2tDLFlBQVVFLFFBQVYsQ0FBbUJncEMsbUJBQW5CLEdBQXlDO0FBQ3ZDdkwsVUFBTSxTQUFTQSxJQUFULENBQWN0QixRQUFkLEVBQXdCalYsT0FBeEIsRUFBaUM7QUFDckMsVUFBSXBlLE1BQU1xekIsU0FBU3J6QixHQUFuQjtBQUFBLFVBQ0lzMEIsZUFBZWpCLFNBQVM5N0IsU0FBVCxDQUFtQnM4QixlQUFuQixFQURuQjtBQUFBLFVBRUloUSxPQUFPN3NCLFVBQVVHLEdBQVYsQ0FBY3d2QixnQkFBZCxDQUErQjJOLFlBQS9CLEVBQTZDLEVBQUUxeUIsVUFBVSxJQUFaLEVBQTdDLENBRlg7QUFBQSxVQUdJbStCLFlBQVkvb0MsVUFBVUcsR0FBVixDQUFjd3ZCLGdCQUFkLENBQStCMk4sWUFBL0IsRUFBNkMsRUFBRTF5QixVQUFVLElBQVosRUFBN0MsQ0FIaEI7QUFBQSxVQUlJbytCLGdCQUFnQixxQkFBcUIsSUFBSXpELElBQUosR0FBVzBELE9BQVgsRUFKekM7QUFBQSxVQUtJbE8sT0FMSjtBQUFBLFVBTUkvTyxXQU5KOztBQVFBLFVBQUlxUSxTQUFTbjhCLFFBQVQsQ0FBa0Jza0MsT0FBbEIsQ0FBMEJwZCxPQUExQixDQUFKLEVBQXdDO0FBQ3RDcGUsWUFBSXdjLFdBQUosQ0FBZ0I0QixPQUFoQixFQUF5QixLQUF6QixFQUFnQyxJQUFoQztBQUNBO0FBQ0Q7O0FBRUQsVUFBSXlGLElBQUosRUFBVTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0F3UCxpQkFBUzk3QixTQUFULENBQW1COCtCLHVCQUFuQixDQUEyQyxZQUFZO0FBQ3JEci9CLG9CQUFVRyxHQUFWLENBQWN5M0IsV0FBZCxDQUEwQi9LLElBQTFCO0FBQ0QsU0FGRDtBQUdELE9BUkQsTUFRTyxJQUFJa2MsU0FBSixFQUFlO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0ExTSxpQkFBUzk3QixTQUFULENBQW1COCtCLHVCQUFuQixDQUEyQyxZQUFZO0FBQ3JEci9CLG9CQUFVRyxHQUFWLENBQWNrM0IsYUFBZCxDQUE0QjBSLFNBQTVCLEVBQXVDLElBQXZDO0FBQ0QsU0FGRDtBQUdELE9BUk0sTUFRQTtBQUNMO0FBQ0ExTSxpQkFBU244QixRQUFULENBQWtCeTlCLElBQWxCLENBQXVCLGFBQXZCLEVBQXNDLEtBQXRDLEVBQTZDcUwsYUFBN0M7QUFDQWhkLHNCQUFjaGpCLElBQUk0YyxhQUFKLENBQWtCLE1BQU1vakIsYUFBeEIsQ0FBZDtBQUNBak8sa0JBQVUvTyxZQUFZN1osU0FBWixLQUEwQixFQUExQixJQUFnQzZaLFlBQVk3WixTQUFaLEtBQTBCblMsVUFBVVMsZUFBOUU7QUFDQTQ3QixpQkFBUzk3QixTQUFULENBQW1COCtCLHVCQUFuQixDQUEyQyxZQUFZO0FBQ3JEeFMsaUJBQU83c0IsVUFBVUcsR0FBVixDQUFjd3NCLGFBQWQsQ0FBNEJYLFdBQTVCLEVBQXlDLElBQXpDLENBQVA7QUFDRCxTQUZEO0FBR0EsWUFBSStPLE9BQUosRUFBYTtBQUNYc0IsbUJBQVM5N0IsU0FBVCxDQUFtQjJULFVBQW5CLENBQThCMlksS0FBS2pILGFBQUwsQ0FBbUIsSUFBbkIsQ0FBOUI7QUFDRDtBQUNGO0FBQ0YsS0EzQ3NDOztBQTZDdkM4ZSxXQUFPLFNBQVNBLEtBQVQsQ0FBZXJJLFFBQWYsRUFBeUI7QUFDOUIsVUFBSWlCLGVBQWVqQixTQUFTOTdCLFNBQVQsQ0FBbUJzOEIsZUFBbkIsRUFBbkI7QUFDQSxhQUFPNzhCLFVBQVVHLEdBQVYsQ0FBY3d2QixnQkFBZCxDQUErQjJOLFlBQS9CLEVBQTZDLEVBQUUxeUIsVUFBVSxJQUFaLEVBQTdDLENBQVA7QUFDRCxLQWhEc0M7O0FBa0R2Q2daLFdBQU8sU0FBU0EsS0FBVCxHQUFpQjtBQUN0QixhQUFPaWhCLEtBQVA7QUFDRDtBQXBEc0MsR0FBekM7QUFzREQsQ0F6RGEsRUF5RFg3a0MsU0F6RFcsRUF5REEsQ0FBQyxVQUFVQSxTQUFWLEVBQXFCO0FBQ2xDLE1BQUk2a0MsS0FBSjs7QUFFQTdrQyxZQUFVRSxRQUFWLENBQW1CaXBDLE1BQW5CLEdBQTRCO0FBQzFCeEwsVUFBTSxTQUFTQSxJQUFULENBQWN0QixRQUFkLEVBQXdCalYsT0FBeEIsRUFBaUM7QUFDckMsYUFBT3BuQixVQUFVRSxRQUFWLENBQW1CNmtDLFlBQW5CLENBQWdDcEgsSUFBaEMsQ0FBcUN0QixRQUFyQyxFQUErQ2pWLE9BQS9DLEVBQXdELEdBQXhELENBQVA7QUFDRCxLQUh5Qjs7QUFLMUJzZCxXQUFPLFNBQVNBLEtBQVQsQ0FBZXJJLFFBQWYsRUFBeUJqVixPQUF6QixFQUFrQzRkLEtBQWxDLEVBQXlDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFPaGxDLFVBQVVFLFFBQVYsQ0FBbUI2a0MsWUFBbkIsQ0FBZ0NMLEtBQWhDLENBQXNDckksUUFBdEMsRUFBZ0RqVixPQUFoRCxFQUF5RCxHQUF6RCxDQUFQO0FBQ0QsS0FaeUI7O0FBYzFCeEQsV0FBTyxTQUFTQSxLQUFULEdBQWlCO0FBQ3RCLGFBQU9paEIsS0FBUDtBQUNEO0FBaEJ5QixHQUE1QjtBQWtCRCxDQXJCYSxFQXFCWDdrQyxTQXJCVyxFQXFCQSxDQUFDLFVBQVVBLFNBQVYsRUFBcUI7QUFDbEMsTUFBSTZrQyxLQUFKO0FBQUEsTUFDSWxLLGFBQWEsMkJBRGpCO0FBQUEsTUFFSXRFLFVBQVUsNEJBRmQ7O0FBSUFyMkIsWUFBVUUsUUFBVixDQUFtQmtwQyxhQUFuQixHQUFtQztBQUNqQ3pMLFVBQU0sU0FBU0EsSUFBVCxDQUFjdEIsUUFBZCxFQUF3QmpWLE9BQXhCLEVBQWlDO0FBQ3JDLGFBQU9wbkIsVUFBVUUsUUFBVixDQUFtQjRtQyxXQUFuQixDQUErQm5KLElBQS9CLENBQW9DdEIsUUFBcEMsRUFBOEMsYUFBOUMsRUFBNkQsSUFBN0QsRUFBbUUxQixVQUFuRSxFQUErRXRFLE9BQS9FLENBQVA7QUFDRCxLQUhnQzs7QUFLakNxTyxXQUFPLFNBQVNBLEtBQVQsQ0FBZXJJLFFBQWYsRUFBeUJqVixPQUF6QixFQUFrQztBQUN2QyxhQUFPcG5CLFVBQVVFLFFBQVYsQ0FBbUI0bUMsV0FBbkIsQ0FBK0JwQyxLQUEvQixDQUFxQ3JJLFFBQXJDLEVBQStDLGFBQS9DLEVBQThELElBQTlELEVBQW9FMUIsVUFBcEUsRUFBZ0Z0RSxPQUFoRixDQUFQO0FBQ0QsS0FQZ0M7O0FBU2pDelMsV0FBTyxTQUFTQSxLQUFULEdBQWlCO0FBQ3RCLGFBQU9paEIsS0FBUDtBQUNEO0FBWGdDLEdBQW5DO0FBYUQsQ0FsQmEsRUFrQlg3a0MsU0FsQlcsRUFrQkEsQ0FBQyxVQUFVQSxTQUFWLEVBQXFCO0FBQ2xDLE1BQUk2a0MsS0FBSjtBQUFBLE1BQ0lsSyxhQUFhLHlCQURqQjtBQUFBLE1BRUl0RSxVQUFVLDRCQUZkOztBQUlBcjJCLFlBQVVFLFFBQVYsQ0FBbUJtcEMsV0FBbkIsR0FBaUM7QUFDL0IxTCxVQUFNLFNBQVNBLElBQVQsQ0FBY3RCLFFBQWQsRUFBd0JqVixPQUF4QixFQUFpQztBQUNyQyxhQUFPcG5CLFVBQVVFLFFBQVYsQ0FBbUI0bUMsV0FBbkIsQ0FBK0JuSixJQUEvQixDQUFvQ3RCLFFBQXBDLEVBQThDLGFBQTlDLEVBQTZELElBQTdELEVBQW1FMUIsVUFBbkUsRUFBK0V0RSxPQUEvRSxDQUFQO0FBQ0QsS0FIOEI7O0FBSy9CcU8sV0FBTyxTQUFTQSxLQUFULENBQWVySSxRQUFmLEVBQXlCalYsT0FBekIsRUFBa0M7QUFDdkMsYUFBT3BuQixVQUFVRSxRQUFWLENBQW1CNG1DLFdBQW5CLENBQStCcEMsS0FBL0IsQ0FBcUNySSxRQUFyQyxFQUErQyxhQUEvQyxFQUE4RCxJQUE5RCxFQUFvRTFCLFVBQXBFLEVBQWdGdEUsT0FBaEYsQ0FBUDtBQUNELEtBUDhCOztBQVMvQnpTLFdBQU8sU0FBU0EsS0FBVCxHQUFpQjtBQUN0QixhQUFPaWhCLEtBQVA7QUFDRDtBQVg4QixHQUFqQztBQWFELENBbEJhLEVBa0JYN2tDLFNBbEJXLEVBa0JBLENBQUMsVUFBVUEsU0FBVixFQUFxQjtBQUNsQyxNQUFJNmtDLEtBQUo7QUFBQSxNQUNJbEssYUFBYSwwQkFEakI7QUFBQSxNQUVJdEUsVUFBVSw0QkFGZDs7QUFJQXIyQixZQUFVRSxRQUFWLENBQW1Cb3BDLFlBQW5CLEdBQWtDO0FBQ2hDM0wsVUFBTSxTQUFTQSxJQUFULENBQWN0QixRQUFkLEVBQXdCalYsT0FBeEIsRUFBaUM7QUFDckMsYUFBT3BuQixVQUFVRSxRQUFWLENBQW1CNG1DLFdBQW5CLENBQStCbkosSUFBL0IsQ0FBb0N0QixRQUFwQyxFQUE4QyxhQUE5QyxFQUE2RCxJQUE3RCxFQUFtRTFCLFVBQW5FLEVBQStFdEUsT0FBL0UsQ0FBUDtBQUNELEtBSCtCOztBQUtoQ3FPLFdBQU8sU0FBU0EsS0FBVCxDQUFlckksUUFBZixFQUF5QmpWLE9BQXpCLEVBQWtDO0FBQ3ZDLGFBQU9wbkIsVUFBVUUsUUFBVixDQUFtQjRtQyxXQUFuQixDQUErQnBDLEtBQS9CLENBQXFDckksUUFBckMsRUFBK0MsYUFBL0MsRUFBOEQsSUFBOUQsRUFBb0UxQixVQUFwRSxFQUFnRnRFLE9BQWhGLENBQVA7QUFDRCxLQVArQjs7QUFTaEN6UyxXQUFPLFNBQVNBLEtBQVQsR0FBaUI7QUFDdEIsYUFBT2loQixLQUFQO0FBQ0Q7QUFYK0IsR0FBbEM7QUFhRCxDQWxCYSxFQWtCWDdrQyxTQWxCVyxFQWtCQSxDQUFDLFVBQVVBLFNBQVYsRUFBcUI7QUFDbEMsTUFBSTZrQyxLQUFKO0FBQ0E3a0MsWUFBVUUsUUFBVixDQUFtQnFwQyxTQUFuQixHQUErQjtBQUM3QjVMLFVBQU0sU0FBU0EsSUFBVCxDQUFjdEIsUUFBZCxFQUF3QmpWLE9BQXhCLEVBQWlDO0FBQ3JDLGFBQU9wbkIsVUFBVUUsUUFBVixDQUFtQjZrQyxZQUFuQixDQUFnQ3BILElBQWhDLENBQXFDdEIsUUFBckMsRUFBK0NqVixPQUEvQyxFQUF3RCxHQUF4RCxDQUFQO0FBQ0QsS0FINEI7O0FBSzdCc2QsV0FBTyxTQUFTQSxLQUFULENBQWVySSxRQUFmLEVBQXlCalYsT0FBekIsRUFBa0M7QUFDdkMsYUFBT3BuQixVQUFVRSxRQUFWLENBQW1CNmtDLFlBQW5CLENBQWdDTCxLQUFoQyxDQUFzQ3JJLFFBQXRDLEVBQWdEalYsT0FBaEQsRUFBeUQsR0FBekQsQ0FBUDtBQUNELEtBUDRCOztBQVM3QnhELFdBQU8sU0FBU0EsS0FBVCxHQUFpQjtBQUN0QixhQUFPaWhCLEtBQVA7QUFDRDtBQVg0QixHQUEvQjtBQWFELENBZmEsRUFlWDdrQyxTQWZXLEUsQ0FlQzs7OztBQUlmLENBQUMsVUFBVUEsU0FBVixFQUFxQjtBQUNwQixNQUFJd3BDLFFBQVEsRUFBWjtBQUFBLE1BQ0lDLFFBQVEsRUFEWjtBQUFBLE1BRUk1b0MsZ0JBQWdCLENBRnBCO0FBQUEsTUFHSUksYUFBYSxFQUhqQjtBQUFBLE1BSUl5b0Msc0JBQXNCLEVBSjFCO0FBQUEsTUFLSUMsWUFBWSx3REFBd0QzcEMsVUFBVVMsZUFBbEUsR0FBb0YsU0FMcEc7QUFBQSxNQU1JbXBDLFlBQVksd0RBQXdENXBDLFVBQVVTLGVBQWxFLEdBQW9GLFNBTnBHO0FBQUEsTUFPSU4sTUFBTUgsVUFBVUcsR0FQcEI7O0FBU0EsV0FBUzBwQyxpQkFBVCxDQUEyQjdnQyxHQUEzQixFQUFnQztBQUM5QixRQUFJZ2pCLFdBQUo7QUFDQSxXQUFPQSxjQUFjaGpCLElBQUk0YyxhQUFKLENBQWtCLGtCQUFsQixDQUFyQixFQUE0RDtBQUMxRG9HLGtCQUFZL2tCLFVBQVosQ0FBdUIrSSxXQUF2QixDQUFtQ2djLFdBQW5DO0FBQ0Q7QUFDRjs7QUFFRGhzQixZQUFVOHBDLFdBQVYsR0FBd0I5cEMsVUFBVU0sSUFBVixDQUFla3BCLFVBQWYsQ0FBMEI1bEIsTUFBMUI7QUFDeEIsK0NBQTZDO0FBQzNDOUQsaUJBQWEsU0FBU0EsV0FBVCxDQUFxQjA2QixNQUFyQixFQUE2QjtBQUN4QyxXQUFLQSxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxXQUFLNkIsUUFBTCxHQUFnQjdCLE9BQU82QixRQUF2QjtBQUNBLFdBQUsvWixPQUFMLEdBQWUsS0FBSytaLFFBQUwsQ0FBYy9aLE9BQTdCO0FBQ0EsV0FBS3luQixPQUFMLEdBQWUsQ0FBQyxLQUFLMU4sUUFBTCxDQUFjMk4sUUFBZCxFQUFELENBQWY7QUFDQSxXQUFLQyxRQUFMLEdBQWdCLENBQWhCOztBQUVBO0FBQ0EsVUFBSSxLQUFLNU4sUUFBTCxDQUFjbjhCLFFBQWQsQ0FBdUJza0MsT0FBdkIsQ0FBK0IsWUFBL0IsQ0FBSixFQUFrRDtBQUNoRCxhQUFLMEYsUUFBTDtBQUNEO0FBQ0YsS0FaMEM7O0FBYzNDQSxjQUFVLFNBQVNBLFFBQVQsR0FBb0I7QUFDNUIsVUFBSXRSLE9BQU8sSUFBWDtBQUFBLFVBQ0k1dkIsTUFBTSxLQUFLcXpCLFFBQUwsQ0FBYzhOLE9BQWQsQ0FBc0J0aEMsV0FBdEIsRUFEVjtBQUFBLFVBRUl1aEMsT0FGSjs7QUFJQTtBQUNBanFDLFVBQUlzcEIsT0FBSixDQUFZLEtBQUtuSCxPQUFqQixFQUEwQixTQUExQixFQUFxQyxVQUFVNk0sS0FBVixFQUFpQjtBQUNwRCxZQUFJQSxNQUFNa2IsTUFBTixJQUFnQixDQUFDbGIsTUFBTW1iLE9BQVAsSUFBa0IsQ0FBQ25iLE1BQU1vYixPQUE3QyxFQUFzRDtBQUNwRDtBQUNEOztBQUVELFlBQUkzTixVQUFVek4sTUFBTXlOLE9BQXBCO0FBQUEsWUFDSTROLFNBQVM1TixZQUFZNE0sS0FBWixJQUFxQixDQUFDcmEsTUFBTXNPLFFBRHpDO0FBQUEsWUFFSWdOLFNBQVM3TixZQUFZNE0sS0FBWixJQUFxQnJhLE1BQU1zTyxRQUEzQixJQUF1Q2IsWUFBWTZNLEtBRmhFOztBQUlBLFlBQUllLE1BQUosRUFBWTtBQUNWNVIsZUFBSzhSLElBQUw7QUFDQXZiLGdCQUFNbUQsY0FBTjtBQUNELFNBSEQsTUFHTyxJQUFJbVksTUFBSixFQUFZO0FBQ2pCN1IsZUFBSytSLElBQUw7QUFDQXhiLGdCQUFNbUQsY0FBTjtBQUNEO0FBQ0YsT0FoQkQ7O0FBa0JBO0FBQ0FueUIsVUFBSXNwQixPQUFKLENBQVksS0FBS25ILE9BQWpCLEVBQTBCLFNBQTFCLEVBQXFDLFVBQVU2TSxLQUFWLEVBQWlCO0FBQ3BELFlBQUl5TixVQUFVek4sTUFBTXlOLE9BQXBCO0FBQ0EsWUFBSUEsWUFBWXdOLE9BQWhCLEVBQXlCO0FBQ3ZCO0FBQ0Q7O0FBRURBLGtCQUFVeE4sT0FBVjs7QUFFQSxZQUFJQSxZQUFZLzdCLGFBQVosSUFBNkIrN0IsWUFBWTM3QixVQUE3QyxFQUF5RDtBQUN2RDIzQixlQUFLZ1MsUUFBTDtBQUNEO0FBQ0YsT0FYRDs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUk1cUMsVUFBVXdrQixPQUFWLENBQWtCd0Usb0JBQWxCLEVBQUosRUFBOEM7QUFDNUMsWUFBSTZoQixRQUFKO0FBQUEsWUFDSUMsUUFESjtBQUFBLFlBRUl4WCxVQUFVLFNBQVNBLE9BQVQsR0FBbUI7QUFDL0J1Vyw0QkFBa0I3Z0MsR0FBbEI7QUFDQStoQyx3QkFBY0YsUUFBZDtBQUNELFNBTEQ7O0FBT0ExcUMsWUFBSXNwQixPQUFKLENBQVksS0FBS25ILE9BQWpCLEVBQTBCLGFBQTFCLEVBQXlDLFlBQVk7QUFDbkRnUjtBQUNBc0YsZUFBS3lELFFBQUwsQ0FBYzk3QixTQUFkLENBQXdCOCtCLHVCQUF4QixDQUFnRCxZQUFZO0FBQzFELGdCQUFJekcsS0FBS3RXLE9BQUwsQ0FBYXJPLFNBQWpCLEVBQTRCO0FBQzFCMmtCLG1CQUFLeUQsUUFBTCxDQUFjOTdCLFNBQWQsQ0FBd0JnK0IsUUFBeEIsQ0FBaUMzRixLQUFLdFcsT0FBTCxDQUFhck8sU0FBOUM7QUFDRDs7QUFFRDtBQUNBakwsZ0JBQUl3YyxXQUFKLENBQWdCLFlBQWhCLEVBQThCLEtBQTlCLEVBQXFDbWtCLFNBQXJDO0FBQ0E7QUFDQTNnQyxnQkFBSXdjLFdBQUosQ0FBZ0IsWUFBaEIsRUFBOEIsS0FBOUIsRUFBcUNva0IsU0FBckM7QUFDQTVnQyxnQkFBSXdjLFdBQUosQ0FBZ0IsTUFBaEIsRUFBd0IsS0FBeEIsRUFBK0IsSUFBL0I7QUFDRCxXQVZEOztBQVlBcWxCLHFCQUFXRyxZQUFZLFlBQVk7QUFDakMsZ0JBQUloaUMsSUFBSXd2QixjQUFKLENBQW1CLGlCQUFuQixDQUFKLEVBQTJDO0FBQ3pDbEY7QUFDQXNGLG1CQUFLK1IsSUFBTDtBQUNEO0FBQ0YsV0FMVSxFQUtSLEdBTFEsQ0FBWDs7QUFPQSxjQUFJLENBQUNHLFFBQUwsRUFBZTtBQUNiQSx1QkFBVyxJQUFYO0FBQ0EzcUMsZ0JBQUlzcEIsT0FBSixDQUFZdGxCLFFBQVosRUFBc0IsV0FBdEIsRUFBbUNtdkIsT0FBbkM7QUFDQW56QixnQkFBSXNwQixPQUFKLENBQVl6Z0IsR0FBWixFQUFpQixDQUFDLFdBQUQsRUFBYyxPQUFkLEVBQXVCLEtBQXZCLEVBQThCLE1BQTlCLENBQWpCLEVBQXdEc3FCLE9BQXhEO0FBQ0Q7QUFDRixTQTFCRDtBQTJCRDs7QUFFRCxXQUFLa0gsTUFBTCxDQUFZL1EsT0FBWixDQUFvQixrQkFBcEIsRUFBd0MsWUFBWTtBQUNsRG1QLGFBQUtnUyxRQUFMO0FBQ0QsT0FGRCxFQUVHbmhCLE9BRkgsQ0FFVyx3QkFGWCxFQUVxQyxZQUFZO0FBQy9DbVAsYUFBS2dTLFFBQUw7QUFDRCxPQUpEO0FBS0QsS0FyRzBDOztBQXVHM0NBLGNBQVUsU0FBU0EsUUFBVCxHQUFvQjtBQUM1QixVQUFJSyxlQUFlLEtBQUtsQixPQUFMLENBQWEsS0FBS0UsUUFBTCxHQUFnQixDQUE3QixDQUFuQjtBQUFBLFVBQ0lpQixjQUFjLEtBQUs3TyxRQUFMLENBQWMyTixRQUFkLEVBRGxCOztBQUdBLFVBQUlrQixlQUFlRCxZQUFuQixFQUFpQztBQUMvQjtBQUNEOztBQUVELFVBQUk3b0MsU0FBUyxLQUFLMm5DLE9BQUwsQ0FBYTNuQyxNQUFiLEdBQXNCLEtBQUs2bkMsUUFBeEM7QUFDQSxVQUFJN25DLFNBQVNzbkMsbUJBQWIsRUFBa0M7QUFDaEMsYUFBS0ssT0FBTCxDQUFhb0IsS0FBYjtBQUNBLGFBQUtsQixRQUFMO0FBQ0Q7O0FBRUQsV0FBS0EsUUFBTDtBQUNBLFdBQUtGLE9BQUwsQ0FBYWhsQyxJQUFiLENBQWtCbW1DLFdBQWxCO0FBQ0QsS0F2SDBDOztBQXlIM0NSLFVBQU0sU0FBU0EsSUFBVCxHQUFnQjtBQUNwQixXQUFLRSxRQUFMOztBQUVBLFVBQUksS0FBS1gsUUFBTCxJQUFpQixDQUFyQixFQUF3QjtBQUN0QjtBQUNEOztBQUVELFdBQUsvUCxHQUFMLENBQVMsS0FBSzZQLE9BQUwsQ0FBYSxFQUFFLEtBQUtFLFFBQVAsR0FBa0IsQ0FBL0IsQ0FBVDtBQUNBLFdBQUt6UCxNQUFMLENBQVkzUSxJQUFaLENBQWlCLGVBQWpCO0FBQ0QsS0FsSTBDOztBQW9JM0M4Z0IsVUFBTSxTQUFTQSxJQUFULEdBQWdCO0FBQ3BCLFVBQUksS0FBS1YsUUFBTCxJQUFpQixLQUFLRixPQUFMLENBQWEzbkMsTUFBbEMsRUFBMEM7QUFDeEM7QUFDRDs7QUFFRCxXQUFLODNCLEdBQUwsQ0FBUyxLQUFLNlAsT0FBTCxDQUFhLEVBQUUsS0FBS0UsUUFBUCxHQUFrQixDQUEvQixDQUFUO0FBQ0EsV0FBS3pQLE1BQUwsQ0FBWTNRLElBQVosQ0FBaUIsZUFBakI7QUFDRCxLQTNJMEM7O0FBNkkzQ3FRLFNBQUssU0FBU0EsR0FBVCxDQUFhMVgsSUFBYixFQUFtQjtBQUN0QixXQUFLNlosUUFBTCxDQUFjckIsUUFBZCxDQUF1QnhZLElBQXZCO0FBQ0EsV0FBS2dZLE1BQUwsQ0FBWTdYLEtBQVosQ0FBa0IsSUFBbEI7QUFDRDtBQWhKMEMsR0FEckIsQ0FBeEI7QUFtSkQsQ0FwS0QsRUFvS0czaUIsU0FwS0g7QUFxS0E7OztBQUdBQSxVQUFVUSxLQUFWLENBQWdCNHFDLElBQWhCLEdBQXVCdG9CLEtBQUtsZixNQUFMO0FBQ3ZCLDRDQUE0QztBQUMxQzlELGVBQWEsU0FBU0EsV0FBVCxDQUFxQmtILE1BQXJCLEVBQTZCcWtDLGVBQTdCLEVBQThDcm9DLE1BQTlDLEVBQXNEO0FBQ2pFLFNBQUtnRSxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLc2IsT0FBTCxHQUFlK29CLGVBQWY7QUFDQSxTQUFLcm9DLE1BQUwsR0FBY0EsTUFBZDs7QUFFQSxTQUFLc29DLGtCQUFMO0FBQ0QsR0FQeUM7O0FBUzFDQSxzQkFBb0IsU0FBU0Esa0JBQVQsR0FBOEI7QUFDaEQsUUFBSTFTLE9BQU8sSUFBWDtBQUNBLFNBQUs1eEIsTUFBTCxDQUFZeWlCLE9BQVosQ0FBb0IsWUFBcEIsRUFBa0MsWUFBWTtBQUM1Q21QLFdBQUs1eEIsTUFBTCxDQUFZeWlCLE9BQVosQ0FBb0IsYUFBcEIsRUFBbUMsVUFBVWdSLElBQVYsRUFBZ0I7QUFDakQsWUFBSUEsU0FBUzdCLEtBQUt2ekIsSUFBbEIsRUFBd0I7QUFDdEJ1ekIsZUFBSzV4QixNQUFMLENBQVl1a0MsV0FBWixHQUEwQjNTLElBQTFCO0FBQ0FBLGVBQUs0UyxJQUFMO0FBQ0E7QUFDQTNSLHFCQUFXLFlBQVk7QUFDckJqQixpQkFBS2pXLEtBQUw7QUFDRCxXQUZELEVBRUcsQ0FGSDtBQUdELFNBUEQsTUFPTztBQUNMaVcsZUFBSzZTLElBQUw7QUFDRDtBQUNGLE9BWEQ7QUFZRCxLQWJEO0FBY0QsR0F6QnlDOztBQTJCMUM5b0IsU0FBTyxTQUFTQSxLQUFULEdBQWlCO0FBQ3RCLFFBQUksS0FBS0wsT0FBTCxDQUFheFosYUFBYixDQUEyQjhjLGFBQTNCLENBQXlDLFFBQXpDLE1BQXVELEtBQUt0RCxPQUFoRSxFQUF5RTtBQUN2RTtBQUNEOztBQUVELFFBQUk7QUFDRixXQUFLQSxPQUFMLENBQWFLLEtBQWI7QUFDRCxLQUZELENBRUUsT0FBTzVjLENBQVAsRUFBVSxDQUFFO0FBQ2YsR0FuQ3lDOztBQXFDMUMwbEMsUUFBTSxTQUFTQSxJQUFULEdBQWdCO0FBQ3BCLFNBQUtucEIsT0FBTCxDQUFhZ04sS0FBYixDQUFtQkMsT0FBbkIsR0FBNkIsTUFBN0I7QUFDRCxHQXZDeUM7O0FBeUMxQ2ljLFFBQU0sU0FBU0EsSUFBVCxHQUFnQjtBQUNwQixTQUFLbHBCLE9BQUwsQ0FBYWdOLEtBQWIsQ0FBbUJDLE9BQW5CLEdBQTZCLEVBQTdCO0FBQ0QsR0EzQ3lDOztBQTZDMUNtYyxXQUFTLFNBQVNBLE9BQVQsR0FBbUI7QUFDMUIsU0FBS3BwQixPQUFMLENBQWFtRSxZQUFiLENBQTBCLFVBQTFCLEVBQXNDLFVBQXRDO0FBQ0QsR0EvQ3lDOztBQWlEMUNrbEIsVUFBUSxTQUFTQSxNQUFULEdBQWtCO0FBQ3hCLFNBQUtycEIsT0FBTCxDQUFheWYsZUFBYixDQUE2QixVQUE3QjtBQUNEO0FBbkR5QyxDQURyQixDQUF2QixDQXFERyxDQUFDLFVBQVUvaEMsU0FBVixFQUFxQjtBQUN2QixNQUFJRyxNQUFNSCxVQUFVRyxHQUFwQjtBQUFBLE1BQ0lxa0IsVUFBVXhrQixVQUFVd2tCLE9BRHhCOztBQUdBeGtCLFlBQVVRLEtBQVYsQ0FBZ0JvckMsUUFBaEIsR0FBMkI1ckMsVUFBVVEsS0FBVixDQUFnQjRxQyxJQUFoQixDQUFxQnhuQyxNQUFyQjtBQUMzQixrREFBZ0Q7QUFDOUN5QixVQUFNLFVBRHdDOztBQUc5QztBQUNBd21DLGdCQUFZLE1BSmtDOztBQU05Qy9yQyxpQkFBYSxTQUFTQSxXQUFULENBQXFCa0gsTUFBckIsRUFBNkJxa0MsZUFBN0IsRUFBOENyb0MsTUFBOUMsRUFBc0Q7QUFDakUsV0FBS21nQixJQUFMLENBQVVuYyxNQUFWLEVBQWtCcWtDLGVBQWxCLEVBQW1Dcm9DLE1BQW5DO0FBQ0EsV0FBSzhvQyxRQUFMLEdBQWdCLEtBQUs5a0MsTUFBTCxDQUFZOGtDLFFBQTVCO0FBQ0EsV0FBS0MsWUFBTDtBQUNELEtBVjZDOztBQVk5Q2pSLFdBQU8sU0FBU0EsS0FBVCxHQUFpQjtBQUN0QixXQUFLeFksT0FBTCxDQUFhblEsU0FBYixHQUF5QnFTLFFBQVE0Qiw0Q0FBUixLQUF5RCxFQUF6RCxHQUE4RCxLQUFLeWxCLFVBQTVGO0FBQ0QsS0FkNkM7O0FBZ0I5QzdCLGNBQVUsU0FBU0EsUUFBVCxDQUFrQnJYLEtBQWxCLEVBQXlCO0FBQ2pDLFVBQUkvTyxRQUFRLEtBQUttWCxPQUFMLEtBQWlCLEVBQWpCLEdBQXNCLzZCLFVBQVVJLE1BQVYsQ0FBaUJxekIsbUJBQWpCLENBQXFDLEtBQUtuUixPQUExQyxDQUFsQzs7QUFFQSxVQUFJcVEsS0FBSixFQUFXO0FBQ1QvTyxnQkFBUSxLQUFLNWMsTUFBTCxDQUFZMnJCLEtBQVosQ0FBa0IvTyxLQUFsQixDQUFSO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0FBLGNBQVE1akIsVUFBVU0sSUFBVixDQUFla3FCLE1BQWYsQ0FBc0I1RyxLQUF0QixFQUE2QjNJLE9BQTdCLENBQXFDamIsVUFBVVMsZUFBL0MsRUFBZ0VvcUIsRUFBaEUsQ0FBbUUsRUFBbkUsQ0FBUjs7QUFFQSxhQUFPakgsS0FBUDtBQUNELEtBN0I2Qzs7QUErQjlDb1gsY0FBVSxTQUFTQSxRQUFULENBQWtCeFksSUFBbEIsRUFBd0JtUSxLQUF4QixFQUErQjtBQUN2QyxVQUFJQSxLQUFKLEVBQVc7QUFDVG5RLGVBQU8sS0FBS3hiLE1BQUwsQ0FBWTJyQixLQUFaLENBQWtCblEsSUFBbEIsQ0FBUDtBQUNEO0FBQ0QsV0FBS0YsT0FBTCxDQUFhblEsU0FBYixHQUF5QnFRLElBQXpCO0FBQ0QsS0FwQzZDOztBQXNDOUNncEIsVUFBTSxTQUFTQSxJQUFULEdBQWdCO0FBQ3BCLFdBQUt0dEIsTUFBTCxDQUFZb1IsS0FBWixDQUFrQkMsT0FBbEIsR0FBNEIsS0FBS3ljLGFBQUwsSUFBc0IsRUFBbEQ7O0FBRUE7QUFDQSxXQUFLTixPQUFMO0FBQ0EsV0FBS0MsTUFBTDtBQUNELEtBNUM2Qzs7QUE4QzlDRixVQUFNLFNBQVNBLElBQVQsR0FBZ0I7QUFDcEIsV0FBS08sYUFBTCxHQUFxQjdyQyxJQUFJcXRCLFFBQUosQ0FBYSxTQUFiLEVBQXdCQyxJQUF4QixDQUE2QixLQUFLdlAsTUFBbEMsQ0FBckI7QUFDQSxVQUFJLEtBQUs4dEIsYUFBTCxLQUF1QixNQUEzQixFQUFtQztBQUNqQyxhQUFLQSxhQUFMLEdBQXFCLElBQXJCO0FBQ0Q7QUFDRCxXQUFLOXRCLE1BQUwsQ0FBWW9SLEtBQVosQ0FBa0JDLE9BQWxCLEdBQTRCLE1BQTVCO0FBQ0QsS0FwRDZDOztBQXNEOUNtYyxhQUFTLFNBQVNBLE9BQVQsR0FBbUI7QUFDMUIsV0FBS3BwQixPQUFMLENBQWF5ZixlQUFiLENBQTZCLGlCQUE3QjtBQUNBLFdBQUs1ZSxJQUFMO0FBQ0QsS0F6RDZDOztBQTJEOUN3b0IsWUFBUSxTQUFTQSxNQUFULEdBQWtCO0FBQ3hCLFdBQUtycEIsT0FBTCxDQUFhbUUsWUFBYixDQUEwQixpQkFBMUIsRUFBNkMsTUFBN0M7QUFDQSxXQUFLdEQsSUFBTDtBQUNELEtBOUQ2Qzs7QUFnRTlDUixXQUFPLFNBQVNBLEtBQVQsQ0FBZXNwQixRQUFmLEVBQXlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFVBQUlqc0MsVUFBVXdrQixPQUFWLENBQWtCc0UsY0FBbEIsTUFBc0MsS0FBSytSLGlCQUFMLEVBQTFDLEVBQW9FO0FBQ2xFLGFBQUtDLEtBQUw7QUFDRDs7QUFFRCxXQUFLM1gsSUFBTDs7QUFFQSxVQUFJbFAsWUFBWSxLQUFLcU8sT0FBTCxDQUFhck8sU0FBN0I7QUFDQSxVQUFJZzRCLFlBQVloNEIsU0FBaEIsRUFBMkI7QUFDekIsWUFBSUEsVUFBVXJKLFFBQVYsS0FBdUIsSUFBM0IsRUFBaUM7QUFDL0IsZUFBS3JLLFNBQUwsQ0FBZSs5QixTQUFmLENBQXlCLEtBQUtoYyxPQUFMLENBQWFyTyxTQUF0QztBQUNELFNBRkQsTUFFTztBQUNMLGVBQUsxVCxTQUFMLENBQWVnK0IsUUFBZixDQUF3QixLQUFLamMsT0FBTCxDQUFhck8sU0FBckM7QUFDRDtBQUNGO0FBQ0YsS0FsRjZDOztBQW9GOUNrbkIsb0JBQWdCLFNBQVNBLGNBQVQsR0FBMEI7QUFDeEMsYUFBT2g3QixJQUFJZzdCLGNBQUosQ0FBbUIsS0FBSzdZLE9BQXhCLENBQVA7QUFDRCxLQXRGNkM7O0FBd0Y5Q3VZLHVCQUFtQixTQUFTQSxpQkFBVCxHQUE2QjtBQUM5QyxhQUFPLEtBQUtNLGNBQUwsTUFBeUIsS0FBSzJRLFFBQUwsQ0FBY3hwQixPQUFkLENBQXNCd0YsWUFBdEIsQ0FBbUMsYUFBbkMsQ0FBaEM7QUFDRCxLQTFGNkM7O0FBNEY5Q2lULGFBQVMsU0FBU0EsT0FBVCxHQUFtQjtBQUMxQixVQUFJNW9CLFlBQVksS0FBS21RLE9BQUwsQ0FBYW5RLFNBQTdCO0FBQUEsVUFDSSs1QiwwQkFBMEIsMkdBRDlCO0FBRUEsYUFBTy81QixjQUFjLEVBQWQsSUFBb0JBLGNBQWMsS0FBSzA1QixVQUF2QyxJQUFxRCxLQUFLaFIsaUJBQUwsRUFBckQsSUFBaUYsS0FBS00sY0FBTCxPQUEwQixFQUExQixJQUFnQyxDQUFDLEtBQUs3WSxPQUFMLENBQWFzRCxhQUFiLENBQTJCc21CLHVCQUEzQixDQUF6SDtBQUNELEtBaEc2Qzs7QUFrRzlDSCxrQkFBYyxTQUFTQSxZQUFULEdBQXdCO0FBQ3BDLFVBQUluVCxPQUFPLElBQVg7O0FBRUEsV0FBS3VSLE9BQUwsR0FBZSxJQUFJaHFDLElBQUlnNEIsT0FBUixDQUFnQixZQUFZO0FBQ3pDUyxhQUFLdVQsT0FBTDtBQUNELE9BRmMsRUFFWjtBQUNEN1MscUJBQWEsS0FBS3QyQixNQUFMLENBQVlzMkI7QUFEeEIsT0FGWSxDQUFmO0FBS0EsV0FBS3BiLE1BQUwsR0FBYyxLQUFLaXNCLE9BQUwsQ0FBYTFSLFNBQWIsRUFBZDs7QUFFQTtBQUNBLFVBQUkyVCxjQUFjam9DLFNBQVNrQyxhQUFULENBQXVCLE9BQXZCLENBQWxCO0FBQ0ErbEMsa0JBQVkzL0IsSUFBWixHQUFtQixRQUFuQjtBQUNBMi9CLGtCQUFZL21DLElBQVosR0FBbUIsaUJBQW5CO0FBQ0ErbUMsa0JBQVl4b0IsS0FBWixHQUFvQixDQUFwQjs7QUFFQTtBQUNBLFVBQUl5bkIsa0JBQWtCLEtBQUtTLFFBQUwsQ0FBY3hwQixPQUFwQztBQUNBbmlCLFVBQUl1dEIsTUFBSixDQUFXLEtBQUt4UCxNQUFoQixFQUF3QnlQLEtBQXhCLENBQThCMGQsZUFBOUI7QUFDQWxyQyxVQUFJdXRCLE1BQUosQ0FBVzBlLFdBQVgsRUFBd0J6ZSxLQUF4QixDQUE4QjBkLGVBQTlCO0FBQ0QsS0F0SDZDOztBQXdIOUNjLGFBQVMsU0FBU0EsT0FBVCxHQUFtQjtBQUMxQixVQUFJdlQsT0FBTyxJQUFYOztBQUVBLFdBQUs1dkIsR0FBTCxHQUFXLEtBQUttaEMsT0FBTCxDQUFhdGhDLFdBQWIsRUFBWDtBQUNBLFdBQUt5WixPQUFMLEdBQWUsS0FBS3RaLEdBQUwsQ0FBUzFFLElBQXhCO0FBQ0EsV0FBS3duQyxRQUFMLEdBQWdCLEtBQUs5a0MsTUFBTCxDQUFZOGtDLFFBQTVCO0FBQ0EsV0FBS3hwQixPQUFMLENBQWFuUSxTQUFiLEdBQXlCLEtBQUsyNUIsUUFBTCxDQUFjOUIsUUFBZCxDQUF1QixJQUF2QixDQUF6QjtBQUNBLFdBQUsyQixNQUFMOztBQUVBO0FBQ0EsV0FBS3ByQyxTQUFMLEdBQWlCLElBQUlQLFVBQVU0aUIsU0FBZCxDQUF3QixLQUFLNWIsTUFBN0IsQ0FBakI7O0FBRUE7QUFDQSxXQUFLOUcsUUFBTCxHQUFnQixJQUFJRixVQUFVdWtDLFFBQWQsQ0FBdUIsS0FBS3Y5QixNQUE1QixDQUFoQjs7QUFFQTdHLFVBQUkwdEIsY0FBSixDQUFtQixDQUFDLFdBQUQsRUFBYyxZQUFkLEVBQTRCLE9BQTVCLEVBQXFDLE1BQXJDLEVBQTZDLEtBQTdDLEVBQW9ELFdBQXBELENBQW5CLEVBQXFGSixJQUFyRixDQUEwRixLQUFLcWUsUUFBTCxDQUFjeHBCLE9BQXhHLEVBQWlIMEwsRUFBakgsQ0FBb0gsS0FBSzFMLE9BQXpIOztBQUVBbmlCLFVBQUlpc0IsUUFBSixDQUFhLEtBQUs5SixPQUFsQixFQUEyQixLQUFLdGYsTUFBTCxDQUFZcXBDLGlCQUF2Qzs7QUFFQTtBQUNBLFVBQUksS0FBS3JwQyxNQUFMLENBQVlzc0IsS0FBaEIsRUFBdUI7QUFDckIsYUFBS0EsS0FBTDtBQUNEOztBQUVELFdBQUs3RixPQUFMOztBQUVBLFVBQUlwa0IsT0FBTyxLQUFLckMsTUFBTCxDQUFZcUMsSUFBdkI7QUFDQSxVQUFJQSxJQUFKLEVBQVU7QUFDUmxGLFlBQUlpc0IsUUFBSixDQUFhLEtBQUs5SixPQUFsQixFQUEyQmpkLElBQTNCO0FBQ0FsRixZQUFJaXNCLFFBQUosQ0FBYSxLQUFLbE8sTUFBbEIsRUFBMEI3WSxJQUExQjtBQUNEOztBQUVEO0FBQ0EsVUFBSXExQixrQkFBa0IsT0FBTyxLQUFLMTNCLE1BQUwsQ0FBWXNwQyxXQUFuQixLQUFtQyxRQUFuQyxHQUE4QyxLQUFLdHBDLE1BQUwsQ0FBWXNwQyxXQUExRCxHQUF3RSxLQUFLUixRQUFMLENBQWN4cEIsT0FBZCxDQUFzQndGLFlBQXRCLENBQW1DLGFBQW5DLENBQTlGO0FBQ0EsVUFBSTRTLGVBQUosRUFBcUI7QUFDbkJ2NkIsWUFBSW82QixtQkFBSixDQUF3QixLQUFLdnpCLE1BQTdCLEVBQXFDLElBQXJDLEVBQTJDMHpCLGVBQTNDO0FBQ0Q7O0FBRUQ7QUFDQSxXQUFLeDZCLFFBQUwsQ0FBY3k5QixJQUFkLENBQW1CLGNBQW5CLEVBQW1DLEtBQW5DOztBQUVBLFdBQUs0TyxnQkFBTDtBQUNBLFdBQUtDLG1CQUFMO0FBQ0EsV0FBS0MsZ0JBQUw7O0FBRUE7QUFDQSxVQUFJLEtBQUtYLFFBQUwsQ0FBY3hwQixPQUFkLENBQXNCMlQsWUFBdEIsQ0FBbUMsV0FBbkMsS0FBbUQ5eEIsU0FBU3loQixhQUFULENBQXVCLFFBQXZCLEtBQW9DLEtBQUtrbUIsUUFBTCxDQUFjeHBCLE9BQXpHLEVBQWtIO0FBQ2hIdVgsbUJBQVcsWUFBWTtBQUNyQmpCLGVBQUtqVyxLQUFMO0FBQ0QsU0FGRCxFQUVHLEdBRkg7QUFHRDs7QUFFRDNpQixnQkFBVUksTUFBVixDQUFpQmc5Qix1QkFBakIsQ0FBeUMsSUFBekM7O0FBRUE7QUFDQSxVQUFJLENBQUM1WSxRQUFRbUQsOEJBQVIsRUFBTCxFQUErQztBQUM3QzNuQixrQkFBVUksTUFBVixDQUFpQis3QixvQkFBakIsQ0FBc0MsSUFBdEM7QUFDRDs7QUFFRCxVQUFJLENBQUMzWCxRQUFRd0QscUNBQVIsRUFBTCxFQUFzRDtBQUNwRGhvQixrQkFBVUksTUFBVixDQUFpQms4QiwyQkFBakIsQ0FBNkMsSUFBN0M7QUFDRDs7QUFFRDtBQUNBLFVBQUksS0FBS29RLFFBQUwsSUFBaUIsS0FBSzFwQyxNQUFMLENBQVkycEMsSUFBakMsRUFBdUM7QUFDckMsYUFBS0QsUUFBTDtBQUNEOztBQUVEO0FBQ0EsV0FBS1osUUFBTCxDQUFjTCxJQUFkOztBQUVBO0FBQ0EsV0FBS3prQyxNQUFMLENBQVk2aUIsSUFBWixDQUFpQixZQUFqQixFQUErQkEsSUFBL0IsQ0FBb0MsTUFBcEM7QUFDRCxLQWpNNkM7O0FBbU05QzBpQixzQkFBa0IsU0FBU0EsZ0JBQVQsR0FBNEI7QUFDNUMsVUFBSTNULE9BQU8sSUFBWDtBQUFBLFVBQ0lnVSxpQ0FBaUNwb0IsUUFBUWtELHFCQUFSLEVBRHJDO0FBQUEsVUFFSW1sQixzQkFBc0Jyb0IsUUFBUWlELGdDQUFSLEVBRjFCO0FBR0EsVUFBSW1sQiw4QkFBSixFQUFvQztBQUNsQyxhQUFLMXNDLFFBQUwsQ0FBY3k5QixJQUFkLENBQW1CLGVBQW5CLEVBQW9DLEtBQXBDO0FBQ0Q7O0FBRUQsVUFBSSxDQUFDLEtBQUszNkIsTUFBTCxDQUFZcW9CLFFBQWpCLEVBQTJCO0FBQ3pCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFVBQUksQ0FBQ3doQixtQkFBRCxJQUF3QkEsdUJBQXVCRCw4QkFBbkQsRUFBbUY7QUFDakYsYUFBSzVsQyxNQUFMLENBQVl5aUIsT0FBWixDQUFvQixrQkFBcEIsRUFBd0MsWUFBWTtBQUNsRG1QLGVBQUtyNEIsU0FBTCxDQUFlbStCLGlCQUFmLENBQWlDLFVBQVVyeUIsY0FBVixFQUEwQkMsWUFBMUIsRUFBd0M7QUFDdkVuTSxnQkFBSWtyQixRQUFKLENBQWEvZSxhQUFhckYsVUFBMUI7QUFDRCxXQUZEO0FBR0QsU0FKRDtBQUtEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBSTtBQUNKNmxDLGNBQVEsS0FBSzNDLE9BQUwsQ0FBYXRoQyxXQUFiLEdBQTJCdEUsb0JBQTNCLENBQWdELEdBQWhELENBRFI7OztBQUdBO0FBQ0F3b0Msa0JBQVk1c0MsSUFBSWtyQixRQUFKLENBQWFKLFdBSnpCO0FBQUEsVUFLSWtRLGlCQUFpQixTQUFTQSxjQUFULENBQXdCN1ksT0FBeEIsRUFBaUM7QUFDcEQsWUFBSTRZLGNBQWNsN0IsVUFBVU0sSUFBVixDQUFla3FCLE1BQWYsQ0FBc0JycUIsSUFBSWc3QixjQUFKLENBQW1CN1ksT0FBbkIsQ0FBdEIsRUFBbURvSSxJQUFuRCxFQUFsQjtBQUNBLFlBQUl3USxZQUFZcFAsTUFBWixDQUFtQixDQUFuQixFQUFzQixDQUF0QixNQUE2QixNQUFqQyxFQUF5QztBQUN2Q29QLHdCQUFjLFlBQVlBLFdBQTFCO0FBQ0Q7QUFDRCxlQUFPQSxXQUFQO0FBQ0QsT0FYRDs7QUFhQS82QixVQUFJc3BCLE9BQUosQ0FBWSxLQUFLbkgsT0FBakIsRUFBMEIsU0FBMUIsRUFBcUMsVUFBVTZNLEtBQVYsRUFBaUI7QUFDcEQsWUFBSSxDQUFDMmQsTUFBTTFxQyxNQUFYLEVBQW1CO0FBQ2pCO0FBQ0Q7O0FBRUQsWUFBSWs3QixlQUFlMUUsS0FBS3I0QixTQUFMLENBQWVzOEIsZUFBZixDQUErQjFOLE1BQU1yaUIsTUFBTixDQUFhaEUsYUFBNUMsQ0FBbkI7QUFBQSxZQUNJa2tDLE9BQU83c0MsSUFBSXd2QixnQkFBSixDQUFxQjJOLFlBQXJCLEVBQW1DLEVBQUUxeUIsVUFBVSxHQUFaLEVBQW5DLEVBQXNELENBQXRELENBRFg7QUFBQSxZQUVJc3dCLFdBRko7O0FBSUEsWUFBSSxDQUFDOFIsSUFBTCxFQUFXO0FBQ1Q7QUFDRDs7QUFFRDlSLHNCQUFjQyxlQUFlNlIsSUFBZixDQUFkO0FBQ0E7QUFDQTtBQUNBblQsbUJBQVcsWUFBWTtBQUNyQixjQUFJb1QsaUJBQWlCOVIsZUFBZTZSLElBQWYsQ0FBckI7QUFDQSxjQUFJQyxtQkFBbUIvUixXQUF2QixFQUFvQztBQUNsQztBQUNEOztBQUVEO0FBQ0EsY0FBSStSLGVBQWU5bkIsS0FBZixDQUFxQjRuQixTQUFyQixDQUFKLEVBQXFDO0FBQ25DQyxpQkFBS3ZtQixZQUFMLENBQWtCLE1BQWxCLEVBQTBCd21CLGNBQTFCO0FBQ0Q7QUFDRixTQVZELEVBVUcsQ0FWSDtBQVdELE9BM0JEO0FBNEJELEtBdFE2Qzs7QUF3UTlDVCx5QkFBcUIsU0FBU0EsbUJBQVQsR0FBK0I7QUFDbEQsVUFBSVUsYUFBYSxDQUFDLE9BQUQsRUFBVSxRQUFWLENBQWpCO0FBQUEsVUFDSUMsbUJBQW1CRCxXQUFXOXFDLE1BRGxDO0FBQUEsVUFFSWtnQixVQUFVLEtBQUtBLE9BRm5COztBQUlBLFdBQUtwaUIsUUFBTCxDQUFjeTlCLElBQWQsQ0FBbUIsc0JBQW5CLEVBQTJDLEtBQUszNkIsTUFBTCxDQUFZb3FDLG1CQUF2RDs7QUFFQSxVQUFJLEtBQUtwcUMsTUFBTCxDQUFZb3FDLG1CQUFoQixFQUFxQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxZQUFJNW9CLFFBQVF5QixhQUFSLENBQXNCLFdBQXRCLENBQUosRUFBd0M7QUFDdEM5bEIsY0FBSXNwQixPQUFKLENBQVluSCxPQUFaLEVBQXFCLFdBQXJCLEVBQWtDLFVBQVU2TSxLQUFWLEVBQWlCO0FBQ2pELGdCQUFJcmlCLFNBQVNxaUIsTUFBTXJpQixNQUFOLElBQWdCcWlCLE1BQU1rRCxVQUFuQztBQUFBLGdCQUNJL0MsUUFBUXhpQixPQUFPd2lCLEtBRG5CO0FBQUEsZ0JBRUludEIsSUFBSSxDQUZSO0FBQUEsZ0JBR0kwbUIsUUFISjtBQUlBLG1CQUFPMW1CLElBQUlnckMsZ0JBQVgsRUFBNkJockMsR0FBN0IsRUFBa0M7QUFDaEMwbUIseUJBQVdxa0IsV0FBVy9xQyxDQUFYLENBQVg7QUFDQSxrQkFBSW10QixNQUFNekcsUUFBTixDQUFKLEVBQXFCO0FBQ25CL2IsdUJBQU8yWixZQUFQLENBQW9Cb0MsUUFBcEIsRUFBOEIyRixTQUFTYyxNQUFNekcsUUFBTixDQUFULEVBQTBCLEVBQTFCLENBQTlCO0FBQ0F5RyxzQkFBTXpHLFFBQU4sSUFBa0IsRUFBbEI7QUFDRDtBQUNGO0FBQ0Q7QUFDQTdvQixzQkFBVUksTUFBVixDQUFpQnc5QixNQUFqQixDQUF3QnRiLE9BQXhCO0FBQ0QsV0FkRDtBQWVEO0FBQ0YsT0FyQkQsTUFxQk87QUFDTCxZQUFJa0MsUUFBUXlCLGFBQVIsQ0FBc0IsYUFBdEIsQ0FBSixFQUEwQztBQUN4QzlsQixjQUFJc3BCLE9BQUosQ0FBWW5ILE9BQVosRUFBcUIsYUFBckIsRUFBb0MsVUFBVTZNLEtBQVYsRUFBaUI7QUFDbkRBLGtCQUFNbUQsY0FBTjtBQUNELFdBRkQ7QUFHRDtBQUNGO0FBQ0YsS0EzUzZDOztBQTZTOUNtYSxzQkFBa0IsU0FBU0EsZ0JBQVQsR0FBNEI7QUFDNUMsVUFBSXpzQyxVQUFVOHBDLFdBQWQsQ0FBMEIsS0FBSzlpQyxNQUEvQjtBQUNEO0FBL1M2QyxHQURyQixDQUEzQjtBQWtURCxDQXRURSxFQXNUQWhILFNBdFRBLEVBc1RXLENBQUMsVUFBVUEsU0FBVixFQUFxQjtBQUNsQyxNQUFJRyxNQUFNSCxVQUFVRyxHQUFwQjtBQUFBLE1BQ0k2SSxNQUFNN0UsUUFEVjtBQUFBLE1BRUlnQixNQUFNakUsTUFGVjtBQUFBLE1BR0ltc0MsZ0JBQWdCcmtDLElBQUkzQyxhQUFKLENBQWtCLEtBQWxCLENBSHBCOzs7QUFLQTs7O0FBR0FpbkMsb0JBQWtCLENBQUMsa0JBQUQsRUFBcUIsT0FBckIsRUFBOEIsUUFBOUIsRUFBd0MsYUFBeEMsRUFBdUQsV0FBdkQsRUFBb0UsWUFBcEUsRUFBa0YsY0FBbEYsRUFBa0csYUFBbEcsRUFBaUgsYUFBakgsRUFBZ0ksZ0JBQWhJLEVBQWtKLFlBQWxKLEVBQWdLLGlCQUFoSyxFQUFtTCxhQUFuTCxFQUFrTSxnQkFBbE0sRUFBb04sWUFBcE4sRUFBa08sV0FBbE8sRUFBK08sY0FBL08sQ0FSbEI7OztBQVVBOzs7QUFHQUMsbUJBQWlCLENBQUMsa0JBQUQsRUFBcUIsaUJBQXJCLEVBQXdDLHFCQUF4QyxFQUErRCxxQkFBL0QsRUFBc0YscUJBQXRGLEVBQTZHLG1CQUE3RyxFQUFrSSxtQkFBbEksRUFBdUosbUJBQXZKLEVBQTRLLG9CQUE1SyxFQUFrTSxvQkFBbE0sRUFBd04sb0JBQXhOLEVBQThPLGtCQUE5TyxFQUFrUSxrQkFBbFEsRUFBc1Isa0JBQXRSLEVBQTBTLE9BQTFTLEVBQW1ULFNBQW5ULEVBQThULE9BQTlULEVBQXVVLGVBQXZVLEVBQXdWLGFBQXhWLEVBQXVXLGNBQXZXLEVBQXVYLFlBQXZYLEVBQXFZLGVBQXJZLEVBQXNaLGdCQUF0WixFQUF3YSxlQUF4YSxFQUF5YixlQUF6YixFQUEwYyxjQUExYyxFQUEwZCxlQUExZCxFQUEyZSxhQUEzZSxFQUEwZixnQkFBMWYsRUFBNGdCLFVBQTVnQixFQUF3aEIsS0FBeGhCLEVBQStoQixNQUEvaEIsRUFBdWlCLE9BQXZpQixFQUFnakIsUUFBaGpCLEVBQTBqQixTQUExakIsRUFBcWtCLGdCQUFya0IsRUFBdWxCLFlBQXZsQixFQUFxbUIsb0JBQXJtQixFQUEybkIsaUJBQTNuQixFQUE4b0IsZ0JBQTlvQixFQUFncUIsWUFBaHFCLEVBQThxQixvQkFBOXFCLEVBQW9zQixpQkFBcHNCLEVBQXV0QixnQkFBdnRCLEVBQXl1QixZQUF6dUIsRUFBdXZCLGlDQUF2dkIsRUFBMHhCLDZCQUExeEIsRUFBeXpCLHlCQUF6ekIsRUFBbzFCLG9DQUFwMUIsRUFBMDNCLGdDQUExM0IsRUFBNDVCLDRCQUE1NUIsRUFBMDdCLG1DQUExN0IsRUFBKzlCLCtCQUEvOUIsRUFBZ2dDLDJCQUFoZ0MsRUFBNmhDLGdDQUE3aEMsRUFBK2pDLDRCQUEvakMsRUFBNmxDLHdCQUE3bEMsRUFBdW5DLE9BQXZuQyxFQUFnb0MsUUFBaG9DLENBYmpCOzs7QUFlQTs7O0FBR0FDLGlCQUFlLENBQUMsT0FBRCxFQUFVLFFBQVYsRUFBb0IsS0FBcEIsRUFBMkIsTUFBM0IsRUFBbUMsT0FBbkMsRUFBNEMsUUFBNUMsQ0FsQmY7QUFBQSxNQW1CSUMsdUJBQXVCLENBQUMsb0NBQUQsRUFBdUMsMEhBQXZDLEVBQW1LLHFDQUFuSyxFQUEwTXp0QyxVQUFVd2tCLE9BQVYsQ0FBa0JNLE9BQWxCLEdBQTRCLGtEQUE1QixHQUFpRixpREFBM1IsRUFBOFUsNkdBQTlVO0FBQzNCO0FBQ0Esb0ZBRjJCLENBbkIzQjs7QUF1QkE7Ozs7Ozs7O0FBUUEsTUFBSTRvQix3QkFBd0IsU0FBU0EscUJBQVQsQ0FBK0JwckIsT0FBL0IsRUFBd0M7QUFDbEUsUUFBSUEsUUFBUXFyQixTQUFaLEVBQXVCO0FBQ3JCO0FBQ0E7QUFDQSxVQUFJO0FBQ0ZyckIsZ0JBQVFxckIsU0FBUjtBQUNELE9BRkQsQ0FFRSxPQUFPNW5DLENBQVAsRUFBVSxDQUFFO0FBQ2YsS0FORCxNQU1PO0FBQ0wsVUFBSTZuQyxlQUFldHJCLFFBQVFnTixLQUEzQjtBQUFBLFVBQ0l1ZSxvQkFBb0I3a0MsSUFBSXNKLGVBQUosQ0FBb0J1c0IsU0FBcEIsSUFBaUM3MUIsSUFBSTFFLElBQUosQ0FBU3U2QixTQURsRTtBQUFBLFVBRUlpUCxxQkFBcUI5a0MsSUFBSXNKLGVBQUosQ0FBb0J5c0IsVUFBcEIsSUFBa0MvMUIsSUFBSTFFLElBQUosQ0FBU3k2QixVQUZwRTtBQUFBLFVBR0lnUCxpQkFBaUI7QUFDbkI5RCxrQkFBVTJELGFBQWEzRCxRQURKO0FBRW5Cbk0sYUFBSzhQLGFBQWE5UCxHQUZDO0FBR25CbkgsY0FBTWlYLGFBQWFqWCxJQUhBO0FBSW5CcVgsMEJBQWtCSixhQUFhSTtBQUpaLE9BSHJCOztBQVVBN3RDLFVBQUk2dUIsU0FBSixDQUFjO0FBQ1ppYixrQkFBVSxVQURFO0FBRVpuTSxhQUFLLFVBRk87QUFHWm5ILGNBQU0sVUFITTtBQUlaO0FBQ0FxWCwwQkFBa0I7QUFMTixPQUFkLEVBTUdwa0IsRUFOSCxDQU1NdEgsT0FOTjs7QUFRQUEsY0FBUUssS0FBUjs7QUFFQXhpQixVQUFJNnVCLFNBQUosQ0FBYytlLGNBQWQsRUFBOEJua0IsRUFBOUIsQ0FBaUN0SCxPQUFqQzs7QUFFQSxVQUFJbmQsSUFBSThvQyxRQUFSLEVBQWtCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOW9DLFlBQUk4b0MsUUFBSixDQUFhSCxrQkFBYixFQUFpQ0QsaUJBQWpDO0FBQ0Q7QUFDRjtBQUNGLEdBckNEOztBQXVDQTd0QyxZQUFVUSxLQUFWLENBQWdCb3JDLFFBQWhCLENBQXlCN3JDLFNBQXpCLENBQW1DdXZCLEtBQW5DLEdBQTJDLFlBQVk7QUFDckQsUUFBSXNKLE9BQU8sSUFBWDtBQUFBLFFBQ0lzVix3QkFBd0JsbEMsSUFBSTRjLGFBQUosQ0FBa0IsUUFBbEIsQ0FENUI7QUFBQSxRQUVJeWxCLGtCQUFrQixLQUFLUyxRQUFMLENBQWN4cEIsT0FGcEM7QUFBQSxRQUdJNnJCLGlCQUFpQjlDLGdCQUFnQnBWLFlBQWhCLENBQTZCLGFBQTdCLENBSHJCO0FBQUEsUUFJSW1ZLHNCQUFzQkQsa0JBQWtCOUMsZ0JBQWdCdmpCLFlBQWhCLENBQTZCLGFBQTdCLENBSjVDO0FBS0EsU0FBS3VtQixlQUFMLEdBQXVCLEtBQUtBLGVBQUwsSUFBd0JoQixjQUFjMWtDLFNBQWQsQ0FBd0IsS0FBeEIsQ0FBL0M7QUFDQSxTQUFLMmxDLGNBQUwsR0FBc0IsS0FBS0EsY0FBTCxJQUF1QmpCLGNBQWMxa0MsU0FBZCxDQUF3QixLQUF4QixDQUE3Qzs7QUFFQTtBQUNBLFFBQUl3bEMsY0FBSixFQUFvQjtBQUNsQjlDLHNCQUFnQnRKLGVBQWhCLENBQWdDLGFBQWhDO0FBQ0Q7O0FBRUQsUUFBSXNKLG9CQUFvQjZDLHFCQUF4QixFQUErQztBQUM3QzdDLHNCQUFnQmtELElBQWhCO0FBQ0Q7O0FBRUQ7QUFDQXB1QyxRQUFJdXVCLFVBQUosQ0FBZTZlLGNBQWYsRUFBK0I5ZixJQUEvQixDQUFvQzRkLGVBQXBDLEVBQXFEcmQsRUFBckQsQ0FBd0QsS0FBSzlQLE1BQTdELEVBQXFFaVEsS0FBckUsQ0FBMkUsS0FBS21nQixjQUFoRjs7QUFFQTtBQUNBbnVDLFFBQUl1dUIsVUFBSixDQUFlNGUsZUFBZixFQUFnQzdmLElBQWhDLENBQXFDNGQsZUFBckMsRUFBc0RyZCxFQUF0RCxDQUF5RCxLQUFLMUwsT0FBOUQsRUFBdUU2TCxLQUF2RSxDQUE2RSxLQUFLbWdCLGNBQWxGOztBQUVBO0FBQ0FudUMsUUFBSTJ4QixTQUFKLENBQWMyYixvQkFBZCxFQUFvQzViLElBQXBDLENBQXlDLEtBQUt2UCxPQUFMLENBQWF4WixhQUF0RDs7QUFFQTtBQUNBNGtDLDBCQUFzQnJDLGVBQXRCO0FBQ0FsckMsUUFBSXV1QixVQUFKLENBQWU2ZSxjQUFmLEVBQStCOWYsSUFBL0IsQ0FBb0M0ZCxlQUFwQyxFQUFxRHJkLEVBQXJELENBQXdELEtBQUtxZ0IsZUFBN0Q7QUFDQWx1QyxRQUFJdXVCLFVBQUosQ0FBZTRlLGVBQWYsRUFBZ0M3ZixJQUFoQyxDQUFxQzRkLGVBQXJDLEVBQXNEcmQsRUFBdEQsQ0FBeUQsS0FBS3FnQixlQUE5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFJRyxzQkFBc0J4dUMsVUFBVU0sSUFBVixDQUFlMm9CLEtBQWYsQ0FBcUJza0IsY0FBckIsRUFBcUNwa0IsT0FBckMsQ0FBNkMsQ0FBQyxTQUFELENBQTdDLENBQTFCOztBQUVBO0FBQ0EsUUFBSStrQixxQkFBSixFQUEyQjtBQUN6QkEsNEJBQXNCdnJCLEtBQXRCO0FBQ0QsS0FGRCxNQUVPO0FBQ0wwb0Isc0JBQWdCa0QsSUFBaEI7QUFDRDs7QUFFRDtBQUNBLFFBQUlKLGNBQUosRUFBb0I7QUFDbEI5QyxzQkFBZ0I1a0IsWUFBaEIsQ0FBNkIsYUFBN0IsRUFBNEMybkIsbUJBQTVDO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFFBQUksQ0FBQ3B1QyxVQUFVd2tCLE9BQVYsQ0FBa0I2Qix1QkFBbEIsRUFBTCxFQUFrRDtBQUNoRCxVQUFJb29CLGNBQWN0dUMsSUFBSXNwQixPQUFKLENBQVl0a0IsR0FBWixFQUFpQixRQUFqQixFQUEyQixZQUFZO0FBQ3ZEO0FBQ0EsWUFBSSxDQUFDaEYsSUFBSTZWLFFBQUosQ0FBYTdSLFNBQVNtTyxlQUF0QixFQUF1Q3NtQixLQUFLMWEsTUFBNUMsQ0FBTCxFQUEwRDtBQUN4RHV3QixzQkFBWTNnQyxJQUFaO0FBQ0E7QUFDRDtBQUNELFlBQUk0Z0MsK0JBQStCdnVDLElBQUlxdEIsUUFBSixDQUFhLFNBQWIsRUFBd0JDLElBQXhCLENBQTZCNGQsZUFBN0IsQ0FBbkM7QUFBQSxZQUNJc0QsK0JBQStCeHVDLElBQUlxdEIsUUFBSixDQUFhLFNBQWIsRUFBd0JDLElBQXhCLENBQTZCbUwsS0FBSzFhLE1BQWxDLENBRG5DO0FBRUFtdEIsd0JBQWdCL2IsS0FBaEIsQ0FBc0JDLE9BQXRCLEdBQWdDLEVBQWhDO0FBQ0FxSixhQUFLMWEsTUFBTCxDQUFZb1IsS0FBWixDQUFrQkMsT0FBbEIsR0FBNEIsTUFBNUI7QUFDQXB2QixZQUFJdXVCLFVBQUosQ0FBZThlLFlBQWYsRUFBNkIvZixJQUE3QixDQUFrQzRkLGVBQWxDLEVBQW1EcmQsRUFBbkQsQ0FBc0Q0SyxLQUFLMWEsTUFBM0QsRUFBbUVpUSxLQUFuRSxDQUF5RXlLLEtBQUt5VixlQUE5RSxFQUErRmxnQixLQUEvRixDQUFxR3lLLEtBQUswVixjQUExRztBQUNBMVYsYUFBSzFhLE1BQUwsQ0FBWW9SLEtBQVosQ0FBa0JDLE9BQWxCLEdBQTRCb2YsNEJBQTVCO0FBQ0F0RCx3QkFBZ0IvYixLQUFoQixDQUFzQkMsT0FBdEIsR0FBZ0NtZiw0QkFBaEM7QUFDRCxPQWJpQixDQUFsQjtBQWNEOztBQUVEO0FBQ0EsU0FBSzFuQyxNQUFMLENBQVl5aUIsT0FBWixDQUFvQixnQkFBcEIsRUFBc0MsWUFBWTtBQUNoRHRwQixVQUFJdXVCLFVBQUosQ0FBZThmLG1CQUFmLEVBQW9DL2dCLElBQXBDLENBQXlDbUwsS0FBS3lWLGVBQTlDLEVBQStEcmdCLEVBQS9ELENBQWtFNEssS0FBSzFhLE1BQXZFO0FBQ0EvZCxVQUFJdXVCLFVBQUosQ0FBZTRlLGVBQWYsRUFBZ0M3ZixJQUFoQyxDQUFxQ21MLEtBQUt5VixlQUExQyxFQUEyRHJnQixFQUEzRCxDQUE4RDRLLEtBQUt0VyxPQUFuRTtBQUNELEtBSEQ7O0FBS0EsU0FBS3RiLE1BQUwsQ0FBWXlpQixPQUFaLENBQW9CLGVBQXBCLEVBQXFDLFlBQVk7QUFDL0N0cEIsVUFBSXV1QixVQUFKLENBQWU4ZixtQkFBZixFQUFvQy9nQixJQUFwQyxDQUF5Q21MLEtBQUswVixjQUE5QyxFQUE4RHRnQixFQUE5RCxDQUFpRTRLLEtBQUsxYSxNQUF0RTtBQUNBL2QsVUFBSXV1QixVQUFKLENBQWU0ZSxlQUFmLEVBQWdDN2YsSUFBaEMsQ0FBcUNtTCxLQUFLMFYsY0FBMUMsRUFBMER0Z0IsRUFBMUQsQ0FBNkQ0SyxLQUFLdFcsT0FBbEU7QUFDRCxLQUhEOztBQUtBLFdBQU8sSUFBUDtBQUNELEdBaEZEO0FBaUZELENBeEphLEVBd0pYdGlCLFNBeEpXLEUsQ0F3SkM7Ozs7Ozs7O0FBUWYsQ0FBQyxVQUFVQSxTQUFWLEVBQXFCO0FBQ3BCLE1BQUlHLE1BQU1ILFVBQVVHLEdBQXBCO0FBQUEsTUFDSXFrQixVQUFVeGtCLFVBQVV3a0IsT0FEeEI7OztBQUdBOzs7QUFHQW9xQixjQUFZO0FBQ1YsVUFBTSxNQURJLEVBQ0k7QUFDZCxVQUFNLFFBRkksRUFFTTtBQUNoQixVQUFNLFdBSEksQ0FHUTtBQUhSLEdBTlo7O0FBWUE1dUMsWUFBVVEsS0FBVixDQUFnQm9yQyxRQUFoQixDQUF5QjdyQyxTQUF6QixDQUFtQzBwQixPQUFuQyxHQUE2QyxZQUFZO0FBQ3ZELFFBQUltUCxPQUFPLElBQVg7QUFBQSxRQUNJOEwsUUFBUSxLQUFLc0YsUUFBTCxFQURaO0FBQUEsUUFFSTlyQixTQUFTLEtBQUtpc0IsT0FBTCxDQUFhMVIsU0FBYixFQUZiO0FBQUEsUUFHSW5XLFVBQVUsS0FBS0EsT0FIbkI7QUFBQSxRQUlJdXNCLG1CQUFtQnJxQixRQUFRa0MsK0JBQVIsS0FBNENwRSxPQUE1QyxHQUFzRCxLQUFLNm5CLE9BQUwsQ0FBYXBoQyxTQUFiLEVBSjdFOzs7QUFNQTtBQUNBK2xDLGtCQUFjdHFCLFFBQVF5QixhQUFSLENBQXNCLE1BQXRCLElBQWdDLENBQUMsTUFBRCxFQUFTLE9BQVQsQ0FBaEMsR0FBb0QsQ0FBQyxVQUFELEVBQWEsT0FBYixDQVBsRTs7QUFTQTtBQUNBOWxCLFFBQUlzcEIsT0FBSixDQUFZdkwsTUFBWixFQUFvQixnQkFBcEIsRUFBc0MsWUFBWTtBQUNoRDZzQixvQkFBY2dFLHNCQUFkO0FBQ0FuVyxXQUFLNXhCLE1BQUwsQ0FBWTZpQixJQUFaLENBQWlCLGtCQUFqQjtBQUNELEtBSEQ7O0FBS0E7QUFDQSxRQUFJa2xCLHlCQUF5Qi9ELFlBQVksWUFBWTtBQUNuRCxVQUFJLENBQUM3cUMsSUFBSTZWLFFBQUosQ0FBYTdSLFNBQVNtTyxlQUF0QixFQUF1QzRMLE1BQXZDLENBQUwsRUFBcUQ7QUFDbkQ2c0Isc0JBQWNnRSxzQkFBZDtBQUNBblcsYUFBSzV4QixNQUFMLENBQVk2aUIsSUFBWixDQUFpQixrQkFBakI7QUFDRDtBQUNGLEtBTDRCLEVBSzFCLEdBTDBCLENBQTdCOztBQU9BO0FBQ0ExcEIsUUFBSXNwQixPQUFKLENBQVlvbEIsZ0JBQVosRUFBOEIsT0FBOUIsRUFBdUMsWUFBWTtBQUNqRGpXLFdBQUs1eEIsTUFBTCxDQUFZNmlCLElBQVosQ0FBaUIsT0FBakIsRUFBMEJBLElBQTFCLENBQStCLGdCQUEvQjs7QUFFQTtBQUNBO0FBQ0FnUSxpQkFBVyxZQUFZO0FBQ3JCNkssZ0JBQVE5TCxLQUFLb1IsUUFBTCxFQUFSO0FBQ0QsT0FGRCxFQUVHLENBRkg7QUFHRCxLQVJEOztBQVVBN3BDLFFBQUlzcEIsT0FBSixDQUFZb2xCLGdCQUFaLEVBQThCLE1BQTlCLEVBQXNDLFlBQVk7QUFDaEQsVUFBSW5LLFVBQVU5TCxLQUFLb1IsUUFBTCxFQUFkLEVBQStCO0FBQzdCcFIsYUFBSzV4QixNQUFMLENBQVk2aUIsSUFBWixDQUFpQixRQUFqQixFQUEyQkEsSUFBM0IsQ0FBZ0MsaUJBQWhDO0FBQ0Q7QUFDRCtPLFdBQUs1eEIsTUFBTCxDQUFZNmlCLElBQVosQ0FBaUIsTUFBakIsRUFBeUJBLElBQXpCLENBQThCLGVBQTlCO0FBQ0QsS0FMRDs7QUFPQSxRQUFJN3BCLFVBQVV3a0IsT0FBVixDQUFrQnVCLEtBQWxCLEVBQUosRUFBK0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E1bEIsVUFBSXNwQixPQUFKLENBQVluSCxPQUFaLEVBQXFCLE1BQXJCLEVBQTZCLFlBQVk7QUFDdkMsWUFBSW9HLFFBQVFwRyxRQUFReFosYUFBUixDQUFzQnpDLGFBQXRCLENBQW9DLE9BQXBDLENBQVo7QUFBQSxZQUNJd25DLG9CQUFvQjFwQyxTQUFTbU8sZUFBVCxDQUF5QnVzQixTQUF6QixJQUFzQzE2QixTQUFTRyxJQUFULENBQWN1NkIsU0FENUU7QUFBQSxZQUVJaVAscUJBQXFCM3BDLFNBQVNtTyxlQUFULENBQXlCeXNCLFVBQXpCLElBQXVDNTZCLFNBQVNHLElBQVQsQ0FBY3k2QixVQUY5RTtBQUdBLFlBQUk7QUFDRm5HLGVBQUtyNEIsU0FBTCxDQUFlK1MsVUFBZixDQUEwQm9WLEtBQTFCO0FBQ0QsU0FGRCxDQUVFLE9BQU8zaUIsQ0FBUCxFQUFVO0FBQ1Z1YyxrQkFBUS9aLFdBQVIsQ0FBb0JtZ0IsS0FBcEI7QUFDRDtBQUNEQSxjQUFNL0YsS0FBTjtBQUNBK0YsY0FBTXpoQixVQUFOLENBQWlCK0ksV0FBakIsQ0FBNkIwWSxLQUE3Qjs7QUFFQXhuQixlQUFPK3NDLFFBQVAsQ0FBZ0JILGtCQUFoQixFQUFvQ0QsaUJBQXBDO0FBQ0QsT0FiRDtBQWNEOztBQUVEO0FBQ0ExdEMsUUFBSXNwQixPQUFKLENBQVluSCxPQUFaLEVBQXFCLFdBQXJCLEVBQWtDLFlBQVk7QUFDNUNzVyxXQUFLNXhCLE1BQUwsQ0FBWTZpQixJQUFaLENBQWlCLG1CQUFqQjtBQUNELEtBRkQ7O0FBSUEsUUFBSXJGLFFBQVFtQyx3Q0FBUixFQUFKLEVBQXdEO0FBQ3REeG1CLFVBQUlzcEIsT0FBSixDQUFZbkgsT0FBWixFQUFxQixDQUFDLFVBQUQsRUFBYSxXQUFiLENBQXJCLEVBQWdELFVBQVU2TSxLQUFWLEVBQWlCO0FBQy9EQSxjQUFNbUQsY0FBTjtBQUNELE9BRkQ7QUFHRDs7QUFFRG55QixRQUFJc3BCLE9BQUosQ0FBWW5ILE9BQVosRUFBcUJ3c0IsV0FBckIsRUFBa0MsVUFBVTNmLEtBQVYsRUFBaUI7QUFDakQsVUFBSTZmLGVBQWU3ZixNQUFNNmYsWUFBekI7QUFBQSxVQUNJdmtDLElBREo7O0FBR0EsVUFBSXVrQyxnQkFBZ0J4cUIsUUFBUW9DLG9CQUFSLEVBQXBCLEVBQW9EO0FBQ2xEbmMsZUFBT3VrQyxhQUFham9CLE9BQWIsQ0FBcUIsV0FBckIsS0FBcUNpb0IsYUFBYWpvQixPQUFiLENBQXFCLFlBQXJCLENBQTVDO0FBQ0Q7QUFDRCxVQUFJdGMsSUFBSixFQUFVO0FBQ1I2WCxnQkFBUUssS0FBUjtBQUNBaVcsYUFBSzE0QixRQUFMLENBQWN5OUIsSUFBZCxDQUFtQixZQUFuQixFQUFpQ2x6QixJQUFqQztBQUNBbXVCLGFBQUs1eEIsTUFBTCxDQUFZNmlCLElBQVosQ0FBaUIsT0FBakIsRUFBMEJBLElBQTFCLENBQStCLGdCQUEvQjtBQUNBc0YsY0FBTW9ELGVBQU47QUFDQXBELGNBQU1tRCxjQUFOO0FBQ0QsT0FORCxNQU1PO0FBQ0x1SCxtQkFBVyxZQUFZO0FBQ3JCakIsZUFBSzV4QixNQUFMLENBQVk2aUIsSUFBWixDQUFpQixPQUFqQixFQUEwQkEsSUFBMUIsQ0FBK0IsZ0JBQS9CO0FBQ0QsU0FGRCxFQUVHLENBRkg7QUFHRDtBQUNGLEtBbEJEOztBQW9CQTtBQUNBMXBCLFFBQUlzcEIsT0FBSixDQUFZbkgsT0FBWixFQUFxQixPQUFyQixFQUE4QixVQUFVNk0sS0FBVixFQUFpQjtBQUM3QyxVQUFJeU4sVUFBVXpOLE1BQU15TixPQUFwQjtBQUNBLFVBQUlBLFlBQVk1OEIsVUFBVWMsU0FBMUIsRUFBcUM7QUFDbkM4M0IsYUFBSzV4QixNQUFMLENBQVk2aUIsSUFBWixDQUFpQixrQkFBakI7QUFDRDtBQUNGLEtBTEQ7O0FBT0EsU0FBSzdpQixNQUFMLENBQVl5aUIsT0FBWixDQUFvQixnQkFBcEIsRUFBc0MsWUFBWTtBQUNoRG9RLGlCQUFXLFlBQVk7QUFDckJqQixhQUFLNXhCLE1BQUwsQ0FBWTZpQixJQUFaLENBQWlCLGtCQUFqQjtBQUNELE9BRkQsRUFFRyxDQUZIO0FBR0QsS0FKRDs7QUFNQTtBQUNBLFFBQUksQ0FBQ3JGLFFBQVF1RCxnQ0FBUixFQUFMLEVBQWlEO0FBQy9DNW5CLFVBQUlzcEIsT0FBSixDQUFZbkgsT0FBWixFQUFxQixXQUFyQixFQUFrQyxVQUFVNk0sS0FBVixFQUFpQjtBQUNqRCxZQUFJcmlCLFNBQVNxaUIsTUFBTXJpQixNQUFuQjtBQUNBLFlBQUlBLE9BQU9sQyxRQUFQLEtBQW9CLEtBQXhCLEVBQStCO0FBQzdCZ3VCLGVBQUtyNEIsU0FBTCxDQUFlMlQsVUFBZixDQUEwQnBILE1BQTFCO0FBQ0FxaUIsZ0JBQU1tRCxjQUFOO0FBQ0Q7QUFDRixPQU5EO0FBT0Q7O0FBRUQ7QUFDQW55QixRQUFJc3BCLE9BQUosQ0FBWW5ILE9BQVosRUFBcUIsU0FBckIsRUFBZ0MsVUFBVTZNLEtBQVYsRUFBaUI7QUFDL0MsVUFBSXlOLFVBQVV6TixNQUFNeU4sT0FBcEI7QUFBQSxVQUNJeFYsVUFBVXduQixVQUFVaFMsT0FBVixDQURkO0FBRUEsVUFBSSxDQUFDek4sTUFBTW1iLE9BQU4sSUFBaUJuYixNQUFNb2IsT0FBeEIsS0FBb0MsQ0FBQ3BiLE1BQU1rYixNQUEzQyxJQUFxRGpqQixPQUF6RCxFQUFrRTtBQUNoRXdSLGFBQUsxNEIsUUFBTCxDQUFjeTlCLElBQWQsQ0FBbUJ2VyxPQUFuQjtBQUNBK0gsY0FBTW1ELGNBQU47QUFDRDtBQUNGLEtBUEQ7O0FBU0E7QUFDQW55QixRQUFJc3BCLE9BQUosQ0FBWW5ILE9BQVosRUFBcUIsU0FBckIsRUFBZ0MsVUFBVTZNLEtBQVYsRUFBaUI7QUFDL0MsVUFBSXJpQixTQUFTOHJCLEtBQUtyNEIsU0FBTCxDQUFlczhCLGVBQWYsQ0FBK0IsSUFBL0IsQ0FBYjtBQUFBLFVBQ0lELFVBQVV6TixNQUFNeU4sT0FEcEI7QUFBQSxVQUVJNTFCLE1BRko7QUFHQSxVQUFJOEYsVUFBVUEsT0FBT2xDLFFBQVAsS0FBb0IsS0FBOUIsS0FBd0NneUIsWUFBWTU4QixVQUFVYSxhQUF0QixJQUF1Qys3QixZQUFZNThCLFVBQVVpQixVQUFyRyxDQUFKLEVBQXNIO0FBQ3BIO0FBQ0ErRixpQkFBUzhGLE9BQU83RixVQUFoQjtBQUNBO0FBQ0FELGVBQU9nSixXQUFQLENBQW1CbEQsTUFBbkI7QUFDQTtBQUNBLFlBQUk5RixPQUFPNEQsUUFBUCxLQUFvQixHQUFwQixJQUEyQixDQUFDNUQsT0FBT21ELFVBQXZDLEVBQW1EO0FBQ2pEbkQsaUJBQU9DLFVBQVAsQ0FBa0IrSSxXQUFsQixDQUE4QmhKLE1BQTlCO0FBQ0Q7O0FBRUQ2eUIsbUJBQVcsWUFBWTtBQUNyQjc1QixvQkFBVUksTUFBVixDQUFpQnc5QixNQUFqQixDQUF3QnRiLE9BQXhCO0FBQ0QsU0FGRCxFQUVHLENBRkg7QUFHQTZNLGNBQU1tRCxjQUFOO0FBQ0Q7QUFDRixLQW5CRDs7QUFxQkE7QUFDQSxRQUFJMmMsZ0JBQWdCO0FBQ2xCQyxXQUFLLFNBRGE7QUFFbEJDLFNBQUc7QUFGZSxLQUFwQjs7QUFLQWh2QyxRQUFJc3BCLE9BQUosQ0FBWW5ILE9BQVosRUFBcUIsV0FBckIsRUFBa0MsVUFBVTZNLEtBQVYsRUFBaUI7QUFDakQsVUFBSXJpQixTQUFTcWlCLE1BQU1yaUIsTUFBbkI7QUFBQSxVQUNJbEMsV0FBV2tDLE9BQU9sQyxRQUR0QjtBQUFBLFVBRUl3a0MsS0FGSjtBQUdBLFVBQUl4a0MsYUFBYSxHQUFiLElBQW9CQSxhQUFhLEtBQXJDLEVBQTRDO0FBQzFDO0FBQ0Q7QUFDRCxVQUFJeWtDLFdBQVd2aUMsT0FBT21wQixZQUFQLENBQW9CLE9BQXBCLENBQWY7QUFDQSxVQUFJLENBQUNvWixRQUFMLEVBQWU7QUFDYkQsZ0JBQVFILGNBQWNya0MsUUFBZCxLQUEyQmtDLE9BQU9nYixZQUFQLENBQW9CLE1BQXBCLEtBQStCaGIsT0FBT2diLFlBQVAsQ0FBb0IsS0FBcEIsQ0FBMUQsQ0FBUjtBQUNBaGIsZUFBTzJaLFlBQVAsQ0FBb0IsT0FBcEIsRUFBNkIyb0IsS0FBN0I7QUFDRDtBQUNGLEtBWkQ7QUFhRCxHQXpLRDtBQTBLRCxDQXZMRCxFQXVMR3B2QyxTQXZMSCxFLENBdUxlOzs7QUFHZixDQUFDLFVBQVVBLFNBQVYsRUFBcUI7QUFDcEIsTUFBSXN2QyxXQUFXLEdBQWY7O0FBRUF0dkMsWUFBVVEsS0FBVixDQUFnQit1QyxZQUFoQixHQUErQnpzQixLQUFLbGYsTUFBTDtBQUMvQixzREFBb0Q7O0FBRWxEOUQsaUJBQWEsU0FBU0EsV0FBVCxDQUFxQjA2QixNQUFyQixFQUE2QnNSLFFBQTdCLEVBQXVDelAsUUFBdkMsRUFBaUQ7QUFDNUQsV0FBSzdCLE1BQUwsR0FBY0EsTUFBZDtBQUNBLFdBQUtzUixRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFdBQUt6UCxRQUFMLEdBQWdCQSxRQUFoQjs7QUFFQSxXQUFLNk4sUUFBTDtBQUNELEtBUmlEOztBQVVsRDs7Ozs7QUFLQXNGLDRCQUF3QixTQUFTQSxzQkFBVCxDQUFnQ0MsZUFBaEMsRUFBaUQ7QUFDdkUsV0FBSzNELFFBQUwsQ0FBYzlRLFFBQWQsQ0FBdUJoN0IsVUFBVU0sSUFBVixDQUFla3FCLE1BQWYsQ0FBc0IsS0FBSzZSLFFBQUwsQ0FBYzJOLFFBQWQsRUFBdEIsRUFBZ0R0ZixJQUFoRCxFQUF2QixFQUErRStrQixlQUEvRTtBQUNELEtBakJpRDs7QUFtQmxEOzs7OztBQUtBQyw0QkFBd0IsU0FBU0Esc0JBQVQsQ0FBZ0NELGVBQWhDLEVBQWlEO0FBQ3ZFLFVBQUlFLGdCQUFnQixLQUFLN0QsUUFBTCxDQUFjOUIsUUFBZCxFQUFwQjtBQUNBLFVBQUkyRixhQUFKLEVBQW1CO0FBQ2pCLGFBQUt0VCxRQUFMLENBQWNyQixRQUFkLENBQXVCMlUsYUFBdkIsRUFBc0NGLGVBQXRDO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBS3BULFFBQUwsQ0FBY3ZCLEtBQWQ7QUFDQSxhQUFLTixNQUFMLENBQVkzUSxJQUFaLENBQWlCLGlCQUFqQjtBQUNEO0FBQ0YsS0FoQ2lEOztBQWtDbEQ7Ozs7QUFJQThpQixVQUFNLFNBQVNBLElBQVQsQ0FBYzhDLGVBQWQsRUFBK0I7QUFDbkMsVUFBSSxLQUFLalYsTUFBTCxDQUFZK1EsV0FBWixDQUF3QmxtQyxJQUF4QixLQUFpQyxVQUFyQyxFQUFpRDtBQUMvQyxhQUFLcXFDLHNCQUFMLENBQTRCRCxlQUE1QjtBQUNELE9BRkQsTUFFTztBQUNMLGFBQUtELHNCQUFMLENBQTRCQyxlQUE1QjtBQUNEO0FBQ0YsS0E1Q2lEOztBQThDbEQ7Ozs7O0FBS0F2RixjQUFVLFNBQVNBLFFBQVQsR0FBb0I7QUFDNUIsVUFBSVcsUUFBSjtBQUFBLFVBQ0lqUyxPQUFPLElBRFg7QUFBQSxVQUVJZ1gsT0FBTyxLQUFLOUQsUUFBTCxDQUFjeHBCLE9BQWQsQ0FBc0JzdEIsSUFGakM7QUFBQSxVQUdJQyxnQkFBZ0IsU0FBU0EsYUFBVCxHQUF5QjtBQUMzQ2hGLG1CQUFXRyxZQUFZLFlBQVk7QUFDakNwUyxlQUFLNFcsc0JBQUw7QUFDRCxTQUZVLEVBRVJGLFFBRlEsQ0FBWDtBQUdELE9BUEQ7QUFBQSxVQVFJUSxlQUFlLFNBQVNBLFlBQVQsR0FBd0I7QUFDekMvRSxzQkFBY0YsUUFBZDtBQUNBQSxtQkFBVyxJQUFYO0FBQ0QsT0FYRDs7QUFhQWdGOztBQUVBLFVBQUlELElBQUosRUFBVTtBQUNSO0FBQ0E7QUFDQTV2QyxrQkFBVUcsR0FBVixDQUFjc3BCLE9BQWQsQ0FBc0JtbUIsSUFBdEIsRUFBNEIsUUFBNUIsRUFBc0MsWUFBWTtBQUNoRGhYLGVBQUsrVCxJQUFMLENBQVUsSUFBVjtBQUNELFNBRkQ7QUFHQTNzQyxrQkFBVUcsR0FBVixDQUFjc3BCLE9BQWQsQ0FBc0JtbUIsSUFBdEIsRUFBNEIsT0FBNUIsRUFBcUMsWUFBWTtBQUMvQy9WLHFCQUFXLFlBQVk7QUFDckJqQixpQkFBSzhXLHNCQUFMO0FBQ0QsV0FGRCxFQUVHLENBRkg7QUFHRCxTQUpEO0FBS0Q7O0FBRUQsV0FBS2xWLE1BQUwsQ0FBWS9RLE9BQVosQ0FBb0IsYUFBcEIsRUFBbUMsVUFBVWdSLElBQVYsRUFBZ0I7QUFDakQsWUFBSUEsU0FBUyxVQUFULElBQXVCLENBQUNvUSxRQUE1QixFQUFzQztBQUNwQ2pTLGVBQUs4VyxzQkFBTCxDQUE0QixJQUE1QjtBQUNBRztBQUNELFNBSEQsTUFHTyxJQUFJcFYsU0FBUyxVQUFiLEVBQXlCO0FBQzlCN0IsZUFBSzRXLHNCQUFMLENBQTRCLElBQTVCO0FBQ0FNO0FBQ0Q7QUFDRixPQVJEOztBQVVBLFdBQUt0VixNQUFMLENBQVkvUSxPQUFaLENBQW9CLGtCQUFwQixFQUF3Q3FtQixZQUF4QztBQUNEO0FBM0ZpRCxHQURyQixDQUEvQjtBQThGRCxDQWpHRCxFQWlHRzl2QyxTQWpHSDtBQWtHQUEsVUFBVVEsS0FBVixDQUFnQnV2QyxRQUFoQixHQUEyQi92QyxVQUFVUSxLQUFWLENBQWdCNHFDLElBQWhCLENBQXFCeG5DLE1BQXJCO0FBQzNCLGdEQUFnRDtBQUM5Q3lCLFFBQU0sVUFEd0M7O0FBRzlDdkYsZUFBYSxTQUFTQSxXQUFULENBQXFCa0gsTUFBckIsRUFBNkJxa0MsZUFBN0IsRUFBOENyb0MsTUFBOUMsRUFBc0Q7QUFDakUsU0FBS21nQixJQUFMLENBQVVuYyxNQUFWLEVBQWtCcWtDLGVBQWxCLEVBQW1Dcm9DLE1BQW5DOztBQUVBLFNBQUtrbkMsUUFBTDtBQUNELEdBUDZDOztBQVM5Q3BQLFNBQU8sU0FBU0EsS0FBVCxHQUFpQjtBQUN0QixTQUFLeFksT0FBTCxDQUFhc0IsS0FBYixHQUFxQixFQUFyQjtBQUNELEdBWDZDOztBQWE5Q29tQixZQUFVLFNBQVNBLFFBQVQsQ0FBa0JyWCxLQUFsQixFQUF5QjtBQUNqQyxRQUFJL08sUUFBUSxLQUFLbVgsT0FBTCxLQUFpQixFQUFqQixHQUFzQixLQUFLelksT0FBTCxDQUFhc0IsS0FBL0M7QUFDQSxRQUFJK08sS0FBSixFQUFXO0FBQ1QvTyxjQUFRLEtBQUs1YyxNQUFMLENBQVkyckIsS0FBWixDQUFrQi9PLEtBQWxCLENBQVI7QUFDRDtBQUNELFdBQU9BLEtBQVA7QUFDRCxHQW5CNkM7O0FBcUI5Q29YLFlBQVUsU0FBU0EsUUFBVCxDQUFrQnhZLElBQWxCLEVBQXdCbVEsS0FBeEIsRUFBK0I7QUFDdkMsUUFBSUEsS0FBSixFQUFXO0FBQ1RuUSxhQUFPLEtBQUt4YixNQUFMLENBQVkyckIsS0FBWixDQUFrQm5RLElBQWxCLENBQVA7QUFDRDtBQUNELFNBQUtGLE9BQUwsQ0FBYXNCLEtBQWIsR0FBcUJwQixJQUFyQjtBQUNELEdBMUI2Qzs7QUE0QjlDcVkscUJBQW1CLFNBQVNBLGlCQUFULEdBQTZCO0FBQzlDLFFBQUltVixzQkFBc0Jod0MsVUFBVXdrQixPQUFWLENBQWtCK0IsOEJBQWxCLENBQWlELEtBQUtqRSxPQUF0RCxDQUExQjtBQUFBLFFBQ0lvWSxrQkFBa0IsS0FBS3BZLE9BQUwsQ0FBYXdGLFlBQWIsQ0FBMEIsYUFBMUIsS0FBNEMsSUFEbEU7QUFBQSxRQUVJbEUsUUFBUSxLQUFLdEIsT0FBTCxDQUFhc0IsS0FGekI7QUFBQSxRQUdJbVgsVUFBVSxDQUFDblgsS0FIZjtBQUlBLFdBQU9vc0IsdUJBQXVCalYsT0FBdkIsSUFBa0NuWCxVQUFVOFcsZUFBbkQ7QUFDRCxHQWxDNkM7O0FBb0M5Q0ssV0FBUyxTQUFTQSxPQUFULEdBQW1CO0FBQzFCLFdBQU8sQ0FBQy82QixVQUFVTSxJQUFWLENBQWVrcUIsTUFBZixDQUFzQixLQUFLbEksT0FBTCxDQUFhc0IsS0FBbkMsRUFBMEM4RyxJQUExQyxFQUFELElBQXFELEtBQUttUSxpQkFBTCxFQUE1RDtBQUNELEdBdEM2Qzs7QUF3QzlDcVAsWUFBVSxTQUFTQSxRQUFULEdBQW9CO0FBQzVCLFFBQUk1bkIsVUFBVSxLQUFLQSxPQUFuQjtBQUFBLFFBQ0l0YixTQUFTLEtBQUtBLE1BRGxCO0FBQUEsUUFFSWlwQyxlQUFlO0FBQ2pCQyxlQUFTLE9BRFE7QUFFakJDLGdCQUFVO0FBRk8sS0FGbkI7OztBQU9BOzs7O0FBSUF4bUIsYUFBUzNwQixVQUFVd2tCLE9BQVYsQ0FBa0J5QixhQUFsQixDQUFnQyxTQUFoQyxJQUE2QyxDQUFDLFNBQUQsRUFBWSxVQUFaLEVBQXdCLFFBQXhCLENBQTdDLEdBQWlGLENBQUMsT0FBRCxFQUFVLE1BQVYsRUFBa0IsUUFBbEIsQ0FYMUY7O0FBYUFqZixXQUFPeWlCLE9BQVAsQ0FBZSxZQUFmLEVBQTZCLFlBQVk7QUFDdkN6cEIsZ0JBQVVHLEdBQVYsQ0FBY3NwQixPQUFkLENBQXNCbkgsT0FBdEIsRUFBK0JxSCxNQUEvQixFQUF1QyxVQUFVd0YsS0FBVixFQUFpQjtBQUN0RCxZQUFJM0ksWUFBWXlwQixhQUFhOWdCLE1BQU0xaUIsSUFBbkIsS0FBNEIwaUIsTUFBTTFpQixJQUFsRDtBQUNBekYsZUFBTzZpQixJQUFQLENBQVlyRCxTQUFaLEVBQXVCcUQsSUFBdkIsQ0FBNEJyRCxZQUFZLFdBQXhDO0FBQ0QsT0FIRDs7QUFLQXhtQixnQkFBVUcsR0FBVixDQUFjc3BCLE9BQWQsQ0FBc0JuSCxPQUF0QixFQUErQixDQUFDLE9BQUQsRUFBVSxNQUFWLENBQS9CLEVBQWtELFlBQVk7QUFDNUR1WCxtQkFBVyxZQUFZO0FBQ3JCN3lCLGlCQUFPNmlCLElBQVAsQ0FBWSxPQUFaLEVBQXFCQSxJQUFyQixDQUEwQixnQkFBMUI7QUFDRCxTQUZELEVBRUcsQ0FGSDtBQUdELE9BSkQ7QUFLRCxLQVhEO0FBWUQ7QUFsRTZDLENBRHJCLENBQTNCLEMsQ0FvRUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCSixDQUFDLFVBQVU3cEIsU0FBVixFQUFxQjtBQUNwQixNQUFJRyxNQUFNSCxVQUFVRyxHQUFwQjtBQUFBLE1BQ0lpd0Msb0JBQW9CLGlDQUR4QjtBQUFBLE1BRUlDLHlCQUF5Qix5QkFGN0I7QUFBQSxNQUdJQyxrQkFBa0IsK0JBSHRCO0FBQUEsTUFJSUMsbUJBQW1CLDZCQUp2Qjs7QUFNQXZ3QyxZQUFVSyxPQUFWLENBQWtCbXdDLE1BQWxCLEdBQTJCeHdDLFVBQVVNLElBQVYsQ0FBZWtwQixVQUFmLENBQTBCNWxCLE1BQTFCO0FBQzNCLGtEQUFnRDtBQUM5QzlELGlCQUFhLFNBQVNBLFdBQVQsQ0FBcUJrdEMsSUFBckIsRUFBMkJyNEIsU0FBM0IsRUFBc0M7QUFDakQsV0FBS3E0QixJQUFMLEdBQVlBLElBQVo7QUFDQSxXQUFLcjRCLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0QsS0FKNkM7O0FBTTlDdTFCLGNBQVUsU0FBU0EsUUFBVCxHQUFvQjtBQUM1QixVQUFJLEtBQUt1RyxTQUFULEVBQW9CO0FBQ2xCO0FBQ0Q7O0FBRUQsVUFBSTdYLE9BQU8sSUFBWDtBQUFBLFVBQ0k4WCxrQkFBa0IsU0FBU0EsZUFBVCxDQUF5QnZoQixLQUF6QixFQUFnQztBQUNwRCxZQUFJNEUsYUFBYTZFLEtBQUsrWCxVQUFMLEVBQWpCO0FBQ0EsWUFBSTVjLGNBQWM2RSxLQUFLZ1ksZUFBdkIsRUFBd0M7QUFDdENoWSxlQUFLL08sSUFBTCxDQUFVLE1BQVYsRUFBa0JrSyxVQUFsQjtBQUNELFNBRkQsTUFFTztBQUNMNkUsZUFBSy9PLElBQUwsQ0FBVSxNQUFWLEVBQWtCa0ssVUFBbEI7QUFDRDtBQUNENkUsYUFBSzZTLElBQUw7QUFDQXRjLGNBQU1tRCxjQUFOO0FBQ0FuRCxjQUFNb0QsZUFBTjtBQUNELE9BWEQ7O0FBYUFweUIsVUFBSXNwQixPQUFKLENBQVltUCxLQUFLb1UsSUFBakIsRUFBdUIsT0FBdkIsRUFBZ0MsVUFBVTdkLEtBQVYsRUFBaUI7QUFDL0MsWUFBSWh2QixJQUFJb3NCLFFBQUosQ0FBYXFNLEtBQUtvVSxJQUFsQixFQUF3Qm9ELGlCQUF4QixDQUFKLEVBQWdEO0FBQzlDdlcscUJBQVcsWUFBWTtBQUNyQmpCLGlCQUFLNlMsSUFBTDtBQUNELFdBRkQsRUFFRyxDQUZIO0FBR0Q7QUFDRixPQU5EOztBQVFBdHJDLFVBQUlzcEIsT0FBSixDQUFZLEtBQUs5VSxTQUFqQixFQUE0QixTQUE1QixFQUF1QyxVQUFVd2EsS0FBVixFQUFpQjtBQUN0RCxZQUFJeU4sVUFBVXpOLE1BQU15TixPQUFwQjtBQUNBLFlBQUlBLFlBQVk1OEIsVUFBVWMsU0FBMUIsRUFBcUM7QUFDbkM0dkMsMEJBQWdCdmhCLEtBQWhCO0FBQ0Q7QUFDRCxZQUFJeU4sWUFBWTU4QixVQUFVZSxVQUExQixFQUFzQztBQUNwQztBQUNEO0FBQ0YsT0FSRDs7QUFVQVosVUFBSTh1QixRQUFKLENBQWEsS0FBS3RhLFNBQWxCLEVBQTZCLHFDQUE3QixFQUFvRSxPQUFwRSxFQUE2RSs3QixlQUE3RTs7QUFFQXZ3QyxVQUFJOHVCLFFBQUosQ0FBYSxLQUFLdGEsU0FBbEIsRUFBNkIsdUNBQTdCLEVBQXNFLE9BQXRFLEVBQStFLFVBQVV3YSxLQUFWLEVBQWlCO0FBQzlGeUosYUFBSy9PLElBQUwsQ0FBVSxRQUFWO0FBQ0ErTyxhQUFLNlMsSUFBTDtBQUNBdGMsY0FBTW1ELGNBQU47QUFDQW5ELGNBQU1vRCxlQUFOO0FBQ0QsT0FMRDs7QUFPQSxVQUFJc2UsZUFBZSxLQUFLbDhCLFNBQUwsQ0FBZWtSLGdCQUFmLENBQWdDd3FCLHNCQUFoQyxDQUFuQjtBQUFBLFVBQ0lsdUMsSUFBSSxDQURSO0FBQUEsVUFFSUMsU0FBU3l1QyxhQUFhenVDLE1BRjFCO0FBQUEsVUFHSTB1QyxpQkFBaUIsU0FBU0EsY0FBVCxHQUEwQjtBQUM3Qy9GLHNCQUFjblMsS0FBS2lTLFFBQW5CO0FBQ0QsT0FMRDtBQU1BLGFBQU8xb0MsSUFBSUMsTUFBWCxFQUFtQkQsR0FBbkIsRUFBd0I7QUFDdEJoQyxZQUFJc3BCLE9BQUosQ0FBWW9uQixhQUFhMXVDLENBQWIsQ0FBWixFQUE2QixRQUE3QixFQUF1QzJ1QyxjQUF2QztBQUNEOztBQUVELFdBQUtMLFNBQUwsR0FBaUIsSUFBakI7QUFDRCxLQTlENkM7O0FBZ0U5Qzs7OztBQUlBRSxnQkFBWSxTQUFTQSxVQUFULEdBQXNCO0FBQ2hDLFVBQUlsbUMsT0FBTyxLQUFLbW1DLGVBQUwsSUFBd0IsRUFBbkM7QUFBQSxVQUNJRyxTQUFTLEtBQUtwOEIsU0FBTCxDQUFla1IsZ0JBQWYsQ0FBZ0N5cUIsZUFBaEMsQ0FEYjtBQUFBLFVBRUlsdUMsU0FBUzJ1QyxPQUFPM3VDLE1BRnBCO0FBQUEsVUFHSUQsSUFBSSxDQUhSO0FBSUEsYUFBT0EsSUFBSUMsTUFBWCxFQUFtQkQsR0FBbkIsRUFBd0I7QUFDdEJzSSxhQUFLc21DLE9BQU81dUMsQ0FBUCxFQUFVMmxCLFlBQVYsQ0FBdUJ5b0IsZ0JBQXZCLENBQUwsSUFBaURRLE9BQU81dUMsQ0FBUCxFQUFVeWhCLEtBQTNEO0FBQ0Q7QUFDRCxhQUFPblosSUFBUDtBQUNELEtBN0U2Qzs7QUErRTlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkF1bUMsa0JBQWMsU0FBU0EsWUFBVCxDQUFzQkMsaUJBQXRCLEVBQXlDO0FBQ3JELFVBQUlDLEtBQUo7QUFBQSxVQUNJQyxTQURKO0FBQUEsVUFFSUMsUUFGSjtBQUFBLFVBR0lDLGlCQUFpQmx0QyxTQUFTeWhCLGFBQVQsQ0FBdUIsUUFBdkIsQ0FIckI7QUFBQSxVQUlJbXJCLFNBQVMsS0FBS3A4QixTQUFMLENBQWVrUixnQkFBZixDQUFnQ3lxQixlQUFoQyxDQUpiO0FBQUEsVUFLSWx1QyxTQUFTMnVDLE9BQU8zdUMsTUFMcEI7QUFBQSxVQU1JRCxJQUFJLENBTlI7QUFPQSxhQUFPQSxJQUFJQyxNQUFYLEVBQW1CRCxHQUFuQixFQUF3QjtBQUN0Qit1QyxnQkFBUUgsT0FBTzV1QyxDQUFQLENBQVI7O0FBRUE7QUFDQSxZQUFJK3VDLFVBQVVHLGNBQWQsRUFBOEI7QUFDNUI7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsWUFBSUoscUJBQXFCQyxNQUFNemtDLElBQU4sS0FBZSxRQUF4QyxFQUFrRDtBQUNoRDtBQUNEOztBQUVEMGtDLG9CQUFZRCxNQUFNcHBCLFlBQU4sQ0FBbUJ5b0IsZ0JBQW5CLENBQVo7QUFDQWEsbUJBQVcsS0FBS1IsZUFBTCxHQUF1QixLQUFLQSxlQUFMLENBQXFCTyxTQUFyQixLQUFtQyxFQUExRCxHQUErREQsTUFBTUksWUFBaEY7QUFDQUosY0FBTXR0QixLQUFOLEdBQWN3dEIsUUFBZDtBQUNEO0FBQ0YsS0EzSDZDOztBQTZIOUM7OztBQUdBNUYsVUFBTSxTQUFTQSxJQUFULENBQWNvRixlQUFkLEVBQStCO0FBQ25DLFVBQUloWSxPQUFPLElBQVg7QUFBQSxVQUNJMlksYUFBYSxLQUFLNThCLFNBQUwsQ0FBZWlSLGFBQWYsQ0FBNkJ5cUIsc0JBQTdCLENBRGpCO0FBRUEsV0FBS08sZUFBTCxHQUF1QkEsZUFBdkI7QUFDQSxXQUFLMUcsUUFBTDtBQUNBLFdBQUs4RyxZQUFMO0FBQ0EsVUFBSUosZUFBSixFQUFxQjtBQUNuQixhQUFLL0YsUUFBTCxHQUFnQkcsWUFBWSxZQUFZO0FBQ3RDcFMsZUFBS29ZLFlBQUwsQ0FBa0IsSUFBbEI7QUFDRCxTQUZlLEVBRWIsR0FGYSxDQUFoQjtBQUdEO0FBQ0Q3d0MsVUFBSWlzQixRQUFKLENBQWEsS0FBSzRnQixJQUFsQixFQUF3Qm9ELGlCQUF4QjtBQUNBLFdBQUt6N0IsU0FBTCxDQUFlMmEsS0FBZixDQUFxQkMsT0FBckIsR0FBK0IsRUFBL0I7QUFDQSxXQUFLMUYsSUFBTCxDQUFVLE1BQVY7QUFDQSxVQUFJMG5CLGNBQWMsQ0FBQ1gsZUFBbkIsRUFBb0M7QUFDbEMsWUFBSTtBQUNGVyxxQkFBVzV1QixLQUFYO0FBQ0QsU0FGRCxDQUVFLE9BQU81YyxDQUFQLEVBQVUsQ0FBRTtBQUNmO0FBQ0YsS0FuSjZDOztBQXFKOUM7OztBQUdBMGxDLFVBQU0sU0FBU0EsSUFBVCxHQUFnQjtBQUNwQlYsb0JBQWMsS0FBS0YsUUFBbkI7QUFDQSxXQUFLK0YsZUFBTCxHQUF1QixJQUF2QjtBQUNBendDLFVBQUlxc0IsV0FBSixDQUFnQixLQUFLd2dCLElBQXJCLEVBQTJCb0QsaUJBQTNCO0FBQ0EsV0FBS3o3QixTQUFMLENBQWUyYSxLQUFmLENBQXFCQyxPQUFyQixHQUErQixNQUEvQjtBQUNBLFdBQUsxRixJQUFMLENBQVUsTUFBVjtBQUNEO0FBOUo2QyxHQURyQixDQUEzQjtBQWlLRCxDQXhLRCxFQXdLRzdwQixTQXhLSDtBQXlLQTs7Ozs7Ozs7Ozs7OztBQWFBLENBQUMsVUFBVUEsU0FBVixFQUFxQjtBQUNwQixNQUFJRyxNQUFNSCxVQUFVRyxHQUFwQjs7QUFFQSxNQUFJcXhDLGFBQWE7QUFDZnZILGNBQVU7QUFESyxHQUFqQjs7QUFJQSxNQUFJd0gsZ0JBQWdCO0FBQ2xCOWEsVUFBTSxDQURZO0FBRWxCK2EsWUFBUSxDQUZVO0FBR2xCQyxhQUFTLENBSFM7QUFJbEIxZ0IsY0FBVSxRQUpRO0FBS2xCMmdCLGFBQVMsQ0FMUztBQU1sQjNILGNBQVUsVUFOUTtBQU9sQm5NLFNBQUssQ0FQYTtBQVFsQitULFlBQVE7QUFSVSxHQUFwQjs7QUFXQSxNQUFJQyxjQUFjO0FBQ2hCQyxZQUFRLFNBRFE7QUFFaEJsTSxjQUFVLE1BRk07QUFHaEIvVyxZQUFRLE1BSFE7QUFJaEJrakIsZUFBVyxPQUpLO0FBS2hCQyxhQUFTLENBTE87QUFNaEJMLGFBQVMsQ0FOTztBQU9oQjNILGNBQVUsVUFQTTtBQVFoQnJULFdBQU8sTUFSUztBQVNoQmtILFNBQUs7QUFUVyxHQUFsQjs7QUFZQSxNQUFJb1Usa0JBQWtCO0FBQ3BCLHVCQUFtQixFQURDO0FBRXBCLGNBQVU7QUFGVSxHQUF0Qjs7QUFLQWx5QyxZQUFVSyxPQUFWLENBQWtCOHhDLE1BQWxCLEdBQTJCLFVBQVVuckMsTUFBVixFQUFrQmdtQyxJQUFsQixFQUF3QjtBQUNqRCxRQUFJdGtCLFFBQVF2a0IsU0FBU2tDLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBWjtBQUNBLFFBQUksQ0FBQ3JHLFVBQVV3a0IsT0FBVixDQUFrQmlFLG1CQUFsQixDQUFzQ0MsS0FBdEMsQ0FBTCxFQUFtRDtBQUNqRHNrQixXQUFLMWQsS0FBTCxDQUFXQyxPQUFYLEdBQXFCLE1BQXJCO0FBQ0E7QUFDRDs7QUFFRCxRQUFJNmlCLFVBQVVqdUMsU0FBU2tDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBZDs7QUFFQXJHLGNBQVVNLElBQVYsQ0FBZTZqQixNQUFmLENBQXNCc3RCLGFBQXRCLEVBQXFDdm5CLEtBQXJDLENBQTJDO0FBQ3pDNEwsYUFBT2tYLEtBQUt2ZSxXQUFMLEdBQW1CLElBRGU7QUFFekNLLGNBQVFrZSxLQUFLamUsWUFBTCxHQUFvQjtBQUZhLEtBQTNDOztBQUtBNXVCLFFBQUl1dEIsTUFBSixDQUFXaEYsS0FBWCxFQUFrQm1KLElBQWxCLENBQXVCdWdCLE9BQXZCO0FBQ0FqeUMsUUFBSXV0QixNQUFKLENBQVcwa0IsT0FBWCxFQUFvQnZnQixJQUFwQixDQUF5Qm1iLElBQXpCOztBQUVBN3NDLFFBQUk2dUIsU0FBSixDQUFjOGlCLFdBQWQsRUFBMkJsb0IsRUFBM0IsQ0FBOEJsQixLQUE5QjtBQUNBdm9CLFFBQUl3MEIsYUFBSixDQUFrQnVkLGVBQWxCLEVBQW1DdG9CLEVBQW5DLENBQXNDbEIsS0FBdEM7O0FBRUF2b0IsUUFBSTZ1QixTQUFKLENBQWN5aUIsYUFBZCxFQUE2QjduQixFQUE3QixDQUFnQ3dvQixPQUFoQztBQUNBanlDLFFBQUk2dUIsU0FBSixDQUFjd2lCLFVBQWQsRUFBMEI1bkIsRUFBMUIsQ0FBNkJvakIsSUFBN0I7O0FBRUEsUUFBSXhtQixZQUFZLDBCQUEwQmtDLEtBQTFCLEdBQWtDLG9CQUFsQyxHQUF5RCxjQUF6RTtBQUNBdm9CLFFBQUlzcEIsT0FBSixDQUFZZixLQUFaLEVBQW1CbEMsU0FBbkIsRUFBOEIsWUFBWTtBQUN4Q3hmLGFBQU93ZSxXQUFQLENBQW1CLFlBQW5CLEVBQWlDa0QsTUFBTTlFLEtBQXZDO0FBQ0E4RSxZQUFNOUUsS0FBTixHQUFjLEVBQWQ7QUFDRCxLQUhEOztBQUtBempCLFFBQUlzcEIsT0FBSixDQUFZZixLQUFaLEVBQW1CLE9BQW5CLEVBQTRCLFVBQVV5RyxLQUFWLEVBQWlCO0FBQzNDLFVBQUlodkIsSUFBSW9zQixRQUFKLENBQWF5Z0IsSUFBYixFQUFtQiw0QkFBbkIsQ0FBSixFQUFzRDtBQUNwRDdkLGNBQU1tRCxjQUFOO0FBQ0Q7O0FBRURuRCxZQUFNb0QsZUFBTjtBQUNELEtBTkQ7QUFPRCxHQXBDRDtBQXFDRCxDQXhFRCxFQXdFR3Z5QixTQXhFSCxFLENBd0VlOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JmLENBQUMsVUFBVUEsU0FBVixFQUFxQjtBQUNwQixNQUFJcXlDLDhCQUE4Qiw0QkFBbEM7QUFBQSxNQUNJQywrQkFBK0IsNkJBRG5DO0FBQUEsTUFFSUMsNEJBQTRCLDBCQUZoQztBQUFBLE1BR0lDLDJCQUEyQix5QkFIL0I7QUFBQSxNQUlJcnlDLE1BQU1ILFVBQVVHLEdBSnBCOztBQU1BSCxZQUFVSyxPQUFWLENBQWtCb3lDLE9BQWxCLEdBQTRCM3ZCLEtBQUtsZixNQUFMO0FBQzVCLG1EQUFpRDtBQUMvQzlELGlCQUFhLFNBQVNBLFdBQVQsQ0FBcUIwNkIsTUFBckIsRUFBNkI3bEIsU0FBN0IsRUFBd0M7QUFDbkQsV0FBSzZsQixNQUFMLEdBQWNBLE1BQWQ7QUFDQSxXQUFLN2xCLFNBQUwsR0FBaUIsT0FBT0EsU0FBUCxLQUFxQixRQUFyQixHQUFnQ3hRLFNBQVNxMEIsY0FBVCxDQUF3QjdqQixTQUF4QixDQUFoQyxHQUFxRUEsU0FBdEY7QUFDQSxXQUFLMG5CLFFBQUwsR0FBZ0I3QixPQUFPNkIsUUFBdkI7O0FBRUEsV0FBS3FXLFNBQUwsQ0FBZSxTQUFmO0FBQ0EsV0FBS0EsU0FBTCxDQUFlLFFBQWY7O0FBRUEsV0FBS3hJLFFBQUw7QUFDQSxXQUFLc0IsSUFBTDs7QUFFQSxVQUFJbUgsbUJBQW1CLEtBQUtoK0IsU0FBTCxDQUFla1IsZ0JBQWYsQ0FBZ0MsdUNBQWhDLENBQXZCO0FBQUEsVUFDSXpqQixTQUFTdXdDLGlCQUFpQnZ3QyxNQUQ5QjtBQUFBLFVBRUlELElBQUksQ0FGUjtBQUdBLGFBQU9BLElBQUlDLE1BQVgsRUFBbUJELEdBQW5CLEVBQXdCO0FBQ3RCLFlBQUluQyxVQUFVSyxPQUFWLENBQWtCOHhDLE1BQXRCLENBQTZCLElBQTdCLEVBQW1DUSxpQkFBaUJ4d0MsQ0FBakIsQ0FBbkM7QUFDRDtBQUNGLEtBbEI4Qzs7QUFvQi9DdXdDLGVBQVcsU0FBU0EsU0FBVCxDQUFtQmptQyxJQUFuQixFQUF5QjtBQUNsQyxVQUFJcWdDLFFBQVEsS0FBS3JnQyxPQUFPLE9BQVosSUFBdUJ6TSxVQUFVTSxJQUFWLENBQWUyb0IsS0FBZixDQUFxQixLQUFLdFUsU0FBTCxDQUFla1IsZ0JBQWYsQ0FBZ0MscUJBQXFCcFosSUFBckIsR0FBNEIsR0FBNUQsQ0FBckIsRUFBdUY2YyxHQUF2RixFQUFuQztBQUFBLFVBQ0lsbkIsU0FBUzBxQyxNQUFNMXFDLE1BRG5CO0FBQUEsVUFFSUQsSUFBSSxDQUZSO0FBQUEsVUFHSXUwQixVQUFVLEtBQUtqcUIsT0FBTyxTQUFaLElBQXlCLEVBSHZDO0FBQUEsVUFJSXVnQyxJQUpKO0FBQUEsVUFLSTRGLEtBTEo7QUFBQSxVQU1JdnRDLElBTko7QUFBQSxVQU9JdWUsS0FQSjtBQUFBLFVBUUlpdkIsTUFSSjtBQVNBLGFBQU8xd0MsSUFBSUMsTUFBWCxFQUFtQkQsR0FBbkIsRUFBd0I7QUFDdEI2cUMsZUFBT0YsTUFBTTNxQyxDQUFOLENBQVA7QUFDQWtELGVBQU8ybkMsS0FBS2xsQixZQUFMLENBQWtCLG9CQUFvQnJiLElBQXRDLENBQVA7QUFDQW1YLGdCQUFRb3BCLEtBQUtsbEIsWUFBTCxDQUFrQixvQkFBb0JyYixJQUFwQixHQUEyQixRQUE3QyxDQUFSO0FBQ0FtbUMsZ0JBQVEsS0FBS2orQixTQUFMLENBQWVpUixhQUFmLENBQTZCLHFCQUFxQm5aLElBQXJCLEdBQTRCLFVBQTVCLEdBQXlDcEgsSUFBekMsR0FBZ0QsSUFBN0UsQ0FBUjtBQUNBd3RDLGlCQUFTLEtBQUtDLFVBQUwsQ0FBZ0I5RixJQUFoQixFQUFzQjNuQyxJQUF0QixDQUFUOztBQUVBcXhCLGdCQUFRcnhCLE9BQU8sR0FBUCxHQUFhdWUsS0FBckIsSUFBOEI7QUFDNUJvcEIsZ0JBQU1BLElBRHNCO0FBRTVCNEYsaUJBQU9BLEtBRnFCO0FBRzVCdnRDLGdCQUFNQSxJQUhzQjtBQUk1QnVlLGlCQUFPQSxLQUpxQjtBQUs1Qml2QixrQkFBUUEsTUFMb0I7QUFNNUJuTyxpQkFBTztBQU5xQixTQUE5QjtBQVFEO0FBQ0YsS0E5QzhDOztBQWdEL0NvTyxnQkFBWSxTQUFTQSxVQUFULENBQW9COUYsSUFBcEIsRUFBMEI1bEIsT0FBMUIsRUFBbUM7QUFDN0MsVUFBSXdSLE9BQU8sSUFBWDtBQUFBLFVBQ0ltYSxnQkFBZ0IsS0FBS3ArQixTQUFMLENBQWVpUixhQUFmLENBQTZCLDZCQUE2QndCLE9BQTdCLEdBQXVDLElBQXBFLENBRHBCO0FBQUEsVUFFSXlyQixNQUZKO0FBQUEsVUFHSUcsYUFISjs7QUFLQSxVQUFJRCxhQUFKLEVBQW1CO0FBQ2pCRixpQkFBUyxJQUFJN3lDLFVBQVVLLE9BQVYsQ0FBa0Jtd0MsTUFBdEIsQ0FBNkJ4RCxJQUE3QixFQUFtQytGLGFBQW5DLENBQVQ7O0FBRUFGLGVBQU9wcEIsT0FBUCxDQUFlLE1BQWYsRUFBdUIsWUFBWTtBQUNqQ3VwQiwwQkFBZ0JwYSxLQUFLeUQsUUFBTCxDQUFjOTdCLFNBQWQsQ0FBd0IwOUIsV0FBeEIsRUFBaEI7O0FBRUFyRixlQUFLNEIsTUFBTCxDQUFZM1EsSUFBWixDQUFpQixhQUFqQixFQUFnQyxFQUFFekMsU0FBU0EsT0FBWCxFQUFvQjZyQixpQkFBaUJGLGFBQXJDLEVBQW9ERyxhQUFhbEcsSUFBakUsRUFBaEM7QUFDRCxTQUpEOztBQU1BNkYsZUFBT3BwQixPQUFQLENBQWUsTUFBZixFQUF1QixVQUFVc0ssVUFBVixFQUFzQjtBQUMzQyxjQUFJaWYsYUFBSixFQUFtQjtBQUNqQnBhLGlCQUFLeUQsUUFBTCxDQUFjOTdCLFNBQWQsQ0FBd0I0OUIsV0FBeEIsQ0FBb0M2VSxhQUFwQztBQUNEO0FBQ0RwYSxlQUFLOE4sWUFBTCxDQUFrQnRmLE9BQWxCLEVBQTJCMk0sVUFBM0I7O0FBRUE2RSxlQUFLNEIsTUFBTCxDQUFZM1EsSUFBWixDQUFpQixhQUFqQixFQUFnQyxFQUFFekMsU0FBU0EsT0FBWCxFQUFvQjZyQixpQkFBaUJGLGFBQXJDLEVBQW9ERyxhQUFhbEcsSUFBakUsRUFBaEM7QUFDRCxTQVBEOztBQVNBNkYsZUFBT3BwQixPQUFQLENBQWUsUUFBZixFQUF5QixZQUFZO0FBQ25DbVAsZUFBSzRCLE1BQUwsQ0FBWTdYLEtBQVosQ0FBa0IsS0FBbEI7QUFDQWlXLGVBQUs0QixNQUFMLENBQVkzUSxJQUFaLENBQWlCLGVBQWpCLEVBQWtDLEVBQUV6QyxTQUFTQSxPQUFYLEVBQW9CNnJCLGlCQUFpQkYsYUFBckMsRUFBb0RHLGFBQWFsRyxJQUFqRSxFQUFsQztBQUNELFNBSEQ7QUFJRDtBQUNELGFBQU82RixNQUFQO0FBQ0QsS0E5RThDOztBQWdGL0M7Ozs7OztBQU1BcnRCLGlCQUFhLFNBQVNBLFdBQVQsQ0FBcUI0QixPQUFyQixFQUE4QnVkLFlBQTlCLEVBQTRDO0FBQ3ZELFVBQUksS0FBS3dPLGdCQUFULEVBQTJCO0FBQ3pCO0FBQ0Q7O0FBRUQsVUFBSUMsYUFBYSxLQUFLQyxjQUFMLENBQW9CanNCLFVBQVUsR0FBVixHQUFnQnVkLFlBQXBDLENBQWpCOztBQUVBO0FBQ0EsVUFBSXlPLGNBQWNBLFdBQVdQLE1BQXpCLElBQW1DLENBQUNPLFdBQVcxTyxLQUFuRCxFQUEwRDtBQUN4RDBPLG1CQUFXUCxNQUFYLENBQWtCckgsSUFBbEI7QUFDRCxPQUZELE1BRU87QUFDTCxhQUFLOUUsWUFBTCxDQUFrQnRmLE9BQWxCLEVBQTJCdWQsWUFBM0I7QUFDRDtBQUNGLEtBbkc4Qzs7QUFxRy9DK0Isa0JBQWMsU0FBU0EsWUFBVCxDQUFzQnRmLE9BQXRCLEVBQStCdWQsWUFBL0IsRUFBNkM7QUFDekQ7QUFDQSxXQUFLbkssTUFBTCxDQUFZN1gsS0FBWixDQUFrQixLQUFsQjs7QUFFQSxXQUFLMFosUUFBTCxDQUFjbjhCLFFBQWQsQ0FBdUJ5OUIsSUFBdkIsQ0FBNEJ2VyxPQUE1QixFQUFxQ3VkLFlBQXJDO0FBQ0EsV0FBSzJPLGlCQUFMO0FBQ0QsS0EzRzhDOztBQTZHL0NDLGdCQUFZLFNBQVNBLFVBQVQsQ0FBb0JDLE1BQXBCLEVBQTRCO0FBQ3RDLFVBQUloWixTQUFTLEtBQUtBLE1BQWxCO0FBQ0EsY0FBUWdaLE1BQVI7QUFDRSxhQUFLLGFBQUw7QUFDRSxjQUFJaFosT0FBTytRLFdBQVAsS0FBdUIvUSxPQUFPc1IsUUFBbEMsRUFBNEM7QUFDMUN0UixtQkFBTzNRLElBQVAsQ0FBWSxhQUFaLEVBQTJCLFVBQTNCO0FBQ0QsV0FGRCxNQUVPO0FBQ0wyUSxtQkFBTzNRLElBQVAsQ0FBWSxhQUFaLEVBQTJCLFVBQTNCO0FBQ0Q7QUFDRDtBQVBKO0FBU0QsS0F4SDhDOztBQTBIL0NxZ0IsY0FBVSxTQUFTQSxRQUFULEdBQW9CO0FBQzVCLFVBQUl0UixPQUFPLElBQVg7QUFBQSxVQUNJNEIsU0FBUyxLQUFLQSxNQURsQjtBQUFBLFVBRUk3bEIsWUFBWSxLQUFLQSxTQUZyQjtBQUFBLFVBR0ltNEIsUUFBUSxLQUFLMkcsWUFBTCxDQUFrQi91QyxNQUFsQixDQUF5QixLQUFLZ3ZDLFdBQTlCLENBSFo7QUFBQSxVQUlJdHhDLFNBQVMwcUMsTUFBTTFxQyxNQUpuQjtBQUFBLFVBS0lELElBQUksQ0FMUjs7QUFPQSxhQUFPQSxJQUFJQyxNQUFYLEVBQW1CRCxHQUFuQixFQUF3QjtBQUN0QjtBQUNBO0FBQ0FoQyxZQUFJdzBCLGFBQUosQ0FBa0I7QUFDaEJzSSxnQkFBTSxjQURVO0FBRWhCMFcsd0JBQWM7QUFGRSxTQUFsQixFQUdHL3BCLEVBSEgsQ0FHTWtqQixNQUFNM3FDLENBQU4sQ0FITjtBQUlEOztBQUVEO0FBQ0FoQyxVQUFJOHVCLFFBQUosQ0FBYXRhLFNBQWIsRUFBd0IsMEJBQXhCLEVBQW9ELFdBQXBELEVBQWlFLFVBQVV3YSxLQUFWLEVBQWlCO0FBQ2hGQSxjQUFNbUQsY0FBTjtBQUNELE9BRkQ7O0FBSUFueUIsVUFBSTh1QixRQUFKLENBQWF0YSxTQUFiLEVBQXdCLDBCQUF4QixFQUFvRCxPQUFwRCxFQUE2RCxVQUFVd2EsS0FBVixFQUFpQjtBQUM1RSxZQUFJNmQsT0FBTyxJQUFYO0FBQUEsWUFDSTVsQixVQUFVNGxCLEtBQUtsbEIsWUFBTCxDQUFrQix3QkFBbEIsQ0FEZDtBQUFBLFlBRUk2YyxlQUFlcUksS0FBS2xsQixZQUFMLENBQWtCLDhCQUFsQixDQUZuQjtBQUdBOFEsYUFBS3BULFdBQUwsQ0FBaUI0QixPQUFqQixFQUEwQnVkLFlBQTFCO0FBQ0F4VixjQUFNbUQsY0FBTjtBQUNELE9BTkQ7O0FBUUFueUIsVUFBSTh1QixRQUFKLENBQWF0YSxTQUFiLEVBQXdCLHlCQUF4QixFQUFtRCxPQUFuRCxFQUE0RCxVQUFVd2EsS0FBVixFQUFpQjtBQUMzRSxZQUFJcWtCLFNBQVMsS0FBSzFyQixZQUFMLENBQWtCLHVCQUFsQixDQUFiO0FBQ0E4USxhQUFLMmEsVUFBTCxDQUFnQkMsTUFBaEI7QUFDQXJrQixjQUFNbUQsY0FBTjtBQUNELE9BSkQ7O0FBTUFrSSxhQUFPL1EsT0FBUCxDQUFlLGdCQUFmLEVBQWlDLFlBQVk7QUFDM0NtUCxhQUFLd0YsUUFBTCxHQUFnQixJQUFoQjtBQUNBMk0sc0JBQWNuUyxLQUFLaVMsUUFBbkI7QUFDQWpTLGFBQUtpUyxRQUFMLEdBQWdCRyxZQUFZLFlBQVk7QUFDdENwUyxlQUFLMGEsaUJBQUw7QUFDRCxTQUZlLEVBRWIsR0FGYSxDQUFoQjtBQUdELE9BTkQ7O0FBUUE5WSxhQUFPL1EsT0FBUCxDQUFlLGVBQWYsRUFBZ0MsWUFBWTtBQUMxQ3NoQixzQkFBY25TLEtBQUtpUyxRQUFuQjtBQUNELE9BRkQ7O0FBSUFyUSxhQUFPL1EsT0FBUCxDQUFlLGtCQUFmLEVBQW1DLFlBQVk7QUFDN0NzaEIsc0JBQWNuUyxLQUFLaVMsUUFBbkI7QUFDRCxPQUZEOztBQUlBclEsYUFBTy9RLE9BQVAsQ0FBZSxhQUFmLEVBQThCLFVBQVU4aEIsV0FBVixFQUF1QjtBQUNuRDtBQUNBMVIsbUJBQVcsWUFBWTtBQUNyQmpCLGVBQUt1YSxnQkFBTCxHQUF3QjVILGdCQUFnQixVQUF4QztBQUNBM1MsZUFBSzBhLGlCQUFMO0FBQ0EsY0FBSTFhLEtBQUt1YSxnQkFBVCxFQUEyQjtBQUN6Qmh6QyxnQkFBSWlzQixRQUFKLENBQWF6WCxTQUFiLEVBQXdCMjlCLDRCQUF4QjtBQUNELFdBRkQsTUFFTztBQUNMbnlDLGdCQUFJcXNCLFdBQUosQ0FBZ0I3WCxTQUFoQixFQUEyQjI5Qiw0QkFBM0I7QUFDRDtBQUNGLFNBUkQsRUFRRyxDQVJIO0FBU0QsT0FYRDtBQVlELEtBMUw4Qzs7QUE0TC9DZ0IsdUJBQW1CLFNBQVNBLGlCQUFULEdBQTZCO0FBQzlDLFVBQUloeEIsVUFBVSxLQUFLK1osUUFBTCxDQUFjL1osT0FBNUI7QUFBQSxVQUNJK3dCLGlCQUFpQixLQUFLQSxjQUQxQjtBQUFBLFVBRUlPLGdCQUFnQixLQUFLQSxhQUZ6QjtBQUFBLFVBR0l6eEMsQ0FISjtBQUFBLFVBSUl1aUMsS0FKSjtBQUFBLFVBS0k4TyxNQUxKO0FBQUEsVUFNSXBzQixPQU5KO0FBT0E7QUFDQSxXQUFLamxCLENBQUwsSUFBVWt4QyxjQUFWLEVBQTBCO0FBQ3hCanNCLGtCQUFVaXNCLGVBQWVseEMsQ0FBZixDQUFWO0FBQ0EsWUFBSSxLQUFLZ3hDLGdCQUFULEVBQTJCO0FBQ3pCek8sa0JBQVEsS0FBUjtBQUNBdmtDLGNBQUlxc0IsV0FBSixDQUFnQnBGLFFBQVE0bEIsSUFBeEIsRUFBOEJ1Rix5QkFBOUI7QUFDQSxjQUFJbnJCLFFBQVF3ckIsS0FBWixFQUFtQjtBQUNqQnp5QyxnQkFBSXFzQixXQUFKLENBQWdCcEYsUUFBUXdyQixLQUF4QixFQUErQkwseUJBQS9CO0FBQ0Q7QUFDRCxjQUFJbnJCLFFBQVF5ckIsTUFBWixFQUFvQjtBQUNsQnpyQixvQkFBUXlyQixNQUFSLENBQWVwSCxJQUFmO0FBQ0Q7QUFDRixTQVRELE1BU087QUFDTC9HLGtCQUFRLEtBQUtySSxRQUFMLENBQWNuOEIsUUFBZCxDQUF1QndrQyxLQUF2QixDQUE2QnRkLFFBQVEvaEIsSUFBckMsRUFBMkMraEIsUUFBUXhELEtBQW5ELENBQVI7QUFDQSxjQUFJNWpCLFVBQVVNLElBQVYsQ0FBZTZqQixNQUFmLENBQXNCdWdCLEtBQXRCLEVBQTZCcmEsT0FBN0IsRUFBSixFQUE0QztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBcWEsb0JBQVFBLE1BQU10aUMsTUFBTixLQUFpQixDQUFqQixHQUFxQnNpQyxNQUFNLENBQU4sQ0FBckIsR0FBZ0MsSUFBeEM7QUFDRDtBQUNEdmtDLGNBQUlxc0IsV0FBSixDQUFnQnBGLFFBQVE0bEIsSUFBeEIsRUFBOEJxRiwyQkFBOUI7QUFDQSxjQUFJanJCLFFBQVF3ckIsS0FBWixFQUFtQjtBQUNqQnp5QyxnQkFBSXFzQixXQUFKLENBQWdCcEYsUUFBUXdyQixLQUF4QixFQUErQlAsMkJBQS9CO0FBQ0Q7QUFDRjs7QUFFRCxZQUFJanJCLFFBQVFzZCxLQUFSLEtBQWtCQSxLQUF0QixFQUE2QjtBQUMzQjtBQUNEOztBQUVEdGQsZ0JBQVFzZCxLQUFSLEdBQWdCQSxLQUFoQjtBQUNBLFlBQUlBLEtBQUosRUFBVztBQUNUdmtDLGNBQUlpc0IsUUFBSixDQUFhaEYsUUFBUTRsQixJQUFyQixFQUEyQnVGLHlCQUEzQjtBQUNBLGNBQUluckIsUUFBUXdyQixLQUFaLEVBQW1CO0FBQ2pCenlDLGdCQUFJaXNCLFFBQUosQ0FBYWhGLFFBQVF3ckIsS0FBckIsRUFBNEJMLHlCQUE1QjtBQUNEO0FBQ0QsY0FBSW5yQixRQUFReXJCLE1BQVosRUFBb0I7QUFDbEIsZ0JBQUksQ0FBQyxPQUFPbk8sS0FBUCxLQUFpQixXQUFqQixHQUErQixXQUEvQixHQUE2Q2hsQyxRQUFRZ2xDLEtBQVIsQ0FBOUMsTUFBa0UsUUFBdEUsRUFBZ0Y7QUFDOUV0ZCxzQkFBUXlyQixNQUFSLENBQWVySCxJQUFmLENBQW9COUcsS0FBcEI7QUFDRCxhQUZELE1BRU87QUFDTHRkLHNCQUFReXJCLE1BQVIsQ0FBZXBILElBQWY7QUFDRDtBQUNGO0FBQ0YsU0FaRCxNQVlPO0FBQ0x0ckMsY0FBSXFzQixXQUFKLENBQWdCcEYsUUFBUTRsQixJQUF4QixFQUE4QnVGLHlCQUE5QjtBQUNBLGNBQUluckIsUUFBUXdyQixLQUFaLEVBQW1CO0FBQ2pCenlDLGdCQUFJcXNCLFdBQUosQ0FBZ0JwRixRQUFRd3JCLEtBQXhCLEVBQStCTCx5QkFBL0I7QUFDRDtBQUNELGNBQUluckIsUUFBUXlyQixNQUFaLEVBQW9CO0FBQ2xCenJCLG9CQUFReXJCLE1BQVIsQ0FBZXBILElBQWY7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsV0FBS3RwQyxDQUFMLElBQVV5eEMsYUFBVixFQUF5QjtBQUN2QkosaUJBQVNJLGNBQWN6eEMsQ0FBZCxDQUFUOztBQUVBLFlBQUlxeEMsT0FBT251QyxJQUFQLEtBQWdCLGFBQXBCLEVBQW1DO0FBQ2pDbXVDLGlCQUFPOU8sS0FBUCxHQUFlLEtBQUtsSyxNQUFMLENBQVkrUSxXQUFaLEtBQTRCLEtBQUsvUSxNQUFMLENBQVlzUixRQUF2RDtBQUNBLGNBQUkwSCxPQUFPOU8sS0FBWCxFQUFrQjtBQUNoQnZrQyxnQkFBSWlzQixRQUFKLENBQWFvbkIsT0FBT3hHLElBQXBCLEVBQTBCd0Ysd0JBQTFCO0FBQ0QsV0FGRCxNQUVPO0FBQ0xyeUMsZ0JBQUlxc0IsV0FBSixDQUFnQmduQixPQUFPeEcsSUFBdkIsRUFBNkJ3Rix3QkFBN0I7QUFDRDtBQUNGO0FBQ0Y7QUFDRixLQXZROEM7O0FBeVEvQ2hILFVBQU0sU0FBU0EsSUFBVCxHQUFnQjtBQUNwQixXQUFLNzJCLFNBQUwsQ0FBZTJhLEtBQWYsQ0FBcUJDLE9BQXJCLEdBQStCLEVBQS9CO0FBQ0QsS0EzUThDOztBQTZRL0NrYyxVQUFNLFNBQVNBLElBQVQsR0FBZ0I7QUFDcEIsV0FBSzkyQixTQUFMLENBQWUyYSxLQUFmLENBQXFCQyxPQUFyQixHQUErQixNQUEvQjtBQUNEO0FBL1E4QyxHQURyQixDQUE1QjtBQWtSRCxDQXpSRCxFQXlSR3Z2QixTQXpSSDtBQTBSQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkEsQ0FBQyxVQUFVQSxTQUFWLEVBQXFCO0FBQ3BCLE1BQUk2a0MsS0FBSjs7QUFFQSxNQUFJZ1AsZ0JBQWdCO0FBQ2xCO0FBQ0F4dUMsVUFBTXcvQixLQUZZO0FBR2xCO0FBQ0F2VixXQUFPLElBSlc7QUFLbEI7QUFDQWp2QixhQUFTd2tDLEtBTlM7QUFPbEI7QUFDQXhaLGNBQVUsSUFSUTtBQVNsQjtBQUNBO0FBQ0F5b0IsaUJBQWEsRUFBRTVnQixNQUFNLEVBQUVnSixJQUFJLEVBQU4sRUFBVStMLE1BQU0sRUFBaEIsRUFBb0JyTSxLQUFLLEVBQXpCLEVBQTZCaDZCLEdBQUcsRUFBaEMsRUFBUixFQUE4Q3V4QixTQUFTLEVBQXZELEVBWEs7QUFZbEI7QUFDQTRnQixZQUFRL3pDLFVBQVVHLEdBQVYsQ0FBY3d5QixLQWJKO0FBY2xCO0FBQ0EwWix1QkFBbUIsa0JBZkQ7QUFnQmxCO0FBQ0EySCxtQkFBZSxxQkFqQkc7QUFrQmxCO0FBQ0ExYSxpQkFBYSxFQW5CSztBQW9CbEI7QUFDQW9CLHFCQUFpQm1LLEtBckJDO0FBc0JsQjtBQUNBdUkseUJBQXFCLElBdkJIO0FBd0JsQjtBQUNBNkcseUJBQXFCO0FBekJILEdBQXBCOztBQTRCQWowQyxZQUFVazBDLE1BQVYsR0FBbUJsMEMsVUFBVU0sSUFBVixDQUFla3BCLFVBQWYsQ0FBMEI1bEIsTUFBMUI7QUFDbkIsMENBQXdDO0FBQ3RDOUQsaUJBQWEsU0FBU0EsV0FBVCxDQUFxQnVyQyxlQUFyQixFQUFzQ3JvQyxNQUF0QyxFQUE4QztBQUN6RCxXQUFLcW9DLGVBQUwsR0FBdUIsT0FBT0EsZUFBUCxLQUEyQixRQUEzQixHQUFzQ2xuQyxTQUFTcTBCLGNBQVQsQ0FBd0I2UyxlQUF4QixDQUF0QyxHQUFpRkEsZUFBeEc7QUFDQSxXQUFLcm9DLE1BQUwsR0FBY2hELFVBQVVNLElBQVYsQ0FBZTZqQixNQUFmLENBQXNCLEVBQXRCLEVBQTBCK0YsS0FBMUIsQ0FBZ0MycEIsYUFBaEMsRUFBK0MzcEIsS0FBL0MsQ0FBcURsbkIsTUFBckQsRUFBNkRzbUIsR0FBN0QsRUFBZDtBQUNBLFdBQUt3aUIsUUFBTCxHQUFnQixJQUFJOXJDLFVBQVVRLEtBQVYsQ0FBZ0J1dkMsUUFBcEIsQ0FBNkIsSUFBN0IsRUFBbUMsS0FBSzFFLGVBQXhDLEVBQXlELEtBQUtyb0MsTUFBOUQsQ0FBaEI7QUFDQSxXQUFLdW9DLFdBQUwsR0FBbUIsS0FBS08sUUFBeEI7QUFDQSxXQUFLcUksYUFBTCxHQUFxQm4wQyxVQUFVd2tCLE9BQVYsQ0FBa0I1aEIsU0FBbEIsRUFBckI7O0FBRUE7QUFDQSxVQUFJLENBQUMsS0FBS3V4QyxhQUFOLElBQXVCLENBQUMsS0FBS254QyxNQUFMLENBQVlpeEMsbUJBQWIsSUFBb0NqMEMsVUFBVXdrQixPQUFWLENBQWtCd0IsYUFBbEIsRUFBL0QsRUFBa0c7QUFDaEcsWUFBSTRTLE9BQU8sSUFBWDtBQUNBaUIsbUJBQVcsWUFBWTtBQUNyQmpCLGVBQUsvTyxJQUFMLENBQVUsWUFBVixFQUF3QkEsSUFBeEIsQ0FBNkIsTUFBN0I7QUFDRCxTQUZELEVBRUcsQ0FGSDtBQUdBO0FBQ0Q7O0FBRUQ7QUFDQTdwQixnQkFBVUcsR0FBVixDQUFjaXNCLFFBQWQsQ0FBdUJqb0IsU0FBU0csSUFBaEMsRUFBc0MsS0FBS3RCLE1BQUwsQ0FBWWd4QyxhQUFsRDs7QUFFQSxXQUFLM1gsUUFBTCxHQUFnQixJQUFJcjhCLFVBQVVRLEtBQVYsQ0FBZ0JvckMsUUFBcEIsQ0FBNkIsSUFBN0IsRUFBbUMsS0FBS1AsZUFBeEMsRUFBeUQsS0FBS3JvQyxNQUE5RCxDQUFoQjtBQUNBLFdBQUt1b0MsV0FBTCxHQUFtQixLQUFLbFAsUUFBeEI7O0FBRUEsVUFBSSxPQUFPLEtBQUtyNUIsTUFBTCxDQUFZK3dDLE1BQW5CLEtBQThCLFVBQWxDLEVBQThDO0FBQzVDLGFBQUtLLFdBQUw7QUFDRDs7QUFFRCxXQUFLM3FCLE9BQUwsQ0FBYSxZQUFiLEVBQTJCLFlBQVk7QUFDckMsYUFBSzRxQixZQUFMLEdBQW9CLElBQUlyMEMsVUFBVVEsS0FBVixDQUFnQit1QyxZQUFwQixDQUFpQyxJQUFqQyxFQUF1QyxLQUFLekQsUUFBNUMsRUFBc0QsS0FBS3pQLFFBQTNELENBQXBCO0FBQ0EsWUFBSSxLQUFLcjVCLE1BQUwsQ0FBWTNDLE9BQWhCLEVBQXlCO0FBQ3ZCLGVBQUtBLE9BQUwsR0FBZSxJQUFJTCxVQUFVSyxPQUFWLENBQWtCb3lDLE9BQXRCLENBQThCLElBQTlCLEVBQW9DLEtBQUt6dkMsTUFBTCxDQUFZM0MsT0FBaEQsQ0FBZjtBQUNEO0FBQ0YsT0FMRDs7QUFPQSxVQUFJO0FBQ0ZvRCxnQkFBUUMsR0FBUixDQUFZLHVHQUFaO0FBQ0QsT0FGRCxDQUVFLE9BQU9xQyxDQUFQLEVBQVUsQ0FBRTtBQUNmLEtBckNxQzs7QUF1Q3RDdXVDLGtCQUFjLFNBQVNBLFlBQVQsR0FBd0I7QUFDcEMsYUFBTyxLQUFLSCxhQUFaO0FBQ0QsS0F6Q3FDOztBQTJDdENyWixXQUFPLFNBQVNBLEtBQVQsR0FBaUI7QUFDdEIsV0FBS3lRLFdBQUwsQ0FBaUJ6USxLQUFqQjtBQUNBLGFBQU8sSUFBUDtBQUNELEtBOUNxQzs7QUFnRHRDa1AsY0FBVSxTQUFTQSxRQUFULENBQWtCclgsS0FBbEIsRUFBeUI7QUFDakMsYUFBTyxLQUFLNFksV0FBTCxDQUFpQnZCLFFBQWpCLENBQTBCclgsS0FBMUIsQ0FBUDtBQUNELEtBbERxQzs7QUFvRHRDcUksY0FBVSxTQUFTQSxRQUFULENBQWtCeFksSUFBbEIsRUFBd0JtUSxLQUF4QixFQUErQjtBQUN2QyxVQUFJLENBQUNuUSxJQUFMLEVBQVc7QUFDVCxlQUFPLEtBQUtzWSxLQUFMLEVBQVA7QUFDRDtBQUNELFdBQUt5USxXQUFMLENBQWlCdlEsUUFBakIsQ0FBMEJ4WSxJQUExQixFQUFnQ21RLEtBQWhDO0FBQ0EsYUFBTyxJQUFQO0FBQ0QsS0ExRHFDOztBQTREdENoUSxXQUFPLFNBQVNBLEtBQVQsQ0FBZXNwQixRQUFmLEVBQXlCO0FBQzlCLFdBQUtWLFdBQUwsQ0FBaUI1b0IsS0FBakIsQ0FBdUJzcEIsUUFBdkI7QUFDQSxhQUFPLElBQVA7QUFDRCxLQS9EcUM7O0FBaUV0Qzs7O0FBR0FQLGFBQVMsU0FBU0EsT0FBVCxHQUFtQjtBQUMxQixXQUFLSCxXQUFMLENBQWlCRyxPQUFqQjtBQUNBLGFBQU8sSUFBUDtBQUNELEtBdkVxQzs7QUF5RXRDOzs7QUFHQUMsWUFBUSxTQUFTQSxNQUFULEdBQWtCO0FBQ3hCLFdBQUtKLFdBQUwsQ0FBaUJJLE1BQWpCO0FBQ0EsYUFBTyxJQUFQO0FBQ0QsS0EvRXFDOztBQWlGdEM1USxhQUFTLFNBQVNBLE9BQVQsR0FBbUI7QUFDMUIsYUFBTyxLQUFLd1EsV0FBTCxDQUFpQnhRLE9BQWpCLEVBQVA7QUFDRCxLQW5GcUM7O0FBcUZ0Q0YsdUJBQW1CLFNBQVNBLGlCQUFULEdBQTZCO0FBQzlDLGFBQU8sS0FBSzBRLFdBQUwsQ0FBaUIxUSxpQkFBakIsRUFBUDtBQUNELEtBdkZxQzs7QUF5RnRDbEksV0FBTyxTQUFTQSxLQUFULENBQWU0aEIsYUFBZixFQUE4QjtBQUNuQyxVQUFJbDlCLGNBQWMsS0FBS3JVLE1BQUwsQ0FBWSt3QyxNQUFaLENBQW1CUSxhQUFuQixFQUFrQyxLQUFLdnhDLE1BQUwsQ0FBWTh3QyxXQUE5QyxFQUEyRCxLQUFLelgsUUFBTCxDQUFjOE4sT0FBZCxDQUFzQnRoQyxXQUF0QixFQUEzRCxFQUFnRyxJQUFoRyxDQUFsQjtBQUNBLFVBQUksQ0FBQyxPQUFPMHJDLGFBQVAsS0FBeUIsV0FBekIsR0FBdUMsV0FBdkMsR0FBcUQ3MEMsUUFBUTYwQyxhQUFSLENBQXRELE1BQWtGLFFBQXRGLEVBQWdHO0FBQzlGdjBDLGtCQUFVSSxNQUFWLENBQWlCdzlCLE1BQWpCLENBQXdCMlcsYUFBeEI7QUFDRDtBQUNELGFBQU9sOUIsV0FBUDtBQUNELEtBL0ZxQzs7QUFpR3RDOzs7O0FBSUErOEIsaUJBQWEsU0FBU0EsV0FBVCxHQUF1QjtBQUNsQyxXQUFLM3FCLE9BQUwsQ0FBYSxnQkFBYixFQUErQixZQUFZO0FBQ3pDLFlBQUkrcUIscUJBQXFCLElBQXpCO0FBQUEsWUFDSTViLE9BQU8sSUFEWDtBQUVBQSxhQUFLeUQsUUFBTCxDQUFjOTdCLFNBQWQsQ0FBd0JtK0IsaUJBQXhCLENBQTBDLFlBQVk7QUFDcEQxK0Isb0JBQVVJLE1BQVYsQ0FBaUJrN0IsZUFBakIsQ0FBaUMxQyxLQUFLeUQsUUFBTCxDQUFjL1osT0FBL0M7QUFDQXNXLGVBQUtqRyxLQUFMLENBQVdpRyxLQUFLeUQsUUFBTCxDQUFjL1osT0FBekI7QUFDRCxTQUhELEVBR0dreUIsa0JBSEg7QUFJRCxPQVBEOztBQVNBLFdBQUsvcUIsT0FBTCxDQUFhLGdCQUFiLEVBQStCLFlBQVk7QUFDekMsWUFBSTdGLFFBQVEsS0FBS2tvQixRQUFMLENBQWM5QixRQUFkLEVBQVo7QUFBQSxZQUNJb0gsUUFESjtBQUVBQSxtQkFBVyxLQUFLemUsS0FBTCxDQUFXL08sS0FBWCxDQUFYO0FBQ0EsYUFBS2tvQixRQUFMLENBQWM5USxRQUFkLENBQXVCb1csUUFBdkI7QUFDRCxPQUxEO0FBTUQ7QUFySHFDLEdBRHJCLENBQW5CO0FBd0hELENBdkpELEVBdUpHcHhDLFNBdkpIO0FBd0pBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQSxDQUFDLFVBQVVnOEIsQ0FBVixFQUFhOztBQUVaOTZCLFNBQU91ekMsU0FBUCxHQUFtQixTQUFTQSxTQUFULENBQW1CQyxPQUFuQixFQUE0QjtBQUM3QyxTQUFLM3dDLElBQUwsQ0FBVSxXQUFWLEVBQXVCMndDLE9BQXZCLEVBQWdDRCxVQUFVRSxRQUExQzs7QUFFQTtBQUNBLFNBQUtELE9BQUwsQ0FBYTEwQyxTQUFiLEdBQXlCZzhCLEVBQUVwNEIsTUFBRixDQUFTLEVBQVQsRUFBYTZ3QyxVQUFVRSxRQUFWLENBQW1CMzBDLFNBQWhDLEVBQTJDMDBDLFFBQVExMEMsU0FBbkQsQ0FBekI7QUFDRCxHQUxEOztBQU9Ba0IsU0FBTzg2QixDQUFQLENBQVM0WSxFQUFULENBQVlDLGFBQVosQ0FBMEJDLE9BQTFCLENBQWtDTCxTQUFsQyxFQUE2Q3Z6QyxPQUFPODZCLENBQVAsQ0FBUzRZLEVBQVQsQ0FBWUcsYUFBWixDQUEwQkMsYUFBdkU7O0FBRUFoWixJQUFFcDRCLE1BQUYsQ0FBUzZ3QyxVQUFVMTBDLFNBQW5CLEVBQThCO0FBQzVCazFDLFlBQVEsU0FBU0EsTUFBVCxHQUFrQjtBQUN4QixVQUFJQyxXQUFXbFosRUFBRW1aLFFBQUYsRUFBZjtBQUFBLFVBQ0lDLE9BREo7O0FBR0E7QUFDQSxXQUFLQyxNQUFMLENBQVlDLElBQVosQ0FBaUIsSUFBakIsRUFBdUIsY0FBYyxJQUFJL1AsSUFBSixHQUFXMEQsT0FBWCxFQUFyQzs7QUFFQSxXQUFLelUsUUFBTDtBQUNBLFdBQUsrZ0IsT0FBTCxDQUFhLGFBQWI7O0FBRUE7QUFDQXZaLFFBQUVwNEIsTUFBRixDQUFTLEtBQUs4d0MsT0FBTCxDQUFhMTBDLFNBQXRCLEVBQWlDO0FBQy9CMnBCLGdCQUFRO0FBQ042ckIsZ0JBQU0sU0FBU0EsSUFBVCxHQUFnQjtBQUNwQk4scUJBQVNPLE9BQVQ7QUFDRDtBQUhLO0FBRHVCLE9BQWpDOztBQVFBLFdBQUtKLE1BQUwsQ0FBWXIxQyxTQUFaLENBQXNCLEtBQUswMEMsT0FBTCxDQUFhMTBDLFNBQW5DOztBQUVBOzs7O0FBSUFvMUMsZ0JBQVUsaUJBQWlCdm1DLElBQWpCLENBQXNCNlYsVUFBVUQsU0FBVixDQUFvQlksV0FBcEIsRUFBdEIsQ0FBVjtBQUNBLFVBQUkrdkIsT0FBSixFQUFhO0FBQ1gsYUFBS0MsTUFBTCxDQUFZempCLE1BQVosQ0FBbUIsVUFBbkI7QUFDRDs7QUFFRCxhQUFPc2pCLFNBQVNRLE9BQVQsRUFBUDtBQUNELEtBaEMyQjs7QUFrQzVCQyxnQkFBWSxTQUFTQSxVQUFULENBQW9CL3hCLEtBQXBCLEVBQTJCdEIsT0FBM0IsRUFBb0M7QUFDOUMwWixRQUFFMVosT0FBRixFQUFXRSxJQUFYLENBQWdCb0IsS0FBaEI7QUFDRCxLQXBDMkI7O0FBc0M1Qmd5QixnQkFBWSxTQUFTQSxVQUFULENBQW9CcHpCLElBQXBCLEVBQTBCO0FBQ3BDLGFBQU9BLElBQVA7QUFDRCxLQXhDMkI7O0FBMEM1QnF6QixpQkFBYSxTQUFTQSxXQUFULENBQXFCanlCLEtBQXJCLEVBQTRCO0FBQ3ZDLFdBQUt5eEIsTUFBTCxDQUFZNXFDLElBQVosQ0FBaUIsV0FBakIsRUFBOEIrdkIsTUFBOUIsQ0FBcUNRLFFBQXJDLENBQThDcFgsS0FBOUMsRUFBcUQsSUFBckQ7QUFDRCxLQTVDMkI7O0FBOEM1Qmt5QixjQUFVLFNBQVNBLFFBQVQsR0FBb0I7QUFDNUIsV0FBS1QsTUFBTCxDQUFZNXFDLElBQVosQ0FBaUIsV0FBakIsRUFBOEIrdkIsTUFBOUIsQ0FBcUM3WCxLQUFyQztBQUNELEtBaEQyQjs7QUFrRDVCb1ksYUFBUyxTQUFTQSxPQUFULENBQWlCZ2IsUUFBakIsRUFBMkI7QUFDbEMsVUFBSS9aLEVBQUV0UixJQUFGLENBQU9xckIsU0FBU3Z6QixJQUFULEVBQVAsTUFBNEIsRUFBaEMsRUFBb0M7QUFDbEMsZUFBTyxJQUFQO0FBQ0QsT0FGRCxNQUVPLElBQUl3WixFQUFFdFIsSUFBRixDQUFPcXJCLFNBQVMvNkIsSUFBVCxFQUFQLE1BQTRCLEVBQWhDLEVBQW9DO0FBQ3pDLGVBQU8sS0FBUDtBQUNELE9BRk0sTUFFQTtBQUNMO0FBQ0EsZUFBTyxDQUFDKzZCLFNBQVNqbkIsTUFBVCxFQUFELElBQXNCLENBQUNpbkIsU0FBU2pnQixLQUFULEVBQTlCO0FBQ0Q7QUFDRjtBQTNEMkIsR0FBOUI7O0FBOERBMmUsWUFBVUUsUUFBVixHQUFxQjNZLEVBQUVwNEIsTUFBRixDQUFTLEVBQVQsRUFBYTFDLE9BQU84NkIsQ0FBUCxDQUFTNFksRUFBVCxDQUFZRyxhQUFaLENBQTBCQyxhQUExQixDQUF3Q0wsUUFBckQsRUFBK0Q7QUFDbEY7Ozs7QUFJQXFCLFNBQUssdUJBTDZFO0FBTWxGOzs7O0FBSUFDLGdCQUFZLG9CQVZzRTtBQVdsRjs7Ozs7O0FBTUEzSixpQkFBYSxJQWpCcUU7QUFrQmxGOzs7Ozs7O0FBT0F0c0MsZUFBVztBQUNUczVCLG1CQUFhO0FBREo7QUF6QnVFLEdBQS9ELENBQXJCOztBQThCQXA0QixTQUFPODZCLENBQVAsQ0FBUzRZLEVBQVQsQ0FBWUcsYUFBWixDQUEwQi8wQyxTQUExQixHQUFzQ3kwQyxTQUF0QztBQUNELENBeEdELEVBd0dHdnpDLE9BQU9nMUMsTUF4R1Y7O0FBMEdBLENBQUMsVUFBVWxhLENBQVYsRUFBYW1hLElBQWIsRUFBbUI7O0FBRWxCLE1BQUlILE1BQU07QUFDUixtQkFBZSxTQUFTSSxVQUFULENBQW9CQyxNQUFwQixFQUE0QjNCLE9BQTVCLEVBQXFDO0FBQ2xELFVBQUk1TyxPQUFPNE8sV0FBV0EsUUFBUTVPLElBQW5CLEdBQTBCLFVBQVU0TyxRQUFRNU8sSUFBNUMsR0FBbUQsRUFBOUQ7QUFDQSxhQUFPLDBCQUEwQiwyQ0FBMUIsR0FBd0VBLElBQXhFLEdBQStFLG9DQUEvRSxHQUFzSCw2REFBdEgsR0FBc0x1USxPQUFPQyxXQUFQLENBQW1CQyxNQUF6TSxHQUFrTixvQ0FBbE4sR0FBeVAsTUFBelAsR0FBa1EsNEJBQWxRLEdBQWlTLCtGQUFqUyxHQUFtWUYsT0FBT0MsV0FBUCxDQUFtQkMsTUFBdFosR0FBK1osV0FBL1osR0FBNmEsOEZBQTdhLEdBQThnQkYsT0FBT0MsV0FBUCxDQUFtQkUsRUFBamlCLEdBQXNpQixXQUF0aUIsR0FBb2pCLDhGQUFwakIsR0FBcXBCSCxPQUFPQyxXQUFQLENBQW1CRyxFQUF4cUIsR0FBNnFCLFdBQTdxQixHQUEyckIsOEZBQTNyQixHQUE0eEJKLE9BQU9DLFdBQVAsQ0FBbUJJLEVBQS95QixHQUFvekIsV0FBcHpCLEdBQWswQixPQUFsMEIsR0FBNDBCLE9BQW4xQjtBQUNELEtBSk87O0FBTVIsZ0JBQVksU0FBU0MsUUFBVCxDQUFrQk4sTUFBbEIsRUFBMEIzQixPQUExQixFQUFtQztBQUM3QyxVQUFJNU8sT0FBTzRPLFdBQVdBLFFBQVE1TyxJQUFuQixHQUEwQixVQUFVNE8sUUFBUTVPLElBQTVDLEdBQW1ELEVBQTlEO0FBQ0EsYUFBTyxTQUFTLHlCQUFULEdBQXFDLDJCQUFyQyxHQUFtRUEsSUFBbkUsR0FBMEUsK0RBQTFFLEdBQTRJdVEsT0FBT00sUUFBUCxDQUFnQjdSLElBQTVKLEdBQW1LLE1BQW5LLEdBQTRLLDJCQUE1SyxHQUEwTWdCLElBQTFNLEdBQWlOLGlFQUFqTixHQUFxUnVRLE9BQU9NLFFBQVAsQ0FBZ0J4TixNQUFyUyxHQUE4UyxNQUE5UyxHQUF1VCwyQkFBdlQsR0FBcVZyRCxJQUFyVixHQUE0VixvRUFBNVYsR0FBbWF1USxPQUFPTSxRQUFQLENBQWdCcE4sU0FBbmIsR0FBK2IsTUFBL2IsR0FBd2MsUUFBeGMsR0FBbWQsT0FBMWQ7QUFDRCxLQVRPOztBQVdSLGFBQVMsU0FBU3FOLEtBQVQsQ0FBZVAsTUFBZixFQUF1QjNCLE9BQXZCLEVBQWdDO0FBQ3ZDLFVBQUk1TyxPQUFPNE8sV0FBV0EsUUFBUTVPLElBQW5CLEdBQTBCLFVBQVU0TyxRQUFRNU8sSUFBNUMsR0FBbUQsRUFBOUQ7QUFDQSxhQUFPLFNBQVMseUJBQVQsR0FBcUMsMkJBQXJDLEdBQW1FQSxJQUFuRSxHQUEwRSx3REFBMUUsR0FBcUl1USxPQUFPTyxLQUFQLENBQWFDLFNBQWxKLEdBQThKLGdEQUE5SixHQUFpTiwyQkFBak4sR0FBK08vUSxJQUEvTyxHQUFzUCxzREFBdFAsR0FBK1N1USxPQUFPTyxLQUFQLENBQWFFLE9BQTVULEdBQXNVLG1EQUF0VSxHQUE0WCwyQkFBNVgsR0FBMFpoUixJQUExWixHQUFpYSwwRkFBamEsR0FBOGYsUUFBOWYsR0FBeWdCLE9BQWhoQjtBQUNELEtBZE87O0FBZ0JSLFlBQVEsU0FBU2tILElBQVQsQ0FBY3FKLE1BQWQsRUFBc0IzQixPQUF0QixFQUErQjtBQUNyQyxVQUFJNU8sT0FBTzRPLFdBQVdBLFFBQVE1TyxJQUFuQixHQUEwQixVQUFVNE8sUUFBUTVPLElBQTVDLEdBQW1ELEVBQTlEO0FBQ0EsYUFBTyxTQUFTLHFFQUFULEdBQWlGLDRCQUFqRixHQUFnSCxtREFBaEgsR0FBc0ssTUFBdEssR0FBK0t1USxPQUFPckosSUFBUCxDQUFZdGYsTUFBM0wsR0FBb00sT0FBcE0sR0FBOE0sUUFBOU0sR0FBeU4sMEJBQXpOLEdBQXNQLGtGQUF0UCxHQUEyVSxRQUEzVSxHQUFzViw0QkFBdFYsR0FBcVgsMkRBQXJYLEdBQW1iMm9CLE9BQU9ySixJQUFQLENBQVkrSixNQUEvYixHQUF3YyxNQUF4YyxHQUFpZCwyREFBamQsR0FBK2dCVixPQUFPckosSUFBUCxDQUFZdGYsTUFBM2hCLEdBQW9pQixNQUFwaUIsR0FBNmlCLFFBQTdpQixHQUF3akIsUUFBeGpCLEdBQW1rQiwyQkFBbmtCLEdBQWltQm9ZLElBQWptQixHQUF3bUIsK0NBQXhtQixHQUEwcEJ1USxPQUFPckosSUFBUCxDQUFZdGYsTUFBdHFCLEdBQStxQixpREFBL3FCLEdBQW11QixPQUExdUI7QUFDRCxLQW5CTzs7QUFxQlIsYUFBUyxTQUFTZ2IsS0FBVCxDQUFlMk4sTUFBZixFQUF1QjNCLE9BQXZCLEVBQWdDO0FBQ3ZDLFVBQUk1TyxPQUFPNE8sV0FBV0EsUUFBUTVPLElBQW5CLEdBQTBCLFVBQVU0TyxRQUFRNU8sSUFBNUMsR0FBbUQsRUFBOUQ7QUFDQSxhQUFPLFNBQVMsc0VBQVQsR0FBa0YsNEJBQWxGLEdBQWlILG1EQUFqSCxHQUF1SyxNQUF2SyxHQUFnTHVRLE9BQU8zTixLQUFQLENBQWFoYixNQUE3TCxHQUFzTSxPQUF0TSxHQUFnTixRQUFoTixHQUEyTiwwQkFBM04sR0FBd1AsbUZBQXhQLEdBQThVLFFBQTlVLEdBQXlWLDRCQUF6VixHQUF3WCwyREFBeFgsR0FBc2Iyb0IsT0FBTzNOLEtBQVAsQ0FBYXFPLE1BQW5jLEdBQTRjLE1BQTVjLEdBQXFkLDJEQUFyZCxHQUFtaEJWLE9BQU8zTixLQUFQLENBQWFoYixNQUFoaUIsR0FBeWlCLE1BQXppQixHQUFrakIsUUFBbGpCLEdBQTZqQixRQUE3akIsR0FBd2tCLDJCQUF4a0IsR0FBc21Cb1ksSUFBdG1CLEdBQTZtQixnREFBN21CLEdBQWdxQnVRLE9BQU8zTixLQUFQLENBQWFoYixNQUE3cUIsR0FBc3JCLG1EQUF0ckIsR0FBNHVCLE9BQW52QjtBQUNELEtBeEJPOztBQTBCUixZQUFRLFNBQVNsTCxJQUFULENBQWM2ekIsTUFBZCxFQUFzQjNCLE9BQXRCLEVBQStCO0FBQ3JDLFVBQUk1TyxPQUFPNE8sV0FBV0EsUUFBUTVPLElBQW5CLEdBQTBCLFVBQVU0TyxRQUFRNU8sSUFBNUMsR0FBbUQsRUFBOUQ7QUFDQSxhQUFPLFNBQVMseUJBQVQsR0FBcUMsMkJBQXJDLEdBQW1FQSxJQUFuRSxHQUEwRSwrQ0FBMUUsR0FBNEh1USxPQUFPN3pCLElBQVAsQ0FBWXcwQixJQUF4SSxHQUErSSxrREFBL0ksR0FBb00sUUFBcE0sR0FBK00sT0FBdE47QUFDRCxLQTdCTzs7QUErQlIsYUFBUyxTQUFTaFMsS0FBVCxDQUFlcVIsTUFBZixFQUF1QjNCLE9BQXZCLEVBQWdDO0FBQ3ZDLFVBQUk1TyxPQUFPNE8sV0FBV0EsUUFBUTVPLElBQW5CLEdBQTBCLFVBQVU0TyxRQUFRNU8sSUFBNUMsR0FBbUQsRUFBOUQ7QUFDQSxhQUFPLDBCQUEwQiwyQ0FBMUIsR0FBd0VBLElBQXhFLEdBQStFLGtEQUEvRSxHQUFvSSxrRUFBcEksR0FBeU0sTUFBek0sR0FBa04sNEJBQWxOLEdBQWlQLHlMQUFqUCxHQUE2YXVRLE9BQU9ZLE9BQVAsQ0FBZW5jLEtBQTViLEdBQW9jLFdBQXBjLEdBQWtkLHlMQUFsZCxHQUE4b0J1YixPQUFPWSxPQUFQLENBQWVDLEtBQTdwQixHQUFxcUIsV0FBcnFCLEdBQW1yQiwyTEFBbnJCLEdBQWkzQmIsT0FBT1ksT0FBUCxDQUFlRSxNQUFoNEIsR0FBeTRCLFdBQXo0QixHQUF1NUIseUxBQXY1QixHQUFtbENkLE9BQU9ZLE9BQVAsQ0FBZUcsS0FBbG1DLEdBQTBtQyxXQUExbUMsR0FBd25DLE9BQXhuQyxHQUFrb0MsT0FBem9DO0FBQ0Q7QUFsQ08sR0FBVjs7QUFxQ0EsTUFBSUMsWUFBWSxTQUFTQSxTQUFULENBQW1CcHpCLEdBQW5CLEVBQXdCb3lCLE1BQXhCLEVBQWdDM0IsT0FBaEMsRUFBeUM7QUFDdkQsV0FBT3NCLElBQUkveEIsR0FBSixFQUFTb3lCLE1BQVQsRUFBaUIzQixPQUFqQixDQUFQO0FBQ0QsR0FGRDs7QUFJQSxNQUFJRCxZQUFZLFNBQVNBLFNBQVQsQ0FBbUJydUMsRUFBbkIsRUFBdUJzdUMsT0FBdkIsRUFBZ0M7QUFDOUMsU0FBS3R1QyxFQUFMLEdBQVVBLEVBQVY7QUFDQSxRQUFJa3hDLGNBQWM1QyxXQUFXNkMsY0FBN0I7QUFDQSxTQUFLLElBQUkxMUMsQ0FBVCxJQUFjeTFDLFlBQVlFLGVBQTFCLEVBQTJDO0FBQ3pDeEIsVUFBSW4wQyxDQUFKLElBQVN5MUMsWUFBWUUsZUFBWixDQUE0QjMxQyxDQUE1QixDQUFUO0FBQ0Q7QUFDRCxTQUFLeEIsT0FBTCxHQUFlLEtBQUtvM0MsYUFBTCxDQUFtQnJ4QyxFQUFuQixFQUF1Qmt4QyxXQUF2QixDQUFmO0FBQ0EsU0FBSzljLE1BQUwsR0FBYyxLQUFLa2QsWUFBTCxDQUFrQmhELE9BQWxCLENBQWQ7O0FBRUF4ekMsV0FBT3M1QixNQUFQLEdBQWdCLEtBQUtBLE1BQXJCOztBQUVBd0IsTUFBRSwwQkFBRixFQUE4QnFMLElBQTlCLENBQW1DLFVBQVVsbEMsQ0FBVixFQUFhaUUsRUFBYixFQUFpQjtBQUNsRDQxQixRQUFFNTFCLEdBQUdrRCxhQUFMLEVBQW9CcXVDLEdBQXBCLENBQXdCLGlCQUF4QixFQUEyQy90QixFQUEzQyxDQUE4QztBQUM1QywyQkFBbUIsU0FBU2d1QixjQUFULEdBQTBCO0FBQzNDNWIsWUFBRSxhQUFGLEVBQWlCeFAsV0FBakIsQ0FBNkIsTUFBN0I7QUFDRDtBQUgyQyxPQUE5QztBQUtELEtBTkQ7QUFPRCxHQWxCRDs7QUFvQkFpb0IsWUFBVTEwQyxTQUFWLEdBQXNCOztBQUVwQkQsaUJBQWEyMEMsU0FGTzs7QUFJcEJpRCxrQkFBYyxTQUFTQSxZQUFULENBQXNCaEQsT0FBdEIsRUFBK0I7QUFDM0NBLGdCQUFVQSxXQUFXLEVBQXJCOztBQUVBO0FBQ0E7QUFDQUEsZ0JBQVUxWSxFQUFFcDRCLE1BQUYsQ0FBUyxJQUFULEVBQWUsRUFBZixFQUFtQjh3QyxPQUFuQixDQUFWO0FBQ0FBLGNBQVFyMEMsT0FBUixHQUFrQixLQUFLQSxPQUFMLENBQWEsQ0FBYixDQUFsQjs7QUFFQSxVQUFJbTZCLFNBQVMsSUFBSXg2QixVQUFVazBDLE1BQWQsQ0FBcUIsS0FBSzl0QyxFQUFMLENBQVEsQ0FBUixDQUFyQixFQUFpQ3N1QyxPQUFqQyxDQUFiOztBQUVBLFVBQUlBLFdBQVdBLFFBQVEvcUIsTUFBdkIsRUFBK0I7QUFDN0IsYUFBSyxJQUFJbkQsU0FBVCxJQUFzQmt1QixRQUFRL3FCLE1BQTlCLEVBQXNDO0FBQ3BDNlEsaUJBQU81USxFQUFQLENBQVVwRCxTQUFWLEVBQXFCa3VCLFFBQVEvcUIsTUFBUixDQUFlbkQsU0FBZixDQUFyQjtBQUNEO0FBQ0Y7QUFDRCxhQUFPZ1UsTUFBUDtBQUNELEtBcEJtQjs7QUFzQnBCaWQsbUJBQWUsU0FBU0EsYUFBVCxDQUF1QnJ4QyxFQUF2QixFQUEyQnN1QyxPQUEzQixFQUFvQztBQUNqRCxVQUFJbUQsT0FBTyxJQUFYO0FBQ0EsVUFBSXgzQyxVQUFVMjdCLEVBQUUsT0FBRixFQUFXO0FBQ3ZCLGlCQUFTLG1CQURjO0FBRXZCLGlCQUFTO0FBRmMsT0FBWCxDQUFkO0FBSUEsVUFBSThiLFVBQVVwRCxRQUFRMkIsTUFBUixJQUFrQmtCLGVBQWVsQixNQUFqQyxJQUEyQyxJQUF6RDtBQUNBLFdBQUssSUFBSXB5QixHQUFULElBQWdCL2lCLE9BQU84NkIsQ0FBUCxDQUFTNFksRUFBVCxDQUFZNTBDLFNBQVosQ0FBc0J1M0MsY0FBdEMsRUFBc0Q7QUFDcEQsWUFBSTN6QixRQUFRLEtBQVo7O0FBRUEsWUFBSTh3QixRQUFRendCLEdBQVIsTUFBaUJLLFNBQXJCLEVBQWdDO0FBQzlCLGNBQUlvd0IsUUFBUXp3QixHQUFSLE1BQWlCLElBQXJCLEVBQTJCO0FBQ3pCTCxvQkFBUSxJQUFSO0FBQ0Q7QUFDRixTQUpELE1BSU87QUFDTEEsa0JBQVEyekIsZUFBZXR6QixHQUFmLENBQVI7QUFDRDs7QUFFRCxZQUFJTCxVQUFVLElBQWQsRUFBb0I7QUFDbEJ2akIsa0JBQVEwM0MsTUFBUixDQUFlVixVQUFVcHpCLEdBQVYsRUFBZW95QixPQUFPeUIsT0FBUCxDQUFmLEVBQWdDcEQsT0FBaEMsQ0FBZjs7QUFFQSxjQUFJendCLFFBQVEsTUFBWixFQUFvQjtBQUNsQixpQkFBSyt6QixRQUFMLENBQWMzM0MsT0FBZDtBQUNEOztBQUVELGNBQUk0akIsUUFBUSxNQUFaLEVBQW9CO0FBQ2xCLGlCQUFLZzBCLGNBQUwsQ0FBb0I1M0MsT0FBcEI7QUFDRDs7QUFFRCxjQUFJNGpCLFFBQVEsT0FBWixFQUFxQjtBQUNuQixpQkFBS2kwQixlQUFMLENBQXFCNzNDLE9BQXJCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFVBQUlxMEMsUUFBUXIwQyxPQUFaLEVBQXFCO0FBQ25CLGFBQUs0akIsR0FBTCxJQUFZeXdCLFFBQVFyMEMsT0FBcEIsRUFBNkI7QUFDM0JBLGtCQUFRMDNDLE1BQVIsQ0FBZXJELFFBQVFyMEMsT0FBUixDQUFnQjRqQixHQUFoQixDQUFmO0FBQ0Q7QUFDRjs7QUFFRDVqQixjQUFRMm5DLElBQVIsQ0FBYSx5Q0FBYixFQUF3RG1RLEtBQXhELENBQThELFVBQVVweUMsQ0FBVixFQUFhO0FBQ3pFLFlBQUkrRyxTQUFTL0csRUFBRStHLE1BQUYsSUFBWS9HLEVBQUVzc0IsVUFBM0I7QUFDQSxZQUFJanNCLEtBQUs0MUIsRUFBRWx2QixNQUFGLENBQVQ7QUFDQStxQyxhQUFLeDNDLE9BQUwsQ0FBYTJuQyxJQUFiLENBQWtCLGVBQWxCLEVBQW1DaHRCLElBQW5DLENBQXdDNVUsR0FBR29jLElBQUgsRUFBeEM7QUFDRCxPQUpEOztBQU1BbmlCLGNBQVEybkMsSUFBUixDQUFhLHVDQUFiLEVBQXNEbVEsS0FBdEQsQ0FBNEQsVUFBVXB5QyxDQUFWLEVBQWE7QUFDdkUsWUFBSStHLFNBQVMvRyxFQUFFK0csTUFBRixJQUFZL0csRUFBRXNzQixVQUEzQjtBQUNBLFlBQUlqc0IsS0FBSzQxQixFQUFFbHZCLE1BQUYsQ0FBVDtBQUNBK3FDLGFBQUt4M0MsT0FBTCxDQUFhMm5DLElBQWIsQ0FBa0IsZ0JBQWxCLEVBQW9DaHRCLElBQXBDLENBQXlDNVUsR0FBR29jLElBQUgsRUFBekM7QUFDRCxPQUpEOztBQU1BLFdBQUtwYyxFQUFMLENBQVF3ckIsTUFBUixDQUFldnhCLE9BQWY7O0FBRUEsYUFBT0EsT0FBUDtBQUNELEtBOUVtQjs7QUFnRnBCMjNDLGNBQVUsU0FBU0EsUUFBVCxDQUFrQjMzQyxPQUFsQixFQUEyQjtBQUNuQyxVQUFJKzNDLHFCQUFxQix3Q0FBekI7QUFDQS8zQyxjQUFRMm5DLElBQVIsQ0FBYW9RLGtCQUFiLEVBQWlDRCxLQUFqQyxDQUF1QyxVQUFVcHlDLENBQVYsRUFBYTtBQUNsRDFGLGdCQUFRMm5DLElBQVIsQ0FBYSxPQUFiLEVBQXNCTCxHQUF0QixDQUEwQnlRLGtCQUExQixFQUE4Q0MsV0FBOUMsQ0FBMEQsVUFBMUQ7QUFDRCxPQUZEO0FBR0QsS0FyRm1COztBQXVGcEJILHFCQUFpQixTQUFTQSxlQUFULENBQXlCNzNDLE9BQXpCLEVBQWtDO0FBQ2pELFVBQUl3M0MsT0FBTyxJQUFYO0FBQ0EsVUFBSVMsbUJBQW1CajRDLFFBQVEybkMsSUFBUixDQUFhLHlDQUFiLENBQXZCO0FBQ0EsVUFBSXVRLFdBQVdELGlCQUFpQnRRLElBQWpCLENBQXNCLHVDQUF0QixDQUFmO0FBQ0EsVUFBSXdRLGVBQWVGLGlCQUFpQnRRLElBQWpCLENBQXNCLGVBQXRCLENBQW5CO0FBQ0EsVUFBSXlRLGVBQWVGLFNBQVM3eEMsR0FBVCxFQUFuQjtBQUNBLFVBQUlzc0MsYUFBSjs7QUFFQSxVQUFJdkssY0FBYyxTQUFTQSxXQUFULEdBQXVCO0FBQ3ZDLFlBQUloZCxNQUFNOHNCLFNBQVM3eEMsR0FBVCxFQUFWO0FBQ0E2eEMsaUJBQVM3eEMsR0FBVCxDQUFhK3hDLFlBQWI7QUFDQVosYUFBS3JkLE1BQUwsQ0FBWStRLFdBQVosQ0FBd0JqcEIsT0FBeEIsQ0FBZ0NLLEtBQWhDO0FBQ0EsWUFBSXF3QixhQUFKLEVBQW1CO0FBQ2pCNkUsZUFBS3JkLE1BQUwsQ0FBWTZCLFFBQVosQ0FBcUI5N0IsU0FBckIsQ0FBK0I0OUIsV0FBL0IsQ0FBMkM2VSxhQUEzQztBQUNBQSwwQkFBZ0IsSUFBaEI7QUFDRDtBQUNENkUsYUFBS3JkLE1BQUwsQ0FBWTZCLFFBQVosQ0FBcUJuOEIsUUFBckIsQ0FBOEJ5OUIsSUFBOUIsQ0FBbUMsYUFBbkMsRUFBa0RsUyxHQUFsRDtBQUNELE9BVEQ7O0FBV0E4c0IsZUFBU0csUUFBVCxDQUFrQixVQUFVM3lDLENBQVYsRUFBYTtBQUM3QixZQUFJQSxFQUFFNHlDLEtBQUYsSUFBVyxFQUFmLEVBQW1CO0FBQ2pCbFE7QUFDQTZQLDJCQUFpQk0sS0FBakIsQ0FBdUIsTUFBdkI7QUFDRDtBQUNGLE9BTEQ7O0FBT0FKLG1CQUFhTCxLQUFiLENBQW1CMVAsV0FBbkI7O0FBRUE2UCx1QkFBaUIxdUIsRUFBakIsQ0FBb0IsT0FBcEIsRUFBNkIsWUFBWTtBQUN2QzJ1QixpQkFBUzUxQixLQUFUO0FBQ0QsT0FGRDs7QUFJQTIxQix1QkFBaUIxdUIsRUFBakIsQ0FBb0IsTUFBcEIsRUFBNEIsWUFBWTtBQUN0Q2l1QixhQUFLcmQsTUFBTCxDQUFZK1EsV0FBWixDQUF3QmpwQixPQUF4QixDQUFnQ0ssS0FBaEM7QUFDRCxPQUZEOztBQUlBdGlCLGNBQVEybkMsSUFBUixDQUFhLHVDQUFiLEVBQXNEbVEsS0FBdEQsQ0FBNEQsWUFBWTtBQUN0RSxZQUFJVSxlQUFlN2MsRUFBRSxJQUFGLEVBQVF6UCxRQUFSLENBQWlCLDBCQUFqQixDQUFuQjs7QUFFQSxZQUFJLENBQUNzc0IsWUFBTCxFQUFtQjtBQUNqQmhCLGVBQUtyZCxNQUFMLENBQVkrUSxXQUFaLENBQXdCanBCLE9BQXhCLENBQWdDSyxLQUFoQyxDQUFzQyxLQUF0QztBQUNBcXdCLDBCQUFnQjZFLEtBQUtyZCxNQUFMLENBQVk2QixRQUFaLENBQXFCOTdCLFNBQXJCLENBQStCMDlCLFdBQS9CLEVBQWhCO0FBQ0FxYSwyQkFBaUJRLFFBQWpCLENBQTBCLE1BQTFCLEVBQWtDRixLQUFsQyxDQUF3QyxNQUF4QztBQUNBTiwyQkFBaUIxdUIsRUFBakIsQ0FBb0IscUJBQXBCLEVBQTJDLHdCQUEzQyxFQUFxRSxVQUFVN2pCLENBQVYsRUFBYTtBQUNoRkEsY0FBRXdzQixlQUFGO0FBQ0QsV0FGRDtBQUdBLGlCQUFPLEtBQVA7QUFDRCxTQVJELE1BUU87QUFDTCxpQkFBTyxJQUFQO0FBQ0Q7QUFDRixPQWREO0FBZUQsS0ExSW1COztBQTRJcEIwbEIsb0JBQWdCLFNBQVNBLGNBQVQsQ0FBd0I1M0MsT0FBeEIsRUFBaUM7QUFDL0MsVUFBSXczQyxPQUFPLElBQVg7QUFDQSxVQUFJa0Isa0JBQWtCMTRDLFFBQVEybkMsSUFBUixDQUFhLHdDQUFiLENBQXRCO0FBQ0EsVUFBSXVRLFdBQVdRLGdCQUFnQi9RLElBQWhCLENBQXFCLHNDQUFyQixDQUFmO0FBQ0EsVUFBSXdRLGVBQWVPLGdCQUFnQi9RLElBQWhCLENBQXFCLGVBQXJCLENBQW5CO0FBQ0EsVUFBSXlRLGVBQWVGLFNBQVM3eEMsR0FBVCxFQUFuQjtBQUNBLFVBQUlzc0MsYUFBSjs7QUFFQSxVQUFJZ0csYUFBYSxTQUFTQSxVQUFULEdBQXNCO0FBQ3JDLFlBQUl2dEIsTUFBTThzQixTQUFTN3hDLEdBQVQsRUFBVjtBQUNBNnhDLGlCQUFTN3hDLEdBQVQsQ0FBYSt4QyxZQUFiO0FBQ0FaLGFBQUtyZCxNQUFMLENBQVkrUSxXQUFaLENBQXdCanBCLE9BQXhCLENBQWdDSyxLQUFoQztBQUNBLFlBQUlxd0IsYUFBSixFQUFtQjtBQUNqQjZFLGVBQUtyZCxNQUFMLENBQVk2QixRQUFaLENBQXFCOTdCLFNBQXJCLENBQStCNDlCLFdBQS9CLENBQTJDNlUsYUFBM0M7QUFDQUEsMEJBQWdCLElBQWhCO0FBQ0Q7QUFDRDZFLGFBQUtyZCxNQUFMLENBQVk2QixRQUFaLENBQXFCbjhCLFFBQXJCLENBQThCeTlCLElBQTlCLENBQW1DLFlBQW5DLEVBQWlEO0FBQy9DVixnQkFBTXhSLEdBRHlDO0FBRS9DM2Usa0JBQVEsUUFGdUM7QUFHL0Ntc0MsZUFBSztBQUgwQyxTQUFqRDtBQUtELE9BYkQ7QUFjQSxVQUFJQyxlQUFlLEtBQW5COztBQUVBWCxlQUFTRyxRQUFULENBQWtCLFVBQVUzeUMsQ0FBVixFQUFhO0FBQzdCLFlBQUlBLEVBQUU0eUMsS0FBRixJQUFXLEVBQWYsRUFBbUI7QUFDakJLO0FBQ0FELDBCQUFnQkgsS0FBaEIsQ0FBc0IsTUFBdEI7QUFDRDtBQUNGLE9BTEQ7O0FBT0FKLG1CQUFhTCxLQUFiLENBQW1CYSxVQUFuQjs7QUFFQUQsc0JBQWdCbnZCLEVBQWhCLENBQW1CLE9BQW5CLEVBQTRCLFlBQVk7QUFDdEMydUIsaUJBQVM1MUIsS0FBVDtBQUNELE9BRkQ7O0FBSUFvMkIsc0JBQWdCbnZCLEVBQWhCLENBQW1CLE1BQW5CLEVBQTJCLFlBQVk7QUFDckNpdUIsYUFBS3JkLE1BQUwsQ0FBWStRLFdBQVosQ0FBd0JqcEIsT0FBeEIsQ0FBZ0NLLEtBQWhDO0FBQ0QsT0FGRDs7QUFJQXRpQixjQUFRMm5DLElBQVIsQ0FBYSxzQ0FBYixFQUFxRG1RLEtBQXJELENBQTJELFlBQVk7QUFDckUsWUFBSVUsZUFBZTdjLEVBQUUsSUFBRixFQUFRelAsUUFBUixDQUFpQiwwQkFBakIsQ0FBbkI7O0FBRUEsWUFBSSxDQUFDc3NCLFlBQUwsRUFBbUI7QUFDakJoQixlQUFLcmQsTUFBTCxDQUFZK1EsV0FBWixDQUF3QmpwQixPQUF4QixDQUFnQ0ssS0FBaEMsQ0FBc0MsS0FBdEM7QUFDQXF3QiwwQkFBZ0I2RSxLQUFLcmQsTUFBTCxDQUFZNkIsUUFBWixDQUFxQjk3QixTQUFyQixDQUErQjA5QixXQUEvQixFQUFoQjtBQUNBOGEsMEJBQWdCRCxRQUFoQixDQUF5QixNQUF6QixFQUFpQ0YsS0FBakMsQ0FBdUMsTUFBdkM7QUFDQUcsMEJBQWdCbnZCLEVBQWhCLENBQW1CLHFCQUFuQixFQUEwQyx3QkFBMUMsRUFBb0UsVUFBVTdqQixDQUFWLEVBQWE7QUFDL0VBLGNBQUV3c0IsZUFBRjtBQUNELFdBRkQ7QUFHQSxpQkFBTyxLQUFQO0FBQ0QsU0FSRCxNQVFPO0FBQ0wsaUJBQU8sSUFBUDtBQUNEO0FBQ0YsT0FkRDtBQWVEO0FBcE1tQixHQUF0Qjs7QUF1TUE7QUFDQSxNQUFJNG1CLFVBQVU7QUFDWkMsbUJBQWUsU0FBU0EsYUFBVCxHQUF5QjtBQUN0Q2w0QyxhQUFPODZCLENBQVAsQ0FBUzRZLEVBQVQsQ0FBWTUwQyxTQUFaLENBQXNCdTNDLGNBQXRCLEdBQXVDdmIsRUFBRXA0QixNQUFGLENBQVMsSUFBVCxFQUFlLEVBQWYsRUFBbUIxQyxPQUFPODZCLENBQVAsQ0FBUzRZLEVBQVQsQ0FBWTUwQyxTQUFaLENBQXNCcTVDLG1CQUF6QyxDQUF2QztBQUNELEtBSFc7QUFJWkMsb0JBQWdCLFNBQVNBLGNBQVQsQ0FBd0I1RSxPQUF4QixFQUFpQztBQUMvQyxhQUFPLEtBQUtyTixJQUFMLENBQVUsWUFBWTtBQUMzQixZQUFJa1MsUUFBUXZkLEVBQUUsSUFBRixDQUFaO0FBQ0F1ZCxjQUFNOXVDLElBQU4sQ0FBVyxXQUFYLEVBQXdCLElBQUlncUMsU0FBSixDQUFjOEUsS0FBZCxFQUFxQjdFLE9BQXJCLENBQXhCO0FBQ0QsT0FITSxDQUFQO0FBSUQsS0FUVztBQVVaOEUsbUJBQWUsU0FBU0EsYUFBVCxDQUF1QjlFLE9BQXZCLEVBQWdDO0FBQzdDLFVBQUkrRSxXQUFXemQsRUFBRXA0QixNQUFGLENBQVMsRUFBVCxFQUFhMUMsT0FBTzg2QixDQUFQLENBQVM0WSxFQUFULENBQVk1MEMsU0FBWixDQUFzQnUzQyxjQUFuQyxFQUFtRDdDLFdBQVcsRUFBOUQsQ0FBZjtBQUNBLFVBQUk5YixPQUFPLElBQVg7QUFDQSxhQUFPdWdCLFFBQVFHLGNBQVIsQ0FBdUJoMkIsS0FBdkIsQ0FBNkJzVixJQUE3QixFQUFtQyxDQUFDNmdCLFFBQUQsQ0FBbkMsQ0FBUDtBQUNELEtBZFc7QUFlWkMsZ0JBQVksU0FBU0EsVUFBVCxDQUFvQmhGLE9BQXBCLEVBQTZCO0FBQ3ZDLFVBQUkrRSxXQUFXemQsRUFBRXA0QixNQUFGLENBQVMsSUFBVCxFQUFlLEVBQWYsRUFBbUIxQyxPQUFPODZCLENBQVAsQ0FBUzRZLEVBQVQsQ0FBWTUwQyxTQUFaLENBQXNCdTNDLGNBQXpDLEVBQXlEN0MsV0FBVyxFQUFwRSxDQUFmO0FBQ0EsVUFBSTliLE9BQU8sSUFBWDtBQUNBLGFBQU91Z0IsUUFBUUcsY0FBUixDQUF1QmgyQixLQUF2QixDQUE2QnNWLElBQTdCLEVBQW1DLENBQUM2Z0IsUUFBRCxDQUFuQyxDQUFQO0FBQ0QsS0FuQlc7QUFvQloxMUMsVUFBTSxTQUFTQSxJQUFULENBQWMyd0MsT0FBZCxFQUF1QjtBQUMzQixVQUFJOWIsT0FBTyxJQUFYO0FBQ0EsYUFBT3VnQixRQUFRSyxhQUFSLENBQXNCbDJCLEtBQXRCLENBQTRCc1YsSUFBNUIsRUFBa0MsQ0FBQzhiLE9BQUQsQ0FBbEMsQ0FBUDtBQUNEO0FBdkJXLEdBQWQ7O0FBMEJBeHpDLFNBQU84NkIsQ0FBUCxDQUFTNFksRUFBVCxDQUFZNTBDLFNBQVosR0FBd0IsVUFBVTZqQixNQUFWLEVBQWtCO0FBQ3hDLFFBQUlzMUIsUUFBUXQxQixNQUFSLENBQUosRUFBcUI7QUFDbkIsYUFBT3MxQixRQUFRdDFCLE1BQVIsRUFBZ0JQLEtBQWhCLENBQXNCLElBQXRCLEVBQTRCcTJCLE1BQU01NUMsU0FBTixDQUFnQjJULEtBQWhCLENBQXNCN0csSUFBdEIsQ0FBMkIwVyxTQUEzQixFQUFzQyxDQUF0QyxDQUE1QixDQUFQO0FBQ0QsS0FGRCxNQUVPLElBQUksQ0FBQyxPQUFPTSxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDLFdBQWhDLEdBQThDbmtCLFFBQVFta0IsTUFBUixDQUEvQyxNQUFvRSxRQUFwRSxJQUFnRixDQUFDQSxNQUFyRixFQUE2RjtBQUNsRyxhQUFPczFCLFFBQVFwMUMsSUFBUixDQUFhdWYsS0FBYixDQUFtQixJQUFuQixFQUF5QkMsU0FBekIsQ0FBUDtBQUNELEtBRk0sTUFFQTtBQUNMeVksUUFBRTRkLEtBQUYsQ0FBUSxZQUFZLzFCLE1BQVosR0FBcUIscUNBQTdCO0FBQ0Q7QUFDRixHQVJEOztBQVVBM2lCLFNBQU84NkIsQ0FBUCxDQUFTNFksRUFBVCxDQUFZNTBDLFNBQVosQ0FBc0I2NUMsV0FBdEIsR0FBb0NwRixTQUFwQzs7QUFFQXZ6QyxTQUFPODZCLENBQVAsQ0FBUzRZLEVBQVQsQ0FBWTUwQyxTQUFaLENBQXNCdTNDLGNBQXRCLEdBQXVDO0FBQ3JDLG1CQUFlLElBRHNCO0FBRXJDLGFBQVMsS0FGNEI7QUFHckMsZ0JBQVksSUFIeUI7QUFJckMsYUFBUyxJQUo0QjtBQUtyQyxZQUFRLEtBTDZCO0FBTXJDLFlBQVEsSUFONkI7QUFPckMsYUFBUyxJQVA0QjtBQVFyQzV0QixZQUFRLEVBUjZCO0FBU3JDbXFCLGlCQUFhO0FBQ1gzZ0IsZUFBUztBQUNQO0FBQ0EsK0JBQXVCLENBRmhCO0FBR1AsK0JBQXVCLENBSGhCO0FBSVAsZ0NBQXdCLENBSmpCO0FBS1AsK0JBQXVCO0FBTGhCLE9BREU7QUFRWEQsWUFBTTtBQUNKLGFBQUssRUFERDtBQUVKLGFBQUssRUFGRDtBQUdKLGNBQU0sRUFIRjtBQUlKLGNBQU0sRUFKRjtBQUtKLGNBQU0sRUFMRjtBQU1KLGNBQU0sRUFORjtBQU9KLGNBQU0sRUFQRjtBQVFKLGNBQU0sRUFSRjtBQVNKLGNBQU0sRUFURjtBQVVKLHNCQUFjLEVBVlY7QUFXSixhQUFLLENBWEQ7QUFZSixlQUFPO0FBQ0wsOEJBQW9CO0FBQ2xCLHFCQUFTLFNBRFM7QUFFbEIsbUJBQU8sS0FGVztBQUdsQixtQkFBTyxLQUhXO0FBSWxCLHNCQUFVO0FBSlE7QUFEZixTQVpIO0FBb0JKLGFBQUs7QUFDSDBCLDBCQUFnQjtBQUNkOW5CLG9CQUFRLFFBRE07QUFFZG1zQyxpQkFBSztBQUZTLFdBRGI7QUFLSG5rQiw0QkFBa0I7QUFDaEJtSSxrQkFBTSxLQURVLENBQ0o7QUFESTtBQUxmLFNBcEJEO0FBNkJKLGdCQUFRLENBN0JKO0FBOEJKLGVBQU8sQ0E5Qkg7QUErQko7QUFDQSxnQkFBUSxDQWhDSjtBQWlDSixlQUFPO0FBakNIO0FBUkssS0FUd0I7QUFxRHJDM0QsaUJBQWEsQ0FBQyw2QkFBRCxDQXJEd0IsRUFxRFM7QUFDOUMrYyxZQUFRO0FBdEQ2QixHQUF2Qzs7QUF5REEsTUFBSSxPQUFPbjFDLE9BQU84NkIsQ0FBUCxDQUFTNFksRUFBVCxDQUFZNTBDLFNBQVosQ0FBc0JxNUMsbUJBQTdCLEtBQXFELFdBQXpELEVBQXNFO0FBQ3BFbjRDLFdBQU84NkIsQ0FBUCxDQUFTNFksRUFBVCxDQUFZNTBDLFNBQVosQ0FBc0JxNUMsbUJBQXRCLEdBQTRDcmQsRUFBRXA0QixNQUFGLENBQVMsSUFBVCxFQUFlLEVBQWYsRUFBbUIxQyxPQUFPODZCLENBQVAsQ0FBUzRZLEVBQVQsQ0FBWTUwQyxTQUFaLENBQXNCdTNDLGNBQXpDLENBQTVDO0FBQ0Q7O0FBRUQsTUFBSWxCLFNBQVNuMUMsT0FBTzg2QixDQUFQLENBQVM0WSxFQUFULENBQVk1MEMsU0FBWixDQUFzQnEyQyxNQUF0QixHQUErQjtBQUMxQ3lELFFBQUk7QUFDRnhELG1CQUFhO0FBQ1hDLGdCQUFRLGFBREc7QUFFWEMsWUFBSSxXQUZPO0FBR1hDLFlBQUksV0FITztBQUlYQyxZQUFJO0FBSk8sT0FEWDtBQU9GQyxnQkFBVTtBQUNSN1IsY0FBTSxNQURFO0FBRVJxRSxnQkFBUSxRQUZBO0FBR1JJLG1CQUFXO0FBSEgsT0FQUjtBQVlGcU4sYUFBTztBQUNMQyxtQkFBVyxnQkFETjtBQUVMQyxpQkFBUyxjQUZKO0FBR0xpRCxpQkFBUyxTQUhKO0FBSUxDLGdCQUFRO0FBSkgsT0FaTDtBQWtCRmhOLFlBQU07QUFDSnRmLGdCQUFRLGFBREo7QUFFSnFwQixnQkFBUTtBQUZKLE9BbEJKO0FBc0JGck8sYUFBTztBQUNMaGIsZ0JBQVEsY0FESDtBQUVMcXBCLGdCQUFRO0FBRkgsT0F0Qkw7QUEwQkZ2MEIsWUFBTTtBQUNKdzBCLGNBQU07QUFERixPQTFCSjtBQTZCRkMsZUFBUztBQUNQbmMsZUFBTyxPQURBO0FBRVBvYyxlQUFPLElBRkE7QUFHUEMsZ0JBQVEsSUFIRDtBQUlQQyxlQUFPLElBSkE7QUFLUDZDLGVBQU8sT0FMQTtBQU1QQyxnQkFBUSxRQU5EO0FBT1BDLGNBQU0sTUFQQztBQVFQQyxnQkFBUSxRQVJEO0FBU1BDLGFBQUssS0FURTtBQVVQQyxnQkFBUSxRQVZEO0FBV1BDLGVBQU8sT0FYQTtBQVlQQyxlQUFPLE9BWkE7QUFhUEMsY0FBTSxNQWJDO0FBY1BDLGNBQU0sTUFkQztBQWVQQyxnQkFBUTtBQWZEO0FBN0JQO0FBRHNDLEdBQTVDO0FBaURELENBM1pBLENBMlpDejVDLE9BQU9nMUMsTUEzWlIsRUEyWmdCaDFDLE9BQU9sQixTQTNadkIsQ0FBRCIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgd3lzaWh0bWw1ID0ge1xuICB2ZXJzaW9uOiBcIjAuMy4wXCIsXG5cbiAgLy8gbmFtZXNwYWNlc1xuICBjb21tYW5kczoge30sXG4gIGRvbToge30sXG4gIHF1aXJrczoge30sXG4gIHRvb2xiYXI6IHt9LFxuICBsYW5nOiB7fSxcbiAgc2VsZWN0aW9uOiB7fSxcbiAgdmlld3M6IHt9LFxuXG4gIElOVklTSUJMRV9TUEFDRTogXCJcXHVGRUZGXCIsXG5cbiAgRU1QVFlfRlVOQ1RJT046IGZ1bmN0aW9uIEVNUFRZX0ZVTkNUSU9OKCkge30sXG5cbiAgRUxFTUVOVF9OT0RFOiAxLFxuICBURVhUX05PREU6IDMsXG5cbiAgQkFDS1NQQUNFX0tFWTogOCxcbiAgRU5URVJfS0VZOiAxMyxcbiAgRVNDQVBFX0tFWTogMjcsXG4gIFNQQUNFX0tFWTogMzIsXG4gIERFTEVURV9LRVk6IDQ2XG59OyAvKipcbiAgICogQGxpY2Vuc2UgUmFuZ3ksIGEgY3Jvc3MtYnJvd3NlciBKYXZhU2NyaXB0IHJhbmdlIGFuZCBzZWxlY3Rpb24gbGlicmFyeVxuICAgKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcmFuZ3kvXG4gICAqXG4gICAqIENvcHlyaWdodCAyMDExLCBUaW0gRG93blxuICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gICAqIFZlcnNpb246IDEuMi4yXG4gICAqIEJ1aWxkIGRhdGU6IDEzIE5vdmVtYmVyIDIwMTFcbiAgICovXG53aW5kb3dbJ3Jhbmd5J10gPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIE9CSkVDVCA9IFwib2JqZWN0XCIsXG4gICAgICBGVU5DVElPTiA9IFwiZnVuY3Rpb25cIixcbiAgICAgIFVOREVGSU5FRCA9IFwidW5kZWZpbmVkXCI7XG5cbiAgdmFyIGRvbVJhbmdlUHJvcGVydGllcyA9IFtcInN0YXJ0Q29udGFpbmVyXCIsIFwic3RhcnRPZmZzZXRcIiwgXCJlbmRDb250YWluZXJcIiwgXCJlbmRPZmZzZXRcIiwgXCJjb2xsYXBzZWRcIiwgXCJjb21tb25BbmNlc3RvckNvbnRhaW5lclwiLCBcIlNUQVJUX1RPX1NUQVJUXCIsIFwiU1RBUlRfVE9fRU5EXCIsIFwiRU5EX1RPX1NUQVJUXCIsIFwiRU5EX1RPX0VORFwiXTtcblxuICB2YXIgZG9tUmFuZ2VNZXRob2RzID0gW1wic2V0U3RhcnRcIiwgXCJzZXRTdGFydEJlZm9yZVwiLCBcInNldFN0YXJ0QWZ0ZXJcIiwgXCJzZXRFbmRcIiwgXCJzZXRFbmRCZWZvcmVcIiwgXCJzZXRFbmRBZnRlclwiLCBcImNvbGxhcHNlXCIsIFwic2VsZWN0Tm9kZVwiLCBcInNlbGVjdE5vZGVDb250ZW50c1wiLCBcImNvbXBhcmVCb3VuZGFyeVBvaW50c1wiLCBcImRlbGV0ZUNvbnRlbnRzXCIsIFwiZXh0cmFjdENvbnRlbnRzXCIsIFwiY2xvbmVDb250ZW50c1wiLCBcImluc2VydE5vZGVcIiwgXCJzdXJyb3VuZENvbnRlbnRzXCIsIFwiY2xvbmVSYW5nZVwiLCBcInRvU3RyaW5nXCIsIFwiZGV0YWNoXCJdO1xuXG4gIHZhciB0ZXh0UmFuZ2VQcm9wZXJ0aWVzID0gW1wiYm91bmRpbmdIZWlnaHRcIiwgXCJib3VuZGluZ0xlZnRcIiwgXCJib3VuZGluZ1RvcFwiLCBcImJvdW5kaW5nV2lkdGhcIiwgXCJodG1sVGV4dFwiLCBcInRleHRcIl07XG5cbiAgLy8gU3Vic2V0IG9mIFRleHRSYW5nZSdzIGZ1bGwgc2V0IG9mIG1ldGhvZHMgdGhhdCB3ZSdyZSBpbnRlcmVzdGVkIGluXG4gIHZhciB0ZXh0UmFuZ2VNZXRob2RzID0gW1wiY29sbGFwc2VcIiwgXCJjb21wYXJlRW5kUG9pbnRzXCIsIFwiZHVwbGljYXRlXCIsIFwiZ2V0Qm9va21hcmtcIiwgXCJtb3ZlVG9Cb29rbWFya1wiLCBcIm1vdmVUb0VsZW1lbnRUZXh0XCIsIFwicGFyZW50RWxlbWVudFwiLCBcInBhc3RlSFRNTFwiLCBcInNlbGVjdFwiLCBcInNldEVuZFBvaW50XCIsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCJdO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gVHJpbyBvZiBmdW5jdGlvbnMgdGFrZW4gZnJvbSBQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZTpcbiAgLy8gaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvZmVhdHVyZS1kZXRlY3Rpb24tc3RhdGUtb2YtdGhlLWFydC1icm93c2VyLXNjcmlwdGluZ1xuICBmdW5jdGlvbiBpc0hvc3RNZXRob2QobywgcCkge1xuICAgIHZhciB0ID0gX3R5cGVvZihvW3BdKTtcbiAgICByZXR1cm4gdCA9PSBGVU5DVElPTiB8fCAhISh0ID09IE9CSkVDVCAmJiBvW3BdKSB8fCB0ID09IFwidW5rbm93blwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNIb3N0T2JqZWN0KG8sIHApIHtcbiAgICByZXR1cm4gISEoX3R5cGVvZihvW3BdKSA9PSBPQkpFQ1QgJiYgb1twXSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvc3RQcm9wZXJ0eShvLCBwKSB7XG4gICAgcmV0dXJuIF90eXBlb2Yob1twXSkgIT0gVU5ERUZJTkVEO1xuICB9XG5cbiAgLy8gQ3JlYXRlcyBhIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNhdmUgdmVyYm9zZSByZXBlYXRlZCBjYWxscyB0byB0ZXN0cyBmdW5jdGlvbnNcbiAgZnVuY3Rpb24gY3JlYXRlTXVsdGlwbGVQcm9wZXJ0eVRlc3QodGVzdEZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG8sIHByb3BzKSB7XG4gICAgICB2YXIgaSA9IHByb3BzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKCF0ZXN0RnVuYyhvLCBwcm9wc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cblxuICAvLyBOZXh0IHRyaW8gb2YgZnVuY3Rpb25zIGFyZSBhIGNvbnZlbmllbmNlIHRvIHNhdmUgdmVyYm9zZSByZXBlYXRlZCBjYWxscyB0byBwcmV2aW91cyB0d28gZnVuY3Rpb25zXG4gIHZhciBhcmVIb3N0TWV0aG9kcyA9IGNyZWF0ZU11bHRpcGxlUHJvcGVydHlUZXN0KGlzSG9zdE1ldGhvZCk7XG4gIHZhciBhcmVIb3N0T2JqZWN0cyA9IGNyZWF0ZU11bHRpcGxlUHJvcGVydHlUZXN0KGlzSG9zdE9iamVjdCk7XG4gIHZhciBhcmVIb3N0UHJvcGVydGllcyA9IGNyZWF0ZU11bHRpcGxlUHJvcGVydHlUZXN0KGlzSG9zdFByb3BlcnR5KTtcblxuICBmdW5jdGlvbiBpc1RleHRSYW5nZShyYW5nZSkge1xuICAgIHJldHVybiByYW5nZSAmJiBhcmVIb3N0TWV0aG9kcyhyYW5nZSwgdGV4dFJhbmdlTWV0aG9kcykgJiYgYXJlSG9zdFByb3BlcnRpZXMocmFuZ2UsIHRleHRSYW5nZVByb3BlcnRpZXMpO1xuICB9XG5cbiAgdmFyIGFwaSA9IHtcbiAgICB2ZXJzaW9uOiBcIjEuMi4yXCIsXG4gICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgIHN1cHBvcnRlZDogdHJ1ZSxcblxuICAgIHV0aWw6IHtcbiAgICAgIGlzSG9zdE1ldGhvZDogaXNIb3N0TWV0aG9kLFxuICAgICAgaXNIb3N0T2JqZWN0OiBpc0hvc3RPYmplY3QsXG4gICAgICBpc0hvc3RQcm9wZXJ0eTogaXNIb3N0UHJvcGVydHksXG4gICAgICBhcmVIb3N0TWV0aG9kczogYXJlSG9zdE1ldGhvZHMsXG4gICAgICBhcmVIb3N0T2JqZWN0czogYXJlSG9zdE9iamVjdHMsXG4gICAgICBhcmVIb3N0UHJvcGVydGllczogYXJlSG9zdFByb3BlcnRpZXMsXG4gICAgICBpc1RleHRSYW5nZTogaXNUZXh0UmFuZ2VcbiAgICB9LFxuXG4gICAgZmVhdHVyZXM6IHt9LFxuXG4gICAgbW9kdWxlczoge30sXG4gICAgY29uZmlnOiB7XG4gICAgICBhbGVydE9uV2FybjogZmFsc2UsXG4gICAgICBwcmVmZXJUZXh0UmFuZ2U6IGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGZhaWwocmVhc29uKSB7XG4gICAgd2luZG93LmFsZXJ0KFwiUmFuZ3kgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGJyb3dzZXIuIFJlYXNvbjogXCIgKyByZWFzb24pO1xuICAgIGFwaS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgYXBpLnN1cHBvcnRlZCA9IGZhbHNlO1xuICB9XG5cbiAgYXBpLmZhaWwgPSBmYWlsO1xuXG4gIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgdmFyIHdhcm5pbmdNZXNzYWdlID0gXCJSYW5neSB3YXJuaW5nOiBcIiArIG1zZztcbiAgICBpZiAoYXBpLmNvbmZpZy5hbGVydE9uV2Fybikge1xuICAgICAgd2luZG93LmFsZXJ0KHdhcm5pbmdNZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2Yod2luZG93LmNvbnNvbGUpICE9IFVOREVGSU5FRCAmJiBfdHlwZW9mKHdpbmRvdy5jb25zb2xlLmxvZykgIT0gVU5ERUZJTkVEKSB7XG4gICAgICB3aW5kb3cuY29uc29sZS5sb2cod2FybmluZ01lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGFwaS53YXJuID0gd2FybjtcblxuICBpZiAoe30uaGFzT3duUHJvcGVydHkpIHtcbiAgICBhcGkudXRpbC5leHRlbmQgPSBmdW5jdGlvbiAobywgcHJvcHMpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gcHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgb1tpXSA9IHByb3BzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBmYWlsKFwiaGFzT3duUHJvcGVydHkgbm90IHN1cHBvcnRlZFwiKTtcbiAgfVxuXG4gIHZhciBpbml0TGlzdGVuZXJzID0gW107XG4gIHZhciBtb2R1bGVJbml0aWFsaXplcnMgPSBbXTtcblxuICAvLyBJbml0aWFsaXphdGlvblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIGlmIChhcGkuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRlc3RSYW5nZTtcbiAgICB2YXIgaW1wbGVtZW50c0RvbVJhbmdlID0gZmFsc2UsXG4gICAgICAgIGltcGxlbWVudHNUZXh0UmFuZ2UgPSBmYWxzZTtcblxuICAgIC8vIEZpcnN0LCBwZXJmb3JtIGJhc2ljIGZlYXR1cmUgdGVzdHNcblxuICAgIGlmIChpc0hvc3RNZXRob2QoZG9jdW1lbnQsIFwiY3JlYXRlUmFuZ2VcIikpIHtcbiAgICAgIHRlc3RSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICBpZiAoYXJlSG9zdE1ldGhvZHModGVzdFJhbmdlLCBkb21SYW5nZU1ldGhvZHMpICYmIGFyZUhvc3RQcm9wZXJ0aWVzKHRlc3RSYW5nZSwgZG9tUmFuZ2VQcm9wZXJ0aWVzKSkge1xuICAgICAgICBpbXBsZW1lbnRzRG9tUmFuZ2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGVzdFJhbmdlLmRldGFjaCgpO1xuICAgIH1cblxuICAgIHZhciBib2R5ID0gaXNIb3N0T2JqZWN0KGRvY3VtZW50LCBcImJvZHlcIikgPyBkb2N1bWVudC5ib2R5IDogZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO1xuXG4gICAgaWYgKGJvZHkgJiYgaXNIb3N0TWV0aG9kKGJvZHksIFwiY3JlYXRlVGV4dFJhbmdlXCIpKSB7XG4gICAgICB0ZXN0UmFuZ2UgPSBib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgaWYgKGlzVGV4dFJhbmdlKHRlc3RSYW5nZSkpIHtcbiAgICAgICAgaW1wbGVtZW50c1RleHRSYW5nZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpbXBsZW1lbnRzRG9tUmFuZ2UgJiYgIWltcGxlbWVudHNUZXh0UmFuZ2UpIHtcbiAgICAgIGZhaWwoXCJOZWl0aGVyIFJhbmdlIG5vciBUZXh0UmFuZ2UgYXJlIGltcGxlbWVudGVkXCIpO1xuICAgIH1cblxuICAgIGFwaS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgYXBpLmZlYXR1cmVzID0ge1xuICAgICAgaW1wbGVtZW50c0RvbVJhbmdlOiBpbXBsZW1lbnRzRG9tUmFuZ2UsXG4gICAgICBpbXBsZW1lbnRzVGV4dFJhbmdlOiBpbXBsZW1lbnRzVGV4dFJhbmdlXG4gICAgfTtcblxuICAgIC8vIEluaXRpYWxpemUgbW9kdWxlcyBhbmQgY2FsbCBpbml0IGxpc3RlbmVyc1xuICAgIHZhciBhbGxMaXN0ZW5lcnMgPSBtb2R1bGVJbml0aWFsaXplcnMuY29uY2F0KGluaXRMaXN0ZW5lcnMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhbGxMaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFsbExpc3RlbmVyc1tpXShhcGkpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgaWYgKGlzSG9zdE9iamVjdCh3aW5kb3csIFwiY29uc29sZVwiKSAmJiBpc0hvc3RNZXRob2Qod2luZG93LmNvbnNvbGUsIFwibG9nXCIpKSB7XG4gICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKFwiSW5pdCBsaXN0ZW5lciB0aHJldyBhbiBleGNlcHRpb24uIENvbnRpbnVpbmcuXCIsIGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFsbG93IGV4dGVybmFsIHNjcmlwdHMgdG8gaW5pdGlhbGl6ZSB0aGlzIGxpYnJhcnkgaW4gY2FzZSBpdCdzIGxvYWRlZCBhZnRlciB0aGUgZG9jdW1lbnQgaGFzIGxvYWRlZFxuICBhcGkuaW5pdCA9IGluaXQ7XG5cbiAgLy8gRXhlY3V0ZSBsaXN0ZW5lciBpbW1lZGlhdGVseSBpZiBhbHJlYWR5IGluaXRpYWxpemVkXG4gIGFwaS5hZGRJbml0TGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBpZiAoYXBpLmluaXRpYWxpemVkKSB7XG4gICAgICBsaXN0ZW5lcihhcGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY3JlYXRlTWlzc2luZ05hdGl2ZUFwaUxpc3RlbmVycyA9IFtdO1xuXG4gIGFwaS5hZGRDcmVhdGVNaXNzaW5nTmF0aXZlQXBpTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBjcmVhdGVNaXNzaW5nTmF0aXZlQXBpTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdOYXRpdmVBcGkod2luKSB7XG4gICAgd2luID0gd2luIHx8IHdpbmRvdztcbiAgICBpbml0KCk7XG5cbiAgICAvLyBOb3RpZnkgbGlzdGVuZXJzXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNyZWF0ZU1pc3NpbmdOYXRpdmVBcGlMaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNyZWF0ZU1pc3NpbmdOYXRpdmVBcGlMaXN0ZW5lcnNbaV0od2luKTtcbiAgICB9XG4gIH1cblxuICBhcGkuY3JlYXRlTWlzc2luZ05hdGl2ZUFwaSA9IGNyZWF0ZU1pc3NpbmdOYXRpdmVBcGk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gTW9kdWxlKG5hbWUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN1cHBvcnRlZCA9IGZhbHNlO1xuICB9XG5cbiAgTW9kdWxlLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuc3VwcG9ydGVkID0gZmFsc2U7XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2R1bGUgJ1wiICsgdGhpcy5uYW1lICsgXCInIGZhaWxlZCB0byBsb2FkOiBcIiArIHJlYXNvbik7XG4gIH07XG5cbiAgTW9kdWxlLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1zZykge1xuICAgIGFwaS53YXJuKFwiTW9kdWxlIFwiICsgdGhpcy5uYW1lICsgXCI6IFwiICsgbXNnKTtcbiAgfTtcblxuICBNb2R1bGUucHJvdG90eXBlLmNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKG1zZykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJFcnJvciBpbiBSYW5neSBcIiArIHRoaXMubmFtZSArIFwiIG1vZHVsZTogXCIgKyBtc2cpO1xuICB9O1xuXG4gIGFwaS5jcmVhdGVNb2R1bGUgPSBmdW5jdGlvbiAobmFtZSwgaW5pdEZ1bmMpIHtcbiAgICB2YXIgbW9kdWxlID0gbmV3IE1vZHVsZShuYW1lKTtcbiAgICBhcGkubW9kdWxlc1tuYW1lXSA9IG1vZHVsZTtcblxuICAgIG1vZHVsZUluaXRpYWxpemVycy5wdXNoKGZ1bmN0aW9uIChhcGkpIHtcbiAgICAgIGluaXRGdW5jKGFwaSwgbW9kdWxlKTtcbiAgICAgIG1vZHVsZS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBtb2R1bGUuc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgfTtcblxuICBhcGkucmVxdWlyZU1vZHVsZXMgPSBmdW5jdGlvbiAobW9kdWxlcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtb2R1bGVzLmxlbmd0aCwgbW9kdWxlLCBtb2R1bGVOYW1lOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIG1vZHVsZU5hbWUgPSBtb2R1bGVzW2ldO1xuICAgICAgbW9kdWxlID0gYXBpLm1vZHVsZXNbbW9kdWxlTmFtZV07XG4gICAgICBpZiAoIW1vZHVsZSB8fCAhKG1vZHVsZSBpbnN0YW5jZW9mIE1vZHVsZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kdWxlICdcIiArIG1vZHVsZU5hbWUgKyBcIicgbm90IGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFtb2R1bGUuc3VwcG9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZHVsZSAnXCIgKyBtb2R1bGVOYW1lICsgXCInIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gV2FpdCBmb3IgZG9jdW1lbnQgdG8gbG9hZCBiZWZvcmUgcnVubmluZyB0ZXN0c1xuXG4gIHZhciBkb2NSZWFkeSA9IGZhbHNlO1xuXG4gIHZhciBsb2FkSGFuZGxlciA9IGZ1bmN0aW9uIGxvYWRIYW5kbGVyKGUpIHtcblxuICAgIGlmICghZG9jUmVhZHkpIHtcbiAgICAgIGRvY1JlYWR5ID0gdHJ1ZTtcbiAgICAgIGlmICghYXBpLmluaXRpYWxpemVkKSB7XG4gICAgICAgIGluaXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gVGVzdCB3aGV0aGVyIHdlIGhhdmUgd2luZG93IGFuZCBkb2N1bWVudCBvYmplY3RzIHRoYXQgd2Ugd2lsbCBuZWVkXG4gIGlmICgodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHdpbmRvdykpID09IFVOREVGSU5FRCkge1xuICAgIGZhaWwoXCJObyB3aW5kb3cgZm91bmRcIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICgodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZG9jdW1lbnQpKSA9PSBVTkRFRklORUQpIHtcbiAgICBmYWlsKFwiTm8gZG9jdW1lbnQgZm91bmRcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlzSG9zdE1ldGhvZChkb2N1bWVudCwgXCJhZGRFdmVudExpc3RlbmVyXCIpKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgbG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxuXG4gIC8vIEFkZCBhIGZhbGxiYWNrIGluIGNhc2UgdGhlIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQgaXNuJ3Qgc3VwcG9ydGVkXG4gIGlmIChpc0hvc3RNZXRob2Qod2luZG93LCBcImFkZEV2ZW50TGlzdGVuZXJcIikpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgbG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChpc0hvc3RNZXRob2Qod2luZG93LCBcImF0dGFjaEV2ZW50XCIpKSB7XG4gICAgd2luZG93LmF0dGFjaEV2ZW50KFwib25sb2FkXCIsIGxvYWRIYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBmYWlsKFwiV2luZG93IGRvZXMgbm90IGhhdmUgcmVxdWlyZWQgYWRkRXZlbnRMaXN0ZW5lciBvciBhdHRhY2hFdmVudCBtZXRob2RcIik7XG4gIH1cblxuICByZXR1cm4gYXBpO1xufSgpO1xucmFuZ3kuY3JlYXRlTW9kdWxlKFwiRG9tVXRpbFwiLCBmdW5jdGlvbiAoYXBpLCBtb2R1bGUpIHtcblxuICB2YXIgVU5ERUYgPSBcInVuZGVmaW5lZFwiO1xuICB2YXIgdXRpbCA9IGFwaS51dGlsO1xuXG4gIC8vIFBlcmZvcm0gZmVhdHVyZSB0ZXN0c1xuICBpZiAoIXV0aWwuYXJlSG9zdE1ldGhvZHMoZG9jdW1lbnQsIFtcImNyZWF0ZURvY3VtZW50RnJhZ21lbnRcIiwgXCJjcmVhdGVFbGVtZW50XCIsIFwiY3JlYXRlVGV4dE5vZGVcIl0pKSB7XG4gICAgbW9kdWxlLmZhaWwoXCJkb2N1bWVudCBtaXNzaW5nIGEgTm9kZSBjcmVhdGlvbiBtZXRob2RcIik7XG4gIH1cblxuICBpZiAoIXV0aWwuaXNIb3N0TWV0aG9kKGRvY3VtZW50LCBcImdldEVsZW1lbnRzQnlUYWdOYW1lXCIpKSB7XG4gICAgbW9kdWxlLmZhaWwoXCJkb2N1bWVudCBtaXNzaW5nIGdldEVsZW1lbnRzQnlUYWdOYW1lIG1ldGhvZFwiKTtcbiAgfVxuXG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGlmICghdXRpbC5hcmVIb3N0TWV0aG9kcyhlbCwgW1wiaW5zZXJ0QmVmb3JlXCIsIFwiYXBwZW5kQ2hpbGRcIiwgXCJjbG9uZU5vZGVcIl0gfHwgIXV0aWwuYXJlSG9zdE9iamVjdHMoZWwsIFtcInByZXZpb3VzU2libGluZ1wiLCBcIm5leHRTaWJsaW5nXCIsIFwiY2hpbGROb2Rlc1wiLCBcInBhcmVudE5vZGVcIl0pKSkge1xuICAgIG1vZHVsZS5mYWlsKFwiSW5jb21wbGV0ZSBFbGVtZW50IGltcGxlbWVudGF0aW9uXCIpO1xuICB9XG5cbiAgLy8gaW5uZXJIVE1MIGlzIHJlcXVpcmVkIGZvciBSYW5nZSdzIGNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCBtZXRob2RcbiAgaWYgKCF1dGlsLmlzSG9zdFByb3BlcnR5KGVsLCBcImlubmVySFRNTFwiKSkge1xuICAgIG1vZHVsZS5mYWlsKFwiRWxlbWVudCBpcyBtaXNzaW5nIGlubmVySFRNTCBwcm9wZXJ0eVwiKTtcbiAgfVxuXG4gIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwidGVzdFwiKTtcbiAgaWYgKCF1dGlsLmFyZUhvc3RNZXRob2RzKHRleHROb2RlLCBbXCJzcGxpdFRleHRcIiwgXCJkZWxldGVEYXRhXCIsIFwiaW5zZXJ0RGF0YVwiLCBcImFwcGVuZERhdGFcIiwgXCJjbG9uZU5vZGVcIl0gfHwgIXV0aWwuYXJlSG9zdE9iamVjdHMoZWwsIFtcInByZXZpb3VzU2libGluZ1wiLCBcIm5leHRTaWJsaW5nXCIsIFwiY2hpbGROb2Rlc1wiLCBcInBhcmVudE5vZGVcIl0pIHx8ICF1dGlsLmFyZUhvc3RQcm9wZXJ0aWVzKHRleHROb2RlLCBbXCJkYXRhXCJdKSkpIHtcbiAgICBtb2R1bGUuZmFpbChcIkluY29tcGxldGUgVGV4dCBOb2RlIGltcGxlbWVudGF0aW9uXCIpO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBSZW1vdmVkIHVzZSBvZiBpbmRleE9mIGJlY2F1c2Ugb2YgYSBiaXphcnJlIGJ1ZyBpbiBPcGVyYSB0aGF0IGlzIHRocm93biBpbiBvbmUgb2YgdGhlIEFjaWQzIHRlc3RzLiBJIGhhdmVuJ3QgYmVlblxuICAvLyBhYmxlIHRvIHJlcGxpY2F0ZSBpdCBvdXRzaWRlIG9mIHRoZSB0ZXN0LiBUaGUgYnVnIGlzIHRoYXQgaW5kZXhPZiByZXR1cm5zIC0xIHdoZW4gY2FsbGVkIG9uIGFuIEFycmF5IHRoYXRcbiAgLy8gY29udGFpbnMganVzdCB0aGUgZG9jdW1lbnQgYXMgYSBzaW5nbGUgZWxlbWVudCBhbmQgdGhlIHZhbHVlIHNlYXJjaGVkIGZvciBpcyB0aGUgZG9jdW1lbnQuXG4gIHZhciBhcnJheUNvbnRhaW5zID0gLypBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA/XG4gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oYXJyLCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyLmluZGV4T2YodmFsKSA+IC0xO1xuICAgICAgICAgICAgICAgICAgICAgIH06Ki9cblxuICBmdW5jdGlvbiBhcnJheUNvbnRhaW5zKGFyciwgdmFsKSB7XG4gICAgdmFyIGkgPSBhcnIubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChhcnJbaV0gPT09IHZhbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIE9wZXJhIDExIHB1dHMgSFRNTCBlbGVtZW50cyBpbiB0aGUgbnVsbCBuYW1lc3BhY2UsIGl0IHNlZW1zLCBhbmQgSUUgNyBoYXMgdW5kZWZpbmVkIG5hbWVzcGFjZVVSSVxuICBmdW5jdGlvbiBpc0h0bWxOYW1lc3BhY2Uobm9kZSkge1xuICAgIHZhciBucztcbiAgICByZXR1cm4gX3R5cGVvZihub2RlLm5hbWVzcGFjZVVSSSkgPT0gVU5ERUYgfHwgKG5zID0gbm9kZS5uYW1lc3BhY2VVUkkpID09PSBudWxsIHx8IG5zID09IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyZW50RWxlbWVudChub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gcGFyZW50Lm5vZGVUeXBlID09IDEgPyBwYXJlbnQgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Tm9kZUluZGV4KG5vZGUpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZykge1xuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vZGVMZW5ndGgobm9kZSkge1xuICAgIHZhciBjaGlsZE5vZGVzO1xuICAgIHJldHVybiBpc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpID8gbm9kZS5sZW5ndGggOiAoY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcykgPyBjaGlsZE5vZGVzLmxlbmd0aCA6IDA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb21tb25BbmNlc3Rvcihub2RlMSwgbm9kZTIpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gW10sXG4gICAgICAgIG47XG4gICAgZm9yIChuID0gbm9kZTE7IG47IG4gPSBuLnBhcmVudE5vZGUpIHtcbiAgICAgIGFuY2VzdG9ycy5wdXNoKG4pO1xuICAgIH1cblxuICAgIGZvciAobiA9IG5vZGUyOyBuOyBuID0gbi5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoYXJyYXlDb250YWlucyhhbmNlc3RvcnMsIG4pKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBbmNlc3Rvck9mKGFuY2VzdG9yLCBkZXNjZW5kYW50LCBzZWxmSXNBbmNlc3Rvcikge1xuICAgIHZhciBuID0gc2VsZklzQW5jZXN0b3IgPyBkZXNjZW5kYW50IDogZGVzY2VuZGFudC5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiA9PT0gYW5jZXN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbi5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDbG9zZXN0QW5jZXN0b3JJbihub2RlLCBhbmNlc3Rvciwgc2VsZklzQW5jZXN0b3IpIHtcbiAgICB2YXIgcCxcbiAgICAgICAgbiA9IHNlbGZJc0FuY2VzdG9yID8gbm9kZSA6IG5vZGUucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAobikge1xuICAgICAgcCA9IG4ucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwID09PSBhbmNlc3Rvcikge1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICAgIG4gPSBwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ2hhcmFjdGVyRGF0YU5vZGUobm9kZSkge1xuICAgIHZhciB0ID0gbm9kZS5ub2RlVHlwZTtcbiAgICByZXR1cm4gdCA9PSAzIHx8IHQgPT0gNCB8fCB0ID09IDg7IC8vIFRleHQsIENEYXRhU2VjdGlvbiBvciBDb21tZW50XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRBZnRlcihub2RlLCBwcmVjZWRpbmdOb2RlKSB7XG4gICAgdmFyIG5leHROb2RlID0gcHJlY2VkaW5nTm9kZS5uZXh0U2libGluZyxcbiAgICAgICAgcGFyZW50ID0gcHJlY2VkaW5nTm9kZS5wYXJlbnROb2RlO1xuICAgIGlmIChuZXh0Tm9kZSkge1xuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBuZXh0Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvLyBOb3RlIHRoYXQgd2UgY2Fubm90IHVzZSBzcGxpdFRleHQoKSBiZWNhdXNlIGl0IGlzIGJ1Z3JpZGRlbiBpbiBJRSA5LlxuICBmdW5jdGlvbiBzcGxpdERhdGFOb2RlKG5vZGUsIGluZGV4KSB7XG4gICAgdmFyIG5ld05vZGUgPSBub2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgbmV3Tm9kZS5kZWxldGVEYXRhKDAsIGluZGV4KTtcbiAgICBub2RlLmRlbGV0ZURhdGEoaW5kZXgsIG5vZGUubGVuZ3RoIC0gaW5kZXgpO1xuICAgIGluc2VydEFmdGVyKG5ld05vZGUsIG5vZGUpO1xuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihub2RlLm93bmVyRG9jdW1lbnQpICE9IFVOREVGKSB7XG4gICAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihub2RlLmRvY3VtZW50KSAhPSBVTkRFRikge1xuICAgICAgcmV0dXJuIG5vZGUuZG9jdW1lbnQ7XG4gICAgfSBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBnZXREb2N1bWVudChub2RlLnBhcmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXREb2N1bWVudDogbm8gZG9jdW1lbnQgZm91bmQgZm9yIG5vZGVcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgICB2YXIgZG9jID0gZ2V0RG9jdW1lbnQobm9kZSk7XG4gICAgaWYgKF90eXBlb2YoZG9jLmRlZmF1bHRWaWV3KSAhPSBVTkRFRikge1xuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldztcbiAgICB9IGVsc2UgaWYgKF90eXBlb2YoZG9jLnBhcmVudFdpbmRvdykgIT0gVU5ERUYpIHtcbiAgICAgIHJldHVybiBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGEgd2luZG93IG9iamVjdCBmb3Igbm9kZVwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJZnJhbWVEb2N1bWVudChpZnJhbWVFbCkge1xuICAgIGlmIChfdHlwZW9mKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCkgIT0gVU5ERUYpIHtcbiAgICAgIHJldHVybiBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQ7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cpICE9IFVOREVGKSB7XG4gICAgICByZXR1cm4gaWZyYW1lRWwuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0SWZyYW1lV2luZG93OiBObyBEb2N1bWVudCBvYmplY3QgZm91bmQgZm9yIGlmcmFtZSBlbGVtZW50XCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElmcmFtZVdpbmRvdyhpZnJhbWVFbCkge1xuICAgIGlmIChfdHlwZW9mKGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cpICE9IFVOREVGKSB7XG4gICAgICByZXR1cm4gaWZyYW1lRWwuY29udGVudFdpbmRvdztcbiAgICB9IGVsc2UgaWYgKF90eXBlb2YoaWZyYW1lRWwuY29udGVudERvY3VtZW50KSAhPSBVTkRFRikge1xuICAgICAgcmV0dXJuIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0SWZyYW1lV2luZG93OiBObyBXaW5kb3cgb2JqZWN0IGZvdW5kIGZvciBpZnJhbWUgZWxlbWVudFwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCb2R5KGRvYykge1xuICAgIHJldHVybiB1dGlsLmlzSG9zdE9iamVjdChkb2MsIFwiYm9keVwiKSA/IGRvYy5ib2R5IDogZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJvb3RDb250YWluZXIobm9kZSkge1xuICAgIHZhciBwYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlUG9pbnRzKG5vZGVBLCBvZmZzZXRBLCBub2RlQiwgb2Zmc2V0Qikge1xuICAgIC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1UcmF2ZXJzYWwtUmFuZ2UvcmFuZ2VzLmh0bWwjTGV2ZWwtMi1SYW5nZS1Db21wYXJpbmdcbiAgICB2YXIgbm9kZUMsIHJvb3QsIGNoaWxkQSwgY2hpbGRCLCBuO1xuICAgIGlmIChub2RlQSA9PSBub2RlQikge1xuXG4gICAgICAvLyBDYXNlIDE6IG5vZGVzIGFyZSB0aGUgc2FtZVxuICAgICAgcmV0dXJuIG9mZnNldEEgPT09IG9mZnNldEIgPyAwIDogb2Zmc2V0QSA8IG9mZnNldEIgPyAtMSA6IDE7XG4gICAgfSBlbHNlIGlmIChub2RlQyA9IGdldENsb3Nlc3RBbmNlc3RvckluKG5vZGVCLCBub2RlQSwgdHJ1ZSkpIHtcblxuICAgICAgLy8gQ2FzZSAyOiBub2RlIEMgKGNvbnRhaW5lciBCIG9yIGFuIGFuY2VzdG9yKSBpcyBhIGNoaWxkIG5vZGUgb2YgQVxuICAgICAgcmV0dXJuIG9mZnNldEEgPD0gZ2V0Tm9kZUluZGV4KG5vZGVDKSA/IC0xIDogMTtcbiAgICB9IGVsc2UgaWYgKG5vZGVDID0gZ2V0Q2xvc2VzdEFuY2VzdG9ySW4obm9kZUEsIG5vZGVCLCB0cnVlKSkge1xuXG4gICAgICAvLyBDYXNlIDM6IG5vZGUgQyAoY29udGFpbmVyIEEgb3IgYW4gYW5jZXN0b3IpIGlzIGEgY2hpbGQgbm9kZSBvZiBCXG4gICAgICByZXR1cm4gZ2V0Tm9kZUluZGV4KG5vZGVDKSA8IG9mZnNldEIgPyAtMSA6IDE7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gQ2FzZSA0OiBjb250YWluZXJzIGFyZSBzaWJsaW5ncyBvciBkZXNjZW5kYW50cyBvZiBzaWJsaW5nc1xuICAgICAgcm9vdCA9IGdldENvbW1vbkFuY2VzdG9yKG5vZGVBLCBub2RlQik7XG4gICAgICBjaGlsZEEgPSBub2RlQSA9PT0gcm9vdCA/IHJvb3QgOiBnZXRDbG9zZXN0QW5jZXN0b3JJbihub2RlQSwgcm9vdCwgdHJ1ZSk7XG4gICAgICBjaGlsZEIgPSBub2RlQiA9PT0gcm9vdCA/IHJvb3QgOiBnZXRDbG9zZXN0QW5jZXN0b3JJbihub2RlQiwgcm9vdCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChjaGlsZEEgPT09IGNoaWxkQikge1xuICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCBiZSBwb3NzaWJsZVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbXBhcmVQb2ludHMgZ290IHRvIGNhc2UgNCBhbmQgY2hpbGRBIGFuZCBjaGlsZEIgYXJlIHRoZSBzYW1lIVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSByb290LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgaWYgKG4gPT09IGNoaWxkQSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gY2hpbGRCKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbiA9IG4ubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5vdCBiZSBoZXJlIVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmcmFnbWVudEZyb21Ob2RlQ2hpbGRyZW4obm9kZSkge1xuICAgIHZhciBmcmFnbWVudCA9IGdldERvY3VtZW50KG5vZGUpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgY2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkID0gbm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3ROb2RlKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiBcIltObyBub2RlXVwiO1xuICAgIH1cbiAgICBpZiAoaXNDaGFyYWN0ZXJEYXRhTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuICdcIicgKyBub2RlLmRhdGEgKyAnXCInO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICB2YXIgaWRBdHRyID0gbm9kZS5pZCA/ICcgaWQ9XCInICsgbm9kZS5pZCArICdcIicgOiBcIlwiO1xuICAgICAgcmV0dXJuIFwiPFwiICsgbm9kZS5ub2RlTmFtZSArIGlkQXR0ciArIFwiPltcIiArIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggKyBcIl1cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZU5hbWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gTm9kZUl0ZXJhdG9yKHJvb3QpIHtcbiAgICB0aGlzLnJvb3QgPSByb290O1xuICAgIHRoaXMuX25leHQgPSByb290O1xuICB9XG5cbiAgTm9kZUl0ZXJhdG9yLnByb3RvdHlwZSA9IHtcbiAgICBfY3VycmVudDogbnVsbCxcblxuICAgIGhhc05leHQ6IGZ1bmN0aW9uIGhhc05leHQoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl9uZXh0O1xuICAgIH0sXG5cbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIG4gPSB0aGlzLl9jdXJyZW50ID0gdGhpcy5fbmV4dDtcbiAgICAgIHZhciBjaGlsZCwgbmV4dDtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICAgIGNoaWxkID0gbi5maXJzdENoaWxkO1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICB0aGlzLl9uZXh0ID0gY2hpbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICAgICAgd2hpbGUgKG4gIT09IHRoaXMucm9vdCAmJiAhKG5leHQgPSBuLm5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fbmV4dCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICAgIH0sXG5cbiAgICBkZXRhY2g6IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9uZXh0ID0gdGhpcy5yb290ID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3Iocm9vdCkge1xuICAgIHJldHVybiBuZXcgTm9kZUl0ZXJhdG9yKHJvb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gRG9tUG9zaXRpb24obm9kZSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfVxuXG4gIERvbVBvc2l0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhwb3MpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUgPT09IHBvcy5ub2RlICYgdGhpcy5vZmZzZXQgPT0gcG9zLm9mZnNldDtcbiAgICB9LFxuXG4gICAgaW5zcGVjdDogZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgIHJldHVybiBcIltEb21Qb3NpdGlvbihcIiArIGluc3BlY3ROb2RlKHRoaXMubm9kZSkgKyBcIjpcIiArIHRoaXMub2Zmc2V0ICsgXCIpXVwiO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBET01FeGNlcHRpb24oY29kZU5hbWUpIHtcbiAgICB0aGlzLmNvZGUgPSB0aGlzW2NvZGVOYW1lXTtcbiAgICB0aGlzLmNvZGVOYW1lID0gY29kZU5hbWU7XG4gICAgdGhpcy5tZXNzYWdlID0gXCJET01FeGNlcHRpb246IFwiICsgdGhpcy5jb2RlTmFtZTtcbiAgfVxuXG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgSU5ERVhfU0laRV9FUlI6IDEsXG4gICAgSElFUkFSQ0hZX1JFUVVFU1RfRVJSOiAzLFxuICAgIFdST05HX0RPQ1VNRU5UX0VSUjogNCxcbiAgICBOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlI6IDcsXG4gICAgTk9UX0ZPVU5EX0VSUjogOCxcbiAgICBOT1RfU1VQUE9SVEVEX0VSUjogOSxcbiAgICBJTlZBTElEX1NUQVRFX0VSUjogMTFcbiAgfTtcblxuICBET01FeGNlcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gIH07XG5cbiAgYXBpLmRvbSA9IHtcbiAgICBhcnJheUNvbnRhaW5zOiBhcnJheUNvbnRhaW5zLFxuICAgIGlzSHRtbE5hbWVzcGFjZTogaXNIdG1sTmFtZXNwYWNlLFxuICAgIHBhcmVudEVsZW1lbnQ6IHBhcmVudEVsZW1lbnQsXG4gICAgZ2V0Tm9kZUluZGV4OiBnZXROb2RlSW5kZXgsXG4gICAgZ2V0Tm9kZUxlbmd0aDogZ2V0Tm9kZUxlbmd0aCxcbiAgICBnZXRDb21tb25BbmNlc3RvcjogZ2V0Q29tbW9uQW5jZXN0b3IsXG4gICAgaXNBbmNlc3Rvck9mOiBpc0FuY2VzdG9yT2YsXG4gICAgZ2V0Q2xvc2VzdEFuY2VzdG9ySW46IGdldENsb3Nlc3RBbmNlc3RvckluLFxuICAgIGlzQ2hhcmFjdGVyRGF0YU5vZGU6IGlzQ2hhcmFjdGVyRGF0YU5vZGUsXG4gICAgaW5zZXJ0QWZ0ZXI6IGluc2VydEFmdGVyLFxuICAgIHNwbGl0RGF0YU5vZGU6IHNwbGl0RGF0YU5vZGUsXG4gICAgZ2V0RG9jdW1lbnQ6IGdldERvY3VtZW50LFxuICAgIGdldFdpbmRvdzogZ2V0V2luZG93LFxuICAgIGdldElmcmFtZVdpbmRvdzogZ2V0SWZyYW1lV2luZG93LFxuICAgIGdldElmcmFtZURvY3VtZW50OiBnZXRJZnJhbWVEb2N1bWVudCxcbiAgICBnZXRCb2R5OiBnZXRCb2R5LFxuICAgIGdldFJvb3RDb250YWluZXI6IGdldFJvb3RDb250YWluZXIsXG4gICAgY29tcGFyZVBvaW50czogY29tcGFyZVBvaW50cyxcbiAgICBpbnNwZWN0Tm9kZTogaW5zcGVjdE5vZGUsXG4gICAgZnJhZ21lbnRGcm9tTm9kZUNoaWxkcmVuOiBmcmFnbWVudEZyb21Ob2RlQ2hpbGRyZW4sXG4gICAgY3JlYXRlSXRlcmF0b3I6IGNyZWF0ZUl0ZXJhdG9yLFxuICAgIERvbVBvc2l0aW9uOiBEb21Qb3NpdGlvblxuICB9O1xuXG4gIGFwaS5ET01FeGNlcHRpb24gPSBET01FeGNlcHRpb247XG59KTtyYW5neS5jcmVhdGVNb2R1bGUoXCJEb21SYW5nZVwiLCBmdW5jdGlvbiAoYXBpLCBtb2R1bGUpIHtcbiAgYXBpLnJlcXVpcmVNb2R1bGVzKFtcIkRvbVV0aWxcIl0pO1xuXG4gIHZhciBkb20gPSBhcGkuZG9tO1xuICB2YXIgRG9tUG9zaXRpb24gPSBkb20uRG9tUG9zaXRpb247XG4gIHZhciBET01FeGNlcHRpb24gPSBhcGkuRE9NRXhjZXB0aW9uO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbnNcblxuICBmdW5jdGlvbiBpc05vblRleHRQYXJ0aWFsbHlTZWxlY3RlZChub2RlLCByYW5nZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlICE9IDMgJiYgKGRvbS5pc0FuY2VzdG9yT2Yobm9kZSwgcmFuZ2Uuc3RhcnRDb250YWluZXIsIHRydWUpIHx8IGRvbS5pc0FuY2VzdG9yT2Yobm9kZSwgcmFuZ2UuZW5kQ29udGFpbmVyLCB0cnVlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSYW5nZURvY3VtZW50KHJhbmdlKSB7XG4gICAgcmV0dXJuIGRvbS5nZXREb2N1bWVudChyYW5nZS5zdGFydENvbnRhaW5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHJhbmdlLCB0eXBlLCBhcmdzKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IHJhbmdlLl9saXN0ZW5lcnNbdHlwZV07XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbChyYW5nZSwgeyB0YXJnZXQ6IHJhbmdlLCBhcmdzOiBhcmdzIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJvdW5kYXJ5QmVmb3JlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBEb21Qb3NpdGlvbihub2RlLnBhcmVudE5vZGUsIGRvbS5nZXROb2RlSW5kZXgobm9kZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Qm91bmRhcnlBZnRlck5vZGUobm9kZSkge1xuICAgIHJldHVybiBuZXcgRG9tUG9zaXRpb24obm9kZS5wYXJlbnROb2RlLCBkb20uZ2V0Tm9kZUluZGV4KG5vZGUpICsgMSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnROb2RlQXRQb3NpdGlvbihub2RlLCBuLCBvKSB7XG4gICAgdmFyIGZpcnN0Tm9kZUluc2VydGVkID0gbm9kZS5ub2RlVHlwZSA9PSAxMSA/IG5vZGUuZmlyc3RDaGlsZCA6IG5vZGU7XG4gICAgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKG4pKSB7XG4gICAgICBpZiAobyA9PSBuLmxlbmd0aCkge1xuICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIobm9kZSwgbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG8gPT0gMCA/IG4gOiBkb20uc3BsaXREYXRhTm9kZShuLCBvKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvID49IG4uY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIG4uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4uaW5zZXJ0QmVmb3JlKG5vZGUsIG4uY2hpbGROb2Rlc1tvXSk7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdE5vZGVJbnNlcnRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lU3VidHJlZShpdGVyYXRvcikge1xuICAgIHZhciBwYXJ0aWFsbHlTZWxlY3RlZDtcbiAgICBmb3IgKHZhciBub2RlLCBmcmFnID0gZ2V0UmFuZ2VEb2N1bWVudChpdGVyYXRvci5yYW5nZSkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdWJJdGVyYXRvcjsgbm9kZSA9IGl0ZXJhdG9yLm5leHQoKTspIHtcbiAgICAgIHBhcnRpYWxseVNlbGVjdGVkID0gaXRlcmF0b3IuaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUoKTtcblxuICAgICAgbm9kZSA9IG5vZGUuY2xvbmVOb2RlKCFwYXJ0aWFsbHlTZWxlY3RlZCk7XG4gICAgICBpZiAocGFydGlhbGx5U2VsZWN0ZWQpIHtcbiAgICAgICAgc3ViSXRlcmF0b3IgPSBpdGVyYXRvci5nZXRTdWJ0cmVlSXRlcmF0b3IoKTtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjbG9uZVN1YnRyZWUoc3ViSXRlcmF0b3IpKTtcbiAgICAgICAgc3ViSXRlcmF0b3IuZGV0YWNoKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxMCkge1xuICAgICAgICAvLyBEb2N1bWVudFR5cGVcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIkhJRVJBUkNIWV9SRVFVRVNUX0VSUlwiKTtcbiAgICAgIH1cbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZVN1YnRyZWUocmFuZ2VJdGVyYXRvciwgZnVuYywgaXRlcmF0b3JTdGF0ZSkge1xuICAgIHZhciBpdCwgbjtcbiAgICBpdGVyYXRvclN0YXRlID0gaXRlcmF0b3JTdGF0ZSB8fCB7IHN0b3A6IGZhbHNlIH07XG4gICAgZm9yICh2YXIgbm9kZSwgc3ViUmFuZ2VJdGVyYXRvcjsgbm9kZSA9IHJhbmdlSXRlcmF0b3IubmV4dCgpOykge1xuICAgICAgLy9sb2cuZGVidWcoXCJpdGVyYXRlU3VidHJlZSwgcGFydGlhbGx5IHNlbGVjdGVkOiBcIiArIHJhbmdlSXRlcmF0b3IuaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUoKSwgbm9kZVRvU3RyaW5nKG5vZGUpKTtcbiAgICAgIGlmIChyYW5nZUl0ZXJhdG9yLmlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlKCkpIHtcbiAgICAgICAgLy8gVGhlIG5vZGUgaXMgcGFydGlhbGx5IHNlbGVjdGVkIGJ5IHRoZSBSYW5nZSwgc28gd2UgY2FuIHVzZSBhIG5ldyBSYW5nZUl0ZXJhdG9yIG9uIHRoZSBwb3J0aW9uIG9mIHRoZVxuICAgICAgICAvLyBub2RlIHNlbGVjdGVkIGJ5IHRoZSBSYW5nZS5cbiAgICAgICAgaWYgKGZ1bmMobm9kZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaXRlcmF0b3JTdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ViUmFuZ2VJdGVyYXRvciA9IHJhbmdlSXRlcmF0b3IuZ2V0U3VidHJlZUl0ZXJhdG9yKCk7XG4gICAgICAgICAgaXRlcmF0ZVN1YnRyZWUoc3ViUmFuZ2VJdGVyYXRvciwgZnVuYywgaXRlcmF0b3JTdGF0ZSk7XG4gICAgICAgICAgc3ViUmFuZ2VJdGVyYXRvci5kZXRhY2godHJ1ZSk7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yU3RhdGUuc3RvcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHdob2xlIG5vZGUgaXMgc2VsZWN0ZWQsIHNvIHdlIGNhbiB1c2UgZWZmaWNpZW50IERPTSBpdGVyYXRpb24gdG8gaXRlcmF0ZSBvdmVyIHRoZSBub2RlIGFuZCBpdHNcbiAgICAgICAgLy8gZGVzY2VuZGFudFxuICAgICAgICBpdCA9IGRvbS5jcmVhdGVJdGVyYXRvcihub2RlKTtcbiAgICAgICAgd2hpbGUgKG4gPSBpdC5uZXh0KCkpIHtcbiAgICAgICAgICBpZiAoZnVuYyhuKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yU3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlU3VidHJlZShpdGVyYXRvcikge1xuICAgIHZhciBzdWJJdGVyYXRvcjtcbiAgICB3aGlsZSAoaXRlcmF0b3IubmV4dCgpKSB7XG4gICAgICBpZiAoaXRlcmF0b3IuaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUoKSkge1xuICAgICAgICBzdWJJdGVyYXRvciA9IGl0ZXJhdG9yLmdldFN1YnRyZWVJdGVyYXRvcigpO1xuICAgICAgICBkZWxldGVTdWJ0cmVlKHN1Ykl0ZXJhdG9yKTtcbiAgICAgICAgc3ViSXRlcmF0b3IuZGV0YWNoKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3IucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdFN1YnRyZWUoaXRlcmF0b3IpIHtcblxuICAgIGZvciAodmFyIG5vZGUsIGZyYWcgPSBnZXRSYW5nZURvY3VtZW50KGl0ZXJhdG9yLnJhbmdlKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIHN1Ykl0ZXJhdG9yOyBub2RlID0gaXRlcmF0b3IubmV4dCgpOykge1xuXG4gICAgICBpZiAoaXRlcmF0b3IuaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUoKSkge1xuICAgICAgICBub2RlID0gbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICBzdWJJdGVyYXRvciA9IGl0ZXJhdG9yLmdldFN1YnRyZWVJdGVyYXRvcigpO1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGV4dHJhY3RTdWJ0cmVlKHN1Ykl0ZXJhdG9yKSk7XG4gICAgICAgIHN1Ykl0ZXJhdG9yLmRldGFjaCh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdG9yLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMTApIHtcbiAgICAgICAgLy8gRG9jdW1lbnRUeXBlXG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJISUVSQVJDSFlfUkVRVUVTVF9FUlJcIik7XG4gICAgICB9XG4gICAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vZGVzSW5SYW5nZShyYW5nZSwgbm9kZVR5cGVzLCBmaWx0ZXIpIHtcbiAgICAvL2xvZy5pbmZvKFwiZ2V0Tm9kZXNJblJhbmdlLCBcIiArIG5vZGVUeXBlcy5qb2luKFwiLFwiKSk7XG4gICAgdmFyIGZpbHRlck5vZGVUeXBlcyA9ICEhKG5vZGVUeXBlcyAmJiBub2RlVHlwZXMubGVuZ3RoKSxcbiAgICAgICAgcmVnZXg7XG4gICAgdmFyIGZpbHRlckV4aXN0cyA9ICEhZmlsdGVyO1xuICAgIGlmIChmaWx0ZXJOb2RlVHlwZXMpIHtcbiAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBub2RlVHlwZXMuam9pbihcInxcIikgKyBcIikkXCIpO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIGl0ZXJhdGVTdWJ0cmVlKG5ldyBSYW5nZUl0ZXJhdG9yKHJhbmdlLCBmYWxzZSksIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoKCFmaWx0ZXJOb2RlVHlwZXMgfHwgcmVnZXgudGVzdChub2RlLm5vZGVUeXBlKSkgJiYgKCFmaWx0ZXJFeGlzdHMgfHwgZmlsdGVyKG5vZGUpKSkge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbnNwZWN0KHJhbmdlKSB7XG4gICAgdmFyIG5hbWUgPSB0eXBlb2YgcmFuZ2UuZ2V0TmFtZSA9PSBcInVuZGVmaW5lZFwiID8gXCJSYW5nZVwiIDogcmFuZ2UuZ2V0TmFtZSgpO1xuICAgIHJldHVybiBcIltcIiArIG5hbWUgKyBcIihcIiArIGRvbS5pbnNwZWN0Tm9kZShyYW5nZS5zdGFydENvbnRhaW5lcikgKyBcIjpcIiArIHJhbmdlLnN0YXJ0T2Zmc2V0ICsgXCIsIFwiICsgZG9tLmluc3BlY3ROb2RlKHJhbmdlLmVuZENvbnRhaW5lcikgKyBcIjpcIiArIHJhbmdlLmVuZE9mZnNldCArIFwiKV1cIjtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gUmFuZ2VJdGVyYXRvciBjb2RlIHBhcnRpYWxseSBib3Jyb3dzIGZyb20gSUVSYW5nZSBieSBUaW0gUnlhbiAoaHR0cDovL2dpdGh1Yi5jb20vdGltY2FtZXJvbnJ5YW4vSUVSYW5nZSlcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBSYW5nZUl0ZXJhdG9yKHJhbmdlLCBjbG9uZVBhcnRpYWxseVNlbGVjdGVkVGV4dE5vZGVzKSB7XG4gICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgIHRoaXMuY2xvbmVQYXJ0aWFsbHlTZWxlY3RlZFRleHROb2RlcyA9IGNsb25lUGFydGlhbGx5U2VsZWN0ZWRUZXh0Tm9kZXM7XG5cbiAgICBpZiAoIXJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgdGhpcy5zYyA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgdGhpcy5zbyA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgdGhpcy5lYyA9IHJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgIHRoaXMuZW8gPSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgICB2YXIgcm9vdCA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gICAgICBpZiAodGhpcy5zYyA9PT0gdGhpcy5lYyAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZSh0aGlzLnNjKSkge1xuICAgICAgICB0aGlzLmlzU2luZ2xlQ2hhcmFjdGVyRGF0YU5vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9maXJzdCA9IHRoaXMuX2xhc3QgPSB0aGlzLl9uZXh0ID0gdGhpcy5zYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gdGhpcy5fbmV4dCA9IHRoaXMuc2MgPT09IHJvb3QgJiYgIWRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKHRoaXMuc2MpID8gdGhpcy5zYy5jaGlsZE5vZGVzW3RoaXMuc29dIDogZG9tLmdldENsb3Nlc3RBbmNlc3RvckluKHRoaXMuc2MsIHJvb3QsIHRydWUpO1xuICAgICAgICB0aGlzLl9sYXN0ID0gdGhpcy5lYyA9PT0gcm9vdCAmJiAhZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUodGhpcy5lYykgPyB0aGlzLmVjLmNoaWxkTm9kZXNbdGhpcy5lbyAtIDFdIDogZG9tLmdldENsb3Nlc3RBbmNlc3RvckluKHRoaXMuZWMsIHJvb3QsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFJhbmdlSXRlcmF0b3IucHJvdG90eXBlID0ge1xuICAgIF9jdXJyZW50OiBudWxsLFxuICAgIF9uZXh0OiBudWxsLFxuICAgIF9maXJzdDogbnVsbCxcbiAgICBfbGFzdDogbnVsbCxcbiAgICBpc1NpbmdsZUNoYXJhY3RlckRhdGFOb2RlOiBmYWxzZSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5fbmV4dCA9IHRoaXMuX2ZpcnN0O1xuICAgIH0sXG5cbiAgICBoYXNOZXh0OiBmdW5jdGlvbiBoYXNOZXh0KCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fbmV4dDtcbiAgICB9LFxuXG4gICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIC8vIE1vdmUgdG8gbmV4dCBub2RlXG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9uZXh0O1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5fbmV4dCA9IGN1cnJlbnQgIT09IHRoaXMuX2xhc3QgPyBjdXJyZW50Lm5leHRTaWJsaW5nIDogbnVsbDtcblxuICAgICAgICAvLyBDaGVjayBmb3IgcGFydGlhbGx5IHNlbGVjdGVkIHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKGN1cnJlbnQpICYmIHRoaXMuY2xvbmVQYXJ0aWFsbHlTZWxlY3RlZFRleHROb2Rlcykge1xuICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmVjKSB7XG5cbiAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5jbG9uZU5vZGUodHJ1ZSkpLmRlbGV0ZURhdGEodGhpcy5lbywgY3VycmVudC5sZW5ndGggLSB0aGlzLmVvKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnQgPT09IHRoaXMuc2MpIHtcblxuICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LmNsb25lTm9kZSh0cnVlKSkuZGVsZXRlRGF0YSgwLCB0aGlzLnNvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50LFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZDtcblxuICAgICAgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKGN1cnJlbnQpICYmIChjdXJyZW50ID09PSB0aGlzLnNjIHx8IGN1cnJlbnQgPT09IHRoaXMuZWMpKSB7XG4gICAgICAgIHN0YXJ0ID0gY3VycmVudCA9PT0gdGhpcy5zYyA/IHRoaXMuc28gOiAwO1xuICAgICAgICBlbmQgPSBjdXJyZW50ID09PSB0aGlzLmVjID8gdGhpcy5lbyA6IGN1cnJlbnQubGVuZ3RoO1xuICAgICAgICBpZiAoc3RhcnQgIT0gZW5kKSB7XG4gICAgICAgICAgY3VycmVudC5kZWxldGVEYXRhKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXJyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjdXJyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY3VycmVudCk7XG4gICAgICAgIH0gZWxzZSB7fVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBDaGVja3MgaWYgdGhlIGN1cnJlbnQgbm9kZSBpcyBwYXJ0aWFsbHkgc2VsZWN0ZWRcbiAgICBpc1BhcnRpYWxseVNlbGVjdGVkU3VidHJlZTogZnVuY3Rpb24gaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICByZXR1cm4gaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQoY3VycmVudCwgdGhpcy5yYW5nZSk7XG4gICAgfSxcblxuICAgIGdldFN1YnRyZWVJdGVyYXRvcjogZnVuY3Rpb24gZ2V0U3VidHJlZUl0ZXJhdG9yKCkge1xuICAgICAgdmFyIHN1YlJhbmdlO1xuICAgICAgaWYgKHRoaXMuaXNTaW5nbGVDaGFyYWN0ZXJEYXRhTm9kZSkge1xuICAgICAgICBzdWJSYW5nZSA9IHRoaXMucmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgICBzdWJSYW5nZS5jb2xsYXBzZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ViUmFuZ2UgPSBuZXcgUmFuZ2UoZ2V0UmFuZ2VEb2N1bWVudCh0aGlzLnJhbmdlKSk7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgdmFyIHN0YXJ0Q29udGFpbmVyID0gY3VycmVudCxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gMCxcbiAgICAgICAgICAgIGVuZENvbnRhaW5lciA9IGN1cnJlbnQsXG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBkb20uZ2V0Tm9kZUxlbmd0aChjdXJyZW50KTtcblxuICAgICAgICBpZiAoZG9tLmlzQW5jZXN0b3JPZihjdXJyZW50LCB0aGlzLnNjLCB0cnVlKSkge1xuICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gdGhpcy5zYztcbiAgICAgICAgICBzdGFydE9mZnNldCA9IHRoaXMuc287XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvbS5pc0FuY2VzdG9yT2YoY3VycmVudCwgdGhpcy5lYywgdHJ1ZSkpIHtcbiAgICAgICAgICBlbmRDb250YWluZXIgPSB0aGlzLmVjO1xuICAgICAgICAgIGVuZE9mZnNldCA9IHRoaXMuZW87XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVCb3VuZGFyaWVzKHN1YlJhbmdlLCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2VJdGVyYXRvcihzdWJSYW5nZSwgdGhpcy5jbG9uZVBhcnRpYWxseVNlbGVjdGVkVGV4dE5vZGVzKTtcbiAgICB9LFxuXG4gICAgZGV0YWNoOiBmdW5jdGlvbiBkZXRhY2goZGV0YWNoUmFuZ2UpIHtcbiAgICAgIGlmIChkZXRhY2hSYW5nZSkge1xuICAgICAgICB0aGlzLnJhbmdlLmRldGFjaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5yYW5nZSA9IHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9uZXh0ID0gdGhpcy5fZmlyc3QgPSB0aGlzLl9sYXN0ID0gdGhpcy5zYyA9IHRoaXMuc28gPSB0aGlzLmVjID0gdGhpcy5lbyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRXhjZXB0aW9uc1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFJhbmdlRXhjZXB0aW9uKGNvZGVOYW1lKSB7XG4gICAgdGhpcy5jb2RlID0gdGhpc1tjb2RlTmFtZV07XG4gICAgdGhpcy5jb2RlTmFtZSA9IGNvZGVOYW1lO1xuICAgIHRoaXMubWVzc2FnZSA9IFwiUmFuZ2VFeGNlcHRpb246IFwiICsgdGhpcy5jb2RlTmFtZTtcbiAgfVxuXG4gIFJhbmdlRXhjZXB0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBCQURfQk9VTkRBUllQT0lOVFNfRVJSOiAxLFxuICAgIElOVkFMSURfTk9ERV9UWVBFX0VSUjogMlxuICB9O1xuXG4gIFJhbmdlRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICB9O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIEN1cnJlbnRseSBpdGVyYXRlcyB0aHJvdWdoIGFsbCBub2RlcyBpbiB0aGUgcmFuZ2Ugb24gY3JlYXRpb24gdW50aWwgSSB0aGluayBvZiBhIGRlY2VudCB3YXkgdG8gZG8gaXRcbiAgICogVE9ETzogTG9vayBpbnRvIG1ha2luZyB0aGlzIGEgcHJvcGVyIGl0ZXJhdG9yLCBub3QgcmVxdWlyaW5nIHByZWxvYWRpbmcgZXZlcnl0aGluZyBmaXJzdFxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFJhbmdlTm9kZUl0ZXJhdG9yKHJhbmdlLCBub2RlVHlwZXMsIGZpbHRlcikge1xuICAgIHRoaXMubm9kZXMgPSBnZXROb2Rlc0luUmFuZ2UocmFuZ2UsIG5vZGVUeXBlcywgZmlsdGVyKTtcbiAgICB0aGlzLl9uZXh0ID0gdGhpcy5ub2Rlc1swXTtcbiAgICB0aGlzLl9wb3NpdGlvbiA9IDA7XG4gIH1cblxuICBSYW5nZU5vZGVJdGVyYXRvci5wcm90b3R5cGUgPSB7XG4gICAgX2N1cnJlbnQ6IG51bGwsXG5cbiAgICBoYXNOZXh0OiBmdW5jdGlvbiBoYXNOZXh0KCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fbmV4dDtcbiAgICB9LFxuXG4gICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9uZXh0O1xuICAgICAgdGhpcy5fbmV4dCA9IHRoaXMubm9kZXNbKyt0aGlzLl9wb3NpdGlvbl07XG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgICB9LFxuXG4gICAgZGV0YWNoOiBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fbmV4dCA9IHRoaXMubm9kZXMgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYmVmb3JlQWZ0ZXJOb2RlVHlwZXMgPSBbMSwgMywgNCwgNSwgNywgOCwgMTBdO1xuICB2YXIgcm9vdENvbnRhaW5lck5vZGVUeXBlcyA9IFsyLCA5LCAxMV07XG4gIHZhciByZWFkb25seU5vZGVUeXBlcyA9IFs1LCA2LCAxMCwgMTJdO1xuICB2YXIgaW5zZXJ0YWJsZU5vZGVUeXBlcyA9IFsxLCAzLCA0LCA1LCA3LCA4LCAxMCwgMTFdO1xuICB2YXIgc3Vycm91bmROb2RlVHlwZXMgPSBbMSwgMywgNCwgNSwgNywgOF07XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW5jZXN0b3JGaW5kZXIobm9kZVR5cGVzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBzZWxmSXNBbmNlc3Rvcikge1xuICAgICAgdmFyIHQsXG4gICAgICAgICAgbiA9IHNlbGZJc0FuY2VzdG9yID8gbm9kZSA6IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgIHQgPSBuLm5vZGVUeXBlO1xuICAgICAgICBpZiAoZG9tLmFycmF5Q29udGFpbnMobm9kZVR5cGVzLCB0KSkge1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGdldFJvb3RDb250YWluZXIgPSBkb20uZ2V0Um9vdENvbnRhaW5lcjtcbiAgdmFyIGdldERvY3VtZW50T3JGcmFnbWVudENvbnRhaW5lciA9IGNyZWF0ZUFuY2VzdG9yRmluZGVyKFs5LCAxMV0pO1xuICB2YXIgZ2V0UmVhZG9ubHlBbmNlc3RvciA9IGNyZWF0ZUFuY2VzdG9yRmluZGVyKHJlYWRvbmx5Tm9kZVR5cGVzKTtcbiAgdmFyIGdldERvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yID0gY3JlYXRlQW5jZXN0b3JGaW5kZXIoWzYsIDEwLCAxMl0pO1xuXG4gIGZ1bmN0aW9uIGFzc2VydE5vRG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3Iobm9kZSwgYWxsb3dTZWxmKSB7XG4gICAgaWYgKGdldERvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIGFsbG93U2VsZikpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUV4Y2VwdGlvbihcIklOVkFMSURfTk9ERV9UWVBFX0VSUlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb3REZXRhY2hlZChyYW5nZSkge1xuICAgIGlmICghcmFuZ2Uuc3RhcnRDb250YWluZXIpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTlZBTElEX1NUQVRFX0VSUlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRWYWxpZE5vZGVUeXBlKG5vZGUsIGludmFsaWRUeXBlcykge1xuICAgIGlmICghZG9tLmFycmF5Q29udGFpbnMoaW52YWxpZFR5cGVzLCBub2RlLm5vZGVUeXBlKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXhjZXB0aW9uKFwiSU5WQUxJRF9OT0RFX1RZUEVfRVJSXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydFZhbGlkT2Zmc2V0KG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+IChkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShub2RlKSA/IG5vZGUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTkRFWF9TSVpFX0VSUlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRTYW1lRG9jdW1lbnRPckZyYWdtZW50KG5vZGUxLCBub2RlMikge1xuICAgIGlmIChnZXREb2N1bWVudE9yRnJhZ21lbnRDb250YWluZXIobm9kZTEsIHRydWUpICE9PSBnZXREb2N1bWVudE9yRnJhZ21lbnRDb250YWluZXIobm9kZTIsIHRydWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiV1JPTkdfRE9DVU1FTlRfRVJSXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVOb3RSZWFkT25seShub2RlKSB7XG4gICAgaWYgKGdldFJlYWRvbmx5QW5jZXN0b3Iobm9kZSwgdHJ1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlJcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZShub2RlLCBjb2RlTmFtZSkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihjb2RlTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNPcnBoYW4obm9kZSkge1xuICAgIHJldHVybiAhZG9tLmFycmF5Q29udGFpbnMocm9vdENvbnRhaW5lck5vZGVUeXBlcywgbm9kZS5ub2RlVHlwZSkgJiYgIWdldERvY3VtZW50T3JGcmFnbWVudENvbnRhaW5lcihub2RlLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWRPZmZzZXQobm9kZSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCA8PSAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUobm9kZSkgPyBub2RlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0UmFuZ2VWYWxpZChyYW5nZSkge1xuICAgIGFzc2VydE5vdERldGFjaGVkKHJhbmdlKTtcbiAgICBpZiAoaXNPcnBoYW4ocmFuZ2Uuc3RhcnRDb250YWluZXIpIHx8IGlzT3JwaGFuKHJhbmdlLmVuZENvbnRhaW5lcikgfHwgIWlzVmFsaWRPZmZzZXQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSB8fCAhaXNWYWxpZE9mZnNldChyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbmdlIGVycm9yOiBSYW5nZSBpcyBubyBsb25nZXIgdmFsaWQgYWZ0ZXIgRE9NIG11dGF0aW9uIChcIiArIHJhbmdlLmluc3BlY3QoKSArIFwiKVwiKTtcbiAgICB9XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIFRlc3QgdGhlIGJyb3dzZXIncyBpbm5lckhUTUwgc3VwcG9ydCB0byBkZWNpZGUgaG93IHRvIGltcGxlbWVudCBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnRcbiAgdmFyIHN0eWxlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIHZhciBodG1sUGFyc2luZ0NvbmZvcm1zID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgc3R5bGVFbC5pbm5lckhUTUwgPSBcIjxiPng8L2I+XCI7XG4gICAgaHRtbFBhcnNpbmdDb25mb3JtcyA9IHN0eWxlRWwuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAzOyAvLyBPcGVyYSBpbmNvcnJlY3RseSBjcmVhdGVzIGFuIGVsZW1lbnQgbm9kZVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSUUgNiBhbmQgNyB0aHJvd1xuICB9XG5cbiAgYXBpLmZlYXR1cmVzLmh0bWxQYXJzaW5nQ29uZm9ybXMgPSBodG1sUGFyc2luZ0NvbmZvcm1zO1xuXG4gIHZhciBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgPSBodG1sUGFyc2luZ0NvbmZvcm1zID9cblxuICAvLyBJbXBsZW1lbnRhdGlvbiBhcyBwZXIgSFRNTCBwYXJzaW5nIHNwZWMsIHRydXN0aW5nIGluIHRoZSBicm93c2VyJ3MgaW1wbGVtZW50YXRpb24gb2YgaW5uZXJIVE1MLiBTZWVcbiAgLy8gZGlzY3Vzc2lvbiBhbmQgYmFzZSBjb2RlIGZvciB0aGlzIGltcGxlbWVudGF0aW9uIGF0IGlzc3VlIDY3LlxuICAvLyBTcGVjOiBodHRwOi8vaHRtbDUub3JnL3NwZWNzL2RvbS1wYXJzaW5nLmh0bWwjZXh0ZW5zaW9ucy10by10aGUtcmFuZ2UtaW50ZXJmYWNlXG4gIC8vIFRoYW5rcyB0byBBbGVrcyBXaWxsaWFtcy5cbiAgZnVuY3Rpb24gKGZyYWdtZW50U3RyKSB7XG4gICAgLy8gXCJMZXQgbm9kZSB0aGUgY29udGV4dCBvYmplY3QncyBzdGFydCdzIG5vZGUuXCJcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnRDb250YWluZXI7XG4gICAgdmFyIGRvYyA9IGRvbS5nZXREb2N1bWVudChub2RlKTtcblxuICAgIC8vIFwiSWYgdGhlIGNvbnRleHQgb2JqZWN0J3Mgc3RhcnQncyBub2RlIGlzIG51bGwsIHJhaXNlIGFuIElOVkFMSURfU1RBVEVfRVJSXG4gICAgLy8gZXhjZXB0aW9uIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cIlxuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOVkFMSURfU1RBVEVfRVJSXCIpO1xuICAgIH1cblxuICAgIC8vIFwiTGV0IGVsZW1lbnQgYmUgYXMgZm9sbG93cywgZGVwZW5kaW5nIG9uIG5vZGUncyBpbnRlcmZhY2U6XCJcbiAgICAvLyBEb2N1bWVudCwgRG9jdW1lbnQgRnJhZ21lbnQ6IG51bGxcbiAgICB2YXIgZWwgPSBudWxsO1xuXG4gICAgLy8gXCJFbGVtZW50OiBub2RlXCJcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICBlbCA9IG5vZGU7XG5cbiAgICAgIC8vIFwiVGV4dCwgQ29tbWVudDogbm9kZSdzIHBhcmVudEVsZW1lbnRcIlxuICAgIH0gZWxzZSBpZiAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUobm9kZSkpIHtcbiAgICAgIGVsID0gZG9tLnBhcmVudEVsZW1lbnQobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gXCJJZiBlaXRoZXIgZWxlbWVudCBpcyBudWxsIG9yIGVsZW1lbnQncyBvd25lckRvY3VtZW50IGlzIGFuIEhUTUwgZG9jdW1lbnRcbiAgICAvLyBhbmQgZWxlbWVudCdzIGxvY2FsIG5hbWUgaXMgXCJodG1sXCIgYW5kIGVsZW1lbnQncyBuYW1lc3BhY2UgaXMgdGhlIEhUTUxcbiAgICAvLyBuYW1lc3BhY2VcIlxuICAgIGlmIChlbCA9PT0gbnVsbCB8fCBlbC5ub2RlTmFtZSA9PSBcIkhUTUxcIiAmJiBkb20uaXNIdG1sTmFtZXNwYWNlKGRvbS5nZXREb2N1bWVudChlbCkuZG9jdW1lbnRFbGVtZW50KSAmJiBkb20uaXNIdG1sTmFtZXNwYWNlKGVsKSkge1xuXG4gICAgICAvLyBcImxldCBlbGVtZW50IGJlIGEgbmV3IEVsZW1lbnQgd2l0aCBcImJvZHlcIiBhcyBpdHMgbG9jYWwgbmFtZSBhbmQgdGhlIEhUTUxcbiAgICAgIC8vIG5hbWVzcGFjZSBhcyBpdHMgbmFtZXNwYWNlLlwiXCJcbiAgICAgIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbCA9IGVsLmNsb25lTm9kZShmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gXCJJZiB0aGUgbm9kZSdzIGRvY3VtZW50IGlzIGFuIEhUTUwgZG9jdW1lbnQ6IEludm9rZSB0aGUgSFRNTCBmcmFnbWVudCBwYXJzaW5nIGFsZ29yaXRobS5cIlxuICAgIC8vIFwiSWYgdGhlIG5vZGUncyBkb2N1bWVudCBpcyBhbiBYTUwgZG9jdW1lbnQ6IEludm9rZSB0aGUgWE1MIGZyYWdtZW50IHBhcnNpbmcgYWxnb3JpdGhtLlwiXG4gICAgLy8gXCJJbiBlaXRoZXIgY2FzZSwgdGhlIGFsZ29yaXRobSBtdXN0IGJlIGludm9rZWQgd2l0aCBmcmFnbWVudCBhcyB0aGUgaW5wdXRcbiAgICAvLyBhbmQgZWxlbWVudCBhcyB0aGUgY29udGV4dCBlbGVtZW50LlwiXG4gICAgZWwuaW5uZXJIVE1MID0gZnJhZ21lbnRTdHI7XG5cbiAgICAvLyBcIklmIHRoaXMgcmFpc2VzIGFuIGV4Y2VwdGlvbiwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy4gT3RoZXJ3aXNlLCBsZXQgbmV3XG4gICAgLy8gY2hpbGRyZW4gYmUgdGhlIG5vZGVzIHJldHVybmVkLlwiXG5cbiAgICAvLyBcIkxldCBmcmFnbWVudCBiZSBhIG5ldyBEb2N1bWVudEZyYWdtZW50LlwiXG4gICAgLy8gXCJBcHBlbmQgYWxsIG5ldyBjaGlsZHJlbiB0byBmcmFnbWVudC5cIlxuICAgIC8vIFwiUmV0dXJuIGZyYWdtZW50LlwiXG4gICAgcmV0dXJuIGRvbS5mcmFnbWVudEZyb21Ob2RlQ2hpbGRyZW4oZWwpO1xuICB9IDpcblxuICAvLyBJbiB0aGlzIGNhc2UsIGlubmVySFRNTCBjYW5ub3QgYmUgdHJ1c3RlZCwgc28gZmFsbCBiYWNrIHRvIGEgc2ltcGxlciwgbm9uLWNvbmZvcm1hbnQgaW1wbGVtZW50YXRpb24gdGhhdFxuICAvLyBwcmV2aW91cyB2ZXJzaW9ucyBvZiBSYW5neSB1c2VkICh3aXRoIHRoZSBleGNlcHRpb24gb2YgdXNpbmcgYSBib2R5IGVsZW1lbnQgcmF0aGVyIHRoYW4gYSBkaXYpXG4gIGZ1bmN0aW9uIChmcmFnbWVudFN0cikge1xuICAgIGFzc2VydE5vdERldGFjaGVkKHRoaXMpO1xuICAgIHZhciBkb2MgPSBnZXRSYW5nZURvY3VtZW50KHRoaXMpO1xuICAgIHZhciBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYm9keVwiKTtcbiAgICBlbC5pbm5lckhUTUwgPSBmcmFnbWVudFN0cjtcblxuICAgIHJldHVybiBkb20uZnJhZ21lbnRGcm9tTm9kZUNoaWxkcmVuKGVsKTtcbiAgfTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIHZhciByYW5nZVByb3BlcnRpZXMgPSBbXCJzdGFydENvbnRhaW5lclwiLCBcInN0YXJ0T2Zmc2V0XCIsIFwiZW5kQ29udGFpbmVyXCIsIFwiZW5kT2Zmc2V0XCIsIFwiY29sbGFwc2VkXCIsIFwiY29tbW9uQW5jZXN0b3JDb250YWluZXJcIl07XG5cbiAgdmFyIHMycyA9IDAsXG4gICAgICBzMmUgPSAxLFxuICAgICAgZTJlID0gMixcbiAgICAgIGUycyA9IDM7XG4gIHZhciBuX2IgPSAwLFxuICAgICAgbl9hID0gMSxcbiAgICAgIG5fYl9hID0gMixcbiAgICAgIG5faSA9IDM7XG5cbiAgZnVuY3Rpb24gUmFuZ2VQcm90b3R5cGUoKSB7fVxuXG4gIFJhbmdlUHJvdG90eXBlLnByb3RvdHlwZSA9IHtcbiAgICBhdHRhY2hMaXN0ZW5lcjogZnVuY3Rpb24gYXR0YWNoTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9LFxuXG4gICAgY29tcGFyZUJvdW5kYXJ5UG9pbnRzOiBmdW5jdGlvbiBjb21wYXJlQm91bmRhcnlQb2ludHMoaG93LCByYW5nZSkge1xuICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgIGFzc2VydFNhbWVEb2N1bWVudE9yRnJhZ21lbnQodGhpcy5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRDb250YWluZXIpO1xuXG4gICAgICB2YXIgbm9kZUEsIG9mZnNldEEsIG5vZGVCLCBvZmZzZXRCO1xuICAgICAgdmFyIHByZWZpeEEgPSBob3cgPT0gZTJzIHx8IGhvdyA9PSBzMnMgPyBcInN0YXJ0XCIgOiBcImVuZFwiO1xuICAgICAgdmFyIHByZWZpeEIgPSBob3cgPT0gczJlIHx8IGhvdyA9PSBzMnMgPyBcInN0YXJ0XCIgOiBcImVuZFwiO1xuICAgICAgbm9kZUEgPSB0aGlzW3ByZWZpeEEgKyBcIkNvbnRhaW5lclwiXTtcbiAgICAgIG9mZnNldEEgPSB0aGlzW3ByZWZpeEEgKyBcIk9mZnNldFwiXTtcbiAgICAgIG5vZGVCID0gcmFuZ2VbcHJlZml4QiArIFwiQ29udGFpbmVyXCJdO1xuICAgICAgb2Zmc2V0QiA9IHJhbmdlW3ByZWZpeEIgKyBcIk9mZnNldFwiXTtcbiAgICAgIHJldHVybiBkb20uY29tcGFyZVBvaW50cyhub2RlQSwgb2Zmc2V0QSwgbm9kZUIsIG9mZnNldEIpO1xuICAgIH0sXG5cbiAgICBpbnNlcnROb2RlOiBmdW5jdGlvbiBpbnNlcnROb2RlKG5vZGUpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICBhc3NlcnRWYWxpZE5vZGVUeXBlKG5vZGUsIGluc2VydGFibGVOb2RlVHlwZXMpO1xuICAgICAgYXNzZXJ0Tm9kZU5vdFJlYWRPbmx5KHRoaXMuc3RhcnRDb250YWluZXIpO1xuXG4gICAgICBpZiAoZG9tLmlzQW5jZXN0b3JPZihub2RlLCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0cnVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBObyBjaGVjayBmb3Igd2hldGhlciB0aGUgY29udGFpbmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgUmFuZ2UgaXMgb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWxsb3dcbiAgICAgIC8vIGNoaWxkcmVuIG9mIHRoZSB0eXBlIG9mIG5vZGU6IHRoZSBicm93c2VyJ3MgRE9NIGltcGxlbWVudGF0aW9uIHNob3VsZCBkbyB0aGlzIGZvciB1cyB3aGVuIHdlIGF0dGVtcHRcbiAgICAgIC8vIHRvIGFkZCB0aGUgbm9kZVxuXG4gICAgICB2YXIgZmlyc3ROb2RlSW5zZXJ0ZWQgPSBpbnNlcnROb2RlQXRQb3NpdGlvbihub2RlLCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0KTtcbiAgICAgIHRoaXMuc2V0U3RhcnRCZWZvcmUoZmlyc3ROb2RlSW5zZXJ0ZWQpO1xuICAgIH0sXG5cbiAgICBjbG9uZUNvbnRlbnRzOiBmdW5jdGlvbiBjbG9uZUNvbnRlbnRzKCkge1xuICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcblxuICAgICAgdmFyIGNsb25lLCBmcmFnO1xuICAgICAgaWYgKHRoaXMuY29sbGFwc2VkKSB7XG4gICAgICAgIHJldHVybiBnZXRSYW5nZURvY3VtZW50KHRoaXMpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0Q29udGFpbmVyID09PSB0aGlzLmVuZENvbnRhaW5lciAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZSh0aGlzLnN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgICAgIGNsb25lID0gdGhpcy5zdGFydENvbnRhaW5lci5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgY2xvbmUuZGF0YSA9IGNsb25lLmRhdGEuc2xpY2UodGhpcy5zdGFydE9mZnNldCwgdGhpcy5lbmRPZmZzZXQpO1xuICAgICAgICAgIGZyYWcgPSBnZXRSYW5nZURvY3VtZW50KHRoaXMpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgUmFuZ2VJdGVyYXRvcih0aGlzLCB0cnVlKTtcbiAgICAgICAgICBjbG9uZSA9IGNsb25lU3VidHJlZShpdGVyYXRvcik7XG4gICAgICAgICAgaXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjYW5TdXJyb3VuZENvbnRlbnRzOiBmdW5jdGlvbiBjYW5TdXJyb3VuZENvbnRlbnRzKCkge1xuICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgIGFzc2VydE5vZGVOb3RSZWFkT25seSh0aGlzLnN0YXJ0Q29udGFpbmVyKTtcbiAgICAgIGFzc2VydE5vZGVOb3RSZWFkT25seSh0aGlzLmVuZENvbnRhaW5lcik7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZW50cyBjYW4gYmUgc3Vycm91bmRlZC4gU3BlY2lmaWNhbGx5LCB0aGlzIG1lYW5zIHdoZXRoZXIgdGhlIHJhbmdlIHBhcnRpYWxseSBzZWxlY3RzXG4gICAgICAvLyBubyBub24tdGV4dCBub2Rlcy5cbiAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuICAgICAgdmFyIGJvdW5kYXJpZXNJbnZhbGlkID0gaXRlcmF0b3IuX2ZpcnN0ICYmIGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKGl0ZXJhdG9yLl9maXJzdCwgdGhpcykgfHwgaXRlcmF0b3IuX2xhc3QgJiYgaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQoaXRlcmF0b3IuX2xhc3QsIHRoaXMpO1xuICAgICAgaXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICByZXR1cm4gIWJvdW5kYXJpZXNJbnZhbGlkO1xuICAgIH0sXG5cbiAgICBzdXJyb3VuZENvbnRlbnRzOiBmdW5jdGlvbiBzdXJyb3VuZENvbnRlbnRzKG5vZGUpIHtcbiAgICAgIGFzc2VydFZhbGlkTm9kZVR5cGUobm9kZSwgc3Vycm91bmROb2RlVHlwZXMpO1xuXG4gICAgICBpZiAoIXRoaXMuY2FuU3Vycm91bmRDb250ZW50cygpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUV4Y2VwdGlvbihcIkJBRF9CT1VOREFSWVBPSU5UU19FUlJcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4dHJhY3QgdGhlIGNvbnRlbnRzXG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuZXh0cmFjdENvbnRlbnRzKCk7XG5cbiAgICAgIC8vIENsZWFyIHRoZSBjaGlsZHJlbiBvZiB0aGUgbm9kZVxuICAgICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEluc2VydCB0aGUgbmV3IG5vZGUgYW5kIGFkZCB0aGUgZXh0cmFjdGVkIGNvbnRlbnRzXG4gICAgICBpbnNlcnROb2RlQXRQb3NpdGlvbihub2RlLCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0KTtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICAgIHRoaXMuc2VsZWN0Tm9kZShub2RlKTtcbiAgICB9LFxuXG4gICAgY2xvbmVSYW5nZTogZnVuY3Rpb24gY2xvbmVSYW5nZSgpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2UoZ2V0UmFuZ2VEb2N1bWVudCh0aGlzKSk7XG4gICAgICB2YXIgaSA9IHJhbmdlUHJvcGVydGllcy5sZW5ndGgsXG4gICAgICAgICAgcHJvcDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgcHJvcCA9IHJhbmdlUHJvcGVydGllc1tpXTtcbiAgICAgICAgcmFuZ2VbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgdmFyIHNjID0gdGhpcy5zdGFydENvbnRhaW5lcjtcbiAgICAgIGlmIChzYyA9PT0gdGhpcy5lbmRDb250YWluZXIgJiYgZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoc2MpKSB7XG4gICAgICAgIHJldHVybiBzYy5ub2RlVHlwZSA9PSAzIHx8IHNjLm5vZGVUeXBlID09IDQgPyBzYy5kYXRhLnNsaWNlKHRoaXMuc3RhcnRPZmZzZXQsIHRoaXMuZW5kT2Zmc2V0KSA6IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGV4dEJpdHMgPSBbXSxcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3IFJhbmdlSXRlcmF0b3IodGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgaXRlcmF0ZVN1YnRyZWUoaXRlcmF0b3IsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgLy8gQWNjZXB0IG9ubHkgdGV4dCBvciBDREFUQSBub2Rlcywgbm90IGNvbW1lbnRzXG5cbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzIHx8IG5vZGUubm9kZVR5cGUgPT0gNCkge1xuICAgICAgICAgICAgdGV4dEJpdHMucHVzaChub2RlLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGl0ZXJhdG9yLmRldGFjaCgpO1xuICAgICAgICByZXR1cm4gdGV4dEJpdHMuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gVGhlIG1ldGhvZHMgYmVsb3cgYXJlIGFsbCBub24tc3RhbmRhcmQuIFRoZSBmb2xsb3dpbmcgYmF0Y2ggd2VyZSBpbnRyb2R1Y2VkIGJ5IE1vemlsbGEgYnV0IGhhdmUgc2luY2VcbiAgICAvLyBiZWVuIHJlbW92ZWQgZnJvbSBNb3ppbGxhLlxuXG4gICAgY29tcGFyZU5vZGU6IGZ1bmN0aW9uIGNvbXBhcmVOb2RlKG5vZGUpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG5cbiAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICB2YXIgbm9kZUluZGV4ID0gZG9tLmdldE5vZGVJbmRleChub2RlKTtcblxuICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIk5PVF9GT1VORF9FUlJcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydENvbXBhcmlzb24gPSB0aGlzLmNvbXBhcmVQb2ludChwYXJlbnQsIG5vZGVJbmRleCksXG4gICAgICAgICAgZW5kQ29tcGFyaXNvbiA9IHRoaXMuY29tcGFyZVBvaW50KHBhcmVudCwgbm9kZUluZGV4ICsgMSk7XG5cbiAgICAgIGlmIChzdGFydENvbXBhcmlzb24gPCAwKSB7XG4gICAgICAgIC8vIE5vZGUgc3RhcnRzIGJlZm9yZVxuICAgICAgICByZXR1cm4gZW5kQ29tcGFyaXNvbiA+IDAgPyBuX2JfYSA6IG5fYjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbmRDb21wYXJpc29uID4gMCA/IG5fYSA6IG5faTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29tcGFyZVBvaW50OiBmdW5jdGlvbiBjb21wYXJlUG9pbnQobm9kZSwgb2Zmc2V0KSB7XG4gICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgYXNzZXJ0Tm9kZShub2RlLCBcIkhJRVJBUkNIWV9SRVFVRVNUX0VSUlwiKTtcbiAgICAgIGFzc2VydFNhbWVEb2N1bWVudE9yRnJhZ21lbnQobm9kZSwgdGhpcy5zdGFydENvbnRhaW5lcik7XG5cbiAgICAgIGlmIChkb20uY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpIDwgMCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKGRvbS5jb21wYXJlUG9pbnRzKG5vZGUsIG9mZnNldCwgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0KSA+IDApIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50OiBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQsXG5cbiAgICB0b0h0bWw6IGZ1bmN0aW9uIHRvSHRtbCgpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICB2YXIgY29udGFpbmVyID0gZ2V0UmFuZ2VEb2N1bWVudCh0aGlzKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2xvbmVDb250ZW50cygpKTtcbiAgICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgIH0sXG5cbiAgICAvLyB0b3VjaGluZ0lzSW50ZXJzZWN0aW5nIGRldGVybWluZXMgd2hldGhlciB0aGlzIG1ldGhvZCBjb25zaWRlcnMgYSBub2RlIHRoYXQgYm9yZGVycyBhIHJhbmdlIGludGVyc2VjdHNcbiAgICAvLyB3aXRoIGl0IChhcyBpbiBXZWJLaXQpIG9yIG5vdCAoYXMgaW4gR2Vja28gcHJlLTEuOSwgYW5kIHRoZSBkZWZhdWx0KVxuICAgIGludGVyc2VjdHNOb2RlOiBmdW5jdGlvbiBpbnRlcnNlY3RzTm9kZShub2RlLCB0b3VjaGluZ0lzSW50ZXJzZWN0aW5nKSB7XG4gICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgYXNzZXJ0Tm9kZShub2RlLCBcIk5PVF9GT1VORF9FUlJcIik7XG4gICAgICBpZiAoZG9tLmdldERvY3VtZW50KG5vZGUpICE9PSBnZXRSYW5nZURvY3VtZW50KHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICBvZmZzZXQgPSBkb20uZ2V0Tm9kZUluZGV4KG5vZGUpO1xuICAgICAgYXNzZXJ0Tm9kZShwYXJlbnQsIFwiTk9UX0ZPVU5EX0VSUlwiKTtcblxuICAgICAgdmFyIHN0YXJ0Q29tcGFyaXNvbiA9IGRvbS5jb21wYXJlUG9pbnRzKHBhcmVudCwgb2Zmc2V0LCB0aGlzLmVuZENvbnRhaW5lciwgdGhpcy5lbmRPZmZzZXQpLFxuICAgICAgICAgIGVuZENvbXBhcmlzb24gPSBkb20uY29tcGFyZVBvaW50cyhwYXJlbnQsIG9mZnNldCArIDEsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpO1xuXG4gICAgICByZXR1cm4gdG91Y2hpbmdJc0ludGVyc2VjdGluZyA/IHN0YXJ0Q29tcGFyaXNvbiA8PSAwICYmIGVuZENvbXBhcmlzb24gPj0gMCA6IHN0YXJ0Q29tcGFyaXNvbiA8IDAgJiYgZW5kQ29tcGFyaXNvbiA+IDA7XG4gICAgfSxcblxuICAgIGlzUG9pbnRJblJhbmdlOiBmdW5jdGlvbiBpc1BvaW50SW5SYW5nZShub2RlLCBvZmZzZXQpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICBhc3NlcnROb2RlKG5vZGUsIFwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSXCIpO1xuICAgICAgYXNzZXJ0U2FtZURvY3VtZW50T3JGcmFnbWVudChub2RlLCB0aGlzLnN0YXJ0Q29udGFpbmVyKTtcblxuICAgICAgcmV0dXJuIGRvbS5jb21wYXJlUG9pbnRzKG5vZGUsIG9mZnNldCwgdGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCkgPj0gMCAmJiBkb20uY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCkgPD0gMDtcbiAgICB9LFxuXG4gICAgLy8gVGhlIG1ldGhvZHMgYmVsb3cgYXJlIG5vbi1zdGFuZGFyZCBhbmQgaW52ZW50ZWQgYnkgbWUuXG5cbiAgICAvLyBTaGFyaW5nIGEgYm91bmRhcnkgc3RhcnQtdG8tZW5kIG9yIGVuZC10by1zdGFydCBkb2VzIG5vdCBjb3VudCBhcyBpbnRlcnNlY3Rpb24uXG4gICAgaW50ZXJzZWN0c1JhbmdlOiBmdW5jdGlvbiBpbnRlcnNlY3RzUmFuZ2UocmFuZ2UsIHRvdWNoaW5nSXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG5cbiAgICAgIGlmIChnZXRSYW5nZURvY3VtZW50KHJhbmdlKSAhPSBnZXRSYW5nZURvY3VtZW50KHRoaXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJXUk9OR19ET0NVTUVOVF9FUlJcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydENvbXBhcmlzb24gPSBkb20uY29tcGFyZVBvaW50cyh0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0LCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCksXG4gICAgICAgICAgZW5kQ29tcGFyaXNvbiA9IGRvbS5jb21wYXJlUG9pbnRzKHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCwgcmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICAgICAgcmV0dXJuIHRvdWNoaW5nSXNJbnRlcnNlY3RpbmcgPyBzdGFydENvbXBhcmlzb24gPD0gMCAmJiBlbmRDb21wYXJpc29uID49IDAgOiBzdGFydENvbXBhcmlzb24gPCAwICYmIGVuZENvbXBhcmlzb24gPiAwO1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3Rpb246IGZ1bmN0aW9uIGludGVyc2VjdGlvbihyYW5nZSkge1xuICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c1JhbmdlKHJhbmdlKSkge1xuICAgICAgICB2YXIgc3RhcnRDb21wYXJpc29uID0gZG9tLmNvbXBhcmVQb2ludHModGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCwgcmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSxcbiAgICAgICAgICAgIGVuZENvbXBhcmlzb24gPSBkb20uY29tcGFyZVBvaW50cyh0aGlzLmVuZENvbnRhaW5lciwgdGhpcy5lbmRPZmZzZXQsIHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcblxuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUmFuZ2UgPSB0aGlzLmNsb25lUmFuZ2UoKTtcblxuICAgICAgICBpZiAoc3RhcnRDb21wYXJpc29uID09IC0xKSB7XG4gICAgICAgICAgaW50ZXJzZWN0aW9uUmFuZ2Uuc2V0U3RhcnQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kQ29tcGFyaXNvbiA9PSAxKSB7XG4gICAgICAgICAgaW50ZXJzZWN0aW9uUmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uUmFuZ2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgdW5pb246IGZ1bmN0aW9uIHVuaW9uKHJhbmdlKSB7XG4gICAgICBpZiAodGhpcy5pbnRlcnNlY3RzUmFuZ2UocmFuZ2UsIHRydWUpKSB7XG4gICAgICAgIHZhciB1bmlvblJhbmdlID0gdGhpcy5jbG9uZVJhbmdlKCk7XG4gICAgICAgIGlmIChkb20uY29tcGFyZVBvaW50cyhyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpID09IC0xKSB7XG4gICAgICAgICAgdW5pb25SYW5nZS5zZXRTdGFydChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb20uY29tcGFyZVBvaW50cyhyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCwgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0KSA9PSAxKSB7XG4gICAgICAgICAgdW5pb25SYW5nZS5zZXRFbmQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmlvblJhbmdlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXhjZXB0aW9uKFwiUmFuZ2VzIGRvIG5vdCBpbnRlcnNlY3RcIik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbnRhaW5zTm9kZTogZnVuY3Rpb24gY29udGFpbnNOb2RlKG5vZGUsIGFsbG93UGFydGlhbCkge1xuICAgICAgaWYgKGFsbG93UGFydGlhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RzTm9kZShub2RlLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlTm9kZShub2RlKSA9PSBuX2k7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbnRhaW5zTm9kZUNvbnRlbnRzOiBmdW5jdGlvbiBjb250YWluc05vZGVDb250ZW50cyhub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wYXJlUG9pbnQobm9kZSwgMCkgPj0gMCAmJiB0aGlzLmNvbXBhcmVQb2ludChub2RlLCBkb20uZ2V0Tm9kZUxlbmd0aChub2RlKSkgPD0gMDtcbiAgICB9LFxuXG4gICAgY29udGFpbnNSYW5nZTogZnVuY3Rpb24gY29udGFpbnNSYW5nZShyYW5nZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0aW9uKHJhbmdlKS5lcXVhbHMocmFuZ2UpO1xuICAgIH0sXG5cbiAgICBjb250YWluc05vZGVUZXh0OiBmdW5jdGlvbiBjb250YWluc05vZGVUZXh0KG5vZGUpIHtcbiAgICAgIHZhciBub2RlUmFuZ2UgPSB0aGlzLmNsb25lUmFuZ2UoKTtcbiAgICAgIG5vZGVSYW5nZS5zZWxlY3ROb2RlKG5vZGUpO1xuICAgICAgdmFyIHRleHROb2RlcyA9IG5vZGVSYW5nZS5nZXROb2RlcyhbM10pO1xuICAgICAgaWYgKHRleHROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5vZGVSYW5nZS5zZXRTdGFydCh0ZXh0Tm9kZXNbMF0sIDApO1xuICAgICAgICB2YXIgbGFzdFRleHROb2RlID0gdGV4dE5vZGVzLnBvcCgpO1xuICAgICAgICBub2RlUmFuZ2Uuc2V0RW5kKGxhc3RUZXh0Tm9kZSwgbGFzdFRleHROb2RlLmxlbmd0aCk7XG4gICAgICAgIHZhciBjb250YWlucyA9IHRoaXMuY29udGFpbnNSYW5nZShub2RlUmFuZ2UpO1xuICAgICAgICBub2RlUmFuZ2UuZGV0YWNoKCk7XG4gICAgICAgIHJldHVybiBjb250YWlucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5zTm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjcmVhdGVOb2RlSXRlcmF0b3I6IGZ1bmN0aW9uIGNyZWF0ZU5vZGVJdGVyYXRvcihub2RlVHlwZXMsIGZpbHRlcikge1xuICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2VOb2RlSXRlcmF0b3IodGhpcywgbm9kZVR5cGVzLCBmaWx0ZXIpO1xuICAgIH0sXG5cbiAgICBnZXROb2RlczogZnVuY3Rpb24gZ2V0Tm9kZXMobm9kZVR5cGVzLCBmaWx0ZXIpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICByZXR1cm4gZ2V0Tm9kZXNJblJhbmdlKHRoaXMsIG5vZGVUeXBlcywgZmlsdGVyKTtcbiAgICB9LFxuXG4gICAgZ2V0RG9jdW1lbnQ6IGZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgICAgcmV0dXJuIGdldFJhbmdlRG9jdW1lbnQodGhpcyk7XG4gICAgfSxcblxuICAgIGNvbGxhcHNlQmVmb3JlOiBmdW5jdGlvbiBjb2xsYXBzZUJlZm9yZShub2RlKSB7XG4gICAgICBhc3NlcnROb3REZXRhY2hlZCh0aGlzKTtcblxuICAgICAgdGhpcy5zZXRFbmRCZWZvcmUobm9kZSk7XG4gICAgICB0aGlzLmNvbGxhcHNlKGZhbHNlKTtcbiAgICB9LFxuXG4gICAgY29sbGFwc2VBZnRlcjogZnVuY3Rpb24gY29sbGFwc2VBZnRlcihub2RlKSB7XG4gICAgICBhc3NlcnROb3REZXRhY2hlZCh0aGlzKTtcblxuICAgICAgdGhpcy5zZXRTdGFydEFmdGVyKG5vZGUpO1xuICAgICAgdGhpcy5jb2xsYXBzZSh0cnVlKTtcbiAgICB9LFxuXG4gICAgZ2V0TmFtZTogZnVuY3Rpb24gZ2V0TmFtZSgpIHtcbiAgICAgIHJldHVybiBcIkRvbVJhbmdlXCI7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKHJhbmdlKSB7XG4gICAgICByZXR1cm4gUmFuZ2UucmFuZ2VzRXF1YWwodGhpcywgcmFuZ2UpO1xuICAgIH0sXG5cbiAgICBpbnNwZWN0OiBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgcmV0dXJuIF9pbnNwZWN0KHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjb3B5Q29tcGFyaXNvbkNvbnN0YW50c1RvT2JqZWN0KG9iaikge1xuICAgIG9iai5TVEFSVF9UT19TVEFSVCA9IHMycztcbiAgICBvYmouU1RBUlRfVE9fRU5EID0gczJlO1xuICAgIG9iai5FTkRfVE9fRU5EID0gZTJlO1xuICAgIG9iai5FTkRfVE9fU1RBUlQgPSBlMnM7XG5cbiAgICBvYmouTk9ERV9CRUZPUkUgPSBuX2I7XG4gICAgb2JqLk5PREVfQUZURVIgPSBuX2E7XG4gICAgb2JqLk5PREVfQkVGT1JFX0FORF9BRlRFUiA9IG5fYl9hO1xuICAgIG9iai5OT0RFX0lOU0lERSA9IG5faTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlDb21wYXJpc29uQ29uc3RhbnRzKGNvbnN0cnVjdG9yKSB7XG4gICAgY29weUNvbXBhcmlzb25Db25zdGFudHNUb09iamVjdChjb25zdHJ1Y3Rvcik7XG4gICAgY29weUNvbXBhcmlzb25Db25zdGFudHNUb09iamVjdChjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmFuZ2VDb250ZW50UmVtb3ZlcihyZW1vdmVyLCBib3VuZGFyeVVwZGF0ZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcblxuICAgICAgdmFyIHNjID0gdGhpcy5zdGFydENvbnRhaW5lcixcbiAgICAgICAgICBzbyA9IHRoaXMuc3RhcnRPZmZzZXQsXG4gICAgICAgICAgcm9vdCA9IHRoaXMuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuXG4gICAgICAvLyBXb3JrIG91dCB3aGVyZSB0byBwb3NpdGlvbiB0aGUgcmFuZ2UgYWZ0ZXIgY29udGVudCByZW1vdmFsXG4gICAgICB2YXIgbm9kZSwgYm91bmRhcnk7XG4gICAgICBpZiAoc2MgIT09IHJvb3QpIHtcbiAgICAgICAgbm9kZSA9IGRvbS5nZXRDbG9zZXN0QW5jZXN0b3JJbihzYywgcm9vdCwgdHJ1ZSk7XG4gICAgICAgIGJvdW5kYXJ5ID0gZ2V0Qm91bmRhcnlBZnRlck5vZGUobm9kZSk7XG4gICAgICAgIHNjID0gYm91bmRhcnkubm9kZTtcbiAgICAgICAgc28gPSBib3VuZGFyeS5vZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIG5vbmUgb2YgdGhlIHJhbmdlIGlzIHJlYWQtb25seVxuICAgICAgaXRlcmF0ZVN1YnRyZWUoaXRlcmF0b3IsIGFzc2VydE5vZGVOb3RSZWFkT25seSk7XG5cbiAgICAgIGl0ZXJhdG9yLnJlc2V0KCk7XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgY29udGVudFxuICAgICAgdmFyIHJldHVyblZhbHVlID0gcmVtb3ZlcihpdGVyYXRvcik7XG4gICAgICBpdGVyYXRvci5kZXRhY2goKTtcblxuICAgICAgLy8gTW92ZSB0byB0aGUgbmV3IHBvc2l0aW9uXG4gICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgc2MsIHNvLCBzYywgc28pO1xuXG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByb3RvdHlwZVJhbmdlKGNvbnN0cnVjdG9yLCBib3VuZGFyeVVwZGF0ZXIsIGRldGFjaGVyKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKGlzQmVmb3JlLCBpc1N0YXJ0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgYXNzZXJ0Tm90RGV0YWNoZWQodGhpcyk7XG4gICAgICAgIGFzc2VydFZhbGlkTm9kZVR5cGUobm9kZSwgYmVmb3JlQWZ0ZXJOb2RlVHlwZXMpO1xuICAgICAgICBhc3NlcnRWYWxpZE5vZGVUeXBlKGdldFJvb3RDb250YWluZXIobm9kZSksIHJvb3RDb250YWluZXJOb2RlVHlwZXMpO1xuXG4gICAgICAgIHZhciBib3VuZGFyeSA9IChpc0JlZm9yZSA/IGdldEJvdW5kYXJ5QmVmb3JlTm9kZSA6IGdldEJvdW5kYXJ5QWZ0ZXJOb2RlKShub2RlKTtcbiAgICAgICAgKGlzU3RhcnQgPyBzZXRSYW5nZVN0YXJ0IDogc2V0UmFuZ2VFbmQpKHRoaXMsIGJvdW5kYXJ5Lm5vZGUsIGJvdW5kYXJ5Lm9mZnNldCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFJhbmdlU3RhcnQocmFuZ2UsIG5vZGUsIG9mZnNldCkge1xuICAgICAgdmFyIGVjID0gcmFuZ2UuZW5kQ29udGFpbmVyLFxuICAgICAgICAgIGVvID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgaWYgKG5vZGUgIT09IHJhbmdlLnN0YXJ0Q29udGFpbmVyIHx8IG9mZnNldCAhPT0gcmFuZ2Uuc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHJvb3QgY29udGFpbmVycyBvZiB0aGUgcmFuZ2UgYW5kIHRoZSBuZXcgYm91bmRhcnksIGFuZCBhbHNvIGNoZWNrIHdoZXRoZXIgdGhlIG5ldyBib3VuZGFyeVxuICAgICAgICAvLyBpcyBhZnRlciB0aGUgY3VycmVudCBlbmQuIEluIGVpdGhlciBjYXNlLCBjb2xsYXBzZSB0aGUgcmFuZ2UgdG8gdGhlIG5ldyBwb3NpdGlvblxuICAgICAgICBpZiAoZ2V0Um9vdENvbnRhaW5lcihub2RlKSAhPSBnZXRSb290Q29udGFpbmVyKGVjKSB8fCBkb20uY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIGVjLCBlbykgPT0gMSkge1xuICAgICAgICAgIGVjID0gbm9kZTtcbiAgICAgICAgICBlbyA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBib3VuZGFyeVVwZGF0ZXIocmFuZ2UsIG5vZGUsIG9mZnNldCwgZWMsIGVvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRSYW5nZUVuZChyYW5nZSwgbm9kZSwgb2Zmc2V0KSB7XG4gICAgICB2YXIgc2MgPSByYW5nZS5zdGFydENvbnRhaW5lcixcbiAgICAgICAgICBzbyA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgaWYgKG5vZGUgIT09IHJhbmdlLmVuZENvbnRhaW5lciB8fCBvZmZzZXQgIT09IHJhbmdlLmVuZE9mZnNldCkge1xuICAgICAgICAvLyBDaGVjayB0aGUgcm9vdCBjb250YWluZXJzIG9mIHRoZSByYW5nZSBhbmQgdGhlIG5ldyBib3VuZGFyeSwgYW5kIGFsc28gY2hlY2sgd2hldGhlciB0aGUgbmV3IGJvdW5kYXJ5XG4gICAgICAgIC8vIGlzIGFmdGVyIHRoZSBjdXJyZW50IGVuZC4gSW4gZWl0aGVyIGNhc2UsIGNvbGxhcHNlIHRoZSByYW5nZSB0byB0aGUgbmV3IHBvc2l0aW9uXG4gICAgICAgIGlmIChnZXRSb290Q29udGFpbmVyKG5vZGUpICE9IGdldFJvb3RDb250YWluZXIoc2MpIHx8IGRvbS5jb21wYXJlUG9pbnRzKG5vZGUsIG9mZnNldCwgc2MsIHNvKSA9PSAtMSkge1xuICAgICAgICAgIHNjID0gbm9kZTtcbiAgICAgICAgICBzbyA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBib3VuZGFyeVVwZGF0ZXIocmFuZ2UsIHNjLCBzbywgbm9kZSwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRSYW5nZVN0YXJ0QW5kRW5kKHJhbmdlLCBub2RlLCBvZmZzZXQpIHtcbiAgICAgIGlmIChub2RlICE9PSByYW5nZS5zdGFydENvbnRhaW5lciB8fCBvZmZzZXQgIT09IHJhbmdlLnN0YXJ0T2Zmc2V0IHx8IG5vZGUgIT09IHJhbmdlLmVuZENvbnRhaW5lciB8fCBvZmZzZXQgIT09IHJhbmdlLmVuZE9mZnNldCkge1xuICAgICAgICBib3VuZGFyeVVwZGF0ZXIocmFuZ2UsIG5vZGUsIG9mZnNldCwgbm9kZSwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmFuZ2VQcm90b3R5cGUoKTtcblxuICAgIGFwaS51dGlsLmV4dGVuZChjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIHNldFN0YXJ0OiBmdW5jdGlvbiBzZXRTdGFydChub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgYXNzZXJ0Tm90RGV0YWNoZWQodGhpcyk7XG4gICAgICAgIGFzc2VydE5vRG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3Iobm9kZSwgdHJ1ZSk7XG4gICAgICAgIGFzc2VydFZhbGlkT2Zmc2V0KG5vZGUsIG9mZnNldCk7XG5cbiAgICAgICAgc2V0UmFuZ2VTdGFydCh0aGlzLCBub2RlLCBvZmZzZXQpO1xuICAgICAgfSxcblxuICAgICAgc2V0RW5kOiBmdW5jdGlvbiBzZXRFbmQobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGFzc2VydE5vdERldGFjaGVkKHRoaXMpO1xuICAgICAgICBhc3NlcnROb0RvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIHRydWUpO1xuICAgICAgICBhc3NlcnRWYWxpZE9mZnNldChub2RlLCBvZmZzZXQpO1xuXG4gICAgICAgIHNldFJhbmdlRW5kKHRoaXMsIG5vZGUsIG9mZnNldCk7XG4gICAgICB9LFxuXG4gICAgICBzZXRTdGFydEJlZm9yZTogY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKHRydWUsIHRydWUpLFxuICAgICAgc2V0U3RhcnRBZnRlcjogY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKGZhbHNlLCB0cnVlKSxcbiAgICAgIHNldEVuZEJlZm9yZTogY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKHRydWUsIGZhbHNlKSxcbiAgICAgIHNldEVuZEFmdGVyOiBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoZmFsc2UsIGZhbHNlKSxcblxuICAgICAgY29sbGFwc2U6IGZ1bmN0aW9uIGNvbGxhcHNlKGlzU3RhcnQpIHtcbiAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgICAgaWYgKGlzU3RhcnQpIHtcbiAgICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgdGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCwgdGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm91bmRhcnlVcGRhdGVyKHRoaXMsIHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCwgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgc2VsZWN0Tm9kZUNvbnRlbnRzOiBmdW5jdGlvbiBzZWxlY3ROb2RlQ29udGVudHMobm9kZSkge1xuICAgICAgICAvLyBUaGlzIGRvZXNuJ3Qgc2VlbSB3ZWxsIHNwZWNpZmllZDogdGhlIHNwZWMgdGFsa3Mgb25seSBhYm91dCBzZWxlY3RpbmcgdGhlIG5vZGUncyBjb250ZW50cywgd2hpY2hcbiAgICAgICAgLy8gY291bGQgYmUgdGFrZW4gdG8gbWVhbiBvbmx5IGl0cyBjaGlsZHJlbi4gSG93ZXZlciwgYnJvd3NlcnMgaW1wbGVtZW50IHRoaXMgdGhlIHNhbWUgYXMgc2VsZWN0Tm9kZSBmb3JcbiAgICAgICAgLy8gdGV4dCBub2Rlcywgc28gSSBzaGFsbCBkbyBsaWtld2lzZVxuICAgICAgICBhc3NlcnROb3REZXRhY2hlZCh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Tm9Eb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3Rvcihub2RlLCB0cnVlKTtcblxuICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgbm9kZSwgMCwgbm9kZSwgZG9tLmdldE5vZGVMZW5ndGgobm9kZSkpO1xuICAgICAgfSxcblxuICAgICAgc2VsZWN0Tm9kZTogZnVuY3Rpb24gc2VsZWN0Tm9kZShub2RlKSB7XG4gICAgICAgIGFzc2VydE5vdERldGFjaGVkKHRoaXMpO1xuICAgICAgICBhc3NlcnROb0RvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgYXNzZXJ0VmFsaWROb2RlVHlwZShub2RlLCBiZWZvcmVBZnRlck5vZGVUeXBlcyk7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gZ2V0Qm91bmRhcnlCZWZvcmVOb2RlKG5vZGUpLFxuICAgICAgICAgICAgZW5kID0gZ2V0Qm91bmRhcnlBZnRlck5vZGUobm9kZSk7XG4gICAgICAgIGJvdW5kYXJ5VXBkYXRlcih0aGlzLCBzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQsIGVuZC5ub2RlLCBlbmQub2Zmc2V0KTtcbiAgICAgIH0sXG5cbiAgICAgIGV4dHJhY3RDb250ZW50czogY3JlYXRlUmFuZ2VDb250ZW50UmVtb3ZlcihleHRyYWN0U3VidHJlZSwgYm91bmRhcnlVcGRhdGVyKSxcblxuICAgICAgZGVsZXRlQ29udGVudHM6IGNyZWF0ZVJhbmdlQ29udGVudFJlbW92ZXIoZGVsZXRlU3VidHJlZSwgYm91bmRhcnlVcGRhdGVyKSxcblxuICAgICAgY2FuU3Vycm91bmRDb250ZW50czogZnVuY3Rpb24gY2FuU3Vycm91bmRDb250ZW50cygpIHtcbiAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Tm9kZU5vdFJlYWRPbmx5KHRoaXMuc3RhcnRDb250YWluZXIpO1xuICAgICAgICBhc3NlcnROb2RlTm90UmVhZE9ubHkodGhpcy5lbmRDb250YWluZXIpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZW50cyBjYW4gYmUgc3Vycm91bmRlZC4gU3BlY2lmaWNhbGx5LCB0aGlzIG1lYW5zIHdoZXRoZXIgdGhlIHJhbmdlIHBhcnRpYWxseSBzZWxlY3RzXG4gICAgICAgIC8vIG5vIG5vbi10ZXh0IG5vZGVzLlxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgUmFuZ2VJdGVyYXRvcih0aGlzLCB0cnVlKTtcbiAgICAgICAgdmFyIGJvdW5kYXJpZXNJbnZhbGlkID0gaXRlcmF0b3IuX2ZpcnN0ICYmIGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKGl0ZXJhdG9yLl9maXJzdCwgdGhpcykgfHwgaXRlcmF0b3IuX2xhc3QgJiYgaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQoaXRlcmF0b3IuX2xhc3QsIHRoaXMpO1xuICAgICAgICBpdGVyYXRvci5kZXRhY2goKTtcbiAgICAgICAgcmV0dXJuICFib3VuZGFyaWVzSW52YWxpZDtcbiAgICAgIH0sXG5cbiAgICAgIGRldGFjaDogZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgICBkZXRhY2hlcih0aGlzKTtcbiAgICAgIH0sXG5cbiAgICAgIHNwbGl0Qm91bmRhcmllczogZnVuY3Rpb24gc3BsaXRCb3VuZGFyaWVzKCkge1xuICAgICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuXG4gICAgICAgIHZhciBzYyA9IHRoaXMuc3RhcnRDb250YWluZXIsXG4gICAgICAgICAgICBzbyA9IHRoaXMuc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICBlYyA9IHRoaXMuZW5kQ29udGFpbmVyLFxuICAgICAgICAgICAgZW8gPSB0aGlzLmVuZE9mZnNldDtcbiAgICAgICAgdmFyIHN0YXJ0RW5kU2FtZSA9IHNjID09PSBlYztcblxuICAgICAgICBpZiAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoZWMpICYmIGVvID4gMCAmJiBlbyA8IGVjLmxlbmd0aCkge1xuICAgICAgICAgIGRvbS5zcGxpdERhdGFOb2RlKGVjLCBlbyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoc2MpICYmIHNvID4gMCAmJiBzbyA8IHNjLmxlbmd0aCkge1xuXG4gICAgICAgICAgc2MgPSBkb20uc3BsaXREYXRhTm9kZShzYywgc28pO1xuICAgICAgICAgIGlmIChzdGFydEVuZFNhbWUpIHtcbiAgICAgICAgICAgIGVvIC09IHNvO1xuICAgICAgICAgICAgZWMgPSBzYztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVjID09IHNjLnBhcmVudE5vZGUgJiYgZW8gPj0gZG9tLmdldE5vZGVJbmRleChzYykpIHtcbiAgICAgICAgICAgIGVvKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvID0gMDtcbiAgICAgICAgfVxuICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgc2MsIHNvLCBlYywgZW8pO1xuICAgICAgfSxcblxuICAgICAgbm9ybWFsaXplQm91bmRhcmllczogZnVuY3Rpb24gbm9ybWFsaXplQm91bmRhcmllcygpIHtcbiAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcblxuICAgICAgICB2YXIgc2MgPSB0aGlzLnN0YXJ0Q29udGFpbmVyLFxuICAgICAgICAgICAgc28gPSB0aGlzLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgZWMgPSB0aGlzLmVuZENvbnRhaW5lcixcbiAgICAgICAgICAgIGVvID0gdGhpcy5lbmRPZmZzZXQ7XG5cbiAgICAgICAgdmFyIG1lcmdlRm9yd2FyZCA9IGZ1bmN0aW9uIG1lcmdlRm9yd2FyZChub2RlKSB7XG4gICAgICAgICAgdmFyIHNpYmxpbmcgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcubm9kZVR5cGUgPT0gbm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgZWMgPSBub2RlO1xuICAgICAgICAgICAgZW8gPSBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kRGF0YShzaWJsaW5nLmRhdGEpO1xuICAgICAgICAgICAgc2libGluZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbWVyZ2VCYWNrd2FyZCA9IGZ1bmN0aW9uIG1lcmdlQmFja3dhcmQobm9kZSkge1xuICAgICAgICAgIHZhciBzaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgaWYgKHNpYmxpbmcgJiYgc2libGluZy5ub2RlVHlwZSA9PSBub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBzYyA9IG5vZGU7XG4gICAgICAgICAgICB2YXIgbm9kZUxlbmd0aCA9IG5vZGUubGVuZ3RoO1xuICAgICAgICAgICAgc28gPSBzaWJsaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIG5vZGUuaW5zZXJ0RGF0YSgwLCBzaWJsaW5nLmRhdGEpO1xuICAgICAgICAgICAgc2libGluZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNpYmxpbmcpO1xuICAgICAgICAgICAgaWYgKHNjID09IGVjKSB7XG4gICAgICAgICAgICAgIGVvICs9IHNvO1xuICAgICAgICAgICAgICBlYyA9IHNjO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlYyA9PSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IGRvbS5nZXROb2RlSW5kZXgobm9kZSk7XG4gICAgICAgICAgICAgIGlmIChlbyA9PSBub2RlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBlYyA9IG5vZGU7XG4gICAgICAgICAgICAgICAgZW8gPSBub2RlTGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVvID4gbm9kZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgZW8tLTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbm9ybWFsaXplU3RhcnQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShlYykpIHtcbiAgICAgICAgICBpZiAoZWMubGVuZ3RoID09IGVvKSB7XG4gICAgICAgICAgICBtZXJnZUZvcndhcmQoZWMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZW8gPiAwKSB7XG4gICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGVjLmNoaWxkTm9kZXNbZW8gLSAxXTtcbiAgICAgICAgICAgIGlmIChlbmROb2RlICYmIGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKGVuZE5vZGUpKSB7XG4gICAgICAgICAgICAgIG1lcmdlRm9yd2FyZChlbmROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9ybWFsaXplU3RhcnQgPSAhdGhpcy5jb2xsYXBzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9ybWFsaXplU3RhcnQpIHtcbiAgICAgICAgICBpZiAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoc2MpKSB7XG4gICAgICAgICAgICBpZiAoc28gPT0gMCkge1xuICAgICAgICAgICAgICBtZXJnZUJhY2t3YXJkKHNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNvIDwgc2MuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IHNjLmNoaWxkTm9kZXNbc29dO1xuICAgICAgICAgICAgICBpZiAoc3RhcnROb2RlICYmIGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZUJhY2t3YXJkKHN0YXJ0Tm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2MgPSBlYztcbiAgICAgICAgICBzbyA9IGVvO1xuICAgICAgICB9XG5cbiAgICAgICAgYm91bmRhcnlVcGRhdGVyKHRoaXMsIHNjLCBzbywgZWMsIGVvKTtcbiAgICAgIH0sXG5cbiAgICAgIGNvbGxhcHNlVG9Qb2ludDogZnVuY3Rpb24gY29sbGFwc2VUb1BvaW50KG5vZGUsIG9mZnNldCkge1xuICAgICAgICBhc3NlcnROb3REZXRhY2hlZCh0aGlzKTtcblxuICAgICAgICBhc3NlcnROb0RvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIHRydWUpO1xuICAgICAgICBhc3NlcnRWYWxpZE9mZnNldChub2RlLCBvZmZzZXQpO1xuXG4gICAgICAgIHNldFJhbmdlU3RhcnRBbmRFbmQodGhpcywgbm9kZSwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvcHlDb21wYXJpc29uQ29uc3RhbnRzKGNvbnN0cnVjdG9yKTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gVXBkYXRlcyBjb21tb25BbmNlc3RvckNvbnRhaW5lciBhbmQgY29sbGFwc2VkIGFmdGVyIGJvdW5kYXJ5IGNoYW5nZVxuICBmdW5jdGlvbiB1cGRhdGVDb2xsYXBzZWRBbmRDb21tb25BbmNlc3RvcihyYW5nZSkge1xuICAgIHJhbmdlLmNvbGxhcHNlZCA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyID09PSByYW5nZS5lbmRDb250YWluZXIgJiYgcmFuZ2Uuc3RhcnRPZmZzZXQgPT09IHJhbmdlLmVuZE9mZnNldDtcbiAgICByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbGxhcHNlZCA/IHJhbmdlLnN0YXJ0Q29udGFpbmVyIDogZG9tLmdldENvbW1vbkFuY2VzdG9yKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5lbmRDb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQm91bmRhcmllcyhyYW5nZSwgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCkge1xuICAgIHZhciBzdGFydE1vdmVkID0gcmFuZ2Uuc3RhcnRDb250YWluZXIgIT09IHN0YXJ0Q29udGFpbmVyIHx8IHJhbmdlLnN0YXJ0T2Zmc2V0ICE9PSBzdGFydE9mZnNldDtcbiAgICB2YXIgZW5kTW92ZWQgPSByYW5nZS5lbmRDb250YWluZXIgIT09IGVuZENvbnRhaW5lciB8fCByYW5nZS5lbmRPZmZzZXQgIT09IGVuZE9mZnNldDtcblxuICAgIHJhbmdlLnN0YXJ0Q29udGFpbmVyID0gc3RhcnRDb250YWluZXI7XG4gICAgcmFuZ2Uuc3RhcnRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICByYW5nZS5lbmRDb250YWluZXIgPSBlbmRDb250YWluZXI7XG4gICAgcmFuZ2UuZW5kT2Zmc2V0ID0gZW5kT2Zmc2V0O1xuXG4gICAgdXBkYXRlQ29sbGFwc2VkQW5kQ29tbW9uQW5jZXN0b3IocmFuZ2UpO1xuICAgIGRpc3BhdGNoRXZlbnQocmFuZ2UsIFwiYm91bmRhcnljaGFuZ2VcIiwgeyBzdGFydE1vdmVkOiBzdGFydE1vdmVkLCBlbmRNb3ZlZDogZW5kTW92ZWQgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2gocmFuZ2UpIHtcbiAgICBhc3NlcnROb3REZXRhY2hlZChyYW5nZSk7XG4gICAgcmFuZ2Uuc3RhcnRDb250YWluZXIgPSByYW5nZS5zdGFydE9mZnNldCA9IHJhbmdlLmVuZENvbnRhaW5lciA9IHJhbmdlLmVuZE9mZnNldCA9IG51bGw7XG4gICAgcmFuZ2UuY29sbGFwc2VkID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSBudWxsO1xuICAgIGRpc3BhdGNoRXZlbnQocmFuZ2UsIFwiZGV0YWNoXCIsIG51bGwpO1xuICAgIHJhbmdlLl9saXN0ZW5lcnMgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gUmFuZ2UoZG9jKSB7XG4gICAgdGhpcy5zdGFydENvbnRhaW5lciA9IGRvYztcbiAgICB0aGlzLnN0YXJ0T2Zmc2V0ID0gMDtcbiAgICB0aGlzLmVuZENvbnRhaW5lciA9IGRvYztcbiAgICB0aGlzLmVuZE9mZnNldCA9IDA7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge1xuICAgICAgYm91bmRhcnljaGFuZ2U6IFtdLFxuICAgICAgZGV0YWNoOiBbXVxuICAgIH07XG4gICAgdXBkYXRlQ29sbGFwc2VkQW5kQ29tbW9uQW5jZXN0b3IodGhpcyk7XG4gIH1cblxuICBjcmVhdGVQcm90b3R5cGVSYW5nZShSYW5nZSwgdXBkYXRlQm91bmRhcmllcywgZGV0YWNoKTtcblxuICBhcGkucmFuZ2VQcm90b3R5cGUgPSBSYW5nZVByb3RvdHlwZS5wcm90b3R5cGU7XG5cbiAgUmFuZ2UucmFuZ2VQcm9wZXJ0aWVzID0gcmFuZ2VQcm9wZXJ0aWVzO1xuICBSYW5nZS5SYW5nZUl0ZXJhdG9yID0gUmFuZ2VJdGVyYXRvcjtcbiAgUmFuZ2UuY29weUNvbXBhcmlzb25Db25zdGFudHMgPSBjb3B5Q29tcGFyaXNvbkNvbnN0YW50cztcbiAgUmFuZ2UuY3JlYXRlUHJvdG90eXBlUmFuZ2UgPSBjcmVhdGVQcm90b3R5cGVSYW5nZTtcbiAgUmFuZ2UuaW5zcGVjdCA9IF9pbnNwZWN0O1xuICBSYW5nZS5nZXRSYW5nZURvY3VtZW50ID0gZ2V0UmFuZ2VEb2N1bWVudDtcbiAgUmFuZ2UucmFuZ2VzRXF1YWwgPSBmdW5jdGlvbiAocjEsIHIyKSB7XG4gICAgcmV0dXJuIHIxLnN0YXJ0Q29udGFpbmVyID09PSByMi5zdGFydENvbnRhaW5lciAmJiByMS5zdGFydE9mZnNldCA9PT0gcjIuc3RhcnRPZmZzZXQgJiYgcjEuZW5kQ29udGFpbmVyID09PSByMi5lbmRDb250YWluZXIgJiYgcjEuZW5kT2Zmc2V0ID09PSByMi5lbmRPZmZzZXQ7XG4gIH07XG5cbiAgYXBpLkRvbVJhbmdlID0gUmFuZ2U7XG4gIGFwaS5SYW5nZUV4Y2VwdGlvbiA9IFJhbmdlRXhjZXB0aW9uO1xufSk7cmFuZ3kuY3JlYXRlTW9kdWxlKFwiV3JhcHBlZFJhbmdlXCIsIGZ1bmN0aW9uIChhcGksIG1vZHVsZSkge1xuICBhcGkucmVxdWlyZU1vZHVsZXMoW1wiRG9tVXRpbFwiLCBcIkRvbVJhbmdlXCJdKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICB2YXIgV3JhcHBlZFJhbmdlO1xuICB2YXIgZG9tID0gYXBpLmRvbTtcbiAgdmFyIERvbVBvc2l0aW9uID0gZG9tLkRvbVBvc2l0aW9uO1xuICB2YXIgRG9tUmFuZ2UgPSBhcGkuRG9tUmFuZ2U7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKlxuICBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgYSBidWcgd2hlcmUgSUUgcmV0dXJucyB0aGUgd3JvbmcgY29udGFpbmVyIGVsZW1lbnQgZnJvbSB0aGUgVGV4dFJhbmdlJ3MgcGFyZW50RWxlbWVudCgpXG4gIG1ldGhvZC4gRm9yIGV4YW1wbGUsIGluIHRoZSBmb2xsb3dpbmcgKHdoZXJlIHBpcGVzIGRlbm90ZSB0aGUgc2VsZWN0aW9uIGJvdW5kYXJpZXMpOlxuICAgPHVsIGlkPVwidWxcIj48bGkgaWQ9XCJhXCI+fCBhIDwvbGk+PGxpIGlkPVwiYlwiPiBiIHw8L2xpPjwvdWw+XG4gICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgYWxlcnQocmFuZ2UucGFyZW50RWxlbWVudCgpLmlkKTsgLy8gU2hvdWxkIGFsZXJ0IFwidWxcIiBidXQgYWxlcnRzIFwiYlwiXG4gICBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjb21tb24gYW5jZXN0b3Igbm9kZSBvZiB0aGUgZm9sbG93aW5nOlxuICAtIHRoZSBwYXJlbnRFbGVtZW50KCkgb2YgdGhlIHRleHRSYW5nZVxuICAtIHRoZSBwYXJlbnRFbGVtZW50KCkgb2YgdGhlIHRleHRSYW5nZSBhZnRlciBjYWxsaW5nIGNvbGxhcHNlKHRydWUpXG4gIC0gdGhlIHBhcmVudEVsZW1lbnQoKSBvZiB0aGUgdGV4dFJhbmdlIGFmdGVyIGNhbGxpbmcgY29sbGFwc2UoZmFsc2UpXG4gICAqL1xuICBmdW5jdGlvbiBnZXRUZXh0UmFuZ2VDb250YWluZXJFbGVtZW50KHRleHRSYW5nZSkge1xuICAgIHZhciBwYXJlbnRFbCA9IHRleHRSYW5nZS5wYXJlbnRFbGVtZW50KCk7XG5cbiAgICB2YXIgcmFuZ2UgPSB0ZXh0UmFuZ2UuZHVwbGljYXRlKCk7XG4gICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgdmFyIHN0YXJ0RWwgPSByYW5nZS5wYXJlbnRFbGVtZW50KCk7XG4gICAgcmFuZ2UgPSB0ZXh0UmFuZ2UuZHVwbGljYXRlKCk7XG4gICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgIHZhciBlbmRFbCA9IHJhbmdlLnBhcmVudEVsZW1lbnQoKTtcbiAgICB2YXIgc3RhcnRFbmRDb250YWluZXIgPSBzdGFydEVsID09IGVuZEVsID8gc3RhcnRFbCA6IGRvbS5nZXRDb21tb25BbmNlc3RvcihzdGFydEVsLCBlbmRFbCk7XG5cbiAgICByZXR1cm4gc3RhcnRFbmRDb250YWluZXIgPT0gcGFyZW50RWwgPyBzdGFydEVuZENvbnRhaW5lciA6IGRvbS5nZXRDb21tb25BbmNlc3RvcihwYXJlbnRFbCwgc3RhcnRFbmRDb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dFJhbmdlSXNDb2xsYXBzZWQodGV4dFJhbmdlKSB7XG4gICAgcmV0dXJuIHRleHRSYW5nZS5jb21wYXJlRW5kUG9pbnRzKFwiU3RhcnRUb0VuZFwiLCB0ZXh0UmFuZ2UpID09IDA7XG4gIH1cblxuICAvLyBHZXRzIHRoZSBib3VuZGFyeSBvZiBhIFRleHRSYW5nZSBleHByZXNzZWQgYXMgYSBub2RlIGFuZCBhbiBvZmZzZXQgd2l0aGluIHRoYXQgbm9kZS4gVGhpcyBmdW5jdGlvbiBzdGFydGVkIG91dCBhc1xuICAvLyBhbiBpbXByb3ZlZCB2ZXJzaW9uIG9mIGNvZGUgZm91bmQgaW4gVGltIENhbWVyb24gUnlhbidzIElFUmFuZ2UgKGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9pZXJhbmdlLykgYnV0IGhhc1xuICAvLyBncm93biwgZml4aW5nIHByb2JsZW1zIHdpdGggbGluZSBicmVha3MgaW4gcHJlZm9ybWF0dGVkIHRleHQsIGFkZGluZyB3b3JrYXJvdW5kIGZvciBJRSBUZXh0UmFuZ2UgYnVncywgaGFuZGxpbmdcbiAgLy8gZm9yIGlucHV0cyBhbmQgaW1hZ2VzLCBwbHVzIG9wdGltaXphdGlvbnMuXG4gIGZ1bmN0aW9uIGdldFRleHRSYW5nZUJvdW5kYXJ5UG9zaXRpb24odGV4dFJhbmdlLCB3aG9sZVJhbmdlQ29udGFpbmVyRWxlbWVudCwgaXNTdGFydCwgaXNDb2xsYXBzZWQpIHtcbiAgICB2YXIgd29ya2luZ1JhbmdlID0gdGV4dFJhbmdlLmR1cGxpY2F0ZSgpO1xuXG4gICAgd29ya2luZ1JhbmdlLmNvbGxhcHNlKGlzU3RhcnQpO1xuICAgIHZhciBjb250YWluZXJFbGVtZW50ID0gd29ya2luZ1JhbmdlLnBhcmVudEVsZW1lbnQoKTtcblxuICAgIC8vIFNvbWV0aW1lcyBjb2xsYXBzaW5nIGEgVGV4dFJhbmdlIHRoYXQncyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0IG5vZGUgY2FuIG1vdmUgaXQgaW50byB0aGUgcHJldmlvdXMgbm9kZSwgc29cbiAgICAvLyBjaGVjayBmb3IgdGhhdFxuICAgIC8vIFRPRE86IEZpbmQgb3V0IHdoZW4uIFdvcmthcm91bmQgZm9yIHdob2xlUmFuZ2VDb250YWluZXJFbGVtZW50IG1heSBicmVhayB0aGlzXG4gICAgaWYgKCFkb20uaXNBbmNlc3Rvck9mKHdob2xlUmFuZ2VDb250YWluZXJFbGVtZW50LCBjb250YWluZXJFbGVtZW50LCB0cnVlKSkge1xuICAgICAgY29udGFpbmVyRWxlbWVudCA9IHdob2xlUmFuZ2VDb250YWluZXJFbGVtZW50O1xuICAgIH1cblxuICAgIC8vIERlYWwgd2l0aCBub2RlcyB0aGF0IGNhbm5vdCBcImNvbnRhaW4gcmljaCBIVE1MIG1hcmt1cFwiLiBJbiBwcmFjdGljZSwgdGhpcyBtZWFucyBmb3JtIGlucHV0cywgaW1hZ2VzIGFuZFxuICAgIC8vIHNpbWlsYXIuIFNlZSBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvYWE3MDM5NTAlMjhWUy44NSUyOS5hc3B4XG4gICAgaWYgKCFjb250YWluZXJFbGVtZW50LmNhbkhhdmVIVE1MKSB7XG4gICAgICByZXR1cm4gbmV3IERvbVBvc2l0aW9uKGNvbnRhaW5lckVsZW1lbnQucGFyZW50Tm9kZSwgZG9tLmdldE5vZGVJbmRleChjb250YWluZXJFbGVtZW50KSk7XG4gICAgfVxuXG4gICAgdmFyIHdvcmtpbmdOb2RlID0gZG9tLmdldERvY3VtZW50KGNvbnRhaW5lckVsZW1lbnQpLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHZhciBjb21wYXJpc29uLFxuICAgICAgICB3b3JraW5nQ29tcGFyaXNvblR5cGUgPSBpc1N0YXJ0ID8gXCJTdGFydFRvU3RhcnRcIiA6IFwiU3RhcnRUb0VuZFwiO1xuICAgIHZhciBwcmV2aW91c05vZGUsIG5leHROb2RlLCBib3VuZGFyeVBvc2l0aW9uLCBib3VuZGFyeU5vZGU7XG5cbiAgICAvLyBNb3ZlIHRoZSB3b3JraW5nIHJhbmdlIHRocm91Z2ggdGhlIGNvbnRhaW5lcidzIGNoaWxkcmVuLCBzdGFydGluZyBhdCB0aGUgZW5kIGFuZCB3b3JraW5nIGJhY2t3YXJkcywgdW50aWwgdGhlXG4gICAgLy8gd29ya2luZyByYW5nZSByZWFjaGVzIG9yIGdvZXMgcGFzdCB0aGUgYm91bmRhcnkgd2UncmUgaW50ZXJlc3RlZCBpblxuICAgIGRvIHtcbiAgICAgIGNvbnRhaW5lckVsZW1lbnQuaW5zZXJ0QmVmb3JlKHdvcmtpbmdOb2RlLCB3b3JraW5nTm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgd29ya2luZ1JhbmdlLm1vdmVUb0VsZW1lbnRUZXh0KHdvcmtpbmdOb2RlKTtcbiAgICB9IHdoaWxlICgoY29tcGFyaXNvbiA9IHdvcmtpbmdSYW5nZS5jb21wYXJlRW5kUG9pbnRzKHdvcmtpbmdDb21wYXJpc29uVHlwZSwgdGV4dFJhbmdlKSkgPiAwICYmIHdvcmtpbmdOb2RlLnByZXZpb3VzU2libGluZyk7XG5cbiAgICAvLyBXZSd2ZSBub3cgcmVhY2hlZCBvciBnb25lIHBhc3QgdGhlIGJvdW5kYXJ5IG9mIHRoZSB0ZXh0IHJhbmdlIHdlJ3JlIGludGVyZXN0ZWQgaW5cbiAgICAvLyBzbyBoYXZlIGlkZW50aWZpZWQgdGhlIG5vZGUgd2Ugd2FudFxuICAgIGJvdW5kYXJ5Tm9kZSA9IHdvcmtpbmdOb2RlLm5leHRTaWJsaW5nO1xuXG4gICAgaWYgKGNvbXBhcmlzb24gPT0gLTEgJiYgYm91bmRhcnlOb2RlICYmIGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKGJvdW5kYXJ5Tm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBjaGFyYWN0ZXIgZGF0YSBub2RlICh0ZXh0LCBjb21tZW50LCBjZGF0YSkuIFRoZSB3b3JraW5nIHJhbmdlIGlzIGNvbGxhcHNlZCBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICAvLyBub2RlIGNvbnRhaW5pbmcgdGhlIHRleHQgcmFuZ2UncyBib3VuZGFyeSwgc28gd2UgbW92ZSB0aGUgZW5kIG9mIHRoZSB3b3JraW5nIHJhbmdlIHRvIHRoZSBib3VuZGFyeSBwb2ludFxuICAgICAgLy8gYW5kIG1lYXN1cmUgdGhlIGxlbmd0aCBvZiBpdHMgdGV4dCB0byBnZXQgdGhlIGJvdW5kYXJ5J3Mgb2Zmc2V0IHdpdGhpbiB0aGUgbm9kZS5cbiAgICAgIHdvcmtpbmdSYW5nZS5zZXRFbmRQb2ludChpc1N0YXJ0ID8gXCJFbmRUb1N0YXJ0XCIgOiBcIkVuZFRvRW5kXCIsIHRleHRSYW5nZSk7XG5cbiAgICAgIHZhciBvZmZzZXQ7XG5cbiAgICAgIGlmICgvW1xcclxcbl0vLnRlc3QoYm91bmRhcnlOb2RlLmRhdGEpKSB7XG4gICAgICAgIC8qXG4gICAgICAgIEZvciB0aGUgcGFydGljdWxhciBjYXNlIG9mIGEgYm91bmRhcnkgd2l0aGluIGEgdGV4dCBub2RlIGNvbnRhaW5pbmcgbGluZSBicmVha3MgKHdpdGhpbiBhIDxwcmU+IGVsZW1lbnQsXG4gICAgICAgIGZvciBleGFtcGxlKSwgd2UgbmVlZCBhIHNsaWdodGx5IGNvbXBsaWNhdGVkIGFwcHJvYWNoIHRvIGdldCB0aGUgYm91bmRhcnkncyBvZmZzZXQgaW4gSUUuIFRoZSBmYWN0czpcbiAgICAgICAgIC0gRWFjaCBsaW5lIGJyZWFrIGlzIHJlcHJlc2VudGVkIGFzIFxcciBpbiB0aGUgdGV4dCBub2RlJ3MgZGF0YS9ub2RlVmFsdWUgcHJvcGVydGllc1xuICAgICAgICAtIEVhY2ggbGluZSBicmVhayBpcyByZXByZXNlbnRlZCBhcyBcXHJcXG4gaW4gdGhlIFRleHRSYW5nZSdzICd0ZXh0JyBwcm9wZXJ0eVxuICAgICAgICAtIFRoZSAndGV4dCcgcHJvcGVydHkgb2YgdGhlIFRleHRSYW5nZSBkb2VzIG5vdCBjb250YWluIHRyYWlsaW5nIGxpbmUgYnJlYWtzXG4gICAgICAgICBUbyBnZXQgcm91bmQgdGhlIHByb2JsZW0gcHJlc2VudGVkIGJ5IHRoZSBmaW5hbCBmYWN0IGFib3ZlLCB3ZSBjYW4gdXNlIHRoZSBmYWN0IHRoYXQgVGV4dFJhbmdlJ3NcbiAgICAgICAgbW92ZVN0YXJ0KCkgYW5kIG1vdmVFbmQoKSBtZXRob2RzIHJldHVybiB0aGUgYWN0dWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIG1vdmVkLCB3aGljaCBpcyBub3QgbmVjZXNzYXJpbHlcbiAgICAgICAgdGhlIHNhbWUgYXMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGl0IHdhcyBpbnN0cnVjdGVkIHRvIG1vdmUuIFRoZSBzaW1wbGVzdCBhcHByb2FjaCBpcyB0byB1c2UgdGhpcyB0b1xuICAgICAgICBzdG9yZSB0aGUgY2hhcmFjdGVycyBtb3ZlZCB3aGVuIG1vdmluZyBib3RoIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSByYW5nZSB0byB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIGJvZHkgYW5kIHN1YnRyYWN0aW5nIHRoZSBzdGFydCBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mZnNldCAodGhlIFwibW92ZS1uZWdhdGl2ZS1nYXppbGxpb25cIiBtZXRob2QpLlxuICAgICAgICBIb3dldmVyLCB0aGlzIGlzIGV4dHJlbWVseSBzbG93IHdoZW4gdGhlIGRvY3VtZW50IGlzIGxhcmdlIGFuZCB0aGUgcmFuZ2UgaXMgbmVhciB0aGUgZW5kIG9mIGl0LiBDbGVhcmx5XG4gICAgICAgIGRvaW5nIHRoZSBtaXJyb3IgaW1hZ2UgKGkuZS4gbW92aW5nIHRoZSByYW5nZSBib3VuZGFyaWVzIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50KSBoYXMgdGhlIHNhbWVcbiAgICAgICAgcHJvYmxlbS5cbiAgICAgICAgIEFub3RoZXIgYXBwcm9hY2ggdGhhdCB3b3JrcyBpcyB0byB1c2UgbW92ZVN0YXJ0KCkgdG8gbW92ZSB0aGUgc3RhcnQgYm91bmRhcnkgb2YgdGhlIHJhbmdlIHVwIHRvIHRoZSBlbmRcbiAgICAgICAgYm91bmRhcnkgb25lIGNoYXJhY3RlciBhdCBhIHRpbWUgYW5kIGluY3JlbWVudGluZyBhIGNvdW50ZXIgd2l0aCB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIG1vdmVTdGFydCgpXG4gICAgICAgIGNhbGwuIEhvd2V2ZXIsIHRoZSBjaGVjayBmb3Igd2hldGhlciB0aGUgc3RhcnQgYm91bmRhcnkgaGFzIHJlYWNoZWQgdGhlIGVuZCBib3VuZGFyeSBpcyBleHBlbnNpdmUsIHNvXG4gICAgICAgIHRoaXMgbWV0aG9kIGlzIHNsb3cgKGFsdGhvdWdoIHVubGlrZSBcIm1vdmUtbmVnYXRpdmUtZ2F6aWxsaW9uXCIgaXMgbGFyZ2VseSB1bmFmZmVjdGVkIGJ5IHRoZSBsb2NhdGlvbiBvZlxuICAgICAgICB0aGUgcmFuZ2Ugd2l0aGluIHRoZSBkb2N1bWVudCkuXG4gICAgICAgICBUaGUgbWV0aG9kIGJlbG93IGlzIGEgaHlicmlkIG9mIHRoZSB0d28gbWV0aG9kcyBhYm92ZS4gSXQgdXNlcyB0aGUgZmFjdCB0aGF0IGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlXG4gICAgICAgIFRleHRSYW5nZSdzICd0ZXh0JyBwcm9wZXJ0eSB3aXRoIGVhY2ggXFxyXFxuIGNvbnZlcnRlZCB0byBhIHNpbmdsZSBcXHIgY2hhcmFjdGVyIGNhbm5vdCBiZSBsb25nZXIgdGhhbiB0aGVcbiAgICAgICAgdGV4dCBvZiB0aGUgVGV4dFJhbmdlLCBzbyB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlIGlzIG1vdmVkIHRoYXQgbGVuZ3RoIGluaXRpYWxseSBhbmQgdGhlbiBhIGNoYXJhY3RlciBhdFxuICAgICAgICBhIHRpbWUgdG8gbWFrZSB1cCBmb3IgYW55IHRyYWlsaW5nIGxpbmUgYnJlYWtzIG5vdCBjb250YWluZWQgaW4gdGhlICd0ZXh0JyBwcm9wZXJ0eS4gVGhpcyBoYXMgZ29vZFxuICAgICAgICBwZXJmb3JtYW5jZSBpbiBtb3N0IHNpdHVhdGlvbnMgY29tcGFyZWQgdG8gdGhlIHByZXZpb3VzIHR3byBtZXRob2RzLlxuICAgICAgICAqL1xuICAgICAgICB2YXIgdGVtcFJhbmdlID0gd29ya2luZ1JhbmdlLmR1cGxpY2F0ZSgpO1xuICAgICAgICB2YXIgcmFuZ2VMZW5ndGggPSB0ZW1wUmFuZ2UudGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgXCJcXHJcIikubGVuZ3RoO1xuXG4gICAgICAgIG9mZnNldCA9IHRlbXBSYW5nZS5tb3ZlU3RhcnQoXCJjaGFyYWN0ZXJcIiwgcmFuZ2VMZW5ndGgpO1xuICAgICAgICB3aGlsZSAoKGNvbXBhcmlzb24gPSB0ZW1wUmFuZ2UuY29tcGFyZUVuZFBvaW50cyhcIlN0YXJ0VG9FbmRcIiwgdGVtcFJhbmdlKSkgPT0gLTEpIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICB0ZW1wUmFuZ2UubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSB3b3JraW5nUmFuZ2UudGV4dC5sZW5ndGg7XG4gICAgICB9XG4gICAgICBib3VuZGFyeVBvc2l0aW9uID0gbmV3IERvbVBvc2l0aW9uKGJvdW5kYXJ5Tm9kZSwgb2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBJZiB0aGUgYm91bmRhcnkgaW1tZWRpYXRlbHkgZm9sbG93cyBhIGNoYXJhY3RlciBkYXRhIG5vZGUgYW5kIHRoaXMgaXMgdGhlIGVuZCBib3VuZGFyeSwgd2Ugc2hvdWxkIGZhdm91clxuICAgICAgLy8gYSBwb3NpdGlvbiB3aXRoaW4gdGhhdCwgYW5kIGxpa2V3aXNlIGZvciBhIHN0YXJ0IGJvdW5kYXJ5IHByZWNlZGluZyBhIGNoYXJhY3RlciBkYXRhIG5vZGVcbiAgICAgIHByZXZpb3VzTm9kZSA9IChpc0NvbGxhcHNlZCB8fCAhaXNTdGFydCkgJiYgd29ya2luZ05vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgbmV4dE5vZGUgPSAoaXNDb2xsYXBzZWQgfHwgaXNTdGFydCkgJiYgd29ya2luZ05vZGUubmV4dFNpYmxpbmc7XG5cbiAgICAgIGlmIChuZXh0Tm9kZSAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShuZXh0Tm9kZSkpIHtcbiAgICAgICAgYm91bmRhcnlQb3NpdGlvbiA9IG5ldyBEb21Qb3NpdGlvbihuZXh0Tm9kZSwgMCk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzTm9kZSAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShwcmV2aW91c05vZGUpKSB7XG4gICAgICAgIGJvdW5kYXJ5UG9zaXRpb24gPSBuZXcgRG9tUG9zaXRpb24ocHJldmlvdXNOb2RlLCBwcmV2aW91c05vZGUubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kYXJ5UG9zaXRpb24gPSBuZXcgRG9tUG9zaXRpb24oY29udGFpbmVyRWxlbWVudCwgZG9tLmdldE5vZGVJbmRleCh3b3JraW5nTm9kZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFuIHVwXG4gICAgd29ya2luZ05vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3b3JraW5nTm9kZSk7XG5cbiAgICByZXR1cm4gYm91bmRhcnlQb3NpdGlvbjtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBUZXh0UmFuZ2UgcmVwcmVzZW50aW5nIHRoZSBib3VuZGFyeSBvZiBhIFRleHRSYW5nZSBleHByZXNzZWQgYXMgYSBub2RlIGFuZCBhbiBvZmZzZXQgd2l0aGluIHRoYXQgbm9kZS5cbiAgLy8gVGhpcyBmdW5jdGlvbiBzdGFydGVkIG91dCBhcyBhbiBvcHRpbWl6ZWQgdmVyc2lvbiBvZiBjb2RlIGZvdW5kIGluIFRpbSBDYW1lcm9uIFJ5YW4ncyBJRVJhbmdlXG4gIC8vIChodHRwOi8vY29kZS5nb29nbGUuY29tL3AvaWVyYW5nZS8pXG4gIGZ1bmN0aW9uIGNyZWF0ZUJvdW5kYXJ5VGV4dFJhbmdlKGJvdW5kYXJ5UG9zaXRpb24sIGlzU3RhcnQpIHtcbiAgICB2YXIgYm91bmRhcnlOb2RlLFxuICAgICAgICBib3VuZGFyeVBhcmVudCxcbiAgICAgICAgYm91bmRhcnlPZmZzZXQgPSBib3VuZGFyeVBvc2l0aW9uLm9mZnNldDtcbiAgICB2YXIgZG9jID0gZG9tLmdldERvY3VtZW50KGJvdW5kYXJ5UG9zaXRpb24ubm9kZSk7XG4gICAgdmFyIHdvcmtpbmdOb2RlLFxuICAgICAgICBjaGlsZE5vZGVzLFxuICAgICAgICB3b3JraW5nUmFuZ2UgPSBkb2MuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICB2YXIgbm9kZUlzRGF0YU5vZGUgPSBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShib3VuZGFyeVBvc2l0aW9uLm5vZGUpO1xuXG4gICAgaWYgKG5vZGVJc0RhdGFOb2RlKSB7XG4gICAgICBib3VuZGFyeU5vZGUgPSBib3VuZGFyeVBvc2l0aW9uLm5vZGU7XG4gICAgICBib3VuZGFyeVBhcmVudCA9IGJvdW5kYXJ5Tm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZE5vZGVzID0gYm91bmRhcnlQb3NpdGlvbi5ub2RlLmNoaWxkTm9kZXM7XG4gICAgICBib3VuZGFyeU5vZGUgPSBib3VuZGFyeU9mZnNldCA8IGNoaWxkTm9kZXMubGVuZ3RoID8gY2hpbGROb2Rlc1tib3VuZGFyeU9mZnNldF0gOiBudWxsO1xuICAgICAgYm91bmRhcnlQYXJlbnQgPSBib3VuZGFyeVBvc2l0aW9uLm5vZGU7XG4gICAgfVxuXG4gICAgLy8gUG9zaXRpb24gdGhlIHJhbmdlIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBib3VuZGFyeVxuICAgIHdvcmtpbmdOb2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgLy8gTWFraW5nIHRoZSB3b3JraW5nIGVsZW1lbnQgbm9uLWVtcHR5IGVsZW1lbnQgcGVyc3VhZGVzIElFIHRvIGNvbnNpZGVyIHRoZSBUZXh0UmFuZ2UgYm91bmRhcnkgdG8gYmUgd2l0aGluIHRoZVxuICAgIC8vIGVsZW1lbnQgcmF0aGVyIHRoYW4gaW1tZWRpYXRlbHkgYmVmb3JlIG9yIGFmdGVyIGl0LCB3aGljaCBpcyB3aGF0IHdlIHdhbnRcbiAgICB3b3JraW5nTm9kZS5pbm5lckhUTUwgPSBcIiYjZmVmZjtcIjtcblxuICAgIC8vIGluc2VydEJlZm9yZSBpcyBzdXBwb3NlZCB0byB3b3JrIGxpa2UgYXBwZW5kQ2hpbGQgaWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgbnVsbC4gSG93ZXZlciwgYSBidWcgcmVwb3J0XG4gICAgLy8gZm9yIElFUmFuZ2Ugc3VnZ2VzdHMgdGhhdCBpdCBjYW4gY3Jhc2ggdGhlIGJyb3dzZXI6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9pZXJhbmdlL2lzc3Vlcy9kZXRhaWw/aWQ9MTJcbiAgICBpZiAoYm91bmRhcnlOb2RlKSB7XG4gICAgICBib3VuZGFyeVBhcmVudC5pbnNlcnRCZWZvcmUod29ya2luZ05vZGUsIGJvdW5kYXJ5Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kYXJ5UGFyZW50LmFwcGVuZENoaWxkKHdvcmtpbmdOb2RlKTtcbiAgICB9XG5cbiAgICB3b3JraW5nUmFuZ2UubW92ZVRvRWxlbWVudFRleHQod29ya2luZ05vZGUpO1xuICAgIHdvcmtpbmdSYW5nZS5jb2xsYXBzZSghaXNTdGFydCk7XG5cbiAgICAvLyBDbGVhbiB1cFxuICAgIGJvdW5kYXJ5UGFyZW50LnJlbW92ZUNoaWxkKHdvcmtpbmdOb2RlKTtcblxuICAgIC8vIE1vdmUgdGhlIHdvcmtpbmcgcmFuZ2UgdG8gdGhlIHRleHQgb2Zmc2V0LCBpZiByZXF1aXJlZFxuICAgIGlmIChub2RlSXNEYXRhTm9kZSkge1xuICAgICAgd29ya2luZ1JhbmdlW2lzU3RhcnQgPyBcIm1vdmVTdGFydFwiIDogXCJtb3ZlRW5kXCJdKFwiY2hhcmFjdGVyXCIsIGJvdW5kYXJ5T2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya2luZ1JhbmdlO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICBpZiAoYXBpLmZlYXR1cmVzLmltcGxlbWVudHNEb21SYW5nZSAmJiAoIWFwaS5mZWF0dXJlcy5pbXBsZW1lbnRzVGV4dFJhbmdlIHx8ICFhcGkuY29uZmlnLnByZWZlclRleHRSYW5nZSkpIHtcbiAgICAvLyBUaGlzIGlzIGEgd3JhcHBlciBhcm91bmQgdGhlIGJyb3dzZXIncyBuYXRpdmUgRE9NIFJhbmdlLiBJdCBoYXMgdHdvIGFpbXM6XG4gICAgLy8gLSBQcm92aWRlIHdvcmthcm91bmRzIGZvciBzcGVjaWZpYyBicm93c2VyIGJ1Z3NcbiAgICAvLyAtIHByb3ZpZGUgY29udmVuaWVudCBleHRlbnNpb25zLCB3aGljaCBhcmUgaW5oZXJpdGVkIGZyb20gUmFuZ3kncyBEb21SYW5nZVxuXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByYW5nZVByb3RvO1xuICAgICAgdmFyIHJhbmdlUHJvcGVydGllcyA9IERvbVJhbmdlLnJhbmdlUHJvcGVydGllcztcbiAgICAgIHZhciBjYW5TZXRSYW5nZVN0YXJ0QWZ0ZXJFbmQ7XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVJhbmdlUHJvcGVydGllcyhyYW5nZSkge1xuICAgICAgICB2YXIgaSA9IHJhbmdlUHJvcGVydGllcy5sZW5ndGgsXG4gICAgICAgICAgICBwcm9wO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgcHJvcCA9IHJhbmdlUHJvcGVydGllc1tpXTtcbiAgICAgICAgICByYW5nZVtwcm9wXSA9IHJhbmdlLm5hdGl2ZVJhbmdlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZU5hdGl2ZVJhbmdlKHJhbmdlLCBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0KSB7XG4gICAgICAgIHZhciBzdGFydE1vdmVkID0gcmFuZ2Uuc3RhcnRDb250YWluZXIgIT09IHN0YXJ0Q29udGFpbmVyIHx8IHJhbmdlLnN0YXJ0T2Zmc2V0ICE9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICB2YXIgZW5kTW92ZWQgPSByYW5nZS5lbmRDb250YWluZXIgIT09IGVuZENvbnRhaW5lciB8fCByYW5nZS5lbmRPZmZzZXQgIT0gZW5kT2Zmc2V0O1xuXG4gICAgICAgIC8vIEFsd2F5cyBzZXQgYm90aCBib3VuZGFyaWVzIGZvciB0aGUgYmVuZWZpdCBvZiBJRTkgKHNlZSBpc3N1ZSAzNSlcbiAgICAgICAgaWYgKHN0YXJ0TW92ZWQgfHwgZW5kTW92ZWQpIHtcbiAgICAgICAgICByYW5nZS5zZXRFbmQoZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQpO1xuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGV0YWNoKHJhbmdlKSB7XG4gICAgICAgIHJhbmdlLm5hdGl2ZVJhbmdlLmRldGFjaCgpO1xuICAgICAgICByYW5nZS5kZXRhY2hlZCA9IHRydWU7XG4gICAgICAgIHZhciBpID0gcmFuZ2VQcm9wZXJ0aWVzLmxlbmd0aCxcbiAgICAgICAgICAgIHByb3A7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBwcm9wID0gcmFuZ2VQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgIHJhbmdlW3Byb3BdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyO1xuXG4gICAgICBXcmFwcGVkUmFuZ2UgPSBmdW5jdGlvbiBXcmFwcGVkUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbmdlIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmF0aXZlUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgRG9tUmFuZ2UuY3JlYXRlUHJvdG90eXBlUmFuZ2UoV3JhcHBlZFJhbmdlLCB1cGRhdGVOYXRpdmVSYW5nZSwgZGV0YWNoKTtcblxuICAgICAgcmFuZ2VQcm90byA9IFdyYXBwZWRSYW5nZS5wcm90b3R5cGU7XG5cbiAgICAgIHJhbmdlUHJvdG8uc2VsZWN0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgcmFuZ2VQcm90by5kZWxldGVDb250ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5kZWxldGVDb250ZW50cygpO1xuICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICB9O1xuXG4gICAgICByYW5nZVByb3RvLmV4dHJhY3RDb250ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZyYWcgPSB0aGlzLm5hdGl2ZVJhbmdlLmV4dHJhY3RDb250ZW50cygpO1xuICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgIHJldHVybiBmcmFnO1xuICAgICAgfTtcblxuICAgICAgcmFuZ2VQcm90by5jbG9uZUNvbnRlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVSYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBUT0RPOiBVbnRpbCBJIGNhbiBmaW5kIGEgd2F5IHRvIHByb2dyYW1tYXRpY2FsbHkgdHJpZ2dlciB0aGUgRmlyZWZveCBidWcgKGFwcGFyZW50bHkgbG9uZy1zdGFuZGluZywgc3RpbGxcbiAgICAgIC8vIHByZXNlbnQgaW4gMy42LjgpIHRoYXQgdGhyb3dzIFwiSW5kZXggb3Igc2l6ZSBpcyBuZWdhdGl2ZSBvciBncmVhdGVyIHRoYW4gdGhlIGFsbG93ZWQgYW1vdW50XCIgZm9yXG4gICAgICAvLyBpbnNlcnROb2RlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcywgYWxsIGJyb3dzZXJzIHdpbGwgaGF2ZSB0byB1c2UgdGhlIFJhbmd5J3Mgb3duIGltcGxlbWVudGF0aW9uIG9mXG4gICAgICAvLyBpbnNlcnROb2RlLCB3aGljaCB3b3JrcyBidXQgaXMgYWxtb3N0IGNlcnRhaW5seSBzbG93ZXIgdGhhbiB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLlxuICAgICAgLypcbiAgICAgICAgICAgICAgICAgIHJhbmdlUHJvdG8uaW5zZXJ0Tm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLmluc2VydE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICovXG5cbiAgICAgIHJhbmdlUHJvdG8uc3Vycm91bmRDb250ZW50cyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc3Vycm91bmRDb250ZW50cyhub2RlKTtcbiAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgcmFuZ2VQcm90by5jb2xsYXBzZSA9IGZ1bmN0aW9uIChpc1N0YXJ0KSB7XG4gICAgICAgIHRoaXMubmF0aXZlUmFuZ2UuY29sbGFwc2UoaXNTdGFydCk7XG4gICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgIH07XG5cbiAgICAgIHJhbmdlUHJvdG8uY2xvbmVSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcmFwcGVkUmFuZ2UodGhpcy5uYXRpdmVSYW5nZS5jbG9uZVJhbmdlKCkpO1xuICAgICAgfTtcblxuICAgICAgcmFuZ2VQcm90by5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICB9O1xuXG4gICAgICByYW5nZVByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVSYW5nZS50b1N0cmluZygpO1xuICAgICAgfTtcblxuICAgICAgLy8gQ3JlYXRlIHRlc3QgcmFuZ2UgYW5kIG5vZGUgZm9yIGZlYXR1cmUgZGV0ZWN0aW9uXG5cbiAgICAgIHZhciB0ZXN0VGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcInRlc3RcIik7XG4gICAgICBkb20uZ2V0Qm9keShkb2N1bWVudCkuYXBwZW5kQ2hpbGQodGVzdFRleHROb2RlKTtcbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG5cbiAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAvLyBUZXN0IGZvciBGaXJlZm94IDIgYnVnIHRoYXQgcHJldmVudHMgbW92aW5nIHRoZSBzdGFydCBvZiBhIFJhbmdlIHRvIGEgcG9pbnQgYWZ0ZXIgaXRzIGN1cnJlbnQgZW5kIGFuZFxuICAgICAgLy8gY29ycmVjdCBmb3IgaXRcblxuICAgICAgcmFuZ2Uuc2V0U3RhcnQodGVzdFRleHROb2RlLCAwKTtcbiAgICAgIHJhbmdlLnNldEVuZCh0ZXN0VGV4dE5vZGUsIDApO1xuXG4gICAgICB0cnkge1xuICAgICAgICByYW5nZS5zZXRTdGFydCh0ZXN0VGV4dE5vZGUsIDEpO1xuICAgICAgICBjYW5TZXRSYW5nZVN0YXJ0QWZ0ZXJFbmQgPSB0cnVlO1xuXG4gICAgICAgIHJhbmdlUHJvdG8uc2V0U3RhcnQgPSBmdW5jdGlvbiAobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgfTtcblxuICAgICAgICByYW5nZVByb3RvLnNldEVuZCA9IGZ1bmN0aW9uIChub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIgPSBmdW5jdGlvbiBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIobmFtZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZVtuYW1lXShub2RlKTtcbiAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZXgpIHtcblxuICAgICAgICBjYW5TZXRSYW5nZVN0YXJ0QWZ0ZXJFbmQgPSBmYWxzZTtcblxuICAgICAgICByYW5nZVByb3RvLnNldFN0YXJ0ID0gZnVuY3Rpb24gKG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgfTtcblxuICAgICAgICByYW5nZVByb3RvLnNldEVuZCA9IGZ1bmN0aW9uIChub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlciA9IGZ1bmN0aW9uIGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcihuYW1lLCBvcHBvc2l0ZU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2VbbmFtZV0obm9kZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlW29wcG9zaXRlTmFtZV0obm9kZSk7XG4gICAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2VbbmFtZV0obm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmFuZ2VQcm90by5zZXRTdGFydEJlZm9yZSA9IGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcihcInNldFN0YXJ0QmVmb3JlXCIsIFwic2V0RW5kQmVmb3JlXCIpO1xuICAgICAgcmFuZ2VQcm90by5zZXRTdGFydEFmdGVyID0gY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKFwic2V0U3RhcnRBZnRlclwiLCBcInNldEVuZEFmdGVyXCIpO1xuICAgICAgcmFuZ2VQcm90by5zZXRFbmRCZWZvcmUgPSBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoXCJzZXRFbmRCZWZvcmVcIiwgXCJzZXRTdGFydEJlZm9yZVwiKTtcbiAgICAgIHJhbmdlUHJvdG8uc2V0RW5kQWZ0ZXIgPSBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoXCJzZXRFbmRBZnRlclwiLCBcInNldFN0YXJ0QWZ0ZXJcIik7XG5cbiAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAvLyBUZXN0IGZvciBhbmQgY29ycmVjdCBGaXJlZm94IDIgYmVoYXZpb3VyIHdpdGggc2VsZWN0Tm9kZUNvbnRlbnRzIG9uIHRleHQgbm9kZXM6IGl0IGNvbGxhcHNlcyB0aGUgcmFuZ2UgdG9cbiAgICAgIC8vIHRoZSAwdGggY2hhcmFjdGVyIG9mIHRoZSB0ZXh0IG5vZGVcbiAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyh0ZXN0VGV4dE5vZGUpO1xuICAgICAgaWYgKHJhbmdlLnN0YXJ0Q29udGFpbmVyID09IHRlc3RUZXh0Tm9kZSAmJiByYW5nZS5lbmRDb250YWluZXIgPT0gdGVzdFRleHROb2RlICYmIHJhbmdlLnN0YXJ0T2Zmc2V0ID09IDAgJiYgcmFuZ2UuZW5kT2Zmc2V0ID09IHRlc3RUZXh0Tm9kZS5sZW5ndGgpIHtcbiAgICAgICAgcmFuZ2VQcm90by5zZWxlY3ROb2RlQ29udGVudHMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlUHJvdG8uc2VsZWN0Tm9kZUNvbnRlbnRzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB0aGlzLnNldFN0YXJ0KG5vZGUsIDApO1xuICAgICAgICAgIHRoaXMuc2V0RW5kKG5vZGUsIERvbVJhbmdlLmdldEVuZE9mZnNldChub2RlKSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAvLyBUZXN0IGZvciBXZWJLaXQgYnVnIHRoYXQgaGFzIHRoZSBiZWFodmlvdXIgb2YgY29tcGFyZUJvdW5kYXJ5UG9pbnRzIHJvdW5kIHRoZSB3cm9uZyB3YXkgZm9yIGNvbnN0YW50c1xuICAgICAgLy8gU1RBUlRfVE9fRU5EIGFuZCBFTkRfVE9fU1RBUlQ6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDczOFxuXG4gICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHModGVzdFRleHROb2RlKTtcbiAgICAgIHJhbmdlLnNldEVuZCh0ZXN0VGV4dE5vZGUsIDMpO1xuXG4gICAgICB2YXIgcmFuZ2UyID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJhbmdlMi5zZWxlY3ROb2RlQ29udGVudHModGVzdFRleHROb2RlKTtcbiAgICAgIHJhbmdlMi5zZXRFbmQodGVzdFRleHROb2RlLCA0KTtcbiAgICAgIHJhbmdlMi5zZXRTdGFydCh0ZXN0VGV4dE5vZGUsIDIpO1xuXG4gICAgICBpZiAocmFuZ2UuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKHJhbmdlLlNUQVJUX1RPX0VORCwgcmFuZ2UyKSA9PSAtMSAmIHJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyhyYW5nZS5FTkRfVE9fU1RBUlQsIHJhbmdlMikgPT0gMSkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSB3cm9uZyB3YXkgcm91bmQsIHNvIGNvcnJlY3QgZm9yIGl0XG5cblxuICAgICAgICByYW5nZVByb3RvLmNvbXBhcmVCb3VuZGFyeVBvaW50cyA9IGZ1bmN0aW9uICh0eXBlLCByYW5nZSkge1xuICAgICAgICAgIHJhbmdlID0gcmFuZ2UubmF0aXZlUmFuZ2UgfHwgcmFuZ2U7XG4gICAgICAgICAgaWYgKHR5cGUgPT0gcmFuZ2UuU1RBUlRfVE9fRU5EKSB7XG4gICAgICAgICAgICB0eXBlID0gcmFuZ2UuRU5EX1RPX1NUQVJUO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSByYW5nZS5FTkRfVE9fU1RBUlQpIHtcbiAgICAgICAgICAgIHR5cGUgPSByYW5nZS5TVEFSVF9UT19FTkQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZVJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyh0eXBlLCByYW5nZSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZVByb3RvLmNvbXBhcmVCb3VuZGFyeVBvaW50cyA9IGZ1bmN0aW9uICh0eXBlLCByYW5nZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZVJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyh0eXBlLCByYW5nZS5uYXRpdmVSYW5nZSB8fCByYW5nZSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAvLyBUZXN0IGZvciBleGlzdGVuY2Ugb2YgY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IGFuZCBkZWxlZ2F0ZSB0byBpdCBpZiBpdCBleGlzdHNcbiAgICAgIGlmIChhcGkudXRpbC5pc0hvc3RNZXRob2QocmFuZ2UsIFwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50XCIpKSB7XG4gICAgICAgIHJhbmdlUHJvdG8uY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50ID0gZnVuY3Rpb24gKGZyYWdtZW50U3RyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlUmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KGZyYWdtZW50U3RyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAgIC8vIENsZWFuIHVwXG4gICAgICBkb20uZ2V0Qm9keShkb2N1bWVudCkucmVtb3ZlQ2hpbGQodGVzdFRleHROb2RlKTtcbiAgICAgIHJhbmdlLmRldGFjaCgpO1xuICAgICAgcmFuZ2UyLmRldGFjaCgpO1xuICAgIH0pKCk7XG5cbiAgICBhcGkuY3JlYXRlTmF0aXZlUmFuZ2UgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgICByZXR1cm4gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChhcGkuZmVhdHVyZXMuaW1wbGVtZW50c1RleHRSYW5nZSkge1xuICAgIC8vIFRoaXMgaXMgYSB3cmFwcGVyIGFyb3VuZCBhIFRleHRSYW5nZSwgcHJvdmlkaW5nIGZ1bGwgRE9NIFJhbmdlIGZ1bmN0aW9uYWxpdHkgdXNpbmcgcmFuZ3kncyBEb21SYW5nZSBhcyBhXG4gICAgLy8gcHJvdG90eXBlXG5cbiAgICBXcmFwcGVkUmFuZ2UgPSBmdW5jdGlvbiBXcmFwcGVkUmFuZ2UodGV4dFJhbmdlKSB7XG4gICAgICB0aGlzLnRleHRSYW5nZSA9IHRleHRSYW5nZTtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH07XG5cbiAgICBXcmFwcGVkUmFuZ2UucHJvdG90eXBlID0gbmV3IERvbVJhbmdlKGRvY3VtZW50KTtcblxuICAgIFdyYXBwZWRSYW5nZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGFydCwgZW5kO1xuXG4gICAgICAvLyBUZXh0UmFuZ2UncyBwYXJlbnRFbGVtZW50KCkgbWV0aG9kIGNhbm5vdCBiZSB0cnVzdGVkLiBnZXRUZXh0UmFuZ2VDb250YWluZXJFbGVtZW50KCkgd29ya3MgYXJvdW5kIHRoYXQuXG4gICAgICB2YXIgcmFuZ2VDb250YWluZXJFbGVtZW50ID0gZ2V0VGV4dFJhbmdlQ29udGFpbmVyRWxlbWVudCh0aGlzLnRleHRSYW5nZSk7XG5cbiAgICAgIGlmICh0ZXh0UmFuZ2VJc0NvbGxhcHNlZCh0aGlzLnRleHRSYW5nZSkpIHtcbiAgICAgICAgZW5kID0gc3RhcnQgPSBnZXRUZXh0UmFuZ2VCb3VuZGFyeVBvc2l0aW9uKHRoaXMudGV4dFJhbmdlLCByYW5nZUNvbnRhaW5lckVsZW1lbnQsIHRydWUsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBzdGFydCA9IGdldFRleHRSYW5nZUJvdW5kYXJ5UG9zaXRpb24odGhpcy50ZXh0UmFuZ2UsIHJhbmdlQ29udGFpbmVyRWxlbWVudCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBlbmQgPSBnZXRUZXh0UmFuZ2VCb3VuZGFyeVBvc2l0aW9uKHRoaXMudGV4dFJhbmdlLCByYW5nZUNvbnRhaW5lckVsZW1lbnQsIGZhbHNlLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhcnQoc3RhcnQubm9kZSwgc3RhcnQub2Zmc2V0KTtcbiAgICAgIHRoaXMuc2V0RW5kKGVuZC5ub2RlLCBlbmQub2Zmc2V0KTtcbiAgICB9O1xuXG4gICAgRG9tUmFuZ2UuY29weUNvbXBhcmlzb25Db25zdGFudHMoV3JhcHBlZFJhbmdlKTtcblxuICAgIC8vIEFkZCBXcmFwcGVkUmFuZ2UgYXMgdGhlIFJhbmdlIHByb3BlcnR5IG9mIHRoZSBnbG9iYWwgb2JqZWN0IHRvIGFsbG93IGV4cHJlc3Npb24gbGlrZSBSYW5nZS5FTkRfVE9fRU5EIHRvIHdvcmtcbiAgICB2YXIgZ2xvYmFsT2JqID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSgpO1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsT2JqLlJhbmdlID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGdsb2JhbE9iai5SYW5nZSA9IFdyYXBwZWRSYW5nZTtcbiAgICB9XG5cbiAgICBhcGkuY3JlYXRlTmF0aXZlUmFuZ2UgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgICByZXR1cm4gZG9jLmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChhcGkuZmVhdHVyZXMuaW1wbGVtZW50c1RleHRSYW5nZSkge1xuICAgIFdyYXBwZWRSYW5nZS5yYW5nZVRvVGV4dFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICBpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIHZhciB0ciA9IGNyZWF0ZUJvdW5kYXJ5VGV4dFJhbmdlKG5ldyBEb21Qb3NpdGlvbihyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gdHI7XG5cbiAgICAgICAgLy9yZXR1cm4gY3JlYXRlQm91bmRhcnlUZXh0UmFuZ2UobmV3IERvbVBvc2l0aW9uKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCksIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHN0YXJ0UmFuZ2UgPSBjcmVhdGVCb3VuZGFyeVRleHRSYW5nZShuZXcgRG9tUG9zaXRpb24ocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSwgdHJ1ZSk7XG4gICAgICAgIHZhciBlbmRSYW5nZSA9IGNyZWF0ZUJvdW5kYXJ5VGV4dFJhbmdlKG5ldyBEb21Qb3NpdGlvbihyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCksIGZhbHNlKTtcbiAgICAgICAgdmFyIHRleHRSYW5nZSA9IGRvbS5nZXREb2N1bWVudChyYW5nZS5zdGFydENvbnRhaW5lcikuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgdGV4dFJhbmdlLnNldEVuZFBvaW50KFwiU3RhcnRUb1N0YXJ0XCIsIHN0YXJ0UmFuZ2UpO1xuICAgICAgICB0ZXh0UmFuZ2Uuc2V0RW5kUG9pbnQoXCJFbmRUb0VuZFwiLCBlbmRSYW5nZSk7XG4gICAgICAgIHJldHVybiB0ZXh0UmFuZ2U7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIFdyYXBwZWRSYW5nZS5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJXcmFwcGVkUmFuZ2VcIjtcbiAgfTtcblxuICBhcGkuV3JhcHBlZFJhbmdlID0gV3JhcHBlZFJhbmdlO1xuXG4gIGFwaS5jcmVhdGVSYW5nZSA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgcmV0dXJuIG5ldyBXcmFwcGVkUmFuZ2UoYXBpLmNyZWF0ZU5hdGl2ZVJhbmdlKGRvYykpO1xuICB9O1xuXG4gIGFwaS5jcmVhdGVSYW5neVJhbmdlID0gZnVuY3Rpb24gKGRvYykge1xuICAgIGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcbiAgICByZXR1cm4gbmV3IERvbVJhbmdlKGRvYyk7XG4gIH07XG5cbiAgYXBpLmNyZWF0ZUlmcmFtZVJhbmdlID0gZnVuY3Rpb24gKGlmcmFtZUVsKSB7XG4gICAgcmV0dXJuIGFwaS5jcmVhdGVSYW5nZShkb20uZ2V0SWZyYW1lRG9jdW1lbnQoaWZyYW1lRWwpKTtcbiAgfTtcblxuICBhcGkuY3JlYXRlSWZyYW1lUmFuZ3lSYW5nZSA9IGZ1bmN0aW9uIChpZnJhbWVFbCkge1xuICAgIHJldHVybiBhcGkuY3JlYXRlUmFuZ3lSYW5nZShkb20uZ2V0SWZyYW1lRG9jdW1lbnQoaWZyYW1lRWwpKTtcbiAgfTtcblxuICBhcGkuYWRkQ3JlYXRlTWlzc2luZ05hdGl2ZUFwaUxpc3RlbmVyKGZ1bmN0aW9uICh3aW4pIHtcbiAgICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuICAgIGlmICh0eXBlb2YgZG9jLmNyZWF0ZVJhbmdlID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRvYy5jcmVhdGVSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFwaS5jcmVhdGVSYW5nZSh0aGlzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGRvYyA9IHdpbiA9IG51bGw7XG4gIH0pO1xufSk7cmFuZ3kuY3JlYXRlTW9kdWxlKFwiV3JhcHBlZFNlbGVjdGlvblwiLCBmdW5jdGlvbiAoYXBpLCBtb2R1bGUpIHtcbiAgLy8gVGhpcyB3aWxsIGNyZWF0ZSBhIHNlbGVjdGlvbiBvYmplY3Qgd3JhcHBlciB0aGF0IGZvbGxvd3MgdGhlIFNlbGVjdGlvbiBvYmplY3QgZm91bmQgaW4gdGhlIFdIQVRXRyBkcmFmdCBET00gUmFuZ2VcbiAgLy8gc3BlYyAoaHR0cDovL2h0bWw1Lm9yZy9zcGVjcy9kb20tcmFuZ2UuaHRtbClcblxuICBhcGkucmVxdWlyZU1vZHVsZXMoW1wiRG9tVXRpbFwiLCBcIkRvbVJhbmdlXCIsIFwiV3JhcHBlZFJhbmdlXCJdKTtcblxuICBhcGkuY29uZmlnLmNoZWNrU2VsZWN0aW9uUmFuZ2VzID0gdHJ1ZTtcblxuICB2YXIgQk9PTEVBTiA9IFwiYm9vbGVhblwiLFxuICAgICAgd2luZG93UHJvcGVydHlOYW1lID0gXCJfcmFuZ3lTZWxlY3Rpb25cIixcbiAgICAgIGRvbSA9IGFwaS5kb20sXG4gICAgICB1dGlsID0gYXBpLnV0aWwsXG4gICAgICBEb21SYW5nZSA9IGFwaS5Eb21SYW5nZSxcbiAgICAgIFdyYXBwZWRSYW5nZSA9IGFwaS5XcmFwcGVkUmFuZ2UsXG4gICAgICBET01FeGNlcHRpb24gPSBhcGkuRE9NRXhjZXB0aW9uLFxuICAgICAgRG9tUG9zaXRpb24gPSBkb20uRG9tUG9zaXRpb24sXG4gICAgICBnZXRTZWxlY3Rpb24sXG4gICAgICBzZWxlY3Rpb25Jc0NvbGxhcHNlZCxcbiAgICAgIENPTlRST0wgPSBcIkNvbnRyb2xcIjtcblxuICBmdW5jdGlvbiBnZXRXaW5TZWxlY3Rpb24od2luUGFyYW0pIHtcbiAgICByZXR1cm4gKHdpblBhcmFtIHx8IHdpbmRvdykuZ2V0U2VsZWN0aW9uKCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREb2NTZWxlY3Rpb24od2luUGFyYW0pIHtcbiAgICByZXR1cm4gKHdpblBhcmFtIHx8IHdpbmRvdykuZG9jdW1lbnQuc2VsZWN0aW9uO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgdGhlIFJhbmdlL1RleHRSYW5nZSBhbmQgU2VsZWN0aW9uIGZlYXR1cmVzIHJlcXVpcmVkXG4gIC8vIFRlc3QgZm9yIGFiaWxpdHkgdG8gcmV0cmlldmUgc2VsZWN0aW9uXG4gIHZhciBpbXBsZW1lbnRzV2luR2V0U2VsZWN0aW9uID0gYXBpLnV0aWwuaXNIb3N0TWV0aG9kKHdpbmRvdywgXCJnZXRTZWxlY3Rpb25cIiksXG4gICAgICBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uID0gYXBpLnV0aWwuaXNIb3N0T2JqZWN0KGRvY3VtZW50LCBcInNlbGVjdGlvblwiKTtcblxuICB2YXIgdXNlRG9jdW1lbnRTZWxlY3Rpb24gPSBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uICYmICghaW1wbGVtZW50c1dpbkdldFNlbGVjdGlvbiB8fCBhcGkuY29uZmlnLnByZWZlclRleHRSYW5nZSk7XG5cbiAgaWYgKHVzZURvY3VtZW50U2VsZWN0aW9uKSB7XG4gICAgZ2V0U2VsZWN0aW9uID0gZ2V0RG9jU2VsZWN0aW9uO1xuICAgIGFwaS5pc1NlbGVjdGlvblZhbGlkID0gZnVuY3Rpb24gKHdpblBhcmFtKSB7XG4gICAgICB2YXIgZG9jID0gKHdpblBhcmFtIHx8IHdpbmRvdykuZG9jdW1lbnQsXG4gICAgICAgICAgbmF0aXZlU2VsID0gZG9jLnNlbGVjdGlvbjtcblxuICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgc2VsZWN0aW9uIFRleHRSYW5nZSBpcyBhY3R1YWxseSBjb250YWluZWQgd2l0aGluIHRoZSBjb3JyZWN0IGRvY3VtZW50XG4gICAgICByZXR1cm4gbmF0aXZlU2VsLnR5cGUgIT0gXCJOb25lXCIgfHwgZG9tLmdldERvY3VtZW50KG5hdGl2ZVNlbC5jcmVhdGVSYW5nZSgpLnBhcmVudEVsZW1lbnQoKSkgPT0gZG9jO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoaW1wbGVtZW50c1dpbkdldFNlbGVjdGlvbikge1xuICAgIGdldFNlbGVjdGlvbiA9IGdldFdpblNlbGVjdGlvbjtcbiAgICBhcGkuaXNTZWxlY3Rpb25WYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmZhaWwoXCJOZWl0aGVyIGRvY3VtZW50LnNlbGVjdGlvbiBvciB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkgZGV0ZWN0ZWQuXCIpO1xuICB9XG5cbiAgYXBpLmdldE5hdGl2ZVNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbjtcblxuICB2YXIgdGVzdFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbigpO1xuICB2YXIgdGVzdFJhbmdlID0gYXBpLmNyZWF0ZU5hdGl2ZVJhbmdlKGRvY3VtZW50KTtcbiAgdmFyIGJvZHkgPSBkb20uZ2V0Qm9keShkb2N1bWVudCk7XG5cbiAgLy8gT2J0YWluaW5nIGEgcmFuZ2UgZnJvbSBhIHNlbGVjdGlvblxuICB2YXIgc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMgPSB1dGlsLmFyZUhvc3RPYmplY3RzKHRlc3RTZWxlY3Rpb24sIFtcImFuY2hvck5vZGVcIiwgXCJmb2N1c05vZGVcIl0gJiYgdXRpbC5hcmVIb3N0UHJvcGVydGllcyh0ZXN0U2VsZWN0aW9uLCBbXCJhbmNob3JPZmZzZXRcIiwgXCJmb2N1c09mZnNldFwiXSkpO1xuICBhcGkuZmVhdHVyZXMuc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cztcblxuICAvLyBUZXN0IGZvciBleGlzdGVuY2Ugb2YgbmF0aXZlIHNlbGVjdGlvbiBleHRlbmQoKSBtZXRob2RcbiAgdmFyIHNlbGVjdGlvbkhhc0V4dGVuZCA9IHV0aWwuaXNIb3N0TWV0aG9kKHRlc3RTZWxlY3Rpb24sIFwiZXh0ZW5kXCIpO1xuICBhcGkuZmVhdHVyZXMuc2VsZWN0aW9uSGFzRXh0ZW5kID0gc2VsZWN0aW9uSGFzRXh0ZW5kO1xuXG4gIC8vIFRlc3QgaWYgcmFuZ2VDb3VudCBleGlzdHNcbiAgdmFyIHNlbGVjdGlvbkhhc1JhbmdlQ291bnQgPSB0eXBlb2YgdGVzdFNlbGVjdGlvbi5yYW5nZUNvdW50ID09IFwibnVtYmVyXCI7XG4gIGFwaS5mZWF0dXJlcy5zZWxlY3Rpb25IYXNSYW5nZUNvdW50ID0gc2VsZWN0aW9uSGFzUmFuZ2VDb3VudDtcblxuICB2YXIgc2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcyA9IGZhbHNlO1xuICB2YXIgY29sbGFwc2VkTm9uRWRpdGFibGVTZWxlY3Rpb25zU3VwcG9ydGVkID0gdHJ1ZTtcblxuICBpZiAodXRpbC5hcmVIb3N0TWV0aG9kcyh0ZXN0U2VsZWN0aW9uLCBbXCJhZGRSYW5nZVwiLCBcImdldFJhbmdlQXRcIiwgXCJyZW1vdmVBbGxSYW5nZXNcIl0pICYmIHR5cGVvZiB0ZXN0U2VsZWN0aW9uLnJhbmdlQ291bnQgPT0gXCJudW1iZXJcIiAmJiBhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlKSB7XG5cbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICBib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgICAgIHZhciBpZnJhbWVEb2MgPSBkb20uZ2V0SWZyYW1lRG9jdW1lbnQoaWZyYW1lKTtcbiAgICAgIGlmcmFtZURvYy5vcGVuKCk7XG4gICAgICBpZnJhbWVEb2Mud3JpdGUoXCI8aHRtbD48aGVhZD48L2hlYWQ+PGJvZHk+MTI8L2JvZHk+PC9odG1sPlwiKTtcbiAgICAgIGlmcmFtZURvYy5jbG9zZSgpO1xuXG4gICAgICB2YXIgc2VsID0gZG9tLmdldElmcmFtZVdpbmRvdyhpZnJhbWUpLmdldFNlbGVjdGlvbigpO1xuICAgICAgdmFyIGRvY0VsID0gaWZyYW1lRG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgIHZhciBpZnJhbWVCb2R5ID0gZG9jRWwubGFzdENoaWxkLFxuICAgICAgICAgIHRleHROb2RlID0gaWZyYW1lQm9keS5maXJzdENoaWxkO1xuXG4gICAgICAvLyBUZXN0IHdoZXRoZXIgdGhlIG5hdGl2ZSBzZWxlY3Rpb24gd2lsbCBhbGxvdyBhIGNvbGxhcHNlZCBzZWxlY3Rpb24gd2l0aGluIGEgbm9uLWVkaXRhYmxlIGVsZW1lbnRcbiAgICAgIHZhciByMSA9IGlmcmFtZURvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgcjEuc2V0U3RhcnQodGV4dE5vZGUsIDEpO1xuICAgICAgcjEuY29sbGFwc2UodHJ1ZSk7XG4gICAgICBzZWwuYWRkUmFuZ2UocjEpO1xuICAgICAgY29sbGFwc2VkTm9uRWRpdGFibGVTZWxlY3Rpb25zU3VwcG9ydGVkID0gc2VsLnJhbmdlQ291bnQgPT0gMTtcbiAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgICAgLy8gVGVzdCB3aGV0aGVyIHRoZSBuYXRpdmUgc2VsZWN0aW9uIGlzIGNhcGFibGUgb2Ygc3VwcG9ydGluZyBtdWx0aXBsZSByYW5nZXNcbiAgICAgIHZhciByMiA9IHIxLmNsb25lUmFuZ2UoKTtcbiAgICAgIHIxLnNldFN0YXJ0KHRleHROb2RlLCAwKTtcbiAgICAgIHIyLnNldEVuZCh0ZXh0Tm9kZSwgMik7XG4gICAgICBzZWwuYWRkUmFuZ2UocjEpO1xuICAgICAgc2VsLmFkZFJhbmdlKHIyKTtcblxuICAgICAgc2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcyA9IHNlbC5yYW5nZUNvdW50ID09IDI7XG5cbiAgICAgIC8vIENsZWFuIHVwXG4gICAgICByMS5kZXRhY2goKTtcbiAgICAgIHIyLmRldGFjaCgpO1xuXG4gICAgICBib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSkoKTtcbiAgfVxuXG4gIGFwaS5mZWF0dXJlcy5zZWxlY3Rpb25TdXBwb3J0c011bHRpcGxlUmFuZ2VzID0gc2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcztcbiAgYXBpLmZlYXR1cmVzLmNvbGxhcHNlZE5vbkVkaXRhYmxlU2VsZWN0aW9uc1N1cHBvcnRlZCA9IGNvbGxhcHNlZE5vbkVkaXRhYmxlU2VsZWN0aW9uc1N1cHBvcnRlZDtcblxuICAvLyBDb250cm9sUmFuZ2VzXG4gIHZhciBpbXBsZW1lbnRzQ29udHJvbFJhbmdlID0gZmFsc2UsXG4gICAgICB0ZXN0Q29udHJvbFJhbmdlO1xuXG4gIGlmIChib2R5ICYmIHV0aWwuaXNIb3N0TWV0aG9kKGJvZHksIFwiY3JlYXRlQ29udHJvbFJhbmdlXCIpKSB7XG4gICAgdGVzdENvbnRyb2xSYW5nZSA9IGJvZHkuY3JlYXRlQ29udHJvbFJhbmdlKCk7XG4gICAgaWYgKHV0aWwuYXJlSG9zdFByb3BlcnRpZXModGVzdENvbnRyb2xSYW5nZSwgW1wiaXRlbVwiLCBcImFkZFwiXSkpIHtcbiAgICAgIGltcGxlbWVudHNDb250cm9sUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0NvbnRyb2xSYW5nZSA9IGltcGxlbWVudHNDb250cm9sUmFuZ2U7XG5cbiAgLy8gU2VsZWN0aW9uIGNvbGxhcHNlZG5lc3NcbiAgaWYgKHNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzKSB7XG4gICAgc2VsZWN0aW9uSXNDb2xsYXBzZWQgPSBmdW5jdGlvbiBzZWxlY3Rpb25Jc0NvbGxhcHNlZChzZWwpIHtcbiAgICAgIHJldHVybiBzZWwuYW5jaG9yTm9kZSA9PT0gc2VsLmZvY3VzTm9kZSAmJiBzZWwuYW5jaG9yT2Zmc2V0ID09PSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzZWxlY3Rpb25Jc0NvbGxhcHNlZCA9IGZ1bmN0aW9uIHNlbGVjdGlvbklzQ29sbGFwc2VkKHNlbCkge1xuICAgICAgcmV0dXJuIHNlbC5yYW5nZUNvdW50ID8gc2VsLmdldFJhbmdlQXQoc2VsLnJhbmdlQ291bnQgLSAxKS5jb2xsYXBzZWQgOiBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tUmFuZ2Uoc2VsLCByYW5nZSwgYmFja3dhcmRzKSB7XG4gICAgdmFyIGFuY2hvclByZWZpeCA9IGJhY2t3YXJkcyA/IFwiZW5kXCIgOiBcInN0YXJ0XCIsXG4gICAgICAgIGZvY3VzUHJlZml4ID0gYmFja3dhcmRzID8gXCJzdGFydFwiIDogXCJlbmRcIjtcbiAgICBzZWwuYW5jaG9yTm9kZSA9IHJhbmdlW2FuY2hvclByZWZpeCArIFwiQ29udGFpbmVyXCJdO1xuICAgIHNlbC5hbmNob3JPZmZzZXQgPSByYW5nZVthbmNob3JQcmVmaXggKyBcIk9mZnNldFwiXTtcbiAgICBzZWwuZm9jdXNOb2RlID0gcmFuZ2VbZm9jdXNQcmVmaXggKyBcIkNvbnRhaW5lclwiXTtcbiAgICBzZWwuZm9jdXNPZmZzZXQgPSByYW5nZVtmb2N1c1ByZWZpeCArIFwiT2Zmc2V0XCJdO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tTmF0aXZlU2VsZWN0aW9uKHNlbCkge1xuICAgIHZhciBuYXRpdmVTZWwgPSBzZWwubmF0aXZlU2VsZWN0aW9uO1xuICAgIHNlbC5hbmNob3JOb2RlID0gbmF0aXZlU2VsLmFuY2hvck5vZGU7XG4gICAgc2VsLmFuY2hvck9mZnNldCA9IG5hdGl2ZVNlbC5hbmNob3JPZmZzZXQ7XG4gICAgc2VsLmZvY3VzTm9kZSA9IG5hdGl2ZVNlbC5mb2N1c05vZGU7XG4gICAgc2VsLmZvY3VzT2Zmc2V0ID0gbmF0aXZlU2VsLmZvY3VzT2Zmc2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKSB7XG4gICAgc2VsLmFuY2hvck5vZGUgPSBzZWwuZm9jdXNOb2RlID0gbnVsbDtcbiAgICBzZWwuYW5jaG9yT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0ID0gMDtcbiAgICBzZWwucmFuZ2VDb3VudCA9IDA7XG4gICAgc2VsLmlzQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICBzZWwuX3Jhbmdlcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmF0aXZlUmFuZ2UocmFuZ2UpIHtcbiAgICB2YXIgbmF0aXZlUmFuZ2U7XG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRG9tUmFuZ2UpIHtcbiAgICAgIG5hdGl2ZVJhbmdlID0gcmFuZ2UuX3NlbGVjdGlvbk5hdGl2ZVJhbmdlO1xuICAgICAgaWYgKCFuYXRpdmVSYW5nZSkge1xuICAgICAgICBuYXRpdmVSYW5nZSA9IGFwaS5jcmVhdGVOYXRpdmVSYW5nZShkb20uZ2V0RG9jdW1lbnQocmFuZ2Uuc3RhcnRDb250YWluZXIpKTtcbiAgICAgICAgbmF0aXZlUmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgbmF0aXZlUmFuZ2Uuc2V0U3RhcnQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgcmFuZ2UuX3NlbGVjdGlvbk5hdGl2ZVJhbmdlID0gbmF0aXZlUmFuZ2U7XG4gICAgICAgIHJhbmdlLmF0dGFjaExpc3RlbmVyKFwiZGV0YWNoXCIsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbk5hdGl2ZVJhbmdlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyYW5nZSBpbnN0YW5jZW9mIFdyYXBwZWRSYW5nZSkge1xuICAgICAgbmF0aXZlUmFuZ2UgPSByYW5nZS5uYXRpdmVSYW5nZTtcbiAgICB9IGVsc2UgaWYgKGFwaS5mZWF0dXJlcy5pbXBsZW1lbnRzRG9tUmFuZ2UgJiYgcmFuZ2UgaW5zdGFuY2VvZiBkb20uZ2V0V2luZG93KHJhbmdlLnN0YXJ0Q29udGFpbmVyKS5SYW5nZSkge1xuICAgICAgbmF0aXZlUmFuZ2UgPSByYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZVJhbmdlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmFuZ2VDb250YWluc1NpbmdsZUVsZW1lbnQocmFuZ2VOb2Rlcykge1xuICAgIGlmICghcmFuZ2VOb2Rlcy5sZW5ndGggfHwgcmFuZ2VOb2Rlc1swXS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSByYW5nZU5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAoIWRvbS5pc0FuY2VzdG9yT2YocmFuZ2VOb2Rlc1swXSwgcmFuZ2VOb2Rlc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNpbmdsZUVsZW1lbnRGcm9tUmFuZ2UocmFuZ2UpIHtcbiAgICB2YXIgbm9kZXMgPSByYW5nZS5nZXROb2RlcygpO1xuICAgIGlmICghcmFuZ2VDb250YWluc1NpbmdsZUVsZW1lbnQobm9kZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlOiByYW5nZSBcIiArIHJhbmdlLmluc3BlY3QoKSArIFwiIGRpZCBub3QgY29uc2lzdCBvZiBhIHNpbmdsZSBlbGVtZW50XCIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNbMF07XG4gIH1cblxuICBmdW5jdGlvbiBpc1RleHRSYW5nZShyYW5nZSkge1xuICAgIHJldHVybiAhIXJhbmdlICYmIHR5cGVvZiByYW5nZS50ZXh0ICE9IFwidW5kZWZpbmVkXCI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcm9tVGV4dFJhbmdlKHNlbCwgcmFuZ2UpIHtcbiAgICAvLyBDcmVhdGUgYSBSYW5nZSBmcm9tIHRoZSBzZWxlY3RlZCBUZXh0UmFuZ2VcbiAgICB2YXIgd3JhcHBlZFJhbmdlID0gbmV3IFdyYXBwZWRSYW5nZShyYW5nZSk7XG4gICAgc2VsLl9yYW5nZXMgPSBbd3JhcHBlZFJhbmdlXTtcblxuICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHNlbCwgd3JhcHBlZFJhbmdlLCBmYWxzZSk7XG4gICAgc2VsLnJhbmdlQ291bnQgPSAxO1xuICAgIHNlbC5pc0NvbGxhcHNlZCA9IHdyYXBwZWRSYW5nZS5jb2xsYXBzZWQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDb250cm9sU2VsZWN0aW9uKHNlbCkge1xuICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlZCBzZWxlY3Rpb24gYmFzZWQgb24gd2hhdCdzIG5vdyBpbiB0aGUgbmF0aXZlIHNlbGVjdGlvblxuICAgIHNlbC5fcmFuZ2VzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHNlbC5kb2NTZWxlY3Rpb24udHlwZSA9PSBcIk5vbmVcIikge1xuICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRyb2xSYW5nZSA9IHNlbC5kb2NTZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIGlmIChpc1RleHRSYW5nZShjb250cm9sUmFuZ2UpKSB7XG4gICAgICAgIC8vIFRoaXMgY2FzZSAod2hlcmUgdGhlIHNlbGVjdGlvbiB0eXBlIGlzIFwiQ29udHJvbFwiIGFuZCBjYWxsaW5nIGNyZWF0ZVJhbmdlKCkgb24gdGhlIHNlbGVjdGlvbiByZXR1cm5zXG4gICAgICAgIC8vIGEgVGV4dFJhbmdlKSBjYW4gaGFwcGVuIGluIElFIDkuIEl0IGhhcHBlbnMsIGZvciBleGFtcGxlLCB3aGVuIGFsbCBlbGVtZW50cyBpbiB0aGUgc2VsZWN0ZWRcbiAgICAgICAgLy8gQ29udHJvbFJhbmdlIGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIENvbnRyb2xSYW5nZSBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgICAgdXBkYXRlRnJvbVRleHRSYW5nZShzZWwsIGNvbnRyb2xSYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWwucmFuZ2VDb3VudCA9IGNvbnRyb2xSYW5nZS5sZW5ndGg7XG4gICAgICAgIHZhciByYW5nZSxcbiAgICAgICAgICAgIGRvYyA9IGRvbS5nZXREb2N1bWVudChjb250cm9sUmFuZ2UuaXRlbSgwKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLnJhbmdlQ291bnQ7ICsraSkge1xuICAgICAgICAgIHJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKGRvYyk7XG4gICAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShjb250cm9sUmFuZ2UuaXRlbShpKSk7XG4gICAgICAgICAgc2VsLl9yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsLmlzQ29sbGFwc2VkID0gc2VsLnJhbmdlQ291bnQgPT0gMSAmJiBzZWwuX3Jhbmdlc1swXS5jb2xsYXBzZWQ7XG4gICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHNlbCwgc2VsLl9yYW5nZXNbc2VsLnJhbmdlQ291bnQgLSAxXSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFJhbmdlVG9Db250cm9sU2VsZWN0aW9uKHNlbCwgcmFuZ2UpIHtcbiAgICB2YXIgY29udHJvbFJhbmdlID0gc2VsLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgIHZhciByYW5nZUVsZW1lbnQgPSBnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlKHJhbmdlKTtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBDb250cm9sUmFuZ2UgY29udGFpbmluZyBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZWxlY3RlZCBDb250cm9sUmFuZ2UgcGx1cyB0aGUgZWxlbWVudFxuICAgIC8vIGNvbnRhaW5lZCBieSB0aGUgc3VwcGxpZWQgcmFuZ2VcbiAgICB2YXIgZG9jID0gZG9tLmdldERvY3VtZW50KGNvbnRyb2xSYW5nZS5pdGVtKDApKTtcbiAgICB2YXIgbmV3Q29udHJvbFJhbmdlID0gZG9tLmdldEJvZHkoZG9jKS5jcmVhdGVDb250cm9sUmFuZ2UoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29udHJvbFJhbmdlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBuZXdDb250cm9sUmFuZ2UuYWRkKGNvbnRyb2xSYW5nZS5pdGVtKGkpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NvbnRyb2xSYW5nZS5hZGQocmFuZ2VFbGVtZW50KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkUmFuZ2UoKTogRWxlbWVudCB3aXRoaW4gdGhlIHNwZWNpZmllZCBSYW5nZSBjb3VsZCBub3QgYmUgYWRkZWQgdG8gY29udHJvbCBzZWxlY3Rpb24gKGRvZXMgaXQgaGF2ZSBsYXlvdXQ/KVwiKTtcbiAgICB9XG4gICAgbmV3Q29udHJvbFJhbmdlLnNlbGVjdCgpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBiYXNlZCBvbiB3aGF0J3Mgbm93IGluIHRoZSBuYXRpdmUgc2VsZWN0aW9uXG4gICAgdXBkYXRlQ29udHJvbFNlbGVjdGlvbihzZWwpO1xuICB9XG5cbiAgdmFyIGdldFNlbGVjdGlvblJhbmdlQXQ7XG5cbiAgaWYgKHV0aWwuaXNIb3N0TWV0aG9kKHRlc3RTZWxlY3Rpb24sIFwiZ2V0UmFuZ2VBdFwiKSkge1xuICAgIGdldFNlbGVjdGlvblJhbmdlQXQgPSBmdW5jdGlvbiBnZXRTZWxlY3Rpb25SYW5nZUF0KHNlbCwgaW5kZXgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZWwuZ2V0UmFuZ2VBdChpbmRleCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzKSB7XG4gICAgZ2V0U2VsZWN0aW9uUmFuZ2VBdCA9IGZ1bmN0aW9uIGdldFNlbGVjdGlvblJhbmdlQXQoc2VsKSB7XG4gICAgICB2YXIgZG9jID0gZG9tLmdldERvY3VtZW50KHNlbC5hbmNob3JOb2RlKTtcbiAgICAgIHZhciByYW5nZSA9IGFwaS5jcmVhdGVSYW5nZShkb2MpO1xuICAgICAgcmFuZ2Uuc2V0U3RhcnQoc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgcmFuZ2Uuc2V0RW5kKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG5cbiAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVuIHRoZSBzZWxlY3Rpb24gd2FzIHNlbGVjdGVkIGJhY2t3YXJkcyAoZnJvbSB0aGUgZW5kIHRvIHRoZSBzdGFydCBpbiB0aGVcbiAgICAgIC8vIGRvY3VtZW50KVxuICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCAhPT0gdGhpcy5pc0NvbGxhcHNlZCkge1xuICAgICAgICByYW5nZS5zZXRTdGFydChzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgICAgICByYW5nZS5zZXRFbmQoc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFdyYXBwZWRTZWxlY3Rpb24oc2VsZWN0aW9uLCBkb2NTZWxlY3Rpb24sIHdpbikge1xuICAgIHRoaXMubmF0aXZlU2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgIHRoaXMuZG9jU2VsZWN0aW9uID0gZG9jU2VsZWN0aW9uO1xuICAgIHRoaXMuX3JhbmdlcyA9IFtdO1xuICAgIHRoaXMud2luID0gd2luO1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICB9XG5cbiAgYXBpLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICh3aW4pIHtcbiAgICB3aW4gPSB3aW4gfHwgd2luZG93O1xuICAgIHZhciBzZWwgPSB3aW5bd2luZG93UHJvcGVydHlOYW1lXTtcbiAgICB2YXIgbmF0aXZlU2VsID0gZ2V0U2VsZWN0aW9uKHdpbiksXG4gICAgICAgIGRvY1NlbCA9IGltcGxlbWVudHNEb2NTZWxlY3Rpb24gPyBnZXREb2NTZWxlY3Rpb24od2luKSA6IG51bGw7XG4gICAgaWYgKHNlbCkge1xuICAgICAgc2VsLm5hdGl2ZVNlbGVjdGlvbiA9IG5hdGl2ZVNlbDtcbiAgICAgIHNlbC5kb2NTZWxlY3Rpb24gPSBkb2NTZWw7XG4gICAgICBzZWwucmVmcmVzaCh3aW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWwgPSBuZXcgV3JhcHBlZFNlbGVjdGlvbihuYXRpdmVTZWwsIGRvY1NlbCwgd2luKTtcbiAgICAgIHdpblt3aW5kb3dQcm9wZXJ0eU5hbWVdID0gc2VsO1xuICAgIH1cbiAgICByZXR1cm4gc2VsO1xuICB9O1xuXG4gIGFwaS5nZXRJZnJhbWVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoaWZyYW1lRWwpIHtcbiAgICByZXR1cm4gYXBpLmdldFNlbGVjdGlvbihkb20uZ2V0SWZyYW1lV2luZG93KGlmcmFtZUVsKSk7XG4gIH07XG5cbiAgdmFyIHNlbFByb3RvID0gV3JhcHBlZFNlbGVjdGlvbi5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29udHJvbFNlbGVjdGlvbihzZWwsIHJhbmdlcykge1xuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBzZWxlY3Rpb24gYmVjb21lcyBvZiB0eXBlIFwiQ29udHJvbFwiXG4gICAgdmFyIGRvYyA9IGRvbS5nZXREb2N1bWVudChyYW5nZXNbMF0uc3RhcnRDb250YWluZXIpO1xuICAgIHZhciBjb250cm9sUmFuZ2UgPSBkb20uZ2V0Qm9keShkb2MpLmNyZWF0ZUNvbnRyb2xSYW5nZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBlbDsgaSA8IHJhbmdlQ291bnQ7ICsraSkge1xuICAgICAgZWwgPSBnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlKHJhbmdlc1tpXSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb250cm9sUmFuZ2UuYWRkKGVsKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldFJhbmdlcygpOiBFbGVtZW50IHdpdGhpbiB0aGUgb25lIG9mIHRoZSBzcGVjaWZpZWQgUmFuZ2VzIGNvdWxkIG5vdCBiZSBhZGRlZCB0byBjb250cm9sIHNlbGVjdGlvbiAoZG9lcyBpdCBoYXZlIGxheW91dD8pXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250cm9sUmFuZ2Uuc2VsZWN0KCk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZWQgc2VsZWN0aW9uIGJhc2VkIG9uIHdoYXQncyBub3cgaW4gdGhlIG5hdGl2ZSBzZWxlY3Rpb25cbiAgICB1cGRhdGVDb250cm9sU2VsZWN0aW9uKHNlbCk7XG4gIH1cblxuICAvLyBTZWxlY3RpbmcgYSByYW5nZVxuICBpZiAoIXVzZURvY3VtZW50U2VsZWN0aW9uICYmIHNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzICYmIHV0aWwuYXJlSG9zdE1ldGhvZHModGVzdFNlbGVjdGlvbiwgW1wicmVtb3ZlQWxsUmFuZ2VzXCIsIFwiYWRkUmFuZ2VcIl0pKSB7XG4gICAgc2VsUHJvdG8ucmVtb3ZlQWxsUmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5uYXRpdmVTZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB1cGRhdGVFbXB0eVNlbGVjdGlvbih0aGlzKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZFJhbmdlQmFja3dhcmRzID0gZnVuY3Rpb24gYWRkUmFuZ2VCYWNrd2FyZHMoc2VsLCByYW5nZSkge1xuICAgICAgdmFyIGRvYyA9IERvbVJhbmdlLmdldFJhbmdlRG9jdW1lbnQocmFuZ2UpO1xuICAgICAgdmFyIGVuZFJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKGRvYyk7XG4gICAgICBlbmRSYW5nZS5jb2xsYXBzZVRvUG9pbnQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgc2VsLm5hdGl2ZVNlbGVjdGlvbi5hZGRSYW5nZShnZXROYXRpdmVSYW5nZShlbmRSYW5nZSkpO1xuICAgICAgc2VsLm5hdGl2ZVNlbGVjdGlvbi5leHRlbmQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgIHNlbC5yZWZyZXNoKCk7XG4gICAgfTtcblxuICAgIGlmIChzZWxlY3Rpb25IYXNSYW5nZUNvdW50KSB7XG4gICAgICBzZWxQcm90by5hZGRSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSwgYmFja3dhcmRzKSB7XG4gICAgICAgIGlmIChpbXBsZW1lbnRzQ29udHJvbFJhbmdlICYmIGltcGxlbWVudHNEb2NTZWxlY3Rpb24gJiYgdGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgICAgYWRkUmFuZ2VUb0NvbnRyb2xTZWxlY3Rpb24odGhpcywgcmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChiYWNrd2FyZHMgJiYgc2VsZWN0aW9uSGFzRXh0ZW5kKSB7XG4gICAgICAgICAgICBhZGRSYW5nZUJhY2t3YXJkcyh0aGlzLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1JhbmdlQ291bnQ7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcykge1xuICAgICAgICAgICAgICBwcmV2aW91c1JhbmdlQ291bnQgPSB0aGlzLnJhbmdlQ291bnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICBwcmV2aW91c1JhbmdlQ291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uYXRpdmVTZWxlY3Rpb24uYWRkUmFuZ2UoZ2V0TmF0aXZlUmFuZ2UocmFuZ2UpKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBhZGRpbmcgdGhlIHJhbmdlIHdhcyBzdWNjZXNzZnVsXG4gICAgICAgICAgICB0aGlzLnJhbmdlQ291bnQgPSB0aGlzLm5hdGl2ZVNlbGVjdGlvbi5yYW5nZUNvdW50O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUNvdW50ID09IHByZXZpb3VzUmFuZ2VDb3VudCArIDEpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIHJhbmdlIHdhcyBhZGRlZCBzdWNjZXNzZnVsbHlcblxuICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSByYW5nZSB0aGF0IHdlIGFkZGVkIHRvIHRoZSBzZWxlY3Rpb24gaXMgcmVmbGVjdGVkIGluIHRoZSBsYXN0IHJhbmdlIGV4dHJhY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgaWYgKGFwaS5jb25maWcuY2hlY2tTZWxlY3Rpb25SYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmF0aXZlUmFuZ2UgPSBnZXRTZWxlY3Rpb25SYW5nZUF0KHRoaXMubmF0aXZlU2VsZWN0aW9uLCB0aGlzLnJhbmdlQ291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAobmF0aXZlUmFuZ2UgJiYgIURvbVJhbmdlLnJhbmdlc0VxdWFsKG5hdGl2ZVJhbmdlLCByYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEhhcHBlbnMgaW4gV2ViS2l0IHdpdGgsIGZvciBleGFtcGxlLCBhIHNlbGVjdGlvbiBwbGFjZWQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBXcmFwcGVkUmFuZ2UobmF0aXZlUmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9yYW5nZXNbdGhpcy5yYW5nZUNvdW50IC0gMV0gPSByYW5nZTtcbiAgICAgICAgICAgICAgdXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tUmFuZ2UodGhpcywgcmFuZ2UsIHNlbGVjdGlvbklzQmFja3dhcmRzKHRoaXMubmF0aXZlU2VsZWN0aW9uKSk7XG4gICAgICAgICAgICAgIHRoaXMuaXNDb2xsYXBzZWQgPSBzZWxlY3Rpb25Jc0NvbGxhcHNlZCh0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFRoZSByYW5nZSB3YXMgbm90IGFkZGVkIHN1Y2Nlc3NmdWxseS4gVGhlIHNpbXBsZXN0IHRoaW5nIGlzIHRvIHJlZnJlc2hcbiAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxQcm90by5hZGRSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSwgYmFja3dhcmRzKSB7XG4gICAgICAgIGlmIChiYWNrd2FyZHMgJiYgc2VsZWN0aW9uSGFzRXh0ZW5kKSB7XG4gICAgICAgICAgYWRkUmFuZ2VCYWNrd2FyZHModGhpcywgcmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubmF0aXZlU2VsZWN0aW9uLmFkZFJhbmdlKGdldE5hdGl2ZVJhbmdlKHJhbmdlKSk7XG4gICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgc2VsUHJvdG8uc2V0UmFuZ2VzID0gZnVuY3Rpb24gKHJhbmdlcykge1xuICAgICAgaWYgKGltcGxlbWVudHNDb250cm9sUmFuZ2UgJiYgcmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY3JlYXRlQ29udHJvbFNlbGVjdGlvbih0aGlzLCByYW5nZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIHRoaXMuYWRkUmFuZ2UocmFuZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAodXRpbC5pc0hvc3RNZXRob2QodGVzdFNlbGVjdGlvbiwgXCJlbXB0eVwiKSAmJiB1dGlsLmlzSG9zdE1ldGhvZCh0ZXN0UmFuZ2UsIFwic2VsZWN0XCIpICYmIGltcGxlbWVudHNDb250cm9sUmFuZ2UgJiYgdXNlRG9jdW1lbnRTZWxlY3Rpb24pIHtcblxuICAgIHNlbFByb3RvLnJlbW92ZUFsbFJhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEFkZGVkIHRyeS9jYXRjaCBhcyBmaXggZm9yIGlzc3VlICMyMVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5kb2NTZWxlY3Rpb24uZW1wdHkoKTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgZW1wdHkoKSBub3Qgd29ya2luZyAoaXNzdWUgIzI0KVxuICAgICAgICBpZiAodGhpcy5kb2NTZWxlY3Rpb24udHlwZSAhPSBcIk5vbmVcIikge1xuICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGZhaWx1cmUgdG8gZW1wdHkgYSBjb250cm9sIHNlbGVjdGlvbiBieSBpbnN0ZWFkIHNlbGVjdGluZyBhIFRleHRSYW5nZSBhbmQgdGhlblxuICAgICAgICAgIC8vIGNhbGxpbmcgZW1wdHkoKVxuICAgICAgICAgIHZhciBkb2M7XG4gICAgICAgICAgaWYgKHRoaXMuYW5jaG9yTm9kZSkge1xuICAgICAgICAgICAgZG9jID0gZG9tLmdldERvY3VtZW50KHRoaXMuYW5jaG9yTm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRvY1NlbGVjdGlvbi50eXBlID09IENPTlRST0wpIHtcbiAgICAgICAgICAgIHZhciBjb250cm9sUmFuZ2UgPSB0aGlzLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xSYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZG9jID0gZG9tLmdldERvY3VtZW50KGNvbnRyb2xSYW5nZS5pdGVtKDApKS5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgICB2YXIgdGV4dFJhbmdlID0gZG9jLmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICB0ZXh0UmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmRvY1NlbGVjdGlvbi5lbXB0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXgpIHt9XG4gICAgICB1cGRhdGVFbXB0eVNlbGVjdGlvbih0aGlzKTtcbiAgICB9O1xuXG4gICAgc2VsUHJvdG8uYWRkUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIGlmICh0aGlzLmRvY1NlbGVjdGlvbi50eXBlID09IENPTlRST0wpIHtcbiAgICAgICAgYWRkUmFuZ2VUb0NvbnRyb2xTZWxlY3Rpb24odGhpcywgcmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgV3JhcHBlZFJhbmdlLnJhbmdlVG9UZXh0UmFuZ2UocmFuZ2UpLnNlbGVjdCgpO1xuICAgICAgICB0aGlzLl9yYW5nZXNbMF0gPSByYW5nZTtcbiAgICAgICAgdGhpcy5yYW5nZUNvdW50ID0gMTtcbiAgICAgICAgdGhpcy5pc0NvbGxhcHNlZCA9IHRoaXMuX3Jhbmdlc1swXS5jb2xsYXBzZWQ7XG4gICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHRoaXMsIHJhbmdlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbFByb3RvLnNldFJhbmdlcyA9IGZ1bmN0aW9uIChyYW5nZXMpIHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB2YXIgcmFuZ2VDb3VudCA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICBpZiAocmFuZ2VDb3VudCA+IDEpIHtcbiAgICAgICAgY3JlYXRlQ29udHJvbFNlbGVjdGlvbih0aGlzLCByYW5nZXMpO1xuICAgICAgfSBlbHNlIGlmIChyYW5nZUNvdW50KSB7XG4gICAgICAgIHRoaXMuYWRkUmFuZ2UocmFuZ2VzWzBdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5mYWlsKFwiTm8gbWVhbnMgb2Ygc2VsZWN0aW5nIGEgUmFuZ2Ugb3IgVGV4dFJhbmdlIHdhcyBmb3VuZFwiKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzZWxQcm90by5nZXRSYW5nZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLnJhbmdlQ291bnQpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTkRFWF9TSVpFX0VSUlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jhbmdlc1tpbmRleF07XG4gICAgfVxuICB9O1xuXG4gIHZhciByZWZyZXNoU2VsZWN0aW9uO1xuXG4gIGlmICh1c2VEb2N1bWVudFNlbGVjdGlvbikge1xuICAgIHJlZnJlc2hTZWxlY3Rpb24gPSBmdW5jdGlvbiByZWZyZXNoU2VsZWN0aW9uKHNlbCkge1xuICAgICAgdmFyIHJhbmdlO1xuICAgICAgaWYgKGFwaS5pc1NlbGVjdGlvblZhbGlkKHNlbC53aW4pKSB7XG4gICAgICAgIHJhbmdlID0gc2VsLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBkb20uZ2V0Qm9keShzZWwud2luLmRvY3VtZW50KS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWwuZG9jU2VsZWN0aW9uLnR5cGUgPT0gQ09OVFJPTCkge1xuICAgICAgICB1cGRhdGVDb250cm9sU2VsZWN0aW9uKHNlbCk7XG4gICAgICB9IGVsc2UgaWYgKGlzVGV4dFJhbmdlKHJhbmdlKSkge1xuICAgICAgICB1cGRhdGVGcm9tVGV4dFJhbmdlKHNlbCwgcmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHV0aWwuaXNIb3N0TWV0aG9kKHRlc3RTZWxlY3Rpb24sIFwiZ2V0UmFuZ2VBdFwiKSAmJiB0eXBlb2YgdGVzdFNlbGVjdGlvbi5yYW5nZUNvdW50ID09IFwibnVtYmVyXCIpIHtcbiAgICByZWZyZXNoU2VsZWN0aW9uID0gZnVuY3Rpb24gcmVmcmVzaFNlbGVjdGlvbihzZWwpIHtcbiAgICAgIGlmIChpbXBsZW1lbnRzQ29udHJvbFJhbmdlICYmIGltcGxlbWVudHNEb2NTZWxlY3Rpb24gJiYgc2VsLmRvY1NlbGVjdGlvbi50eXBlID09IENPTlRST0wpIHtcbiAgICAgICAgdXBkYXRlQ29udHJvbFNlbGVjdGlvbihzZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsLl9yYW5nZXMubGVuZ3RoID0gc2VsLnJhbmdlQ291bnQgPSBzZWwubmF0aXZlU2VsZWN0aW9uLnJhbmdlQ291bnQ7XG4gICAgICAgIGlmIChzZWwucmFuZ2VDb3VudCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWwucmFuZ2VDb3VudDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBzZWwuX3Jhbmdlc1tpXSA9IG5ldyBhcGkuV3JhcHBlZFJhbmdlKHNlbC5uYXRpdmVTZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHNlbCwgc2VsLl9yYW5nZXNbc2VsLnJhbmdlQ291bnQgLSAxXSwgc2VsZWN0aW9uSXNCYWNrd2FyZHMoc2VsLm5hdGl2ZVNlbGVjdGlvbikpO1xuICAgICAgICAgIHNlbC5pc0NvbGxhcHNlZCA9IHNlbGVjdGlvbklzQ29sbGFwc2VkKHNlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAoc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMgJiYgX3R5cGVvZih0ZXN0U2VsZWN0aW9uLmlzQ29sbGFwc2VkKSA9PSBCT09MRUFOICYmIF90eXBlb2YodGVzdFJhbmdlLmNvbGxhcHNlZCkgPT0gQk9PTEVBTiAmJiBhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlKSB7XG4gICAgcmVmcmVzaFNlbGVjdGlvbiA9IGZ1bmN0aW9uIHJlZnJlc2hTZWxlY3Rpb24oc2VsKSB7XG4gICAgICB2YXIgcmFuZ2UsXG4gICAgICAgICAgbmF0aXZlU2VsID0gc2VsLm5hdGl2ZVNlbGVjdGlvbjtcbiAgICAgIGlmIChuYXRpdmVTZWwuYW5jaG9yTm9kZSkge1xuICAgICAgICByYW5nZSA9IGdldFNlbGVjdGlvblJhbmdlQXQobmF0aXZlU2VsLCAwKTtcbiAgICAgICAgc2VsLl9yYW5nZXMgPSBbcmFuZ2VdO1xuICAgICAgICBzZWwucmFuZ2VDb3VudCA9IDE7XG4gICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbU5hdGl2ZVNlbGVjdGlvbihzZWwpO1xuICAgICAgICBzZWwuaXNDb2xsYXBzZWQgPSBzZWxlY3Rpb25Jc0NvbGxhcHNlZChzZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5mYWlsKFwiTm8gbWVhbnMgb2Ygb2J0YWluaW5nIGEgUmFuZ2Ugb3IgVGV4dFJhbmdlIGZyb20gdGhlIHVzZXIncyBzZWxlY3Rpb24gd2FzIGZvdW5kXCIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHNlbFByb3RvLnJlZnJlc2ggPSBmdW5jdGlvbiAoY2hlY2tGb3JDaGFuZ2VzKSB7XG4gICAgdmFyIG9sZFJhbmdlcyA9IGNoZWNrRm9yQ2hhbmdlcyA/IHRoaXMuX3Jhbmdlcy5zbGljZSgwKSA6IG51bGw7XG4gICAgcmVmcmVzaFNlbGVjdGlvbih0aGlzKTtcbiAgICBpZiAoY2hlY2tGb3JDaGFuZ2VzKSB7XG4gICAgICB2YXIgaSA9IG9sZFJhbmdlcy5sZW5ndGg7XG4gICAgICBpZiAoaSAhPSB0aGlzLl9yYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKCFEb21SYW5nZS5yYW5nZXNFcXVhbChvbGRSYW5nZXNbaV0sIHRoaXMuX3Jhbmdlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZW1vdmFsIG9mIGEgc2luZ2xlIHJhbmdlXG4gIHZhciByZW1vdmVSYW5nZU1hbnVhbGx5ID0gZnVuY3Rpb24gcmVtb3ZlUmFuZ2VNYW51YWxseShzZWwsIHJhbmdlKSB7XG4gICAgdmFyIHJhbmdlcyA9IHNlbC5nZXRBbGxSYW5nZXMoKSxcbiAgICAgICAgcmVtb3ZlZCA9IGZhbHNlO1xuICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAocmVtb3ZlZCB8fCByYW5nZSAhPT0gcmFuZ2VzW2ldKSB7XG4gICAgICAgIHNlbC5hZGRSYW5nZShyYW5nZXNbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBkcmFmdCBXSEFUV0cgUmFuZ2Ugc3BlYywgdGhlIHNhbWUgcmFuZ2UgbWF5IGJlIGFkZGVkIHRvIHRoZSBzZWxlY3Rpb24gbXVsdGlwbGVcbiAgICAgICAgLy8gdGltZXMuIHJlbW92ZVJhbmdlIHNob3VsZCBvbmx5IHJlbW92ZSB0aGUgZmlyc3QgaW5zdGFuY2UsIHNvIHRoZSBmb2xsb3dpbmcgZW5zdXJlcyBvbmx5IHRoZSBmaXJzdFxuICAgICAgICAvLyBpbnN0YW5jZSBpcyByZW1vdmVkXG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXNlbC5yYW5nZUNvdW50KSB7XG4gICAgICB1cGRhdGVFbXB0eVNlbGVjdGlvbihzZWwpO1xuICAgIH1cbiAgfTtcblxuICBpZiAoaW1wbGVtZW50c0NvbnRyb2xSYW5nZSkge1xuICAgIHNlbFByb3RvLnJlbW92ZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICBpZiAodGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgIHZhciBjb250cm9sUmFuZ2UgPSB0aGlzLmRvY1NlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICB2YXIgcmFuZ2VFbGVtZW50ID0gZ2V0U2luZ2xlRWxlbWVudEZyb21SYW5nZShyYW5nZSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IENvbnRyb2xSYW5nZSBjb250YWluaW5nIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIHNlbGVjdGVkIENvbnRyb2xSYW5nZSBtaW51cyB0aGVcbiAgICAgICAgLy8gZWxlbWVudCBjb250YWluZWQgYnkgdGhlIHN1cHBsaWVkIHJhbmdlXG4gICAgICAgIHZhciBkb2MgPSBkb20uZ2V0RG9jdW1lbnQoY29udHJvbFJhbmdlLml0ZW0oMCkpO1xuICAgICAgICB2YXIgbmV3Q29udHJvbFJhbmdlID0gZG9tLmdldEJvZHkoZG9jKS5jcmVhdGVDb250cm9sUmFuZ2UoKTtcbiAgICAgICAgdmFyIGVsLFxuICAgICAgICAgICAgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29udHJvbFJhbmdlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgZWwgPSBjb250cm9sUmFuZ2UuaXRlbShpKTtcbiAgICAgICAgICBpZiAoZWwgIT09IHJhbmdlRWxlbWVudCB8fCByZW1vdmVkKSB7XG4gICAgICAgICAgICBuZXdDb250cm9sUmFuZ2UuYWRkKGNvbnRyb2xSYW5nZS5pdGVtKGkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld0NvbnRyb2xSYW5nZS5zZWxlY3QoKTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZWQgc2VsZWN0aW9uIGJhc2VkIG9uIHdoYXQncyBub3cgaW4gdGhlIG5hdGl2ZSBzZWxlY3Rpb25cbiAgICAgICAgdXBkYXRlQ29udHJvbFNlbGVjdGlvbih0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZVJhbmdlTWFudWFsbHkodGhpcywgcmFuZ2UpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc2VsUHJvdG8ucmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHJlbW92ZVJhbmdlTWFudWFsbHkodGhpcywgcmFuZ2UpO1xuICAgIH07XG4gIH1cblxuICAvLyBEZXRlY3RpbmcgaWYgYSBzZWxlY3Rpb24gaXMgYmFja3dhcmRzXG4gIHZhciBzZWxlY3Rpb25Jc0JhY2t3YXJkcztcbiAgaWYgKCF1c2VEb2N1bWVudFNlbGVjdGlvbiAmJiBzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cyAmJiBhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlKSB7XG4gICAgc2VsZWN0aW9uSXNCYWNrd2FyZHMgPSBmdW5jdGlvbiBzZWxlY3Rpb25Jc0JhY2t3YXJkcyhzZWwpIHtcbiAgICAgIHZhciBiYWNrd2FyZHMgPSBmYWxzZTtcbiAgICAgIGlmIChzZWwuYW5jaG9yTm9kZSkge1xuICAgICAgICBiYWNrd2FyZHMgPSBkb20uY29tcGFyZVBvaW50cyhzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCwgc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KSA9PSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhY2t3YXJkcztcbiAgICB9O1xuXG4gICAgc2VsUHJvdG8uaXNCYWNrd2FyZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uSXNCYWNrd2FyZHModGhpcyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzZWxlY3Rpb25Jc0JhY2t3YXJkcyA9IHNlbFByb3RvLmlzQmFja3dhcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBTZWxlY3Rpb24gdGV4dFxuICAvLyBUaGlzIGlzIGNvbmZvcm1hbnQgdG8gdGhlIG5ldyBXSEFUV0cgRE9NIFJhbmdlIGRyYWZ0IHNwZWMgYnV0IGRpZmZlcnMgZnJvbSBXZWJLaXQgYW5kIE1vemlsbGEncyBpbXBsZW1lbnRhdGlvblxuICBzZWxQcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciByYW5nZVRleHRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucmFuZ2VDb3VudDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICByYW5nZVRleHRzW2ldID0gXCJcIiArIHRoaXMuX3Jhbmdlc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlVGV4dHMuam9pbihcIlwiKTtcbiAgfTtcblxuICBmdW5jdGlvbiBhc3NlcnROb2RlSW5TYW1lRG9jdW1lbnQoc2VsLCBub2RlKSB7XG4gICAgaWYgKHNlbC5hbmNob3JOb2RlICYmIGRvbS5nZXREb2N1bWVudChzZWwuYW5jaG9yTm9kZSkgIT09IGRvbS5nZXREb2N1bWVudChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIldST05HX0RPQ1VNRU5UX0VSUlwiKTtcbiAgICB9XG4gIH1cblxuICAvLyBObyBjdXJyZW50IGJyb3dzZXJzIGNvbmZvcm0gZnVsbHkgdG8gdGhlIEhUTUwgNSBkcmFmdCBzcGVjIGZvciB0aGlzIG1ldGhvZCwgc28gUmFuZ3kncyBvd24gbWV0aG9kIGlzIGFsd2F5cyB1c2VkXG4gIHNlbFByb3RvLmNvbGxhcHNlID0gZnVuY3Rpb24gKG5vZGUsIG9mZnNldCkge1xuICAgIGFzc2VydE5vZGVJblNhbWVEb2N1bWVudCh0aGlzLCBub2RlKTtcbiAgICB2YXIgcmFuZ2UgPSBhcGkuY3JlYXRlUmFuZ2UoZG9tLmdldERvY3VtZW50KG5vZGUpKTtcbiAgICByYW5nZS5jb2xsYXBzZVRvUG9pbnQobm9kZSwgb2Zmc2V0KTtcbiAgICB0aGlzLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHRoaXMuYWRkUmFuZ2UocmFuZ2UpO1xuICAgIHRoaXMuaXNDb2xsYXBzZWQgPSB0cnVlO1xuICB9O1xuXG4gIHNlbFByb3RvLmNvbGxhcHNlVG9TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yYW5nZUNvdW50KSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZXNbMF07XG4gICAgICB0aGlzLmNvbGxhcHNlKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTlZBTElEX1NUQVRFX0VSUlwiKTtcbiAgICB9XG4gIH07XG5cbiAgc2VsUHJvdG8uY29sbGFwc2VUb0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yYW5nZUNvdW50KSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZXNbdGhpcy5yYW5nZUNvdW50IC0gMV07XG4gICAgICB0aGlzLmNvbGxhcHNlKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIklOVkFMSURfU1RBVEVfRVJSXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGUgSFRNTCA1IHNwZWMgaXMgdmVyeSBzcGVjaWZpYyBvbiBob3cgc2VsZWN0QWxsQ2hpbGRyZW4gc2hvdWxkIGJlIGltcGxlbWVudGVkIHNvIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXNcbiAgLy8gbmV2ZXIgdXNlZCBieSBSYW5neS5cbiAgc2VsUHJvdG8uc2VsZWN0QWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGFzc2VydE5vZGVJblNhbWVEb2N1bWVudCh0aGlzLCBub2RlKTtcbiAgICB2YXIgcmFuZ2UgPSBhcGkuY3JlYXRlUmFuZ2UoZG9tLmdldERvY3VtZW50KG5vZGUpKTtcbiAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG4gICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB0aGlzLmFkZFJhbmdlKHJhbmdlKTtcbiAgfTtcblxuICBzZWxQcm90by5kZWxldGVGcm9tRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2VwY2lhbCBiZWhhdmlvdXIgcmVxdWlyZWQgZm9yIENvbnRyb2wgc2VsZWN0aW9uc1xuICAgIGlmIChpbXBsZW1lbnRzQ29udHJvbFJhbmdlICYmIGltcGxlbWVudHNEb2NTZWxlY3Rpb24gJiYgdGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICB2YXIgY29udHJvbFJhbmdlID0gdGhpcy5kb2NTZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHZhciBlbGVtZW50O1xuICAgICAgd2hpbGUgKGNvbnRyb2xSYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgZWxlbWVudCA9IGNvbnRyb2xSYW5nZS5pdGVtKDApO1xuICAgICAgICBjb250cm9sUmFuZ2UucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmFuZ2VDb3VudCkge1xuICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuZ2V0QWxsUmFuZ2VzKCk7XG4gICAgICB0aGlzLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICByYW5nZXNbaV0uZGVsZXRlQ29udGVudHMoKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBIVE1MNSBzcGVjIHNheXMgbm90aGluZyBhYm91dCB3aGF0IHRoZSBzZWxlY3Rpb24gc2hvdWxkIGNvbnRhaW4gYWZ0ZXIgY2FsbGluZyBkZWxldGVDb250ZW50cyBvbiBlYWNoXG4gICAgICAvLyByYW5nZS4gRmlyZWZveCBtb3ZlcyB0aGUgc2VsZWN0aW9uIHRvIHdoZXJlIHRoZSBmaW5hbCBzZWxlY3RlZCByYW5nZSB3YXMsIHNvIHdlIGVtdWxhdGUgdGhhdFxuICAgICAgdGhpcy5hZGRSYW5nZShyYW5nZXNbbGVuIC0gMV0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGUgZm9sbG93aW5nIGFyZSBub24tc3RhbmRhcmQgZXh0ZW5zaW9uc1xuICBzZWxQcm90by5nZXRBbGxSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jhbmdlcy5zbGljZSgwKTtcbiAgfTtcblxuICBzZWxQcm90by5zZXRTaW5nbGVSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIHRoaXMuc2V0UmFuZ2VzKFtyYW5nZV0pO1xuICB9O1xuXG4gIHNlbFByb3RvLmNvbnRhaW5zTm9kZSA9IGZ1bmN0aW9uIChub2RlLCBhbGxvd1BhcnRpYWwpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAodGhpcy5fcmFuZ2VzW2ldLmNvbnRhaW5zTm9kZShub2RlLCBhbGxvd1BhcnRpYWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgc2VsUHJvdG8udG9IdG1sID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBodG1sID0gXCJcIjtcbiAgICBpZiAodGhpcy5yYW5nZUNvdW50KSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gRG9tUmFuZ2UuZ2V0UmFuZ2VEb2N1bWVudCh0aGlzLl9yYW5nZXNbMF0pLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcmFuZ2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yYW5nZXNbaV0uY2xvbmVDb250ZW50cygpKTtcbiAgICAgIH1cbiAgICAgIGh0bWwgPSBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcblxuICBmdW5jdGlvbiBpbnNwZWN0KHNlbCkge1xuICAgIHZhciByYW5nZUluc3BlY3RzID0gW107XG4gICAgdmFyIGFuY2hvciA9IG5ldyBEb21Qb3NpdGlvbihzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XG4gICAgdmFyIGZvY3VzID0gbmV3IERvbVBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgdmFyIG5hbWUgPSB0eXBlb2Ygc2VsLmdldE5hbWUgPT0gXCJmdW5jdGlvblwiID8gc2VsLmdldE5hbWUoKSA6IFwiU2VsZWN0aW9uXCI7XG5cbiAgICBpZiAodHlwZW9mIHNlbC5yYW5nZUNvdW50ICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWwucmFuZ2VDb3VudDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHJhbmdlSW5zcGVjdHNbaV0gPSBEb21SYW5nZS5pbnNwZWN0KHNlbC5nZXRSYW5nZUF0KGkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiW1wiICsgbmFtZSArIFwiKFJhbmdlczogXCIgKyByYW5nZUluc3BlY3RzLmpvaW4oXCIsIFwiKSArIFwiKShhbmNob3I6IFwiICsgYW5jaG9yLmluc3BlY3QoKSArIFwiLCBmb2N1czogXCIgKyBmb2N1cy5pbnNwZWN0KCkgKyBcIl1cIjtcbiAgfVxuXG4gIHNlbFByb3RvLmdldE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiV3JhcHBlZFNlbGVjdGlvblwiO1xuICB9O1xuXG4gIHNlbFByb3RvLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGluc3BlY3QodGhpcyk7XG4gIH07XG5cbiAgc2VsUHJvdG8uZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMud2luW3dpbmRvd1Byb3BlcnR5TmFtZV0gPSBudWxsO1xuICAgIHRoaXMud2luID0gdGhpcy5hbmNob3JOb2RlID0gdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICB9O1xuXG4gIFdyYXBwZWRTZWxlY3Rpb24uaW5zcGVjdCA9IGluc3BlY3Q7XG5cbiAgYXBpLlNlbGVjdGlvbiA9IFdyYXBwZWRTZWxlY3Rpb247XG5cbiAgYXBpLnNlbGVjdGlvblByb3RvdHlwZSA9IHNlbFByb3RvO1xuXG4gIGFwaS5hZGRDcmVhdGVNaXNzaW5nTmF0aXZlQXBpTGlzdGVuZXIoZnVuY3Rpb24gKHdpbikge1xuICAgIGlmICh0eXBlb2Ygd2luLmdldFNlbGVjdGlvbiA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW4uZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXBpLmdldFNlbGVjdGlvbih0aGlzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHdpbiA9IG51bGw7XG4gIH0pO1xufSk7XG4vKlxuXHRCYXNlLmpzLCB2ZXJzaW9uIDEuMWFcblx0Q29weXJpZ2h0IDIwMDYtMjAxMCwgRGVhbiBFZHdhcmRzXG5cdExpY2Vuc2U6IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4qL1xuXG52YXIgQmFzZSA9IGZ1bmN0aW9uIEJhc2UoKSB7XG4gIC8vIGR1bW15XG59O1xuXG5CYXNlLmV4dGVuZCA9IGZ1bmN0aW9uIChfaW5zdGFuY2UsIF9zdGF0aWMpIHtcbiAgLy8gc3ViY2xhc3NcbiAgdmFyIGV4dGVuZCA9IEJhc2UucHJvdG90eXBlLmV4dGVuZDtcblxuICAvLyBidWlsZCB0aGUgcHJvdG90eXBlXG4gIEJhc2UuX3Byb3RvdHlwaW5nID0gdHJ1ZTtcbiAgdmFyIHByb3RvID0gbmV3IHRoaXMoKTtcbiAgZXh0ZW5kLmNhbGwocHJvdG8sIF9pbnN0YW5jZSk7XG4gIHByb3RvLmJhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY2FsbCB0aGlzIG1ldGhvZCBmcm9tIGFueSBvdGhlciBtZXRob2QgdG8gaW52b2tlIHRoYXQgbWV0aG9kJ3MgYW5jZXN0b3JcbiAgfTtcbiAgZGVsZXRlIEJhc2UuX3Byb3RvdHlwaW5nO1xuXG4gIC8vIGNyZWF0ZSB0aGUgd3JhcHBlciBmb3IgdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gIC8vdmFyIGNvbnN0cnVjdG9yID0gcHJvdG8uY29uc3RydWN0b3IudmFsdWVPZigpOyAvLy1kZWFuXG4gIHZhciBjb25zdHJ1Y3RvciA9IHByb3RvLmNvbnN0cnVjdG9yO1xuICB2YXIga2xhc3MgPSBwcm90by5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJhc2UuX3Byb3RvdHlwaW5nKSB7XG4gICAgICBpZiAodGhpcy5fY29uc3RydWN0aW5nIHx8IHRoaXMuY29uc3RydWN0b3IgPT0ga2xhc3MpIHtcbiAgICAgICAgLy8gaW5zdGFudGlhdGlvblxuICAgICAgICB0aGlzLl9jb25zdHJ1Y3RpbmcgPSB0cnVlO1xuICAgICAgICBjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBkZWxldGUgdGhpcy5fY29uc3RydWN0aW5nO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gIT0gbnVsbCkge1xuICAgICAgICAvLyBjYXN0aW5nXG4gICAgICAgIHJldHVybiAoYXJndW1lbnRzWzBdLmV4dGVuZCB8fCBleHRlbmQpLmNhbGwoYXJndW1lbnRzWzBdLCBwcm90byk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGJ1aWxkIHRoZSBjbGFzcyBpbnRlcmZhY2VcbiAga2xhc3MuYW5jZXN0b3IgPSB0aGlzO1xuICBrbGFzcy5leHRlbmQgPSB0aGlzLmV4dGVuZDtcbiAga2xhc3MuZm9yRWFjaCA9IHRoaXMuZm9yRWFjaDtcbiAga2xhc3MuaW1wbGVtZW50ID0gdGhpcy5pbXBsZW1lbnQ7XG4gIGtsYXNzLnByb3RvdHlwZSA9IHByb3RvO1xuICBrbGFzcy50b1N0cmluZyA9IHRoaXMudG9TdHJpbmc7XG4gIGtsYXNzLnZhbHVlT2YgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIC8vcmV0dXJuICh0eXBlID09IFwib2JqZWN0XCIpID8ga2xhc3MgOiBjb25zdHJ1Y3RvcjsgLy8tZGVhblxuICAgIHJldHVybiB0eXBlID09IFwib2JqZWN0XCIgPyBrbGFzcyA6IGNvbnN0cnVjdG9yLnZhbHVlT2YoKTtcbiAgfTtcbiAgZXh0ZW5kLmNhbGwoa2xhc3MsIF9zdGF0aWMpO1xuICAvLyBjbGFzcyBpbml0aWFsaXNhdGlvblxuICBpZiAodHlwZW9mIGtsYXNzLmluaXQgPT0gXCJmdW5jdGlvblwiKSBrbGFzcy5pbml0KCk7XG4gIHJldHVybiBrbGFzcztcbn07XG5cbkJhc2UucHJvdG90eXBlID0ge1xuICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChzb3VyY2UsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBleHRlbmRpbmcgd2l0aCBhIG5hbWUvdmFsdWUgcGFpclxuICAgICAgdmFyIGFuY2VzdG9yID0gdGhpc1tzb3VyY2VdO1xuICAgICAgaWYgKGFuY2VzdG9yICYmIHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIgJiYgKCAvLyBvdmVycmlkaW5nIGEgbWV0aG9kP1xuICAgICAgLy8gdGhlIHZhbHVlT2YoKSBjb21wYXJpc29uIGlzIHRvIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgICFhbmNlc3Rvci52YWx1ZU9mIHx8IGFuY2VzdG9yLnZhbHVlT2YoKSAhPSB2YWx1ZS52YWx1ZU9mKCkpICYmIC9cXGJiYXNlXFxiLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAvLyBnZXQgdGhlIHVuZGVybHlpbmcgbWV0aG9kXG4gICAgICAgIHZhciBtZXRob2QgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgIC8vIG92ZXJyaWRlXG4gICAgICAgIHZhbHVlID0gZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5iYXNlIHx8IEJhc2UucHJvdG90eXBlLmJhc2U7XG4gICAgICAgICAgdGhpcy5iYXNlID0gYW5jZXN0b3I7XG4gICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdGhpcy5iYXNlID0gcHJldmlvdXM7XG4gICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBwb2ludCB0byB0aGUgdW5kZXJseWluZyBtZXRob2RcbiAgICAgICAgdmFsdWUudmFsdWVPZiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGUgPT0gXCJvYmplY3RcIiA/IHZhbHVlIDogbWV0aG9kO1xuICAgICAgICB9O1xuICAgICAgICB2YWx1ZS50b1N0cmluZyA9IEJhc2UudG9TdHJpbmc7XG4gICAgICB9XG4gICAgICB0aGlzW3NvdXJjZV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZSkge1xuICAgICAgLy8gZXh0ZW5kaW5nIHdpdGggYW4gb2JqZWN0IGxpdGVyYWxcbiAgICAgIHZhciBleHRlbmQgPSBCYXNlLnByb3RvdHlwZS5leHRlbmQ7XG4gICAgICAvLyBpZiB0aGlzIG9iamVjdCBoYXMgYSBjdXN0b21pc2VkIGV4dGVuZCBtZXRob2QgdGhlbiB1c2UgaXRcbiAgICAgIGlmICghQmFzZS5fcHJvdG90eXBpbmcgJiYgdHlwZW9mIHRoaXMgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGV4dGVuZCA9IHRoaXMuZXh0ZW5kIHx8IGV4dGVuZDtcbiAgICAgIH1cbiAgICAgIHZhciBwcm90byA9IHsgdG9Tb3VyY2U6IG51bGwgfTtcbiAgICAgIC8vIGRvIHRoZSBcInRvU3RyaW5nXCIgYW5kIG90aGVyIG1ldGhvZHMgbWFudWFsbHlcbiAgICAgIHZhciBoaWRkZW4gPSBbXCJjb25zdHJ1Y3RvclwiLCBcInRvU3RyaW5nXCIsIFwidmFsdWVPZlwiXTtcbiAgICAgIC8vIGlmIHdlIGFyZSBwcm90b3R5cGluZyB0aGVuIGluY2x1ZGUgdGhlIGNvbnN0cnVjdG9yXG4gICAgICB2YXIgaSA9IEJhc2UuX3Byb3RvdHlwaW5nID8gMCA6IDE7XG4gICAgICB3aGlsZSAoa2V5ID0gaGlkZGVuW2krK10pIHtcbiAgICAgICAgaWYgKHNvdXJjZVtrZXldICE9IHByb3RvW2tleV0pIHtcbiAgICAgICAgICBleHRlbmQuY2FsbCh0aGlzLCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29weSBlYWNoIG9mIHRoZSBzb3VyY2Ugb2JqZWN0J3MgcHJvcGVydGllcyB0byB0aGlzIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoIXByb3RvW2tleV0pIGV4dGVuZC5jYWxsKHRoaXMsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuLy8gaW5pdGlhbGlzZVxuQmFzZSA9IEJhc2UuZXh0ZW5kKHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZXh0ZW5kKGFyZ3VtZW50c1swXSk7XG4gIH1cbn0sIHtcbiAgYW5jZXN0b3I6IE9iamVjdCxcbiAgdmVyc2lvbjogXCIxLjFcIixcblxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKG9iamVjdCwgYmxvY2ssIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAodGhpcy5wcm90b3R5cGVba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJsb2NrLmNhbGwoY29udGV4dCwgb2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaW1wbGVtZW50OiBmdW5jdGlvbiBpbXBsZW1lbnQoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBpZiBpdCdzIGEgZnVuY3Rpb24sIGNhbGwgaXRcbiAgICAgICAgYXJndW1lbnRzW2ldKHRoaXMucHJvdG90eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFkZCB0aGUgaW50ZXJmYWNlIHVzaW5nIHRoZSBleHRlbmQgbWV0aG9kXG4gICAgICAgIHRoaXMucHJvdG90eXBlLmV4dGVuZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlT2YoKSk7XG4gIH1cbn0pOyAvKipcbiAgICAqIERldGVjdCBicm93c2VyIHN1cHBvcnQgZm9yIHNwZWNpZmljIGZlYXR1cmVzXG4gICAgKi9cbnd5c2lodG1sNS5icm93c2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblxuICAvLyBCcm93c2VyIHNuaWZmaW5nIGlzIHVuZm9ydHVuYXRlbHkgbmVlZGVkIHNpbmNlIHNvbWUgYmVoYXZpb3JzIGFyZSBpbXBvc3NpYmxlIHRvIGZlYXR1cmUgZGV0ZWN0XG4gIGlzSUUgPSB1c2VyQWdlbnQuaW5kZXhPZihcIk1TSUVcIikgIT09IC0xICYmIHVzZXJBZ2VudC5pbmRleE9mKFwiT3BlcmFcIikgPT09IC0xLFxuICAgICAgaXNHZWNrbyA9IHVzZXJBZ2VudC5pbmRleE9mKFwiR2Vja29cIikgIT09IC0xICYmIHVzZXJBZ2VudC5pbmRleE9mKFwiS0hUTUxcIikgPT09IC0xLFxuICAgICAgaXNXZWJLaXQgPSB1c2VyQWdlbnQuaW5kZXhPZihcIkFwcGxlV2ViS2l0L1wiKSAhPT0gLTEsXG4gICAgICBpc0Nocm9tZSA9IHVzZXJBZ2VudC5pbmRleE9mKFwiQ2hyb21lL1wiKSAhPT0gLTEsXG4gICAgICBpc09wZXJhID0gdXNlckFnZW50LmluZGV4T2YoXCJPcGVyYS9cIikgIT09IC0xO1xuXG4gIGZ1bmN0aW9uIGlvc1ZlcnNpb24odXNlckFnZW50KSB7XG4gICAgcmV0dXJuICgvaXBhZHxpcGhvbmV8aXBvZC8udGVzdCh1c2VyQWdlbnQpICYmIHVzZXJBZ2VudC5tYXRjaCgvIG9zIChcXGQrKS4rPyBsaWtlIG1hYyBvcyB4LykgfHwgWywgMF0pWzFdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBTdGF0aWMgdmFyaWFibGUgbmVlZGVkLCBwdWJsaWNseSBhY2Nlc3NpYmxlLCB0byBiZSBhYmxlIG92ZXJyaWRlIGl0IGluIHVuaXQgdGVzdHNcbiAgICBVU0VSX0FHRU5UOiB1c2VyQWdlbnQsXG5cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlIGJyb3dzZXJzIHRoYXQgYXJlIG5vdCBjYXBhYmxlIG9mIGRpc3BsYXlpbmcgYW5kIGhhbmRsaW5nXG4gICAgICogY29udGVudEVkaXRhYmxlIGFzIGRlc2lyZWQ6XG4gICAgICogICAgLSBpUGhvbmUsIGlQYWQgKHRlc3RlZCBpT1MgNC4yLjIpIGFuZCBBbmRyb2lkICh0ZXN0ZWQgMi4yKSByZWZ1c2UgdG8gbWFrZSBjb250ZW50RWRpdGFibGVzIGZvY3VzYWJsZVxuICAgICAqICAgIC0gSUUgPCA4IGNyZWF0ZSBpbnZhbGlkIG1hcmt1cCBhbmQgY3Jhc2ggcmFuZG9tbHkgZnJvbSB0aW1lIHRvIHRpbWVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3VwcG9ydGVkOiBmdW5jdGlvbiBzdXBwb3J0ZWQoKSB7XG4gICAgICB2YXIgdXNlckFnZW50ID0gdGhpcy5VU0VSX0FHRU5ULnRvTG93ZXJDYXNlKCksXG5cbiAgICAgIC8vIEVzc2VudGlhbCBmb3IgbWFraW5nIGh0bWwgZWxlbWVudHMgZWRpdGFibGVcbiAgICAgIGhhc0NvbnRlbnRFZGl0YWJsZVN1cHBvcnQgPSBcImNvbnRlbnRFZGl0YWJsZVwiIGluIHRlc3RFbGVtZW50LFxuXG4gICAgICAvLyBGb2xsb3dpbmcgbWV0aG9kcyBhcmUgbmVlZGVkIGluIG9yZGVyIHRvIGludGVyYWN0IHdpdGggdGhlIGNvbnRlbnRFZGl0YWJsZSBhcmVhXG4gICAgICBoYXNFZGl0aW5nQXBpU3VwcG9ydCA9IGRvY3VtZW50LmV4ZWNDb21tYW5kICYmIGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCAmJiBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZSxcblxuICAgICAgLy8gZG9jdW1lbnQgc2VsZWN0b3IgYXBpcyBhcmUgb25seSBzdXBwb3J0ZWQgYnkgSUUgOCssIFNhZmFyaSA0KywgQ2hyb21lIGFuZCBGaXJlZm94IDMuNStcbiAgICAgIGhhc1F1ZXJ5U2VsZWN0b3JTdXBwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsLFxuXG4gICAgICAvLyBjb250ZW50RWRpdGFibGUgaXMgdW51c2FibGUgaW4gbW9iaWxlIGJyb3dzZXJzICh0ZXN0ZWQgaU9TIDQuMi4yLCBBbmRyb2lkIDIuMiwgT3BlcmEgTW9iaWxlLCBXZWJPUyAzLjA1KVxuICAgICAgaXNJbmNvbXBhdGlibGVNb2JpbGVCcm93c2VyID0gdGhpcy5pc0lvcygpICYmIGlvc1ZlcnNpb24odXNlckFnZW50KSA8IDUgfHwgdXNlckFnZW50LmluZGV4T2YoXCJvcGVyYSBtb2JpXCIpICE9PSAtMSB8fCB1c2VyQWdlbnQuaW5kZXhPZihcImhwd29zL1wiKSAhPT0gLTE7XG5cbiAgICAgIHJldHVybiBoYXNDb250ZW50RWRpdGFibGVTdXBwb3J0ICYmIGhhc0VkaXRpbmdBcGlTdXBwb3J0ICYmIGhhc1F1ZXJ5U2VsZWN0b3JTdXBwb3J0ICYmICFpc0luY29tcGF0aWJsZU1vYmlsZUJyb3dzZXI7XG4gICAgfSxcblxuICAgIGlzVG91Y2hEZXZpY2U6IGZ1bmN0aW9uIGlzVG91Y2hEZXZpY2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdXBwb3J0c0V2ZW50KFwidG91Y2htb3ZlXCIpO1xuICAgIH0sXG5cbiAgICBpc0lvczogZnVuY3Rpb24gaXNJb3MoKSB7XG4gICAgICB2YXIgdXNlckFnZW50ID0gdGhpcy5VU0VSX0FHRU5ULnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gdXNlckFnZW50LmluZGV4T2YoXCJ3ZWJraXRcIikgIT09IC0xICYmIHVzZXJBZ2VudC5pbmRleE9mKFwibW9iaWxlXCIpICE9PSAtMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyBzYW5kYm94ZWQgaWZyYW1lc1xuICAgICAqIEN1cnJlbnRseSBvbmx5IElFIDYrIG9mZmVycyBzdWNoIGZlYXR1cmUgPGlmcmFtZSBzZWN1cml0eT1cInJlc3RyaWN0ZWRcIj5cbiAgICAgKlxuICAgICAqIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNDYyMih2PXZzLjg1KS5hc3B4XG4gICAgICogaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWUvYXJjaGl2ZS8yMDA4LzAxLzE4L3VzaW5nLWZyYW1lcy1tb3JlLXNlY3VyZWx5LmFzcHhcbiAgICAgKlxuICAgICAqIEhUTUw1IHNhbmRib3hlZCBpZnJhbWVzIGFyZSBzdGlsbCBidWdneSBhbmQgdGhlaXIgRE9NIGlzIG5vdCByZWFjaGFibGUgZnJvbSB0aGUgb3V0c2lkZSAoZXhjZXB0IHdoZW4gdXNpbmcgcG9zdE1lc3NhZ2UpXG4gICAgICovXG4gICAgc3VwcG9ydHNTYW5kYm94ZWRJZnJhbWVzOiBmdW5jdGlvbiBzdXBwb3J0c1NhbmRib3hlZElmcmFtZXMoKSB7XG4gICAgICByZXR1cm4gaXNJRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSUU2KzcgdGhyb3cgYSBtaXhlZCBjb250ZW50IHdhcm5pbmcgd2hlbiB0aGUgc3JjIG9mIGFuIGlmcmFtZVxuICAgICAqIGlzIGVtcHR5L3Vuc2V0IG9yIGFib3V0OmJsYW5rXG4gICAgICogd2luZG93LnF1ZXJ5U2VsZWN0b3IgaXMgaW1wbGVtZW50ZWQgYXMgb2YgSUU4XG4gICAgICovXG4gICAgdGhyb3dzTWl4ZWRDb250ZW50V2FybmluZ1doZW5JZnJhbWVTcmNJc0VtcHR5OiBmdW5jdGlvbiB0aHJvd3NNaXhlZENvbnRlbnRXYXJuaW5nV2hlbklmcmFtZVNyY0lzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gIShcInF1ZXJ5U2VsZWN0b3JcIiBpbiBkb2N1bWVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGNhcmV0IGlzIGNvcnJlY3RseSBkaXNwbGF5ZWQgaW4gY29udGVudEVkaXRhYmxlIGVsZW1lbnRzXG4gICAgICogRmlyZWZveCBzb21ldGltZXMgc2hvd3MgYSBodWdlIGNhcmV0IGluIHRoZSBiZWdpbm5pbmcgYWZ0ZXIgZm9jdXNpbmdcbiAgICAgKi9cbiAgICBkaXNwbGF5c0NhcmV0SW5FbXB0eUNvbnRlbnRFZGl0YWJsZUNvcnJlY3RseTogZnVuY3Rpb24gZGlzcGxheXNDYXJldEluRW1wdHlDb250ZW50RWRpdGFibGVDb3JyZWN0bHkoKSB7XG4gICAgICByZXR1cm4gIWlzR2Vja287XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9wZXJhIGFuZCBJRSBhcmUgdGhlIG9ubHkgYnJvd3NlcnMgd2hvIG9mZmVyIHRoZSBjc3MgdmFsdWVcbiAgICAgKiBpbiB0aGUgb3JpZ2luYWwgdW5pdCwgdGh4IHRvIHRoZSBjdXJyZW50U3R5bGUgb2JqZWN0XG4gICAgICogQWxsIG90aGVyIGJyb3dzZXJzIHByb3ZpZGUgdGhlIGNvbXB1dGVkIHN0eWxlIGluIHB4IHZpYSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZVxuICAgICAqL1xuICAgIGhhc0N1cnJlbnRTdHlsZVByb3BlcnR5OiBmdW5jdGlvbiBoYXNDdXJyZW50U3R5bGVQcm9wZXJ0eSgpIHtcbiAgICAgIHJldHVybiBcImN1cnJlbnRTdHlsZVwiIGluIHRlc3RFbGVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBicm93c2VyIGluc2VydHMgYSA8YnI+IHdoZW4gcHJlc3NpbmcgZW50ZXIgaW4gYSBjb250ZW50RWRpdGFibGUgZWxlbWVudFxuICAgICAqL1xuICAgIGluc2VydHNMaW5lQnJlYWtzT25SZXR1cm46IGZ1bmN0aW9uIGluc2VydHNMaW5lQnJlYWtzT25SZXR1cm4oKSB7XG4gICAgICByZXR1cm4gaXNHZWNrbztcbiAgICB9LFxuXG4gICAgc3VwcG9ydHNQbGFjZWhvbGRlckF0dHJpYnV0ZU9uOiBmdW5jdGlvbiBzdXBwb3J0c1BsYWNlaG9sZGVyQXR0cmlidXRlT24oZWxlbWVudCkge1xuICAgICAgcmV0dXJuIFwicGxhY2Vob2xkZXJcIiBpbiBlbGVtZW50O1xuICAgIH0sXG5cbiAgICBzdXBwb3J0c0V2ZW50OiBmdW5jdGlvbiBzdXBwb3J0c0V2ZW50KGV2ZW50TmFtZSkge1xuICAgICAgcmV0dXJuIFwib25cIiArIGV2ZW50TmFtZSBpbiB0ZXN0RWxlbWVudCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRlc3RFbGVtZW50LnNldEF0dHJpYnV0ZShcIm9uXCIgKyBldmVudE5hbWUsIFwicmV0dXJuO1wiKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0ZXN0RWxlbWVudFtcIm9uXCIgKyBldmVudE5hbWVdID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB9KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9wZXJhIGRvZXNuJ3QgY29ycmVjdGx5IGZpcmUgZm9jdXMvYmx1ciBldmVudHMgd2hlbiBjbGlja2luZyBpbi0gYW5kIG91dHNpZGUgb2YgaWZyYW1lXG4gICAgICovXG4gICAgc3VwcG9ydHNFdmVudHNJbklmcmFtZUNvcnJlY3RseTogZnVuY3Rpb24gc3VwcG9ydHNFdmVudHNJbklmcmFtZUNvcnJlY3RseSgpIHtcbiAgICAgIHJldHVybiAhaXNPcGVyYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hyb21lICYgU2FmYXJpIG9ubHkgZmlyZSB0aGUgb25kcm9wL29uZHJhZ2VuZC8uLi4gZXZlbnRzIHdoZW4gdGhlIG9uZHJhZ292ZXIgZXZlbnQgaXMgY2FuY2VsbGVkXG4gICAgICogd2l0aCBldmVudC5wcmV2ZW50RGVmYXVsdFxuICAgICAqIEZpcmVmb3ggMy42IGZpcmVzIHRob3NlIGV2ZW50cyBhbnl3YXksIGJ1dCB0aGUgbW96aWxsYSBkb2Mgc2F5cyB0aGF0IHRoZSBkcmFnb3Zlci9kcmFnZW50ZXIgZXZlbnQgbmVlZHNcbiAgICAgKiB0byBiZSBjYW5jZWxsZWRcbiAgICAgKi9cbiAgICBmaXJlc09uRHJvcE9ubHlXaGVuT25EcmFnT3ZlcklzQ2FuY2VsbGVkOiBmdW5jdGlvbiBmaXJlc09uRHJvcE9ubHlXaGVuT25EcmFnT3ZlcklzQ2FuY2VsbGVkKCkge1xuICAgICAgcmV0dXJuIGlzV2ViS2l0IHx8IGlzR2Vja287XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGV2ZW50LmRhdGFUcmFuc2ZlciBwcm9wZXJ0eSBpbiBhIHByb3BlciB3YXlcbiAgICAgKi9cbiAgICBzdXBwb3J0c0RhdGFUcmFuc2ZlcjogZnVuY3Rpb24gc3VwcG9ydHNEYXRhVHJhbnNmZXIoKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBkYXRhVHJhbnNmZXIgaW4gYSBzYWZlIHdheSwgaXQgZG9lc24ndCBzdHJpcCBzY3JpcHQgY29kZSBpbiB0aGUgaHRtbCBwYXlsb2FkIChsaWtlIENocm9tZSBkb2VzKVxuICAgICAgICByZXR1cm4gaXNXZWJLaXQgJiYgKHdpbmRvdy5DbGlwYm9hcmQgfHwgd2luZG93LkRhdGFUcmFuc2ZlcikucHJvdG90eXBlLmdldERhdGE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXZlcnl0aGluZyBiZWxvdyBJRTkgZG9lc24ndCBrbm93IGhvdyB0byB0cmVhdCBIVE1MNSB0YWdzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgZG9jdW1lbnQgb2JqZWN0IG9uIHdoaWNoIHRvIGNoZWNrIEhUTUw1IHN1cHBvcnRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNIVE1MNVRhZ3MoZG9jdW1lbnQpO1xuICAgICAqL1xuICAgIHN1cHBvcnRzSFRNTDVUYWdzOiBmdW5jdGlvbiBzdXBwb3J0c0hUTUw1VGFncyhjb250ZXh0KSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICBodG1sNSA9IFwiPGFydGljbGU+Zm9vPC9hcnRpY2xlPlwiO1xuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBodG1sNTtcbiAgICAgIHJldHVybiBlbGVtZW50LmlubmVySFRNTC50b0xvd2VyQ2FzZSgpID09PSBodG1sNTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSBkb2N1bWVudCBzdXBwb3J0cyBhIGNlcnRhaW4gcXVlcnlDb21tYW5kXG4gICAgICogSW4gcGFydGljdWxhciwgT3BlcmEgbmVlZHMgYSByZWZlcmVuY2UgdG8gYSBkb2N1bWVudCB0aGF0IGhhcyBhIGNvbnRlbnRFZGl0YWJsZSBpbiBpdCdzIGRvbSB0cmVlXG4gICAgICogaW4gb2RlciB0byByZXBvcnQgY29ycmVjdCByZXN1bHRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZG9jIERvY3VtZW50IG9iamVjdCBvbiB3aGljaCB0byBjaGVjayBmb3IgYSBxdWVyeSBjb21tYW5kXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbW1hbmQgVGhlIHF1ZXJ5IGNvbW1hbmQgdG8gY2hlY2sgZm9yXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNDb21tYW5kKGRvY3VtZW50LCBcImJvbGRcIik7XG4gICAgICovXG4gICAgc3VwcG9ydHNDb21tYW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBGb2xsb3dpbmcgY29tbWFuZHMgYXJlIHN1cHBvcnRlZCBidXQgY29udGFpbiBidWdzIGluIHNvbWUgYnJvd3NlcnNcbiAgICAgIHZhciBidWdneUNvbW1hbmRzID0ge1xuICAgICAgICAvLyBmb3JtYXRCbG9jayBmYWlscyB3aXRoIHNvbWUgdGFncyAoZWcuIDxibG9ja3F1b3RlPilcbiAgICAgICAgXCJmb3JtYXRCbG9ja1wiOiBpc0lFLFxuICAgICAgICAvLyBXaGVuIGluc2VydGluZyB1bm9yZGVyZWQgb3Igb3JkZXJlZCBsaXN0cyBpbiBGaXJlZm94LCBDaHJvbWUgb3IgU2FmYXJpLCB0aGUgY3VycmVudCBzZWxlY3Rpb24gb3IgbGluZSBnZXRzXG4gICAgICAgIC8vIGNvbnZlcnRlZCBpbnRvIGEgbGlzdCAoPHVsPjxsaT4uLi48L2xpPjwvdWw+LCA8b2w+PGxpPi4uLjwvbGk+PC9vbD4pXG4gICAgICAgIC8vIElFIGFuZCBPcGVyYSBhY3QgYSBiaXQgZGlmZmVyZW50IGhlcmUgYXMgdGhleSBjb252ZXJ0IHRoZSBlbnRpcmUgY29udGVudCBvZiB0aGUgY3VycmVudCBibG9jayBlbGVtZW50IGludG8gYSBsaXN0XG4gICAgICAgIFwiaW5zZXJ0VW5vcmRlcmVkTGlzdFwiOiBpc0lFIHx8IGlzT3BlcmEgfHwgaXNXZWJLaXQsXG4gICAgICAgIFwiaW5zZXJ0T3JkZXJlZExpc3RcIjogaXNJRSB8fCBpc09wZXJhIHx8IGlzV2ViS2l0XG4gICAgICB9O1xuXG4gICAgICAvLyBGaXJlZm94IHRocm93cyBlcnJvcnMgZm9yIHF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCwgc28gd2UgaGF2ZSB0byBidWlsZCB1cCBvdXIgb3duIG9iamVjdCBvZiBzdXBwb3J0ZWQgY29tbWFuZHNcbiAgICAgIHZhciBzdXBwb3J0ZWQgPSB7XG4gICAgICAgIFwiaW5zZXJ0SFRNTFwiOiBpc0dlY2tvXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRvYywgY29tbWFuZCkge1xuICAgICAgICB2YXIgaXNCdWdneSA9IGJ1Z2d5Q29tbWFuZHNbY29tbWFuZF07XG4gICAgICAgIGlmICghaXNCdWdneSkge1xuICAgICAgICAgIC8vIEZpcmVmb3ggdGhyb3dzIGVycm9ycyB3aGVuIGludm9raW5nIHF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCBvciBxdWVyeUNvbW1hbmRFbmFibGVkXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBkb2MucXVlcnlDb21tYW5kU3VwcG9ydGVkKGNvbW1hbmQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUxKSB7fVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBkb2MucXVlcnlDb21tYW5kRW5hYmxlZChjb21tYW5kKTtcbiAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgcmV0dXJuICEhc3VwcG9ydGVkW2NvbW1hbmRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH0oKSxcblxuICAgIC8qKlxuICAgICAqIElFOiBVUkxzIHN0YXJ0aW5nIHdpdGg6XG4gICAgICogICAgd3d3LiwgaHR0cDovLywgaHR0cHM6Ly8sIGZ0cDovLywgZ29waGVyOi8vLCBtYWlsdG86LCBuZXc6LCBzbmV3czosIHRlbG5ldDosIHdhc2lzOiwgZmlsZTovLyxcbiAgICAgKiAgICBubnRwOi8vLCBuZXdzcmM6LCBsZGFwOi8vLCBsZGFwczovLywgb3V0bG9vazosIG1pYzovLyBhbmQgdXJsOlxuICAgICAqIHdpbGwgYXV0b21hdGljYWxseSBiZSBhdXRvLWxpbmtlZCB3aGVuIGVpdGhlciB0aGUgdXNlciBpbnNlcnRzIHRoZW0gdmlhIGNvcHkmcGFzdGUgb3IgcHJlc3NlcyB0aGVcbiAgICAgKiBzcGFjZSBiYXIgd2hlbiB0aGUgY2FyZXQgaXMgZGlyZWN0bHkgYWZ0ZXIgc3VjaCBhbiB1cmwuXG4gICAgICogVGhpcyBiZWhhdmlvciBjYW5ub3QgZWFzaWx5IGJlIGF2b2lkZWQgaW4gSUUgPCA5IHNpbmNlIHRoZSBsb2dpYyBpcyBoYXJkY29kZWQgaW4gdGhlIG1zaHRtbC5kbGxcbiAgICAgKiAocmVsYXRlZCBibG9nIHBvc3Qgb24gbXNkblxuICAgICAqIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAwOS8wOS8xNy9wcmV2ZW50LWF1dG9tYXRpYy1oeXBlcmxpbmtpbmctaW4tY29udGVudGVkaXRhYmxlLWh0bWwuYXNweCkuXG4gICAgICovXG4gICAgZG9lc0F1dG9MaW5raW5nSW5Db250ZW50RWRpdGFibGU6IGZ1bmN0aW9uIGRvZXNBdXRvTGlua2luZ0luQ29udGVudEVkaXRhYmxlKCkge1xuICAgICAgcmV0dXJuIGlzSUU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFzIHN0YXRlZCBhYm92ZSwgSUUgYXV0byBsaW5rcyB1cmxzIHR5cGVkIGludG8gY29udGVudEVkaXRhYmxlIGVsZW1lbnRzXG4gICAgICogU2luY2UgSUU5IGl0J3MgcG9zc2libGUgdG8gcHJldmVudCB0aGlzIGJlaGF2aW9yXG4gICAgICovXG4gICAgY2FuRGlzYWJsZUF1dG9MaW5raW5nOiBmdW5jdGlvbiBjYW5EaXNhYmxlQXV0b0xpbmtpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdXBwb3J0c0NvbW1hbmQoZG9jdW1lbnQsIFwiQXV0b1VybERldGVjdFwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSUUgbGVhdmVzIGFuIGVtcHR5IHBhcmFncmFwaCBpbiB0aGUgY29udGVudEVkaXRhYmxlIGVsZW1lbnQgYWZ0ZXIgY2xlYXJpbmcgaXRcbiAgICAgKiBDaHJvbWUvU2FmYXJpIHNvbWV0aW1lcyBhbiBlbXB0eSA8ZGl2PlxuICAgICAqL1xuICAgIGNsZWFyc0NvbnRlbnRFZGl0YWJsZUNvcnJlY3RseTogZnVuY3Rpb24gY2xlYXJzQ29udGVudEVkaXRhYmxlQ29ycmVjdGx5KCkge1xuICAgICAgcmV0dXJuIGlzR2Vja28gfHwgaXNPcGVyYSB8fCBpc1dlYktpdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSUUgZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgZ2V0QXR0cmlidXRlXG4gICAgICovXG4gICAgc3VwcG9ydHNHZXRBdHRyaWJ1dGVDb3JyZWN0bHk6IGZ1bmN0aW9uIHN1cHBvcnRzR2V0QXR0cmlidXRlQ29ycmVjdGx5KCkge1xuICAgICAgdmFyIHRkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuICAgICAgcmV0dXJuIHRkLmdldEF0dHJpYnV0ZShcInJvd3NwYW5cIikgIT0gXCIxXCI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2xpY2tpbmcgb24gaW1hZ2VzIGluIElFLCBPcGVyYSBhbmQgRmlyZWZveCwgdGhleSBhcmUgc2VsZWN0ZWQsIHdoaWNoIG1ha2VzIGl0IGVhc3kgdG8gaW50ZXJhY3Qgd2l0aCB0aGVtLlxuICAgICAqIENocm9tZSBhbmQgU2FmYXJpIGJvdGggZG9uJ3Qgc3VwcG9ydCB0aGlzXG4gICAgICovXG4gICAgY2FuU2VsZWN0SW1hZ2VzSW5Db250ZW50RWRpdGFibGU6IGZ1bmN0aW9uIGNhblNlbGVjdEltYWdlc0luQ29udGVudEVkaXRhYmxlKCkge1xuICAgICAgcmV0dXJuIGlzR2Vja28gfHwgaXNJRSB8fCBpc09wZXJhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBjYXJldCBpcyBpbiBhbiBlbXB0eSBsaXN0ICg8dWw+PGxpPnw8L2xpPjwvdWw+KSB3aGljaCBpcyB0aGUgZmlyc3QgY2hpbGQgaW4gYW4gY29udGVudEVkaXRhYmxlIGNvbnRhaW5lclxuICAgICAqIHByZXNzaW5nIGJhY2tzcGFjZSBkb2Vzbid0IHJlbW92ZSB0aGUgZW50aXJlIGxpc3QgYXMgZG9uZSBpbiBvdGhlciBicm93c2Vyc1xuICAgICAqL1xuICAgIGNsZWFyc0xpc3RzSW5Db250ZW50RWRpdGFibGVDb3JyZWN0bHk6IGZ1bmN0aW9uIGNsZWFyc0xpc3RzSW5Db250ZW50RWRpdGFibGVDb3JyZWN0bHkoKSB7XG4gICAgICByZXR1cm4gaXNHZWNrbyB8fCBpc0lFIHx8IGlzV2ViS2l0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbGwgYnJvd3NlcnMgZXhjZXB0IFNhZmFyaSBhbmQgQ2hyb21lIGF1dG9tYXRpY2FsbHkgc2Nyb2xsIHRoZSByYW5nZS9jYXJldCBwb3NpdGlvbiBpbnRvIHZpZXdcbiAgICAgKi9cbiAgICBhdXRvU2Nyb2xsc1RvQ2FyZXQ6IGZ1bmN0aW9uIGF1dG9TY3JvbGxzVG9DYXJldCgpIHtcbiAgICAgIHJldHVybiAhaXNXZWJLaXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGJyb3dzZXIgYXV0b21hdGljYWxseSBjbG9zZXMgdGFncyB0aGF0IGRvbid0IG5lZWQgdG8gYmUgb3BlbmVkXG4gICAgICovXG4gICAgYXV0b0Nsb3Nlc1VuY2xvc2VkVGFnczogZnVuY3Rpb24gYXV0b0Nsb3Nlc1VuY2xvc2VkVGFncygpIHtcbiAgICAgIHZhciBjbG9uZWRUZXN0RWxlbWVudCA9IHRlc3RFbGVtZW50LmNsb25lTm9kZShmYWxzZSksXG4gICAgICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICAgICAgaW5uZXJIVE1MO1xuXG4gICAgICBjbG9uZWRUZXN0RWxlbWVudC5pbm5lckhUTUwgPSBcIjxwPjxkaXY+PC9kaXY+XCI7XG4gICAgICBpbm5lckhUTUwgPSBjbG9uZWRUZXN0RWxlbWVudC5pbm5lckhUTUwudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVyblZhbHVlID0gaW5uZXJIVE1MID09PSBcIjxwPjwvcD48ZGl2PjwvZGl2PlwiIHx8IGlubmVySFRNTCA9PT0gXCI8cD48ZGl2PjwvZGl2PjwvcD5cIjtcblxuICAgICAgLy8gQ2FjaGUgcmVzdWx0IGJ5IG92ZXJ3cml0aW5nIGN1cnJlbnQgZnVuY3Rpb25cbiAgICAgIHRoaXMuYXV0b0Nsb3Nlc1VuY2xvc2VkVGFncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBuYXRpdmUgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSB3aGljaCByZXR1cm5zIGxpdmUgTm9kZUxpc3RzXG4gICAgICovXG4gICAgc3VwcG9ydHNOYXRpdmVHZXRFbGVtZW50c0J5Q2xhc3NOYW1lOiBmdW5jdGlvbiBzdXBwb3J0c05hdGl2ZUdldEVsZW1lbnRzQnlDbGFzc05hbWUoKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXMgb2Ygbm93ICgxOS4wNC4yMDExKSBvbmx5IHN1cHBvcnRlZCBieSBGaXJlZm94IDQgYW5kIENocm9tZVxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vU2VsZWN0aW9uL21vZGlmeVxuICAgICAqL1xuICAgIHN1cHBvcnRzU2VsZWN0aW9uTW9kaWZ5OiBmdW5jdGlvbiBzdXBwb3J0c1NlbGVjdGlvbk1vZGlmeSgpIHtcbiAgICAgIHJldHVybiBcImdldFNlbGVjdGlvblwiIGluIHdpbmRvdyAmJiBcIm1vZGlmeVwiIGluIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgY2xhc3NMaXN0IG9iamVjdCBmb3IgZmFzdCBjbGFzc05hbWUgbWFuaXB1bGF0aW9uXG4gICAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9lbGVtZW50LmNsYXNzTGlzdFxuICAgICAqL1xuICAgIHN1cHBvcnRzQ2xhc3NMaXN0OiBmdW5jdGlvbiBzdXBwb3J0c0NsYXNzTGlzdCgpIHtcbiAgICAgIHJldHVybiBcImNsYXNzTGlzdFwiIGluIHRlc3RFbGVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPcGVyYSBuZWVkcyBhIHdoaXRlIHNwYWNlIGFmdGVyIGEgPGJyPiBpbiBvcmRlciB0byBwb3NpdGlvbiB0aGUgY2FyZXQgY29ycmVjdGx5XG4gICAgICovXG4gICAgbmVlZHNTcGFjZUFmdGVyTGluZUJyZWFrOiBmdW5jdGlvbiBuZWVkc1NwYWNlQWZ0ZXJMaW5lQnJlYWsoKSB7XG4gICAgICByZXR1cm4gaXNPcGVyYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgc3BlZWNoIGFwaSBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgICAqIFNlZSBodHRwOi8vbWlrZXB1bHR6LmNvbS8yMDExLzAzL2FjY2Vzc2luZy1nb29nbGUtc3BlZWNoLWFwaS1jaHJvbWUtMTEvXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgKiAgICBpZiAod3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNTcGVlY2hBcGlPbihpbnB1dCkpIHtcbiAgICAgKiAgICAgIC8vIC4uLlxuICAgICAqICAgIH1cbiAgICAgKi9cbiAgICBzdXBwb3J0c1NwZWVjaEFwaU9uOiBmdW5jdGlvbiBzdXBwb3J0c1NwZWVjaEFwaU9uKGlucHV0KSB7XG4gICAgICB2YXIgY2hyb21lVmVyc2lvbiA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLykgfHwgWywgMF07XG4gICAgICByZXR1cm4gY2hyb21lVmVyc2lvblsxXSA+PSAxMSAmJiAoXCJvbndlYmtpdHNwZWVjaGNoYW5nZVwiIGluIGlucHV0IHx8IFwic3BlZWNoXCIgaW4gaW5wdXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJRTkgY3Jhc2hlcyB3aGVuIHNldHRpbmcgYSBnZXR0ZXIgdmlhIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBvbiBYTUxIdHRwUmVxdWVzdCBvciBYRG9tYWluUmVxdWVzdFxuICAgICAqIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9pZS9mZWVkYmFjay9kZXRhaWxzLzY1MDExMlxuICAgICAqIG9yIHRyeSB0aGUgUE9DIGh0dHA6Ly90aWZmdGlmZi5kZS9pZTlfY3Jhc2gvXG4gICAgICovXG4gICAgY3Jhc2hlc1doZW5EZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gY3Jhc2hlc1doZW5EZWZpbmVQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIGlzSUUgJiYgKHByb3BlcnR5ID09PSBcIlhNTEh0dHBSZXF1ZXN0XCIgfHwgcHJvcGVydHkgPT09IFwiWERvbWFpblJlcXVlc3RcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElFIGlzIHRoZSBvbmx5IGJyb3dzZXIgd2hvIGZpcmVzIHRoZSBcImZvY3VzXCIgZXZlbnQgbm90IGltbWVkaWF0ZWx5IHdoZW4gLmZvY3VzKCkgaXMgY2FsbGVkIG9uIGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBkb2VzQXN5bmNGb2N1czogZnVuY3Rpb24gZG9lc0FzeW5jRm9jdXMoKSB7XG4gICAgICByZXR1cm4gaXNJRTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW4gSUUgaXQncyBpbXBzc2libGUgZm9yIHRoZSB1c2VyIGFuZCBmb3IgdGhlIHNlbGVjdGlvbiBsaWJyYXJ5IHRvIHNldCB0aGUgY2FyZXQgYWZ0ZXIgYW4gPGltZz4gd2hlbiBpdCdzIHRoZSBsYXN0Q2hpbGQgaW4gdGhlIGRvY3VtZW50XG4gICAgICovXG4gICAgaGFzUHJvYmxlbXNTZXR0aW5nQ2FyZXRBZnRlckltZzogZnVuY3Rpb24gaGFzUHJvYmxlbXNTZXR0aW5nQ2FyZXRBZnRlckltZygpIHtcbiAgICAgIHJldHVybiBpc0lFO1xuICAgIH0sXG5cbiAgICBoYXNVbmRvSW5Db250ZXh0TWVudTogZnVuY3Rpb24gaGFzVW5kb0luQ29udGV4dE1lbnUoKSB7XG4gICAgICByZXR1cm4gaXNHZWNrbyB8fCBpc0Nocm9tZSB8fCBpc09wZXJhO1xuICAgIH1cbiAgfTtcbn0oKTt3eXNpaHRtbDUubGFuZy5hcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIGEgZ2l2ZW4gb2JqZWN0IGV4aXN0cyBpbiBhbiBhcnJheVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB3eXNpaHRtbDUubGFuZy5hcnJheShbMSwgMl0pLmNvbnRhaW5zKDEpO1xuICAgICAqICAgIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBjb250YWluczogZnVuY3Rpb24gY29udGFpbnMobmVlZGxlKSB7XG4gICAgICBpZiAoYXJyLmluZGV4T2YpIHtcbiAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhcnJbaV0gPT09IG5lZWRsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3Vic3RyYWN0IG9uZSBhcnJheSBmcm9tIGFub3RoZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1LmxhbmcuYXJyYXkoWzEsIDIsIDMsIDRdKS53aXRob3V0KFszLCA0XSk7XG4gICAgICogICAgLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgd2l0aG91dDogZnVuY3Rpb24gd2l0aG91dChhcnJheVRvU3Vic3RyYWN0KSB7XG4gICAgICBhcnJheVRvU3Vic3RyYWN0ID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoYXJyYXlUb1N1YnN0cmFjdCk7XG4gICAgICB2YXIgbmV3QXJyID0gW10sXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFhcnJheVRvU3Vic3RyYWN0LmNvbnRhaW5zKGFycltpXSkpIHtcbiAgICAgICAgICBuZXdBcnIucHVzaChhcnJbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3QXJyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBjbGVhbiBuYXRpdmUgYXJyYXlcbiAgICAgKiBcbiAgICAgKiBGb2xsb3dpbmcgd2lsbCBjb252ZXJ0IGEgTGl2ZSBOb2RlTGlzdCB0byBhIHByb3BlciBBcnJheVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgdmFyIGNoaWxkTm9kZXMgPSB3eXNpaHRtbDUubGFuZy5hcnJheShkb2N1bWVudC5ib2R5LmNoaWxkTm9kZXMpLmdldCgpO1xuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgbmV3QXJyYXkgPSBbXTtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3QXJyYXkucHVzaChhcnJbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgIH1cbiAgfTtcbn07d3lzaWh0bWw1LmxhbmcuRGlzcGF0Y2hlciA9IEJhc2UuZXh0ZW5kKFxuLyoqIEBzY29wZSB3eXNpaHRtbDUubGFuZy5EaWFsb2cucHJvdG90eXBlICove1xuICBvYnNlcnZlOiBmdW5jdGlvbiBvYnNlcnZlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMgfHwge307XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gfHwgW107XG4gICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9uOiBmdW5jdGlvbiBvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vYnNlcnZlLmFwcGx5KHRoaXMsIHd5c2lodG1sNS5sYW5nLmFycmF5KGFyZ3VtZW50cykuZ2V0KCkpO1xuICB9LFxuXG4gIGZpcmU6IGZ1bmN0aW9uIGZpcmUoZXZlbnROYW1lLCBwYXlsb2FkKSB7XG4gICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cyB8fCB7fTtcbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdIHx8IFtdLFxuICAgICAgICBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYW5kbGVyc1tpXS5jYWxsKHRoaXMsIHBheWxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzdG9wT2JzZXJ2aW5nOiBmdW5jdGlvbiBzdG9wT2JzZXJ2aW5nKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMgfHwge307XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBoYW5kbGVycyxcbiAgICAgICAgbmV3SGFuZGxlcnM7XG4gICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgaGFuZGxlcnMgPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdIHx8IFtdLCBuZXdIYW5kbGVycyA9IFtdO1xuICAgICAgZm9yICg7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGFuZGxlcnNbaV0gIT09IGhhbmRsZXIgJiYgaGFuZGxlcikge1xuICAgICAgICAgIG5ld0hhbmRsZXJzLnB1c2goaGFuZGxlcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gbmV3SGFuZGxlcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFuIHVwIGFsbCBldmVudHNcbiAgICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTt3eXNpaHRtbDUubGFuZy5vYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB3eXNpaHRtbDUubGFuZy5vYmplY3QoeyBmb286IDEsIGJhcjogMSB9KS5tZXJnZSh7IGJhcjogMiwgYmF6OiAzIH0pLmdldCgpO1xuICAgICAqICAgIC8vID0+IHsgZm9vOiAxLCBiYXI6IDIsIGJhejogMyB9XG4gICAgICovXG4gICAgbWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKG90aGVyT2JqKSB7XG4gICAgICBmb3IgKHZhciBpIGluIG90aGVyT2JqKSB7XG4gICAgICAgIG9ialtpXSA9IG90aGVyT2JqW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB3eXNpaHRtbDUubGFuZy5vYmplY3QoeyBmb286IDEgfSkuY2xvbmUoKTtcbiAgICAgKiAgICAvLyA9PiB7IGZvbzogMSB9XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgdmFyIG5ld09iaiA9IHt9LFxuICAgICAgICAgIGk7XG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgIG5ld09ialtpXSA9IG9ialtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1Lmxhbmcub2JqZWN0KFtdKS5pc0FycmF5KCk7XG4gICAgICogICAgLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGlzQXJyYXk6IGZ1bmN0aW9uIGlzQXJyYXkoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICB9XG4gIH07XG59OyhmdW5jdGlvbiAoKSB7XG4gIHZhciBXSElURV9TUEFDRV9TVEFSVCA9IC9eXFxzKy8sXG4gICAgICBXSElURV9TUEFDRV9FTkQgPSAvXFxzKyQvO1xuICB3eXNpaHRtbDUubGFuZy5zdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqICAgIHd5c2lodG1sNS5sYW5nLnN0cmluZyhcIiAgIGZvbyAgIFwiKS50cmltKCk7XG4gICAgICAgKiAgICAvLyA9PiBcImZvb1wiXG4gICAgICAgKi9cbiAgICAgIHRyaW06IGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShXSElURV9TUEFDRV9TVEFSVCwgXCJcIikucmVwbGFjZShXSElURV9TUEFDRV9FTkQsIFwiXCIpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogICAgd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKFwiSGVsbG8gI3tuYW1lfVwiKS5pbnRlcnBvbGF0ZSh7IG5hbWU6IFwiQ2hyaXN0b3BoZXJcIiB9KTtcbiAgICAgICAqICAgIC8vID0+IFwiSGVsbG8gQ2hyaXN0b3BoZXJcIlxuICAgICAgICovXG4gICAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGUodmFycykge1xuICAgICAgICBmb3IgKHZhciBpIGluIHZhcnMpIHtcbiAgICAgICAgICBzdHIgPSB0aGlzLnJlcGxhY2UoXCIje1wiICsgaSArIFwifVwiKS5ieSh2YXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogICAgd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKFwiSGVsbG8gVG9tXCIpLnJlcGxhY2UoXCJUb21cIikud2l0aChcIkhhbnNcIik7XG4gICAgICAgKiAgICAvLyA9PiBcIkhlbGxvIEhhbnNcIlxuICAgICAgICovXG4gICAgICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKHNlYXJjaCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJ5OiBmdW5jdGlvbiBieShyZXBsYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnNwbGl0KHNlYXJjaCkuam9pbihyZXBsYWNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn0pKCk7IC8qKlxuICAgICAgKiBGaW5kIHVybHMgaW4gZGVzY2VuZGFudCB0ZXh0IG5vZGVzIG9mIGFuIGVsZW1lbnQgYW5kIGF1dG8tbGlua3MgdGhlbVxuICAgICAgKiBJbnNwaXJlZCBieSBodHRwOi8vamFtZXMucGFkb2xzZXkuY29tL2phdmFzY3JpcHQvZmluZC1hbmQtcmVwbGFjZS10ZXh0LXdpdGgtamF2YXNjcmlwdC9cbiAgICAgICpcbiAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IENvbnRhaW5lciBlbGVtZW50IGluIHdoaWNoIHRvIHNlYXJjaCBmb3IgdXJsc1xuICAgICAgKlxuICAgICAgKiBAZXhhbXBsZVxuICAgICAgKiAgICA8ZGl2IGlkPVwidGV4dC1jb250YWluZXJcIj5QbGVhc2UgY2xpY2sgaGVyZTogd3d3Lmdvb2dsZS5jb208L2Rpdj5cbiAgICAgICogICAgPHNjcmlwdD53eXNpaHRtbDUuZG9tLmF1dG9MaW5rKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGV4dC1jb250YWluZXJcIikpOzwvc2NyaXB0PlxuICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciAvKipcbiAgICAgICAqIERvbid0IGF1dG8tbGluayB1cmxzIHRoYXQgYXJlIGNvbnRhaW5lZCBpbiB0aGUgZm9sbG93aW5nIGVsZW1lbnRzOlxuICAgICAgICovXG4gIElHTk9SRV9VUkxTX0lOID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoW1wiQ09ERVwiLCBcIlBSRVwiLCBcIkFcIiwgXCJTQ1JJUFRcIiwgXCJIRUFEXCIsIFwiVElUTEVcIiwgXCJTVFlMRVwiXSksXG5cbiAgLyoqXG4gICAqIHJldmlzaW9uIDE6XG4gICAqICAgIC8oXFxTK1xcLnsxfVteXFxzXFwsXFwuXFwhXSspL2dcbiAgICpcbiAgICogcmV2aXNpb24gMjpcbiAgICogICAgLyhcXGIoKChodHRwcz98ZnRwKTpcXC9cXC8pfCh3d3dcXC4pKVstQS1aMC05KyZAI1xcLyU/PX5ffCE6LC47XFxbXFxdXSpbLUEtWjAtOSsmQCNcXC8lPX5ffF0pL2dpbVxuICAgKlxuICAgKiBwdXQgdGhpcyBpbiB0aGUgYmVnaW5uaW5nIGlmIHlvdSBkb24ndCB3YW4ndCB0byBtYXRjaCB3aXRoaW4gYSB3b3JkXG4gICAqICAgIChefFtcXD5cXChcXHtcXFtcXHNcXD5dKVxuICAgKi9cbiAgVVJMX1JFR19FWFAgPSAvKChodHRwcz86XFwvXFwvfHd3d1xcLilbXlxcczxdezMsfSkvZ2ksXG4gICAgICBUUkFJTElOR19DSEFSX1JFR19FWFAgPSAvKFteXFx3XFwvXFwtXSgsPykpJC9pLFxuICAgICAgTUFYX0RJU1BMQVlfTEVOR1RIID0gMTAwLFxuICAgICAgQlJBQ0tFVFMgPSB7IFwiKVwiOiBcIihcIiwgXCJdXCI6IFwiW1wiLCBcIn1cIjogXCJ7XCIgfTtcblxuICBmdW5jdGlvbiBhdXRvTGluayhlbGVtZW50KSB7XG4gICAgaWYgKF9oYXNQYXJlbnRUaGF0U2hvdWxkQmVJZ25vcmVkKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudCA9PT0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIH1cblxuICAgIHJldHVybiBfcGFyc2VOb2RlKGVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYmFzaWNhbGx5IGEgcmVidWlsZCBvZlxuICAgKiB0aGUgcmFpbHMgYXV0b19saW5rX3VybHMgdGV4dCBoZWxwZXJcbiAgICovXG4gIGZ1bmN0aW9uIF9jb252ZXJ0VXJsc1RvTGlua3Moc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKFVSTF9SRUdfRVhQLCBmdW5jdGlvbiAobWF0Y2gsIHVybCkge1xuICAgICAgdmFyIHB1bmN0dWF0aW9uID0gKHVybC5tYXRjaChUUkFJTElOR19DSEFSX1JFR19FWFApIHx8IFtdKVsxXSB8fCBcIlwiLFxuICAgICAgICAgIG9wZW5pbmcgPSBCUkFDS0VUU1twdW5jdHVhdGlvbl07XG4gICAgICB1cmwgPSB1cmwucmVwbGFjZShUUkFJTElOR19DSEFSX1JFR19FWFAsIFwiXCIpO1xuXG4gICAgICBpZiAodXJsLnNwbGl0KG9wZW5pbmcpLmxlbmd0aCA+IHVybC5zcGxpdChwdW5jdHVhdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIHVybCA9IHVybCArIHB1bmN0dWF0aW9uO1xuICAgICAgICBwdW5jdHVhdGlvbiA9IFwiXCI7XG4gICAgICB9XG4gICAgICB2YXIgcmVhbFVybCA9IHVybCxcbiAgICAgICAgICBkaXNwbGF5VXJsID0gdXJsO1xuICAgICAgaWYgKHVybC5sZW5ndGggPiBNQVhfRElTUExBWV9MRU5HVEgpIHtcbiAgICAgICAgZGlzcGxheVVybCA9IGRpc3BsYXlVcmwuc3Vic3RyKDAsIE1BWF9ESVNQTEFZX0xFTkdUSCkgKyBcIi4uLlwiO1xuICAgICAgfVxuICAgICAgLy8gQWRkIGh0dHAgcHJlZml4IGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHJlYWxVcmwuc3Vic3RyKDAsIDQpID09PSBcInd3dy5cIikge1xuICAgICAgICByZWFsVXJsID0gXCJodHRwOi8vXCIgKyByZWFsVXJsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzxhIGhyZWY9XCInICsgcmVhbFVybCArICdcIj4nICsgcmVhbFVybCArICc8L2E+JyArIHB1bmN0dWF0aW9uO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgb3IgKGlmIGFscmVhZHkgY2FjaGVkKSByZXR1cm5zIGEgdGVtcCBlbGVtZW50XG4gICAqIGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQgb2JqZWN0XG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0VGVtcEVsZW1lbnQoY29udGV4dCkge1xuICAgIHZhciB0ZW1wRWxlbWVudCA9IGNvbnRleHQuX3d5c2lodG1sNV90ZW1wRWxlbWVudDtcbiAgICBpZiAoIXRlbXBFbGVtZW50KSB7XG4gICAgICB0ZW1wRWxlbWVudCA9IGNvbnRleHQuX3d5c2lodG1sNV90ZW1wRWxlbWVudCA9IGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBvcmlnaW5hbCB0ZXh0IG5vZGVzIHdpdGggdGhlIG5ld2x5IGF1dG8tbGlua2VkIGRvbSB0cmVlXG4gICAqL1xuICBmdW5jdGlvbiBfd3JhcE1hdGNoZXNJbk5vZGUodGV4dE5vZGUpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHRleHROb2RlLnBhcmVudE5vZGUsXG4gICAgICAgIHRlbXBFbGVtZW50ID0gX2dldFRlbXBFbGVtZW50KHBhcmVudE5vZGUub3duZXJEb2N1bWVudCk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGluc2VydCBhbiBlbXB0eS90ZW1wb3JhcnkgPHNwYW4gLz4gdG8gZml4IElFIHF1aXJrc1xuICAgIC8vIEVsc2V3aXNlIElFIHdvdWxkIHN0cmlwIHdoaXRlIHNwYWNlIGluIHRoZSBiZWdpbm5pbmdcbiAgICB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPSBcIjxzcGFuPjwvc3Bhbj5cIiArIF9jb252ZXJ0VXJsc1RvTGlua3ModGV4dE5vZGUuZGF0YSk7XG4gICAgdGVtcEVsZW1lbnQucmVtb3ZlQ2hpbGQodGVtcEVsZW1lbnQuZmlyc3RDaGlsZCk7XG5cbiAgICB3aGlsZSAodGVtcEVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgLy8gaW5zZXJ0cyB0ZW1wRWxlbWVudC5maXJzdENoaWxkIGJlZm9yZSB0ZXh0Tm9kZVxuICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGVtcEVsZW1lbnQuZmlyc3RDaGlsZCwgdGV4dE5vZGUpO1xuICAgIH1cbiAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9oYXNQYXJlbnRUaGF0U2hvdWxkQmVJZ25vcmVkKG5vZGUpIHtcbiAgICB2YXIgbm9kZU5hbWU7XG4gICAgd2hpbGUgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZTtcbiAgICAgIGlmIChJR05PUkVfVVJMU19JTi5jb250YWlucyhub2RlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcImJvZHlcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9wYXJzZU5vZGUoZWxlbWVudCkge1xuICAgIGlmIChJR05PUkVfVVJMU19JTi5jb250YWlucyhlbGVtZW50Lm5vZGVOYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSB3eXNpaHRtbDUuVEVYVF9OT0RFICYmIGVsZW1lbnQuZGF0YS5tYXRjaChVUkxfUkVHX0VYUCkpIHtcbiAgICAgIF93cmFwTWF0Y2hlc0luTm9kZShlbGVtZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGROb2RlcyA9IHd5c2lodG1sNS5sYW5nLmFycmF5KGVsZW1lbnQuY2hpbGROb2RlcykuZ2V0KCksXG4gICAgICAgIGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgICAgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGNoaWxkTm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgX3BhcnNlTm9kZShjaGlsZE5vZGVzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHd5c2lodG1sNS5kb20uYXV0b0xpbmsgPSBhdXRvTGluaztcblxuICAvLyBSZXZlYWwgdXJsIHJlZyBleHAgdG8gdGhlIG91dHNpZGVcbiAgd3lzaWh0bWw1LmRvbS5hdXRvTGluay5VUkxfUkVHX0VYUCA9IFVSTF9SRUdfRVhQO1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgc3VwcG9ydHNDbGFzc0xpc3QgPSB3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c0NsYXNzTGlzdCgpLFxuICAgICAgYXBpID0gd3lzaWh0bWw1LmRvbTtcblxuICBhcGkuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKHN1cHBvcnRzQ2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGlmIChhcGkuaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgfTtcblxuICBhcGkucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKHN1cHBvcnRzQ2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoXnxcXFxccyspXCIgKyBjbGFzc05hbWUgKyBcIihcXFxccyt8JClcIiksIFwiIFwiKTtcbiAgfTtcblxuICBhcGkuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKHN1cHBvcnRzQ2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudENsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lO1xuICAgIHJldHVybiBlbGVtZW50Q2xhc3NOYW1lLmxlbmd0aCA+IDAgJiYgKGVsZW1lbnRDbGFzc05hbWUgPT0gY2xhc3NOYW1lIHx8IG5ldyBSZWdFeHAoXCIoXnxcXFxccylcIiArIGNsYXNzTmFtZSArIFwiKFxcXFxzfCQpXCIpLnRlc3QoZWxlbWVudENsYXNzTmFtZSkpO1xuICB9O1xufSkod3lzaWh0bWw1KTtcbnd5c2lodG1sNS5kb20uY29udGFpbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmIChkb2N1bWVudEVsZW1lbnQuY29udGFpbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRhaW5lciwgZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IHd5c2lodG1sNS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXIgIT09IGVsZW1lbnQgJiYgY29udGFpbmVyLmNvbnRhaW5zKGVsZW1lbnQpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9Ob2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4gICAgICByZXR1cm4gISEoY29udGFpbmVyLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQpICYgMTYpO1xuICAgIH07XG4gIH1cbn0oKTsgLyoqXG4gICAgICogQ29udmVydHMgYW4gSFRNTCBmcmFnbWVudC9lbGVtZW50IGludG8gYSB1bm9yZGVyZWQvb3JkZXJlZCBsaXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlIHR1cm5lZCBpbnRvIGEgbGlzdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaXN0VHlwZSBUaGUgbGlzdCB0eXBlIGluIHdoaWNoIHRvIGNvbnZlcnQgdGhlIHRyZWUgKGVpdGhlciBcInVsXCIgb3IgXCJvbFwiKVxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSBjcmVhdGVkIGxpc3RcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgPCEtLSBBc3N1bWUgdGhlIGZvbGxvd2luZyBkb206IC0tPlxuICAgICAqICAgIDxzcGFuIGlkPVwicHNldWRvLWxpc3RcIj5cbiAgICAgKiAgICAgIGVtaW5lbTxicj5cbiAgICAgKiAgICAgIGRyLiBkcmVcbiAgICAgKiAgICAgIDxkaXY+NTAgQ2VudDwvZGl2PlxuICAgICAqICAgIDwvc3Bhbj5cbiAgICAgKlxuICAgICAqICAgIDxzY3JpcHQ+XG4gICAgICogICAgICB3eXNpaHRtbDUuZG9tLmNvbnZlcnRUb0xpc3QoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwc2V1ZG8tbGlzdFwiKSwgXCJ1bFwiKTtcbiAgICAgKiAgICA8L3NjcmlwdD5cbiAgICAgKlxuICAgICAqICAgIDwhLS0gV2lsbCByZXN1bHQgaW46IC0tPlxuICAgICAqICAgIDx1bD5cbiAgICAgKiAgICAgIDxsaT5lbWluZW08L2xpPlxuICAgICAqICAgICAgPGxpPmRyLiBkcmU8L2xpPlxuICAgICAqICAgICAgPGxpPjUwIENlbnQ8L2xpPlxuICAgICAqICAgIDwvdWw+XG4gICAgICovXG53eXNpaHRtbDUuZG9tLmNvbnZlcnRUb0xpc3QgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9jcmVhdGVMaXN0SXRlbShkb2MsIGxpc3QpIHtcbiAgICB2YXIgbGlzdEl0ZW0gPSBkb2MuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgIGxpc3QuYXBwZW5kQ2hpbGQobGlzdEl0ZW0pO1xuICAgIHJldHVybiBsaXN0SXRlbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVMaXN0KGRvYywgdHlwZSkge1xuICAgIHJldHVybiBkb2MuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRUb0xpc3QoZWxlbWVudCwgbGlzdFR5cGUpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gXCJVTFwiIHx8IGVsZW1lbnQubm9kZU5hbWUgPT09IFwiT0xcIiB8fCBlbGVtZW50Lm5vZGVOYW1lID09PSBcIk1FTlVcIikge1xuICAgICAgLy8gQWxyZWFkeSBhIGxpc3RcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgIGxpc3QgPSBfY3JlYXRlTGlzdChkb2MsIGxpc3RUeXBlKSxcbiAgICAgICAgbGluZUJyZWFrcyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcImJyXCIpLFxuICAgICAgICBsaW5lQnJlYWtzTGVuZ3RoID0gbGluZUJyZWFrcy5sZW5ndGgsXG4gICAgICAgIGNoaWxkTm9kZXMsXG4gICAgICAgIGNoaWxkTm9kZXNMZW5ndGgsXG4gICAgICAgIGNoaWxkTm9kZSxcbiAgICAgICAgbGluZUJyZWFrLFxuICAgICAgICBwYXJlbnROb2RlLFxuICAgICAgICBpc0Jsb2NrRWxlbWVudCxcbiAgICAgICAgaXNMaW5lQnJlYWssXG4gICAgICAgIGN1cnJlbnRMaXN0SXRlbSxcbiAgICAgICAgaTtcblxuICAgIC8vIEZpcnN0IGZpbmQgPGJyPiBhdCB0aGUgZW5kIG9mIGlubGluZSBlbGVtZW50cyBhbmQgbW92ZSB0aGVtIGJlaGluZCB0aGVtXG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmVCcmVha3NMZW5ndGg7IGkrKykge1xuICAgICAgbGluZUJyZWFrID0gbGluZUJyZWFrc1tpXTtcbiAgICAgIHdoaWxlICgocGFyZW50Tm9kZSA9IGxpbmVCcmVhay5wYXJlbnROb2RlKSAmJiBwYXJlbnROb2RlICE9PSBlbGVtZW50ICYmIHBhcmVudE5vZGUubGFzdENoaWxkID09PSBsaW5lQnJlYWspIHtcbiAgICAgICAgaWYgKHd5c2lodG1sNS5kb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20ocGFyZW50Tm9kZSkgPT09IFwiYmxvY2tcIikge1xuICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluZUJyZWFrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB3eXNpaHRtbDUuZG9tLmluc2VydChsaW5lQnJlYWspLmFmdGVyKGxpbmVCcmVhay5wYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZE5vZGVzID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoZWxlbWVudC5jaGlsZE5vZGVzKS5nZXQoKTtcbiAgICBjaGlsZE5vZGVzTGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGROb2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgICBjdXJyZW50TGlzdEl0ZW0gPSBjdXJyZW50TGlzdEl0ZW0gfHwgX2NyZWF0ZUxpc3RJdGVtKGRvYywgbGlzdCk7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgaXNCbG9ja0VsZW1lbnQgPSB3eXNpaHRtbDUuZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKGNoaWxkTm9kZSkgPT09IFwiYmxvY2tcIjtcbiAgICAgIGlzTGluZUJyZWFrID0gY2hpbGROb2RlLm5vZGVOYW1lID09PSBcIkJSXCI7XG5cbiAgICAgIGlmIChpc0Jsb2NrRWxlbWVudCkge1xuICAgICAgICAvLyBBcHBlbmQgYmxvY2tFbGVtZW50IHRvIGN1cnJlbnQgPGxpPiBpZiBlbXB0eSwgb3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgY3VycmVudExpc3RJdGVtID0gY3VycmVudExpc3RJdGVtLmZpcnN0Q2hpbGQgPyBfY3JlYXRlTGlzdEl0ZW0oZG9jLCBsaXN0KSA6IGN1cnJlbnRMaXN0SXRlbTtcbiAgICAgICAgY3VycmVudExpc3RJdGVtLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgICAgIGN1cnJlbnRMaXN0SXRlbSA9IG51bGw7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNMaW5lQnJlYWspIHtcbiAgICAgICAgLy8gT25seSBjcmVhdGUgYSBuZXcgbGlzdCBpdGVtIGluIHRoZSBuZXh0IGl0ZXJhdGlvbiB3aGVuIHRoZSBjdXJyZW50IG9uZSBoYXMgYWxyZWFkeSBjb250ZW50XG4gICAgICAgIGN1cnJlbnRMaXN0SXRlbSA9IGN1cnJlbnRMaXN0SXRlbS5maXJzdENoaWxkID8gbnVsbCA6IGN1cnJlbnRMaXN0SXRlbTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRMaXN0SXRlbS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgIH1cblxuICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobGlzdCwgZWxlbWVudCk7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICByZXR1cm4gY29udmVydFRvTGlzdDtcbn0oKTsgLyoqXG4gICAgICogQ29weSBhIHNldCBvZiBhdHRyaWJ1dGVzIGZyb20gb25lIGVsZW1lbnQgdG8gYW5vdGhlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXR0cmlidXRlc1RvQ29weSBMaXN0IG9mIGF0dHJpYnV0ZXMgd2hpY2ggc2hvdWxkIGJlIGNvcGllZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2hpY2ggb2ZmZXJzIHRoZSBcImZyb21cIiBtZXRob2Qgd2hpY2ggY2FuIGJlIGludm9rZWQgd2l0aCB0aGUgZWxlbWVudCB3aGVyZSB0b1xuICAgICAqICAgIGNvcHkgdGhlIGF0dHJpYnV0ZXMgZnJvbS4sIHRoaXMgYWdhaW4gcmV0dXJucyBhbiBvYmplY3Qgd2hpY2ggcHJvdmlkZXMgYSBtZXRob2QgbmFtZWQgXCJ0b1wiIHdoaWNoIGNhbiBiZSBpbnZva2VkIFxuICAgICAqICAgIHdpdGggdGhlIGVsZW1lbnQgd2hlcmUgdG8gY29weSB0aGUgYXR0cmlidXRlcyB0byAoc2VlIGV4YW1wbGUpXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHZhciB0ZXh0YXJlYSAgICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0YXJlYVwiKSxcbiAgICAgKiAgICAgICAgZGl2ICAgICAgICAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiZGl2W2NvbnRlbnRlZGl0YWJsZT10cnVlXVwiKSxcbiAgICAgKiAgICAgICAgYW5vdGhlckRpdiAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiZGl2LnByZXZpZXdcIik7XG4gICAgICogICAgd3lzaWh0bWw1LmRvbS5jb3B5QXR0cmlidXRlcyhbXCJzcGVsbGNoZWNrXCIsIFwidmFsdWVcIiwgXCJwbGFjZWhvbGRlclwiXSkuZnJvbSh0ZXh0YXJlYSkudG8oZGl2KS5hbmRUbyhhbm90aGVyRGl2KTtcbiAgICAgKlxuICAgICAqL1xud3lzaWh0bWw1LmRvbS5jb3B5QXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVzVG9Db3B5KSB7XG4gIHJldHVybiB7XG4gICAgZnJvbTogZnVuY3Rpb24gZnJvbShlbGVtZW50VG9Db3B5RnJvbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG86IGZ1bmN0aW9uIHRvKGVsZW1lbnRUb0NvcHlUbykge1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGUsXG4gICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICBsZW5ndGggPSBhdHRyaWJ1dGVzVG9Db3B5Lmxlbmd0aDtcbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzVG9Db3B5W2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50VG9Db3B5RnJvbVthdHRyaWJ1dGVdICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW1lbnRUb0NvcHlGcm9tW2F0dHJpYnV0ZV0gIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgZWxlbWVudFRvQ29weVRvW2F0dHJpYnV0ZV0gPSBlbGVtZW50VG9Db3B5RnJvbVthdHRyaWJ1dGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBhbmRUbzogYXJndW1lbnRzLmNhbGxlZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IC8qKlxuICAgKiBDb3B5IGEgc2V0IG9mIHN0eWxlcyBmcm9tIG9uZSBlbGVtZW50IHRvIGFub3RoZXJcbiAgICogUGxlYXNlIG5vdGUgdGhhdCB0aGlzIG9ubHkgd29ya3MgcHJvcGVybHkgYWNyb3NzIGJyb3dzZXJzIHdoZW4gdGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBjb3B5IHRoZSBzdHlsZXNcbiAgICogaXMgaW4gdGhlIGRvbVxuICAgKlxuICAgKiBJbnRlcmVzdGluZyBhcnRpY2xlIG9uIGhvdyB0byBjb3B5IHN0eWxlc1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHlsZXNUb0NvcHkgTGlzdCBvZiBzdHlsZXMgd2hpY2ggc2hvdWxkIGJlIGNvcGllZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIG9mZmVycyB0aGUgXCJmcm9tXCIgbWV0aG9kIHdoaWNoIGNhbiBiZSBpbnZva2VkIHdpdGggdGhlIGVsZW1lbnQgd2hlcmUgdG9cbiAgICogICAgY29weSB0aGUgc3R5bGVzIGZyb20uLCB0aGlzIGFnYWluIHJldHVybnMgYW4gb2JqZWN0IHdoaWNoIHByb3ZpZGVzIGEgbWV0aG9kIG5hbWVkIFwidG9cIiB3aGljaCBjYW4gYmUgaW52b2tlZCBcbiAgICogICAgd2l0aCB0aGUgZWxlbWVudCB3aGVyZSB0byBjb3B5IHRoZSBzdHlsZXMgdG8gKHNlZSBleGFtcGxlKVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgICB2YXIgdGV4dGFyZWEgICAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwidGV4dGFyZWFcIiksXG4gICAqICAgICAgICBkaXYgICAgICAgICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJkaXZbY29udGVudGVkaXRhYmxlPXRydWVdXCIpLFxuICAgKiAgICAgICAgYW5vdGhlckRpdiAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiZGl2LnByZXZpZXdcIik7XG4gICAqICAgIHd5c2lodG1sNS5kb20uY29weVN0eWxlcyhbXCJvdmVyZmxvdy15XCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl0pLmZyb20odGV4dGFyZWEpLnRvKGRpdikuYW5kVG8oYW5vdGhlckRpdik7XG4gICAqXG4gICAqL1xuKGZ1bmN0aW9uIChkb20pIHtcblxuICAvKipcbiAgICogTW96aWxsYSwgV2ViS2l0IGFuZCBPcGVyYSByZWNhbGN1bGF0ZSB0aGUgY29tcHV0ZWQgd2lkdGggd2hlbiBib3gtc2l6aW5nOiBib2Rlci1ib3g7IGlzIHNldFxuICAgKiBTbyBpZiBhbiBlbGVtZW50IGhhcyBcIndpZHRoOiAyMDBweDsgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94OyBib3JkZXI6IDFweDtcIiB0aGVuIFxuICAgKiBpdHMgY29tcHV0ZWQgY3NzIHdpZHRoIHdpbGwgYmUgMTk4cHhcbiAgICovXG4gIHZhciBCT1hfU0laSU5HX1BST1BFUlRJRVMgPSBbXCItd2Via2l0LWJveC1zaXppbmdcIiwgXCItbW96LWJveC1zaXppbmdcIiwgXCItbXMtYm94LXNpemluZ1wiLCBcImJveC1zaXppbmdcIl07XG5cbiAgdmFyIHNob3VsZElnbm9yZUJveFNpemluZ0JvcmRlckJveCA9IGZ1bmN0aW9uIHNob3VsZElnbm9yZUJveFNpemluZ0JvcmRlckJveChlbGVtZW50KSB7XG4gICAgaWYgKGhhc0JveFNpemluZ0JvcmRlckJveChlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KGRvbS5nZXRTdHlsZShcIndpZHRoXCIpLmZyb20oZWxlbWVudCksIDEwKSA8IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB2YXIgaGFzQm94U2l6aW5nQm9yZGVyQm94ID0gZnVuY3Rpb24gaGFzQm94U2l6aW5nQm9yZGVyQm94KGVsZW1lbnQpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbmd0aCA9IEJPWF9TSVpJTkdfUFJPUEVSVElFUy5sZW5ndGg7XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGRvbS5nZXRTdHlsZShCT1hfU0laSU5HX1BST1BFUlRJRVNbaV0pLmZyb20oZWxlbWVudCkgPT09IFwiYm9yZGVyLWJveFwiKSB7XG4gICAgICAgIHJldHVybiBCT1hfU0laSU5HX1BST1BFUlRJRVNbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGRvbS5jb3B5U3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlc1RvQ29weSkge1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiBmdW5jdGlvbiBmcm9tKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUJveFNpemluZ0JvcmRlckJveChlbGVtZW50KSkge1xuICAgICAgICAgIHN0eWxlc1RvQ29weSA9IHd5c2lodG1sNS5sYW5nLmFycmF5KHN0eWxlc1RvQ29weSkud2l0aG91dChCT1hfU0laSU5HX1BST1BFUlRJRVMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNzc1RleHQgPSBcIlwiLFxuICAgICAgICAgICAgbGVuZ3RoID0gc3R5bGVzVG9Db3B5Lmxlbmd0aCxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgcHJvcGVydHk7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IHN0eWxlc1RvQ29weVtpXTtcbiAgICAgICAgICBjc3NUZXh0ICs9IHByb3BlcnR5ICsgXCI6XCIgKyBkb20uZ2V0U3R5bGUocHJvcGVydHkpLmZyb20oZWxlbWVudCkgKyBcIjtcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG86IGZ1bmN0aW9uIHRvKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHRfciA9IC9cXDtoZWlnaHRcXDovO1xuICAgICAgICAgICAgaWYgKGNzc1RleHQubWF0Y2goaGVpZ2h0X3IpICYmIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgbGlzdCA9IGNzc1RleHQuc3BsaXQoaGVpZ2h0X3IpO1xuICAgICAgICAgICAgICBoZWlnaHQgPSBwYXJzZUludChsaXN0WzFdLCAxMCk7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldEhlaWdodCA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGNzc1RleHQgPSBsaXN0WzBdICsgJ2hlaWdodDonICsgZWxlbWVudC5vZmZzZXRIZWlnaHQgKyAncHg7JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tLnNldFN0eWxlcyhjc3NUZXh0KS5vbihlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB7IGFuZFRvOiBhcmd1bWVudHMuY2FsbGVlIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG59KSh3eXNpaHRtbDUuZG9tKTsgLyoqXG4gICAgICAgICAgICAgICAgICAgKiBFdmVudCBEZWxlZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAqICAgIHd5c2lodG1sNS5kb20uZGVsZWdhdGUoZG9jdW1lbnQuYm9keSwgXCJhXCIsIFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIGZvb1xuICAgICAgICAgICAgICAgICAgICogICAgfSk7XG4gICAgICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG5cbiAgd3lzaWh0bWw1LmRvbS5kZWxlZ2F0ZSA9IGZ1bmN0aW9uIChjb250YWluZXIsIHNlbGVjdG9yLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gd3lzaWh0bWw1LmRvbS5vYnNlcnZlKGNvbnRhaW5lciwgZXZlbnROYW1lLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQsXG4gICAgICAgICAgbWF0Y2ggPSB3eXNpaHRtbDUubGFuZy5hcnJheShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuXG4gICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChtYXRjaC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRhcmdldCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSkod3lzaWh0bWw1KTsgLyoqXG4gICAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGdpdmVuIGh0bWwgd3JhcHBlZCBpbiBhIGRpdiBlbGVtZW50XG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIEZpeGluZyBJRSdzIGluYWJpbGl0eSB0byB0cmVhdCB1bmtub3duIGVsZW1lbnRzIChIVE1MNSBzZWN0aW9uLCBhcnRpY2xlLCAuLi4pIGNvcnJlY3RseVxuICAgICAgICAgICAgICAgKiB3aGVuIGluc2VydGVkIHZpYSBpbm5lckhUTUxcbiAgICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIFRoZSBodG1sIHdoaWNoIHNob3VsZCBiZSB3cmFwcGVkIGluIGEgZG9tIGVsZW1lbnRcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmVqY3R9IFtjb250ZXh0XSBEb2N1bWVudCBvYmplY3Qgb2YgdGhlIGNvbnRleHQgdGhlIGh0bWwgYmVsb25ncyB0b1xuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgKiAgICB3eXNpaHRtbDUuZG9tLmdldEFzRG9tKFwiPGFydGljbGU+Zm9vPC9hcnRpY2xlPlwiKTtcbiAgICAgICAgICAgICAgICovXG53eXNpaHRtbDUuZG9tLmdldEFzRG9tID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBfaW5uZXJIVE1MU2hpdiA9IGZ1bmN0aW9uIF9pbm5lckhUTUxTaGl2KGh0bWwsIGNvbnRleHQpIHtcbiAgICB2YXIgdGVtcEVsZW1lbnQgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGVtcEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIGNvbnRleHQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wRWxlbWVudCk7XG4gICAgLy8gSUUgdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIHRyeWluZyB0byBpbnNlcnQgPGZyYW1lc2V0PjwvZnJhbWVzZXQ+IHZpYSBpbm5lckhUTUxcbiAgICB0cnkge1xuICAgICAgdGVtcEVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGNvbnRleHQuYm9keS5yZW1vdmVDaGlsZCh0ZW1wRWxlbWVudCk7XG4gICAgcmV0dXJuIHRlbXBFbGVtZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIHN1cmUgSUUgc3VwcG9ydHMgSFRNTDUgdGFncywgd2hpY2ggaXMgYWNjb21wbGlzaGVkIGJ5IHNpbXBseSBjcmVhdGluZyBvbmUgaW5zdGFuY2Ugb2YgZWFjaCBlbGVtZW50XG4gICAqL1xuICB2YXIgX2Vuc3VyZUhUTUw1Q29tcGF0aWJpbGl0eSA9IGZ1bmN0aW9uIF9lbnN1cmVIVE1MNUNvbXBhdGliaWxpdHkoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0Ll93eXNpaHRtbDVfc3VwcG9ydHNIVE1MNVRhZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IEhUTUw1X0VMRU1FTlRTLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoSFRNTDVfRUxFTUVOVFNbaV0pO1xuICAgIH1cbiAgICBjb250ZXh0Ll93eXNpaHRtbDVfc3VwcG9ydHNIVE1MNVRhZ3MgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGh0bWw1IHRhZ3NcbiAgICogdGFrZW4gZnJvbSBodHRwOi8vc2ltb24uaHRtbDUub3JnL2h0bWw1LWVsZW1lbnRzXG4gICAqL1xuICB2YXIgSFRNTDVfRUxFTUVOVFMgPSBbXCJhYmJyXCIsIFwiYXJ0aWNsZVwiLCBcImFzaWRlXCIsIFwiYXVkaW9cIiwgXCJiZGlcIiwgXCJjYW52YXNcIiwgXCJjb21tYW5kXCIsIFwiZGF0YWxpc3RcIiwgXCJkZXRhaWxzXCIsIFwiZmlnY2FwdGlvblwiLCBcImZpZ3VyZVwiLCBcImZvb3RlclwiLCBcImhlYWRlclwiLCBcImhncm91cFwiLCBcImtleWdlblwiLCBcIm1hcmtcIiwgXCJtZXRlclwiLCBcIm5hdlwiLCBcIm91dHB1dFwiLCBcInByb2dyZXNzXCIsIFwicnBcIiwgXCJydFwiLCBcInJ1YnlcIiwgXCJzdmdcIiwgXCJzZWN0aW9uXCIsIFwic291cmNlXCIsIFwic3VtbWFyeVwiLCBcInRpbWVcIiwgXCJ0cmFja1wiLCBcInZpZGVvXCIsIFwid2JyXCJdO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoaHRtbCwgY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuICAgIHZhciB0ZW1wRWxlbWVudDtcbiAgICBpZiAoKHR5cGVvZiBodG1sID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoaHRtbCkpID09PSBcIm9iamVjdFwiICYmIGh0bWwubm9kZVR5cGUpIHtcbiAgICAgIHRlbXBFbGVtZW50ID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGVtcEVsZW1lbnQuYXBwZW5kQ2hpbGQoaHRtbCk7XG4gICAgfSBlbHNlIGlmICh3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c0hUTUw1VGFncyhjb250ZXh0KSkge1xuICAgICAgdGVtcEVsZW1lbnQgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0gZWxzZSB7XG4gICAgICBfZW5zdXJlSFRNTDVDb21wYXRpYmlsaXR5KGNvbnRleHQpO1xuICAgICAgdGVtcEVsZW1lbnQgPSBfaW5uZXJIVE1MU2hpdihodG1sLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBFbGVtZW50O1xuICB9O1xufSgpOyAvKipcbiAgICAgKiBXYWxrcyB0aGUgZG9tIHRyZWUgZnJvbSB0aGUgZ2l2ZW4gbm9kZSB1cCB1bnRpbCBpdCBmaW5kcyBhIG1hdGNoXG4gICAgICogRGVzaWduZWQgZm9yIG9wdGltYWwgcGVyZm9ybWFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgVGhlIGZyb20gd2hpY2ggdG8gY2hlY2sgdGhlIHBhcmVudCBub2Rlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaGluZ1NldCBPYmplY3QgdG8gbWF0Y2ggYWdhaW5zdCAocG9zc2libGUgcHJvcGVydGllczogbm9kZU5hbWUsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtsZXZlbHNdIEhvdyBtYW55IHBhcmVudHMgc2hvdWxkIHRoZSBmdW5jdGlvbiBjaGVjayB1cCBmcm9tIHRoZSBjdXJyZW50IG5vZGUgKGRlZmF1bHRzIHRvIDUwKVxuICAgICAqIEByZXR1cm4ge251bGx8RWxlbWVudH0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZWQgdGhlIGRlc2lyZWROb2RlTmFtZShzKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgdmFyIGxpc3RFbGVtZW50ID0gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJsaVwiKSwgeyBub2RlTmFtZTogW1wiTUVOVVwiLCBcIlVMXCIsIFwiT0xcIl0gfSk7XG4gICAgICogICAgLy8gLi4uIG9yIC4uLlxuICAgICAqICAgIHZhciB1bm9yZGVyZWRMaXN0RWxlbWVudCA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibGlcIiksIHsgbm9kZU5hbWU6IFwiVUxcIiB9KTtcbiAgICAgKiAgICAvLyAuLi4gb3IgLi4uXG4gICAgICogICAgdmFyIGNvbG9yZWRFbGVtZW50ID0gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KG15VGV4dE5vZGUsIHsgbm9kZU5hbWU6IFwiU1BBTlwiLCBjbGFzc05hbWU6IFwid3lzaXd5Zy1jb2xvci1yZWRcIiwgY2xhc3NSZWdFeHA6IC93eXNpd3lnLWNvbG9yLVthLXpdL2cgfSk7XG4gICAgICovXG53eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgZnVuY3Rpb24gX2lzU2FtZU5vZGVOYW1lKG5vZGVOYW1lLCBkZXNpcmVkTm9kZU5hbWVzKSB7XG4gICAgaWYgKCFkZXNpcmVkTm9kZU5hbWVzIHx8ICFkZXNpcmVkTm9kZU5hbWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXNpcmVkTm9kZU5hbWVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbm9kZU5hbWUgPT09IGRlc2lyZWROb2RlTmFtZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUubGFuZy5hcnJheShkZXNpcmVkTm9kZU5hbWVzKS5jb250YWlucyhub2RlTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2lzRWxlbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5FTEVNRU5UX05PREU7XG4gIH1cblxuICBmdW5jdGlvbiBfaGFzQ2xhc3NOYW1lKGVsZW1lbnQsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IChlbGVtZW50LmNsYXNzTmFtZSB8fCBcIlwiKS5tYXRjaChjbGFzc1JlZ0V4cCkgfHwgW107XG4gICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiAhIWNsYXNzTmFtZXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lc1tjbGFzc05hbWVzLmxlbmd0aCAtIDFdID09PSBjbGFzc05hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0UGFyZW50RWxlbWVudFdpdGhOb2RlTmFtZShub2RlLCBub2RlTmFtZSwgbGV2ZWxzKSB7XG4gICAgd2hpbGUgKGxldmVscy0tICYmIG5vZGUgJiYgbm9kZS5ub2RlTmFtZSAhPT0gXCJCT0RZXCIpIHtcbiAgICAgIGlmIChfaXNTYW1lTm9kZU5hbWUobm9kZS5ub2RlTmFtZSwgbm9kZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0UGFyZW50RWxlbWVudFdpdGhOb2RlTmFtZUFuZENsYXNzTmFtZShub2RlLCBub2RlTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCwgbGV2ZWxzKSB7XG4gICAgd2hpbGUgKGxldmVscy0tICYmIG5vZGUgJiYgbm9kZS5ub2RlTmFtZSAhPT0gXCJCT0RZXCIpIHtcbiAgICAgIGlmIChfaXNFbGVtZW50KG5vZGUpICYmIF9pc1NhbWVOb2RlTmFtZShub2RlLm5vZGVOYW1lLCBub2RlTmFtZSkgJiYgX2hhc0NsYXNzTmFtZShub2RlLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBtYXRjaGluZ1NldCwgbGV2ZWxzKSB7XG4gICAgbGV2ZWxzID0gbGV2ZWxzIHx8IDUwOyAvLyBHbyBtYXggNTAgbm9kZXMgdXB3YXJkcyBmcm9tIGN1cnJlbnQgbm9kZVxuICAgIGlmIChtYXRjaGluZ1NldC5jbGFzc05hbWUgfHwgbWF0Y2hpbmdTZXQuY2xhc3NSZWdFeHApIHtcbiAgICAgIHJldHVybiBfZ2V0UGFyZW50RWxlbWVudFdpdGhOb2RlTmFtZUFuZENsYXNzTmFtZShub2RlLCBtYXRjaGluZ1NldC5ub2RlTmFtZSwgbWF0Y2hpbmdTZXQuY2xhc3NOYW1lLCBtYXRjaGluZ1NldC5jbGFzc1JlZ0V4cCwgbGV2ZWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9nZXRQYXJlbnRFbGVtZW50V2l0aE5vZGVOYW1lKG5vZGUsIG1hdGNoaW5nU2V0Lm5vZGVOYW1lLCBsZXZlbHMpO1xuICAgIH1cbiAgfTtcbn0oKTtcbi8qKlxuICogR2V0IGVsZW1lbnQncyBzdHlsZSBmb3IgYSBzcGVjaWZpYyBjc3MgcHJvcGVydHlcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb24gd2hpY2ggdG8gcmV0cmlldmUgdGhlIHN0eWxlXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgVGhlIENTUyBwcm9wZXJ0eSB0byByZXRyaWV2ZSAoXCJmbG9hdFwiLCBcImRpc3BsYXlcIiwgXCJ0ZXh0LWFsaWduXCIsIC4uLilcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgd3lzaWh0bWw1LmRvbS5nZXRTdHlsZShcImRpc3BsYXlcIikuZnJvbShkb2N1bWVudC5ib2R5KTtcbiAqICAgIC8vID0+IFwiYmxvY2tcIlxuICovXG53eXNpaHRtbDUuZG9tLmdldFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3R5bGVQcm9wZXJ0eU1hcHBpbmcgPSB7XG4gICAgXCJmbG9hdFwiOiBcInN0eWxlRmxvYXRcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlID8gXCJzdHlsZUZsb2F0XCIgOiBcImNzc0Zsb2F0XCJcbiAgfSxcbiAgICAgIFJFR19FWFBfQ0FNRUxJWkUgPSAvXFwtW2Etel0vZztcblxuICBmdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoUkVHX0VYUF9DQU1FTElaRSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2guY2hhckF0KDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb206IGZ1bmN0aW9uIGZyb20oZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gd3lzaWh0bWw1LkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICBjYW1lbGl6ZWRQcm9wZXJ0eSA9IHN0eWxlUHJvcGVydHlNYXBwaW5nW3Byb3BlcnR5XSB8fCBjYW1lbGl6ZShwcm9wZXJ0eSksXG4gICAgICAgICAgICBzdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG4gICAgICAgICAgICBjdXJyZW50U3R5bGUgPSBlbGVtZW50LmN1cnJlbnRTdHlsZSxcbiAgICAgICAgICAgIHN0eWxlVmFsdWUgPSBzdHlsZVtjYW1lbGl6ZWRQcm9wZXJ0eV07XG4gICAgICAgIGlmIChzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjdXJyZW50U3R5bGUgaXMgbm8gc3RhbmRhcmQgYW5kIG9ubHkgc3VwcG9ydGVkIGJ5IE9wZXJhIGFuZCBJRSBidXQgaXQgaGFzIG9uZSBpbXBvcnRhbnQgYWR2YW50YWdlIG92ZXIgdGhlIHN0YW5kYXJkLWNvbXBsaWFudFxuICAgICAgICAvLyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSwgc2luY2UgaXQgcmV0dXJucyBjc3MgcHJvcGVydHkgdmFsdWVzIGluIHRoZWlyIG9yaWdpbmFsIHVuaXQ6XG4gICAgICAgIC8vIElmIHlvdSBzZXQgYW4gZWxlbWVudHMgd2lkdGggdG8gXCI1MCVcIiwgd2luZG93LmdldENvbXB1dGVkU3R5bGUgd2lsbCBnaXZlIHlvdSBpdCdzIGN1cnJlbnQgd2lkdGggaW4gcHggd2hpbGUgY3VycmVudFN0eWxlXG4gICAgICAgIC8vIGdpdmVzIHlvdSB0aGUgb3JpZ2luYWwgXCI1MCVcIi5cbiAgICAgICAgLy8gT3BlcmEgc3VwcG9ydHMgYm90aCwgY3VycmVudFN0eWxlIGFuZCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSwgdGhhdCdzIHdoeSBjaGVja2luZyBmb3IgY3VycmVudFN0eWxlIHNob3VsZCBoYXZlIGhpZ2hlciBwcmlvXG4gICAgICAgIGlmIChjdXJyZW50U3R5bGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTdHlsZVtjYW1lbGl6ZWRQcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy9pZSB3aWxsIG9jY2FzaW9uYWxseSBmYWlsIGZvciB1bmtub3duIHJlYXNvbnMuIHN3YWxsb3dpbmcgZXhjZXB0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93LFxuICAgICAgICAgICAgbmVlZHNPdmVyZmxvd1Jlc2V0ID0gKHByb3BlcnR5ID09PSBcImhlaWdodFwiIHx8IHByb3BlcnR5ID09PSBcIndpZHRoXCIpICYmIGVsZW1lbnQubm9kZU5hbWUgPT09IFwiVEVYVEFSRUFcIixcbiAgICAgICAgICAgIG9yaWdpbmFsT3ZlcmZsb3csXG4gICAgICAgICAgICByZXR1cm5WYWx1ZTtcblxuICAgICAgICBpZiAod2luLmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSBib3RoIGNhbGN1bGF0ZSBhIHdyb25nIHdpZHRoIGFuZCBoZWlnaHQgZm9yIHRleHRhcmVhcyB3aGVuIHRoZXkgaGF2ZSBzY3JvbGwgYmFyc1xuICAgICAgICAgIC8vIHRoZXJmb3JlIHdlIHJlbW92ZSBhbmQgcmVzdG9yZSB0aGUgc2Nyb2xsYmFyIGFuZCBjYWxjdWxhdGUgdGhlIHZhbHVlIGluIGJldHdlZW5cbiAgICAgICAgICBpZiAobmVlZHNPdmVyZmxvd1Jlc2V0KSB7XG4gICAgICAgICAgICBvcmlnaW5hbE92ZXJmbG93ID0gc3R5bGUub3ZlcmZsb3c7XG4gICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVyblZhbHVlID0gd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gICAgICAgICAgaWYgKG5lZWRzT3ZlcmZsb3dSZXNldCkge1xuICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBvcmlnaW5hbE92ZXJmbG93IHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH07XG59KCk7IC8qKlxuICAgICAqIEhpZ2ggcGVyZm9ybWFudCB3YXkgdG8gY2hlY2sgd2hldGhlciBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpYyB0YWcgbmFtZSBpcyBpbiB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAgICAgKiBPcHRpbWl6ZWQgZm9yIGJlaW5nIGhlYXZpbHkgZXhlY3V0ZWRcbiAgICAgKiBVbmxlYXNoZXMgdGhlIHBvd2VyIG9mIGxpdmUgbm9kZSBsaXN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRvYyBUaGUgZG9jdW1lbnQgb2JqZWN0IG9mIHRoZSBjb250ZXh0IHdoZXJlIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWUgVXBwZXIgY2FzZWQgdGFnIG5hbWVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHd5c2lodG1sNS5kb20uaGFzRWxlbWVudFdpdGhUYWdOYW1lKGRvY3VtZW50LCBcIklNR1wiKTtcbiAgICAgKi9cbnd5c2lodG1sNS5kb20uaGFzRWxlbWVudFdpdGhUYWdOYW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgTElWRV9DQUNIRSA9IHt9LFxuICAgICAgRE9DVU1FTlRfSURFTlRJRklFUiA9IDE7XG5cbiAgZnVuY3Rpb24gX2dldERvY3VtZW50SWRlbnRpZmllcihkb2MpIHtcbiAgICByZXR1cm4gZG9jLl93eXNpaHRtbDVfaWRlbnRpZmllciB8fCAoZG9jLl93eXNpaHRtbDVfaWRlbnRpZmllciA9IERPQ1VNRU5UX0lERU5USUZJRVIrKyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGRvYywgdGFnTmFtZSkge1xuICAgIHZhciBrZXkgPSBfZ2V0RG9jdW1lbnRJZGVudGlmaWVyKGRvYykgKyBcIjpcIiArIHRhZ05hbWUsXG4gICAgICAgIGNhY2hlRW50cnkgPSBMSVZFX0NBQ0hFW2tleV07XG4gICAgaWYgKCFjYWNoZUVudHJ5KSB7XG4gICAgICBjYWNoZUVudHJ5ID0gTElWRV9DQUNIRVtrZXldID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZUVudHJ5Lmxlbmd0aCA+IDA7XG4gIH07XG59KCk7IC8qKlxuICAgICAqIEhpZ2ggcGVyZm9ybWFudCB3YXkgdG8gY2hlY2sgd2hldGhlciBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpYyBjbGFzcyBuYW1lIGlzIGluIHRoZSBnaXZlbiBkb2N1bWVudFxuICAgICAqIE9wdGltaXplZCBmb3IgYmVpbmcgaGVhdmlseSBleGVjdXRlZFxuICAgICAqIFVubGVhc2hlcyB0aGUgcG93ZXIgb2YgbGl2ZSBub2RlIGxpc3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZG9jIFRoZSBkb2N1bWVudCBvYmplY3Qgb2YgdGhlIGNvbnRleHQgd2hlcmUgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZSBVcHBlciBjYXNlZCB0YWcgbmFtZVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1LmRvbS5oYXNFbGVtZW50V2l0aENsYXNzTmFtZShkb2N1bWVudCwgXCJmb29iYXJcIik7XG4gICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgTElWRV9DQUNIRSA9IHt9LFxuICAgICAgRE9DVU1FTlRfSURFTlRJRklFUiA9IDE7XG5cbiAgZnVuY3Rpb24gX2dldERvY3VtZW50SWRlbnRpZmllcihkb2MpIHtcbiAgICByZXR1cm4gZG9jLl93eXNpaHRtbDVfaWRlbnRpZmllciB8fCAoZG9jLl93eXNpaHRtbDVfaWRlbnRpZmllciA9IERPQ1VNRU5UX0lERU5USUZJRVIrKyk7XG4gIH1cblxuICB3eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoQ2xhc3NOYW1lID0gZnVuY3Rpb24gKGRvYywgY2xhc3NOYW1lKSB7XG4gICAgLy8gZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFPDlcbiAgICAvLyBidXQgaXMgc29tZXRpbWVzIG1vY2tlZCB2aWEgbGlicmFyeSBjb2RlICh3aGljaCB0aGVuIGRvZXNuJ3QgcmV0dXJuIGxpdmUgbm9kZSBsaXN0cylcbiAgICBpZiAoIXd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzTmF0aXZlR2V0RWxlbWVudHNCeUNsYXNzTmFtZSgpKSB7XG4gICAgICByZXR1cm4gISFkb2MucXVlcnlTZWxlY3RvcihcIi5cIiArIGNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IF9nZXREb2N1bWVudElkZW50aWZpZXIoZG9jKSArIFwiOlwiICsgY2xhc3NOYW1lLFxuICAgICAgICBjYWNoZUVudHJ5ID0gTElWRV9DQUNIRVtrZXldO1xuICAgIGlmICghY2FjaGVFbnRyeSkge1xuICAgICAgY2FjaGVFbnRyeSA9IExJVkVfQ0FDSEVba2V5XSA9IGRvYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlRW50cnkubGVuZ3RoID4gMDtcbiAgfTtcbn0pKHd5c2lodG1sNSk7XG53eXNpaHRtbDUuZG9tLmluc2VydCA9IGZ1bmN0aW9uIChlbGVtZW50VG9JbnNlcnQpIHtcbiAgcmV0dXJuIHtcbiAgICBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIoZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50VG9JbnNlcnQsIGVsZW1lbnQubmV4dFNpYmxpbmcpO1xuICAgIH0sXG5cbiAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZShlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnRUb0luc2VydCwgZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGludG86IGZ1bmN0aW9uIGludG8oZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50VG9JbnNlcnQpO1xuICAgIH1cbiAgfTtcbn07d3lzaWh0bWw1LmRvbS5pbnNlcnRDU1MgPSBmdW5jdGlvbiAocnVsZXMpIHtcbiAgcnVsZXMgPSBydWxlcy5qb2luKFwiXFxuXCIpO1xuXG4gIHJldHVybiB7XG4gICAgaW50bzogZnVuY3Rpb24gaW50byhkb2MpIHtcbiAgICAgIHZhciBoZWFkID0gZG9jLmhlYWQgfHwgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXSxcbiAgICAgICAgICBzdHlsZUVsZW1lbnQgPSBkb2MuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG4gICAgICBzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuICAgICAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBydWxlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUocnVsZXMpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07IC8qKlxuICAgKiBNZXRob2QgdG8gc2V0IGRvbSBldmVudHNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgd3lzaWh0bWw1LmRvbS5vYnNlcnZlKGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50LmJvZHksIFtcImZvY3VzXCIsIFwiYmx1clwiXSwgZnVuY3Rpb24oKSB7IC4uLiB9KTtcbiAgICovXG53eXNpaHRtbDUuZG9tLm9ic2VydmUgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lcywgaGFuZGxlcikge1xuICBldmVudE5hbWVzID0gdHlwZW9mIGV2ZW50TmFtZXMgPT09IFwic3RyaW5nXCIgPyBbZXZlbnROYW1lc10gOiBldmVudE5hbWVzO1xuXG4gIHZhciBoYW5kbGVyV3JhcHBlcixcbiAgICAgIGV2ZW50TmFtZSxcbiAgICAgIGkgPSAwLFxuICAgICAgbGVuZ3RoID0gZXZlbnROYW1lcy5sZW5ndGg7XG5cbiAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZXNbaV07XG4gICAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVyV3JhcHBlciA9IGZ1bmN0aW9uIGhhbmRsZXJXcmFwcGVyKGV2ZW50KSB7XG4gICAgICAgIGlmICghKFwidGFyZ2V0XCIgaW4gZXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQuc3JjRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IGV2ZW50LnByZXZlbnREZWZhdWx0IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGV2ZW50LnN0b3BQcm9wYWdhdGlvbiB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBoYW5kbGVyLmNhbGwoZWxlbWVudCwgZXZlbnQpO1xuICAgICAgfTtcbiAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoXCJvblwiICsgZXZlbnROYW1lLCBoYW5kbGVyV3JhcHBlcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdmFyIGV2ZW50TmFtZSxcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBldmVudE5hbWVzLmxlbmd0aDtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lc1tpXTtcbiAgICAgICAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LmRldGFjaEV2ZW50KFwib25cIiArIGV2ZW50TmFtZSwgaGFuZGxlcldyYXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcbi8qKlxuICogSFRNTCBTYW5pdGl6ZXJcbiAqIFJld3JpdGVzIHRoZSBIVE1MIGJhc2VkIG9uIGdpdmVuIHJ1bGVzXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxlbWVudE9ySHRtbCBIVE1MIFN0cmluZyB0byBiZSBzYW5pdGl6ZWQgT1IgZWxlbWVudCB3aG9zZSBjb250ZW50IHNob3VsZCBiZSBzYW5pdGl6ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcnVsZXNdIExpc3Qgb2YgcnVsZXMgZm9yIHJld3JpdGluZyB0aGUgSFRNTCwgaWYgdGhlcmUncyBubyBydWxlIGZvciBhbiBlbGVtZW50IGl0IHdpbGxcbiAqICAgIGJlIGNvbnZlcnRlZCB0byBhIFwic3BhblwiLiBFYWNoIHJ1bGUgaXMgYSBrZXkvdmFsdWUgcGFpciB3aGVyZSBrZXkgaXMgdGhlIHRhZyB0byBjb252ZXJ0LCBhbmQgdmFsdWUgdGhlXG4gKiAgICBkZXNpcmVkIHN1YnN0aXR1dGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IERvY3VtZW50IG9iamVjdCBpbiB3aGljaCB0byBwYXJzZSB0aGUgaHRtbCwgbmVlZGVkIHRvIHNhbmRib3ggdGhlIHBhcnNpbmdcbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fFN0cmluZ30gRGVwZW5kcyBvbiB0aGUgZWxlbWVudE9ySHRtbCBwYXJhbWV0ZXIuIFdoZW4gaHRtbCB0aGVuIHRoZSBzYW5pdGl6ZWQgaHRtbCBhcyBzdHJpbmcgZWxzZXdpc2UgdGhlIGVsZW1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIHZhciB1c2VySFRNTCA9ICc8ZGl2IGlkPVwiZm9vXCIgb25jbGljaz1cImFsZXJ0KDEpO1wiPjxwPjxmb250IGNvbG9yPVwicmVkXCI+Zm9vPC9mb250PjxzY3JpcHQ+YWxlcnQoMSk7PC9zY3JpcHQ+PC9wPjwvZGl2Pic7XG4gKiAgICB3eXNpaHRtbDUuZG9tLnBhcnNlKHVzZXJIVE1MLCB7XG4gKiAgICAgIHRhZ3Mge1xuICogICAgICAgIHA6ICAgICAgXCJkaXZcIiwgICAgICAvLyBSZW5hbWUgcCB0YWdzIHRvIGRpdiB0YWdzXG4gKiAgICAgICAgZm9udDogICBcInNwYW5cIiAgICAgIC8vIFJlbmFtZSBmb250IHRhZ3MgdG8gc3BhbiB0YWdzXG4gKiAgICAgICAgZGl2OiAgICB0cnVlLCAgICAgICAvLyBLZWVwIHRoZW0sIGFsc28gcG9zc2libGUgKHNhbWUgcmVzdWx0IHdoZW4gcGFzc2luZzogXCJkaXZcIiBvciB0cnVlKVxuICogICAgICAgIHNjcmlwdDogdW5kZWZpbmVkICAgLy8gUmVtb3ZlIHNjcmlwdCBlbGVtZW50c1xuICogICAgICB9XG4gKiAgICB9KTtcbiAqICAgIC8vID0+IDxkaXY+PGRpdj48c3Bhbj5mb28gYmFyPC9zcGFuPjwvZGl2PjwvZGl2PlxuICpcbiAqICAgIHZhciB1c2VySFRNTCA9ICc8dGFibGU+PHRib2R5Pjx0cj48dGQ+SSdtIGEgdGFibGUhPC90ZD48L3RyPjwvdGJvZHk+PC90YWJsZT4nO1xuICogICAgd3lzaWh0bWw1LmRvbS5wYXJzZSh1c2VySFRNTCk7XG4gKiAgICAvLyA9PiAnPHNwYW4+PHNwYW4+PHNwYW4+PHNwYW4+SSdtIGEgdGFibGUhPC9zcGFuPjwvc3Bhbj48L3NwYW4+PC9zcGFuPidcbiAqXG4gKiAgICB2YXIgdXNlckhUTUwgPSAnPGRpdj5mb29iYXI8YnI+Zm9vYmFyPC9kaXY+JztcbiAqICAgIHd5c2lodG1sNS5kb20ucGFyc2UodXNlckhUTUwsIHtcbiAqICAgICAgdGFnczoge1xuICogICAgICAgIGRpdjogdW5kZWZpbmVkLFxuICogICAgICAgIGJyOiAgdHJ1ZVxuICogICAgICB9XG4gKiAgICB9KTtcbiAqICAgIC8vID0+ICcnXG4gKlxuICogICAgdmFyIHVzZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJyZWRcIj5mb288L2Rpdj48ZGl2IGNsYXNzPVwicGlua1wiPmJhcjwvZGl2Pic7XG4gKiAgICB3eXNpaHRtbDUuZG9tLnBhcnNlKHVzZXJIVE1MLCB7XG4gKiAgICAgIGNsYXNzZXM6IHtcbiAqICAgICAgICByZWQ6ICAgIDEsXG4gKiAgICAgICAgZ3JlZW46ICAxXG4gKiAgICAgIH0sXG4gKiAgICAgIHRhZ3M6IHtcbiAqICAgICAgICBkaXY6IHtcbiAqICAgICAgICAgIHJlbmFtZV90YWc6ICAgICBcInBcIlxuICogICAgICAgIH1cbiAqICAgICAgfVxuICogICAgfSk7XG4gKiAgICAvLyA9PiAnPHAgY2xhc3M9XCJyZWRcIj5mb288L3A+PHA+YmFyPC9wPidcbiAqL1xud3lzaWh0bWw1LmRvbS5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGEgWE1MUGFyc2VyL0RPTVBhcnNlciBhcyBIVE1MNSBpcyBub3QgYWx3YXlzIHdlbGwtZm9ybWVkIFhNTFxuICAgKiBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKCc8aW1nIHNyYz1cImZvby5naWZcIj4nKSB3aWxsIGNhdXNlIGEgcGFyc2VFcnJvciBzaW5jZSB0aGVcbiAgICogbm9kZSBpc24ndCBjbG9zZWRcbiAgICpcbiAgICogVGhlcmVmb3JlIHdlJ3ZlIHRvIHVzZSB0aGUgYnJvd3NlcidzIG9yZGluYXJ5IEhUTUwgcGFyc2VyIGludm9rZWQgYnkgc2V0dGluZyBpbm5lckhUTUwuXG4gICAqL1xuICB2YXIgTk9ERV9UWVBFX01BUFBJTkcgPSB7XG4gICAgXCIxXCI6IF9oYW5kbGVFbGVtZW50LFxuICAgIFwiM1wiOiBfaGFuZGxlVGV4dFxuICB9LFxuXG4gIC8vIFJlbmFtZSB1bmtub3duIHRhZ3MgdG8gdGhpc1xuICBERUZBVUxUX05PREVfTkFNRSA9IFwic3BhblwiLFxuICAgICAgV0hJVEVfU1BBQ0VfUkVHX0VYUCA9IC9cXHMrLyxcbiAgICAgIGRlZmF1bHRSdWxlcyA9IHsgdGFnczoge30sIGNsYXNzZXM6IHt9IH0sXG4gICAgICBjdXJyZW50UnVsZXMgPSB7fTtcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBhbGwgY2hpbGRzIG9mIHRoZSBlbGVtZW50LCByZWNyZWF0ZXMgdGhlbSwgYXBwZW5kcyB0aGVtIGludG8gYSBkb2N1bWVudCBmcmFnbWVudFxuICAgKiB3aGljaCBsYXRlciByZXBsYWNlcyB0aGUgZW50aXJlIGJvZHkgY29udGVudFxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2UoZWxlbWVudE9ySHRtbCwgcnVsZXMsIGNvbnRleHQsIGNsZWFuVXApIHtcbiAgICB3eXNpaHRtbDUubGFuZy5vYmplY3QoY3VycmVudFJ1bGVzKS5tZXJnZShkZWZhdWx0UnVsZXMpLm1lcmdlKHJ1bGVzKS5nZXQoKTtcblxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGVsZW1lbnRPckh0bWwub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICB2YXIgZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgaXNTdHJpbmcgPSB0eXBlb2YgZWxlbWVudE9ySHRtbCA9PT0gXCJzdHJpbmdcIixcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgbmV3Tm9kZSxcbiAgICAgICAgZmlyc3RDaGlsZDtcblxuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgZWxlbWVudCA9IHd5c2lodG1sNS5kb20uZ2V0QXNEb20oZWxlbWVudE9ySHRtbCwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50T3JIdG1sO1xuICAgIH1cblxuICAgIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGZpcnN0Q2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgICAgbmV3Tm9kZSA9IF9jb252ZXJ0KGZpcnN0Q2hpbGQsIGNsZWFuVXApO1xuICAgICAgaWYgKG5ld05vZGUpIHtcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgZWxlbWVudCBjb250ZW50c1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcblxuICAgIC8vIEluc2VydCBuZXcgRE9NIHRyZWVcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcblxuICAgIHJldHVybiBpc1N0cmluZyA/IHd5c2lodG1sNS5xdWlya3MuZ2V0Q29ycmVjdElubmVySFRNTChlbGVtZW50KSA6IGVsZW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBfY29udmVydChvbGROb2RlLCBjbGVhblVwKSB7XG4gICAgdmFyIG9sZE5vZGVUeXBlID0gb2xkTm9kZS5ub2RlVHlwZSxcbiAgICAgICAgb2xkQ2hpbGRzID0gb2xkTm9kZS5jaGlsZE5vZGVzLFxuICAgICAgICBvbGRDaGlsZHNMZW5ndGggPSBvbGRDaGlsZHMubGVuZ3RoLFxuICAgICAgICBuZXdOb2RlLFxuICAgICAgICBtZXRob2QgPSBOT0RFX1RZUEVfTUFQUElOR1tvbGROb2RlVHlwZV0sXG4gICAgICAgIGkgPSAwO1xuXG4gICAgbmV3Tm9kZSA9IG1ldGhvZCAmJiBtZXRob2Qob2xkTm9kZSk7XG5cbiAgICBpZiAoIW5ld05vZGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBvbGRDaGlsZHNMZW5ndGg7IGkrKykge1xuICAgICAgbmV3Q2hpbGQgPSBfY29udmVydChvbGRDaGlsZHNbaV0sIGNsZWFuVXApO1xuICAgICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICAgIG5ld05vZGUuYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFudXAgc2Vuc2VsZXNzIDxzcGFuPiBlbGVtZW50c1xuICAgIGlmIChjbGVhblVwICYmIG5ld05vZGUuY2hpbGROb2Rlcy5sZW5ndGggPD0gMSAmJiBuZXdOb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IERFRkFVTFRfTk9ERV9OQU1FICYmICFuZXdOb2RlLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3Tm9kZS5maXJzdENoaWxkO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2hhbmRsZUVsZW1lbnQob2xkTm9kZSkge1xuICAgIHZhciBydWxlLFxuICAgICAgICBuZXdOb2RlLFxuICAgICAgICBlbmRUYWcsXG4gICAgICAgIHRhZ1J1bGVzID0gY3VycmVudFJ1bGVzLnRhZ3MsXG4gICAgICAgIG5vZGVOYW1lID0gb2xkTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBzY29wZU5hbWUgPSBvbGROb2RlLnNjb3BlTmFtZTtcblxuICAgIC8qKlxuICAgICAqIFdlIGFscmVhZHkgcGFyc2VkIHRoYXQgZWxlbWVudFxuICAgICAqIGlnbm9yZSBpdCEgKHllcywgdGhpcyBzb21ldGltZXMgaGFwcGVucyBpbiBJRTggd2hlbiB0aGUgaHRtbCBpcyBpbnZhbGlkKVxuICAgICAqL1xuICAgIGlmIChvbGROb2RlLl93eXNpaHRtbDUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBvbGROb2RlLl93eXNpaHRtbDUgPSAxO1xuXG4gICAgaWYgKG9sZE5vZGUuY2xhc3NOYW1lID09PSBcInd5c2lodG1sNS10ZW1wXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElFIGlzIHRoZSBvbmx5IGJyb3dzZXIgd2hvIGRvZXNuJ3QgaW5jbHVkZSB0aGUgbmFtZXNwYWNlIGluIHRoZVxuICAgICAqIG5vZGVOYW1lLCB0aGF0J3Mgd2h5IHdlIGhhdmUgdG8gcHJlcGVuZCBpdCBieSBvdXJzZWx2ZXNcbiAgICAgKiBzY29wZU5hbWUgaXMgYSBwcm9wcmlldGFyeSBJRSBmZWF0dXJlXG4gICAgICogcmVhZCBtb3JlIGhlcmUgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM0Mzg4KHY9dnMuODUpLmFzcHhcbiAgICAgKi9cbiAgICBpZiAoc2NvcGVOYW1lICYmIHNjb3BlTmFtZSAhPSBcIkhUTUxcIikge1xuICAgICAgbm9kZU5hbWUgPSBzY29wZU5hbWUgKyBcIjpcIiArIG5vZGVOYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGFpciBub2RlXG4gICAgICogSUUgaXMgYSBiaXQgYml0Y2h5IHdoZW4gaXQgY29tZXMgdG8gaW52YWxpZCBuZXN0ZWQgbWFya3VwIHdoaWNoIGluY2x1ZGVzIHVuY2xvc2VkIHRhZ3NcbiAgICAgKiBBIDxwPiBkb2Vzbid0IG5lZWQgdG8gYmUgY2xvc2VkIGFjY29yZGluZyBIVE1MNC01IHNwZWMsIHdlIHNpbXBseSByZXBsYWNlIGl0IHdpdGggYSA8ZGl2PiB0byBwcmVzZXJ2ZSBpdHMgY29udGVudCBhbmQgbGF5b3V0XG4gICAgICovXG4gICAgaWYgKFwib3V0ZXJIVE1MXCIgaW4gb2xkTm9kZSkge1xuICAgICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5hdXRvQ2xvc2VzVW5jbG9zZWRUYWdzKCkgJiYgb2xkTm9kZS5ub2RlTmFtZSA9PT0gXCJQXCIgJiYgb2xkTm9kZS5vdXRlckhUTUwuc2xpY2UoLTQpLnRvTG93ZXJDYXNlKCkgIT09IFwiPC9wPlwiKSB7XG4gICAgICAgIG5vZGVOYW1lID0gXCJkaXZcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZU5hbWUgaW4gdGFnUnVsZXMpIHtcbiAgICAgIHJ1bGUgPSB0YWdSdWxlc1tub2RlTmFtZV07XG4gICAgICBpZiAoIXJ1bGUgfHwgcnVsZS5yZW1vdmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJ1bGUgPSB0eXBlb2YgcnVsZSA9PT0gXCJzdHJpbmdcIiA/IHsgcmVuYW1lX3RhZzogcnVsZSB9IDogcnVsZTtcbiAgICB9IGVsc2UgaWYgKG9sZE5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgcnVsZSA9IHsgcmVuYW1lX3RhZzogREVGQVVMVF9OT0RFX05BTUUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIGVtcHR5IHVua25vd24gZWxlbWVudHNcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG5ld05vZGUgPSBvbGROb2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChydWxlLnJlbmFtZV90YWcgfHwgbm9kZU5hbWUpO1xuICAgIF9oYW5kbGVBdHRyaWJ1dGVzKG9sZE5vZGUsIG5ld05vZGUsIHJ1bGUpO1xuXG4gICAgb2xkTm9kZSA9IG51bGw7XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBfaGFuZGxlQXR0cmlidXRlcyhvbGROb2RlLCBuZXdOb2RlLCBydWxlKSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fSxcbiAgICAgICAgLy8gZnJlc2ggbmV3IHNldCBvZiBhdHRyaWJ1dGVzIHRvIHNldCBvbiBuZXdOb2RlXG4gICAgc2V0Q2xhc3MgPSBydWxlLnNldF9jbGFzcyxcbiAgICAgICAgLy8gY2xhc3NlcyB0byBzZXRcbiAgICBhZGRDbGFzcyA9IHJ1bGUuYWRkX2NsYXNzLFxuICAgICAgICAvLyBhZGQgY2xhc3NlcyBiYXNlZCBvbiBleGlzdGluZyBhdHRyaWJ1dGVzXG4gICAgc2V0QXR0cmlidXRlcyA9IHJ1bGUuc2V0X2F0dHJpYnV0ZXMsXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMgdG8gc2V0IG9uIHRoZSBjdXJyZW50IG5vZGVcbiAgICBjaGVja0F0dHJpYnV0ZXMgPSBydWxlLmNoZWNrX2F0dHJpYnV0ZXMsXG4gICAgICAgIC8vIGNoZWNrL2NvbnZlcnQgdmFsdWVzIG9mIGF0dHJpYnV0ZXNcbiAgICBhbGxvd2VkQ2xhc3NlcyA9IGN1cnJlbnRSdWxlcy5jbGFzc2VzLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgY2xhc3NlcyA9IFtdLFxuICAgICAgICBuZXdDbGFzc2VzID0gW10sXG4gICAgICAgIG5ld1VuaXF1ZUNsYXNzZXMgPSBbXSxcbiAgICAgICAgb2xkQ2xhc3NlcyA9IFtdLFxuICAgICAgICBjbGFzc2VzTGVuZ3RoLFxuICAgICAgICBuZXdDbGFzc2VzTGVuZ3RoLFxuICAgICAgICBjdXJyZW50Q2xhc3MsXG4gICAgICAgIG5ld0NsYXNzLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lLFxuICAgICAgICBuZXdBdHRyaWJ1dGVWYWx1ZSxcbiAgICAgICAgbWV0aG9kO1xuXG4gICAgaWYgKHNldEF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSB3eXNpaHRtbDUubGFuZy5vYmplY3Qoc2V0QXR0cmlidXRlcykuY2xvbmUoKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBdHRyaWJ1dGVzKSB7XG4gICAgICBmb3IgKGF0dHJpYnV0ZU5hbWUgaW4gY2hlY2tBdHRyaWJ1dGVzKSB7XG4gICAgICAgIG1ldGhvZCA9IGF0dHJpYnV0ZUNoZWNrTWV0aG9kc1tjaGVja0F0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV1dO1xuICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5ld0F0dHJpYnV0ZVZhbHVlID0gbWV0aG9kKF9nZXRBdHRyaWJ1dGUob2xkTm9kZSwgYXR0cmlidXRlTmFtZSkpO1xuICAgICAgICBpZiAodHlwZW9mIG5ld0F0dHJpYnV0ZVZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IG5ld0F0dHJpYnV0ZVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNldENsYXNzKSB7XG4gICAgICBjbGFzc2VzLnB1c2goc2V0Q2xhc3MpO1xuICAgIH1cblxuICAgIGlmIChhZGRDbGFzcykge1xuICAgICAgZm9yIChhdHRyaWJ1dGVOYW1lIGluIGFkZENsYXNzKSB7XG4gICAgICAgIG1ldGhvZCA9IGFkZENsYXNzTWV0aG9kc1thZGRDbGFzc1thdHRyaWJ1dGVOYW1lXV07XG4gICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbmV3Q2xhc3MgPSBtZXRob2QoX2dldEF0dHJpYnV0ZShvbGROb2RlLCBhdHRyaWJ1dGVOYW1lKSk7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3Q2xhc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjbGFzc2VzLnB1c2gobmV3Q2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgd3lzaWh0bWw1IHRlbXAgY2xhc3MgZG9lc24ndCBnZXQgc3RyaXBwZWQgb3V0XG4gICAgYWxsb3dlZENsYXNzZXNbXCJfd3lzaWh0bWw1LXRlbXAtcGxhY2Vob2xkZXJcIl0gPSAxO1xuXG4gICAgLy8gYWRkIG9sZCBjbGFzc2VzIGxhc3RcbiAgICBvbGRDbGFzc2VzID0gb2xkTm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICBpZiAob2xkQ2xhc3Nlcykge1xuICAgICAgY2xhc3NlcyA9IGNsYXNzZXMuY29uY2F0KG9sZENsYXNzZXMuc3BsaXQoV0hJVEVfU1BBQ0VfUkVHX0VYUCkpO1xuICAgIH1cbiAgICBjbGFzc2VzTGVuZ3RoID0gY2xhc3Nlcy5sZW5ndGg7XG4gICAgZm9yICg7IGkgPCBjbGFzc2VzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1cnJlbnRDbGFzcyA9IGNsYXNzZXNbaV07XG4gICAgICBpZiAoYWxsb3dlZENsYXNzZXNbY3VycmVudENsYXNzXSkge1xuICAgICAgICBuZXdDbGFzc2VzLnB1c2goY3VycmVudENsYXNzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgZHVwbGljYXRlIGVudHJpZXMgYW5kIHByZXNlcnZlIGNsYXNzIHNwZWNpZmljaXR5XG4gICAgbmV3Q2xhc3Nlc0xlbmd0aCA9IG5ld0NsYXNzZXMubGVuZ3RoO1xuICAgIHdoaWxlIChuZXdDbGFzc2VzTGVuZ3RoLS0pIHtcbiAgICAgIGN1cnJlbnRDbGFzcyA9IG5ld0NsYXNzZXNbbmV3Q2xhc3Nlc0xlbmd0aF07XG4gICAgICBpZiAoIXd5c2lodG1sNS5sYW5nLmFycmF5KG5ld1VuaXF1ZUNsYXNzZXMpLmNvbnRhaW5zKGN1cnJlbnRDbGFzcykpIHtcbiAgICAgICAgbmV3VW5pcXVlQ2xhc3Nlcy51bnNoaWZ0KGN1cnJlbnRDbGFzcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld1VuaXF1ZUNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICBhdHRyaWJ1dGVzW1wiY2xhc3NcIl0gPSBuZXdVbmlxdWVDbGFzc2VzLmpvaW4oXCIgXCIpO1xuICAgIH1cblxuICAgIC8vIHNldCBhdHRyaWJ1dGVzIG9uIG5ld05vZGVcbiAgICBmb3IgKGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgLy8gU2V0dGluZyBhdHRyaWJ1dGVzIGNhbiBjYXVzZSBhIGpzIGVycm9yIGluIElFIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlc1xuICAgICAgLy8gZWcuIG9uIGEgPGltZz4gdW5kZXIgaHR0cHMgd2hlbiBpdCdzIG5ldyBhdHRyaWJ1dGUgdmFsdWUgaXMgbm9uLWh0dHBzXG4gICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSB0aGlzIGZ1cnRoZXIgYW5kIGNoZWNrIGZvciBzbWFydGVyIGhhbmRsaW5nXG4gICAgICB0cnkge1xuICAgICAgICBuZXdOb2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLy8gSUU4IHNvbWV0aW1lcyBsb3NlcyB0aGUgd2lkdGgvaGVpZ2h0IGF0dHJpYnV0ZXMgd2hlbiB0aG9zZSBhcmUgc2V0IGJlZm9yZSB0aGUgXCJzcmNcIlxuICAgIC8vIHNvIHdlIG1ha2Ugc3VyZSB0byBzZXQgdGhlbSBhZ2FpblxuICAgIGlmIChhdHRyaWJ1dGVzLnNyYykge1xuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLndpZHRoICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG5ld05vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgYXR0cmlidXRlcy53aWR0aCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMuaGVpZ2h0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG5ld05vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGF0dHJpYnV0ZXMuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSUUgZ2l2ZXMgd3JvbmcgcmVzdWx0cyBmb3IgaGFzQXR0cmlidXRlL2dldEF0dHJpYnV0ZSwgZm9yIGV4YW1wbGU6XG4gICAqICAgIHZhciB0ZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiKTtcbiAgICogICAgdGQuZ2V0QXR0cmlidXRlKFwicm93c3BhblwiKTsgLy8gPT4gXCIxXCIgaW4gSUVcbiAgICpcbiAgICogVGhlcmVmb3JlIHdlIGhhdmUgdG8gY2hlY2sgdGhlIGVsZW1lbnQncyBvdXRlckhUTUwgZm9yIHRoZSBhdHRyaWJ1dGVcbiAgICovXG4gIHZhciBIQVNfR0VUX0FUVFJJQlVURV9CVUcgPSAhd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNHZXRBdHRyaWJ1dGVDb3JyZWN0bHkoKTtcbiAgZnVuY3Rpb24gX2dldEF0dHJpYnV0ZShub2RlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lO1xuICAgIGlmIChub2RlTmFtZSA9PSBcIklNR1wiICYmIGF0dHJpYnV0ZU5hbWUgPT0gXCJzcmNcIiAmJiBfaXNMb2FkZWRJbWFnZShub2RlKSA9PT0gdHJ1ZSkge1xuICAgICAgLy8gR2V0ICdzcmMnIGF0dHJpYnV0ZSB2YWx1ZSB2aWEgb2JqZWN0IHByb3BlcnR5IHNpbmNlIHRoaXMgd2lsbCBhbHdheXMgY29udGFpbiB0aGVcbiAgICAgIC8vIGZ1bGwgYWJzb2x1dGUgdXJsIChodHRwOi8vLi4uKVxuICAgICAgLy8gdGhpcyBmaXhlcyBhIHZlcnkgYW5ub3lpbmcgYnVnIGluIGZpcmVmb3ggKHZlciAzLjYgJiA0KSBhbmQgSUUgOCB3aGVyZSBpbWFnZXMgY29waWVkIGZyb20gdGhlIHNhbWUgaG9zdFxuICAgICAgLy8gd2lsbCBoYXZlIHJlbGF0aXZlIHBhdGhzLCB3aGljaCB0aGUgc2FuaXRpemVyIHN0cmlwcyBvdXQgKHNlZSBhdHRyaWJ1dGVDaGVja01ldGhvZHMudXJsKVxuICAgICAgcmV0dXJuIG5vZGUuc3JjO1xuICAgIH0gZWxzZSBpZiAoSEFTX0dFVF9BVFRSSUJVVEVfQlVHICYmIFwib3V0ZXJIVE1MXCIgaW4gbm9kZSkge1xuICAgICAgLy8gRG9uJ3QgdHJ1c3QgZ2V0QXR0cmlidXRlL2hhc0F0dHJpYnV0ZSBpbiBJRSA2LTgsIGluc3RlYWQgY2hlY2sgdGhlIGVsZW1lbnQncyBvdXRlckhUTUxcbiAgICAgIHZhciBvdXRlckhUTUwgPSBub2RlLm91dGVySFRNTC50b0xvd2VyQ2FzZSgpLFxuXG4gICAgICAvLyBUT0RPOiBUaGlzIG1pZ2h0IG5vdCB3b3JrIGZvciBhdHRyaWJ1dGVzIHdpdGhvdXQgdmFsdWU6IDxpbnB1dCBkaXNhYmxlZD5cbiAgICAgIGhhc0F0dHJpYnV0ZSA9IG91dGVySFRNTC5pbmRleE9mKFwiIFwiICsgYXR0cmlidXRlTmFtZSArIFwiPVwiKSAhPSAtMTtcblxuICAgICAgcmV0dXJuIGhhc0F0dHJpYnV0ZSA/IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIGlzIGEgcHJvcGVyIGxvYWRlZCBpbWFnZVxuICAgKiBGSVhNRTogUmV0dXJucyB1bmRlZmluZWQgd2hlbiB1bmtub3duIChDaHJvbWUsIFNhZmFyaSlcbiAgICovXG4gIGZ1bmN0aW9uIF9pc0xvYWRlZEltYWdlKG5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5vZGUuY29tcGxldGUgJiYgIW5vZGUubW96TWF0Y2hlc1NlbGVjdG9yKFwiOi1tb3otYnJva2VuXCIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChub2RlLmNvbXBsZXRlICYmIG5vZGUucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9oYW5kbGVUZXh0KG9sZE5vZGUpIHtcbiAgICByZXR1cm4gb2xkTm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG9sZE5vZGUuZGF0YSk7XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0gYXR0cmlidXRlIGNoZWNrcyAtLS0tLS0tLS0tLS0gXFxcXFxuICB2YXIgYXR0cmlidXRlQ2hlY2tNZXRob2RzID0ge1xuICAgIHVybDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIFJFR19FWFAgPSAvXmh0dHBzPzpcXC9cXC8vaTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCAhYXR0cmlidXRlVmFsdWUubWF0Y2goUkVHX0VYUCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWUucmVwbGFjZShSRUdfRVhQLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0oKSxcblxuICAgIGFsdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIFJFR19FWFAgPSAvW14gYS16MC05X1xcLV0vZ2k7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIGlmICghYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWUucmVwbGFjZShSRUdfRVhQLCBcIlwiKTtcbiAgICAgIH07XG4gICAgfSgpLFxuXG4gICAgbnVtYmVyczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIFJFR19FWFAgPSAvXFxEL2c7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIGF0dHJpYnV0ZVZhbHVlID0gKGF0dHJpYnV0ZVZhbHVlIHx8IFwiXCIpLnJlcGxhY2UoUkVHX0VYUCwgXCJcIik7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZSB8fCBudWxsO1xuICAgICAgfTtcbiAgICB9KClcbiAgfTtcblxuICAvLyAtLS0tLS0tLS0tLS0gY2xhc3MgY29udmVydGVyIChjb252ZXJ0cyBhbiBodG1sIGF0dHJpYnV0ZSB0byBhIGNsYXNzIG5hbWUpIC0tLS0tLS0tLS0tLSBcXFxcXG4gIHZhciBhZGRDbGFzc01ldGhvZHMgPSB7XG4gICAgYWxpZ25faW1nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgbGVmdDogXCJ3eXNpd3lnLWZsb2F0LWxlZnRcIixcbiAgICAgICAgcmlnaHQ6IFwid3lzaXd5Zy1mbG9hdC1yaWdodFwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWFwcGluZ1tTdHJpbmcoYXR0cmlidXRlVmFsdWUpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgfTtcbiAgICB9KCksXG5cbiAgICBhbGlnbl90ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgbGVmdDogXCJ3eXNpd3lnLXRleHQtYWxpZ24tbGVmdFwiLFxuICAgICAgICByaWdodDogXCJ3eXNpd3lnLXRleHQtYWxpZ24tcmlnaHRcIixcbiAgICAgICAgY2VudGVyOiBcInd5c2l3eWctdGV4dC1hbGlnbi1jZW50ZXJcIixcbiAgICAgICAganVzdGlmeTogXCJ3eXNpd3lnLXRleHQtYWxpZ24tanVzdGlmeVwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWFwcGluZ1tTdHJpbmcoYXR0cmlidXRlVmFsdWUpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgfTtcbiAgICB9KCksXG5cbiAgICBjbGVhcl9icjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgIGxlZnQ6IFwid3lzaXd5Zy1jbGVhci1sZWZ0XCIsXG4gICAgICAgIHJpZ2h0OiBcInd5c2l3eWctY2xlYXItcmlnaHRcIixcbiAgICAgICAgYm90aDogXCJ3eXNpd3lnLWNsZWFyLWJvdGhcIixcbiAgICAgICAgYWxsOiBcInd5c2l3eWctY2xlYXItYm90aFwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWFwcGluZ1tTdHJpbmcoYXR0cmlidXRlVmFsdWUpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgfTtcbiAgICB9KCksXG5cbiAgICBzaXplX2ZvbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICBcIjFcIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS14eC1zbWFsbFwiLFxuICAgICAgICBcIjJcIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS1zbWFsbFwiLFxuICAgICAgICBcIjNcIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS1tZWRpdW1cIixcbiAgICAgICAgXCI0XCI6IFwid3lzaXd5Zy1mb250LXNpemUtbGFyZ2VcIixcbiAgICAgICAgXCI1XCI6IFwid3lzaXd5Zy1mb250LXNpemUteC1sYXJnZVwiLFxuICAgICAgICBcIjZcIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS14eC1sYXJnZVwiLFxuICAgICAgICBcIjdcIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS14eC1sYXJnZVwiLFxuICAgICAgICBcIi1cIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS1zbWFsbGVyXCIsXG4gICAgICAgIFwiK1wiOiBcInd5c2l3eWctZm9udC1zaXplLWxhcmdlclwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbWFwcGluZ1tTdHJpbmcoYXR0cmlidXRlVmFsdWUpLmNoYXJBdCgwKV07XG4gICAgICB9O1xuICAgIH0oKVxuICB9O1xuXG4gIHJldHVybiBwYXJzZTtcbn0oKTsgLyoqXG4gICAgICogQ2hlY2tzIGZvciBlbXB0eSB0ZXh0IG5vZGUgY2hpbGRzIGFuZCByZW1vdmVzIHRoZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBUaGUgZWxlbWVudCBpbiB3aGljaCB0byBjbGVhbnVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB3eXNpaHRtbDUuZG9tLnJlbW92ZUVtcHR5VGV4dE5vZGVzKGVsZW1lbnQpO1xuICAgICAqL1xud3lzaWh0bWw1LmRvbS5yZW1vdmVFbXB0eVRleHROb2RlcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBjaGlsZE5vZGUsXG4gICAgICBjaGlsZE5vZGVzID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkobm9kZS5jaGlsZE5vZGVzKS5nZXQoKSxcbiAgICAgIGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aCxcbiAgICAgIGkgPSAwO1xuICBmb3IgKDsgaSA8IGNoaWxkTm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gd3lzaWh0bWw1LlRFWFRfTk9ERSAmJiBjaGlsZE5vZGUuZGF0YSA9PT0gXCJcIikge1xuICAgICAgY2hpbGROb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGROb2RlKTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIFJlbmFtZXMgYW4gZWxlbWVudCAoZWcuIGEgPGRpdj4gdG8gYSA8cD4pIGFuZCBrZWVwcyBpdHMgY2hpbGRzXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBsaXN0IGVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmFtZWRcbiAqIEBwYXJhbSB7RWxlbWVudH0gbmV3Tm9kZU5hbWUgVGhlIGRlc2lyZWQgdGFnIG5hbWVcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgPCEtLSBBc3N1bWUgdGhlIGZvbGxvd2luZyBkb206IC0tPlxuICogICAgPHVsIGlkPVwibGlzdFwiPlxuICogICAgICA8bGk+ZW1pbmVtPC9saT5cbiAqICAgICAgPGxpPmRyLiBkcmU8L2xpPlxuICogICAgICA8bGk+NTAgQ2VudDwvbGk+XG4gKiAgICA8L3VsPlxuICpcbiAqICAgIDxzY3JpcHQ+XG4gKiAgICAgIHd5c2lodG1sNS5kb20ucmVuYW1lRWxlbWVudChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxpc3RcIiksIFwib2xcIik7XG4gKiAgICA8L3NjcmlwdD5cbiAqXG4gKiAgICA8IS0tIFdpbGwgcmVzdWx0IGluOiAtLT5cbiAqICAgIDxvbD5cbiAqICAgICAgPGxpPmVtaW5lbTwvbGk+XG4gKiAgICAgIDxsaT5kci4gZHJlPC9saT5cbiAqICAgICAgPGxpPjUwIENlbnQ8L2xpPlxuICogICAgPC9vbD5cbiAqL1xud3lzaWh0bWw1LmRvbS5yZW5hbWVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5ld05vZGVOYW1lKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmV3Tm9kZU5hbWUpLFxuICAgICAgZmlyc3RDaGlsZDtcbiAgd2hpbGUgKGZpcnN0Q2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICBuZXdFbGVtZW50LmFwcGVuZENoaWxkKGZpcnN0Q2hpbGQpO1xuICB9XG4gIHd5c2lodG1sNS5kb20uY29weUF0dHJpYnV0ZXMoW1wiYWxpZ25cIiwgXCJjbGFzc05hbWVcIl0pLmZyb20oZWxlbWVudCkudG8obmV3RWxlbWVudCk7XG4gIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3RWxlbWVudCwgZWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufTsgLyoqXG4gICAqIFRha2VzIGFuIGVsZW1lbnQsIHJlbW92ZXMgaXQgYW5kIHJlcGxhY2VzIGl0IHdpdGggaXQncyBjaGlsZHNcbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIFRoZSBub2RlIHdoaWNoIHRvIHJlcGxhY2Ugd2l0aCBpdCdzIGNoaWxkIG5vZGVzXG4gICAqIEBleGFtcGxlXG4gICAqICAgIDxkaXYgaWQ9XCJmb29cIj5cbiAgICogICAgICA8c3Bhbj5oZWxsbzwvc3Bhbj5cbiAgICogICAgPC9kaXY+XG4gICAqICAgIDxzY3JpcHQ+XG4gICAqICAgICAgLy8gUmVtb3ZlICNmb28gYW5kIHJlcGxhY2Ugd2l0aCBpdCdzIGNoaWxkcmVuXG4gICAqICAgICAgd3lzaWh0bWw1LmRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXMoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmb29cIikpO1xuICAgKiAgICA8L3NjcmlwdD5cbiAgICovXG53eXNpaHRtbDUuZG9tLnJlcGxhY2VXaXRoQ2hpbGROb2RlcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICghbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZyYWdtZW50ID0gbm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gIH1cbiAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChmcmFnbWVudCwgbm9kZSk7XG4gIG5vZGUgPSBmcmFnbWVudCA9IG51bGw7XG59O1xuLyoqXG4gKiBVbndyYXBzIGFuIHVub3JkZXJlZC9vcmRlcmVkIGxpc3RcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGxpc3QgZWxlbWVudCB3aGljaCBzaG91bGQgYmUgdW53cmFwcGVkXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIDwhLS0gQXNzdW1lIHRoZSBmb2xsb3dpbmcgZG9tOiAtLT5cbiAqICAgIDx1bCBpZD1cImxpc3RcIj5cbiAqICAgICAgPGxpPmVtaW5lbTwvbGk+XG4gKiAgICAgIDxsaT5kci4gZHJlPC9saT5cbiAqICAgICAgPGxpPjUwIENlbnQ8L2xpPlxuICogICAgPC91bD5cbiAqXG4gKiAgICA8c2NyaXB0PlxuICogICAgICB3eXNpaHRtbDUuZG9tLnJlc29sdmVMaXN0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGlzdFwiKSk7XG4gKiAgICA8L3NjcmlwdD5cbiAqXG4gKiAgICA8IS0tIFdpbGwgcmVzdWx0IGluOiAtLT5cbiAqICAgIGVtaW5lbTxicj5cbiAqICAgIGRyLiBkcmU8YnI+XG4gKiAgICA1MCBDZW50PGJyPlxuICovXG4oZnVuY3Rpb24gKGRvbSkge1xuICBmdW5jdGlvbiBfaXNCbG9ja0VsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBkb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20obm9kZSkgPT09IFwiYmxvY2tcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pc0xpbmVCcmVhayhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09IFwiQlJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcHBlbmRMaW5lQnJlYWsoZWxlbWVudCkge1xuICAgIHZhciBsaW5lQnJlYWsgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQobGluZUJyZWFrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVMaXN0KGxpc3QpIHtcbiAgICBpZiAobGlzdC5ub2RlTmFtZSAhPT0gXCJNRU5VXCIgJiYgbGlzdC5ub2RlTmFtZSAhPT0gXCJVTFwiICYmIGxpc3Qubm9kZU5hbWUgIT09IFwiT0xcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkb2MgPSBsaXN0Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgIGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcbiAgICAgICAgcHJldmlvdXNTaWJsaW5nID0gbGlzdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIHx8IGxpc3QucHJldmlvdXNTaWJsaW5nLFxuICAgICAgICBmaXJzdENoaWxkLFxuICAgICAgICBsYXN0Q2hpbGQsXG4gICAgICAgIGlzTGFzdENoaWxkLFxuICAgICAgICBzaG91bGRBcHBlbmRMaW5lQnJlYWssXG4gICAgICAgIGxpc3RJdGVtO1xuXG4gICAgaWYgKHByZXZpb3VzU2libGluZyAmJiAhX2lzQmxvY2tFbGVtZW50KHByZXZpb3VzU2libGluZykpIHtcbiAgICAgIF9hcHBlbmRMaW5lQnJlYWsoZnJhZ21lbnQpO1xuICAgIH1cblxuICAgIHdoaWxlIChsaXN0SXRlbSA9IGxpc3QuZmlyc3RDaGlsZCkge1xuICAgICAgbGFzdENoaWxkID0gbGlzdEl0ZW0ubGFzdENoaWxkO1xuICAgICAgd2hpbGUgKGZpcnN0Q2hpbGQgPSBsaXN0SXRlbS5maXJzdENoaWxkKSB7XG4gICAgICAgIGlzTGFzdENoaWxkID0gZmlyc3RDaGlsZCA9PT0gbGFzdENoaWxkO1xuICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgYmVmb3JlIGFwcGVuZGluZyBpdCB0byB0aGUgZnJhZ21lbnQsIGFzIGl0IG90aGVyd2lzZSB3aWxsIGxvb3NlIHN0eWxlIGluZm9ybWF0aW9uXG4gICAgICAgIHNob3VsZEFwcGVuZExpbmVCcmVhayA9IGlzTGFzdENoaWxkICYmICFfaXNCbG9ja0VsZW1lbnQoZmlyc3RDaGlsZCkgJiYgIV9pc0xpbmVCcmVhayhmaXJzdENoaWxkKTtcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgICAgIGlmIChzaG91bGRBcHBlbmRMaW5lQnJlYWspIHtcbiAgICAgICAgICBfYXBwZW5kTGluZUJyZWFrKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0SXRlbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpc3RJdGVtKTtcbiAgICB9XG4gICAgbGlzdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChmcmFnbWVudCwgbGlzdCk7XG4gIH1cblxuICBkb20ucmVzb2x2ZUxpc3QgPSByZXNvbHZlTGlzdDtcbn0pKHd5c2lodG1sNS5kb20pOyAvKipcbiAgICAgICAgICAgICAgICAgICAqIFNhbmRib3ggZm9yIGV4ZWN1dGluZyBqYXZhc2NyaXB0LCBwYXJzaW5nIGNzcyBzdHlsZXMgYW5kIGRvaW5nIGRvbSBvcGVyYXRpb25zIGluIGEgc2VjdXJlIHdheVxuICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAqIEJyb3dzZXIgQ29tcGF0aWJpbGl0eTpcbiAgICAgICAgICAgICAgICAgICAqICAtIFNlY3VyZSBpbiBNU0lFIDYrLCBidXQgb25seSB3aGVuIHRoZSB1c2VyIGhhc24ndCBtYWRlIGNoYW5nZXMgdG8gaGlzIHNlY3VyaXR5IGxldmVsIFwicmVzdHJpY3RlZFwiXG4gICAgICAgICAgICAgICAgICAgKiAgLSBQYXJ0aWFsbHkgc2VjdXJlIGluIG90aGVyIGJyb3dzZXJzIChGaXJlZm94LCBPcGVyYSwgU2FmYXJpLCBDaHJvbWUsIC4uLilcbiAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgY2xhc3MgY2FuJ3QgYmVuZWZpdCBmcm9tIHRoZSBIVE1MNSBzYW5kYm94IGF0dHJpYnV0ZSBmb3IgdGhlIGZvbGxvd2luZyByZWFzb25zOlxuICAgICAgICAgICAgICAgICAgICogICAgLSBzYW5kYm94aW5nIGRvZXNuJ3Qgd29yayBjb3JyZWN0bHkgd2l0aCBpbmxpbmVkIGNvbnRlbnQgKHNyYz1cImphdmFzY3JpcHQ6JzxodG1sPi4uLjwvaHRtbD4nXCIpXG4gICAgICAgICAgICAgICAgICAgKiAgICAtIHNhbmRib3hpbmcgb2YgcGh5c2ljYWwgZG9jdW1lbnRzIGNhdXNlcyB0aGF0IHRoZSBkb20gaXNuJ3QgYWNjZXNzaWJsZSBhbnltb3JlIGZyb20gdGhlIG91dHNpZGUgKGlmcmFtZS5jb250ZW50V2luZG93LCAuLi4pXG4gICAgICAgICAgICAgICAgICAgKiAgICAtIHNldHRpbmcgdGhlIFwiYWxsb3ctc2FtZS1vcmlnaW5cIiBmbGFnIHdvdWxkIGZpeCB0aGF0LCBidXQgdGhlbiBzdGlsbCBqYXZhc2NyaXB0IGFuZCBkb20gZXZlbnRzIHJlZnVzZSB0byBmaXJlXG4gICAgICAgICAgICAgICAgICAgKiAgICAtIHRoZXJlZm9yZSB0aGUgXCJhbGxvdy1zY3JpcHRzXCIgZmxhZyBpcyBuZWVkZWQsIHdoaWNoIHRoZW4gd291bGQgZGVhY3RpdmF0ZSBhbnkgc2VjdXJpdHksIGFzIHRoZSBqcyBleGVjdXRlZCBpbnNpZGUgdGhlIGlmcmFtZVxuICAgICAgICAgICAgICAgICAgICogICAgICBjYW4gZG8gYW55dGhpbmcgYXMgaWYgdGhlIHNhbmRib3ggYXR0cmlidXRlIHdhc24ndCBzZXRcbiAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVhZHlDYWxsYmFja10gTWV0aG9kIHRoYXQgZ2V0cyBpbnZva2VkIHdoZW4gdGhlIHNhbmRib3ggaXMgcmVhZHlcbiAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAqICAgIG5ldyB3eXNpaHRtbDUuZG9tLlNhbmRib3goZnVuY3Rpb24oc2FuZGJveCkge1xuICAgICAgICAgICAgICAgICAgICogICAgICBzYW5kYm94LmdldFdpbmRvdygpLmRvY3VtZW50LmJvZHkuaW5uZXJIVE1MID0gJzxpbWcgc3JjPWZvby5naWYgb25lcnJvcj1cImFsZXJ0KGRvY3VtZW50LmNvb2tpZSlcIj4nO1xuICAgICAgICAgICAgICAgICAgICogICAgfSk7XG4gICAgICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciAvKipcbiAgICAgICAqIERlZmF1bHQgY29uZmlndXJhdGlvblxuICAgICAgICovXG4gIGRvYyA9IGRvY3VtZW50LFxuXG4gIC8qKlxuICAgKiBQcm9wZXJ0aWVzIHRvIHVuc2V0L3Byb3RlY3Qgb24gdGhlIHdpbmRvdyBvYmplY3RcbiAgICovXG4gIHdpbmRvd1Byb3BlcnRpZXMgPSBbXCJwYXJlbnRcIiwgXCJ0b3BcIiwgXCJvcGVuZXJcIiwgXCJmcmFtZUVsZW1lbnRcIiwgXCJmcmFtZXNcIiwgXCJsb2NhbFN0b3JhZ2VcIiwgXCJnbG9iYWxTdG9yYWdlXCIsIFwic2Vzc2lvblN0b3JhZ2VcIiwgXCJpbmRleGVkREJcIl0sXG5cbiAgLyoqXG4gICAqIFByb3BlcnRpZXMgb24gdGhlIHdpbmRvdyBvYmplY3Qgd2hpY2ggYXJlIHNldCB0byBhbiBlbXB0eSBmdW5jdGlvblxuICAgKi9cbiAgd2luZG93UHJvcGVydGllczIgPSBbXCJvcGVuXCIsIFwiY2xvc2VcIiwgXCJvcGVuRGlhbG9nXCIsIFwic2hvd01vZGFsRGlhbG9nXCIsIFwiYWxlcnRcIiwgXCJjb25maXJtXCIsIFwicHJvbXB0XCIsIFwib3BlbkRhdGFiYXNlXCIsIFwicG9zdE1lc3NhZ2VcIiwgXCJYTUxIdHRwUmVxdWVzdFwiLCBcIlhEb21haW5SZXF1ZXN0XCJdLFxuXG4gIC8qKlxuICAgKiBQcm9wZXJ0aWVzIHRvIHVuc2V0L3Byb3RlY3Qgb24gdGhlIGRvY3VtZW50IG9iamVjdFxuICAgKi9cbiAgZG9jdW1lbnRQcm9wZXJ0aWVzID0gW1wicmVmZXJyZXJcIiwgXCJ3cml0ZVwiLCBcIm9wZW5cIiwgXCJjbG9zZVwiXTtcblxuICB3eXNpaHRtbDUuZG9tLlNhbmRib3ggPSBCYXNlLmV4dGVuZChcbiAgLyoqIEBzY29wZSB3eXNpaHRtbDUuZG9tLlNhbmRib3gucHJvdG90eXBlICove1xuXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKHJlYWR5Q2FsbGJhY2ssIGNvbmZpZykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IHJlYWR5Q2FsbGJhY2sgfHwgd3lzaWh0bWw1LkVNUFRZX0ZVTkNUSU9OO1xuICAgICAgdGhpcy5jb25maWcgPSB3eXNpaHRtbDUubGFuZy5vYmplY3Qoe30pLm1lcmdlKGNvbmZpZykuZ2V0KCk7XG4gICAgICB0aGlzLmlmcmFtZSA9IHRoaXMuX2NyZWF0ZUlmcmFtZSgpO1xuICAgIH0sXG5cbiAgICBpbnNlcnRJbnRvOiBmdW5jdGlvbiBpbnNlcnRJbnRvKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBlbGVtZW50ID0gZG9jLmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaWZyYW1lKTtcbiAgICB9LFxuXG4gICAgZ2V0SWZyYW1lOiBmdW5jdGlvbiBnZXRJZnJhbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pZnJhbWU7XG4gICAgfSxcblxuICAgIGdldFdpbmRvdzogZnVuY3Rpb24gZ2V0V2luZG93KCkge1xuICAgICAgdGhpcy5fcmVhZHlFcnJvcigpO1xuICAgIH0sXG5cbiAgICBnZXREb2N1bWVudDogZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XG4gICAgICB0aGlzLl9yZWFkeUVycm9yKCk7XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgaWZyYW1lID0gdGhpcy5nZXRJZnJhbWUoKTtcbiAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSxcblxuICAgIF9yZWFkeUVycm9yOiBmdW5jdGlvbiBfcmVhZHlFcnJvcigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInd5c2lodG1sNS5TYW5kYm94OiBTYW5kYm94IGlmcmFtZSBpc24ndCBsb2FkZWQgeWV0XCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBzYW5kYm94IGlmcmFtZVxuICAgICAqXG4gICAgICogU29tZSBpbXBvcnRhbnQgbm90ZXM6XG4gICAgICogIC0gV2UgY2FuJ3QgdXNlIEhUTUw1IHNhbmRib3ggZm9yIG5vdzpcbiAgICAgKiAgICBzZXR0aW5nIGl0IGNhdXNlcyB0aGF0IHRoZSBpZnJhbWUncyBkb20gY2FuJ3QgYmUgYWNjZXNzZWQgZnJvbSB0aGUgb3V0c2lkZVxuICAgICAqICAgIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHNldCB0aGUgXCJhbGxvdy1zYW1lLW9yaWdpblwiIGZsYWcgd2hpY2ggZW5hYmxlcyBhY2Nlc3NpbmcgdGhlIGlmcmFtZSdzIGRvbVxuICAgICAqICAgIEJ1dCB0aGVuIHRoZXJlJ3MgYW5vdGhlciBwcm9ibGVtLCBET00gZXZlbnRzIChmb2N1cywgYmx1ciwgY2hhbmdlLCBrZXlwcmVzcywgLi4uKSBhcmVuJ3QgZmlyZWQuXG4gICAgICogICAgSW4gb3JkZXIgdG8gbWFrZSB0aGlzIGhhcHBlbiB3ZSBuZWVkIHRvIHNldCB0aGUgXCJhbGxvdy1zY3JpcHRzXCIgZmxhZy5cbiAgICAgKiAgICBBIGNvbWJpbmF0aW9uIG9mIGFsbG93LXNjcmlwdHMgYW5kIGFsbG93LXNhbWUtb3JpZ2luIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyBzZXR0aW5nIG5vIHNhbmRib3ggYXR0cmlidXRlIGF0IGFsbC5cbiAgICAgKiAgLSBDaHJvbWUgJiBTYWZhcmksIGRvZXNuJ3Qgc2VlbSB0byBzdXBwb3J0IHNhbmRib3hpbmcgY29ycmVjdGx5IHdoZW4gdGhlIGlmcmFtZSdzIGh0bWwgaXMgaW5saW5lZCAobm8gcGh5c2ljYWwgZG9jdW1lbnQpXG4gICAgICogIC0gSUUgbmVlZHMgdG8gaGF2ZSB0aGUgc2VjdXJpdHk9XCJyZXN0cmljdGVkXCIgYXR0cmlidXRlIHNldCBiZWZvcmUgdGhlIGlmcmFtZSBpcyBcbiAgICAgKiAgICBpbnNlcnRlZCBpbnRvIHRoZSBkb20gdHJlZVxuICAgICAqICAtIEJlbGlldmUgaXQgb3Igbm90IGJ1dCBpbiBJRSBcInNlY3VyaXR5XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKSBpcyBmYWxzZSwgZXZlblxuICAgICAqICAgIHRob3VnaCBpdCBzdXBwb3J0cyBpdFxuICAgICAqICAtIFdoZW4gYW4gaWZyYW1lIGhhcyBzZWN1cml0eT1cInJlc3RyaWN0ZWRcIiwgaW4gSUUgZXZhbCgpICYgZXhlY1NjcmlwdCgpIGRvbid0IHdvcmsgYW55bW9yZVxuICAgICAqICAtIElFIGRvZXNuJ3QgZmlyZSB0aGUgb25sb2FkIGV2ZW50IHdoZW4gdGhlIGNvbnRlbnQgaXMgaW5saW5lZCBpbiB0aGUgc3JjIGF0dHJpYnV0ZSwgdGhlcmVmb3JlIHdlIHJlbHlcbiAgICAgKiAgICBvbiB0aGUgb25yZWFkeXN0YXRlY2hhbmdlIGV2ZW50XG4gICAgICovXG4gICAgX2NyZWF0ZUlmcmFtZTogZnVuY3Rpb24gX2NyZWF0ZUlmcmFtZSgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBpZnJhbWUgPSBkb2MuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgIGlmcmFtZS5jbGFzc05hbWUgPSBcInd5c2lodG1sNS1zYW5kYm94XCI7XG4gICAgICB3eXNpaHRtbDUuZG9tLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICBcInNlY3VyaXR5XCI6IFwicmVzdHJpY3RlZFwiLFxuICAgICAgICBcImFsbG93dHJhbnNwYXJlbmN5XCI6IFwidHJ1ZVwiLFxuICAgICAgICBcImZyYW1lYm9yZGVyXCI6IDAsXG4gICAgICAgIFwid2lkdGhcIjogMCxcbiAgICAgICAgXCJoZWlnaHRcIjogMCxcbiAgICAgICAgXCJtYXJnaW53aWR0aFwiOiAwLFxuICAgICAgICBcIm1hcmdpbmhlaWdodFwiOiAwXG4gICAgICB9KS5vbihpZnJhbWUpO1xuXG4gICAgICAvLyBTZXR0aW5nIHRoZSBzcmMgbGlrZSB0aGlzIHByZXZlbnRzIHNzbCB3YXJuaW5ncyBpbiBJRTZcbiAgICAgIGlmICh3eXNpaHRtbDUuYnJvd3Nlci50aHJvd3NNaXhlZENvbnRlbnRXYXJuaW5nV2hlbklmcmFtZVNyY0lzRW1wdHkoKSkge1xuICAgICAgICBpZnJhbWUuc3JjID0gXCJqYXZhc2NyaXB0Oic8aHRtbD48L2h0bWw+J1wiO1xuICAgICAgfVxuXG4gICAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIHRoYXQuX29uTG9hZElmcmFtZShpZnJhbWUpO1xuICAgICAgfTtcblxuICAgICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKC9sb2FkZWR8Y29tcGxldGUvLnRlc3QoaWZyYW1lLnJlYWR5U3RhdGUpKSB7XG4gICAgICAgICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgIHRoYXQuX29uTG9hZElmcmFtZShpZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gaWZyYW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBmb3Igd2hlbiB0aGUgaWZyYW1lIGhhcyBmaW5pc2hlZCBsb2FkaW5nXG4gICAgICovXG4gICAgX29uTG9hZElmcmFtZTogZnVuY3Rpb24gX29uTG9hZElmcmFtZShpZnJhbWUpIHtcbiAgICAgIC8vIGRvbid0IHJlc3VtZSB3aGVuIHRoZSBpZnJhbWUgZ290IHVubG9hZGVkIChlZy4gYnkgcmVtb3ZpbmcgaXQgZnJvbSB0aGUgZG9tKVxuICAgICAgaWYgKCF3eXNpaHRtbDUuZG9tLmNvbnRhaW5zKGRvYy5kb2N1bWVudEVsZW1lbnQsIGlmcmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgaWZyYW1lV2luZG93ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3csXG4gICAgICAgICAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudCxcbiAgICAgICAgICBjaGFyc2V0ID0gZG9jLmNoYXJhY3RlclNldCB8fCBkb2MuY2hhcnNldCB8fCBcInV0Zi04XCIsXG4gICAgICAgICAgc2FuZGJveEh0bWwgPSB0aGlzLl9nZXRIdG1sKHtcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgc3R5bGVzaGVldHM6IHRoaXMuY29uZmlnLnN0eWxlc2hlZXRzXG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBiYXNpYyBkb20gdHJlZSBpbmNsdWRpbmcgcHJvcGVyIERPQ1RZUEUgYW5kIGNoYXJzZXRcbiAgICAgIGlmcmFtZURvY3VtZW50Lm9wZW4oXCJ0ZXh0L2h0bWxcIiwgXCJyZXBsYWNlXCIpO1xuICAgICAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2FuZGJveEh0bWwpO1xuICAgICAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcblxuICAgICAgdGhpcy5nZXRXaW5kb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpZnJhbWUuY29udGVudFdpbmRvdztcbiAgICAgIH07XG4gICAgICB0aGlzLmdldERvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgICB9O1xuXG4gICAgICAvLyBDYXRjaCBqcyBlcnJvcnMgYW5kIHBhc3MgdGhlbSB0byB0aGUgcGFyZW50J3Mgb25lcnJvciBldmVudFxuICAgICAgLy8gYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIpIGRvZXNuJ3Qgd29yayBwcm9wZXJseSBpbiBzb21lIGJyb3dzZXJzXG4gICAgICAvLyBUT0RPOiBhcHBhcmVudGx5IHRoaXMgZG9lc24ndCB3b3JrIGluIElFOSFcbiAgICAgIGlmcmFtZVdpbmRvdy5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yTWVzc2FnZSwgZmlsZU5hbWUsIGxpbmVOdW1iZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid3lzaWh0bWw1LlNhbmRib3g6IFwiICsgZXJyb3JNZXNzYWdlLCBmaWxlTmFtZSwgbGluZU51bWJlcik7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIXd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzU2FuZGJveGVkSWZyYW1lcygpKSB7XG4gICAgICAgIC8vIFVuc2V0IGEgYnVuY2ggb2Ygc2Vuc2l0aXZlIHZhcmlhYmxlc1xuICAgICAgICAvLyBQbGVhc2Ugbm90ZTogVGhpcyBpc24ndCBoYWNrIHNhZmUhICBcbiAgICAgICAgLy8gSXQgbW9yZSBvciBsZXNzIGp1c3QgdGFrZXMgY2FyZSBvZiBiYXNpYyBhdHRhY2tzIGFuZCBwcmV2ZW50cyBhY2NpZGVudGFsIHRoZWZ0IG9mIHNlbnNpdGl2ZSBpbmZvcm1hdGlvblxuICAgICAgICAvLyBJRSBpcyBzZWN1cmUgdGhvdWdoLCB3aGljaCBpcyB0aGUgbW9zdCBpbXBvcnRhbnQgdGhpbmcsIHNpbmNlIElFIGlzIHRoZSBvbmx5IGJyb3dzZXIsIHdob1xuICAgICAgICAvLyB0YWtlcyBvdmVyIHNjcmlwdHMgJiBzdHlsZXMgaW50byBjb250ZW50RWRpdGFibGUgZWxlbWVudHMgd2hlbiBjb3BpZWQgZnJvbSBleHRlcm5hbCB3ZWJzaXRlc1xuICAgICAgICAvLyBvciBhcHBsaWNhdGlvbnMgKE1pY3Jvc29mdCBXb3JkLCAuLi4pXG4gICAgICAgIHZhciBpLCBsZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHdpbmRvd1Byb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl91bnNldChpZnJhbWVXaW5kb3csIHdpbmRvd1Byb3BlcnRpZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHdpbmRvd1Byb3BlcnRpZXMyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5fdW5zZXQoaWZyYW1lV2luZG93LCB3aW5kb3dQcm9wZXJ0aWVzMltpXSwgd3lzaWh0bWw1LkVNUFRZX0ZVTkNUSU9OKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBkb2N1bWVudFByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl91bnNldChpZnJhbWVEb2N1bWVudCwgZG9jdW1lbnRQcm9wZXJ0aWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGRvZXNuJ3Qgd29yayBpbiBTYWZhcmkgNSBcbiAgICAgICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTkyNDYxL2lzLWl0LXBvc3NpYmxlLXRvLW92ZXJyaWRlLWRvY3VtZW50LWNvb2tpZS1pbi13ZWJraXRcbiAgICAgICAgdGhpcy5fdW5zZXQoaWZyYW1lRG9jdW1lbnQsIFwiY29va2llXCIsIFwiXCIsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG5cbiAgICAgIC8vIFRyaWdnZXIgdGhlIGNhbGxiYWNrXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5jYWxsYmFjayh0aGF0KTtcbiAgICAgIH0sIDApO1xuICAgIH0sXG5cbiAgICBfZ2V0SHRtbDogZnVuY3Rpb24gX2dldEh0bWwodGVtcGxhdGVWYXJzKSB7XG4gICAgICB2YXIgc3R5bGVzaGVldHMgPSB0ZW1wbGF0ZVZhcnMuc3R5bGVzaGVldHMsXG4gICAgICAgICAgaHRtbCA9IFwiXCIsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbGVuZ3RoO1xuICAgICAgc3R5bGVzaGVldHMgPSB0eXBlb2Ygc3R5bGVzaGVldHMgPT09IFwic3RyaW5nXCIgPyBbc3R5bGVzaGVldHNdIDogc3R5bGVzaGVldHM7XG4gICAgICBpZiAoc3R5bGVzaGVldHMpIHtcbiAgICAgICAgbGVuZ3RoID0gc3R5bGVzaGVldHMubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaHRtbCArPSAnPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIGhyZWY9XCInICsgc3R5bGVzaGVldHNbaV0gKyAnXCI+JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGVtcGxhdGVWYXJzLnN0eWxlc2hlZXRzID0gaHRtbDtcblxuICAgICAgcmV0dXJuIHd5c2lodG1sNS5sYW5nLnN0cmluZygnPCFET0NUWVBFIGh0bWw+PGh0bWw+PGhlYWQ+JyArICc8bWV0YSBjaGFyc2V0PVwiI3tjaGFyc2V0fVwiPiN7c3R5bGVzaGVldHN9PC9oZWFkPicgKyAnPGJvZHk+PC9ib2R5PjwvaHRtbD4nKS5pbnRlcnBvbGF0ZSh0ZW1wbGF0ZVZhcnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gdW5zZXQvb3ZlcnJpZGUgZXhpc3RpbmcgdmFyaWFibGVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAvLyBNYWtlIGNvb2tpZSB1bnJlYWRhYmxlIGFuZCB1bndyaXRhYmxlXG4gICAgICogICAgdGhpcy5fdW5zZXQoZG9jdW1lbnQsIFwiY29va2llXCIsIFwiXCIsIHRydWUpO1xuICAgICAqL1xuICAgIF91bnNldDogZnVuY3Rpb24gX3Vuc2V0KG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBzZXR0ZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG9iamVjdC5fX2RlZmluZUdldHRlcl9fKHByb3BlcnR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb2JqZWN0Ll9fZGVmaW5lU2V0dGVyX18ocHJvcGVydHksIGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cblxuICAgICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5jcmFzaGVzV2hlbkRlZmluZVByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICAgICAgY29uZmlnLnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgY29uZmlnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSkod3lzaWh0bWw1KTtcbihmdW5jdGlvbiAoKSB7XG4gIHZhciBtYXBwaW5nID0ge1xuICAgIFwiY2xhc3NOYW1lXCI6IFwiY2xhc3NcIlxuICB9O1xuICB3eXNpaHRtbDUuZG9tLnNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0cmlidXRlcykge1xuICAgIHJldHVybiB7XG4gICAgICBvbjogZnVuY3Rpb24gb24oZWxlbWVudCkge1xuICAgICAgICBmb3IgKHZhciBpIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShtYXBwaW5nW2ldIHx8IGksIGF0dHJpYnV0ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn0pKCk7d3lzaWh0bWw1LmRvbS5zZXRTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gIHJldHVybiB7XG4gICAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgICBpZiAodHlwZW9mIHN0eWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdHlsZS5jc3NUZXh0ICs9IFwiO1wiICsgc3R5bGVzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpIGluIHN0eWxlcykge1xuICAgICAgICBpZiAoaSA9PT0gXCJmbG9hdFwiKSB7XG4gICAgICAgICAgc3R5bGUuY3NzRmxvYXQgPSBzdHlsZXNbaV07XG4gICAgICAgICAgc3R5bGUuc3R5bGVGbG9hdCA9IHN0eWxlc1tpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZVtpXSA9IHN0eWxlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07IC8qKlxuICAgKiBTaW11bGF0ZSBIVE1MNSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgICpcbiAgICogTmVlZGVkIHNpbmNlXG4gICAqICAgIC0gZGl2W2NvbnRlbnRFZGl0YWJsZV0gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpdFxuICAgKiAgICAtIG9sZGVyIGJyb3dzZXJzIChzdWNoIGFzIElFOCBhbmQgRmlyZWZveCAzLjYpIGRvbid0IHN1cHBvcnQgaXQgYXQgYWxsXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgSW5zdGFuY2Ugb2YgbWFpbiB3eXNpaHRtbDUuRWRpdG9yIGNsYXNzXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdmlldyBJbnN0YW5jZSBvZiB3eXNpaHRtbDUudmlld3MuKiBjbGFzc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcGxhY2Vob2xkZXJUZXh0XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgIHd5c2lodG1sLmRvbS5zaW11bGF0ZVBsYWNlaG9sZGVyKHRoaXMsIGNvbXBvc2VyLCBcIkZvb2JhclwiKTtcbiAgICovXG4oZnVuY3Rpb24gKGRvbSkge1xuICBkb20uc2ltdWxhdGVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChlZGl0b3IsIHZpZXcsIHBsYWNlaG9sZGVyVGV4dCkge1xuICAgIHZhciBDTEFTU19OQU1FID0gXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICB1bnNldCA9IGZ1bmN0aW9uIHVuc2V0KCkge1xuICAgICAgaWYgKHZpZXcuaGFzUGxhY2Vob2xkZXJTZXQoKSkge1xuICAgICAgICB2aWV3LmNsZWFyKCk7XG4gICAgICB9XG4gICAgICBkb20ucmVtb3ZlQ2xhc3Modmlldy5lbGVtZW50LCBDTEFTU19OQU1FKTtcbiAgICB9LFxuICAgICAgICBzZXQgPSBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICBpZiAodmlldy5pc0VtcHR5KCkpIHtcbiAgICAgICAgdmlldy5zZXRWYWx1ZShwbGFjZWhvbGRlclRleHQpO1xuICAgICAgICBkb20uYWRkQ2xhc3Modmlldy5lbGVtZW50LCBDTEFTU19OQU1FKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZWRpdG9yLm9ic2VydmUoXCJzZXRfcGxhY2Vob2xkZXJcIiwgc2V0KS5vYnNlcnZlKFwidW5zZXRfcGxhY2Vob2xkZXJcIiwgdW5zZXQpLm9ic2VydmUoXCJmb2N1czpjb21wb3NlclwiLCB1bnNldCkub2JzZXJ2ZShcInBhc3RlOmNvbXBvc2VyXCIsIHVuc2V0KS5vYnNlcnZlKFwiYmx1cjpjb21wb3NlclwiLCBzZXQpO1xuXG4gICAgc2V0KCk7XG4gIH07XG59KSh3eXNpaHRtbDUuZG9tKTtcbihmdW5jdGlvbiAoZG9tKSB7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmIChcInRleHRDb250ZW50XCIgaW4gZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgZG9tLnNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRleHQpIHtcbiAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIH07XG5cbiAgICBkb20uZ2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChcImlubmVyVGV4dFwiIGluIGRvY3VtZW50RWxlbWVudCkge1xuICAgIGRvbS5zZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZXh0KSB7XG4gICAgICBlbGVtZW50LmlubmVyVGV4dCA9IHRleHQ7XG4gICAgfTtcblxuICAgIGRvbS5nZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5pbm5lclRleHQ7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBkb20uc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgdGV4dCkge1xuICAgICAgZWxlbWVudC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgIH07XG5cbiAgICBkb20uZ2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubm9kZVZhbHVlO1xuICAgIH07XG4gIH1cbn0pKHd5c2lodG1sNS5kb20pO1xuXG4vKipcbiAqIEZpeCBtb3N0IGNvbW1vbiBodG1sIGZvcm1hdHRpbmcgbWlzYmVoYXZpb3JzIG9mIGJyb3dzZXJzIGltcGxlbWVudGF0aW9uIHdoZW4gaW5zZXJ0aW5nXG4gKiBjb250ZW50IHZpYSBjb3B5ICYgcGFzdGUgY29udGVudEVkaXRhYmxlXG4gKlxuICogQGF1dGhvciBDaHJpc3RvcGhlciBCbHVtXG4gKi9cbnd5c2lodG1sNS5xdWlya3MuY2xlYW5QYXN0ZWRIVE1MID0gZnVuY3Rpb24gKCkge1xuICAvLyBUT0RPOiBXZSBwcm9iYWJseSBuZWVkIG1vcmUgcnVsZXMgaGVyZVxuICB2YXIgZGVmYXVsdFJ1bGVzID0ge1xuICAgIC8vIFdoZW4gcGFzdGluZyB1bmRlcmxpbmVkIGxpbmtzIDxhPiBpbnRvIGEgY29udGVudEVkaXRhYmxlLCBJRSB0aGlua3MsIGl0IGhhcyB0byBpbnNlcnQgPHU+IHRvIGtlZXAgdGhlIHN0eWxpbmdcbiAgICBcImEgdVwiOiB3eXNpaHRtbDUuZG9tLnJlcGxhY2VXaXRoQ2hpbGROb2Rlc1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNsZWFuUGFzdGVkSFRNTChlbGVtZW50T3JIdG1sLCBydWxlcywgY29udGV4dCkge1xuICAgIHJ1bGVzID0gcnVsZXMgfHwgZGVmYXVsdFJ1bGVzO1xuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGVsZW1lbnRPckh0bWwub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblxuICAgIHZhciBlbGVtZW50LFxuICAgICAgICBpc1N0cmluZyA9IHR5cGVvZiBlbGVtZW50T3JIdG1sID09PSBcInN0cmluZ1wiLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIG1hdGNoZXNMZW5ndGgsXG4gICAgICAgIGksXG4gICAgICAgIGogPSAwO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgZWxlbWVudCA9IHd5c2lodG1sNS5kb20uZ2V0QXNEb20oZWxlbWVudE9ySHRtbCwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50T3JIdG1sO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9IGVsZW1lbnQuaW5uZXJIVE1MLnJlcGxhY2UoL1xcbi9nLCAnPC9icj4nKVxuICAgICAgdmFyIGVscyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsID0gZWxzW2ldO1xuICAgICAgICBlbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH1cbiAgICAgIHZhciBkaXZzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdkaXYnKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGl2cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGl2ID0gZGl2c1tpXTtcbiAgICAgICAgdmFyIG5ld19kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgICAgIG5ld19kaXYuaW5uZXJUZXh0ID0gZGl2LmlubmVyVGV4dDtcbiAgICAgICAgZGl2LnJlcGxhY2VXaXRoKG5ld19kaXYpO1xuICAgICAgfVxuICAgICAgdmFyIHBfZWxzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdwJyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBfZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbCA9IHBfZWxzW2ldO1xuICAgICAgICBpZiAoISQudHJpbShlbC5pbm5lclRleHQpLmxlbmd0aCkge1xuICAgICAgICAgIGVsLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYnJfZWxzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdicicpO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUoaSA8IGJyX2Vscy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHZhciBiciA9IGJyX2Vsc1tpXTtcbiAgICAgICAgd2hpbGUgKGJyLm5leHRTaWJsaW5nID09IGJyX2Vsc1tpICsgMV0pIHtcbiAgICAgICAgICB2YXIgZWwgPSBicl9lbHNbaSArIDFdO1xuICAgICAgICAgIGVsLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyX2Vscy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgYnJfZWxzW2ldXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpIGluIHJ1bGVzKSB7XG4gICAgICBtYXRjaGVzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGkpO1xuICAgICAgbWV0aG9kID0gcnVsZXNbaV07XG4gICAgICBtYXRjaGVzTGVuZ3RoID0gbWF0Y2hlcy5sZW5ndGg7XG4gICAgICBmb3IgKDsgaiA8IG1hdGNoZXNMZW5ndGg7IGorKykge1xuICAgICAgICBtZXRob2QobWF0Y2hlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWF0Y2hlcyA9IGVsZW1lbnRPckh0bWwgPSBydWxlcyA9IG51bGw7XG5cbiAgICByZXR1cm4gaXNTdHJpbmcgPyBlbGVtZW50LmlubmVySFRNTCA6IGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gY2xlYW5QYXN0ZWRIVE1MO1xufSgpOyAvKipcbiAgICAgKiBJRSBhbmQgT3BlcmEgbGVhdmUgYW4gZW1wdHkgcGFyYWdyYXBoIGluIHRoZSBjb250ZW50RWRpdGFibGUgZWxlbWVudCBhZnRlciBjbGVhcmluZyBpdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRlbnRFZGl0YWJsZUVsZW1lbnQgVGhlIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50IHRvIG9ic2VydmUgZm9yIGNsZWFyaW5nIGV2ZW50c1xuICAgICAqIEBleGFwbGVcbiAgICAgKiAgICB3eXNpaHRtbDUucXVpcmtzLmVuc3VyZVByb3BlckNsZWFyaW5nKG15Q29udGVudEVkaXRhYmxlRWxlbWVudCk7XG4gICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgZG9tID0gd3lzaWh0bWw1LmRvbTtcblxuICB3eXNpaHRtbDUucXVpcmtzLmVuc3VyZVByb3BlckNsZWFyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGVhcklmTmVjZXNzYXJ5ID0gZnVuY3Rpb24gY2xlYXJJZk5lY2Vzc2FyeShldmVudCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lckhUTUwgPSBlbGVtZW50LmlubmVySFRNTC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoaW5uZXJIVE1MID09IFwiPHA+Jm5ic3A7PC9wPlwiIHx8IGlubmVySFRNTCA9PSBcIjxwPiZuYnNwOzwvcD48cD4mbmJzcDs8L3A+XCIpIHtcbiAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbXBvc2VyKSB7XG4gICAgICBkb20ub2JzZXJ2ZShjb21wb3Nlci5lbGVtZW50LCBbXCJjdXRcIiwgXCJrZXlkb3duXCJdLCBjbGVhcklmTmVjZXNzYXJ5KTtcbiAgICB9O1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIEluIE9wZXJhIHdoZW4gdGhlIGNhcmV0IGlzIGluIHRoZSBmaXJzdCBhbmQgb25seSBpdGVtIG9mIGEgbGlzdCAoPHVsPjxsaT58PC9saT48L3VsPikgYW5kIHRoZSBsaXN0IGlzIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgY29udGVudEVkaXRhYmxlIGVsZW1lbnQsIGl0J3MgaW1wb3NzaWJsZSB0byBkZWxldGUgdGhlIGxpc3QgYnkgaGl0dGluZyBiYWNrc3BhY2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRlbnRFZGl0YWJsZUVsZW1lbnQgVGhlIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50IHRvIG9ic2VydmUgZm9yIGNsZWFyaW5nIGV2ZW50c1xuICAgKiBAZXhhcGxlXG4gICAqICAgIHd5c2lodG1sNS5xdWlya3MuZW5zdXJlUHJvcGVyQ2xlYXJpbmcobXlDb250ZW50RWRpdGFibGVFbGVtZW50KTtcbiAgICovXG4gIHd5c2lodG1sNS5xdWlya3MuZW5zdXJlUHJvcGVyQ2xlYXJpbmdPZkxpc3RzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBFTEVNRU5UU19USEFUX0NPTlRBSU5fTEkgPSBbXCJPTFwiLCBcIlVMXCIsIFwiTUVOVVwiXTtcblxuICAgIHZhciBjbGVhcklmTmVjZXNzYXJ5ID0gZnVuY3Rpb24gY2xlYXJJZk5lY2Vzc2FyeShlbGVtZW50LCBjb250ZW50RWRpdGFibGVFbGVtZW50KSB7XG4gICAgICBpZiAoIWNvbnRlbnRFZGl0YWJsZUVsZW1lbnQuZmlyc3RDaGlsZCB8fCAhd3lzaWh0bWw1LmxhbmcuYXJyYXkoRUxFTUVOVFNfVEhBVF9DT05UQUlOX0xJKS5jb250YWlucyhjb250ZW50RWRpdGFibGVFbGVtZW50LmZpcnN0Q2hpbGQubm9kZU5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpc3QgPSBkb20uZ2V0UGFyZW50RWxlbWVudChlbGVtZW50LCB7IG5vZGVOYW1lOiBFTEVNRU5UU19USEFUX0NPTlRBSU5fTEkgfSk7XG4gICAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGlzdElzRmlyc3RDaGlsZE9mQ29udGVudEVkaXRhYmxlID0gbGlzdCA9PSBjb250ZW50RWRpdGFibGVFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICBpZiAoIWxpc3RJc0ZpcnN0Q2hpbGRPZkNvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNPbmx5T25lTGlzdEl0ZW0gPSBsaXN0LmNoaWxkTm9kZXMubGVuZ3RoIDw9IDE7XG4gICAgICBpZiAoIWhhc09ubHlPbmVMaXN0SXRlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvbmx5TGlzdEl0ZW1Jc0VtcHR5ID0gbGlzdC5maXJzdENoaWxkID8gbGlzdC5maXJzdENoaWxkLmlubmVySFRNTCA9PT0gXCJcIiA6IHRydWU7XG4gICAgICBpZiAoIW9ubHlMaXN0SXRlbUlzRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsaXN0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGlzdCk7XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoY29tcG9zZXIpIHtcbiAgICAgIGRvbS5vYnNlcnZlKGNvbXBvc2VyLmVsZW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgIT09IHd5c2lodG1sNS5CQUNLU1BBQ0VfS0VZKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICAgIGNsZWFySWZOZWNlc3NhcnkoZWxlbWVudCwgY29tcG9zZXIuZWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9KCk7XG59KSh3eXNpaHRtbDUpO1xuLy8gU2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY2NDM5OFxuLy9cbi8vIEluIEZpcmVmb3ggdGhpczpcbi8vICAgICAgdmFyIGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuLy8gICAgICBkLmlubmVySFRNTCA9JzxhIGhyZWY9XCJ+XCI+PC9hPic7XG4vLyAgICAgIGQuaW5uZXJIVE1MO1xuLy8gd2lsbCByZXN1bHQgaW46XG4vLyAgICAgIDxhIGhyZWY9XCIlN0VcIj48L2E+XG4vLyB3aGljaCBpcyB3cm9uZ1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIFRJTERFX0VTQ0FQRUQgPSBcIiU3RVwiO1xuICB3eXNpaHRtbDUucXVpcmtzLmdldENvcnJlY3RJbm5lckhUTUwgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBpbm5lckhUTUwgPSBlbGVtZW50LmlubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MLmluZGV4T2YoVElMREVfRVNDQVBFRCkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gaW5uZXJIVE1MO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50c1dpdGhUaWxkZSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltocmVmKj0nfiddLCBbc3JjKj0nfiddXCIpLFxuICAgICAgICB1cmwsXG4gICAgICAgIHVybFRvU2VhcmNoLFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGk7XG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gZWxlbWVudHNXaXRoVGlsZGUubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHVybCA9IGVsZW1lbnRzV2l0aFRpbGRlW2ldLmhyZWYgfHwgZWxlbWVudHNXaXRoVGlsZGVbaV0uc3JjO1xuICAgICAgdXJsVG9TZWFyY2ggPSB3eXNpaHRtbDUubGFuZy5zdHJpbmcodXJsKS5yZXBsYWNlKFwiflwiKS5ieShUSUxERV9FU0NBUEVEKTtcbiAgICAgIGlubmVySFRNTCA9IHd5c2lodG1sNS5sYW5nLnN0cmluZyhpbm5lckhUTUwpLnJlcGxhY2UodXJsVG9TZWFyY2gpLmJ5KHVybCk7XG4gICAgfVxuICAgIHJldHVybiBpbm5lckhUTUw7XG4gIH07XG59KSh3eXNpaHRtbDUpOyAvKipcbiAgICAgICAgICAgICAgICogU29tZSBicm93c2VycyBkb24ndCBpbnNlcnQgbGluZSBicmVha3Mgd2hlbiBoaXR0aW5nIHJldHVybiBpbiBhIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50XG4gICAgICAgICAgICAgICAqICAgIC0gT3BlcmEgJiBJRSBpbnNlcnQgbmV3IDxwPiBvbiByZXR1cm5cbiAgICAgICAgICAgICAgICogICAgLSBDaHJvbWUgJiBTYWZhcmkgaW5zZXJ0IG5ldyA8ZGl2PiBvbiByZXR1cm5cbiAgICAgICAgICAgICAgICogICAgLSBGaXJlZm94IGluc2VydHMgPGJyPiBvbiByZXR1cm4gKHlpcHBpZSEpXG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgKiAgICB3eXNpaHRtbDUucXVpcmtzLmluc2VydExpbmVCcmVha09uUmV0dXJuKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciBkb20gPSB3eXNpaHRtbDUuZG9tLFxuICAgICAgVVNFX05BVElWRV9MSU5FX0JSRUFLX1dIRU5fQ0FSRVRfSU5TSURFX1RBR1MgPSBbXCJMSVwiLCBcIlBcIiwgXCJIMVwiLCBcIkgyXCIsIFwiSDNcIiwgXCJINFwiLCBcIkg1XCIsIFwiSDZcIl0sXG4gICAgICBMSVNUX1RBR1MgPSBbXCJVTFwiLCBcIk9MXCIsIFwiTUVOVVwiXTtcblxuICB3eXNpaHRtbDUucXVpcmtzLmluc2VydExpbmVCcmVha09uUmV0dXJuID0gZnVuY3Rpb24gKGNvbXBvc2VyKSB7XG4gICAgZnVuY3Rpb24gdW53cmFwKHNlbGVjdGVkTm9kZSkge1xuICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSBkb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHsgbm9kZU5hbWU6IFtcIlBcIiwgXCJESVZcIl0gfSwgMik7XG4gICAgICBpZiAoIXBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW52aXNpYmxlU3BhY2UgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFKTtcbiAgICAgIGRvbS5pbnNlcnQoaW52aXNpYmxlU3BhY2UpLmJlZm9yZShwYXJlbnRFbGVtZW50KTtcbiAgICAgIGRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXMocGFyZW50RWxlbWVudCk7XG4gICAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2VsZWN0Tm9kZShpbnZpc2libGVTcGFjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga2V5RG93bihldmVudCkge1xuICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5IHx8IGtleUNvZGUgIT09IHd5c2lodG1sNS5FTlRFUl9LRVkgJiYga2V5Q29kZSAhPT0gd3lzaWh0bWw1LkJBQ0tTUEFDRV9LRVkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICBzZWxlY3RlZE5vZGUgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCksXG4gICAgICAgICAgYmxvY2tFbGVtZW50ID0gZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBVU0VfTkFUSVZFX0xJTkVfQlJFQUtfV0hFTl9DQVJFVF9JTlNJREVfVEFHUyB9LCA0KTtcbiAgICAgIGlmIChibG9ja0VsZW1lbnQpIHtcbiAgICAgICAgLy8gU29tZSBicm93c2VycyBjcmVhdGUgPHA+IGVsZW1lbnRzIGFmdGVyIGxlYXZpbmcgYSBsaXN0XG4gICAgICAgIC8vIGNoZWNrIGFmdGVyIGtleWRvd24gb2YgYmFja3NwYWNlIGFuZCByZXR1cm4gd2hldGhlciBhIDxwPiBnb3QgaW5zZXJ0ZWQgYW5kIHVud3JhcCBpdFxuICAgICAgICBpZiAoYmxvY2tFbGVtZW50Lm5vZGVOYW1lID09PSBcIkxJXCIgJiYgKGtleUNvZGUgPT09IHd5c2lodG1sNS5FTlRFUl9LRVkgfHwga2V5Q29kZSA9PT0gd3lzaWh0bWw1LkJBQ0tTUEFDRV9LRVkpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSgpLFxuICAgICAgICAgICAgICAgIGxpc3QsXG4gICAgICAgICAgICAgICAgZGl2O1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZE5vZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaXN0ID0gZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7XG4gICAgICAgICAgICAgIG5vZGVOYW1lOiBMSVNUX1RBR1NcbiAgICAgICAgICAgIH0sIDIpO1xuXG4gICAgICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVud3JhcChzZWxlY3RlZE5vZGUpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGJsb2NrRWxlbWVudC5ub2RlTmFtZS5tYXRjaCgvSFsxLTZdLykgJiYga2V5Q29kZSA9PT0gd3lzaWh0bWw1LkVOVEVSX0tFWSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdW53cmFwKGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKSk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5Q29kZSA9PT0gd3lzaWh0bWw1LkVOVEVSX0tFWSAmJiAhd3lzaWh0bWw1LmJyb3dzZXIuaW5zZXJ0c0xpbmVCcmVha3NPblJldHVybigpKSB7XG4gICAgICAgIGNvbXBvc2VyLmNvbW1hbmRzLmV4ZWMoXCJpbnNlcnRMaW5lQnJlYWtcIik7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8ga2V5cHJlc3MgZG9lc24ndCBmaXJlIHdoZW4geW91IGhpdCBiYWNrc3BhY2VcbiAgICBkb20ub2JzZXJ2ZShjb21wb3Nlci5lbGVtZW50Lm93bmVyRG9jdW1lbnQsIFwia2V5ZG93blwiLCBrZXlEb3duKTtcbiAgfTtcbn0pKHd5c2lodG1sNSk7IC8qKlxuICAgICAgICAgICAgICAgKiBGb3JjZSByZXJlbmRlcmluZyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAgICAgICAgICAgICAgICogTmVlZGVkIHRvIGZpeCBkaXNwbGF5IG1pc2JlaGF2aW9ycyBvZiBJRVxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb2JqZWN0IHdoaWNoIG5lZWRzIHRvIGJlIHJlcmVuZGVyZWRcbiAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICogICAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIENMQVNTX05BTUUgPSBcInd5c2lodG1sNS1xdWlya3MtcmVkcmF3XCI7XG5cbiAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHd5c2lodG1sNS5kb20uYWRkQ2xhc3MoZWxlbWVudCwgQ0xBU1NfTkFNRSk7XG4gICAgd3lzaWh0bWw1LmRvbS5yZW1vdmVDbGFzcyhlbGVtZW50LCBDTEFTU19OQU1FKTtcblxuICAgIC8vIEZvbGxvd2luZyBoYWNrIGlzIG5lZWRlZCBmb3IgZmlyZWZveCB0byBtYWtlIHN1cmUgdGhhdCBpbWFnZSByZXNpemUgaGFuZGxlcyBhcmUgcHJvcGVybHkgcmVtb3ZlZFxuICAgIHRyeSB7XG4gICAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgICAgZG9jLmV4ZWNDb21tYW5kKFwiaXRhbGljXCIsIGZhbHNlLCBudWxsKTtcbiAgICAgIGRvYy5leGVjQ29tbWFuZChcIml0YWxpY1wiLCBmYWxzZSwgbnVsbCk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfTtcbn0pKHd5c2lodG1sNSk7IC8qKlxuICAgICAgICAgICAgICAgKiBTZWxlY3Rpb24gQVBJXG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAqICAgIHZhciBzZWxlY3Rpb24gPSBuZXcgd3lzaWh0bWw1LlNlbGVjdGlvbihlZGl0b3IpO1xuICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciBkb20gPSB3eXNpaHRtbDUuZG9tO1xuXG4gIGZ1bmN0aW9uIF9nZXRDdW11bGF0aXZlT2Zmc2V0VG9wKGVsZW1lbnQpIHtcbiAgICB2YXIgdG9wID0gMDtcbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHRvcCArPSBlbGVtZW50Lm9mZnNldFRvcCB8fCAwO1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICB9IHdoaWxlIChlbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcDtcbiAgfVxuXG4gIHd5c2lodG1sNS5TZWxlY3Rpb24gPSBCYXNlLmV4dGVuZChcbiAgLyoqIEBzY29wZSB3eXNpaHRtbDUuU2VsZWN0aW9uLnByb3RvdHlwZSAqL3tcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCBvdXIgZXh0ZXJuYWwgcmFuZ2UgbGlicmFyeSBpcyBpbml0aWFsaXplZFxuICAgICAgd2luZG93LnJhbmd5LmluaXQoKTtcblxuICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICB0aGlzLmNvbXBvc2VyID0gZWRpdG9yLmNvbXBvc2VyO1xuICAgICAgdGhpcy5kb2MgPSB0aGlzLmNvbXBvc2VyLmRvYztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHNlbGVjdGlvbiBhcyBhIGJvb2ttYXJrIHRvIGJlIGFibGUgdG8gbGF0ZXIgcmVzdG9yZSBpdFxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAqL1xuICAgIGdldEJvb2ttYXJrOiBmdW5jdGlvbiBnZXRCb29rbWFyaygpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICAgIHJldHVybiByYW5nZSAmJiByYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgYSBzZWxlY3Rpb24gcmV0cmlldmVkIHZpYSB3eXNpaHRtbDUuU2VsZWN0aW9uLnByb3RvdHlwZS5nZXRCb29rbWFya1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJvb2ttYXJrIEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICovXG4gICAgc2V0Qm9va21hcms6IGZ1bmN0aW9uIHNldEJvb2ttYXJrKGJvb2ttYXJrKSB7XG4gICAgICBpZiAoIWJvb2ttYXJrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oYm9va21hcmspO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNhcmV0IGluIGZyb250IG9mIHRoZSBnaXZlbiBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBUaGUgZWxlbWVudCBvciB0ZXh0IG5vZGUgd2hlcmUgdG8gcG9zaXRpb24gdGhlIGNhcmV0IGluIGZyb250IG9mXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICBzZWxlY3Rpb24uc2V0QmVmb3JlKG15RWxlbWVudCk7XG4gICAgICovXG4gICAgc2V0QmVmb3JlOiBmdW5jdGlvbiBzZXRCZWZvcmUobm9kZSkge1xuICAgICAgdmFyIHJhbmdlID0gcmFuZ3kuY3JlYXRlUmFuZ2UodGhpcy5kb2MpO1xuICAgICAgcmFuZ2Uuc2V0U3RhcnRCZWZvcmUobm9kZSk7XG4gICAgICByYW5nZS5zZXRFbmRCZWZvcmUobm9kZSk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRTZWxlY3Rpb24ocmFuZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNhcmV0IGFmdGVyIHRoZSBnaXZlbiBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBUaGUgZWxlbWVudCBvciB0ZXh0IG5vZGUgd2hlcmUgdG8gcG9zaXRpb24gdGhlIGNhcmV0IGluIGZyb250IG9mXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICBzZWxlY3Rpb24uc2V0QmVmb3JlKG15RWxlbWVudCk7XG4gICAgICovXG4gICAgc2V0QWZ0ZXI6IGZ1bmN0aW9uIHNldEFmdGVyKG5vZGUpIHtcbiAgICAgIHZhciByYW5nZSA9IHJhbmd5LmNyZWF0ZVJhbmdlKHRoaXMuZG9jKTtcbiAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIobm9kZSk7XG4gICAgICByYW5nZS5zZXRFbmRBZnRlcihub2RlKTtcbiAgICAgIHJldHVybiB0aGlzLnNldFNlbGVjdGlvbihyYW5nZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFiaWxpdHkgdG8gc2VsZWN0L21hcmsgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBUaGUgbm9kZS9lbGVtZW50IHRvIHNlbGVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgc2VsZWN0aW9uLnNlbGVjdE5vZGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJteS1pbWFnZVwiKSk7XG4gICAgICovXG4gICAgc2VsZWN0Tm9kZTogZnVuY3Rpb24gc2VsZWN0Tm9kZShub2RlKSB7XG4gICAgICB2YXIgcmFuZ2UgPSByYW5neS5jcmVhdGVSYW5nZSh0aGlzLmRvYyksXG4gICAgICAgICAgaXNFbGVtZW50ID0gbm9kZS5ub2RlVHlwZSA9PT0gd3lzaWh0bWw1LkVMRU1FTlRfTk9ERSxcbiAgICAgICAgICBjYW5IYXZlSFRNTCA9IFwiY2FuSGF2ZUhUTUxcIiBpbiBub2RlID8gbm9kZS5jYW5IYXZlSFRNTCA6IG5vZGUubm9kZU5hbWUgIT09IFwiSU1HXCIsXG4gICAgICAgICAgY29udGVudCA9IGlzRWxlbWVudCA/IG5vZGUuaW5uZXJIVE1MIDogbm9kZS5kYXRhLFxuICAgICAgICAgIGlzRW1wdHkgPSBjb250ZW50ID09PSBcIlwiIHx8IGNvbnRlbnQgPT09IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UsXG4gICAgICAgICAgZGlzcGxheVN0eWxlID0gZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKG5vZGUpLFxuICAgICAgICAgIGlzQmxvY2tFbGVtZW50ID0gZGlzcGxheVN0eWxlID09PSBcImJsb2NrXCIgfHwgZGlzcGxheVN0eWxlID09PSBcImxpc3QtaXRlbVwiO1xuXG4gICAgICBpZiAoaXNFbXB0eSAmJiBpc0VsZW1lbnQgJiYgY2FuSGF2ZUhUTUwpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgY2FyZXQgaXMgdmlzaWJsZSBpbiBub2RlIGJ5IGluc2VydGluZyBhIHplcm8gd2lkdGggbm8gYnJlYWtpbmcgc3BhY2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBub2RlLmlubmVySFRNTCA9IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0U7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5IYXZlSFRNTCkge1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuSGF2ZUhUTUwgJiYgaXNFbXB0eSAmJiBpc0VsZW1lbnQpIHtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2UoaXNCbG9ja0VsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChjYW5IYXZlSFRNTCAmJiBpc0VtcHR5KSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIobm9kZSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFNlbGVjdGlvbihyYW5nZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbm9kZSB3aGljaCBjb250YWlucyB0aGUgc2VsZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb250cm9sUmFuZ2VdIChvbmx5IElFKSBXaGV0aGVyIGl0IHNob3VsZCByZXR1cm4gdGhlIHNlbGVjdGVkIENvbnRyb2xSYW5nZSBlbGVtZW50IHdoZW4gdGhlIHNlbGVjdGlvbiB0eXBlIGlzIGEgXCJDb250cm9sUmFuZ2VcIlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5vZGUgdGhhdCBjb250YWlucyB0aGUgY2FyZXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHZhciBub2RlVGhhdENvbnRhaW5zQ2FyZXQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWROb2RlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZE5vZGUoY29udHJvbFJhbmdlKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uLCByYW5nZTtcblxuICAgICAgaWYgKGNvbnRyb2xSYW5nZSAmJiB0aGlzLmRvYy5zZWxlY3Rpb24gJiYgdGhpcy5kb2Muc2VsZWN0aW9uLnR5cGUgPT09IFwiQ29udHJvbFwiKSB7XG4gICAgICAgIHJhbmdlID0gdGhpcy5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIGlmIChyYW5nZSAmJiByYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcmFuZ2UuaXRlbSgwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbih0aGlzLmRvYyk7XG4gICAgICBpZiAoc2VsZWN0aW9uLmZvY3VzTm9kZSA9PT0gc2VsZWN0aW9uLmFuY2hvck5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UodGhpcy5kb2MpO1xuICAgICAgICByZXR1cm4gcmFuZ2UgPyByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lciA6IHRoaXMuZG9jLmJvZHk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGV4ZWN1dGVBbmRSZXN0b3JlOiBmdW5jdGlvbiBleGVjdXRlQW5kUmVzdG9yZShtZXRob2QsIHJlc3RvcmVTY3JvbGxQb3NpdGlvbikge1xuICAgICAgdmFyIGJvZHkgPSB0aGlzLmRvYy5ib2R5LFxuICAgICAgICAgIG9sZFNjcm9sbFRvcCA9IHJlc3RvcmVTY3JvbGxQb3NpdGlvbiAmJiBib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICBvbGRTY3JvbGxMZWZ0ID0gcmVzdG9yZVNjcm9sbFBvc2l0aW9uICYmIGJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgICBjbGFzc05hbWUgPSBcIl93eXNpaHRtbDUtdGVtcC1wbGFjZWhvbGRlclwiLFxuICAgICAgICAgIHBsYWNlaG9sZGVySFRNTCA9ICc8c3BhbiBjbGFzcz1cIicgKyBjbGFzc05hbWUgKyAnXCI+JyArIHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UgKyAnPC9zcGFuPicsXG4gICAgICAgICAgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKHRoaXMuZG9jKSxcbiAgICAgICAgICBuZXdSYW5nZTtcblxuICAgICAgLy8gTm90aGluZyBzZWxlY3RlZCwgZXhlY3V0ZSBhbmQgc2F5IGdvb2RieWVcbiAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgbWV0aG9kKGJvZHksIGJvZHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHBsYWNlaG9sZGVySFRNTCk7XG4gICAgICByYW5nZS5pbnNlcnROb2RlKG5vZGUpO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCBhIHBvdGVudGlhbCBlcnJvciBkb2Vzbid0IGNhdXNlIG91ciBwbGFjZWhvbGRlciBlbGVtZW50IHRvIGJlIGxlZnQgYXMgYSBwbGFjZWhvbGRlclxuICAgICAgdHJ5IHtcbiAgICAgICAgbWV0aG9kKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5lbmRDb250YWluZXIpO1xuICAgICAgfSBjYXRjaCAoZTMpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZTM7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuXG4gICAgICBjYXJldFBsYWNlaG9sZGVyID0gdGhpcy5kb2MucXVlcnlTZWxlY3RvcihcIi5cIiArIGNsYXNzTmFtZSk7XG4gICAgICBpZiAoY2FyZXRQbGFjZWhvbGRlcikge1xuICAgICAgICBuZXdSYW5nZSA9IHJhbmd5LmNyZWF0ZVJhbmdlKHRoaXMuZG9jKTtcbiAgICAgICAgbmV3UmFuZ2Uuc2VsZWN0Tm9kZShjYXJldFBsYWNlaG9sZGVyKTtcbiAgICAgICAgbmV3UmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24obmV3UmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgZm9yIHdoZW4gYWxsIGhlbGwgYnJlYWtzIGxvb3NlXG4gICAgICAgIGJvZHkuZm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3RvcmVTY3JvbGxQb3NpdGlvbikge1xuICAgICAgICBib2R5LnNjcm9sbFRvcCA9IG9sZFNjcm9sbFRvcDtcbiAgICAgICAgYm9keS5zY3JvbGxMZWZ0ID0gb2xkU2Nyb2xsTGVmdDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGl0IGFnYWluLCBqdXN0IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBwbGFjZWhvbGRlciBpcyBkZWZpbml0ZWx5IG91dCBvZiB0aGUgZG9tIHRyZWVcbiAgICAgIHRyeSB7XG4gICAgICAgIGNhcmV0UGxhY2Vob2xkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjYXJldFBsYWNlaG9sZGVyKTtcbiAgICAgIH0gY2F0Y2ggKGU0KSB7fVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaWZmZXJlbnQgYXBwcm9hY2ggb2YgcHJlc2VydmluZyB0aGUgc2VsZWN0aW9uIChkb2Vzbid0IG1vZGlmeSB0aGUgZG9tKVxuICAgICAqIFRha2VzIGFsbCB0ZXh0IG5vZGVzIGluIHRoZSBzZWxlY3Rpb24gYW5kIHNhdmVzIHRoZSBzZWxlY3Rpb24gcG9zaXRpb24gaW4gdGhlIGZpcnN0IGFuZCBsYXN0IG9uZVxuICAgICAqL1xuICAgIGV4ZWN1dGVBbmRSZXN0b3JlU2ltcGxlOiBmdW5jdGlvbiBleGVjdXRlQW5kUmVzdG9yZVNpbXBsZShtZXRob2QpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKSxcbiAgICAgICAgICBib2R5ID0gdGhpcy5kb2MuYm9keSxcbiAgICAgICAgICBuZXdSYW5nZSxcbiAgICAgICAgICBmaXJzdE5vZGUsXG4gICAgICAgICAgbGFzdE5vZGUsXG4gICAgICAgICAgdGV4dE5vZGVzLFxuICAgICAgICAgIHJhbmdlQmFja3VwO1xuXG4gICAgICAvLyBOb3RoaW5nIHNlbGVjdGVkLCBleGVjdXRlIGFuZCBzYXkgZ29vZGJ5ZVxuICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICBtZXRob2QoYm9keSwgYm9keSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGV4dE5vZGVzID0gcmFuZ2UuZ2V0Tm9kZXMoWzNdKTtcbiAgICAgIGZpcnN0Tm9kZSA9IHRleHROb2Rlc1swXSB8fCByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgIGxhc3ROb2RlID0gdGV4dE5vZGVzW3RleHROb2Rlcy5sZW5ndGggLSAxXSB8fCByYW5nZS5lbmRDb250YWluZXI7XG5cbiAgICAgIHJhbmdlQmFja3VwID0ge1xuICAgICAgICBjb2xsYXBzZWQ6IHJhbmdlLmNvbGxhcHNlZCxcbiAgICAgICAgc3RhcnRDb250YWluZXI6IGZpcnN0Tm9kZSxcbiAgICAgICAgc3RhcnRPZmZzZXQ6IGZpcnN0Tm9kZSA9PT0gcmFuZ2Uuc3RhcnRDb250YWluZXIgPyByYW5nZS5zdGFydE9mZnNldCA6IDAsXG4gICAgICAgIGVuZENvbnRhaW5lcjogbGFzdE5vZGUsXG4gICAgICAgIGVuZE9mZnNldDogbGFzdE5vZGUgPT09IHJhbmdlLmVuZENvbnRhaW5lciA/IHJhbmdlLmVuZE9mZnNldCA6IGxhc3ROb2RlLmxlbmd0aFxuICAgICAgfTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbWV0aG9kKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5lbmRDb250YWluZXIpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cblxuICAgICAgbmV3UmFuZ2UgPSByYW5neS5jcmVhdGVSYW5nZSh0aGlzLmRvYyk7XG4gICAgICB0cnkge1xuICAgICAgICBuZXdSYW5nZS5zZXRTdGFydChyYW5nZUJhY2t1cC5zdGFydENvbnRhaW5lciwgcmFuZ2VCYWNrdXAuc3RhcnRPZmZzZXQpO1xuICAgICAgfSBjYXRjaCAoZTEpIHt9XG4gICAgICB0cnkge1xuICAgICAgICBuZXdSYW5nZS5zZXRFbmQocmFuZ2VCYWNrdXAuZW5kQ29udGFpbmVyLCByYW5nZUJhY2t1cC5lbmRPZmZzZXQpO1xuICAgICAgfSBjYXRjaCAoZTIpIHt9XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihuZXdSYW5nZSk7XG4gICAgICB9IGNhdGNoIChlMykge31cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGh0bWwgYXQgdGhlIGNhcmV0IHBvc2l0aW9uIGFuZCBtb3ZlIHRoZSBjdXJzb3IgYWZ0ZXIgdGhlIGluc2VydGVkIGh0bWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIEhUTUwgc3RyaW5nIHRvIGluc2VydFxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgc2VsZWN0aW9uLmluc2VydEhUTUwoXCI8cD5mb29iYXI8L3A+XCIpO1xuICAgICAqL1xuICAgIGluc2VydEhUTUw6IGZ1bmN0aW9uIGluc2VydEhUTUwoaHRtbCkge1xuICAgICAgdmFyIHJhbmdlID0gcmFuZ3kuY3JlYXRlUmFuZ2UodGhpcy5kb2MpLFxuICAgICAgICAgIG5vZGUgPSByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoaHRtbCksXG4gICAgICAgICAgbGFzdENoaWxkID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgICB0aGlzLmluc2VydE5vZGUobm9kZSk7XG4gICAgICBpZiAobGFzdENoaWxkKSB7XG4gICAgICAgIHRoaXMuc2V0QWZ0ZXIobGFzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgbm9kZSBhdCB0aGUgY2FyZXQgcG9zaXRpb24gYW5kIG1vdmUgdGhlIGN1cnNvciBiZWhpbmQgaXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIEhUTUwgc3RyaW5nIHRvIGluc2VydFxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgc2VsZWN0aW9uLmluc2VydE5vZGUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJmb29iYXJcIikpO1xuICAgICAqL1xuICAgIGluc2VydE5vZGU6IGZ1bmN0aW9uIGluc2VydE5vZGUobm9kZSkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJhbmdlLmluc2VydE5vZGUobm9kZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGN1cnJlbnQgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIFRoZSBub2RlIHRvIHN1cnJvdW5kIHRoZSBzZWxlY3RlZCBlbGVtZW50cyB3aXRoXG4gICAgICovXG4gICAgc3Vycm91bmQ6IGZ1bmN0aW9uIHN1cnJvdW5kKG5vZGUpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIG9ubHkgd29ya3Mgd2hlbiB0aGUgcmFuZ2UgYm91bmRhcmllcyBhcmUgbm90IG92ZXJsYXBwaW5nIG90aGVyIGVsZW1lbnRzXG4gICAgICAgIHJhbmdlLnN1cnJvdW5kQ29udGVudHMobm9kZSk7XG4gICAgICAgIHRoaXMuc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZmFsbGJhY2tcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChyYW5nZS5leHRyYWN0Q29udGVudHMoKSk7XG4gICAgICAgIHJhbmdlLmluc2VydE5vZGUobm9kZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0aGUgY3VycmVudCBjYXJldCBwb3NpdGlvbiBpbnRvIHRoZSB2aWV3XG4gICAgICogRklYTUU6IFRoaXMgaXMgYSBiaXQgaGFja3ksIHRoZXJlIG1pZ2h0IGJlIGEgc21hcnRlciB3YXkgb2YgZG9pbmcgdGhpc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICBzZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldzogZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoKSB7XG4gICAgICB2YXIgZG9jID0gdGhpcy5kb2MsXG4gICAgICAgICAgaGFzU2Nyb2xsQmFycyA9IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jLmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgdGVtcEVsZW1lbnQgPSBkb2MuX3d5c2lodG1sNVNjcm9sbEludG9WaWV3RWxlbWVudCA9IGRvYy5fd3lzaWh0bWw1U2Nyb2xsSW50b1ZpZXdFbGVtZW50IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIC8vIFRoZSBlbGVtZW50IG5lZWRzIGNvbnRlbnQgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgaXQncyBwb3NpdGlvbiBwcm9wZXJseVxuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0U7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfSgpLFxuICAgICAgICAgIG9mZnNldFRvcDtcblxuICAgICAgaWYgKGhhc1Njcm9sbEJhcnMpIHtcbiAgICAgICAgdGhpcy5pbnNlcnROb2RlKHRlbXBFbGVtZW50KTtcbiAgICAgICAgb2Zmc2V0VG9wID0gX2dldEN1bXVsYXRpdmVPZmZzZXRUb3AodGVtcEVsZW1lbnQpO1xuICAgICAgICB0ZW1wRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXBFbGVtZW50KTtcbiAgICAgICAgaWYgKG9mZnNldFRvcCA+IGRvYy5ib2R5LnNjcm9sbFRvcCkge1xuICAgICAgICAgIGRvYy5ib2R5LnNjcm9sbFRvcCA9IG9mZnNldFRvcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgbGluZSB3aGVyZSB0aGUgY2FyZXQgaXMgaW5cbiAgICAgKi9cbiAgICBzZWxlY3RMaW5lOiBmdW5jdGlvbiBzZWxlY3RMaW5lKCkge1xuICAgICAgaWYgKHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzU2VsZWN0aW9uTW9kaWZ5KCkpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0TGluZV9XM0MoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kb2Muc2VsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdExpbmVfTVNJRSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL1NlbGVjdGlvbi9tb2RpZnlcbiAgICAgKi9cbiAgICBfc2VsZWN0TGluZV9XM0M6IGZ1bmN0aW9uIF9zZWxlY3RMaW5lX1czQygpIHtcbiAgICAgIHZhciB3aW4gPSB0aGlzLmRvYy5kZWZhdWx0VmlldyxcbiAgICAgICAgICBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBzZWxlY3Rpb24ubW9kaWZ5KFwiZXh0ZW5kXCIsIFwibGVmdFwiLCBcImxpbmVib3VuZGFyeVwiKTtcbiAgICAgIHNlbGVjdGlvbi5tb2RpZnkoXCJleHRlbmRcIiwgXCJyaWdodFwiLCBcImxpbmVib3VuZGFyeVwiKTtcbiAgICB9LFxuXG4gICAgX3NlbGVjdExpbmVfTVNJRTogZnVuY3Rpb24gX3NlbGVjdExpbmVfTVNJRSgpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLFxuICAgICAgICAgIHJhbmdlVG9wID0gcmFuZ2UuYm91bmRpbmdUb3AsXG4gICAgICAgICAgcmFuZ2VIZWlnaHQgPSByYW5nZS5ib3VuZGluZ0hlaWdodCxcbiAgICAgICAgICBzY3JvbGxXaWR0aCA9IHRoaXMuZG9jLmJvZHkuc2Nyb2xsV2lkdGgsXG4gICAgICAgICAgcmFuZ2VCb3R0b20sXG4gICAgICAgICAgcmFuZ2VFbmQsXG4gICAgICAgICAgbWVhc3VyZU5vZGUsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBqO1xuXG4gICAgICBpZiAoIXJhbmdlLm1vdmVUb1BvaW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhbmdlVG9wID09PSAwKSB7XG4gICAgICAgIC8vIERvbid0IGtub3cgd2h5LCBidXQgd2hlbiB0aGUgc2VsZWN0aW9uIGVuZHMgYXQgdGhlIGVuZCBvZiBhIGxpbmVcbiAgICAgICAgLy8gcmFuZ2UuYm91bmRpbmdUb3AgaXMgMFxuICAgICAgICBtZWFzdXJlTm9kZSA9IHRoaXMuZG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB0aGlzLmluc2VydE5vZGUobWVhc3VyZU5vZGUpO1xuICAgICAgICByYW5nZVRvcCA9IG1lYXN1cmVOb2RlLm9mZnNldFRvcDtcbiAgICAgICAgbWVhc3VyZU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtZWFzdXJlTm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJhbmdlVG9wICs9IDE7XG5cbiAgICAgIGZvciAoaSA9IC0xMDsgaSA8IHNjcm9sbFdpZHRoOyBpICs9IDIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByYW5nZS5tb3ZlVG9Qb2ludChpLCByYW5nZVRvcCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gY2F0Y2ggKGUxKSB7fVxuICAgICAgfVxuXG4gICAgICAvLyBJbnZlc3RpZ2F0ZSB0aGUgZm9sbG93aW5nIGluIG9yZGVyIHRvIGhhbmRsZSBtdWx0aSBsaW5lIHNlbGVjdGlvbnNcbiAgICAgIC8vIHJhbmdlQm90dG9tID0gcmFuZ2VUb3AgKyAocmFuZ2VIZWlnaHQgPyAocmFuZ2VIZWlnaHQgLSAxKSA6IDApO1xuICAgICAgcmFuZ2VCb3R0b20gPSByYW5nZVRvcDtcbiAgICAgIHJhbmdlRW5kID0gdGhpcy5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICBmb3IgKGogPSBzY3JvbGxXaWR0aDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByYW5nZUVuZC5tb3ZlVG9Qb2ludChqLCByYW5nZUJvdHRvbSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gY2F0Y2ggKGUyKSB7fVxuICAgICAgfVxuXG4gICAgICByYW5nZS5zZXRFbmRQb2ludChcIkVuZFRvRW5kXCIsIHJhbmdlRW5kKTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH0sXG5cbiAgICBnZXRUZXh0OiBmdW5jdGlvbiBnZXRUZXh0KCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uID8gc2VsZWN0aW9uLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgIH0sXG5cbiAgICBnZXROb2RlczogZnVuY3Rpb24gZ2V0Tm9kZXMobm9kZVR5cGUsIGZpbHRlcikge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5nZXRSYW5nZSgpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZS5nZXROb2Rlcyhbbm9kZVR5cGVdLCBmaWx0ZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRSYW5nZTogZnVuY3Rpb24gZ2V0UmFuZ2UoKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHJldHVybiBzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLnJhbmdlQ291bnQgJiYgc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbjogZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmd5LmdldFNlbGVjdGlvbih0aGlzLmRvYy5kZWZhdWx0VmlldyB8fCB0aGlzLmRvYy5wYXJlbnRXaW5kb3cpO1xuICAgIH0sXG5cbiAgICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihyYW5nZSkge1xuICAgICAgdmFyIHdpbiA9IHRoaXMuZG9jLmRlZmF1bHRWaWV3IHx8IHRoaXMuZG9jLnBhcmVudFdpbmRvdyxcbiAgICAgICAgICBzZWxlY3Rpb24gPSByYW5neS5nZXRTZWxlY3Rpb24od2luKTtcbiAgICAgIHJldHVybiBzZWxlY3Rpb24uc2V0U2luZ2xlUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfSk7XG59KSh3eXNpaHRtbDUpO1xuLyoqXG4gKiBJbnNwaXJlZCBieSB0aGUgcmFuZ3kgQ1NTIEFwcGxpZXIgbW9kdWxlIHdyaXR0ZW4gYnkgVGltIERvd24gYW5kIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9yYW5neS9cbiAqXG4gKiBjaGFuZ2VkIGluIG9yZGVyIHRvIGJlIGFibGUgLi4uXG4gKiAgICAtIHRvIHVzZSBjdXN0b20gdGFnc1xuICogICAgLSB0byBkZXRlY3QgYW5kIHJlcGxhY2Ugc2ltaWxhciBjc3MgY2xhc3NlcyB2aWEgcmVnIGV4cFxuICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSwgcmFuZ3kpIHtcbiAgdmFyIGRlZmF1bHRUYWdOYW1lID0gXCJzcGFuXCI7XG5cbiAgdmFyIFJFR19FWFBfV0hJVEVfU1BBQ0UgPSAvXFxzKy9nO1xuXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBjc3NDbGFzcywgcmVnRXhwKSB7XG4gICAgaWYgKCFlbC5jbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hpbmdDbGFzc05hbWVzID0gZWwuY2xhc3NOYW1lLm1hdGNoKHJlZ0V4cCkgfHwgW107XG4gICAgcmV0dXJuIG1hdGNoaW5nQ2xhc3NOYW1lc1ttYXRjaGluZ0NsYXNzTmFtZXMubGVuZ3RoIC0gMV0gPT09IGNzc0NsYXNzO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNzc0NsYXNzLCByZWdFeHApIHtcbiAgICBpZiAoZWwuY2xhc3NOYW1lKSB7XG4gICAgICByZW1vdmVDbGFzcyhlbCwgcmVnRXhwKTtcbiAgICAgIGVsLmNsYXNzTmFtZSArPSBcIiBcIiArIGNzc0NsYXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc05hbWUgPSBjc3NDbGFzcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgcmVnRXhwKSB7XG4gICAgaWYgKGVsLmNsYXNzTmFtZSkge1xuICAgICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UocmVnRXhwLCBcIlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNTYW1lQ2xhc3NlcyhlbDEsIGVsMikge1xuICAgIHJldHVybiBlbDEuY2xhc3NOYW1lLnJlcGxhY2UoUkVHX0VYUF9XSElURV9TUEFDRSwgXCIgXCIpID09IGVsMi5jbGFzc05hbWUucmVwbGFjZShSRUdfRVhQX1dISVRFX1NQQUNFLCBcIiBcIik7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlV2l0aE93bkNoaWxkcmVuKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWwuZmlyc3RDaGlsZCwgZWwpO1xuICAgIH1cbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZWxlbWVudHNIYXZlU2FtZU5vbkNsYXNzQXR0cmlidXRlcyhlbDEsIGVsMikge1xuICAgIGlmIChlbDEuYXR0cmlidXRlcy5sZW5ndGggIT0gZWwyLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbDEuYXR0cmlidXRlcy5sZW5ndGgsIGF0dHIxLCBhdHRyMiwgbmFtZTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhdHRyMSA9IGVsMS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgbmFtZSA9IGF0dHIxLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBcImNsYXNzXCIpIHtcbiAgICAgICAgYXR0cjIgPSBlbDIuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0obmFtZSk7XG4gICAgICAgIGlmIChhdHRyMS5zcGVjaWZpZWQgIT0gYXR0cjIuc3BlY2lmaWVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyMS5zcGVjaWZpZWQgJiYgYXR0cjEubm9kZVZhbHVlICE9PSBhdHRyMi5ub2RlVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NwbGl0UG9pbnQobm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKHJhbmd5LmRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpKSB7XG4gICAgICBpZiAob2Zmc2V0ID09IDApIHtcbiAgICAgICAgcmV0dXJuICEhbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCA9PSBub2RlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gISFub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCA+IDAgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGl0Tm9kZUF0KG5vZGUsIGRlc2NlbmRhbnROb2RlLCBkZXNjZW5kYW50T2Zmc2V0KSB7XG4gICAgdmFyIG5ld05vZGU7XG4gICAgaWYgKHJhbmd5LmRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKGRlc2NlbmRhbnROb2RlKSkge1xuICAgICAgaWYgKGRlc2NlbmRhbnRPZmZzZXQgPT0gMCkge1xuICAgICAgICBkZXNjZW5kYW50T2Zmc2V0ID0gcmFuZ3kuZG9tLmdldE5vZGVJbmRleChkZXNjZW5kYW50Tm9kZSk7XG4gICAgICAgIGRlc2NlbmRhbnROb2RlID0gZGVzY2VuZGFudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVzY2VuZGFudE9mZnNldCA9PSBkZXNjZW5kYW50Tm9kZS5sZW5ndGgpIHtcbiAgICAgICAgZGVzY2VuZGFudE9mZnNldCA9IHJhbmd5LmRvbS5nZXROb2RlSW5kZXgoZGVzY2VuZGFudE5vZGUpICsgMTtcbiAgICAgICAgZGVzY2VuZGFudE5vZGUgPSBkZXNjZW5kYW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3Tm9kZSA9IHJhbmd5LmRvbS5zcGxpdERhdGFOb2RlKGRlc2NlbmRhbnROb2RlLCBkZXNjZW5kYW50T2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFuZXdOb2RlKSB7XG4gICAgICBuZXdOb2RlID0gZGVzY2VuZGFudE5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgIGlmIChuZXdOb2RlLmlkKSB7XG4gICAgICAgIG5ld05vZGUucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQgPSBkZXNjZW5kYW50Tm9kZS5jaGlsZE5vZGVzW2Rlc2NlbmRhbnRPZmZzZXRdKSB7XG4gICAgICAgIG5ld05vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgICAgcmFuZ3kuZG9tLmluc2VydEFmdGVyKG5ld05vZGUsIGRlc2NlbmRhbnROb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NlbmRhbnROb2RlID09IG5vZGUgPyBuZXdOb2RlIDogc3BsaXROb2RlQXQobm9kZSwgbmV3Tm9kZS5wYXJlbnROb2RlLCByYW5neS5kb20uZ2V0Tm9kZUluZGV4KG5ld05vZGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIE1lcmdlKGZpcnN0Tm9kZSkge1xuICAgIHRoaXMuaXNFbGVtZW50TWVyZ2UgPSBmaXJzdE5vZGUubm9kZVR5cGUgPT0gd3lzaWh0bWw1LkVMRU1FTlRfTk9ERTtcbiAgICB0aGlzLmZpcnN0VGV4dE5vZGUgPSB0aGlzLmlzRWxlbWVudE1lcmdlID8gZmlyc3ROb2RlLmxhc3RDaGlsZCA6IGZpcnN0Tm9kZTtcbiAgICB0aGlzLnRleHROb2RlcyA9IFt0aGlzLmZpcnN0VGV4dE5vZGVdO1xuICB9XG5cbiAgTWVyZ2UucHJvdG90eXBlID0ge1xuICAgIGRvTWVyZ2U6IGZ1bmN0aW9uIGRvTWVyZ2UoKSB7XG4gICAgICB2YXIgdGV4dEJpdHMgPSBbXSxcbiAgICAgICAgICB0ZXh0Tm9kZSxcbiAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgdGV4dDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnRleHROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB0ZXh0Tm9kZSA9IHRoaXMudGV4dE5vZGVzW2ldO1xuICAgICAgICBwYXJlbnQgPSB0ZXh0Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB0ZXh0Qml0c1tpXSA9IHRleHROb2RlLmRhdGE7XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgICBpZiAoIXBhcmVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmZpcnN0VGV4dE5vZGUuZGF0YSA9IHRleHQgPSB0ZXh0Qml0cy5qb2luKFwiXCIpO1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSxcblxuICAgIGdldExlbmd0aDogZnVuY3Rpb24gZ2V0TGVuZ3RoKCkge1xuICAgICAgdmFyIGkgPSB0aGlzLnRleHROb2Rlcy5sZW5ndGgsXG4gICAgICAgICAgbGVuID0gMDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgbGVuICs9IHRoaXMudGV4dE5vZGVzW2ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW47XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciB0ZXh0Qml0cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMudGV4dE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHRleHRCaXRzW2ldID0gXCInXCIgKyB0aGlzLnRleHROb2Rlc1tpXS5kYXRhICsgXCInXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJbTWVyZ2UoXCIgKyB0ZXh0Qml0cy5qb2luKFwiLFwiKSArIFwiKV1cIjtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSFRNTEFwcGxpZXIodGFnTmFtZXMsIGNzc0NsYXNzLCBzaW1pbGFyQ2xhc3NSZWdFeHAsIG5vcm1hbGl6ZSkge1xuICAgIHRoaXMudGFnTmFtZXMgPSB0YWdOYW1lcyB8fCBbZGVmYXVsdFRhZ05hbWVdO1xuICAgIHRoaXMuY3NzQ2xhc3MgPSBjc3NDbGFzcyB8fCBcIlwiO1xuICAgIHRoaXMuc2ltaWxhckNsYXNzUmVnRXhwID0gc2ltaWxhckNsYXNzUmVnRXhwO1xuICAgIHRoaXMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuICAgIHRoaXMuYXBwbHlUb0FueVRhZ05hbWUgPSBmYWxzZTtcbiAgfVxuXG4gIEhUTUxBcHBsaWVyLnByb3RvdHlwZSA9IHtcbiAgICBnZXRBbmNlc3RvcldpdGhDbGFzczogZnVuY3Rpb24gZ2V0QW5jZXN0b3JXaXRoQ2xhc3Mobm9kZSkge1xuICAgICAgdmFyIGNzc0NsYXNzTWF0Y2g7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBjc3NDbGFzc01hdGNoID0gdGhpcy5jc3NDbGFzcyA/IGhhc0NsYXNzKG5vZGUsIHRoaXMuY3NzQ2xhc3MsIHRoaXMuc2ltaWxhckNsYXNzUmVnRXhwKSA6IHRydWU7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IHd5c2lodG1sNS5FTEVNRU5UX05PREUgJiYgcmFuZ3kuZG9tLmFycmF5Q29udGFpbnModGhpcy50YWdOYW1lcywgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmIGNzc0NsYXNzTWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBOb3JtYWxpemVzIG5vZGVzIGFmdGVyIGFwcGx5aW5nIGEgQ1NTIGNsYXNzIHRvIGEgUmFuZ2UuXG4gICAgcG9zdEFwcGx5OiBmdW5jdGlvbiBwb3N0QXBwbHkodGV4dE5vZGVzLCByYW5nZSkge1xuICAgICAgdmFyIGZpcnN0Tm9kZSA9IHRleHROb2Rlc1swXSxcbiAgICAgICAgICBsYXN0Tm9kZSA9IHRleHROb2Rlc1t0ZXh0Tm9kZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgIHZhciBtZXJnZXMgPSBbXSxcbiAgICAgICAgICBjdXJyZW50TWVyZ2U7XG5cbiAgICAgIHZhciByYW5nZVN0YXJ0Tm9kZSA9IGZpcnN0Tm9kZSxcbiAgICAgICAgICByYW5nZUVuZE5vZGUgPSBsYXN0Tm9kZTtcbiAgICAgIHZhciByYW5nZVN0YXJ0T2Zmc2V0ID0gMCxcbiAgICAgICAgICByYW5nZUVuZE9mZnNldCA9IGxhc3ROb2RlLmxlbmd0aDtcblxuICAgICAgdmFyIHRleHROb2RlLCBwcmVjZWRpbmdUZXh0Tm9kZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB0ZXh0Tm9kZSA9IHRleHROb2Rlc1tpXTtcbiAgICAgICAgcHJlY2VkaW5nVGV4dE5vZGUgPSB0aGlzLmdldEFkamFjZW50TWVyZ2VhYmxlVGV4dE5vZGUodGV4dE5vZGUucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICBpZiAocHJlY2VkaW5nVGV4dE5vZGUpIHtcbiAgICAgICAgICBpZiAoIWN1cnJlbnRNZXJnZSkge1xuICAgICAgICAgICAgY3VycmVudE1lcmdlID0gbmV3IE1lcmdlKHByZWNlZGluZ1RleHROb2RlKTtcbiAgICAgICAgICAgIG1lcmdlcy5wdXNoKGN1cnJlbnRNZXJnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRNZXJnZS50ZXh0Tm9kZXMucHVzaCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgaWYgKHRleHROb2RlID09PSBmaXJzdE5vZGUpIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnROb2RlID0gY3VycmVudE1lcmdlLmZpcnN0VGV4dE5vZGU7XG4gICAgICAgICAgICByYW5nZVN0YXJ0T2Zmc2V0ID0gcmFuZ2VTdGFydE5vZGUubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGV4dE5vZGUgPT09IGxhc3ROb2RlKSB7XG4gICAgICAgICAgICByYW5nZUVuZE5vZGUgPSBjdXJyZW50TWVyZ2UuZmlyc3RUZXh0Tm9kZTtcbiAgICAgICAgICAgIHJhbmdlRW5kT2Zmc2V0ID0gY3VycmVudE1lcmdlLmdldExlbmd0aCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50TWVyZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRlc3Qgd2hldGhlciB0aGUgZmlyc3Qgbm9kZSBhZnRlciB0aGUgcmFuZ2UgbmVlZHMgbWVyZ2luZ1xuICAgICAgdmFyIG5leHRUZXh0Tm9kZSA9IHRoaXMuZ2V0QWRqYWNlbnRNZXJnZWFibGVUZXh0Tm9kZShsYXN0Tm9kZS5wYXJlbnROb2RlLCB0cnVlKTtcbiAgICAgIGlmIChuZXh0VGV4dE5vZGUpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50TWVyZ2UpIHtcbiAgICAgICAgICBjdXJyZW50TWVyZ2UgPSBuZXcgTWVyZ2UobGFzdE5vZGUpO1xuICAgICAgICAgIG1lcmdlcy5wdXNoKGN1cnJlbnRNZXJnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudE1lcmdlLnRleHROb2Rlcy5wdXNoKG5leHRUZXh0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERvIHRoZSBtZXJnZXNcbiAgICAgIGlmIChtZXJnZXMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG1lcmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIG1lcmdlc1tpXS5kb01lcmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSByYW5nZSBib3VuZGFyaWVzXG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KHJhbmdlU3RhcnROb2RlLCByYW5nZVN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKHJhbmdlRW5kTm9kZSwgcmFuZ2VFbmRPZmZzZXQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRBZGphY2VudE1lcmdlYWJsZVRleHROb2RlOiBmdW5jdGlvbiBnZXRBZGphY2VudE1lcmdlYWJsZVRleHROb2RlKG5vZGUsIGZvcndhcmQpIHtcbiAgICAgIHZhciBpc1RleHROb2RlID0gbm9kZS5ub2RlVHlwZSA9PSB3eXNpaHRtbDUuVEVYVF9OT0RFO1xuICAgICAgdmFyIGVsID0gaXNUZXh0Tm9kZSA/IG5vZGUucGFyZW50Tm9kZSA6IG5vZGU7XG4gICAgICB2YXIgYWRqYWNlbnROb2RlO1xuICAgICAgdmFyIHByb3BOYW1lID0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCI7XG4gICAgICBpZiAoaXNUZXh0Tm9kZSkge1xuICAgICAgICAvLyBDYW4gbWVyZ2UgaWYgdGhlIG5vZGUncyBwcmV2aW91cy9uZXh0IHNpYmxpbmcgaXMgYSB0ZXh0IG5vZGVcbiAgICAgICAgYWRqYWNlbnROb2RlID0gbm9kZVtwcm9wTmFtZV07XG4gICAgICAgIGlmIChhZGphY2VudE5vZGUgJiYgYWRqYWNlbnROb2RlLm5vZGVUeXBlID09IHd5c2lodG1sNS5URVhUX05PREUpIHtcbiAgICAgICAgICByZXR1cm4gYWRqYWNlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb21wYXJlIGVsZW1lbnQgd2l0aCBpdHMgc2libGluZ1xuICAgICAgICBhZGphY2VudE5vZGUgPSBlbFtwcm9wTmFtZV07XG4gICAgICAgIGlmIChhZGphY2VudE5vZGUgJiYgdGhpcy5hcmVFbGVtZW50c01lcmdlYWJsZShub2RlLCBhZGphY2VudE5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGFkamFjZW50Tm9kZVtmb3J3YXJkID8gXCJmaXJzdENoaWxkXCIgOiBcImxhc3RDaGlsZFwiXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGFyZUVsZW1lbnRzTWVyZ2VhYmxlOiBmdW5jdGlvbiBhcmVFbGVtZW50c01lcmdlYWJsZShlbDEsIGVsMikge1xuICAgICAgcmV0dXJuIHJhbmd5LmRvbS5hcnJheUNvbnRhaW5zKHRoaXMudGFnTmFtZXMsIChlbDEudGFnTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpKSAmJiByYW5neS5kb20uYXJyYXlDb250YWlucyh0aGlzLnRhZ05hbWVzLCAoZWwyLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSkgJiYgaGFzU2FtZUNsYXNzZXMoZWwxLCBlbDIpICYmIGVsZW1lbnRzSGF2ZVNhbWVOb25DbGFzc0F0dHJpYnV0ZXMoZWwxLCBlbDIpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVDb250YWluZXI6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihkb2MpIHtcbiAgICAgIHZhciBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KHRoaXMudGFnTmFtZXNbMF0pO1xuICAgICAgaWYgKHRoaXMuY3NzQ2xhc3MpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gdGhpcy5jc3NDbGFzcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgYXBwbHlUb1RleHROb2RlOiBmdW5jdGlvbiBhcHBseVRvVGV4dE5vZGUodGV4dE5vZGUpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0ZXh0Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgaWYgKHBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIHJhbmd5LmRvbS5hcnJheUNvbnRhaW5zKHRoaXMudGFnTmFtZXMsIHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGlmICh0aGlzLmNzc0NsYXNzKSB7XG4gICAgICAgICAgYWRkQ2xhc3MocGFyZW50LCB0aGlzLmNzc0NsYXNzLCB0aGlzLnNpbWlsYXJDbGFzc1JlZ0V4cCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuY3JlYXRlQ29udGFpbmVyKHJhbmd5LmRvbS5nZXREb2N1bWVudCh0ZXh0Tm9kZSkpO1xuICAgICAgICB0ZXh0Tm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgdGV4dE5vZGUpO1xuICAgICAgICBlbC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzUmVtb3ZhYmxlOiBmdW5jdGlvbiBpc1JlbW92YWJsZShlbCkge1xuICAgICAgcmV0dXJuIHJhbmd5LmRvbS5hcnJheUNvbnRhaW5zKHRoaXMudGFnTmFtZXMsIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgJiYgd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKGVsLmNsYXNzTmFtZSkudHJpbSgpID09IHRoaXMuY3NzQ2xhc3M7XG4gICAgfSxcblxuICAgIHVuZG9Ub1RleHROb2RlOiBmdW5jdGlvbiB1bmRvVG9UZXh0Tm9kZSh0ZXh0Tm9kZSwgcmFuZ2UsIGFuY2VzdG9yV2l0aENsYXNzKSB7XG4gICAgICBpZiAoIXJhbmdlLmNvbnRhaW5zTm9kZShhbmNlc3RvcldpdGhDbGFzcykpIHtcbiAgICAgICAgLy8gU3BsaXQgb3V0IHRoZSBwb3J0aW9uIG9mIHRoZSBhbmNlc3RvciBmcm9tIHdoaWNoIHdlIGNhbiByZW1vdmUgdGhlIENTUyBjbGFzc1xuICAgICAgICB2YXIgYW5jZXN0b3JSYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgYW5jZXN0b3JSYW5nZS5zZWxlY3ROb2RlKGFuY2VzdG9yV2l0aENsYXNzKTtcblxuICAgICAgICBpZiAoYW5jZXN0b3JSYW5nZS5pc1BvaW50SW5SYW5nZShyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCkgJiYgaXNTcGxpdFBvaW50KHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KSkge1xuICAgICAgICAgIHNwbGl0Tm9kZUF0KGFuY2VzdG9yV2l0aENsYXNzLCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIoYW5jZXN0b3JXaXRoQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmNlc3RvclJhbmdlLmlzUG9pbnRJblJhbmdlKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCkgJiYgaXNTcGxpdFBvaW50KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCkpIHtcbiAgICAgICAgICBhbmNlc3RvcldpdGhDbGFzcyA9IHNwbGl0Tm9kZUF0KGFuY2VzdG9yV2l0aENsYXNzLCByYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNpbWlsYXJDbGFzc1JlZ0V4cCkge1xuICAgICAgICByZW1vdmVDbGFzcyhhbmNlc3RvcldpdGhDbGFzcywgdGhpcy5zaW1pbGFyQ2xhc3NSZWdFeHApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNSZW1vdmFibGUoYW5jZXN0b3JXaXRoQ2xhc3MpKSB7XG4gICAgICAgIHJlcGxhY2VXaXRoT3duQ2hpbGRyZW4oYW5jZXN0b3JXaXRoQ2xhc3MpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhcHBseVRvUmFuZ2U6IGZ1bmN0aW9uIGFwcGx5VG9SYW5nZShyYW5nZSkge1xuICAgICAgdmFyIHRleHROb2RlcyA9IHJhbmdlLmdldE5vZGVzKFt3eXNpaHRtbDUuVEVYVF9OT0RFXSk7XG4gICAgICBpZiAoIXRleHROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3JlYXRlQ29udGFpbmVyKHJhbmdlLmVuZENvbnRhaW5lci5vd25lckRvY3VtZW50KTtcbiAgICAgICAgICByYW5nZS5zdXJyb3VuZENvbnRlbnRzKG5vZGUpO1xuICAgICAgICAgIHRoaXMuc2VsZWN0Tm9kZShyYW5nZSwgbm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuXG4gICAgICByYW5nZS5zcGxpdEJvdW5kYXJpZXMoKTtcbiAgICAgIHRleHROb2RlcyA9IHJhbmdlLmdldE5vZGVzKFt3eXNpaHRtbDUuVEVYVF9OT0RFXSk7XG5cbiAgICAgIGlmICh0ZXh0Tm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0ZXh0Tm9kZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGV4dE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgdGV4dE5vZGUgPSB0ZXh0Tm9kZXNbaV07XG4gICAgICAgICAgaWYgKCF0aGlzLmdldEFuY2VzdG9yV2l0aENsYXNzKHRleHROb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5hcHBseVRvVGV4dE5vZGUodGV4dE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KHRleHROb2Rlc1swXSwgMCk7XG4gICAgICAgIHRleHROb2RlID0gdGV4dE5vZGVzW3RleHROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKHRleHROb2RlLCB0ZXh0Tm9kZS5sZW5ndGgpO1xuXG4gICAgICAgIGlmICh0aGlzLm5vcm1hbGl6ZSkge1xuICAgICAgICAgIHRoaXMucG9zdEFwcGx5KHRleHROb2RlcywgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVuZG9Ub1JhbmdlOiBmdW5jdGlvbiB1bmRvVG9SYW5nZShyYW5nZSkge1xuICAgICAgdmFyIHRleHROb2RlcyA9IHJhbmdlLmdldE5vZGVzKFt3eXNpaHRtbDUuVEVYVF9OT0RFXSksXG4gICAgICAgICAgdGV4dE5vZGUsXG4gICAgICAgICAgYW5jZXN0b3JXaXRoQ2xhc3M7XG4gICAgICBpZiAodGV4dE5vZGVzLmxlbmd0aCkge1xuICAgICAgICByYW5nZS5zcGxpdEJvdW5kYXJpZXMoKTtcbiAgICAgICAgdGV4dE5vZGVzID0gcmFuZ2UuZ2V0Tm9kZXMoW3d5c2lodG1sNS5URVhUX05PREVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkb2MgPSByYW5nZS5lbmRDb250YWluZXIub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgIG5vZGUgPSBkb2MuY3JlYXRlVGV4dE5vZGUod3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRSk7XG4gICAgICAgIHJhbmdlLmluc2VydE5vZGUobm9kZSk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGUobm9kZSk7XG4gICAgICAgIHRleHROb2RlcyA9IFtub2RlXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB0ZXh0Tm9kZSA9IHRleHROb2Rlc1tpXTtcbiAgICAgICAgYW5jZXN0b3JXaXRoQ2xhc3MgPSB0aGlzLmdldEFuY2VzdG9yV2l0aENsYXNzKHRleHROb2RlKTtcbiAgICAgICAgaWYgKGFuY2VzdG9yV2l0aENsYXNzKSB7XG4gICAgICAgICAgdGhpcy51bmRvVG9UZXh0Tm9kZSh0ZXh0Tm9kZSwgcmFuZ2UsIGFuY2VzdG9yV2l0aENsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVuID09IDEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3ROb2RlKHJhbmdlLCB0ZXh0Tm9kZXNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGV4dE5vZGVzWzBdLCAwKTtcbiAgICAgICAgdGV4dE5vZGUgPSB0ZXh0Tm9kZXNbdGV4dE5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICByYW5nZS5zZXRFbmQodGV4dE5vZGUsIHRleHROb2RlLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMubm9ybWFsaXplKSB7XG4gICAgICAgICAgdGhpcy5wb3N0QXBwbHkodGV4dE5vZGVzLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0Tm9kZTogZnVuY3Rpb24gc2VsZWN0Tm9kZShyYW5nZSwgbm9kZSkge1xuICAgICAgdmFyIGlzRWxlbWVudCA9IG5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5FTEVNRU5UX05PREUsXG4gICAgICAgICAgY2FuSGF2ZUhUTUwgPSBcImNhbkhhdmVIVE1MXCIgaW4gbm9kZSA/IG5vZGUuY2FuSGF2ZUhUTUwgOiB0cnVlLFxuICAgICAgICAgIGNvbnRlbnQgPSBpc0VsZW1lbnQgPyBub2RlLmlubmVySFRNTCA6IG5vZGUuZGF0YSxcbiAgICAgICAgICBpc0VtcHR5ID0gY29udGVudCA9PT0gXCJcIiB8fCBjb250ZW50ID09PSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFO1xuXG4gICAgICBpZiAoaXNFbXB0eSAmJiBpc0VsZW1lbnQgJiYgY2FuSGF2ZUhUTUwpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgY2FyZXQgaXMgdmlzaWJsZSBpbiBub2RlIGJ5IGluc2VydGluZyBhIHplcm8gd2lkdGggbm8gYnJlYWtpbmcgc3BhY2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBub2RlLmlubmVySFRNTCA9IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0U7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG4gICAgICBpZiAoaXNFbXB0eSAmJiBpc0VsZW1lbnQpIHtcbiAgICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChpc0VtcHR5KSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIobm9kZSk7XG4gICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKG5vZGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRUZXh0U2VsZWN0ZWRCeVJhbmdlOiBmdW5jdGlvbiBnZXRUZXh0U2VsZWN0ZWRCeVJhbmdlKHRleHROb2RlLCByYW5nZSkge1xuICAgICAgdmFyIHRleHRSYW5nZSA9IHJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgIHRleHRSYW5nZS5zZWxlY3ROb2RlQ29udGVudHModGV4dE5vZGUpO1xuXG4gICAgICB2YXIgaW50ZXJzZWN0aW9uUmFuZ2UgPSB0ZXh0UmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlKTtcbiAgICAgIHZhciB0ZXh0ID0gaW50ZXJzZWN0aW9uUmFuZ2UgPyBpbnRlcnNlY3Rpb25SYW5nZS50b1N0cmluZygpIDogXCJcIjtcbiAgICAgIHRleHRSYW5nZS5kZXRhY2goKTtcblxuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSxcblxuICAgIGlzQXBwbGllZFRvUmFuZ2U6IGZ1bmN0aW9uIGlzQXBwbGllZFRvUmFuZ2UocmFuZ2UpIHtcbiAgICAgIHZhciBhbmNlc3RvcnMgPSBbXSxcbiAgICAgICAgICBhbmNlc3RvcixcbiAgICAgICAgICB0ZXh0Tm9kZXMgPSByYW5nZS5nZXROb2Rlcyhbd3lzaWh0bWw1LlRFWFRfTk9ERV0pO1xuICAgICAgaWYgKCF0ZXh0Tm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGFuY2VzdG9yID0gdGhpcy5nZXRBbmNlc3RvcldpdGhDbGFzcyhyYW5nZS5zdGFydENvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBhbmNlc3RvciA/IFthbmNlc3Rvcl0gOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHROb2Rlcy5sZW5ndGgsIHNlbGVjdGVkVGV4dDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHNlbGVjdGVkVGV4dCA9IHRoaXMuZ2V0VGV4dFNlbGVjdGVkQnlSYW5nZSh0ZXh0Tm9kZXNbaV0sIHJhbmdlKTtcbiAgICAgICAgYW5jZXN0b3IgPSB0aGlzLmdldEFuY2VzdG9yV2l0aENsYXNzKHRleHROb2Rlc1tpXSk7XG4gICAgICAgIGlmIChzZWxlY3RlZFRleHQgIT0gXCJcIiAmJiAhYW5jZXN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYW5jZXN0b3JzO1xuICAgIH0sXG5cbiAgICB0b2dnbGVSYW5nZTogZnVuY3Rpb24gdG9nZ2xlUmFuZ2UocmFuZ2UpIHtcbiAgICAgIGlmICh0aGlzLmlzQXBwbGllZFRvUmFuZ2UocmFuZ2UpKSB7XG4gICAgICAgIHRoaXMudW5kb1RvUmFuZ2UocmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHBseVRvUmFuZ2UocmFuZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3eXNpaHRtbDUuc2VsZWN0aW9uLkhUTUxBcHBsaWVyID0gSFRNTEFwcGxpZXI7XG59KSh3eXNpaHRtbDUsIHJhbmd5KTsgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgKiBSaWNoIFRleHQgUXVlcnkvRm9ybWF0dGluZyBDb21tYW5kc1xuICAgICAgICAgICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgICogICAgdmFyIGNvbW1hbmRzID0gbmV3IHd5c2lodG1sNS5Db21tYW5kcyhlZGl0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICovXG53eXNpaHRtbDUuQ29tbWFuZHMgPSBCYXNlLmV4dGVuZChcbi8qKiBAc2NvcGUgd3lzaWh0bWw1LkNvbW1hbmRzLnByb3RvdHlwZSAqL3tcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuY29tcG9zZXIgPSBlZGl0b3IuY29tcG9zZXI7XG4gICAgdGhpcy5kb2MgPSB0aGlzLmNvbXBvc2VyLmRvYztcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgZ2l2ZW4gY29tbWFuZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29tbWFuZCBUaGUgY29tbWFuZCBzdHJpbmcgd2hpY2ggdG8gY2hlY2sgKGVnLiBcImJvbGRcIiwgXCJpdGFsaWNcIiwgXCJpbnNlcnRVbm9yZGVyZWRMaXN0XCIpXG4gICAqIEBleGFtcGxlXG4gICAqICAgIGNvbW1hbmRzLnN1cHBvcnRzKFwiY3JlYXRlTGlua1wiKTtcbiAgICovXG4gIHN1cHBvcnQ6IGZ1bmN0aW9uIHN1cHBvcnQoY29tbWFuZCkge1xuICAgIHJldHVybiB3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c0NvbW1hbmQodGhpcy5kb2MsIGNvbW1hbmQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBnaXZlbiBjb21tYW5kXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb21tYW5kIFRoZSBjb21tYW5kIHN0cmluZyB3aGljaCB0byBleGVjdXRlIChlZy4gXCJib2xkXCIsIFwiaXRhbGljXCIsIFwiaW5zZXJ0VW5vcmRlcmVkTGlzdFwiKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3ZhbHVlXSBUaGUgY29tbWFuZCB2YWx1ZSBwYXJhbWV0ZXIsIG5lZWRlZCBmb3Igc29tZSBjb21tYW5kcyAoXCJjcmVhdGVMaW5rXCIsIFwiaW5zZXJ0SW1hZ2VcIiwgLi4uKSwgb3B0aW9uYWwgZm9yIGNvbW1hbmRzIHRoYXQgZG9uJ3QgcmVxdWlyZSBvbmUgKFwiYm9sZFwiLCBcInVuZGVybGluZVwiLCAuLi4pXG4gICAqIEBleGFtcGxlXG4gICAqICAgIGNvbW1hbmRzLmV4ZWMoXCJpbnNlcnRJbWFnZVwiLCBcImh0dHA6Ly9hMS50d2ltZy5jb20vcHJvZmlsZV9pbWFnZXMvMTEzODY4NjU1L3NjaHJlaV90d2l0dGVyX3JlYXNvbmFibHlfc21hbGwuanBnXCIpO1xuICAgKi9cbiAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21tYW5kLCB2YWx1ZSkge1xuICAgIHZhciBvYmogPSB3eXNpaHRtbDUuY29tbWFuZHNbY29tbWFuZF0sXG4gICAgICAgIGFyZ3MgPSB3eXNpaHRtbDUubGFuZy5hcnJheShhcmd1bWVudHMpLmdldCgpLFxuICAgICAgICBtZXRob2QgPSBvYmogJiYgb2JqLmV4ZWMsXG4gICAgICAgIHJlc3VsdCA9IG51bGw7XG5cbiAgICB0aGlzLmVkaXRvci5maXJlKFwiYmVmb3JlY29tbWFuZDpjb21wb3NlclwiKTtcblxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLmNvbXBvc2VyKTtcbiAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseShvYmosIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyB0cnkvY2F0Y2ggZm9yIGJ1Z2d5IGZpcmVmb3hcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5kb2MuZXhlY0NvbW1hbmQoY29tbWFuZCwgZmFsc2UsIHZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgdGhpcy5lZGl0b3IuZmlyZShcImFmdGVyY29tbWFuZDpjb21wb3NlclwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBjdXJyZW50IGNvbW1hbmQgaXMgYWN0aXZlXG4gICAqIElmIHRoZSBjYXJldCBpcyB3aXRoaW4gYSBib2xkIHRleHQsIHRoZW4gY2FsbGluZyB0aGlzIHdpdGggY29tbWFuZCBcImJvbGRcIiBzaG91bGQgcmV0dXJuIHRydWVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbW1hbmQgVGhlIGNvbW1hbmQgc3RyaW5nIHdoaWNoIHRvIGNoZWNrIChlZy4gXCJib2xkXCIsIFwiaXRhbGljXCIsIFwiaW5zZXJ0VW5vcmRlcmVkTGlzdFwiKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbW1hbmRWYWx1ZV0gVGhlIGNvbW1hbmQgdmFsdWUgcGFyYW1ldGVyIChlZy4gZm9yIFwiaW5zZXJ0SW1hZ2VcIiB0aGUgaW1hZ2Ugc3JjKVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBjb21tYW5kIGlzIGFjdGl2ZVxuICAgKiBAZXhhbXBsZVxuICAgKiAgICB2YXIgaXNDdXJyZW50U2VsZWN0aW9uQm9sZCA9IGNvbW1hbmRzLnN0YXRlKFwiYm9sZFwiKTtcbiAgICovXG4gIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21tYW5kLCBjb21tYW5kVmFsdWUpIHtcbiAgICB2YXIgb2JqID0gd3lzaWh0bWw1LmNvbW1hbmRzW2NvbW1hbmRdLFxuICAgICAgICBhcmdzID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoYXJndW1lbnRzKS5nZXQoKSxcbiAgICAgICAgbWV0aG9kID0gb2JqICYmIG9iai5zdGF0ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5jb21wb3Nlcik7XG4gICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHRyeS9jYXRjaCBmb3IgYnVnZ3kgZmlyZWZveFxuICAgICAgICByZXR1cm4gdGhpcy5kb2MucXVlcnlDb21tYW5kU3RhdGUoY29tbWFuZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBjb21tYW5kJ3MgdmFsdWVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbW1hbmQgVGhlIGNvbW1hbmQgc3RyaW5nIHdoaWNoIHRvIGNoZWNrIChlZy4gXCJmb3JtYXRCbG9ja1wiKVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBjb21tYW5kIHZhbHVlXG4gICAqIEBleGFtcGxlXG4gICAqICAgIHZhciBjdXJyZW50QmxvY2tFbGVtZW50ID0gY29tbWFuZHMudmFsdWUoXCJmb3JtYXRCbG9ja1wiKTtcbiAgICovXG4gIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShjb21tYW5kKSB7XG4gICAgdmFyIG9iaiA9IHd5c2lodG1sNS5jb21tYW5kc1tjb21tYW5kXSxcbiAgICAgICAgbWV0aG9kID0gb2JqICYmIG9iai52YWx1ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNhbGwob2JqLCB0aGlzLmNvbXBvc2VyLCBjb21tYW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdHJ5L2NhdGNoIGZvciBidWdneSBmaXJlZm94XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5xdWVyeUNvbW1hbmRWYWx1ZShjb21tYW5kKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZjtcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuYm9sZCA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5leGVjKGNvbXBvc2VyLCBjb21tYW5kLCBcImJcIik7XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21wb3NlciwgY29tbWFuZCwgY29sb3IpIHtcbiAgICAgIC8vIGVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZShcImJvbGRcIikgcmVzdWx0czpcbiAgICAgIC8vIGZpcmVmb3g6IG9ubHkgPGI+XG4gICAgICAvLyBjaHJvbWU6ICA8Yj4sIDxzdHJvbmc+LCA8aDE+LCA8aDI+LCAuLi5cbiAgICAgIC8vIGllOiAgICAgIDxiPiwgPHN0cm9uZz5cbiAgICAgIC8vIG9wZXJhOiAgIDxiPiwgPHN0cm9uZz5cbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBcImJcIik7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWYsXG4gICAgICBOT0RFX05BTUUgPSBcIkFcIixcbiAgICAgIGRvbSA9IHd5c2lodG1sNS5kb207XG5cbiAgZnVuY3Rpb24gX3JlbW92ZUZvcm1hdChjb21wb3NlciwgYW5jaG9ycykge1xuICAgIHZhciBsZW5ndGggPSBhbmNob3JzLmxlbmd0aCxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgY29kZUVsZW1lbnQsXG4gICAgICAgIHRleHRDb250ZW50O1xuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGFuY2hvciA9IGFuY2hvcnNbaV07XG4gICAgICBjb2RlRWxlbWVudCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGFuY2hvciwgeyBub2RlTmFtZTogXCJjb2RlXCIgfSk7XG4gICAgICB0ZXh0Q29udGVudCA9IGRvbS5nZXRUZXh0Q29udGVudChhbmNob3IpO1xuXG4gICAgICAvLyBpZiA8YT4gY29udGFpbnMgdXJsLWxpa2UgdGV4dCBjb250ZW50LCByZW5hbWUgaXQgdG8gPGNvZGU+IHRvIHByZXZlbnQgcmUtYXV0b2xpbmtpbmdcbiAgICAgIC8vIGVsc2UgcmVwbGFjZSA8YT4gd2l0aCBpdHMgY2hpbGROb2Rlc1xuICAgICAgaWYgKHRleHRDb250ZW50Lm1hdGNoKGRvbS5hdXRvTGluay5VUkxfUkVHX0VYUCkgJiYgIWNvZGVFbGVtZW50KSB7XG4gICAgICAgIC8vIDxjb2RlPiBlbGVtZW50IGlzIHVzZWQgdG8gcHJldmVudCBsYXRlciBhdXRvLWxpbmtpbmcgb2YgdGhlIGNvbnRlbnRcbiAgICAgICAgY29kZUVsZW1lbnQgPSBkb20ucmVuYW1lRWxlbWVudChhbmNob3IsIFwiY29kZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXMoYW5jaG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZm9ybWF0KGNvbXBvc2VyLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGRvYyA9IGNvbXBvc2VyLmRvYyxcbiAgICAgICAgdGVtcENsYXNzID0gXCJfd3lzaWh0bWw1LXRlbXAtXCIgKyArbmV3IERhdGUoKSxcbiAgICAgICAgdGVtcENsYXNzUmVnRXhwID0gL25vbi1tYXRjaGluZy1jbGFzcy9nLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBhbmNob3JzLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGhhc0VsZW1lbnRDaGlsZCxcbiAgICAgICAgaXNFbXB0eSxcbiAgICAgICAgZWxlbWVudFRvU2V0Q2FyZXRBZnRlcixcbiAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgIHdoaXRlU3BhY2UsXG4gICAgICAgIGo7XG4gICAgd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5leGVjKGNvbXBvc2VyLCB1bmRlZiwgTk9ERV9OQU1FLCB0ZW1wQ2xhc3MsIHRlbXBDbGFzc1JlZ0V4cCk7XG4gICAgYW5jaG9ycyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKE5PREVfTkFNRSArIFwiLlwiICsgdGVtcENsYXNzKTtcbiAgICBsZW5ndGggPSBhbmNob3JzLmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBhbmNob3IgPSBhbmNob3JzW2ldO1xuICAgICAgYW5jaG9yLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgICAgZm9yIChqIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZShqLCBhdHRyaWJ1dGVzW2pdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtZW50VG9TZXRDYXJldEFmdGVyID0gYW5jaG9yO1xuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIHRleHRDb250ZW50ID0gZG9tLmdldFRleHRDb250ZW50KGFuY2hvcik7XG4gICAgICBoYXNFbGVtZW50Q2hpbGQgPSAhIWFuY2hvci5xdWVyeVNlbGVjdG9yKFwiKlwiKTtcbiAgICAgIGlzRW1wdHkgPSB0ZXh0Q29udGVudCA9PT0gXCJcIiB8fCB0ZXh0Q29udGVudCA9PT0gd3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRTtcbiAgICAgIGlmICghaGFzRWxlbWVudENoaWxkICYmIGlzRW1wdHkpIHtcbiAgICAgICAgZG9tLnNldFRleHRDb250ZW50KGFuY2hvciwgYXR0cmlidXRlcy50ZXh0IHx8IGFuY2hvci5ocmVmKTtcbiAgICAgICAgd2hpdGVTcGFjZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZShcIiBcIik7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZXRBZnRlcihhbmNob3IpO1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uaW5zZXJ0Tm9kZSh3aGl0ZVNwYWNlKTtcbiAgICAgICAgZWxlbWVudFRvU2V0Q2FyZXRBZnRlciA9IHdoaXRlU3BhY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZXRBZnRlcihlbGVtZW50VG9TZXRDYXJldEFmdGVyKTtcbiAgfVxuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5jcmVhdGVMaW5rID0ge1xuICAgIC8qKlxuICAgICAqIFRPRE86IFVzZSBIVE1MQXBwbGllciBvciBmb3JtYXRJbmxpbmUgaGVyZVxuICAgICAqXG4gICAgICogVHVybnMgc2VsZWN0aW9uIGludG8gYSBsaW5rXG4gICAgICogSWYgc2VsZWN0aW9uIGlzIGFscmVhZHkgYSBsaW5rLCBpdCByZW1vdmVzIHRoZSBsaW5rIGFuZCB3cmFwcyBpdCB3aXRoIGEgPGNvZGU+IGVsZW1lbnRcbiAgICAgKiBUaGUgPGNvZGU+IGVsZW1lbnQgaXMgbmVlZGVkIHRvIGF2b2lkIGF1dG8gbGlua2luZ1xuICAgICAqIFxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgLy8gZWl0aGVyIC4uLlxuICAgICAqICAgIHd5c2lodG1sNS5jb21tYW5kcy5jcmVhdGVMaW5rLmV4ZWMoY29tcG9zZXIsIFwiY3JlYXRlTGlua1wiLCBcImh0dHA6Ly93d3cuZ29vZ2xlLmRlXCIpO1xuICAgICAqICAgIC8vIC4uLiBvciAuLi5cbiAgICAgKiAgICB3eXNpaHRtbDUuY29tbWFuZHMuY3JlYXRlTGluay5leGVjKGNvbXBvc2VyLCBcImNyZWF0ZUxpbmtcIiwgeyBocmVmOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmRlXCIsIHRhcmdldDogXCJfYmxhbmtcIiB9KTtcbiAgICAgKi9cbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kLCB2YWx1ZSkge1xuICAgICAgdmFyIGFuY2hvcnMgPSB0aGlzLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kKTtcbiAgICAgIGlmIChhbmNob3JzKSB7XG4gICAgICAgIC8vIFNlbGVjdGlvbiBjb250YWlucyBsaW5rc1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF9yZW1vdmVGb3JtYXQoY29tcG9zZXIsIGFuY2hvcnMpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBsaW5rc1xuICAgICAgICB2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih2YWx1ZSkpID09PSBcIm9iamVjdFwiID8gdmFsdWUgOiB7IGhyZWY6IHZhbHVlIH07XG4gICAgICAgIF9mb3JtYXQoY29tcG9zZXIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJBXCIpO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsgLyoqXG4gICAgICAgICAgICAgICAqIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiZm9udFNpemVcIikgd2lsbCBjcmVhdGUgZWl0aGVyIGlubGluZSBzdHlsZXMgKGZpcmVmb3gsIGNocm9tZSkgb3IgdXNlIGZvbnQgdGFnc1xuICAgICAgICAgICAgICAgKiB3aGljaCB3ZSBkb24ndCB3YW50XG4gICAgICAgICAgICAgICAqIEluc3RlYWQgd2Ugc2V0IGEgY3NzIGNsYXNzXG4gICAgICAgICAgICAgICAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmLFxuICAgICAgUkVHX0VYUCA9IC93eXNpd3lnLWZvbnQtc2l6ZS1bYS16XFwtXSsvZztcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuZm9udFNpemUgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCwgc2l6ZSkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuZXhlYyhjb21wb3NlciwgY29tbWFuZCwgXCJzcGFuXCIsIFwid3lzaXd5Zy1mb250LXNpemUtXCIgKyBzaXplLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBzaXplKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJzcGFuXCIsIFwid3lzaXd5Zy1mb250LXNpemUtXCIgKyBzaXplLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7XG4vKipcbiAqIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiZm9yZUNvbG9yXCIpIHdpbGwgY3JlYXRlIGVpdGhlciBpbmxpbmUgc3R5bGVzIChmaXJlZm94LCBjaHJvbWUpIG9yIHVzZSBmb250IHRhZ3NcbiAqIHdoaWNoIHdlIGRvbid0IHdhbnRcbiAqIEluc3RlYWQgd2Ugc2V0IGEgY3NzIGNsYXNzXG4gKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZixcbiAgICAgIFJFR19FWFAgPSAvd3lzaXd5Zy1jb2xvci1bYS16XSsvZztcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuZm9yZUNvbG9yID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIGNvbG9yKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5leGVjKGNvbXBvc2VyLCBjb21tYW5kLCBcInNwYW5cIiwgXCJ3eXNpd3lnLWNvbG9yLVwiICsgY29sb3IsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIGNvbG9yKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJzcGFuXCIsIFwid3lzaXd5Zy1jb2xvci1cIiArIGNvbG9yLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmLFxuICAgICAgZG9tID0gd3lzaWh0bWw1LmRvbSxcbiAgICAgIERFRkFVTFRfTk9ERV9OQU1FID0gXCJESVZcIixcblxuICAvLyBGb2xsb3dpbmcgZWxlbWVudHMgYXJlIGdyb3VwZWRcbiAgLy8gd2hlbiB0aGUgY2FyZXQgaXMgd2l0aGluIGEgSDEgYW5kIHRoZSBINCBpcyBpbnZva2VkLCB0aGUgSDEgc2hvdWxkIHR1cm4gaW50byBINFxuICAvLyBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgSDQgd2l0aGluIGEgSDEgd2hpY2ggd291bGQgcmVzdWx0IGluIHNlbWFudGljYWxseSBpbnZhbGlkIGh0bWxcbiAgQkxPQ0tfRUxFTUVOVFNfR1JPVVAgPSBbXCJIMVwiLCBcIkgyXCIsIFwiSDNcIiwgXCJINFwiLCBcIkg1XCIsIFwiSDZcIiwgXCJQXCIsIFwiQkxPQ0tRVU9URVwiLCBERUZBVUxUX05PREVfTkFNRV07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzaW1pbGlhciBjbGFzc2VzIChiYXNlZCBvbiBjbGFzc1JlZ0V4cClcbiAgICogYW5kIGFkZCB0aGUgZGVzaXJlZCBjbGFzcyBuYW1lXG4gICAqL1xuICBmdW5jdGlvbiBfYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkge1xuICAgIGlmIChlbGVtZW50LmNsYXNzTmFtZSkge1xuICAgICAgX3JlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzUmVnRXhwKTtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NSZWdFeHApIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoY2xhc3NSZWdFeHAsIFwiXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgZ2l2ZW4gbm9kZSBpcyBhIHRleHQgbm9kZSBhbmQgd2hldGhlciBpdCdzIGVtcHR5XG4gICAqL1xuICBmdW5jdGlvbiBfaXNCbGFua1RleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gd3lzaWh0bWw1LlRFWFRfTk9ERSAmJiAhd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKG5vZGUuZGF0YSkudHJpbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcHJldmlvdXMgc2libGluZyBub2RlIHRoYXQgaXMgbm90IGEgYmxhbmsgdGV4dCBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0UHJldmlvdXNTaWJsaW5nVGhhdElzTm90Qmxhbmsobm9kZSkge1xuICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICB3aGlsZSAocHJldmlvdXNTaWJsaW5nICYmIF9pc0JsYW5rVGV4dE5vZGUocHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgcHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXNTaWJsaW5nLnByZXZpb3VzU2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIHByZXZpb3VzU2libGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5leHQgc2libGluZyBub2RlIHRoYXQgaXMgbm90IGEgYmxhbmsgdGV4dCBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0TmV4dFNpYmxpbmdUaGF0SXNOb3RCbGFuayhub2RlKSB7XG4gICAgdmFyIG5leHRTaWJsaW5nID0gbm9kZS5uZXh0U2libGluZztcbiAgICB3aGlsZSAobmV4dFNpYmxpbmcgJiYgX2lzQmxhbmtUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBuZXh0U2libGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGxpbmUgYnJlYWtzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGdpdmVuIG5vZGUgaWYgdGhlIHByZXZpb3VzIGFuZCBuZXh0IHNpYmxpbmdzXG4gICAqIGFyZW4ndCBhbHJlYWR5IGNhdXNpbmcgYSB2aXN1YWwgbGluZSBicmVhayAoYmxvY2sgZWxlbWVudCBvciA8YnI+KVxuICAgKi9cbiAgZnVuY3Rpb24gX2FkZExpbmVCcmVha0JlZm9yZUFuZEFmdGVyKG5vZGUpIHtcbiAgICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50LFxuICAgICAgICBuZXh0U2libGluZyA9IF9nZXROZXh0U2libGluZ1RoYXRJc05vdEJsYW5rKG5vZGUpLFxuICAgICAgICBwcmV2aW91c1NpYmxpbmcgPSBfZ2V0UHJldmlvdXNTaWJsaW5nVGhhdElzTm90Qmxhbmsobm9kZSk7XG5cbiAgICBpZiAobmV4dFNpYmxpbmcgJiYgIV9pc0xpbmVCcmVha09yQmxvY2tFbGVtZW50KG5leHRTaWJsaW5nKSkge1xuICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkb2MuY3JlYXRlRWxlbWVudChcImJyXCIpLCBuZXh0U2libGluZyk7XG4gICAgfVxuICAgIGlmIChwcmV2aW91c1NpYmxpbmcgJiYgIV9pc0xpbmVCcmVha09yQmxvY2tFbGVtZW50KHByZXZpb3VzU2libGluZykpIHtcbiAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9jLmNyZWF0ZUVsZW1lbnQoXCJiclwiKSwgbm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgbGluZSBicmVha3MgYmVmb3JlIGFuZCBhZnRlciB0aGUgZ2l2ZW4gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gX3JlbW92ZUxpbmVCcmVha0JlZm9yZUFuZEFmdGVyKG5vZGUpIHtcbiAgICB2YXIgbmV4dFNpYmxpbmcgPSBfZ2V0TmV4dFNpYmxpbmdUaGF0SXNOb3RCbGFuayhub2RlKSxcbiAgICAgICAgcHJldmlvdXNTaWJsaW5nID0gX2dldFByZXZpb3VzU2libGluZ1RoYXRJc05vdEJsYW5rKG5vZGUpO1xuXG4gICAgaWYgKG5leHRTaWJsaW5nICYmIF9pc0xpbmVCcmVhayhuZXh0U2libGluZykpIHtcbiAgICAgIG5leHRTaWJsaW5nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobmV4dFNpYmxpbmcpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXNTaWJsaW5nICYmIF9pc0xpbmVCcmVhayhwcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICBwcmV2aW91c1NpYmxpbmcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aW91c1NpYmxpbmcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9yZW1vdmVMYXN0Q2hpbGRJZkxpbmVCcmVhayhub2RlKSB7XG4gICAgdmFyIGxhc3RDaGlsZCA9IG5vZGUubGFzdENoaWxkO1xuICAgIGlmIChsYXN0Q2hpbGQgJiYgX2lzTGluZUJyZWFrKGxhc3RDaGlsZCkpIHtcbiAgICAgIGxhc3RDaGlsZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxhc3RDaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2lzTGluZUJyZWFrKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlTmFtZSA9PT0gXCJCUlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBlbG1lbnQgY2F1c2VzIGEgdmlzdWFsIGxpbmUgYnJlYWtcbiAgICogKDxicj4gb3IgYmxvY2sgZWxlbWVudHMpXG4gICAqL1xuICBmdW5jdGlvbiBfaXNMaW5lQnJlYWtPckJsb2NrRWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKF9pc0xpbmVCcmVhayhlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGRvbS5nZXRTdHlsZShcImRpc3BsYXlcIikuZnJvbShlbGVtZW50KSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBuYXRpdmUgcXVlcnkgY29tbWFuZFxuICAgKiBhbmQgaWYgbmVjZXNzYXJ5IG1vZGlmeSB0aGUgaW5zZXJ0ZWQgbm9kZSdzIGNsYXNzTmFtZVxuICAgKi9cbiAgZnVuY3Rpb24gX2V4ZWNDb21tYW5kKGRvYywgY29tbWFuZCwgbm9kZU5hbWUsIGNsYXNzTmFtZSkge1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIHZhciBldmVudExpc3RlbmVyID0gZG9tLm9ic2VydmUoZG9jLCBcIkRPTU5vZGVJbnNlcnRlZFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgIGRpc3BsYXlTdHlsZTtcbiAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSAhPT0gd3lzaWh0bWw1LkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkaXNwbGF5U3R5bGUgPSBkb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20odGFyZ2V0KTtcbiAgICAgICAgaWYgKGRpc3BsYXlTdHlsZS5zdWJzdHIoMCwgNikgIT09IFwiaW5saW5lXCIpIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBvbmx5IGJsb2NrIGVsZW1lbnRzIHJlY2VpdmUgdGhlIGdpdmVuIGNsYXNzXG4gICAgICAgICAgdGFyZ2V0LmNsYXNzTmFtZSArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGRvYy5leGVjQ29tbWFuZChjb21tYW5kLCBmYWxzZSwgbm9kZU5hbWUpO1xuICAgIGlmIChldmVudExpc3RlbmVyKSB7XG4gICAgICBldmVudExpc3RlbmVyLnN0b3AoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfc2VsZWN0TGluZUFuZFdyYXAoY29tcG9zZXIsIGVsZW1lbnQpIHtcbiAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2VsZWN0TGluZSgpO1xuICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zdXJyb3VuZChlbGVtZW50KTtcbiAgICBfcmVtb3ZlTGluZUJyZWFrQmVmb3JlQW5kQWZ0ZXIoZWxlbWVudCk7XG4gICAgX3JlbW92ZUxhc3RDaGlsZElmTGluZUJyZWFrKGVsZW1lbnQpO1xuICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZWxlY3ROb2RlKGVsZW1lbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2hhc0NsYXNzZXMoZWxlbWVudCkge1xuICAgIHJldHVybiAhIXd5c2lodG1sNS5sYW5nLnN0cmluZyhlbGVtZW50LmNsYXNzTmFtZSkudHJpbSgpO1xuICB9XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIG5vZGVOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSB7XG4gICAgICB2YXIgZG9jID0gY29tcG9zZXIuZG9jLFxuICAgICAgICAgIGJsb2NrRWxlbWVudCA9IHRoaXMuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIG5vZGVOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSxcbiAgICAgICAgICBzZWxlY3RlZE5vZGU7XG5cbiAgICAgIG5vZGVOYW1lID0gdHlwZW9mIG5vZGVOYW1lID09PSBcInN0cmluZ1wiID8gbm9kZU5hbWUudG9VcHBlckNhc2UoKSA6IG5vZGVOYW1lO1xuXG4gICAgICBpZiAoYmxvY2tFbGVtZW50KSB7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGNsYXNzUmVnRXhwKSB7XG4gICAgICAgICAgICBfcmVtb3ZlQ2xhc3MoYmxvY2tFbGVtZW50LCBjbGFzc1JlZ0V4cCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBoYXNDbGFzc2VzID0gX2hhc0NsYXNzZXMoYmxvY2tFbGVtZW50KTtcbiAgICAgICAgICBpZiAoIWhhc0NsYXNzZXMgJiYgYmxvY2tFbGVtZW50Lm5vZGVOYW1lID09PSAobm9kZU5hbWUgfHwgREVGQVVMVF9OT0RFX05BTUUpKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgYSBsaW5lIGJyZWFrIGFmdGVyd2FyZHMgYW5kIGJlZm9yZXdhcmRzIHdoZW4gdGhlcmUgYXJlIHNpYmxpbmdzXG4gICAgICAgICAgICAvLyB0aGF0IGFyZSBub3Qgb2YgdHlwZSBsaW5lIGJyZWFrIG9yIGJsb2NrIGVsZW1lbnRcbiAgICAgICAgICAgIF9hZGRMaW5lQnJlYWtCZWZvcmVBbmRBZnRlcihibG9ja0VsZW1lbnQpO1xuICAgICAgICAgICAgZG9tLnJlcGxhY2VXaXRoQ2hpbGROb2RlcyhibG9ja0VsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2xhc3Nlcykge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgc3R5bGluZyBpcyBrZXB0IGJ5IHJlbmFtaW5nIHRoZSBlbGVtZW50IHRvIDxkaXY+IGFuZCBjb3B5aW5nIG92ZXIgdGhlIGNsYXNzIG5hbWVcbiAgICAgICAgICAgIGRvbS5yZW5hbWVFbGVtZW50KGJsb2NrRWxlbWVudCwgREVGQVVMVF9OT0RFX05BTUUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBzaW1pbGlhciBibG9jayBlbGVtZW50IGFuZCByZW5hbWUgaXQgKDxoMiBjbGFzcz1cImZvb1wiPjwvaDI+ICA9PiAgPGgxIGNsYXNzPVwiZm9vXCI+PC9oMT4pXG4gICAgICBpZiAobm9kZU5hbWUgPT09IG51bGwgfHwgd3lzaWh0bWw1LmxhbmcuYXJyYXkoQkxPQ0tfRUxFTUVOVFNfR1JPVVApLmNvbnRhaW5zKG5vZGVOYW1lKSkge1xuICAgICAgICBzZWxlY3RlZE5vZGUgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICAgIGJsb2NrRWxlbWVudCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwge1xuICAgICAgICAgIG5vZGVOYW1lOiBCTE9DS19FTEVNRU5UU19HUk9VUFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYmxvY2tFbGVtZW50KSB7XG4gICAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlU2ltcGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFJlbmFtZSBjdXJyZW50IGJsb2NrIGVsZW1lbnQgdG8gbmV3IGJsb2NrIGVsZW1lbnQgYW5kIGFkZCBjbGFzc1xuICAgICAgICAgICAgaWYgKG5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgIGJsb2NrRWxlbWVudCA9IGRvbS5yZW5hbWVFbGVtZW50KGJsb2NrRWxlbWVudCwgbm9kZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICBfYWRkQ2xhc3MoYmxvY2tFbGVtZW50LCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvc2VyLmNvbW1hbmRzLnN1cHBvcnQoY29tbWFuZCkpIHtcbiAgICAgICAgX2V4ZWNDb21tYW5kKGRvYywgY29tbWFuZCwgbm9kZU5hbWUgfHwgREVGQVVMVF9OT0RFX05BTUUsIGNsYXNzTmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYmxvY2tFbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUgfHwgREVGQVVMVF9OT0RFX05BTUUpO1xuICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBibG9ja0VsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgfVxuICAgICAgX3NlbGVjdExpbmVBbmRXcmFwKGNvbXBvc2VyLCBibG9ja0VsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIG5vZGVOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSB7XG4gICAgICBub2RlTmFtZSA9IHR5cGVvZiBub2RlTmFtZSA9PT0gXCJzdHJpbmdcIiA/IG5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgOiBub2RlTmFtZTtcbiAgICAgIHZhciBzZWxlY3RlZE5vZGUgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICByZXR1cm4gZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7XG4gICAgICAgIG5vZGVOYW1lOiBub2RlTmFtZSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIGNsYXNzUmVnRXhwOiBjbGFzc1JlZ0V4cFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyAvKipcbiAgICAgICAgICAgICAgICogZm9ybWF0SW5saW5lIHNjZW5hcmlvcyBmb3IgdGFnIFwiQlwiICh8ID0gY2FyZXQsIHxmb298ID0gc2VsZWN0ZWQgdGV4dClcbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogICAjMSBjYXJldCBpbiB1bmZvcm1hdHRlZCB0ZXh0OlxuICAgICAgICAgICAgICAgKiAgICAgIGFiY2RlZmd8XG4gICAgICAgICAgICAgICAqICAgb3V0cHV0OlxuICAgICAgICAgICAgICAgKiAgICAgIGFiY2RlZmc8Yj58PC9iPlxuICAgICAgICAgICAgICAgKiAgIFxuICAgICAgICAgICAgICAgKiAgICMyIHVuZm9ybWF0dGVkIHRleHQgc2VsZWN0ZWQ6XG4gICAgICAgICAgICAgICAqICAgICAgYWJjfGRlZ3xoXG4gICAgICAgICAgICAgICAqICAgb3V0cHV0OlxuICAgICAgICAgICAgICAgKiAgICAgIGFiYzxiPnxkZWd8PC9iPmhcbiAgICAgICAgICAgICAgICogICBcbiAgICAgICAgICAgICAgICogICAjMyB1bmZvcm1hdHRlZCB0ZXh0IHNlbGVjdGVkIGFjcm9zcyBib3VuZGFyaWVzOlxuICAgICAgICAgICAgICAgKiAgICAgIGFifGMgPHNwYW4+ZGVmZ3xoPC9zcGFuPlxuICAgICAgICAgICAgICAgKiAgIG91dHB1dDpcbiAgICAgICAgICAgICAgICogICAgICBhYjxiPnxjIDwvYj48c3Bhbj48Yj5kZWZnPC9iPnxoPC9zcGFuPlxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiAgICM0IGZvcm1hdHRlZCB0ZXh0IGVudGlyZWx5IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAqICAgICAgPGI+fGFiY3w8L2I+XG4gICAgICAgICAgICAgICAqICAgb3V0cHV0OlxuICAgICAgICAgICAgICAgKiAgICAgIHxhYmN8XG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqICAgIzUgZm9ybWF0dGVkIHRleHQgcGFydGlhbGx5IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAqICAgICAgPGI+YWJ8Y3w8L2I+XG4gICAgICAgICAgICAgICAqICAgb3V0cHV0OlxuICAgICAgICAgICAgICAgKiAgICAgIDxiPmFiPC9iPnxjfFxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiAgICM2IGZvcm1hdHRlZCB0ZXh0IHNlbGVjdGVkIGFjcm9zcyBib3VuZGFyaWVzXG4gICAgICAgICAgICAgICAqICAgICAgPHNwYW4+YWJ8Yzwvc3Bhbj4gPGI+ZGV8ZmdoPC9iPlxuICAgICAgICAgICAgICAgKiAgIG91dHB1dDpcbiAgICAgICAgICAgICAgICogICAgICA8c3Bhbj5hYnxjPC9zcGFuPiBkZXw8Yj5mZ2g8L2I+XG4gICAgICAgICAgICAgICAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmLFxuXG4gIC8vIFRyZWF0IDxiPiBhcyA8c3Ryb25nPiBhbmQgdmljZSB2ZXJzYVxuICBBTElBU19NQVBQSU5HID0ge1xuICAgIFwic3Ryb25nXCI6IFwiYlwiLFxuICAgIFwiZW1cIjogXCJpXCIsXG4gICAgXCJiXCI6IFwic3Ryb25nXCIsXG4gICAgXCJpXCI6IFwiZW1cIlxuICB9LFxuICAgICAgaHRtbEFwcGxpZXIgPSB7fTtcblxuICBmdW5jdGlvbiBfZ2V0VGFnTmFtZXModGFnTmFtZSkge1xuICAgIHZhciBhbGlhcyA9IEFMSUFTX01BUFBJTkdbdGFnTmFtZV07XG4gICAgcmV0dXJuIGFsaWFzID8gW3RhZ05hbWUudG9Mb3dlckNhc2UoKSwgYWxpYXMudG9Mb3dlckNhc2UoKV0gOiBbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9mb3JtYXRDbGVhcihyYW5nZSkge1xuICAgIGJvZHkgPSAkKHJhbmdlLmVuZENvbnRhaW5lci5vd25lckRvY3VtZW50LmJvZHkpO1xuICAgICQuZWFjaChib2R5LmNoaWxkcmVuKCdmb250JyksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvbnRfZWwgPSAkKHRoaXMpO1xuICAgICAgZm9udF9lbC5yZXBsYWNlV2l0aCgnPHNwYW4+JyArIGZvbnRfZWwuaHRtbCgpICsgJzwvc3Bhbj4nKTtcbiAgICB9KTtcblxuICAgICQuZWFjaChib2R5LmNoaWxkcmVuKCdzcGFuJyksIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNwYW5fZWwgPSAkKHRoaXMpO1xuICAgICAgcmVkdWNlZF9kaW1lbnNpb24oc3Bhbl9lbCk7XG4gICAgfSk7XG4gICAgbm90X3NwYW5fbGlzdCA9ICQoJ3Rib2R5OmZpcnN0ID4gdHInKS5ub3QoJ3RkJykudG9BcnJheSgpO1xuICAgIHdoaWxlIChub3Rfc3Bhbl9saXN0Lmxlbmd0aCkge1xuICAgICAgbm90X3NwYW5fbGlzdF9pdGVtID0gbm90X3NwYW5fbGlzdC5wb3AoKTtcbiAgICAgICQuZWFjaChub3Rfc3Bhbl9saXN0X2l0ZW0uY2hpbGRyZW4oKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXdfZWwgPSAkKHRoaXMpO1xuICAgICAgICBpZiAobmV3X2VsLmlzKCdzcGFuJykpIHtcbiAgICAgICAgICByZWR1Y2VkX2RpbWVuc2lvbihuZXdfZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vdF9zcGFuX2xpc3QucHVzaChuZXdfZWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgJC5lYWNoKGJvZHkuZmluZCgnc3BhbicpLCBmdW5jdGlvbiAoKSB7XG4gICAgICBlbCA9ICQodGhpcyk7XG4gICAgICBpZiAoISQudHJpbShlbC50ZXh0KCkpLmxlbmd0aCkge1xuICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByYW5nZS5lbmRDb250YWluZXIub3duZXJEb2N1bWVudC5nZXRTZWxlY3Rpb24oKS5lbXB0eSgpO1xuICB9XG5cbiAgLy8gbWFrZSA8c3BhbiBjbGFzcz0nYSc+MTIzPHNwYW4gY2xhc3M9J2InPjQ8L3NwYW4+NTwvc3Bhbj4gYmVjb21lXG4gIC8vIDxzcGFuIGNsYXNzPSdhJz4xMjM8L3NwYW4+IDxzcGFuIGNsYXNzPSdiJz40PC9zcGFuPiA8c3BhbiBjbGFzcz0nYSc+NTwvc3Bhbj5cbiAgZnVuY3Rpb24gcmVkdWNlZF9kaW1lbnNpb24oc3Bhbikge1xuICAgIGlmIChzcGFuLmNoaWxkcmVuKCdzcGFuJykubGVuZ3RoKSB7XG4gICAgICBjbGFzc19uYW1lID0gJC50cmltKHNwYW4uZ2V0KDApLmNsYXNzTmFtZSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW4uY2hpbGRyZW4oJ3NwYW4nKS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZF9zcGFuID0gJChzcGFuLmNoaWxkcmVuKCdzcGFuJylbaV0pO1xuICAgICAgICByZWR1Y2VkX2RpbWVuc2lvbihjaGlsZF9zcGFuKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coc3Bhbi5wYXJlbnRzKCdzcGFuJykubGVuZ3RoKTtcbiAgICAgIGh0bWxfdGV4dCA9IHNwYW4uaHRtbCgpO1xuICAgICAgaWYgKCFjbGFzc19uYW1lLmxlbmd0aCkge1xuICAgICAgICBjbGFzc19uYW1lID0gJ3d5c2l3eWctY29sb3ItY2xlYXInO1xuICAgICAgfVxuICAgICAgaHRtbF90ZXh0ID0gaHRtbF90ZXh0LnJlcGxhY2UoLzxzcGFuXFwgLywgJzwvc3Bhbj48c3BhbiAnKTtcbiAgICAgIGh0bWxfdGV4dCA9IGh0bWxfdGV4dC5yZXBsYWNlKC88XFwvc3Bhbj4oPyFbXFxzXFxTXSo8XFwvc3Bhbj5bXFxzXFxTXSokKS9pLCBcIjwvc3Bhbj48c3BhbiBjbGFzcz0nXCIgKyBjbGFzc19uYW1lICsgXCInPlwiKTtcbiAgICAgIGh0bWxfdGV4dCA9IFwiPHNwYW4gY2xhc3M9J1wiICsgY2xhc3NfbmFtZSArIFwiJz5cIiArIGh0bWxfdGV4dCArIFwiPC9zcGFuPlwiO1xuICAgICAgc3Bhbi5yZXBsYWNlV2l0aChodG1sX3RleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2dldEFwcGxpZXIodGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkge1xuICAgIHZhciBpZGVudGlmaWVyID0gdGFnTmFtZSArIFwiOlwiICsgY2xhc3NOYW1lO1xuICAgIGlmICghaHRtbEFwcGxpZXJbaWRlbnRpZmllcl0pIHtcbiAgICAgIGh0bWxBcHBsaWVyW2lkZW50aWZpZXJdID0gbmV3IHd5c2lodG1sNS5zZWxlY3Rpb24uSFRNTEFwcGxpZXIoX2dldFRhZ05hbWVzKHRhZ05hbWUpLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWxBcHBsaWVyW2lkZW50aWZpZXJdO1xuICB9XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZSA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kLCB0YWdOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgX2dldEFwcGxpZXIodGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkudG9nZ2xlUmFuZ2UocmFuZ2UpO1xuICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNldFNlbGVjdGlvbihyYW5nZSk7XG4gICAgICBfZm9ybWF0Q2xlYXIocmFuZ2UpO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIHRhZ05hbWUsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApIHtcbiAgICAgIHZhciBkb2MgPSBjb21wb3Nlci5kb2MsXG4gICAgICAgICAgYWxpYXNUYWdOYW1lID0gQUxJQVNfTUFQUElOR1t0YWdOYW1lXSB8fCB0YWdOYW1lLFxuICAgICAgICAgIHJhbmdlO1xuXG4gICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkb2N1bWVudCBjb250YWlucyBhIG5vZGUgd2l0aCB0aGUgZGVzaXJlZCB0YWdOYW1lXG4gICAgICBpZiAoIXd5c2lodG1sNS5kb20uaGFzRWxlbWVudFdpdGhUYWdOYW1lKGRvYywgdGFnTmFtZSkgJiYgIXd5c2lodG1sNS5kb20uaGFzRWxlbWVudFdpdGhUYWdOYW1lKGRvYywgYWxpYXNUYWdOYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRvY3VtZW50IGNvbnRhaW5zIGEgbm9kZSB3aXRoIHRoZSBkZXNpcmVkIGNsYXNzTmFtZVxuICAgICAgaWYgKGNsYXNzTmFtZSAmJiAhd3lzaWh0bWw1LmRvbS5oYXNFbGVtZW50V2l0aENsYXNzTmFtZShkb2MsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByYW5nZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRSYW5nZSgpO1xuICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZ2V0QXBwbGllcih0YWdOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKS5pc0FwcGxpZWRUb1JhbmdlKHJhbmdlKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmO1xuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRIVE1MID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIGh0bWwpIHtcbiAgICAgIGlmIChjb21wb3Nlci5jb21tYW5kcy5zdXBwb3J0KGNvbW1hbmQpKSB7XG4gICAgICAgIGNvbXBvc2VyLmRvYy5leGVjQ29tbWFuZChjb21tYW5kLCBmYWxzZSwgaHRtbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uaW5zZXJ0SFRNTChodG1sKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgTk9ERV9OQU1FID0gXCJJTUdcIjtcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuaW5zZXJ0SW1hZ2UgPSB7XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiA8aW1nPlxuICAgICAqIElmIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGFuIGltYWdlIGxpbmssIGl0IHJlbW92ZXMgaXRcbiAgICAgKiBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIC8vIGVpdGhlciAuLi5cbiAgICAgKiAgICB3eXNpaHRtbDUuY29tbWFuZHMuaW5zZXJ0SW1hZ2UuZXhlYyhjb21wb3NlciwgXCJpbnNlcnRJbWFnZVwiLCBcImh0dHA6Ly93d3cuZ29vZ2xlLmRlL2xvZ28uanBnXCIpO1xuICAgICAqICAgIC8vIC4uLiBvciAuLi5cbiAgICAgKiAgICB3eXNpaHRtbDUuY29tbWFuZHMuaW5zZXJ0SW1hZ2UuZXhlYyhjb21wb3NlciwgXCJpbnNlcnRJbWFnZVwiLCB7IHNyYzogXCJodHRwOi8vd3d3Lmdvb2dsZS5kZS9sb2dvLmpwZ1wiLCB0aXRsZTogXCJmb29cIiB9KTtcbiAgICAgKi9cbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kLCB2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YodmFsdWUpKSA9PT0gXCJvYmplY3RcIiA/IHZhbHVlIDogeyBzcmM6IHZhbHVlIH07XG5cbiAgICAgIHZhciBkb2MgPSBjb21wb3Nlci5kb2MsXG4gICAgICAgICAgaW1hZ2UgPSB0aGlzLnN0YXRlKGNvbXBvc2VyKSxcbiAgICAgICAgICB0ZXh0Tm9kZSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHBhcmVudDtcblxuICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgIC8vIEltYWdlIGFscmVhZHkgc2VsZWN0ZWQsIHNldCB0aGUgY2FyZXQgYmVmb3JlIGl0IGFuZCBkZWxldGUgaXRcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNldEJlZm9yZShpbWFnZSk7XG4gICAgICAgIHBhcmVudCA9IGltYWdlLnBhcmVudE5vZGU7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChpbWFnZSk7XG5cbiAgICAgICAgLy8gYW5kIGl0J3MgcGFyZW50IDxhPiB0b28gaWYgaXQgaGFzbid0IGdvdCBhbnkgb3RoZXIgcmVsZXZhbnQgY2hpbGQgbm9kZXNcbiAgICAgICAgd3lzaWh0bWw1LmRvbS5yZW1vdmVFbXB0eVRleHROb2RlcyhwYXJlbnQpO1xuICAgICAgICBpZiAocGFyZW50Lm5vZGVOYW1lID09PSBcIkFcIiAmJiAhcGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2V0QWZ0ZXIocGFyZW50KTtcbiAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwYXJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyZWZveCBhbmQgaWUgc29tZXRpbWVzIGRvbid0IHJlbW92ZSB0aGUgaW1hZ2UgaGFuZGxlcywgZXZlbiB0aG91Z2ggdGhlIGltYWdlIGdvdCByZW1vdmVkXG4gICAgICAgIHd5c2lodG1sNS5xdWlya3MucmVkcmF3KGNvbXBvc2VyLmVsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGltYWdlID0gZG9jLmNyZWF0ZUVsZW1lbnQoTk9ERV9OQU1FKTtcblxuICAgICAgZm9yIChpIGluIHZhbHVlKSB7XG4gICAgICAgIGltYWdlW2ldID0gdmFsdWVbaV07XG4gICAgICB9XG5cbiAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5pbnNlcnROb2RlKGltYWdlKTtcbiAgICAgIGlmICh3eXNpaHRtbDUuYnJvd3Nlci5oYXNQcm9ibGVtc1NldHRpbmdDYXJldEFmdGVySW1nKCkpIHtcbiAgICAgICAgdGV4dE5vZGUgPSBkb2MuY3JlYXRlVGV4dE5vZGUod3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRSk7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5pbnNlcnROb2RlKHRleHROb2RlKTtcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNldEFmdGVyKHRleHROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZXRBZnRlcihpbWFnZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21wb3Nlcikge1xuICAgICAgdmFyIGRvYyA9IGNvbXBvc2VyLmRvYyxcbiAgICAgICAgICBzZWxlY3RlZE5vZGUsXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICBpbWFnZXNJblNlbGVjdGlvbjtcblxuICAgICAgaWYgKCF3eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoVGFnTmFtZShkb2MsIE5PREVfTkFNRSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3RlZE5vZGUgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICBpZiAoIXNlbGVjdGVkTm9kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZE5vZGUubm9kZU5hbWUgPT09IE5PREVfTkFNRSkge1xuICAgICAgICAvLyBUaGlzIHdvcmtzIHBlcmZlY3RseSBpbiBJRVxuICAgICAgICByZXR1cm4gc2VsZWN0ZWROb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ZWROb2RlLm5vZGVUeXBlICE9PSB3eXNpaHRtbDUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGV4dCA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRUZXh0KCk7XG4gICAgICB0ZXh0ID0gd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKHRleHQpLnRyaW0oKTtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaW1hZ2VzSW5TZWxlY3Rpb24gPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0Tm9kZXMod3lzaWh0bWw1LkVMRU1FTlRfTk9ERSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09IFwiSU1HXCI7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGltYWdlc0luU2VsZWN0aW9uLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbWFnZXNJblNlbGVjdGlvblswXTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGNvbXBvc2VyKSB7XG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLnN0YXRlKGNvbXBvc2VyKTtcbiAgICAgIHJldHVybiBpbWFnZSAmJiBpbWFnZS5zcmM7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWYsXG4gICAgICBMSU5FX0JSRUFLID0gXCI8YnI+XCIgKyAod3lzaWh0bWw1LmJyb3dzZXIubmVlZHNTcGFjZUFmdGVyTGluZUJyZWFrKCkgPyBcIiBcIiA6IFwiXCIpO1xuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRMaW5lQnJlYWsgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgaWYgKGNvbXBvc2VyLmNvbW1hbmRzLnN1cHBvcnQoY29tbWFuZCkpIHtcbiAgICAgICAgY29tcG9zZXIuZG9jLmV4ZWNDb21tYW5kKGNvbW1hbmQsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5hdXRvU2Nyb2xsc1RvQ2FyZXQoKSkge1xuICAgICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb3Nlci5jb21tYW5kcy5leGVjKFwiaW5zZXJ0SFRNTFwiLCBMSU5FX0JSRUFLKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWY7XG4gIC8vXG4gIC8vIGZ1bmN0aW9uIF9yZW1vdmVGb3JtYXQoY29tcG9zZXIsIGFuY2hvcnMpIHtcbiAgLy8gICB2YXIgbGVuZ3RoICA9IGFuY2hvcnMubGVuZ3RoLFxuICAvLyAgICAgICBpICAgICAgID0gMCxcbiAgLy8gICAgICAgYW5jaG9yLFxuICAvLyAgICAgICBjb2RlRWxlbWVudCxcbiAgLy8gICAgICAgdGV4dENvbnRlbnQ7XG4gIC8vICAgZm9yICg7IGk8bGVuZ3RoOyBpKyspIHtcbiAgLy8gICAgIGFuY2hvciAgICAgID0gYW5jaG9yc1tpXTtcbiAgLy8gICAgIGNvZGVFbGVtZW50ID0gZG9tLmdldFBhcmVudEVsZW1lbnQoYW5jaG9yLCB7IG5vZGVOYW1lOiBcImNvZGVcIiB9KTtcbiAgLy8gICAgIHRleHRDb250ZW50ID0gZG9tLmdldFRleHRDb250ZW50KGFuY2hvcik7XG4gIC8vXG4gIC8vICAgICAvLyBpZiA8YT4gY29udGFpbnMgdXJsLWxpa2UgdGV4dCBjb250ZW50LCByZW5hbWUgaXQgdG8gPGNvZGU+IHRvIHByZXZlbnQgcmUtYXV0b2xpbmtpbmdcbiAgLy8gICAgIC8vIGVsc2UgcmVwbGFjZSA8YT4gd2l0aCBpdHMgY2hpbGROb2Rlc1xuICAvLyAgICAgaWYgKHRleHRDb250ZW50Lm1hdGNoKGRvbS5hdXRvTGluay5VUkxfUkVHX0VYUCkgJiYgIWNvZGVFbGVtZW50KSB7XG4gIC8vICAgICAgIC8vIDxjb2RlPiBlbGVtZW50IGlzIHVzZWQgdG8gcHJldmVudCBsYXRlciBhdXRvLWxpbmtpbmcgb2YgdGhlIGNvbnRlbnRcbiAgLy8gICAgICAgY29kZUVsZW1lbnQgPSBkb20ucmVuYW1lRWxlbWVudChhbmNob3IsIFwiY29kZVwiKTtcbiAgLy8gICAgIH0gZWxzZSB7XG4gIC8vICAgICAgIGRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXMoYW5jaG9yKTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vIH1cbiAgLy9cbiAgLy9cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmNsZWFyID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIGNvbXBvc2VyLmRvYy5leGVjQ29tbWFuZCgncmVtb3ZlRm9ybWF0Jyk7XG4gICAgICBSRUdfRVhQID0gL3d5c2l3eWctY29sb3ItW2Etel0rL2c7XG4gICAgICB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIFwic3BhblwiLCBcIlwiLCBSRUdfRVhQKTtcbiAgICB9XG4gIH07XG4gIHd5c2lodG1sNS5jb21tYW5kcy5pbnNlcnRPcmRlcmVkTGlzdCA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICB2YXIgZG9jID0gY29tcG9zZXIuZG9jLFxuICAgICAgICAgIHNlbGVjdGVkTm9kZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKSxcbiAgICAgICAgICBsaXN0ID0gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwgeyBub2RlTmFtZTogXCJPTFwiIH0pLFxuICAgICAgICAgIG90aGVyTGlzdCA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHsgbm9kZU5hbWU6IFwiVUxcIiB9KSxcbiAgICAgICAgICB0ZW1wQ2xhc3NOYW1lID0gXCJfd3lzaWh0bWw1LXRlbXAtXCIgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICBpc0VtcHR5LFxuICAgICAgICAgIHRlbXBFbGVtZW50O1xuXG4gICAgICBpZiAoY29tcG9zZXIuY29tbWFuZHMuc3VwcG9ydChjb21tYW5kKSkge1xuICAgICAgICBkb2MuZXhlY0NvbW1hbmQoY29tbWFuZCwgZmFsc2UsIG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgIC8vIFVud3JhcCBsaXN0XG4gICAgICAgIC8vIDxvbD48bGk+Zm9vPC9saT48bGk+YmFyPC9saT48L29sPlxuICAgICAgICAvLyBiZWNvbWVzOlxuICAgICAgICAvLyBmb288YnI+YmFyPGJyPlxuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHd5c2lodG1sNS5kb20ucmVzb2x2ZUxpc3QobGlzdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvdGhlckxpc3QpIHtcbiAgICAgICAgLy8gVHVybiBhbiB1bm9yZGVyZWQgbGlzdCBpbnRvIGFuIG9yZGVyZWQgbGlzdFxuICAgICAgICAvLyA8dWw+PGxpPmZvbzwvbGk+PGxpPmJhcjwvbGk+PC91bD5cbiAgICAgICAgLy8gYmVjb21lczpcbiAgICAgICAgLy8gPG9sPjxsaT5mb288L2xpPjxsaT5iYXI8L2xpPjwvb2w+XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd3lzaWh0bWw1LmRvbS5yZW5hbWVFbGVtZW50KG90aGVyTGlzdCwgXCJvbFwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgbGlzdFxuICAgICAgICBjb21wb3Nlci5jb21tYW5kcy5leGVjKFwiZm9ybWF0QmxvY2tcIiwgXCJkaXZcIiwgdGVtcENsYXNzTmFtZSk7XG4gICAgICAgIHRlbXBFbGVtZW50ID0gZG9jLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyB0ZW1wQ2xhc3NOYW1lKTtcbiAgICAgICAgaXNFbXB0eSA9IHRlbXBFbGVtZW50LmlubmVySFRNTCA9PT0gXCJcIiB8fCB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPT09IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0U7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbGlzdCA9IHd5c2lodG1sNS5kb20uY29udmVydFRvTGlzdCh0ZW1wRWxlbWVudCwgXCJvbFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNlbGVjdE5vZGUobGlzdC5xdWVyeVNlbGVjdG9yKFwibGlcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21wb3Nlcikge1xuICAgICAgdmFyIHNlbGVjdGVkTm9kZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKTtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBcIk9MXCIgfSk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZjtcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuaW5zZXJ0VW5vcmRlcmVkTGlzdCA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICB2YXIgZG9jID0gY29tcG9zZXIuZG9jLFxuICAgICAgICAgIHNlbGVjdGVkTm9kZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKSxcbiAgICAgICAgICBsaXN0ID0gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwgeyBub2RlTmFtZTogXCJVTFwiIH0pLFxuICAgICAgICAgIG90aGVyTGlzdCA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHsgbm9kZU5hbWU6IFwiT0xcIiB9KSxcbiAgICAgICAgICB0ZW1wQ2xhc3NOYW1lID0gXCJfd3lzaWh0bWw1LXRlbXAtXCIgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgICBpc0VtcHR5LFxuICAgICAgICAgIHRlbXBFbGVtZW50O1xuXG4gICAgICBpZiAoY29tcG9zZXIuY29tbWFuZHMuc3VwcG9ydChjb21tYW5kKSkge1xuICAgICAgICBkb2MuZXhlY0NvbW1hbmQoY29tbWFuZCwgZmFsc2UsIG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgIC8vIFVud3JhcCBsaXN0XG4gICAgICAgIC8vIDx1bD48bGk+Zm9vPC9saT48bGk+YmFyPC9saT48L3VsPlxuICAgICAgICAvLyBiZWNvbWVzOlxuICAgICAgICAvLyBmb288YnI+YmFyPGJyPlxuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHd5c2lodG1sNS5kb20ucmVzb2x2ZUxpc3QobGlzdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChvdGhlckxpc3QpIHtcbiAgICAgICAgLy8gVHVybiBhbiBvcmRlcmVkIGxpc3QgaW50byBhbiB1bm9yZGVyZWQgbGlzdFxuICAgICAgICAvLyA8b2w+PGxpPmZvbzwvbGk+PGxpPmJhcjwvbGk+PC9vbD5cbiAgICAgICAgLy8gYmVjb21lczpcbiAgICAgICAgLy8gPHVsPjxsaT5mb288L2xpPjxsaT5iYXI8L2xpPjwvdWw+XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd3lzaWh0bWw1LmRvbS5yZW5hbWVFbGVtZW50KG90aGVyTGlzdCwgXCJ1bFwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgbGlzdFxuICAgICAgICBjb21wb3Nlci5jb21tYW5kcy5leGVjKFwiZm9ybWF0QmxvY2tcIiwgXCJkaXZcIiwgdGVtcENsYXNzTmFtZSk7XG4gICAgICAgIHRlbXBFbGVtZW50ID0gZG9jLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyB0ZW1wQ2xhc3NOYW1lKTtcbiAgICAgICAgaXNFbXB0eSA9IHRlbXBFbGVtZW50LmlubmVySFRNTCA9PT0gXCJcIiB8fCB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPT09IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0U7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbGlzdCA9IHd5c2lodG1sNS5kb20uY29udmVydFRvTGlzdCh0ZW1wRWxlbWVudCwgXCJ1bFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNlbGVjdE5vZGUobGlzdC5xdWVyeVNlbGVjdG9yKFwibGlcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21wb3Nlcikge1xuICAgICAgdmFyIHNlbGVjdGVkTm9kZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKTtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBcIlVMXCIgfSk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZjtcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuaXRhbGljID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIFwiaVwiKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBjb2xvcikge1xuICAgICAgLy8gZWxlbWVudC5vd25lckRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN0YXRlKFwiaXRhbGljXCIpIHJlc3VsdHM6XG4gICAgICAvLyBmaXJlZm94OiBvbmx5IDxpPlxuICAgICAgLy8gY2hyb21lOiAgPGk+LCA8ZW0+LCA8YmxvY2txdW90ZT4sIC4uLlxuICAgICAgLy8gaWU6ICAgICAgPGk+LCA8ZW0+XG4gICAgICAvLyBvcGVyYTogICBvbmx5IDxpPlxuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIFwiaVwiKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmLFxuICAgICAgQ0xBU1NfTkFNRSA9IFwid3lzaXd5Zy10ZXh0LWFsaWduLWNlbnRlclwiLFxuICAgICAgUkVHX0VYUCA9IC93eXNpd3lnLXRleHQtYWxpZ24tW2Etel0rL2c7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmp1c3RpZnlDZW50ZXIgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRCbG9jay5leGVjKGNvbXBvc2VyLCBcImZvcm1hdEJsb2NrXCIsIG51bGwsIENMQVNTX05BTUUsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0QmxvY2suc3RhdGUoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgQ0xBU1NfTkFNRSwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZixcbiAgICAgIENMQVNTX05BTUUgPSBcInd5c2l3eWctdGV4dC1hbGlnbi1sZWZ0XCIsXG4gICAgICBSRUdfRVhQID0gL3d5c2l3eWctdGV4dC1hbGlnbi1bYS16XSsvZztcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuanVzdGlmeUxlZnQgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRCbG9jay5leGVjKGNvbXBvc2VyLCBcImZvcm1hdEJsb2NrXCIsIG51bGwsIENMQVNTX05BTUUsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0QmxvY2suc3RhdGUoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgQ0xBU1NfTkFNRSwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZixcbiAgICAgIENMQVNTX05BTUUgPSBcInd5c2l3eWctdGV4dC1hbGlnbi1yaWdodFwiLFxuICAgICAgUkVHX0VYUCA9IC93eXNpd3lnLXRleHQtYWxpZ24tW2Etel0rL2c7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmp1c3RpZnlSaWdodCA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrLmV4ZWMoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgQ0xBU1NfTkFNRSwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRCbG9jay5zdGF0ZShjb21wb3NlciwgXCJmb3JtYXRCbG9ja1wiLCBudWxsLCBDTEFTU19OQU1FLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmO1xuICB3eXNpaHRtbDUuY29tbWFuZHMudW5kZXJsaW5lID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIFwidVwiKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJ1XCIpO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsgLyoqXG4gICAgICAgICAgICAgICAqIFVuZG8gTWFuYWdlciBmb3Igd3lzaWh0bWw1XG4gICAgICAgICAgICAgICAqIHNsaWdodGx5IGluc3BpcmVkIGJ5IGh0dHA6Ly9ybml3YS5jb20vZWRpdGluZy91bmRvbWFuYWdlci5odG1sI3RoZS11bmRvbWFuYWdlci1pbnRlcmZhY2VcbiAgICAgICAgICAgICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgWl9LRVkgPSA5MCxcbiAgICAgIFlfS0VZID0gODksXG4gICAgICBCQUNLU1BBQ0VfS0VZID0gOCxcbiAgICAgIERFTEVURV9LRVkgPSA0NixcbiAgICAgIE1BWF9ISVNUT1JZX0VOVFJJRVMgPSA0MCxcbiAgICAgIFVORE9fSFRNTCA9ICc8c3BhbiBpZD1cIl93eXNpaHRtbDUtdW5kb1wiIGNsYXNzPVwiX3d5c2lodG1sNS10ZW1wXCI+JyArIHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UgKyAnPC9zcGFuPicsXG4gICAgICBSRURPX0hUTUwgPSAnPHNwYW4gaWQ9XCJfd3lzaWh0bWw1LXJlZG9cIiBjbGFzcz1cIl93eXNpaHRtbDUtdGVtcFwiPicgKyB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFICsgJzwvc3Bhbj4nLFxuICAgICAgZG9tID0gd3lzaWh0bWw1LmRvbTtcblxuICBmdW5jdGlvbiBjbGVhblRlbXBFbGVtZW50cyhkb2MpIHtcbiAgICB2YXIgdGVtcEVsZW1lbnQ7XG4gICAgd2hpbGUgKHRlbXBFbGVtZW50ID0gZG9jLnF1ZXJ5U2VsZWN0b3IoXCIuX3d5c2lodG1sNS10ZW1wXCIpKSB7XG4gICAgICB0ZW1wRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXBFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICB3eXNpaHRtbDUuVW5kb01hbmFnZXIgPSB3eXNpaHRtbDUubGFuZy5EaXNwYXRjaGVyLmV4dGVuZChcbiAgLyoqIEBzY29wZSB3eXNpaHRtbDUuVW5kb01hbmFnZXIucHJvdG90eXBlICove1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgdGhpcy5jb21wb3NlciA9IGVkaXRvci5jb21wb3NlcjtcbiAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuY29tcG9zZXIuZWxlbWVudDtcbiAgICAgIHRoaXMuaGlzdG9yeSA9IFt0aGlzLmNvbXBvc2VyLmdldFZhbHVlKCldO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IDE7XG5cbiAgICAgIC8vIFVuZG8gbWFuYWdlciBjdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcnMgd2hvIGhhdmUgdGhlIGluc2VydEhUTUwgY29tbWFuZCAobm90IElFKVxuICAgICAgaWYgKHRoaXMuY29tcG9zZXIuY29tbWFuZHMuc3VwcG9ydChcImluc2VydEhUTUxcIikpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfb2JzZXJ2ZTogZnVuY3Rpb24gX29ic2VydmUoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgZG9jID0gdGhpcy5jb21wb3Nlci5zYW5kYm94LmdldERvY3VtZW50KCksXG4gICAgICAgICAgbGFzdEtleTtcblxuICAgICAgLy8gQ2F0Y2ggQ1RSTCtaIGFuZCBDVFJMK1lcbiAgICAgIGRvbS5vYnNlcnZlKHRoaXMuZWxlbWVudCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuYWx0S2V5IHx8ICFldmVudC5jdHJsS2V5ICYmICFldmVudC5tZXRhS2V5KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlLFxuICAgICAgICAgICAgaXNVbmRvID0ga2V5Q29kZSA9PT0gWl9LRVkgJiYgIWV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgaXNSZWRvID0ga2V5Q29kZSA9PT0gWl9LRVkgJiYgZXZlbnQuc2hpZnRLZXkgfHwga2V5Q29kZSA9PT0gWV9LRVk7XG5cbiAgICAgICAgaWYgKGlzVW5kbykge1xuICAgICAgICAgIHRoYXQudW5kbygpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWRvKSB7XG4gICAgICAgICAgdGhhdC5yZWRvKCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENhdGNoIGRlbGV0ZSBhbmQgYmFja3NwYWNlXG4gICAgICBkb20ub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gbGFzdEtleSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RLZXkgPSBrZXlDb2RlO1xuXG4gICAgICAgIGlmIChrZXlDb2RlID09PSBCQUNLU1BBQ0VfS0VZIHx8IGtleUNvZGUgPT09IERFTEVURV9LRVkpIHtcbiAgICAgICAgICB0aGF0LnRyYW5zYWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBOb3cgdGhpcyBpcyB2ZXJ5IGhhY2t5OlxuICAgICAgLy8gVGhlc2UgZGF5cyBicm93c2VycyBkb24ndCBvZmZlciBhIHVuZG8vcmVkbyBldmVudCB3aGljaCB3ZSBjb3VsZCBob29rIGludG9cbiAgICAgIC8vIHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHVzZXIgaGl0cyB1bmRvL3JlZG8gaW4gdGhlIGNvbnRleHRtZW51LlxuICAgICAgLy8gVGhlcmVmb3JlIHdlIHNpbXBseSBpbnNlcnQgdHdvIGVsZW1lbnRzIGFzIHNvb24gYXMgdGhlIGNvbnRleHRtZW51IGdldHMgb3BlbmVkLlxuICAgICAgLy8gVGhlIGxhc3QgZWxlbWVudCBiZWluZyBpbnNlcnRlZCB3aWxsIGJlIGltbWVkaWF0ZWx5IGJlIHJlbW92ZWQgYWdhaW4gYnkgYSBleGV4Q29tbWFuZChcInVuZG9cIilcbiAgICAgIC8vICA9PiBXaGVuIHRoZSBzZWNvbmQgZWxlbWVudCBhcHBlYXJzIGluIHRoZSBkb20gdHJlZSB0aGVuIHdlIGtub3cgdGhlIHVzZXIgY2xpY2tlZCBcInJlZG9cIiBpbiB0aGUgY29udGV4dCBtZW51XG4gICAgICAvLyAgPT4gV2hlbiB0aGUgZmlyc3QgZWxlbWVudCBkaXNhcHBlYXJzIGZyb20gdGhlIGRvbSB0cmVlIHRoZW4gd2Uga25vdyB0aGUgdXNlciBjbGlja2VkIFwidW5kb1wiIGluIHRoZSBjb250ZXh0IG1lbnVcbiAgICAgIGlmICh3eXNpaHRtbDUuYnJvd3Nlci5oYXNVbmRvSW5Db250ZXh0TWVudSgpKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCxcbiAgICAgICAgICAgIG9ic2VydmVkLFxuICAgICAgICAgICAgY2xlYW5VcCA9IGZ1bmN0aW9uIGNsZWFuVXAoKSB7XG4gICAgICAgICAgY2xlYW5UZW1wRWxlbWVudHMoZG9jKTtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICBkb20ub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNsZWFuVXAoKTtcbiAgICAgICAgICB0aGF0LmNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhhdC5lbGVtZW50Lmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICB0aGF0LmNvbXBvc2VyLnNlbGVjdGlvbi5zZXRBZnRlcih0aGF0LmVsZW1lbnQubGFzdENoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZW5hYmxlIHVuZG8gYnV0dG9uIGluIGNvbnRleHQgbWVudVxuICAgICAgICAgICAgZG9jLmV4ZWNDb21tYW5kKFwiaW5zZXJ0SFRNTFwiLCBmYWxzZSwgVU5ET19IVE1MKTtcbiAgICAgICAgICAgIC8vIGVuYWJsZSByZWRvIGJ1dHRvbiBpbiBjb250ZXh0IG1lbnVcbiAgICAgICAgICAgIGRvYy5leGVjQ29tbWFuZChcImluc2VydEhUTUxcIiwgZmFsc2UsIFJFRE9fSFRNTCk7XG4gICAgICAgICAgICBkb2MuZXhlY0NvbW1hbmQoXCJ1bmRvXCIsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRvYy5nZXRFbGVtZW50QnlJZChcIl93eXNpaHRtbDUtcmVkb1wiKSkge1xuICAgICAgICAgICAgICBjbGVhblVwKCk7XG4gICAgICAgICAgICAgIHRoYXQucmVkbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDQwMCk7XG5cbiAgICAgICAgICBpZiAoIW9ic2VydmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlZCA9IHRydWU7XG4gICAgICAgICAgICBkb20ub2JzZXJ2ZShkb2N1bWVudCwgXCJtb3VzZWRvd25cIiwgY2xlYW5VcCk7XG4gICAgICAgICAgICBkb20ub2JzZXJ2ZShkb2MsIFtcIm1vdXNlZG93blwiLCBcInBhc3RlXCIsIFwiY3V0XCIsIFwiY29weVwiXSwgY2xlYW5VcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lZGl0b3Iub2JzZXJ2ZShcIm5ld3dvcmQ6Y29tcG9zZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0LnRyYW5zYWN0KCk7XG4gICAgICB9KS5vYnNlcnZlKFwiYmVmb3JlY29tbWFuZDpjb21wb3NlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQudHJhbnNhY3QoKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB0cmFuc2FjdDogZnVuY3Rpb24gdHJhbnNhY3QoKSB7XG4gICAgICB2YXIgcHJldmlvdXNIdG1sID0gdGhpcy5oaXN0b3J5W3RoaXMucG9zaXRpb24gLSAxXSxcbiAgICAgICAgICBjdXJyZW50SHRtbCA9IHRoaXMuY29tcG9zZXIuZ2V0VmFsdWUoKTtcblxuICAgICAgaWYgKGN1cnJlbnRIdG1sID09IHByZXZpb3VzSHRtbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLmhpc3RvcnkubGVuZ3RoID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIGlmIChsZW5ndGggPiBNQVhfSElTVE9SWV9FTlRSSUVTKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeS5zaGlmdCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uLS07XG4gICAgICB9XG5cbiAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKGN1cnJlbnRIdG1sKTtcbiAgICB9LFxuXG4gICAgdW5kbzogZnVuY3Rpb24gdW5kbygpIHtcbiAgICAgIHRoaXMudHJhbnNhY3QoKTtcblxuICAgICAgaWYgKHRoaXMucG9zaXRpb24gPD0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0KHRoaXMuaGlzdG9yeVstLXRoaXMucG9zaXRpb24gLSAxXSk7XG4gICAgICB0aGlzLmVkaXRvci5maXJlKFwidW5kbzpjb21wb3NlclwiKTtcbiAgICB9LFxuXG4gICAgcmVkbzogZnVuY3Rpb24gcmVkbygpIHtcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uID49IHRoaXMuaGlzdG9yeS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldCh0aGlzLmhpc3RvcnlbKyt0aGlzLnBvc2l0aW9uIC0gMV0pO1xuICAgICAgdGhpcy5lZGl0b3IuZmlyZShcInJlZG86Y29tcG9zZXJcIik7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24gc2V0KGh0bWwpIHtcbiAgICAgIHRoaXMuY29tcG9zZXIuc2V0VmFsdWUoaHRtbCk7XG4gICAgICB0aGlzLmVkaXRvci5mb2N1cyh0cnVlKTtcbiAgICB9XG4gIH0pO1xufSkod3lzaWh0bWw1KTtcbi8qKlxuICogVE9ETzogdGhlIGZvbGxvd2luZyBtZXRob2RzIHN0aWxsIG5lZWQgdW5pdCB0ZXN0IGNvdmVyYWdlXG4gKi9cbnd5c2lodG1sNS52aWV3cy5WaWV3ID0gQmFzZS5leHRlbmQoXG4vKiogQHNjb3BlIHd5c2lodG1sNS52aWV3cy5WaWV3LnByb3RvdHlwZSAqL3tcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKHBhcmVudCwgdGV4dGFyZWFFbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmVsZW1lbnQgPSB0ZXh0YXJlYUVsZW1lbnQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG5cbiAgICB0aGlzLl9vYnNlcnZlVmlld0NoYW5nZSgpO1xuICB9LFxuXG4gIF9vYnNlcnZlVmlld0NoYW5nZTogZnVuY3Rpb24gX29ic2VydmVWaWV3Q2hhbmdlKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGlzLnBhcmVudC5vYnNlcnZlKFwiYmVmb3JlbG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LnBhcmVudC5vYnNlcnZlKFwiY2hhbmdlX3ZpZXdcIiwgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgaWYgKHZpZXcgPT09IHRoYXQubmFtZSkge1xuICAgICAgICAgIHRoYXQucGFyZW50LmN1cnJlbnRWaWV3ID0gdGhhdDtcbiAgICAgICAgICB0aGF0LnNob3coKTtcbiAgICAgICAgICAvLyBVc2luZyB0aW55IGRlbGF5IGhlcmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHBsYWNlaG9sZGVyIGlzIHNldCBiZWZvcmUgZm9jdXNpbmdcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGF0LmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiOmZvY3VzXCIpID09PSB0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5lbGVtZW50LmZvY3VzKCk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSxcblxuICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIH0sXG5cbiAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gIH0sXG5cbiAgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiKTtcbiAgfSxcblxuICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XG4gIH1cbn0pOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciBkb20gPSB3eXNpaHRtbDUuZG9tLFxuICAgICAgYnJvd3NlciA9IHd5c2lodG1sNS5icm93c2VyO1xuXG4gIHd5c2lodG1sNS52aWV3cy5Db21wb3NlciA9IHd5c2lodG1sNS52aWV3cy5WaWV3LmV4dGVuZChcbiAgLyoqIEBzY29wZSB3eXNpaHRtbDUudmlld3MuQ29tcG9zZXIucHJvdG90eXBlICove1xuICAgIG5hbWU6IFwiY29tcG9zZXJcIixcblxuICAgIC8vIE5lZWRlZCBmb3IgZmlyZWZveCBpbiBvcmRlciB0byBkaXNwbGF5IGEgcHJvcGVyIGNhcmV0IGluIGFuIGVtcHR5IGNvbnRlbnRFZGl0YWJsZVxuICAgIENBUkVUX0hBQ0s6IFwiPGJyPlwiLFxuXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKHBhcmVudCwgdGV4dGFyZWFFbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHRoaXMuYmFzZShwYXJlbnQsIHRleHRhcmVhRWxlbWVudCwgY29uZmlnKTtcbiAgICAgIHRoaXMudGV4dGFyZWEgPSB0aGlzLnBhcmVudC50ZXh0YXJlYTtcbiAgICAgIHRoaXMuX2luaXRTYW5kYm94KCk7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSBicm93c2VyLmRpc3BsYXlzQ2FyZXRJbkVtcHR5Q29udGVudEVkaXRhYmxlQ29ycmVjdGx5KCkgPyBcIlwiIDogdGhpcy5DQVJFVF9IQUNLO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUocGFyc2UpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuaXNFbXB0eSgpID8gXCJcIiA6IHd5c2lodG1sNS5xdWlya3MuZ2V0Q29ycmVjdElubmVySFRNTCh0aGlzLmVsZW1lbnQpO1xuXG4gICAgICBpZiAocGFyc2UpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnBhcmVudC5wYXJzZSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlcGxhY2UgYWxsIFwiemVybyB3aWR0aCBubyBicmVha2luZyBzcGFjZVwiIGNoYXJzXG4gICAgICAvLyB3aGljaCBhcmUgdXNlZCBhcyBoYWNrcyB0byBlbmFibGUgc29tZSBmdW5jdGlvbmFsaXRpZXNcbiAgICAgIC8vIEFsc28gcmVtb3ZlIGFsbCBDQVJFVCBoYWNrcyB0aGF0IHNvbWVob3cgZ290IGxlZnRcbiAgICAgIHZhbHVlID0gd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKHZhbHVlKS5yZXBsYWNlKHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UpLmJ5KFwiXCIpO1xuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZShodG1sLCBwYXJzZSkge1xuICAgICAgaWYgKHBhcnNlKSB7XG4gICAgICAgIGh0bWwgPSB0aGlzLnBhcmVudC5wYXJzZShodG1sKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdGhpcy5pZnJhbWUuc3R5bGUuZGlzcGxheSA9IHRoaXMuX2Rpc3BsYXlTdHlsZSB8fCBcIlwiO1xuXG4gICAgICAvLyBGaXJlZm94IG5lZWRzIHRoaXMsIG90aGVyd2lzZSBjb250ZW50RWRpdGFibGUgYmVjb21lcyB1bmVkaXRhYmxlXG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB0aGlzLl9kaXNwbGF5U3R5bGUgPSBkb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20odGhpcy5pZnJhbWUpO1xuICAgICAgaWYgKHRoaXMuX2Rpc3BsYXlTdHlsZSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgdGhpcy5fZGlzcGxheVN0eWxlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9LFxuXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIik7XG4gICAgICB0aGlzLmJhc2UoKTtcbiAgICB9LFxuXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIsIFwidHJ1ZVwiKTtcbiAgICAgIHRoaXMuYmFzZSgpO1xuICAgIH0sXG5cbiAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoc2V0VG9FbmQpIHtcbiAgICAgIC8vIElFIDggZmlyZXMgdGhlIGZvY3VzIGV2ZW50IGFmdGVyIC5mb2N1cygpXG4gICAgICAvLyBUaGlzIGlzIG5lZWRlZCBieSBvdXIgc2ltdWxhdGVfcGxhY2Vob2xkZXIuanMgdG8gd29ya1xuICAgICAgLy8gdGhlcmVmb3JlIHdlIGNsZWFyIGl0IG91cnNlbHZlcyB0aGlzIHRpbWVcbiAgICAgIGlmICh3eXNpaHRtbDUuYnJvd3Nlci5kb2VzQXN5bmNGb2N1cygpICYmIHRoaXMuaGFzUGxhY2Vob2xkZXJTZXQoKSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYmFzZSgpO1xuXG4gICAgICB2YXIgbGFzdENoaWxkID0gdGhpcy5lbGVtZW50Lmxhc3RDaGlsZDtcbiAgICAgIGlmIChzZXRUb0VuZCAmJiBsYXN0Q2hpbGQpIHtcbiAgICAgICAgaWYgKGxhc3RDaGlsZC5ub2RlTmFtZSA9PT0gXCJCUlwiKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0QmVmb3JlKHRoaXMuZWxlbWVudC5sYXN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldEFmdGVyKHRoaXMuZWxlbWVudC5sYXN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldFRleHRDb250ZW50OiBmdW5jdGlvbiBnZXRUZXh0Q29udGVudCgpIHtcbiAgICAgIHJldHVybiBkb20uZ2V0VGV4dENvbnRlbnQodGhpcy5lbGVtZW50KTtcbiAgICB9LFxuXG4gICAgaGFzUGxhY2Vob2xkZXJTZXQ6IGZ1bmN0aW9uIGhhc1BsYWNlaG9sZGVyU2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dENvbnRlbnQoKSA9PSB0aGlzLnRleHRhcmVhLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIik7XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICB2YXIgaW5uZXJIVE1MID0gdGhpcy5lbGVtZW50LmlubmVySFRNTCxcbiAgICAgICAgICBlbGVtZW50c1dpdGhWaXN1YWxWYWx1ZSA9IFwiYmxvY2txdW90ZSwgdWwsIG9sLCBpbWcsIGVtYmVkLCBvYmplY3QsIHRhYmxlLCBpZnJhbWUsIHN2ZywgdmlkZW8sIGF1ZGlvLCBidXR0b24sIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhXCI7XG4gICAgICByZXR1cm4gaW5uZXJIVE1MID09PSBcIlwiIHx8IGlubmVySFRNTCA9PT0gdGhpcy5DQVJFVF9IQUNLIHx8IHRoaXMuaGFzUGxhY2Vob2xkZXJTZXQoKSB8fCB0aGlzLmdldFRleHRDb250ZW50KCkgPT09IFwiXCIgJiYgIXRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnRzV2l0aFZpc3VhbFZhbHVlKTtcbiAgICB9LFxuXG4gICAgX2luaXRTYW5kYm94OiBmdW5jdGlvbiBfaW5pdFNhbmRib3goKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuc2FuZGJveCA9IG5ldyBkb20uU2FuZGJveChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQuX2NyZWF0ZSgpO1xuICAgICAgfSwge1xuICAgICAgICBzdHlsZXNoZWV0czogdGhpcy5jb25maWcuc3R5bGVzaGVldHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5pZnJhbWUgPSB0aGlzLnNhbmRib3guZ2V0SWZyYW1lKCk7XG5cbiAgICAgIC8vIENyZWF0ZSBoaWRkZW4gZmllbGQgd2hpY2ggdGVsbHMgdGhlIHNlcnZlciBhZnRlciBzdWJtaXQsIHRoYXQgdGhlIHVzZXIgdXNlZCBhbiB3eXNpd3lnIGVkaXRvclxuICAgICAgdmFyIGhpZGRlbkZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgaGlkZGVuRmllbGQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgICBoaWRkZW5GaWVsZC5uYW1lID0gXCJfd3lzaWh0bWw1X21vZGVcIjtcbiAgICAgIGhpZGRlbkZpZWxkLnZhbHVlID0gMTtcblxuICAgICAgLy8gU3RvcmUgcmVmZXJlbmNlIHRvIGN1cnJlbnQgd3lzaWh0bWw1IGluc3RhbmNlIG9uIHRoZSB0ZXh0YXJlYSBlbGVtZW50XG4gICAgICB2YXIgdGV4dGFyZWFFbGVtZW50ID0gdGhpcy50ZXh0YXJlYS5lbGVtZW50O1xuICAgICAgZG9tLmluc2VydCh0aGlzLmlmcmFtZSkuYWZ0ZXIodGV4dGFyZWFFbGVtZW50KTtcbiAgICAgIGRvbS5pbnNlcnQoaGlkZGVuRmllbGQpLmFmdGVyKHRleHRhcmVhRWxlbWVudCk7XG4gICAgfSxcblxuICAgIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIHRoaXMuZG9jID0gdGhpcy5zYW5kYm94LmdldERvY3VtZW50KCk7XG4gICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmRvYy5ib2R5O1xuICAgICAgdGhpcy50ZXh0YXJlYSA9IHRoaXMucGFyZW50LnRleHRhcmVhO1xuICAgICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IHRoaXMudGV4dGFyZWEuZ2V0VmFsdWUodHJ1ZSk7XG4gICAgICB0aGlzLmVuYWJsZSgpO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgb3VyIHNlbGVjdGlvbiBoYW5kbGVyIGlzIHJlYWR5XG4gICAgICB0aGlzLnNlbGVjdGlvbiA9IG5ldyB3eXNpaHRtbDUuU2VsZWN0aW9uKHRoaXMucGFyZW50KTtcblxuICAgICAgLy8gTWFrZSBzdXJlIGNvbW1hbmRzIGRpc3BhdGNoZXIgaXMgcmVhZHlcbiAgICAgIHRoaXMuY29tbWFuZHMgPSBuZXcgd3lzaWh0bWw1LkNvbW1hbmRzKHRoaXMucGFyZW50KTtcblxuICAgICAgZG9tLmNvcHlBdHRyaWJ1dGVzKFtcImNsYXNzTmFtZVwiLCBcInNwZWxsY2hlY2tcIiwgXCJ0aXRsZVwiLCBcImxhbmdcIiwgXCJkaXJcIiwgXCJhY2Nlc3NLZXlcIl0pLmZyb20odGhpcy50ZXh0YXJlYS5lbGVtZW50KS50byh0aGlzLmVsZW1lbnQpO1xuXG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5lbGVtZW50LCB0aGlzLmNvbmZpZy5jb21wb3NlckNsYXNzTmFtZSk7XG5cbiAgICAgIC8vIE1ha2UgdGhlIGVkaXRvciBsb29rIGxpa2UgdGhlIG9yaWdpbmFsIHRleHRhcmVhLCBieSBzeW5jaW5nIHN0eWxlc1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnN0eWxlKSB7XG4gICAgICAgIHRoaXMuc3R5bGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vYnNlcnZlKCk7XG5cbiAgICAgIHZhciBuYW1lID0gdGhpcy5jb25maWcubmFtZTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmVsZW1lbnQsIG5hbWUpO1xuICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5pZnJhbWUsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW11bGF0ZSBodG1sNSBwbGFjZWhvbGRlciBhdHRyaWJ1dGUgb24gY29udGVudEVkaXRhYmxlIGVsZW1lbnRcbiAgICAgIHZhciBwbGFjZWhvbGRlclRleHQgPSB0eXBlb2YgdGhpcy5jb25maWcucGxhY2Vob2xkZXIgPT09IFwic3RyaW5nXCIgPyB0aGlzLmNvbmZpZy5wbGFjZWhvbGRlciA6IHRoaXMudGV4dGFyZWEuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKTtcbiAgICAgIGlmIChwbGFjZWhvbGRlclRleHQpIHtcbiAgICAgICAgZG9tLnNpbXVsYXRlUGxhY2Vob2xkZXIodGhpcy5wYXJlbnQsIHRoaXMsIHBsYWNlaG9sZGVyVGV4dCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBicm93c2VyIGF2b2lkcyB1c2luZyBpbmxpbmUgc3R5bGVzIHdoZW5ldmVyIHBvc3NpYmxlXG4gICAgICB0aGlzLmNvbW1hbmRzLmV4ZWMoXCJzdHlsZVdpdGhDU1NcIiwgZmFsc2UpO1xuXG4gICAgICB0aGlzLl9pbml0QXV0b0xpbmtpbmcoKTtcbiAgICAgIHRoaXMuX2luaXRPYmplY3RSZXNpemluZygpO1xuICAgICAgdGhpcy5faW5pdFVuZG9NYW5hZ2VyKCk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIGh0bWw1IGF1dG9mb2N1cyBvbiBjb250ZW50RWRpdGFibGUgZWxlbWVudFxuICAgICAgaWYgKHRoaXMudGV4dGFyZWEuZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJhdXRvZm9jdXNcIikgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIjpmb2N1c1wiKSA9PSB0aGlzLnRleHRhcmVhLmVsZW1lbnQpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhhdC5mb2N1cygpO1xuICAgICAgICB9LCAxMDApO1xuICAgICAgfVxuXG4gICAgICB3eXNpaHRtbDUucXVpcmtzLmluc2VydExpbmVCcmVha09uUmV0dXJuKHRoaXMpO1xuXG4gICAgICAvLyBJRSBzb21ldGltZXMgbGVhdmVzIGEgc2luZ2xlIHBhcmFncmFwaCwgd2hpY2ggY2FuJ3QgYmUgcmVtb3ZlZCBieSB0aGUgdXNlclxuICAgICAgaWYgKCFicm93c2VyLmNsZWFyc0NvbnRlbnRFZGl0YWJsZUNvcnJlY3RseSgpKSB7XG4gICAgICAgIHd5c2lodG1sNS5xdWlya3MuZW5zdXJlUHJvcGVyQ2xlYXJpbmcodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYnJvd3Nlci5jbGVhcnNMaXN0c0luQ29udGVudEVkaXRhYmxlQ29ycmVjdGx5KCkpIHtcbiAgICAgICAgd3lzaWh0bWw1LnF1aXJrcy5lbnN1cmVQcm9wZXJDbGVhcmluZ09mTGlzdHModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBhIHN5bmMgdGhhdCBtYWtlcyBzdXJlIHRoYXQgdGV4dGFyZWEgYW5kIGVkaXRvciBoYXZlIHRoZSBzYW1lIGNvbnRlbnRcbiAgICAgIGlmICh0aGlzLmluaXRTeW5jICYmIHRoaXMuY29uZmlnLnN5bmMpIHtcbiAgICAgICAgdGhpcy5pbml0U3luYygpO1xuICAgICAgfVxuXG4gICAgICAvLyBPa2F5IGhpZGUgdGhlIHRleHRhcmVhLCB3ZSBhcmUgcmVhZHkgdG8gZ29cbiAgICAgIHRoaXMudGV4dGFyZWEuaGlkZSgpO1xuXG4gICAgICAvLyBGaXJlIGdsb2JhbCAoYmVmb3JlLSlsb2FkIGV2ZW50XG4gICAgICB0aGlzLnBhcmVudC5maXJlKFwiYmVmb3JlbG9hZFwiKS5maXJlKFwibG9hZFwiKTtcbiAgICB9LFxuXG4gICAgX2luaXRBdXRvTGlua2luZzogZnVuY3Rpb24gX2luaXRBdXRvTGlua2luZygpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBzdXBwb3J0c0Rpc2FibGluZ09mQXV0b0xpbmtpbmcgPSBicm93c2VyLmNhbkRpc2FibGVBdXRvTGlua2luZygpLFxuICAgICAgICAgIHN1cHBvcnRzQXV0b0xpbmtpbmcgPSBicm93c2VyLmRvZXNBdXRvTGlua2luZ0luQ29udGVudEVkaXRhYmxlKCk7XG4gICAgICBpZiAoc3VwcG9ydHNEaXNhYmxpbmdPZkF1dG9MaW5raW5nKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMuZXhlYyhcImF1dG9VcmxEZXRlY3RcIiwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuY29uZmlnLmF1dG9MaW5rKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gT25seSBkbyB0aGUgYXV0byBsaW5raW5nIGJ5IG91cnNlbHZlcyB3aGVuIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBhdXRvIGxpbmtpbmdcbiAgICAgIC8vIE9SIHdoZW4gaGUgc3VwcG9ydHMgYXV0byBsaW5raW5nIGJ1dCB3ZSB3ZXJlIGFibGUgdG8gdHVybiBpdCBvZmYgKElFOSspXG4gICAgICBpZiAoIXN1cHBvcnRzQXV0b0xpbmtpbmcgfHwgc3VwcG9ydHNBdXRvTGlua2luZyAmJiBzdXBwb3J0c0Rpc2FibGluZ09mQXV0b0xpbmtpbmcpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQub2JzZXJ2ZShcIm5ld3dvcmQ6Y29tcG9zZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlKGZ1bmN0aW9uIChzdGFydENvbnRhaW5lciwgZW5kQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBkb20uYXV0b0xpbmsoZW5kQ29udGFpbmVyLnBhcmVudE5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQXNzdW1pbmcgd2UgaGF2ZSB0aGUgZm9sbG93aW5nOlxuICAgICAgLy8gIDxhIGhyZWY9XCJodHRwOi8vd3d3Lmdvb2dsZS5kZVwiPmh0dHA6Ly93d3cuZ29vZ2xlLmRlPC9hPlxuICAgICAgLy8gSWYgYSB1c2VyIG5vdyBjaGFuZ2VzIHRoZSB1cmwgaW4gdGhlIGlubmVySFRNTCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgICAvLyBpdCdzIHN5bmNocm9uaXplZCB3aXRoIHRoZSBocmVmIGF0dHJpYnV0ZSAoYXMgbG9uZyBhcyB0aGUgaW5uZXJIVE1MIGlzIHN0aWxsIGEgdXJsKVxuICAgICAgdmFyIC8vIFVzZSBhIGxpdmUgTm9kZUxpc3QgdG8gY2hlY2sgd2hldGhlciB0aGVyZSBhcmUgYW55IGxpbmtzIGluIHRoZSBkb2N1bWVudFxuICAgICAgbGlua3MgPSB0aGlzLnNhbmRib3guZ2V0RG9jdW1lbnQoKS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFcIiksXG5cbiAgICAgIC8vIFRoZSBhdXRvTGluayBoZWxwZXIgbWV0aG9kIHJldmVhbHMgYSByZWcgZXhwIHRvIGRldGVjdCBjb3JyZWN0IHVybHNcbiAgICAgIHVybFJlZ0V4cCA9IGRvbS5hdXRvTGluay5VUkxfUkVHX0VYUCxcbiAgICAgICAgICBnZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIGdldFRleHRDb250ZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHRleHRDb250ZW50ID0gd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKGRvbS5nZXRUZXh0Q29udGVudChlbGVtZW50KSkudHJpbSgpO1xuICAgICAgICBpZiAodGV4dENvbnRlbnQuc3Vic3RyKDAsIDQpID09PSBcInd3dy5cIikge1xuICAgICAgICAgIHRleHRDb250ZW50ID0gXCJodHRwOi8vXCIgKyB0ZXh0Q29udGVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gICAgICB9O1xuXG4gICAgICBkb20ub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZWN0ZWROb2RlID0gdGhhdC5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50KSxcbiAgICAgICAgICAgIGxpbmsgPSBkb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHsgbm9kZU5hbWU6IFwiQVwiIH0sIDQpLFxuICAgICAgICAgICAgdGV4dENvbnRlbnQ7XG5cbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dENvbnRlbnQgPSBnZXRUZXh0Q29udGVudChsaW5rKTtcbiAgICAgICAgLy8ga2V5ZG93biBpcyBmaXJlZCBiZWZvcmUgdGhlIGFjdHVhbCBjb250ZW50IGlzIGNoYW5nZWRcbiAgICAgICAgLy8gdGhlcmVmb3JlIHdlIHNldCBhIHRpbWVvdXQgdG8gY2hhbmdlIHRoZSBocmVmXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBuZXdUZXh0Q29udGVudCA9IGdldFRleHRDb250ZW50KGxpbmspO1xuICAgICAgICAgIGlmIChuZXdUZXh0Q29udGVudCA9PT0gdGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPbmx5IHNldCBocmVmIHdoZW4gbmV3IGhyZWYgbG9va3MgbGlrZSBhIHZhbGlkIHVybFxuICAgICAgICAgIGlmIChuZXdUZXh0Q29udGVudC5tYXRjaCh1cmxSZWdFeHApKSB7XG4gICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgbmV3VGV4dENvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2luaXRPYmplY3RSZXNpemluZzogZnVuY3Rpb24gX2luaXRPYmplY3RSZXNpemluZygpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gW1wid2lkdGhcIiwgXCJoZWlnaHRcIl0sXG4gICAgICAgICAgcHJvcGVydGllc0xlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoLFxuICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cbiAgICAgIHRoaXMuY29tbWFuZHMuZXhlYyhcImVuYWJsZU9iamVjdFJlc2l6aW5nXCIsIHRoaXMuY29uZmlnLmFsbG93T2JqZWN0UmVzaXppbmcpO1xuXG4gICAgICBpZiAodGhpcy5jb25maWcuYWxsb3dPYmplY3RSZXNpemluZykge1xuICAgICAgICAvLyBJRSBzZXRzIGlubGluZSBzdHlsZXMgYWZ0ZXIgcmVzaXppbmcgb2JqZWN0c1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGxpbmVzIG1ha2Ugc3VyZSB0aGF0IHRoZSB3aWR0aC9oZWlnaHQgY3NzIHByb3BlcnRpZXNcbiAgICAgICAgLy8gYXJlIGNvcGllZCBvdmVyIHRvIHRoZSB3aWR0aC9oZWlnaHQgYXR0cmlidXRlc1xuICAgICAgICBpZiAoYnJvd3Nlci5zdXBwb3J0c0V2ZW50KFwicmVzaXplZW5kXCIpKSB7XG4gICAgICAgICAgZG9tLm9ic2VydmUoZWxlbWVudCwgXCJyZXNpemVlbmRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHByb3BlcnRpZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgIGlmIChzdHlsZVtwcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKHByb3BlcnR5LCBwYXJzZUludChzdHlsZVtwcm9wZXJ0eV0sIDEwKSk7XG4gICAgICAgICAgICAgICAgc3R5bGVbcHJvcGVydHldID0gXCJcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWZ0ZXIgcmVzaXppbmcgSUUgc29tZXRpbWVzIGZvcmdldHMgdG8gcmVtb3ZlIHRoZSBvbGQgcmVzaXplIGhhbmRsZXNcbiAgICAgICAgICAgIHd5c2lodG1sNS5xdWlya3MucmVkcmF3KGVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYnJvd3Nlci5zdXBwb3J0c0V2ZW50KFwicmVzaXplc3RhcnRcIikpIHtcbiAgICAgICAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBcInJlc2l6ZXN0YXJ0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfaW5pdFVuZG9NYW5hZ2VyOiBmdW5jdGlvbiBfaW5pdFVuZG9NYW5hZ2VyKCkge1xuICAgICAgbmV3IHd5c2lodG1sNS5VbmRvTWFuYWdlcih0aGlzLnBhcmVudCk7XG4gICAgfVxuICB9KTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIGRvbSA9IHd5c2lodG1sNS5kb20sXG4gICAgICBkb2MgPSBkb2N1bWVudCxcbiAgICAgIHdpbiA9IHdpbmRvdyxcbiAgICAgIEhPU1RfVEVNUExBVEUgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblxuICAvKipcbiAgICogU3R5bGVzIHRvIGNvcHkgZnJvbSB0ZXh0YXJlYSB0byB0aGUgY29tcG9zZXIgZWxlbWVudFxuICAgKi9cbiAgVEVYVF9GT1JNQVRUSU5HID0gW1wiYmFja2dyb3VuZC1jb2xvclwiLCBcImNvbG9yXCIsIFwiY3Vyc29yXCIsIFwiZm9udC1mYW1pbHlcIiwgXCJmb250LXNpemVcIiwgXCJmb250LXN0eWxlXCIsIFwiZm9udC12YXJpYW50XCIsIFwiZm9udC13ZWlnaHRcIiwgXCJsaW5lLWhlaWdodFwiLCBcImxldHRlci1zcGFjaW5nXCIsIFwidGV4dC1hbGlnblwiLCBcInRleHQtZGVjb3JhdGlvblwiLCBcInRleHQtaW5kZW50XCIsIFwidGV4dC1yZW5kZXJpbmdcIiwgXCJ3b3JkLWJyZWFrXCIsIFwid29yZC13cmFwXCIsIFwid29yZC1zcGFjaW5nXCJdLFxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdG8gY29weSBmcm9tIHRleHRhcmVhIHRvIHRoZSBpZnJhbWVcbiAgICovXG4gIEJPWF9GT1JNQVRUSU5HID0gW1wiYmFja2dyb3VuZC1jb2xvclwiLCBcImJvcmRlci1jb2xsYXBzZVwiLCBcImJvcmRlci1ib3R0b20tY29sb3JcIiwgXCJib3JkZXItYm90dG9tLXN0eWxlXCIsIFwiYm9yZGVyLWJvdHRvbS13aWR0aFwiLCBcImJvcmRlci1sZWZ0LWNvbG9yXCIsIFwiYm9yZGVyLWxlZnQtc3R5bGVcIiwgXCJib3JkZXItbGVmdC13aWR0aFwiLCBcImJvcmRlci1yaWdodC1jb2xvclwiLCBcImJvcmRlci1yaWdodC1zdHlsZVwiLCBcImJvcmRlci1yaWdodC13aWR0aFwiLCBcImJvcmRlci10b3AtY29sb3JcIiwgXCJib3JkZXItdG9wLXN0eWxlXCIsIFwiYm9yZGVyLXRvcC13aWR0aFwiLCBcImNsZWFyXCIsIFwiZGlzcGxheVwiLCBcImZsb2F0XCIsIFwibWFyZ2luLWJvdHRvbVwiLCBcIm1hcmdpbi1sZWZ0XCIsIFwibWFyZ2luLXJpZ2h0XCIsIFwibWFyZ2luLXRvcFwiLCBcIm91dGxpbmUtY29sb3JcIiwgXCJvdXRsaW5lLW9mZnNldFwiLCBcIm91dGxpbmUtd2lkdGhcIiwgXCJvdXRsaW5lLXN0eWxlXCIsIFwicGFkZGluZy1sZWZ0XCIsIFwicGFkZGluZy1yaWdodFwiLCBcInBhZGRpbmctdG9wXCIsIFwicGFkZGluZy1ib3R0b21cIiwgXCJwb3NpdGlvblwiLCBcInRvcFwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcInotaW5kZXhcIiwgXCJ2ZXJ0aWNhbC1hbGlnblwiLCBcInRleHQtYWxpZ25cIiwgXCItd2Via2l0LWJveC1zaXppbmdcIiwgXCItbW96LWJveC1zaXppbmdcIiwgXCItbXMtYm94LXNpemluZ1wiLCBcImJveC1zaXppbmdcIiwgXCItd2Via2l0LWJveC1zaGFkb3dcIiwgXCItbW96LWJveC1zaGFkb3dcIiwgXCItbXMtYm94LXNoYWRvd1wiLCBcImJveC1zaGFkb3dcIiwgXCItd2Via2l0LWJvcmRlci10b3AtcmlnaHQtcmFkaXVzXCIsIFwiLW1vei1ib3JkZXItcmFkaXVzLXRvcHJpZ2h0XCIsIFwiYm9yZGVyLXRvcC1yaWdodC1yYWRpdXNcIiwgXCItd2Via2l0LWJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzXCIsIFwiLW1vei1ib3JkZXItcmFkaXVzLWJvdHRvbXJpZ2h0XCIsIFwiYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXNcIiwgXCItd2Via2l0LWJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIiwgXCItbW96LWJvcmRlci1yYWRpdXMtYm90dG9tbGVmdFwiLCBcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIiwgXCItd2Via2l0LWJvcmRlci10b3AtbGVmdC1yYWRpdXNcIiwgXCItbW96LWJvcmRlci1yYWRpdXMtdG9wbGVmdFwiLCBcImJvcmRlci10b3AtbGVmdC1yYWRpdXNcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXSxcblxuICAvKipcbiAgICogU3R5bGVzIHRvIHN5bmMgd2hpbGUgdGhlIHdpbmRvdyBnZXRzIHJlc2l6ZWRcbiAgICovXG4gIFJFU0laRV9TVFlMRSA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwidG9wXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCJdLFxuICAgICAgQURESVRJT05BTF9DU1NfUlVMRVMgPSBbXCJodG1sICAgICAgICAgICAgIHsgaGVpZ2h0OiAxMDAlOyB9XCIsIFwiYm9keSAgICAgICAgICAgICB7IG1pbi1oZWlnaHQ6IDEwMCU7IHBhZGRpbmc6IDA7IG1hcmdpbjogMDsgbWFyZ2luLXRvcDogLTFweDsgcGFkZGluZy10b3A6IDFweDsgd2hpdGUtc3BhY2U6IHByZS13cmFwOyB9XCIsIFwiLl93eXNpaHRtbDUtdGVtcCB7IGRpc3BsYXk6IG5vbmU7IH1cIiwgd3lzaWh0bWw1LmJyb3dzZXIuaXNHZWNrbyA/IFwiYm9keS5wbGFjZWhvbGRlciB7IGNvbG9yOiBncmF5dGV4dCAhaW1wb3J0YW50OyB9XCIgOiBcImJvZHkucGxhY2Vob2xkZXIgeyBjb2xvcjogI2E5YTlhOSAhaW1wb3J0YW50OyB9XCIsIFwiYm9keVtkaXNhYmxlZF0gICB7IGJhY2tncm91bmQtY29sb3I6ICNlZWUgIWltcG9ydGFudDsgY29sb3I6ICM5OTkgIWltcG9ydGFudDsgY3Vyc29yOiBkZWZhdWx0ICFpbXBvcnRhbnQ7IH1cIixcbiAgLy8gRW5zdXJlIHRoYXQgdXNlciBzZWUncyBicm9rZW4gaW1hZ2VzIGFuZCBjYW4gZGVsZXRlIHRoZW1cbiAgXCJpbWc6LW1vei1icm9rZW4gIHsgLW1vei1mb3JjZS1icm9rZW4taW1hZ2UtaWNvbjogMTsgaGVpZ2h0OiAyNHB4OyB3aWR0aDogMjRweDsgfVwiXTtcblxuICAvKipcbiAgICogV2l0aCBcInNldEFjdGl2ZVwiIElFIG9mZmVycyBhIHNtYXJ0IHdheSBvZiBmb2N1c2luZyBlbGVtZW50cyB3aXRob3V0IHNjcm9sbGluZyB0aGVtIGludG8gdmlldzpcbiAgICogaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NzM4KHY9dnMuODUpLmFzcHhcbiAgICpcbiAgICogT3RoZXIgYnJvd3NlcnMgbmVlZCBhIG1vcmUgaGFja3kgd2F5OiAocHNzc3QgZG9uJ3QgdGVsbCBteSBtYW1hKVxuICAgKiBJbiBvcmRlciB0byBwcmV2ZW50IHRoZSBlbGVtZW50IGJlaW5nIHNjcm9sbGVkIGludG8gdmlldyB3aGVuIGZvY3VzaW5nIGl0LCB3ZSBzaW1wbHlcbiAgICogbW92ZSBpdCBvdXQgb2YgdGhlIHNjcm9sbGFibGUgYXJlYSwgZm9jdXMgaXQsIGFuZCByZXNldCBpdCdzIHBvc2l0aW9uXG4gICAqL1xuICB2YXIgZm9jdXNXaXRob3V0U2Nyb2xsaW5nID0gZnVuY3Rpb24gZm9jdXNXaXRob3V0U2Nyb2xsaW5nKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5zZXRBY3RpdmUpIHtcbiAgICAgIC8vIEZvbGxvd2luZyBsaW5lIGNvdWxkIGNhdXNlIGEganMgZXJyb3Igd2hlbiB0aGUgdGV4dGFyZWEgaXMgaW52aXNpYmxlXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3hpbmcvd3lzaWh0bWw1L2lzc3Vlcy85XG4gICAgICB0cnkge1xuICAgICAgICBlbGVtZW50LnNldEFjdGl2ZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVsZW1lbnRTdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG4gICAgICAgICAgb3JpZ2luYWxTY3JvbGxUb3AgPSBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2MuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgICAgb3JpZ2luYWxTY3JvbGxMZWZ0ID0gZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvYy5ib2R5LnNjcm9sbExlZnQsXG4gICAgICAgICAgb3JpZ2luYWxTdHlsZXMgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBlbGVtZW50U3R5bGUucG9zaXRpb24sXG4gICAgICAgIHRvcDogZWxlbWVudFN0eWxlLnRvcCxcbiAgICAgICAgbGVmdDogZWxlbWVudFN0eWxlLmxlZnQsXG4gICAgICAgIFdlYmtpdFVzZXJTZWxlY3Q6IGVsZW1lbnRTdHlsZS5XZWJraXRVc2VyU2VsZWN0XG4gICAgICB9O1xuXG4gICAgICBkb20uc2V0U3R5bGVzKHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgdG9wOiBcIi05OTk5OXB4XCIsXG4gICAgICAgIGxlZnQ6IFwiLTk5OTk5cHhcIixcbiAgICAgICAgLy8gRG9uJ3QgYXNrIHdoeSBidXQgdGVtcG9yYXJpbHkgc2V0dGluZyAtd2Via2l0LXVzZXItc2VsZWN0IHRvIG5vbmUgbWFrZXMgdGhlIHdob2xlIHRoaW5nIHBlcmZvcm1pbmcgc21vb3RoZXJcbiAgICAgICAgV2Via2l0VXNlclNlbGVjdDogXCJub25lXCJcbiAgICAgIH0pLm9uKGVsZW1lbnQpO1xuXG4gICAgICBlbGVtZW50LmZvY3VzKCk7XG5cbiAgICAgIGRvbS5zZXRTdHlsZXMob3JpZ2luYWxTdHlsZXMpLm9uKGVsZW1lbnQpO1xuXG4gICAgICBpZiAod2luLnNjcm9sbFRvKSB7XG4gICAgICAgIC8vIFNvbWUgYnJvd3NlciBleHRlbnNpb25zIHVuc2V0IHRoaXMgbWV0aG9kIHRvIHByZXZlbnQgYW5ub3lhbmNlc1xuICAgICAgICAvLyBcIkJldHRlciBQb3BVcCBCbG9ja2VyXCIgZm9yIENocm9tZSBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYmV0dGVycG9wdXBibG9ja2VyL3NvdXJjZS9icm93c2UvdHJ1bmsvYmxvY2tTdGFydC5qcyMxMDBcbiAgICAgICAgLy8gSXNzdWU6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9iZXR0ZXJwb3B1cGJsb2NrZXIvaXNzdWVzL2RldGFpbD9pZD0xXG4gICAgICAgIHdpbi5zY3JvbGxUbyhvcmlnaW5hbFNjcm9sbExlZnQsIG9yaWdpbmFsU2Nyb2xsVG9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd3lzaWh0bWw1LnZpZXdzLkNvbXBvc2VyLnByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIG9yaWdpbmFsQWN0aXZlRWxlbWVudCA9IGRvYy5xdWVyeVNlbGVjdG9yKFwiOmZvY3VzXCIpLFxuICAgICAgICB0ZXh0YXJlYUVsZW1lbnQgPSB0aGlzLnRleHRhcmVhLmVsZW1lbnQsXG4gICAgICAgIGhhc1BsYWNlaG9sZGVyID0gdGV4dGFyZWFFbGVtZW50Lmhhc0F0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpLFxuICAgICAgICBvcmlnaW5hbFBsYWNlaG9sZGVyID0gaGFzUGxhY2Vob2xkZXIgJiYgdGV4dGFyZWFFbGVtZW50LmdldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpO1xuICAgIHRoaXMuZm9jdXNTdHlsZXNIb3N0ID0gdGhpcy5mb2N1c1N0eWxlc0hvc3QgfHwgSE9TVF9URU1QTEFURS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgIHRoaXMuYmx1clN0eWxlc0hvc3QgPSB0aGlzLmJsdXJTdHlsZXNIb3N0IHx8IEhPU1RfVEVNUExBVEUuY2xvbmVOb2RlKGZhbHNlKTtcblxuICAgIC8vIFJlbW92ZSBwbGFjZWhvbGRlciBiZWZvcmUgY29weWluZyAoYXMgdGhlIHBsYWNlaG9sZGVyIGhhcyBhbiBhZmZlY3Qgb24gdGhlIGNvbXB1dGVkIHN0eWxlKVxuICAgIGlmIChoYXNQbGFjZWhvbGRlcikge1xuICAgICAgdGV4dGFyZWFFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpO1xuICAgIH1cblxuICAgIGlmICh0ZXh0YXJlYUVsZW1lbnQgPT09IG9yaWdpbmFsQWN0aXZlRWxlbWVudCkge1xuICAgICAgdGV4dGFyZWFFbGVtZW50LmJsdXIoKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0gaWZyYW1lIHN0eWxlcyAoaGFzIHRvIGJlIHNldCBiZWZvcmUgZWRpdG9yIHN0eWxlcywgb3RoZXJ3aXNlIElFOSBzZXRzIHdyb25nIGZvbnRGYW1pbHkgb24gYmx1clN0eWxlc0hvc3QpIC0tLS0tLS0tLVxuICAgIGRvbS5jb3B5U3R5bGVzKEJPWF9GT1JNQVRUSU5HKS5mcm9tKHRleHRhcmVhRWxlbWVudCkudG8odGhpcy5pZnJhbWUpLmFuZFRvKHRoaXMuYmx1clN0eWxlc0hvc3QpO1xuXG4gICAgLy8gLS0tLS0tLS0tIGVkaXRvciBzdHlsZXMgLS0tLS0tLS0tXG4gICAgZG9tLmNvcHlTdHlsZXMoVEVYVF9GT1JNQVRUSU5HKS5mcm9tKHRleHRhcmVhRWxlbWVudCkudG8odGhpcy5lbGVtZW50KS5hbmRUbyh0aGlzLmJsdXJTdHlsZXNIb3N0KTtcblxuICAgIC8vIC0tLS0tLS0tLSBhcHBseSBzdGFuZGFyZCBydWxlcyAtLS0tLS0tLS1cbiAgICBkb20uaW5zZXJ0Q1NTKEFERElUSU9OQUxfQ1NTX1JVTEVTKS5pbnRvKHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50KTtcblxuICAgIC8vIC0tLS0tLS0tLSA6Zm9jdXMgc3R5bGVzIC0tLS0tLS0tLVxuICAgIGZvY3VzV2l0aG91dFNjcm9sbGluZyh0ZXh0YXJlYUVsZW1lbnQpO1xuICAgIGRvbS5jb3B5U3R5bGVzKEJPWF9GT1JNQVRUSU5HKS5mcm9tKHRleHRhcmVhRWxlbWVudCkudG8odGhpcy5mb2N1c1N0eWxlc0hvc3QpO1xuICAgIGRvbS5jb3B5U3R5bGVzKFRFWFRfRk9STUFUVElORykuZnJvbSh0ZXh0YXJlYUVsZW1lbnQpLnRvKHRoaXMuZm9jdXNTdHlsZXNIb3N0KTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IGNoYW5nZSB0aGUgZGlzcGxheSBzdHlsZSBvZiB0aGUgaWZyYW1lIHdoZW4gY29weWluZyBzdHlsZXMgb2JsdXIvb25mb2N1c1xuICAgIC8vIHRoaXMgaXMgbmVlZGVkIGZvciB3aGVuIHRoZSBjaGFuZ2VfdmlldyBldmVudCBpcyBmaXJlZCB3aGVyZSB0aGUgaWZyYW1lIGlzIGhpZGRlbiBhbmQgdGhlblxuICAgIC8vIHRoZSBibHVyIGV2ZW50IGZpcmVzIGFuZCByZS1kaXNwbGF5cyBpdFxuICAgIHZhciBib3hGb3JtYXR0aW5nU3R5bGVzID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoQk9YX0ZPUk1BVFRJTkcpLndpdGhvdXQoW1wiZGlzcGxheVwiXSk7XG5cbiAgICAvLyAtLS0tLS0tLS0gcmVzdG9yZSBmb2N1cyAtLS0tLS0tLS1cbiAgICBpZiAob3JpZ2luYWxBY3RpdmVFbGVtZW50KSB7XG4gICAgICBvcmlnaW5hbEFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dGFyZWFFbGVtZW50LmJsdXIoKTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0gcmVzdG9yZSBwbGFjZWhvbGRlciAtLS0tLS0tLS1cbiAgICBpZiAoaGFzUGxhY2Vob2xkZXIpIHtcbiAgICAgIHRleHRhcmVhRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiLCBvcmlnaW5hbFBsYWNlaG9sZGVyKTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGNvcHlpbmcgc3R5bGVzLCB3ZSBvbmx5IGdldCB0aGUgY29tcHV0ZWQgc3R5bGUgd2hpY2ggaXMgbmV2ZXIgcmV0dXJuZWQgaW4gcGVyY2VudCB1bml0XG4gICAgLy8gVGhlcmVmb3JlIHdlJ3ZlIHRvIHJlY2FsY3VsYXRlIHN0eWxlIG9ucmVzaXplXG4gICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5oYXNDdXJyZW50U3R5bGVQcm9wZXJ0eSgpKSB7XG4gICAgICB2YXIgd2luT2JzZXJ2ZXIgPSBkb20ub2JzZXJ2ZSh3aW4sIFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGlmIGNvbXBvc2VyIGRvZXNuJ3QgZXhpc3QgYW55bW9yZVxuICAgICAgICBpZiAoIWRvbS5jb250YWlucyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoYXQuaWZyYW1lKSkge1xuICAgICAgICAgIHdpbk9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9yaWdpbmFsVGV4dGFyZWFEaXNwbGF5U3R5bGUgPSBkb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20odGV4dGFyZWFFbGVtZW50KSxcbiAgICAgICAgICAgIG9yaWdpbmFsQ29tcG9zZXJEaXNwbGF5U3R5bGUgPSBkb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20odGhhdC5pZnJhbWUpO1xuICAgICAgICB0ZXh0YXJlYUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgIHRoYXQuaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgZG9tLmNvcHlTdHlsZXMoUkVTSVpFX1NUWUxFKS5mcm9tKHRleHRhcmVhRWxlbWVudCkudG8odGhhdC5pZnJhbWUpLmFuZFRvKHRoYXQuZm9jdXNTdHlsZXNIb3N0KS5hbmRUbyh0aGF0LmJsdXJTdHlsZXNIb3N0KTtcbiAgICAgICAgdGhhdC5pZnJhbWUuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsQ29tcG9zZXJEaXNwbGF5U3R5bGU7XG4gICAgICAgIHRleHRhcmVhRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxUZXh0YXJlYURpc3BsYXlTdHlsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLSBTeW5jIGZvY3VzL2JsdXIgc3R5bGVzIC0tLS0tLS0tLVxuICAgIHRoaXMucGFyZW50Lm9ic2VydmUoXCJmb2N1czpjb21wb3NlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uY29weVN0eWxlcyhib3hGb3JtYXR0aW5nU3R5bGVzKS5mcm9tKHRoYXQuZm9jdXNTdHlsZXNIb3N0KS50byh0aGF0LmlmcmFtZSk7XG4gICAgICBkb20uY29weVN0eWxlcyhURVhUX0ZPUk1BVFRJTkcpLmZyb20odGhhdC5mb2N1c1N0eWxlc0hvc3QpLnRvKHRoYXQuZWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnBhcmVudC5vYnNlcnZlKFwiYmx1cjpjb21wb3NlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBkb20uY29weVN0eWxlcyhib3hGb3JtYXR0aW5nU3R5bGVzKS5mcm9tKHRoYXQuYmx1clN0eWxlc0hvc3QpLnRvKHRoYXQuaWZyYW1lKTtcbiAgICAgIGRvbS5jb3B5U3R5bGVzKFRFWFRfRk9STUFUVElORykuZnJvbSh0aGF0LmJsdXJTdHlsZXNIb3N0KS50byh0aGF0LmVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59KSh3eXNpaHRtbDUpOyAvKipcbiAgICAgICAgICAgICAgICogVGFraW5nIGNhcmUgb2YgZXZlbnRzXG4gICAgICAgICAgICAgICAqICAtIFNpbXVsYXRpbmcgJ2NoYW5nZScgZXZlbnQgb24gY29udGVudEVkaXRhYmxlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICogIC0gSGFuZGxpbmcgZHJhZyAmIGRyb3AgbG9naWNcbiAgICAgICAgICAgICAgICogIC0gQ2F0Y2ggcGFzdGUgZXZlbnRzXG4gICAgICAgICAgICAgICAqICAtIERpc3BhdGNoIHByb3ByaWV0YXJ5IG5ld3dvcmQ6Y29tcG9zZXIgZXZlbnRcbiAgICAgICAgICAgICAgICogIC0gS2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICAgICAgICAgICAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIGRvbSA9IHd5c2lodG1sNS5kb20sXG4gICAgICBicm93c2VyID0gd3lzaWh0bWw1LmJyb3dzZXIsXG5cbiAgLyoqXG4gICAqIE1hcCBrZXlDb2RlcyB0byBxdWVyeSBjb21tYW5kc1xuICAgKi9cbiAgc2hvcnRjdXRzID0ge1xuICAgIFwiNjZcIjogXCJib2xkXCIsIC8vIEJcbiAgICBcIjczXCI6IFwiaXRhbGljXCIsIC8vIElcbiAgICBcIjg1XCI6IFwidW5kZXJsaW5lXCIgLy8gVVxuICB9O1xuXG4gIHd5c2lodG1sNS52aWV3cy5Db21wb3Nlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIHN0YXRlID0gdGhpcy5nZXRWYWx1ZSgpLFxuICAgICAgICBpZnJhbWUgPSB0aGlzLnNhbmRib3guZ2V0SWZyYW1lKCksXG4gICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsXG4gICAgICAgIGZvY3VzQmx1ckVsZW1lbnQgPSBicm93c2VyLnN1cHBvcnRzRXZlbnRzSW5JZnJhbWVDb3JyZWN0bHkoKSA/IGVsZW1lbnQgOiB0aGlzLnNhbmRib3guZ2V0V2luZG93KCksXG5cbiAgICAvLyBGaXJlZm94IDwgMy41IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZHJvcCBldmVudCwgaW5zdGVhZCBpdCBzdXBwb3J0cyBhIHNvIGNhbGxlZCBcImRyYWdkcm9wXCIgZXZlbnQgd2hpY2ggYmVoYXZlcyBhbG1vc3QgdGhlIHNhbWVcbiAgICBwYXN0ZUV2ZW50cyA9IGJyb3dzZXIuc3VwcG9ydHNFdmVudChcImRyb3BcIikgPyBbXCJkcm9wXCIsIFwicGFzdGVcIl0gOiBbXCJkcmFnZHJvcFwiLCBcInBhc3RlXCJdO1xuXG4gICAgLy8gLS0tLS0tLS0tIGRlc3Ryb3k6Y29tcG9zZXIgZXZlbnQgLS0tLS0tLS0tXG4gICAgZG9tLm9ic2VydmUoaWZyYW1lLCBcIkRPTU5vZGVSZW1vdmVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoZG9tTm9kZVJlbW92ZWRJbnRlcnZhbCk7XG4gICAgICB0aGF0LnBhcmVudC5maXJlKFwiZGVzdHJveTpjb21wb3NlclwiKTtcbiAgICB9KTtcblxuICAgIC8vIERPTU5vZGVSZW1vdmVkIGV2ZW50IGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUUgOFxuICAgIHZhciBkb21Ob2RlUmVtb3ZlZEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFkb20uY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBpZnJhbWUpKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoZG9tTm9kZVJlbW92ZWRJbnRlcnZhbCk7XG4gICAgICAgIHRoYXQucGFyZW50LmZpcmUoXCJkZXN0cm95OmNvbXBvc2VyXCIpO1xuICAgICAgfVxuICAgIH0sIDI1MCk7XG5cbiAgICAvLyAtLS0tLS0tLS0gRm9jdXMgJiBibHVyIGxvZ2ljIC0tLS0tLS0tLVxuICAgIGRvbS5vYnNlcnZlKGZvY3VzQmx1ckVsZW1lbnQsIFwiZm9jdXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC5wYXJlbnQuZmlyZShcImZvY3VzXCIpLmZpcmUoXCJmb2N1czpjb21wb3NlclwiKTtcblxuICAgICAgLy8gRGVsYXkgc3RvcmluZyBvZiBzdGF0ZSB1bnRpbCBhbGwgZm9jdXMgaGFuZGxlciBhcmUgZmlyZWRcbiAgICAgIC8vIGVzcGVjaWFsbHkgdGhlIG9uZSB3aGljaCByZXNldHMgdGhlIHBsYWNlaG9sZGVyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RhdGUgPSB0aGF0LmdldFZhbHVlKCk7XG4gICAgICB9LCAwKTtcbiAgICB9KTtcblxuICAgIGRvbS5vYnNlcnZlKGZvY3VzQmx1ckVsZW1lbnQsIFwiYmx1clwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc3RhdGUgIT09IHRoYXQuZ2V0VmFsdWUoKSkge1xuICAgICAgICB0aGF0LnBhcmVudC5maXJlKFwiY2hhbmdlXCIpLmZpcmUoXCJjaGFuZ2U6Y29tcG9zZXJcIik7XG4gICAgICB9XG4gICAgICB0aGF0LnBhcmVudC5maXJlKFwiYmx1clwiKS5maXJlKFwiYmx1cjpjb21wb3NlclwiKTtcbiAgICB9KTtcblxuICAgIGlmICh3eXNpaHRtbDUuYnJvd3Nlci5pc0lvcygpKSB7XG4gICAgICAvLyBXaGVuIG9uIGlQYWQvaVBob25lL0lQb2QgYWZ0ZXIgY2xpY2tpbmcgb3V0c2lkZSBvZiBlZGl0b3IsIHRoZSBlZGl0b3IgbG9zZXMgZm9jdXNcbiAgICAgIC8vIGJ1dCB0aGUgVUkgc3RpbGwgYWN0cyBhcyBpZiB0aGUgZWRpdG9yIGhhcyBmb2N1cyAoYmxpbmtpbmcgY2FyZXQgYW5kIG9uc2NyZWVuIGtleWJvYXJkIHZpc2libGUpXG4gICAgICAvLyBXZSBwcmV2ZW50IHRoYXQgYnkgZm9jdXNpbmcgYSB0ZW1wb3JhcnkgaW5wdXQgZWxlbWVudCB3aGljaCBpbW1lZGlhdGVseSBsb3NlcyBmb2N1c1xuICAgICAgZG9tLm9ic2VydmUoZWxlbWVudCwgXCJibHVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxcbiAgICAgICAgICAgIG9yaWdpbmFsU2Nyb2xsVG9wID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICAgIG9yaWdpbmFsU2Nyb2xsTGVmdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGF0LnNlbGVjdGlvbi5pbnNlcnROb2RlKGlucHV0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgIGlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW5wdXQpO1xuXG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyhvcmlnaW5hbFNjcm9sbExlZnQsIG9yaWdpbmFsU2Nyb2xsVG9wKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLSBEcmFnICYgRHJvcCBsb2dpYyAtLS0tLS0tLS1cbiAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBcImRyYWdlbnRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LnBhcmVudC5maXJlKFwidW5zZXRfcGxhY2Vob2xkZXJcIik7XG4gICAgfSk7XG5cbiAgICBpZiAoYnJvd3Nlci5maXJlc09uRHJvcE9ubHlXaGVuT25EcmFnT3ZlcklzQ2FuY2VsbGVkKCkpIHtcbiAgICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFtcImRyYWdvdmVyXCIsIFwiZHJhZ2VudGVyXCJdLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIHBhc3RlRXZlbnRzLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBldmVudC5kYXRhVHJhbnNmZXIsXG4gICAgICAgICAgZGF0YTtcblxuICAgICAgaWYgKGRhdGFUcmFuc2ZlciAmJiBicm93c2VyLnN1cHBvcnRzRGF0YVRyYW5zZmVyKCkpIHtcbiAgICAgICAgZGF0YSA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dC9odG1sXCIpIHx8IGRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dC9wbGFpblwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgdGhhdC5jb21tYW5kcy5leGVjKFwiaW5zZXJ0SFRNTFwiLCBkYXRhKTtcbiAgICAgICAgdGhhdC5wYXJlbnQuZmlyZShcInBhc3RlXCIpLmZpcmUoXCJwYXN0ZTpjb21wb3NlclwiKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LnBhcmVudC5maXJlKFwicGFzdGVcIikuZmlyZShcInBhc3RlOmNvbXBvc2VyXCIpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIC0tLS0tLS0tLSBuZXdvcmQgZXZlbnQgLS0tLS0tKy0tLVxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwia2V5dXBcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICBpZiAoa2V5Q29kZSA9PT0gd3lzaWh0bWw1LkVOVEVSX0tFWSkge1xuICAgICAgICB0aGF0LnBhcmVudC5maXJlKFwibmV3d29yZDpjb21wb3NlclwiKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucGFyZW50Lm9ic2VydmUoXCJwYXN0ZTpjb21wb3NlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC5wYXJlbnQuZmlyZShcIm5ld3dvcmQ6Y29tcG9zZXJcIik7XG4gICAgICB9LCAwKTtcbiAgICB9KTtcblxuICAgIC8vIC0tLS0tLS0tLSBNYWtlIHN1cmUgdGhhdCBpbWFnZXMgYXJlIHNlbGVjdGVkIHdoZW4gY2xpY2tpbmcgb24gdGhlbSAtLS0tLS0tLS1cbiAgICBpZiAoIWJyb3dzZXIuY2FuU2VsZWN0SW1hZ2VzSW5Db250ZW50RWRpdGFibGUoKSkge1xuICAgICAgZG9tLm9ic2VydmUoZWxlbWVudCwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09IFwiSU1HXCIpIHtcbiAgICAgICAgICB0aGF0LnNlbGVjdGlvbi5zZWxlY3ROb2RlKHRhcmdldCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tIFNob3J0Y3V0IGxvZ2ljIC0tLS0tLS0tLVxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZSxcbiAgICAgICAgICBjb21tYW5kID0gc2hvcnRjdXRzW2tleUNvZGVdO1xuICAgICAgaWYgKChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpICYmICFldmVudC5hbHRLZXkgJiYgY29tbWFuZCkge1xuICAgICAgICB0aGF0LmNvbW1hbmRzLmV4ZWMoY29tbWFuZCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyAtLS0tLS0tLS0gTWFrZSBzdXJlIHRoYXQgd2hlbiBwcmVzc2luZyBiYWNrc3BhY2UvZGVsZXRlIG9uIHNlbGVjdGVkIGltYWdlcyBkZWxldGVzIHRoZSBpbWFnZSBhbmQgaXQncyBhbmNob3IgLS0tLS0tLS0tXG4gICAgZG9tLm9ic2VydmUoZWxlbWVudCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoYXQuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSh0cnVlKSxcbiAgICAgICAgICBrZXlDb2RlID0gZXZlbnQua2V5Q29kZSxcbiAgICAgICAgICBwYXJlbnQ7XG4gICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5ub2RlTmFtZSA9PT0gXCJJTUdcIiAmJiAoa2V5Q29kZSA9PT0gd3lzaWh0bWw1LkJBQ0tTUEFDRV9LRVkgfHwga2V5Q29kZSA9PT0gd3lzaWh0bWw1LkRFTEVURV9LRVkpKSB7XG4gICAgICAgIC8vIDggPT4gYmFja3NwYWNlLCA0NiA9PiBkZWxldGVcbiAgICAgICAgcGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgIC8vIGRlbGV0ZSB0aGUgPGltZz5cbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgICAgIC8vIGFuZCBpdCdzIHBhcmVudCA8YT4gdG9vIGlmIGl0IGhhc24ndCBnb3QgYW55IG90aGVyIGNoaWxkIG5vZGVzXG4gICAgICAgIGlmIChwYXJlbnQubm9kZU5hbWUgPT09IFwiQVwiICYmICFwYXJlbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBhcmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3eXNpaHRtbDUucXVpcmtzLnJlZHJhdyhlbGVtZW50KTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyAtLS0tLS0tLS0gU2hvdyB1cmwgaW4gdG9vbHRpcCB3aGVuIGhvdmVyaW5nIGxpbmtzIG9yIGltYWdlcyAtLS0tLS0tLS1cbiAgICB2YXIgdGl0bGVQcmVmaXhlcyA9IHtcbiAgICAgIElNRzogXCJJbWFnZTogXCIsXG4gICAgICBBOiBcIkxpbms6IFwiXG4gICAgfTtcblxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICBub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZSxcbiAgICAgICAgICB0aXRsZTtcbiAgICAgIGlmIChub2RlTmFtZSAhPT0gXCJBXCIgJiYgbm9kZU5hbWUgIT09IFwiSU1HXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhhc1RpdGxlID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZShcInRpdGxlXCIpO1xuICAgICAgaWYgKCFoYXNUaXRsZSkge1xuICAgICAgICB0aXRsZSA9IHRpdGxlUHJlZml4ZXNbbm9kZU5hbWVdICsgKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJzcmNcIikpO1xuICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgdGl0bGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSkod3lzaWh0bWw1KTsgLyoqXG4gICAgICAgICAgICAgICAqIENsYXNzIHRoYXQgdGFrZXMgY2FyZSB0aGF0IHRoZSB2YWx1ZSBvZiB0aGUgY29tcG9zZXIgYW5kIHRoZSB0ZXh0YXJlYSBpcyBhbHdheXMgaW4gc3luY1xuICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciBJTlRFUlZBTCA9IDQwMDtcblxuICB3eXNpaHRtbDUudmlld3MuU3luY2hyb25pemVyID0gQmFzZS5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LnZpZXdzLlN5bmNocm9uaXplci5wcm90b3R5cGUgKi97XG5cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gY29uc3RydWN0b3IoZWRpdG9yLCB0ZXh0YXJlYSwgY29tcG9zZXIpIHtcbiAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgdGhpcy50ZXh0YXJlYSA9IHRleHRhcmVhO1xuICAgICAgdGhpcy5jb21wb3NlciA9IGNvbXBvc2VyO1xuXG4gICAgICB0aGlzLl9vYnNlcnZlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN5bmMgaHRtbCBmcm9tIGNvbXBvc2VyIHRvIHRleHRhcmVhXG4gICAgICogVGFrZXMgY2FyZSBvZiBwbGFjZWhvbGRlcnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZFBhcnNlSHRtbCBXaGV0aGVyIHRoZSBodG1sIHNob3VsZCBiZSBzYW5pdGl6ZWQgYmVmb3JlIGluc2VydGluZyBpdCBpbnRvIHRoZSB0ZXh0YXJlYVxuICAgICAqL1xuICAgIGZyb21Db21wb3NlclRvVGV4dGFyZWE6IGZ1bmN0aW9uIGZyb21Db21wb3NlclRvVGV4dGFyZWEoc2hvdWxkUGFyc2VIdG1sKSB7XG4gICAgICB0aGlzLnRleHRhcmVhLnNldFZhbHVlKHd5c2lodG1sNS5sYW5nLnN0cmluZyh0aGlzLmNvbXBvc2VyLmdldFZhbHVlKCkpLnRyaW0oKSwgc2hvdWxkUGFyc2VIdG1sKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3luYyB2YWx1ZSBvZiB0ZXh0YXJlYSB0byBjb21wb3NlclxuICAgICAqIFRha2VzIGNhcmUgb2YgcGxhY2Vob2xkZXJzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaG91bGRQYXJzZUh0bWwgV2hldGhlciB0aGUgaHRtbCBzaG91bGQgYmUgc2FuaXRpemVkIGJlZm9yZSBpbnNlcnRpbmcgaXQgaW50byB0aGUgY29tcG9zZXJcbiAgICAgKi9cbiAgICBmcm9tVGV4dGFyZWFUb0NvbXBvc2VyOiBmdW5jdGlvbiBmcm9tVGV4dGFyZWFUb0NvbXBvc2VyKHNob3VsZFBhcnNlSHRtbCkge1xuICAgICAgdmFyIHRleHRhcmVhVmFsdWUgPSB0aGlzLnRleHRhcmVhLmdldFZhbHVlKCk7XG4gICAgICBpZiAodGV4dGFyZWFWYWx1ZSkge1xuICAgICAgICB0aGlzLmNvbXBvc2VyLnNldFZhbHVlKHRleHRhcmVhVmFsdWUsIHNob3VsZFBhcnNlSHRtbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBvc2VyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLmZpcmUoXCJzZXRfcGxhY2Vob2xkZXJcIik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZSBzeW5jaW5nIGJhc2VkIG9uIHZpZXcgc3RhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZFBhcnNlSHRtbCBXaGV0aGVyIHRoZSBodG1sIHNob3VsZCBiZSBzYW5pdGl6ZWQgYmVmb3JlIGluc2VydGluZyBpdCBpbnRvIHRoZSBjb21wb3Nlci90ZXh0YXJlYVxuICAgICAqL1xuICAgIHN5bmM6IGZ1bmN0aW9uIHN5bmMoc2hvdWxkUGFyc2VIdG1sKSB7XG4gICAgICBpZiAodGhpcy5lZGl0b3IuY3VycmVudFZpZXcubmFtZSA9PT0gXCJ0ZXh0YXJlYVwiKSB7XG4gICAgICAgIHRoaXMuZnJvbVRleHRhcmVhVG9Db21wb3NlcihzaG91bGRQYXJzZUh0bWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mcm9tQ29tcG9zZXJUb1RleHRhcmVhKHNob3VsZFBhcnNlSHRtbCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGludGVydmFsLWJhc2VkIHN5bmNpbmdcbiAgICAgKiBhbHNvIG1ha2VzIHN1cmUgdGhhdCBvbi1zdWJtaXQgdGhlIGNvbXBvc2VyJ3MgY29udGVudCBpcyBzeW5jZWQgd2l0aCB0aGUgdGV4dGFyZWFcbiAgICAgKiBpbW1lZGlhdGVseSB3aGVuIHRoZSBmb3JtIGdldHMgc3VibWl0dGVkXG4gICAgICovXG4gICAgX29ic2VydmU6IGZ1bmN0aW9uIF9vYnNlcnZlKCkge1xuICAgICAgdmFyIGludGVydmFsLFxuICAgICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIGZvcm0gPSB0aGlzLnRleHRhcmVhLmVsZW1lbnQuZm9ybSxcbiAgICAgICAgICBzdGFydEludGVydmFsID0gZnVuY3Rpb24gc3RhcnRJbnRlcnZhbCgpIHtcbiAgICAgICAgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhhdC5mcm9tQ29tcG9zZXJUb1RleHRhcmVhKCk7XG4gICAgICAgIH0sIElOVEVSVkFMKTtcbiAgICAgIH0sXG4gICAgICAgICAgc3RvcEludGVydmFsID0gZnVuY3Rpb24gc3RvcEludGVydmFsKCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgaW50ZXJ2YWwgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgc3RhcnRJbnRlcnZhbCgpO1xuXG4gICAgICBpZiAoZm9ybSkge1xuICAgICAgICAvLyBJZiB0aGUgdGV4dGFyZWEgaXMgaW4gYSBmb3JtIG1ha2Ugc3VyZSB0aGF0IGFmdGVyIG9ucmVzZXQgYW5kIG9uc3VibWl0IHRoZSBjb21wb3NlclxuICAgICAgICAvLyBoYXMgdGhlIGNvcnJlY3Qgc3RhdGVcbiAgICAgICAgd3lzaWh0bWw1LmRvbS5vYnNlcnZlKGZvcm0sIFwic3VibWl0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LnN5bmModHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB3eXNpaHRtbDUuZG9tLm9ic2VydmUoZm9ybSwgXCJyZXNldFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LmZyb21UZXh0YXJlYVRvQ29tcG9zZXIoKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRpdG9yLm9ic2VydmUoXCJjaGFuZ2Vfdmlld1wiLCBmdW5jdGlvbiAodmlldykge1xuICAgICAgICBpZiAodmlldyA9PT0gXCJjb21wb3NlclwiICYmICFpbnRlcnZhbCkge1xuICAgICAgICAgIHRoYXQuZnJvbVRleHRhcmVhVG9Db21wb3Nlcih0cnVlKTtcbiAgICAgICAgICBzdGFydEludGVydmFsKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmlldyA9PT0gXCJ0ZXh0YXJlYVwiKSB7XG4gICAgICAgICAgdGhhdC5mcm9tQ29tcG9zZXJUb1RleHRhcmVhKHRydWUpO1xuICAgICAgICAgIHN0b3BJbnRlcnZhbCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5lZGl0b3Iub2JzZXJ2ZShcImRlc3Ryb3k6Y29tcG9zZXJcIiwgc3RvcEludGVydmFsKTtcbiAgICB9XG4gIH0pO1xufSkod3lzaWh0bWw1KTtcbnd5c2lodG1sNS52aWV3cy5UZXh0YXJlYSA9IHd5c2lodG1sNS52aWV3cy5WaWV3LmV4dGVuZChcbi8qKiBAc2NvcGUgd3lzaWh0bWw1LnZpZXdzLlRleHRhcmVhLnByb3RvdHlwZSAqL3tcbiAgbmFtZTogXCJ0ZXh0YXJlYVwiLFxuXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBjb25zdHJ1Y3RvcihwYXJlbnQsIHRleHRhcmVhRWxlbWVudCwgY29uZmlnKSB7XG4gICAgdGhpcy5iYXNlKHBhcmVudCwgdGV4dGFyZWFFbGVtZW50LCBjb25maWcpO1xuXG4gICAgdGhpcy5fb2JzZXJ2ZSgpO1xuICB9LFxuXG4gIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSBcIlwiO1xuICB9LFxuXG4gIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShwYXJzZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuaXNFbXB0eSgpID8gXCJcIiA6IHRoaXMuZWxlbWVudC52YWx1ZTtcbiAgICBpZiAocGFyc2UpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5wYXJlbnQucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG5cbiAgc2V0VmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKGh0bWwsIHBhcnNlKSB7XG4gICAgaWYgKHBhcnNlKSB7XG4gICAgICBodG1sID0gdGhpcy5wYXJlbnQucGFyc2UoaHRtbCk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudC52YWx1ZSA9IGh0bWw7XG4gIH0sXG5cbiAgaGFzUGxhY2Vob2xkZXJTZXQ6IGZ1bmN0aW9uIGhhc1BsYWNlaG9sZGVyU2V0KCkge1xuICAgIHZhciBzdXBwb3J0c1BsYWNlaG9sZGVyID0gd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNQbGFjZWhvbGRlckF0dHJpYnV0ZU9uKHRoaXMuZWxlbWVudCksXG4gICAgICAgIHBsYWNlaG9sZGVyVGV4dCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKSB8fCBudWxsLFxuICAgICAgICB2YWx1ZSA9IHRoaXMuZWxlbWVudC52YWx1ZSxcbiAgICAgICAgaXNFbXB0eSA9ICF2YWx1ZTtcbiAgICByZXR1cm4gc3VwcG9ydHNQbGFjZWhvbGRlciAmJiBpc0VtcHR5IHx8IHZhbHVlID09PSBwbGFjZWhvbGRlclRleHQ7XG4gIH0sXG5cbiAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIXd5c2lodG1sNS5sYW5nLnN0cmluZyh0aGlzLmVsZW1lbnQudmFsdWUpLnRyaW0oKSB8fCB0aGlzLmhhc1BsYWNlaG9sZGVyU2V0KCk7XG4gIH0sXG5cbiAgX29ic2VydmU6IGZ1bmN0aW9uIF9vYnNlcnZlKCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgICAgZXZlbnRNYXBwaW5nID0ge1xuICAgICAgZm9jdXNpbjogXCJmb2N1c1wiLFxuICAgICAgZm9jdXNvdXQ6IFwiYmx1clwiXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGxpbmcgZm9jdXMoKSBvciBibHVyKCkgb24gYW4gZWxlbWVudCBkb2Vzbid0IHN5bmNocm9ub3VzbHkgdHJpZ2dlciB0aGUgYXR0YWNoZWQgZm9jdXMvYmx1ciBldmVudHNcbiAgICAgKiBUaGlzIGlzIHRoZSBjYXNlIGZvciBmb2N1c2luIGFuZCBmb2N1c291dCwgc28gbGV0J3MgdXNlIHRoZW0gd2hlbmV2ZXIgcG9zc2libGUsIGtrdGh4YmFpXG4gICAgICovXG4gICAgZXZlbnRzID0gd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNFdmVudChcImZvY3VzaW5cIikgPyBbXCJmb2N1c2luXCIsIFwiZm9jdXNvdXRcIiwgXCJjaGFuZ2VcIl0gOiBbXCJmb2N1c1wiLCBcImJsdXJcIiwgXCJjaGFuZ2VcIl07XG5cbiAgICBwYXJlbnQub2JzZXJ2ZShcImJlZm9yZWxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgd3lzaWh0bWw1LmRvbS5vYnNlcnZlKGVsZW1lbnQsIGV2ZW50cywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudE1hcHBpbmdbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgICAgICAgcGFyZW50LmZpcmUoZXZlbnROYW1lKS5maXJlKGV2ZW50TmFtZSArIFwiOnRleHRhcmVhXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIHd5c2lodG1sNS5kb20ub2JzZXJ2ZShlbGVtZW50LCBbXCJwYXN0ZVwiLCBcImRyb3BcIl0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGFyZW50LmZpcmUoXCJwYXN0ZVwiKS5maXJlKFwicGFzdGU6dGV4dGFyZWFcIik7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pOyAvKipcbiAgICAqIFRvb2xiYXIgRGlhbG9nXG4gICAgKlxuICAgICogQHBhcmFtIHtFbGVtZW50fSBsaW5rIFRoZSB0b29sYmFyIGxpbmsgd2hpY2ggY2F1c2VzIHRoZSBkaWFsb2cgdG8gc2hvdyB1cFxuICAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgVGhlIGRpYWxvZyBjb250YWluZXJcbiAgICAqXG4gICAgKiBAZXhhbXBsZVxuICAgICogICAgPCEtLSBUb29sYmFyIGxpbmsgLS0+XG4gICAgKiAgICA8YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPVwiaW5zZXJ0SW1hZ2VcIj5pbnNlcnQgYW4gaW1hZ2U8L2E+XG4gICAgKlxuICAgICogICAgPCEtLSBEaWFsb2cgLS0+XG4gICAgKiAgICA8ZGl2IGRhdGEtd3lzaWh0bWw1LWRpYWxvZz1cImluc2VydEltYWdlXCIgc3R5bGU9XCJkaXNwbGF5OiBub25lO1wiPlxuICAgICogICAgICA8bGFiZWw+XG4gICAgKiAgICAgICAgVVJMOiA8aW5wdXQgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVwic3JjXCIgdmFsdWU9XCJodHRwOi8vXCI+XG4gICAgKiAgICAgIDwvbGFiZWw+XG4gICAgKiAgICAgIDxsYWJlbD5cbiAgICAqICAgICAgICBBbHRlcm5hdGl2ZSB0ZXh0OiA8aW5wdXQgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVwiYWx0XCIgdmFsdWU9XCJcIj5cbiAgICAqICAgICAgPC9sYWJlbD5cbiAgICAqICAgIDwvZGl2PlxuICAgICpcbiAgICAqICAgIDxzY3JpcHQ+XG4gICAgKiAgICAgIHZhciBkaWFsb2cgPSBuZXcgd3lzaWh0bWw1LnRvb2xiYXIuRGlhbG9nKFxuICAgICogICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS13eXNpaHRtbDUtY29tbWFuZD0naW5zZXJ0SW1hZ2UnXVwiKSxcbiAgICAqICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtd3lzaWh0bWw1LWRpYWxvZz0naW5zZXJ0SW1hZ2UnXVwiKVxuICAgICogICAgICApO1xuICAgICogICAgICBkaWFsb2cub2JzZXJ2ZShcInNhdmVcIiwgZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICogICAgICAgIC8vIGRvIHNvbWV0aGluZ1xuICAgICogICAgICB9KTtcbiAgICAqICAgIDwvc2NyaXB0PlxuICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgZG9tID0gd3lzaWh0bWw1LmRvbSxcbiAgICAgIENMQVNTX05BTUVfT1BFTkVEID0gXCJ3eXNpaHRtbDUtY29tbWFuZC1kaWFsb2ctb3BlbmVkXCIsXG4gICAgICBTRUxFQ1RPUl9GT1JNX0VMRU1FTlRTID0gXCJpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYVwiLFxuICAgICAgU0VMRUNUT1JfRklFTERTID0gXCJbZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkXVwiLFxuICAgICAgQVRUUklCVVRFX0ZJRUxEUyA9IFwiZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkXCI7XG5cbiAgd3lzaWh0bWw1LnRvb2xiYXIuRGlhbG9nID0gd3lzaWh0bWw1LmxhbmcuRGlzcGF0Y2hlci5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LnRvb2xiYXIuRGlhbG9nLnByb3RvdHlwZSAqL3tcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gY29uc3RydWN0b3IobGluaywgY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmxpbmsgPSBsaW5rO1xuICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfSxcblxuICAgIF9vYnNlcnZlOiBmdW5jdGlvbiBfb2JzZXJ2ZSgpIHtcbiAgICAgIGlmICh0aGlzLl9vYnNlcnZlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBjYWxsYmFja1dyYXBwZXIgPSBmdW5jdGlvbiBjYWxsYmFja1dyYXBwZXIoZXZlbnQpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGF0Ll9zZXJpYWxpemUoKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMgPT0gdGhhdC5lbGVtZW50VG9DaGFuZ2UpIHtcbiAgICAgICAgICB0aGF0LmZpcmUoXCJlZGl0XCIsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoYXQuZmlyZShcInNhdmVcIiwgYXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5oaWRlKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfTtcblxuICAgICAgZG9tLm9ic2VydmUodGhhdC5saW5rLCBcImNsaWNrXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZG9tLmhhc0NsYXNzKHRoYXQubGluaywgQ0xBU1NfTkFNRV9PUEVORUQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LmhpZGUoKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGRvbS5vYnNlcnZlKHRoaXMuY29udGFpbmVyLCBcImtleWRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IHd5c2lodG1sNS5FTlRFUl9LRVkpIHtcbiAgICAgICAgICBjYWxsYmFja1dyYXBwZXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlDb2RlID09PSB3eXNpaHRtbDUuRVNDQVBFX0tFWSkge1xuICAgICAgICAgIC8vIHRoYXQuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZG9tLmRlbGVnYXRlKHRoaXMuY29udGFpbmVyLCBcIltkYXRhLXd5c2lodG1sNS1kaWFsb2ctYWN0aW9uPXNhdmVdXCIsIFwiY2xpY2tcIiwgY2FsbGJhY2tXcmFwcGVyKTtcblxuICAgICAgZG9tLmRlbGVnYXRlKHRoaXMuY29udGFpbmVyLCBcIltkYXRhLXd5c2lodG1sNS1kaWFsb2ctYWN0aW9uPWNhbmNlbF1cIiwgXCJjbGlja1wiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhhdC5maXJlKFwiY2FuY2VsXCIpO1xuICAgICAgICB0aGF0LmhpZGUoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGZvcm1FbGVtZW50cyA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfRk9STV9FTEVNRU5UUyksXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gZm9ybUVsZW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBfY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uIF9jbGVhckludGVydmFsKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoYXQuaW50ZXJ2YWwpO1xuICAgICAgfTtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZG9tLm9ic2VydmUoZm9ybUVsZW1lbnRzW2ldLCBcImNoYW5nZVwiLCBfY2xlYXJJbnRlcnZhbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29ic2VydmVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR3JhYnMgYWxsIGZpZWxkcyBpbiB0aGUgZGlhbG9nIGFuZCBwdXRzIHRoZW0gaW4ga2V5PT52YWx1ZSBzdHlsZSBpbiBhbiBvYmplY3Qgd2hpY2hcbiAgICAgKiB0aGVuIGdldHMgcmV0dXJuZWRcbiAgICAgKi9cbiAgICBfc2VyaWFsaXplOiBmdW5jdGlvbiBfc2VyaWFsaXplKCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmVsZW1lbnRUb0NoYW5nZSB8fCB7fSxcbiAgICAgICAgICBmaWVsZHMgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0ZJRUxEUyksXG4gICAgICAgICAgbGVuZ3RoID0gZmllbGRzLmxlbmd0aCxcbiAgICAgICAgICBpID0gMDtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtmaWVsZHNbaV0uZ2V0QXR0cmlidXRlKEFUVFJJQlVURV9GSUVMRFMpXSA9IGZpZWxkc1tpXS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyB0aGUgYXR0cmlidXRlcyBvZiB0aGUgXCJlbGVtZW50VG9DaGFuZ2VcIlxuICAgICAqIGFuZCBpbnNlcnRzIHRoZW0gaW4gdGhlaXIgY29ycmVzcG9uZGluZyBkaWFsb2cgaW5wdXQgZmllbGRzXG4gICAgICogXG4gICAgICogQXNzdW1lIHRoZSBcImVsZW1lbnRUb0NoYW5nZVwiIGxvb2tzIGxpa2UgdGhpczpcbiAgICAgKiAgICA8YSBocmVmPVwiaHR0cDovL3d3dy5nb29nbGUuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+Zm9vPC9hPlxuICAgICAqXG4gICAgICogYW5kIHdlIGhhdmUgdGhlIGZvbGxvd2luZyBkaWFsb2c6XG4gICAgICogICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVwiaHJlZlwiIHZhbHVlPVwiXCI+XG4gICAgICogICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgZGF0YS13eXNpaHRtbDUtZGlhbG9nLWZpZWxkPVwidGFyZ2V0XCIgdmFsdWU9XCJcIj5cbiAgICAgKiBcbiAgICAgKiBhZnRlciBjYWxsaW5nIF9pbnRlcnBvbGF0ZSgpIHRoZSBkaWFsb2cgd2lsbCBsb29rIGxpa2UgdGhpc1xuICAgICAqICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtd3lzaWh0bWw1LWRpYWxvZy1maWVsZD1cImhyZWZcIiB2YWx1ZT1cImh0dHA6Ly93d3cuZ29vZ2xlLmNvbVwiPlxuICAgICAqICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtd3lzaWh0bWw1LWRpYWxvZy1maWVsZD1cInRhcmdldFwiIHZhbHVlPVwiX2JsYW5rXCI+XG4gICAgICpcbiAgICAgKiBCYXNpY2FsbHkgaXQgYWRvcHRlZCB0aGUgYXR0cmlidXRlIHZhbHVlcyBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIGlucHV0IGZpZWxkc1xuICAgICAqXG4gICAgICovXG4gICAgX2ludGVycG9sYXRlOiBmdW5jdGlvbiBfaW50ZXJwb2xhdGUoYXZvaWRIaWRkZW5GaWVsZHMpIHtcbiAgICAgIHZhciBmaWVsZCxcbiAgICAgICAgICBmaWVsZE5hbWUsXG4gICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgZm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiOmZvY3VzXCIpLFxuICAgICAgICAgIGZpZWxkcyA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfRklFTERTKSxcbiAgICAgICAgICBsZW5ndGggPSBmaWVsZHMubGVuZ3RoLFxuICAgICAgICAgIGkgPSAwO1xuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBmaWVsZCA9IGZpZWxkc1tpXTtcblxuICAgICAgICAvLyBOZXZlciBjaGFuZ2UgZWxlbWVudHMgd2hlcmUgdGhlIHVzZXIgaXMgY3VycmVudGx5IHR5cGluZyBpblxuICAgICAgICBpZiAoZmllbGQgPT09IGZvY3VzZWRFbGVtZW50KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb24ndCB1cGRhdGUgaGlkZGVuIGZpZWxkc1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3hpbmcvd3lzaWh0bWw1L3B1bGwvMTRcbiAgICAgICAgaWYgKGF2b2lkSGlkZGVuRmllbGRzICYmIGZpZWxkLnR5cGUgPT09IFwiaGlkZGVuXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkLmdldEF0dHJpYnV0ZShBVFRSSUJVVEVfRklFTERTKTtcbiAgICAgICAgbmV3VmFsdWUgPSB0aGlzLmVsZW1lbnRUb0NoYW5nZSA/IHRoaXMuZWxlbWVudFRvQ2hhbmdlW2ZpZWxkTmFtZV0gfHwgXCJcIiA6IGZpZWxkLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgZmllbGQudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgZGlhbG9nIGVsZW1lbnRcbiAgICAgKi9cbiAgICBzaG93OiBmdW5jdGlvbiBzaG93KGVsZW1lbnRUb0NoYW5nZSkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIGZpcnN0RmllbGQgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX0ZPUk1fRUxFTUVOVFMpO1xuICAgICAgdGhpcy5lbGVtZW50VG9DaGFuZ2UgPSBlbGVtZW50VG9DaGFuZ2U7XG4gICAgICB0aGlzLl9vYnNlcnZlKCk7XG4gICAgICB0aGlzLl9pbnRlcnBvbGF0ZSgpO1xuICAgICAgaWYgKGVsZW1lbnRUb0NoYW5nZSkge1xuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuX2ludGVycG9sYXRlKHRydWUpO1xuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgICAgZG9tLmFkZENsYXNzKHRoaXMubGluaywgQ0xBU1NfTkFNRV9PUEVORUQpO1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICB0aGlzLmZpcmUoXCJzaG93XCIpO1xuICAgICAgaWYgKGZpcnN0RmllbGQgJiYgIWVsZW1lbnRUb0NoYW5nZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZpcnN0RmllbGQuZm9jdXMoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgZGlhbG9nIGVsZW1lbnRcbiAgICAgKi9cbiAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgIHRoaXMuZWxlbWVudFRvQ2hhbmdlID0gbnVsbDtcbiAgICAgIGRvbS5yZW1vdmVDbGFzcyh0aGlzLmxpbmssIENMQVNTX05BTUVfT1BFTkVEKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIHRoaXMuZmlyZShcImhpZGVcIik7XG4gICAgfVxuICB9KTtcbn0pKHd5c2lodG1sNSk7XG4vKipcbiAqIENvbnZlcnRzIHNwZWVjaC10by10ZXh0IGFuZCBpbnNlcnRzIHRoaXMgaW50byB0aGUgZWRpdG9yXG4gKiBBcyBvZiBub3cgKDIwMTEvMDMvMjUpIHRoaXMgb25seSBpcyBzdXBwb3J0ZWQgaW4gQ2hyb21lID49IDExXG4gKlxuICogTm90ZSB0aGF0IGl0IHNlbmRzIHRoZSByZWNvcmRlZCBhdWRpbyB0byB0aGUgZ29vZ2xlIHNwZWVjaCByZWNvZ25pdGlvbiBhcGk6XG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQzNjE4MjYvZG9lcy1jaHJvbWUtaGF2ZS1idWlsLWluLXNwZWVjaC1yZWNvZ25pdGlvbi1mb3ItaW5wdXQtdHlwZS10ZXh0LXgtd2Via2l0LXNwZWVjXG4gKlxuICogQ3VycmVudCBIVE1MNSBkcmFmdCBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cDovL2xpc3RzLnczLm9yZy9BcmNoaXZlcy9QdWJsaWMvcHVibGljLXhnLWh0bWxzcGVlY2gvMjAxMUZlYi9hdHQtMDAyMC9hcGktZHJhZnQuaHRtbFxuICogXG4gKiBcIkFjY2Vzc2luZyBHb29nbGUgU3BlZWNoIEFQSSBDaHJvbWUgMTFcIlxuICogaHR0cDovL21pa2VwdWx0ei5jb20vMjAxMS8wMy9hY2Nlc3NpbmctZ29vZ2xlLXNwZWVjaC1hcGktY2hyb21lLTExL1xuICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgZG9tID0gd3lzaWh0bWw1LmRvbTtcblxuICB2YXIgbGlua1N0eWxlcyA9IHtcbiAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiXG4gIH07XG5cbiAgdmFyIHdyYXBwZXJTdHlsZXMgPSB7XG4gICAgbGVmdDogMCxcbiAgICBtYXJnaW46IDAsXG4gICAgb3BhY2l0eTogMCxcbiAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICBwYWRkaW5nOiAwLFxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgdG9wOiAwLFxuICAgIHpJbmRleDogMVxuICB9O1xuXG4gIHZhciBpbnB1dFN0eWxlcyA9IHtcbiAgICBjdXJzb3I6IFwiaW5oZXJpdFwiLFxuICAgIGZvbnRTaXplOiBcIjUwcHhcIixcbiAgICBoZWlnaHQ6IFwiNTBweFwiLFxuICAgIG1hcmdpblRvcDogXCItMjVweFwiLFxuICAgIG91dGxpbmU6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIHJpZ2h0OiBcIi00cHhcIixcbiAgICB0b3A6IFwiNTAlXCJcbiAgfTtcblxuICB2YXIgaW5wdXRBdHRyaWJ1dGVzID0ge1xuICAgIFwieC13ZWJraXQtc3BlZWNoXCI6IFwiXCIsXG4gICAgXCJzcGVlY2hcIjogXCJcIlxuICB9O1xuXG4gIHd5c2lodG1sNS50b29sYmFyLlNwZWVjaCA9IGZ1bmN0aW9uIChwYXJlbnQsIGxpbmspIHtcbiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c1NwZWVjaEFwaU9uKGlucHV0KSkge1xuICAgICAgbGluay5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgd3lzaWh0bWw1Lmxhbmcub2JqZWN0KHdyYXBwZXJTdHlsZXMpLm1lcmdlKHtcbiAgICAgIHdpZHRoOiBsaW5rLm9mZnNldFdpZHRoICsgXCJweFwiLFxuICAgICAgaGVpZ2h0OiBsaW5rLm9mZnNldEhlaWdodCArIFwicHhcIlxuICAgIH0pO1xuXG4gICAgZG9tLmluc2VydChpbnB1dCkuaW50byh3cmFwcGVyKTtcbiAgICBkb20uaW5zZXJ0KHdyYXBwZXIpLmludG8obGluayk7XG5cbiAgICBkb20uc2V0U3R5bGVzKGlucHV0U3R5bGVzKS5vbihpbnB1dCk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZXMoaW5wdXRBdHRyaWJ1dGVzKS5vbihpbnB1dCk7XG5cbiAgICBkb20uc2V0U3R5bGVzKHdyYXBwZXJTdHlsZXMpLm9uKHdyYXBwZXIpO1xuICAgIGRvbS5zZXRTdHlsZXMobGlua1N0eWxlcykub24obGluayk7XG5cbiAgICB2YXIgZXZlbnROYW1lID0gXCJvbndlYmtpdHNwZWVjaGNoYW5nZVwiIGluIGlucHV0ID8gXCJ3ZWJraXRzcGVlY2hjaGFuZ2VcIiA6IFwic3BlZWNoY2hhbmdlXCI7XG4gICAgZG9tLm9ic2VydmUoaW5wdXQsIGV2ZW50TmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgcGFyZW50LmV4ZWNDb21tYW5kKFwiaW5zZXJ0VGV4dFwiLCBpbnB1dC52YWx1ZSk7XG4gICAgICBpbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgfSk7XG5cbiAgICBkb20ub2JzZXJ2ZShpbnB1dCwgXCJjbGlja1wiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChkb20uaGFzQ2xhc3MobGluaywgXCJ3eXNpaHRtbDUtY29tbWFuZC1kaXNhYmxlZFwiKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9KTtcbiAgfTtcbn0pKHd5c2lodG1sNSk7IC8qKlxuICAgICAgICAgICAgICAgKiBUb29sYmFyXG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgUmVmZXJlbmNlIHRvIGluc3RhbmNlIG9mIEVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciBSZWZlcmVuY2UgdG8gdGhlIHRvb2xiYXIgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICogICAgPGRpdiBpZD1cInRvb2xiYXJcIj5cbiAgICAgICAgICAgICAgICogICAgICA8YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPVwiY3JlYXRlTGlua1wiPmluc2VydCBsaW5rPC9hPlxuICAgICAgICAgICAgICAgKiAgICAgIDxhIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9XCJmb3JtYXRCbG9ja1wiIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XCJoMVwiPmluc2VydCBoMTwvYT5cbiAgICAgICAgICAgICAgICogICAgPC9kaXY+XG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqICAgIDxzY3JpcHQ+XG4gICAgICAgICAgICAgICAqICAgICAgdmFyIHRvb2xiYXIgPSBuZXcgd3lzaWh0bWw1LnRvb2xiYXIuVG9vbGJhcihlZGl0b3IsIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidG9vbGJhclwiKSk7XG4gICAgICAgICAgICAgICAqICAgIDwvc2NyaXB0PlxuICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciBDTEFTU19OQU1FX0NPTU1BTkRfRElTQUJMRUQgPSBcInd5c2lodG1sNS1jb21tYW5kLWRpc2FibGVkXCIsXG4gICAgICBDTEFTU19OQU1FX0NPTU1BTkRTX0RJU0FCTEVEID0gXCJ3eXNpaHRtbDUtY29tbWFuZHMtZGlzYWJsZWRcIixcbiAgICAgIENMQVNTX05BTUVfQ09NTUFORF9BQ1RJVkUgPSBcInd5c2lodG1sNS1jb21tYW5kLWFjdGl2ZVwiLFxuICAgICAgQ0xBU1NfTkFNRV9BQ1RJT05fQUNUSVZFID0gXCJ3eXNpaHRtbDUtYWN0aW9uLWFjdGl2ZVwiLFxuICAgICAgZG9tID0gd3lzaWh0bWw1LmRvbTtcblxuICB3eXNpaHRtbDUudG9vbGJhci5Ub29sYmFyID0gQmFzZS5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LnRvb2xiYXIuVG9vbGJhci5wcm90b3R5cGUgKi97XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKGVkaXRvciwgY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gdHlwZW9mIGNvbnRhaW5lciA9PT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRhaW5lcikgOiBjb250YWluZXI7XG4gICAgICB0aGlzLmNvbXBvc2VyID0gZWRpdG9yLmNvbXBvc2VyO1xuXG4gICAgICB0aGlzLl9nZXRMaW5rcyhcImNvbW1hbmRcIik7XG4gICAgICB0aGlzLl9nZXRMaW5rcyhcImFjdGlvblwiKTtcblxuICAgICAgdGhpcy5fb2JzZXJ2ZSgpO1xuICAgICAgdGhpcy5zaG93KCk7XG5cbiAgICAgIHZhciBzcGVlY2hJbnB1dExpbmtzID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLXd5c2lodG1sNS1jb21tYW5kPWluc2VydFNwZWVjaF1cIiksXG4gICAgICAgICAgbGVuZ3RoID0gc3BlZWNoSW5wdXRMaW5rcy5sZW5ndGgsXG4gICAgICAgICAgaSA9IDA7XG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ldyB3eXNpaHRtbDUudG9vbGJhci5TcGVlY2godGhpcywgc3BlZWNoSW5wdXRMaW5rc1tpXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9nZXRMaW5rczogZnVuY3Rpb24gX2dldExpbmtzKHR5cGUpIHtcbiAgICAgIHZhciBsaW5rcyA9IHRoaXNbdHlwZSArIFwiTGlua3NcIl0gPSB3eXNpaHRtbDUubGFuZy5hcnJheSh0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtd3lzaWh0bWw1LVwiICsgdHlwZSArIFwiXVwiKSkuZ2V0KCksXG4gICAgICAgICAgbGVuZ3RoID0gbGlua3MubGVuZ3RoLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzW3R5cGUgKyBcIk1hcHBpbmdcIl0gPSB7fSxcbiAgICAgICAgICBsaW5rLFxuICAgICAgICAgIGdyb3VwLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZGlhbG9nO1xuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBsaW5rID0gbGlua3NbaV07XG4gICAgICAgIG5hbWUgPSBsaW5rLmdldEF0dHJpYnV0ZShcImRhdGEtd3lzaWh0bWw1LVwiICsgdHlwZSk7XG4gICAgICAgIHZhbHVlID0gbGluay5nZXRBdHRyaWJ1dGUoXCJkYXRhLXd5c2lodG1sNS1cIiArIHR5cGUgKyBcIi12YWx1ZVwiKTtcbiAgICAgICAgZ3JvdXAgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtd3lzaWh0bWw1LVwiICsgdHlwZSArIFwiLWdyb3VwPSdcIiArIG5hbWUgKyBcIiddXCIpO1xuICAgICAgICBkaWFsb2cgPSB0aGlzLl9nZXREaWFsb2cobGluaywgbmFtZSk7XG5cbiAgICAgICAgbWFwcGluZ1tuYW1lICsgXCI6XCIgKyB2YWx1ZV0gPSB7XG4gICAgICAgICAgbGluazogbGluayxcbiAgICAgICAgICBncm91cDogZ3JvdXAsXG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgZGlhbG9nOiBkaWFsb2csXG4gICAgICAgICAgc3RhdGU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9nZXREaWFsb2c6IGZ1bmN0aW9uIF9nZXREaWFsb2cobGluaywgY29tbWFuZCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIGRpYWxvZ0VsZW1lbnQgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtd3lzaWh0bWw1LWRpYWxvZz0nXCIgKyBjb21tYW5kICsgXCInXVwiKSxcbiAgICAgICAgICBkaWFsb2csXG4gICAgICAgICAgY2FyZXRCb29rbWFyaztcblxuICAgICAgaWYgKGRpYWxvZ0VsZW1lbnQpIHtcbiAgICAgICAgZGlhbG9nID0gbmV3IHd5c2lodG1sNS50b29sYmFyLkRpYWxvZyhsaW5rLCBkaWFsb2dFbGVtZW50KTtcblxuICAgICAgICBkaWFsb2cub2JzZXJ2ZShcInNob3dcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhcmV0Qm9va21hcmsgPSB0aGF0LmNvbXBvc2VyLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuXG4gICAgICAgICAgdGhhdC5lZGl0b3IuZmlyZShcInNob3c6ZGlhbG9nXCIsIHsgY29tbWFuZDogY29tbWFuZCwgZGlhbG9nQ29udGFpbmVyOiBkaWFsb2dFbGVtZW50LCBjb21tYW5kTGluazogbGluayB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGlhbG9nLm9ic2VydmUoXCJzYXZlXCIsIGZ1bmN0aW9uIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgaWYgKGNhcmV0Qm9va21hcmspIHtcbiAgICAgICAgICAgIHRoYXQuY29tcG9zZXIuc2VsZWN0aW9uLnNldEJvb2ttYXJrKGNhcmV0Qm9va21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGF0Ll9leGVjQ29tbWFuZChjb21tYW5kLCBhdHRyaWJ1dGVzKTtcblxuICAgICAgICAgIHRoYXQuZWRpdG9yLmZpcmUoXCJzYXZlOmRpYWxvZ1wiLCB7IGNvbW1hbmQ6IGNvbW1hbmQsIGRpYWxvZ0NvbnRhaW5lcjogZGlhbG9nRWxlbWVudCwgY29tbWFuZExpbms6IGxpbmsgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRpYWxvZy5vYnNlcnZlKFwiY2FuY2VsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LmVkaXRvci5mb2N1cyhmYWxzZSk7XG4gICAgICAgICAgdGhhdC5lZGl0b3IuZmlyZShcImNhbmNlbDpkaWFsb2dcIiwgeyBjb21tYW5kOiBjb21tYW5kLCBkaWFsb2dDb250YWluZXI6IGRpYWxvZ0VsZW1lbnQsIGNvbW1hbmRMaW5rOiBsaW5rIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaWFsb2c7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgdmFyIHRvb2xiYXIgPSBuZXcgd3lzaWh0bWw1LlRvb2xiYXIoKTtcbiAgICAgKiAgICAvLyBJbnNlcnQgYSA8YmxvY2txdW90ZT4gZWxlbWVudCBvciB3cmFwIGN1cnJlbnQgc2VsZWN0aW9uIGluIDxibG9ja3F1b3RlPlxuICAgICAqICAgIHRvb2xiYXIuZXhlY0NvbW1hbmQoXCJmb3JtYXRCbG9ja1wiLCBcImJsb2NrcXVvdGVcIik7XG4gICAgICovXG4gICAgZXhlY0NvbW1hbmQ6IGZ1bmN0aW9uIGV4ZWNDb21tYW5kKGNvbW1hbmQsIGNvbW1hbmRWYWx1ZSkge1xuICAgICAgaWYgKHRoaXMuY29tbWFuZHNEaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21tYW5kT2JqID0gdGhpcy5jb21tYW5kTWFwcGluZ1tjb21tYW5kICsgXCI6XCIgKyBjb21tYW5kVmFsdWVdO1xuXG4gICAgICAvLyBTaG93IGRpYWxvZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgaWYgKGNvbW1hbmRPYmogJiYgY29tbWFuZE9iai5kaWFsb2cgJiYgIWNvbW1hbmRPYmouc3RhdGUpIHtcbiAgICAgICAgY29tbWFuZE9iai5kaWFsb2cuc2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXhlY0NvbW1hbmQoY29tbWFuZCwgY29tbWFuZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2V4ZWNDb21tYW5kOiBmdW5jdGlvbiBfZXhlY0NvbW1hbmQoY29tbWFuZCwgY29tbWFuZFZhbHVlKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCBjb21wb3NlciBpcyBmb2N1c3NlZCAoZmFsc2UgPT4gZG9uJ3QgbW92ZSBjYXJldCB0byB0aGUgZW5kKVxuICAgICAgdGhpcy5lZGl0b3IuZm9jdXMoZmFsc2UpO1xuXG4gICAgICB0aGlzLmNvbXBvc2VyLmNvbW1hbmRzLmV4ZWMoY29tbWFuZCwgY29tbWFuZFZhbHVlKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUxpbmtTdGF0ZXMoKTtcbiAgICB9LFxuXG4gICAgZXhlY0FjdGlvbjogZnVuY3Rpb24gZXhlY0FjdGlvbihhY3Rpb24pIHtcbiAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJjaGFuZ2Vfdmlld1wiOlxuICAgICAgICAgIGlmIChlZGl0b3IuY3VycmVudFZpZXcgPT09IGVkaXRvci50ZXh0YXJlYSkge1xuICAgICAgICAgICAgZWRpdG9yLmZpcmUoXCJjaGFuZ2Vfdmlld1wiLCBcImNvbXBvc2VyXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZGl0b3IuZmlyZShcImNoYW5nZV92aWV3XCIsIFwidGV4dGFyZWFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfb2JzZXJ2ZTogZnVuY3Rpb24gX29ic2VydmUoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgZWRpdG9yID0gdGhpcy5lZGl0b3IsXG4gICAgICAgICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgbGlua3MgPSB0aGlzLmNvbW1hbmRMaW5rcy5jb25jYXQodGhpcy5hY3Rpb25MaW5rcyksXG4gICAgICAgICAgbGVuZ3RoID0gbGlua3MubGVuZ3RoLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vICdqYXZhc2NyaXB0OjsnIGFuZCB1bnNlbGVjdGFibGU9b24gTmVlZGVkIGZvciBJRSwgYnV0IGRvbmUgaW4gYWxsIGJyb3dzZXJzIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBnZXQgdGhlIHNhbWUgY3NzIGFwcGxpZWRcbiAgICAgICAgLy8gKHlvdSBrbm93LCBhOmxpbmsgeyAuLi4gfSBkb2Vzbid0IG1hdGNoIGFuY2hvcnMgd2l0aCBtaXNzaW5nIGhyZWYgYXR0cmlidXRlKVxuICAgICAgICBkb20uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgaHJlZjogXCJqYXZhc2NyaXB0OjtcIixcbiAgICAgICAgICB1bnNlbGVjdGFibGU6IFwib25cIlxuICAgICAgICB9KS5vbihsaW5rc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5lZWRlZCBmb3Igb3BlcmFcbiAgICAgIGRvbS5kZWxlZ2F0ZShjb250YWluZXIsIFwiW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmRdXCIsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGRvbS5kZWxlZ2F0ZShjb250YWluZXIsIFwiW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmRdXCIsIFwiY2xpY2tcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcyxcbiAgICAgICAgICAgIGNvbW1hbmQgPSBsaW5rLmdldEF0dHJpYnV0ZShcImRhdGEtd3lzaWh0bWw1LWNvbW1hbmRcIiksXG4gICAgICAgICAgICBjb21tYW5kVmFsdWUgPSBsaW5rLmdldEF0dHJpYnV0ZShcImRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWVcIik7XG4gICAgICAgIHRoYXQuZXhlY0NvbW1hbmQoY29tbWFuZCwgY29tbWFuZFZhbHVlKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBkb20uZGVsZWdhdGUoY29udGFpbmVyLCBcIltkYXRhLXd5c2lodG1sNS1hY3Rpb25dXCIsIFwiY2xpY2tcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtd3lzaWh0bWw1LWFjdGlvblwiKTtcbiAgICAgICAgdGhhdC5leGVjQWN0aW9uKGFjdGlvbik7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcblxuICAgICAgZWRpdG9yLm9ic2VydmUoXCJmb2N1czpjb21wb3NlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQuYm9va21hcmsgPSBudWxsO1xuICAgICAgICBjbGVhckludGVydmFsKHRoYXQuaW50ZXJ2YWwpO1xuICAgICAgICB0aGF0LmludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuX3VwZGF0ZUxpbmtTdGF0ZXMoKTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBlZGl0b3Iub2JzZXJ2ZShcImJsdXI6Y29tcG9zZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoYXQuaW50ZXJ2YWwpO1xuICAgICAgfSk7XG5cbiAgICAgIGVkaXRvci5vYnNlcnZlKFwiZGVzdHJveTpjb21wb3NlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhhdC5pbnRlcnZhbCk7XG4gICAgICB9KTtcblxuICAgICAgZWRpdG9yLm9ic2VydmUoXCJjaGFuZ2Vfdmlld1wiLCBmdW5jdGlvbiAoY3VycmVudFZpZXcpIHtcbiAgICAgICAgLy8gU2V0IHRpbWVvdXQgbmVlZGVkIGluIG9yZGVyIHRvIGxldCB0aGUgYmx1ciBldmVudCBmaXJlIGZpcnN0XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuY29tbWFuZHNEaXNhYmxlZCA9IGN1cnJlbnRWaWV3ICE9PSBcImNvbXBvc2VyXCI7XG4gICAgICAgICAgdGhhdC5fdXBkYXRlTGlua1N0YXRlcygpO1xuICAgICAgICAgIGlmICh0aGF0LmNvbW1hbmRzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhjb250YWluZXIsIENMQVNTX05BTUVfQ09NTUFORFNfRElTQUJMRUQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBDTEFTU19OQU1FX0NPTU1BTkRTX0RJU0FCTEVEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF91cGRhdGVMaW5rU3RhdGVzOiBmdW5jdGlvbiBfdXBkYXRlTGlua1N0YXRlcygpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb21wb3Nlci5lbGVtZW50LFxuICAgICAgICAgIGNvbW1hbmRNYXBwaW5nID0gdGhpcy5jb21tYW5kTWFwcGluZyxcbiAgICAgICAgICBhY3Rpb25NYXBwaW5nID0gdGhpcy5hY3Rpb25NYXBwaW5nLFxuICAgICAgICAgIGksXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIGNvbW1hbmQ7XG4gICAgICAvLyBldmVyeSBtaWxsaXNlY29uZCBjb3VudHMuLi4gdGhpcyBpcyBleGVjdXRlZCBxdWl0ZSBvZnRlblxuICAgICAgZm9yIChpIGluIGNvbW1hbmRNYXBwaW5nKSB7XG4gICAgICAgIGNvbW1hbmQgPSBjb21tYW5kTWFwcGluZ1tpXTtcbiAgICAgICAgaWYgKHRoaXMuY29tbWFuZHNEaXNhYmxlZCkge1xuICAgICAgICAgIHN0YXRlID0gZmFsc2U7XG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbW1hbmQubGluaywgQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSk7XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZ3JvdXApIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb21tYW5kLmdyb3VwLCBDTEFTU19OQU1FX0NPTU1BTkRfQUNUSVZFKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZGlhbG9nKSB7XG4gICAgICAgICAgICBjb21tYW5kLmRpYWxvZy5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gdGhpcy5jb21wb3Nlci5jb21tYW5kcy5zdGF0ZShjb21tYW5kLm5hbWUsIGNvbW1hbmQudmFsdWUpO1xuICAgICAgICAgIGlmICh3eXNpaHRtbDUubGFuZy5vYmplY3Qoc3RhdGUpLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgLy8gR3JhYiBmaXJzdCBhbmQgb25seSBvYmplY3QvZWxlbWVudCBpbiBzdGF0ZSBhcnJheSwgb3RoZXJ3aXNlIGNvbnZlcnQgc3RhdGUgaW50byBib29sZWFuXG4gICAgICAgICAgICAvLyB0byBhdm9pZCBzaG93aW5nIGEgZGlhbG9nIGZvciBtdWx0aXBsZSBzZWxlY3RlZCBlbGVtZW50cyB3aGljaCBtYXkgaGF2ZSBkaWZmZXJlbnQgYXR0cmlidXRlc1xuICAgICAgICAgICAgLy8gZWcuIHdoZW4gdHdvIGxpbmtzIHdpdGggZGlmZmVyZW50IGhyZWYgYXJlIHNlbGVjdGVkLCB0aGUgc3RhdGUgd2lsbCBiZSBhbiBhcnJheSBjb25zaXN0aW5nIG9mIGJvdGggbGluayBlbGVtZW50c1xuICAgICAgICAgICAgLy8gYnV0IHRoZSBkaWFsb2cgaW50ZXJmYWNlIGNhbiBvbmx5IHVwZGF0ZSBvbmVcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUubGVuZ3RoID09PSAxID8gc3RhdGVbMF0gOiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29tbWFuZC5saW5rLCBDTEFTU19OQU1FX0NPTU1BTkRfRElTQUJMRUQpO1xuICAgICAgICAgIGlmIChjb21tYW5kLmdyb3VwKSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29tbWFuZC5ncm91cCwgQ0xBU1NfTkFNRV9DT01NQU5EX0RJU0FCTEVEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbWFuZC5zdGF0ZSA9PT0gc3RhdGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbW1hbmQuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKGNvbW1hbmQubGluaywgQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSk7XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZ3JvdXApIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhjb21tYW5kLmdyb3VwLCBDTEFTU19OQU1FX0NPTU1BTkRfQUNUSVZFKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbW1hbmQuZGlhbG9nKSB7XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBzdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHN0YXRlKSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgY29tbWFuZC5kaWFsb2cuc2hvdyhzdGF0ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb21tYW5kLmRpYWxvZy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb21tYW5kLmxpbmssIENMQVNTX05BTUVfQ09NTUFORF9BQ1RJVkUpO1xuICAgICAgICAgIGlmIChjb21tYW5kLmdyb3VwKSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29tbWFuZC5ncm91cCwgQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb21tYW5kLmRpYWxvZykge1xuICAgICAgICAgICAgY29tbWFuZC5kaWFsb2cuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgaW4gYWN0aW9uTWFwcGluZykge1xuICAgICAgICBhY3Rpb24gPSBhY3Rpb25NYXBwaW5nW2ldO1xuXG4gICAgICAgIGlmIChhY3Rpb24ubmFtZSA9PT0gXCJjaGFuZ2Vfdmlld1wiKSB7XG4gICAgICAgICAgYWN0aW9uLnN0YXRlID0gdGhpcy5lZGl0b3IuY3VycmVudFZpZXcgPT09IHRoaXMuZWRpdG9yLnRleHRhcmVhO1xuICAgICAgICAgIGlmIChhY3Rpb24uc3RhdGUpIHtcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhhY3Rpb24ubGluaywgQ0xBU1NfTkFNRV9BQ1RJT05fQUNUSVZFKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGFjdGlvbi5saW5rLCBDTEFTU19OQU1FX0FDVElPTl9BQ1RJVkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxuICB9KTtcbn0pKHd5c2lodG1sNSk7XG4vKipcbiAqIFdZU0lIVE1MNSBFZGl0b3JcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRleHRhcmVhRWxlbWVudCBSZWZlcmVuY2UgdG8gdGhlIHRleHRhcmVhIHdoaWNoIHNob3VsZCBiZSB0dXJuZWQgaW50byBhIHJpY2ggdGV4dCBpbnRlcmZhY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXSBTZWUgZGVmYXVsdENvbmZpZyBvYmplY3QgYmVsb3cgZm9yIGV4cGxhbmF0aW9uIG9mIGVhY2ggaW5kaXZpZHVhbCBjb25maWcgb3B0aW9uXG4gKlxuICogQGV2ZW50c1xuICogICAgbG9hZFxuICogICAgYmVmb3JlbG9hZCAoZm9yIGludGVybmFsIHVzZSBvbmx5KVxuICogICAgZm9jdXNcbiAqICAgIGZvY3VzOmNvbXBvc2VyXG4gKiAgICBmb2N1czp0ZXh0YXJlYVxuICogICAgYmx1clxuICogICAgYmx1cjpjb21wb3NlclxuICogICAgYmx1cjp0ZXh0YXJlYVxuICogICAgY2hhbmdlXG4gKiAgICBjaGFuZ2U6Y29tcG9zZXJcbiAqICAgIGNoYW5nZTp0ZXh0YXJlYVxuICogICAgcGFzdGVcbiAqICAgIHBhc3RlOmNvbXBvc2VyXG4gKiAgICBwYXN0ZTp0ZXh0YXJlYVxuICogICAgbmV3d29yZDpjb21wb3NlclxuICogICAgZGVzdHJveTpjb21wb3NlclxuICogICAgdW5kbzpjb21wb3NlclxuICogICAgcmVkbzpjb21wb3NlclxuICogICAgYmVmb3JlY29tbWFuZDpjb21wb3NlclxuICogICAgYWZ0ZXJjb21tYW5kOmNvbXBvc2VyXG4gKiAgICBjaGFuZ2Vfdmlld1xuICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWY7XG5cbiAgdmFyIGRlZmF1bHRDb25maWcgPSB7XG4gICAgLy8gR2l2ZSB0aGUgZWRpdG9yIGEgbmFtZSwgdGhlIG5hbWUgd2lsbCBhbHNvIGJlIHNldCBhcyBjbGFzcyBuYW1lIG9uIHRoZSBpZnJhbWUgYW5kIG9uIHRoZSBpZnJhbWUncyBib2R5IFxuICAgIG5hbWU6IHVuZGVmLFxuICAgIC8vIFdoZXRoZXIgdGhlIGVkaXRvciBzaG91bGQgbG9vayBsaWtlIHRoZSB0ZXh0YXJlYSAoYnkgYWRvcHRpbmcgc3R5bGVzKVxuICAgIHN0eWxlOiB0cnVlLFxuICAgIC8vIElkIG9mIHRoZSB0b29sYmFyIGVsZW1lbnQsIHBhc3MgZmFsc2V5IHZhbHVlIGlmIHlvdSBkb24ndCB3YW50IGFueSB0b29sYmFyIGxvZ2ljXG4gICAgdG9vbGJhcjogdW5kZWYsXG4gICAgLy8gV2hldGhlciB1cmxzLCBlbnRlcmVkIGJ5IHRoZSB1c2VyIHNob3VsZCBhdXRvbWF0aWNhbGx5IGJlY29tZSBjbGlja2FibGUtbGlua3NcbiAgICBhdXRvTGluazogdHJ1ZSxcbiAgICAvLyBPYmplY3Qgd2hpY2ggaW5jbHVkZXMgcGFyc2VyIHJ1bGVzIHRvIGFwcGx5IHdoZW4gaHRtbCBnZXRzIGluc2VydGVkIHZpYSBjb3B5ICYgcGFzdGVcbiAgICAvLyBTZWUgcGFyc2VyX3J1bGVzLyouanMgZm9yIGV4YW1wbGVzXG4gICAgcGFyc2VyUnVsZXM6IHsgdGFnczogeyBicjoge30sIHNwYW46IHt9LCBkaXY6IHt9LCBwOiB7fSB9LCBjbGFzc2VzOiB7fSB9LFxuICAgIC8vIFBhcnNlciBtZXRob2QgdG8gdXNlIHdoZW4gdGhlIHVzZXIgaW5zZXJ0cyBjb250ZW50IHZpYSBjb3B5ICYgcGFzdGVcbiAgICBwYXJzZXI6IHd5c2lodG1sNS5kb20ucGFyc2UsXG4gICAgLy8gQ2xhc3MgbmFtZSB3aGljaCBzaG91bGQgYmUgc2V0IG9uIHRoZSBjb250ZW50RWRpdGFibGUgZWxlbWVudCBpbiB0aGUgY3JlYXRlZCBzYW5kYm94IGlmcmFtZSwgY2FuIGJlIHN0eWxlZCB2aWEgdGhlICdzdHlsZXNoZWV0cycgb3B0aW9uXG4gICAgY29tcG9zZXJDbGFzc05hbWU6IFwid3lzaWh0bWw1LWVkaXRvclwiLFxuICAgIC8vIENsYXNzIG5hbWUgdG8gYWRkIHRvIHRoZSBib2R5IHdoZW4gdGhlIHd5c2lodG1sNSBlZGl0b3IgaXMgc3VwcG9ydGVkXG4gICAgYm9keUNsYXNzTmFtZTogXCJ3eXNpaHRtbDUtc3VwcG9ydGVkXCIsXG4gICAgLy8gQXJyYXkgKG9yIHNpbmdsZSBzdHJpbmcpIG9mIHN0eWxlc2hlZXQgdXJscyB0byBiZSBsb2FkZWQgaW4gdGhlIGVkaXRvcidzIGlmcmFtZVxuICAgIHN0eWxlc2hlZXRzOiBbXSxcbiAgICAvLyBQbGFjZWhvbGRlciB0ZXh0IHRvIHVzZSwgZGVmYXVsdHMgdG8gdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZSBvbiB0aGUgdGV4dGFyZWEgZWxlbWVudFxuICAgIHBsYWNlaG9sZGVyVGV4dDogdW5kZWYsXG4gICAgLy8gV2hldGhlciB0aGUgY29tcG9zZXIgc2hvdWxkIGFsbG93IHRoZSB1c2VyIHRvIG1hbnVhbGx5IHJlc2l6ZSBpbWFnZXMsIHRhYmxlcyBldGMuXG4gICAgYWxsb3dPYmplY3RSZXNpemluZzogdHJ1ZSxcbiAgICAvLyBXaGV0aGVyIHRoZSByaWNoIHRleHQgZWRpdG9yIHNob3VsZCBiZSByZW5kZXJlZCBvbiB0b3VjaCBkZXZpY2VzICh3eXNpaHRtbDUgPj0gMC4zLjAgY29tZXMgd2l0aCBiYXNpYyBzdXBwb3J0IGZvciBpT1MgNSlcbiAgICBzdXBwb3J0VG91Y2hEZXZpY2VzOiB0cnVlXG4gIH07XG5cbiAgd3lzaWh0bWw1LkVkaXRvciA9IHd5c2lodG1sNS5sYW5nLkRpc3BhdGNoZXIuZXh0ZW5kKFxuICAvKiogQHNjb3BlIHd5c2lodG1sNS5FZGl0b3IucHJvdG90eXBlICove1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBjb25zdHJ1Y3Rvcih0ZXh0YXJlYUVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgdGhpcy50ZXh0YXJlYUVsZW1lbnQgPSB0eXBlb2YgdGV4dGFyZWFFbGVtZW50ID09PSBcInN0cmluZ1wiID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGV4dGFyZWFFbGVtZW50KSA6IHRleHRhcmVhRWxlbWVudDtcbiAgICAgIHRoaXMuY29uZmlnID0gd3lzaWh0bWw1Lmxhbmcub2JqZWN0KHt9KS5tZXJnZShkZWZhdWx0Q29uZmlnKS5tZXJnZShjb25maWcpLmdldCgpO1xuICAgICAgdGhpcy50ZXh0YXJlYSA9IG5ldyB3eXNpaHRtbDUudmlld3MuVGV4dGFyZWEodGhpcywgdGhpcy50ZXh0YXJlYUVsZW1lbnQsIHRoaXMuY29uZmlnKTtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcgPSB0aGlzLnRleHRhcmVhO1xuICAgICAgdGhpcy5faXNDb21wYXRpYmxlID0gd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydGVkKCk7XG5cbiAgICAgIC8vIFNvcnQgb3V0IHVuc3VwcG9ydGVkL3Vud2FudGVkIGJyb3dzZXJzIGhlcmVcbiAgICAgIGlmICghdGhpcy5faXNDb21wYXRpYmxlIHx8ICF0aGlzLmNvbmZpZy5zdXBwb3J0VG91Y2hEZXZpY2VzICYmIHd5c2lodG1sNS5icm93c2VyLmlzVG91Y2hEZXZpY2UoKSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuZmlyZShcImJlZm9yZWxvYWRcIikuZmlyZShcImxvYWRcIik7XG4gICAgICAgIH0sIDApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBjbGFzcyBuYW1lIHRvIGJvZHksIHRvIGluZGljYXRlIHRoYXQgdGhlIGVkaXRvciBpcyBzdXBwb3J0ZWRcbiAgICAgIHd5c2lodG1sNS5kb20uYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgdGhpcy5jb25maWcuYm9keUNsYXNzTmFtZSk7XG5cbiAgICAgIHRoaXMuY29tcG9zZXIgPSBuZXcgd3lzaWh0bWw1LnZpZXdzLkNvbXBvc2VyKHRoaXMsIHRoaXMudGV4dGFyZWFFbGVtZW50LCB0aGlzLmNvbmZpZyk7XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gdGhpcy5jb21wb3NlcjtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZy5wYXJzZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLl9pbml0UGFyc2VyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub2JzZXJ2ZShcImJlZm9yZWxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplciA9IG5ldyB3eXNpaHRtbDUudmlld3MuU3luY2hyb25pemVyKHRoaXMsIHRoaXMudGV4dGFyZWEsIHRoaXMuY29tcG9zZXIpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcudG9vbGJhcikge1xuICAgICAgICAgIHRoaXMudG9vbGJhciA9IG5ldyB3eXNpaHRtbDUudG9vbGJhci5Ub29sYmFyKHRoaXMsIHRoaXMuY29uZmlnLnRvb2xiYXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJIZXlhISBUaGlzIHBhZ2UgaXMgdXNpbmcgd3lzaWh0bWw1IGZvciByaWNoIHRleHQgZWRpdGluZy4gQ2hlY2sgb3V0IGh0dHBzOi8vZ2l0aHViLmNvbS94aW5nL3d5c2lodG1sNVwiKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSxcblxuICAgIGlzQ29tcGF0aWJsZTogZnVuY3Rpb24gaXNDb21wYXRpYmxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzQ29tcGF0aWJsZTtcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5jdXJyZW50Vmlldy5jbGVhcigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShwYXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFZpZXcuZ2V0VmFsdWUocGFyc2UpO1xuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUoaHRtbCwgcGFyc2UpIHtcbiAgICAgIGlmICghaHRtbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGVhcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50Vmlldy5zZXRWYWx1ZShodG1sLCBwYXJzZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKHNldFRvRW5kKSB7XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3LmZvY3VzKHNldFRvRW5kKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRlIGVkaXRvciAobWFrZSBpdCByZWFkb25seSlcbiAgICAgKi9cbiAgICBkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgdGhpcy5jdXJyZW50Vmlldy5kaXNhYmxlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGUgZWRpdG9yXG4gICAgICovXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3LmVuYWJsZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50Vmlldy5pc0VtcHR5KCk7XG4gICAgfSxcblxuICAgIGhhc1BsYWNlaG9sZGVyU2V0OiBmdW5jdGlvbiBoYXNQbGFjZWhvbGRlclNldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWaWV3Lmhhc1BsYWNlaG9sZGVyU2V0KCk7XG4gICAgfSxcblxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShodG1sT3JFbGVtZW50KSB7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSB0aGlzLmNvbmZpZy5wYXJzZXIoaHRtbE9yRWxlbWVudCwgdGhpcy5jb25maWcucGFyc2VyUnVsZXMsIHRoaXMuY29tcG9zZXIuc2FuZGJveC5nZXREb2N1bWVudCgpLCB0cnVlKTtcbiAgICAgIGlmICgodHlwZW9mIGh0bWxPckVsZW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihodG1sT3JFbGVtZW50KSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcoaHRtbE9yRWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgaHRtbCBwYXJzZXIgbG9naWNcbiAgICAgKiAgLSBPYnNlcnZlcyBmb3IgcGFzdGUgYW5kIGRyb3BcbiAgICAgKi9cbiAgICBfaW5pdFBhcnNlcjogZnVuY3Rpb24gX2luaXRQYXJzZXIoKSB7XG4gICAgICB0aGlzLm9ic2VydmUoXCJwYXN0ZTpjb21wb3NlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrZWVwU2Nyb2xsUG9zaXRpb24gPSB0cnVlLFxuICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoYXQuY29tcG9zZXIuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3eXNpaHRtbDUucXVpcmtzLmNsZWFuUGFzdGVkSFRNTCh0aGF0LmNvbXBvc2VyLmVsZW1lbnQpO1xuICAgICAgICAgIHRoYXQucGFyc2UodGhhdC5jb21wb3Nlci5lbGVtZW50KTtcbiAgICAgICAgfSwga2VlcFNjcm9sbFBvc2l0aW9uKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm9ic2VydmUoXCJwYXN0ZTp0ZXh0YXJlYVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudGV4dGFyZWEuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgIG5ld1ZhbHVlO1xuICAgICAgICBuZXdWYWx1ZSA9IHRoaXMucGFyc2UodmFsdWUpO1xuICAgICAgICB0aGlzLnRleHRhcmVhLnNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59KSh3eXNpaHRtbDUpO1xuLyoqXG5Cb290c3RyYXAgd3lzaWh0bWw1IGVkaXRvci4gQmFzZWQgb24gW2Jvb3RzdHJhcC13eXNpaHRtbDVdKGh0dHBzOi8vZ2l0aHViLmNvbS9qaG9sbGluZ3dvcnRoL2Jvb3RzdHJhcC13eXNpaHRtbDUpLiAgXG5Zb3Ugc2hvdWxkIGluY2x1ZGUgKiptYW51YWxseSoqIGRpc3RyaWJ1dGl2ZXMgb2YgYHd5c2lodG1sNWAgYW5kIGBib290c3RyYXAtd3lzaWh0bWw1YDpcblxuICAgIDxsaW5rIGhyZWY9XCJqcy9pbnB1dHMtZXh0L3d5c2lodG1sNS9ib290c3RyYXAtd3lzaWh0bWw1LTAuMC4yL2Jvb3RzdHJhcC13eXNpaHRtbDUtMC4wLjIuY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiIHR5cGU9XCJ0ZXh0L2Nzc1wiPjwvbGluaz4gIFxuICAgIDxzY3JpcHQgc3JjPVwianMvaW5wdXRzLWV4dC93eXNpaHRtbDUvYm9vdHN0cmFwLXd5c2lodG1sNS0wLjAuMi93eXNpaHRtbDUtMC4zLjAubWluLmpzXCI+PC9zY3JpcHQ+ICBcbiAgICA8c2NyaXB0IHNyYz1cImpzL2lucHV0cy1leHQvd3lzaWh0bWw1L2Jvb3RzdHJhcC13eXNpaHRtbDUtMC4wLjIvYm9vdHN0cmFwLXd5c2lodG1sNS0wLjAuMi5taW4uanNcIj48L3NjcmlwdD5cbiAgICBcbkFuZCBhbHNvIGluY2x1ZGUgYHd5c2lodG1sNS5qc2AgZnJvbSBgaW5wdXRzLWV4dGAgZGlyZWN0b3J5IG9mIHgtZWRpdGFibGU6XG4gICAgICBcbiAgICA8c2NyaXB0IHNyYz1cImpzL2lucHV0cy1leHQvd3lzaWh0bWw1L3d5c2lodG1sNS5qc1wiPjwvc2NyaXB0PiAgXG5cbioqTm90ZToqKiBJdCdzIGJldHRlciB0byB1c2UgZnJlc2ggYm9vdHN0cmFwLXd5c2lodG1sNSBmcm9tIGl0J3MgW21hc3RlciBicmFuY2hdKGh0dHBzOi8vZ2l0aHViLmNvbS9qaG9sbGluZ3dvcnRoL2Jvb3RzdHJhcC13eXNpaHRtbDUvdHJlZS9tYXN0ZXIvc3JjKSBhcyB0aGVyZSBpcyB1cGRhdGUgZm9yIGNvcnJlY3QgaW1hZ2UgaW5zZXJ0aW9uLiAgICBcbiAgICBcbkBjbGFzcyB3eXNpaHRtbDVcbkBleHRlbmRzIGFic3RyYWN0aW5wdXRcbkBmaW5hbFxuQHNpbmNlIDEuNC4wXG5AZXhhbXBsZVxuPGRpdiBpZD1cImNvbW1lbnRzXCIgZGF0YS10eXBlPVwid3lzaWh0bWw1XCIgZGF0YS1waz1cIjFcIj48aDI+YXdlc29tZTwvaDI+IGNvbW1lbnQhPC9kaXY+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNjb21tZW50cycpLmVkaXRhYmxlKHtcbiAgICAgICAgdXJsOiAnL3Bvc3QnLFxuICAgICAgICB0aXRsZTogJ0VudGVyIGNvbW1lbnRzJ1xuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG5cbiAgd2luZG93Lld5c2lodG1sNSA9IGZ1bmN0aW9uIFd5c2lodG1sNShvcHRpb25zKSB7XG4gICAgdGhpcy5pbml0KCd3eXNpaHRtbDUnLCBvcHRpb25zLCBXeXNpaHRtbDUuZGVmYXVsdHMpO1xuXG4gICAgLy9leHRlbmQgd3lzaWh0bWw1IG1hbnVhbGx5IGFzICQuZXh0ZW5kIG5vdCByZWN1cnNpdmUgXG4gICAgdGhpcy5vcHRpb25zLnd5c2lodG1sNSA9ICQuZXh0ZW5kKHt9LCBXeXNpaHRtbDUuZGVmYXVsdHMud3lzaWh0bWw1LCBvcHRpb25zLnd5c2lodG1sNSk7XG4gIH07XG5cbiAgd2luZG93LiQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KFd5c2lodG1sNSwgd2luZG93LiQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTtcblxuICAkLmV4dGVuZChXeXNpaHRtbDUucHJvdG90eXBlLCB7XG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCksXG4gICAgICAgICAgbXNpZU9sZDtcblxuICAgICAgLy9nZW5lcmF0ZSB1bmlxdWUgaWQgYXMgaXQgcmVxdWlyZWQgZm9yIHd5c2lodG1sNVxuICAgICAgdGhpcy4kaW5wdXQuYXR0cignaWQnLCAndGV4dGFyZWFfJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcblxuICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgdGhpcy5zZXRBdHRyKCdwbGFjZWhvbGRlcicpO1xuXG4gICAgICAvL3Jlc29sdmUgZGVmZmVyZWQgd2hlbiB3aWRnZXQgbG9hZGVkXG4gICAgICAkLmV4dGVuZCh0aGlzLm9wdGlvbnMud3lzaWh0bWw1LCB7XG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy4kaW5wdXQud3lzaWh0bWw1KHRoaXMub3B0aW9ucy53eXNpaHRtbDUpO1xuXG4gICAgICAvKlxuICAgICAgIEluIElFOCB3eXNpaHRtbDUgaWZyYW1lIHN0YXlzIG9uIHRoZSBzYW1lIGxpbmUgd2l0aCBidXR0b25zIHRvb2xiYXIgKGluc2lkZSBwb3BvdmVyKS5cbiAgICAgICBUaGUgb25seSBzb2x1dGlvbiBJIGZvdW5kIGlzIHRvIGFkZCA8YnI+LiBJZiB5b3UgZmluZSBiZXR0ZXIgd2F5LCBwbGVhc2Ugc2VuZCBQUi4gICBcbiAgICAgICovXG4gICAgICBtc2llT2xkID0gL21zaWVcXHMqKDh8N3w2KS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKG1zaWVPbGQpIHtcbiAgICAgICAgdGhpcy4kaW5wdXQuYmVmb3JlKCc8YnI+PGJyPicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgIH0sXG5cbiAgICB2YWx1ZTJodG1sOiBmdW5jdGlvbiB2YWx1ZTJodG1sKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAkKGVsZW1lbnQpLmh0bWwodmFsdWUpO1xuICAgIH0sXG5cbiAgICBodG1sMnZhbHVlOiBmdW5jdGlvbiBodG1sMnZhbHVlKGh0bWwpIHtcbiAgICAgIHJldHVybiBodG1sO1xuICAgIH0sXG5cbiAgICB2YWx1ZTJpbnB1dDogZnVuY3Rpb24gdmFsdWUyaW5wdXQodmFsdWUpIHtcbiAgICAgIHRoaXMuJGlucHV0LmRhdGEoXCJ3eXNpaHRtbDVcIikuZWRpdG9yLnNldFZhbHVlKHZhbHVlLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgYWN0aXZhdGU6IGZ1bmN0aW9uIGFjdGl2YXRlKCkge1xuICAgICAgdGhpcy4kaW5wdXQuZGF0YShcInd5c2lodG1sNVwiKS5lZGl0b3IuZm9jdXMoKTtcbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eSgkZWxlbWVudCkge1xuICAgICAgaWYgKCQudHJpbSgkZWxlbWVudC5odG1sKCkpID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoJC50cmltKCRlbGVtZW50LnRleHQoKSkgIT09ICcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vZS5nLiAnPGltZz4nLCAnPGJyPicsICc8cD48L3A+J1xuICAgICAgICByZXR1cm4gISRlbGVtZW50LmhlaWdodCgpIHx8ICEkZWxlbWVudC53aWR0aCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgV3lzaWh0bWw1LmRlZmF1bHRzID0gJC5leHRlbmQoe30sIHdpbmRvdy4kLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgIC8qKlxuICAgIEBwcm9wZXJ0eSB0cGxcbiAgICBAZGVmYXVsdCA8dGV4dGFyZWE+PC90ZXh0YXJlYT5cbiAgICAqKi9cbiAgICB0cGw6ICc8dGV4dGFyZWE+PC90ZXh0YXJlYT4nLFxuICAgIC8qKlxuICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzXG4gICAgQGRlZmF1bHQgZWRpdGFibGUtd3lzaWh0bWw1XG4gICAgKiovXG4gICAgaW5wdXRjbGFzczogJ2VkaXRhYmxlLXd5c2lodG1sNScsXG4gICAgLyoqXG4gICAgUGxhY2Vob2xkZXIgYXR0cmlidXRlIG9mIGlucHV0LiBTaG93biB3aGVuIGlucHV0IGlzIGVtcHR5LlxuICAgICBAcHJvcGVydHkgcGxhY2Vob2xkZXJcbiAgICBAdHlwZSBzdHJpbmdcbiAgICBAZGVmYXVsdCBudWxsXG4gICAgKiovXG4gICAgcGxhY2Vob2xkZXI6IG51bGwsXG4gICAgLyoqXG4gICAgV3lzaWh0bWw1IGRlZmF1bHQgb3B0aW9ucy4gIFxuICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamhvbGxpbmd3b3J0aC9ib290c3RyYXAtd3lzaWh0bWw1I29wdGlvbnNcbiAgICAgQHByb3BlcnR5IHd5c2lodG1sNVxuICAgIEB0eXBlIG9iamVjdFxuICAgIEBkZWZhdWx0IHtzdHlsZXNoZWV0czogZmFsc2V9XG4gICAgKiovXG4gICAgd3lzaWh0bWw1OiB7XG4gICAgICBzdHlsZXNoZWV0czogZmFsc2VcbiAgICB9XG4gIH0pO1xuXG4gIHdpbmRvdy4kLmZuLmVkaXRhYmxldHlwZXMud3lzaWh0bWw1ID0gV3lzaWh0bWw1O1xufSkod2luZG93LmpRdWVyeSk7XG5cbiFmdW5jdGlvbiAoJCwgd3lzaSkge1xuXG4gIHZhciB0cGwgPSB7XG4gICAgXCJmb250LXN0eWxlc1wiOiBmdW5jdGlvbiBmb250U3R5bGVzKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHNpemUgPSBvcHRpb25zICYmIG9wdGlvbnMuc2l6ZSA/ICcgYnRuLScgKyBvcHRpb25zLnNpemUgOiAnJztcbiAgICAgIHJldHVybiBcIjxsaSBjbGFzcz0nZHJvcGRvd24nPlwiICsgXCI8YSBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0IGRyb3Bkb3duLXRvZ2dsZVwiICsgc2l6ZSArIFwiJyBkYXRhLXRvZ2dsZT0nZHJvcGRvd24nIGhyZWY9JyMnPlwiICsgXCI8aSBjbGFzcz0nZmEgZmEtZm9udCc+PC9pPiZuYnNwOzxzcGFuIGNsYXNzPSdjdXJyZW50LWZvbnQnPlwiICsgbG9jYWxlLmZvbnRfc3R5bGVzLm5vcm1hbCArIFwiPC9zcGFuPiZuYnNwOzxiIGNsYXNzPSdjYXJldCc+PC9iPlwiICsgXCI8L2E+XCIgKyBcIjx1bCBjbGFzcz0nZHJvcGRvd24tbWVudSc+XCIgKyBcIjxsaT48YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JtYXRCbG9jaycgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0nZGl2JyB0YWJpbmRleD0nLTEnPlwiICsgbG9jYWxlLmZvbnRfc3R5bGVzLm5vcm1hbCArIFwiPC9hPjwvbGk+XCIgKyBcIjxsaT48YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JtYXRCbG9jaycgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0naDEnIHRhYmluZGV4PSctMSc+XCIgKyBsb2NhbGUuZm9udF9zdHlsZXMuaDEgKyBcIjwvYT48L2xpPlwiICsgXCI8bGk+PGEgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nZm9ybWF0QmxvY2snIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J2gyJyB0YWJpbmRleD0nLTEnPlwiICsgbG9jYWxlLmZvbnRfc3R5bGVzLmgyICsgXCI8L2E+PC9saT5cIiArIFwiPGxpPjxhIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2Zvcm1hdEJsb2NrJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdoMycgdGFiaW5kZXg9Jy0xJz5cIiArIGxvY2FsZS5mb250X3N0eWxlcy5oMyArIFwiPC9hPjwvbGk+XCIgKyBcIjwvdWw+XCIgKyBcIjwvbGk+XCI7XG4gICAgfSxcblxuICAgIFwiZW1waGFzaXNcIjogZnVuY3Rpb24gZW1waGFzaXMobG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2l6ZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaXplID8gJyBidG4tJyArIG9wdGlvbnMuc2l6ZSA6ICcnO1xuICAgICAgcmV0dXJuIFwiPGxpPlwiICsgXCI8ZGl2IGNsYXNzPSdidG4tZ3JvdXAnPlwiICsgXCI8YSBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0XCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2JvbGQnIHRpdGxlPSdDVFJMK0InIHRhYmluZGV4PSctMSc+XCIgKyBsb2NhbGUuZW1waGFzaXMuYm9sZCArIFwiPC9hPlwiICsgXCI8YSBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0XCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2l0YWxpYycgdGl0bGU9J0NUUkwrSScgdGFiaW5kZXg9Jy0xJz5cIiArIGxvY2FsZS5lbXBoYXNpcy5pdGFsaWMgKyBcIjwvYT5cIiArIFwiPGEgY2xhc3M9J2J0biBidG4tZGVmYXVsdFwiICsgc2l6ZSArIFwiJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSd1bmRlcmxpbmUnIHRpdGxlPSdDVFJMK1UnIHRhYmluZGV4PSctMSc+XCIgKyBsb2NhbGUuZW1waGFzaXMudW5kZXJsaW5lICsgXCI8L2E+XCIgKyBcIjwvZGl2PlwiICsgXCI8L2xpPlwiO1xuICAgIH0sXG5cbiAgICBcImxpc3RzXCI6IGZ1bmN0aW9uIGxpc3RzKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHNpemUgPSBvcHRpb25zICYmIG9wdGlvbnMuc2l6ZSA/ICcgYnRuLScgKyBvcHRpb25zLnNpemUgOiAnJztcbiAgICAgIHJldHVybiBcIjxsaT5cIiArIFwiPGRpdiBjbGFzcz0nYnRuLWdyb3VwJz5cIiArIFwiPGEgY2xhc3M9J2J0biBidG4tZGVmYXVsdFwiICsgc2l6ZSArIFwiJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdpbnNlcnRVbm9yZGVyZWRMaXN0JyB0aXRsZT0nXCIgKyBsb2NhbGUubGlzdHMudW5vcmRlcmVkICsgXCInIHRhYmluZGV4PSctMSc+PGkgY2xhc3M9J2ZhIGZhLWxpc3QnPjwvaT48L2E+XCIgKyBcIjxhIGNsYXNzPSdidG4gYnRuLWRlZmF1bHRcIiArIHNpemUgKyBcIicgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0naW5zZXJ0T3JkZXJlZExpc3QnIHRpdGxlPSdcIiArIGxvY2FsZS5saXN0cy5vcmRlcmVkICsgXCInIHRhYmluZGV4PSctMSc+PGkgY2xhc3M9J2ZhIGZhLXRoLWxpc3QnPjwvaT48L2E+XCIgKyBcIjxhIGNsYXNzPSdidG4gYnRuLWRlZmF1bHRcIiArIHNpemUgKyBcIicgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nY2xlYXInIHRpdGxlPSdiYW4nIHRhYmluZGV4PSctMSc+PGkgY2xhc3M9J2ZhIGZhLWJhbic+PC9pPjwvYT5cIiArIFwiPC9kaXY+XCIgKyBcIjwvbGk+XCI7XG4gICAgfSxcblxuICAgIFwibGlua1wiOiBmdW5jdGlvbiBsaW5rKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHNpemUgPSBvcHRpb25zICYmIG9wdGlvbnMuc2l6ZSA/ICcgYnRuLScgKyBvcHRpb25zLnNpemUgOiAnJztcbiAgICAgIHJldHVybiBcIjxsaT5cIiArIFwiPGRpdiBjbGFzcz0nYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtbGluay1tb2RhbCBtb2RhbCBoaWRlIGZhZGUnPlwiICsgXCI8ZGl2IGNsYXNzPSdtb2RhbC1oZWFkZXInPlwiICsgXCI8YSBjbGFzcz0nY2xvc2UnIGRhdGEtZGlzbWlzcz0nbW9kYWwnPiZ0aW1lczs8L2E+XCIgKyBcIjxoMz5cIiArIGxvY2FsZS5saW5rLmluc2VydCArIFwiPC9oMz5cIiArIFwiPC9kaXY+XCIgKyBcIjxkaXYgY2xhc3M9J21vZGFsLWJvZHknPlwiICsgXCI8aW5wdXQgdmFsdWU9J2h0dHA6Ly8nIGNsYXNzPSdib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1saW5rLXVybCBpbnB1dC14bGFyZ2UnPlwiICsgXCI8L2Rpdj5cIiArIFwiPGRpdiBjbGFzcz0nbW9kYWwtZm9vdGVyJz5cIiArIFwiPGEgaHJlZj0nIycgY2xhc3M9J2J0biBidG4tZGVmYXVsdCcgZGF0YS1kaXNtaXNzPSdtb2RhbCc+XCIgKyBsb2NhbGUubGluay5jYW5jZWwgKyBcIjwvYT5cIiArIFwiPGEgaHJlZj0nIycgY2xhc3M9J2J0biBidG4tcHJpbWFyeScgZGF0YS1kaXNtaXNzPSdtb2RhbCc+XCIgKyBsb2NhbGUubGluay5pbnNlcnQgKyBcIjwvYT5cIiArIFwiPC9kaXY+XCIgKyBcIjwvZGl2PlwiICsgXCI8YSBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0XCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2NyZWF0ZUxpbmsnIHRpdGxlPSdcIiArIGxvY2FsZS5saW5rLmluc2VydCArIFwiJyB0YWJpbmRleD0nLTEnPjxpIGNsYXNzPSdmYSBmYS1zaGFyZSc+PC9pPjwvYT5cIiArIFwiPC9saT5cIjtcbiAgICB9LFxuXG4gICAgXCJpbWFnZVwiOiBmdW5jdGlvbiBpbWFnZShsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaXplID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpemUgPyAnIGJ0bi0nICsgb3B0aW9ucy5zaXplIDogJyc7XG4gICAgICByZXR1cm4gXCI8bGk+XCIgKyBcIjxkaXYgY2xhc3M9J2Jvb3RzdHJhcC13eXNpaHRtbDUtaW5zZXJ0LWltYWdlLW1vZGFsIG1vZGFsIGhpZGUgZmFkZSc+XCIgKyBcIjxkaXYgY2xhc3M9J21vZGFsLWhlYWRlcic+XCIgKyBcIjxhIGNsYXNzPSdjbG9zZScgZGF0YS1kaXNtaXNzPSdtb2RhbCc+JnRpbWVzOzwvYT5cIiArIFwiPGgzPlwiICsgbG9jYWxlLmltYWdlLmluc2VydCArIFwiPC9oMz5cIiArIFwiPC9kaXY+XCIgKyBcIjxkaXYgY2xhc3M9J21vZGFsLWJvZHknPlwiICsgXCI8aW5wdXQgdmFsdWU9J2h0dHA6Ly8nIGNsYXNzPSdib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1pbWFnZS11cmwgaW5wdXQteGxhcmdlJz5cIiArIFwiPC9kaXY+XCIgKyBcIjxkaXYgY2xhc3M9J21vZGFsLWZvb3Rlcic+XCIgKyBcIjxhIGhyZWY9JyMnIGNsYXNzPSdidG4gYnRuLWRlZmF1bHQnIGRhdGEtZGlzbWlzcz0nbW9kYWwnPlwiICsgbG9jYWxlLmltYWdlLmNhbmNlbCArIFwiPC9hPlwiICsgXCI8YSBocmVmPScjJyBjbGFzcz0nYnRuIGJ0bi1wcmltYXJ5JyBkYXRhLWRpc21pc3M9J21vZGFsJz5cIiArIGxvY2FsZS5pbWFnZS5pbnNlcnQgKyBcIjwvYT5cIiArIFwiPC9kaXY+XCIgKyBcIjwvZGl2PlwiICsgXCI8YSBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0XCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2luc2VydEltYWdlJyB0aXRsZT0nXCIgKyBsb2NhbGUuaW1hZ2UuaW5zZXJ0ICsgXCInIHRhYmluZGV4PSctMSc+PGkgY2xhc3M9J2ZhIGZhLXBpY3R1cmUnPjwvaT48L2E+XCIgKyBcIjwvbGk+XCI7XG4gICAgfSxcblxuICAgIFwiaHRtbFwiOiBmdW5jdGlvbiBodG1sKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHNpemUgPSBvcHRpb25zICYmIG9wdGlvbnMuc2l6ZSA/ICcgYnRuLScgKyBvcHRpb25zLnNpemUgOiAnJztcbiAgICAgIHJldHVybiBcIjxsaT5cIiArIFwiPGRpdiBjbGFzcz0nYnRuLWdyb3VwJz5cIiArIFwiPGEgY2xhc3M9J2J0biBidG4tZGVmYXVsdFwiICsgc2l6ZSArIFwiJyBkYXRhLXd5c2lodG1sNS1hY3Rpb249J2NoYW5nZV92aWV3JyB0aXRsZT0nXCIgKyBsb2NhbGUuaHRtbC5lZGl0ICsgXCInIHRhYmluZGV4PSctMSc+PGkgY2xhc3M9J2ZhIGZhLXBlbmNpbCc+PC9pPjwvYT5cIiArIFwiPC9kaXY+XCIgKyBcIjwvbGk+XCI7XG4gICAgfSxcblxuICAgIFwiY29sb3JcIjogZnVuY3Rpb24gY29sb3IobG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2l6ZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaXplID8gJyBidG4tJyArIG9wdGlvbnMuc2l6ZSA6ICcnO1xuICAgICAgcmV0dXJuIFwiPGxpIGNsYXNzPSdkcm9wZG93bic+XCIgKyBcIjxhIGNsYXNzPSdidG4gYnRuLWRlZmF1bHQgZHJvcGRvd24tdG9nZ2xlXCIgKyBzaXplICsgXCInIGRhdGEtdG9nZ2xlPSdkcm9wZG93bicgaHJlZj0nIycgdGFiaW5kZXg9Jy0xJz5cIiArIFwiPHNwYW4gY2xhc3M9J2N1cnJlbnQtY29sb3InPuWOn+iJsjwvc3Bhbj4mbmJzcDs8YiBjbGFzcz0nY2FyZXQnPjwvYj5cIiArIFwiPC9hPlwiICsgXCI8dWwgY2xhc3M9J2Ryb3Bkb3duLW1lbnUnPlwiICsgXCI8bGk+PGRpdiBjbGFzcz0nd3lzaWh0bWw1LWNvbG9ycycgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0nY2xlYXInPjwvZGl2PjxhIGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzLXRpdGxlJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JlQ29sb3InIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J2NsZWFyJz5cIiArIGxvY2FsZS5jb2xvdXJzLmNsZWFyICsgXCI8L2E+PC9saT5cIiArIFwiPGxpPjxkaXYgY2xhc3M9J3d5c2lodG1sNS1jb2xvcnMnIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J2ZpcnN0Jz48L2Rpdj48YSBjbGFzcz0nd3lzaWh0bWw1LWNvbG9ycy10aXRsZScgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nZm9yZUNvbG9yJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdmaXJzdCc+XCIgKyBsb2NhbGUuY29sb3Vycy5maXJzdCArIFwiPC9hPjwvbGk+XCIgKyBcIjxsaT48ZGl2IGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdzZWNvbmQnPjwvZGl2PjxhIGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzLXRpdGxlJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JlQ29sb3InIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J3NlY29uZCc+XCIgKyBsb2NhbGUuY29sb3Vycy5zZWNvbmQgKyBcIjwvYT48L2xpPlwiICsgXCI8bGk+PGRpdiBjbGFzcz0nd3lzaWh0bWw1LWNvbG9ycycgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0ndGhyZWUnPjwvZGl2PjxhIGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzLXRpdGxlJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JlQ29sb3InIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J3RocmVlJz5cIiArIGxvY2FsZS5jb2xvdXJzLnRocmVlICsgXCI8L2E+PC9saT5cIiArIFwiPC91bD5cIiArIFwiPC9saT5cIjtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHRlbXBsYXRlcyA9IGZ1bmN0aW9uIHRlbXBsYXRlcyhrZXksIGxvY2FsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0cGxba2V5XShsb2NhbGUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHZhciBXeXNpaHRtbDUgPSBmdW5jdGlvbiBXeXNpaHRtbDUoZWwsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdmFyIHRvb2xiYXJPcHRzID0gb3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucztcbiAgICBmb3IgKHZhciB0IGluIHRvb2xiYXJPcHRzLmN1c3RvbVRlbXBsYXRlcykge1xuICAgICAgdHBsW3RdID0gdG9vbGJhck9wdHMuY3VzdG9tVGVtcGxhdGVzW3RdO1xuICAgIH1cbiAgICB0aGlzLnRvb2xiYXIgPSB0aGlzLmNyZWF0ZVRvb2xiYXIoZWwsIHRvb2xiYXJPcHRzKTtcbiAgICB0aGlzLmVkaXRvciA9IHRoaXMuY3JlYXRlRWRpdG9yKG9wdGlvbnMpO1xuXG4gICAgd2luZG93LmVkaXRvciA9IHRoaXMuZWRpdG9yO1xuXG4gICAgJCgnaWZyYW1lLnd5c2lodG1sNS1zYW5kYm94JykuZWFjaChmdW5jdGlvbiAoaSwgZWwpIHtcbiAgICAgICQoZWwuY29udGVudFdpbmRvdykub2ZmKCdmb2N1cy53eXNpaHRtbDUnKS5vbih7XG4gICAgICAgICdmb2N1cy53eXNpaHRtbDUnOiBmdW5jdGlvbiBmb2N1c1d5c2lodG1sNSgpIHtcbiAgICAgICAgICAkKCdsaS5kcm9wZG93bicpLnJlbW92ZUNsYXNzKCdvcGVuJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFd5c2lodG1sNS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogV3lzaWh0bWw1LFxuXG4gICAgY3JlYXRlRWRpdG9yOiBmdW5jdGlvbiBjcmVhdGVFZGl0b3Iob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIEFkZCB0aGUgdG9vbGJhciB0byBhIGNsb25lIG9mIHRoZSBvcHRpb25zIG9iamVjdCBzbyBtdWx0aXBsZSBpbnN0YW5jZXNcbiAgICAgIC8vIG9mIHRoZSBXWUlTWVdHIGRvbid0IGJyZWFrIGJlY2F1c2UgXCJ0b29sYmFyXCIgaXMgYWxyZWFkeSBkZWZpbmVkXG4gICAgICBvcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy50b29sYmFyID0gdGhpcy50b29sYmFyWzBdO1xuXG4gICAgICB2YXIgZWRpdG9yID0gbmV3IHd5c2lodG1sNS5FZGl0b3IodGhpcy5lbFswXSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBvcHRpb25zLmV2ZW50cykge1xuICAgICAgICAgIGVkaXRvci5vbihldmVudE5hbWUsIG9wdGlvbnMuZXZlbnRzW2V2ZW50TmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRpdG9yO1xuICAgIH0sXG5cbiAgICBjcmVhdGVUb29sYmFyOiBmdW5jdGlvbiBjcmVhdGVUb29sYmFyKGVsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgdG9vbGJhciA9ICQoXCI8dWwvPlwiLCB7XG4gICAgICAgICdjbGFzcyc6IFwid3lzaWh0bWw1LXRvb2xiYXJcIixcbiAgICAgICAgJ3N0eWxlJzogXCJkaXNwbGF5Om5vbmVcIlxuICAgICAgfSk7XG4gICAgICB2YXIgY3VsdHVyZSA9IG9wdGlvbnMubG9jYWxlIHx8IGRlZmF1bHRPcHRpb25zLmxvY2FsZSB8fCBcImVuXCI7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gd2luZG93LiQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvcHRpb25zW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChvcHRpb25zW2tleV0gPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBkZWZhdWx0T3B0aW9uc1trZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgdG9vbGJhci5hcHBlbmQodGVtcGxhdGVzKGtleSwgbG9jYWxlW2N1bHR1cmVdLCBvcHRpb25zKSk7XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSBcImh0bWxcIikge1xuICAgICAgICAgICAgdGhpcy5pbml0SHRtbCh0b29sYmFyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSBcImxpbmtcIikge1xuICAgICAgICAgICAgdGhpcy5pbml0SW5zZXJ0TGluayh0b29sYmFyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdEluc2VydEltYWdlKHRvb2xiYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50b29sYmFyKSB7XG4gICAgICAgIGZvciAoa2V5IGluIG9wdGlvbnMudG9vbGJhcikge1xuICAgICAgICAgIHRvb2xiYXIuYXBwZW5kKG9wdGlvbnMudG9vbGJhcltrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b29sYmFyLmZpbmQoXCJhW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2Zvcm1hdEJsb2NrJ11cIikuY2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICAgICAgdmFyIGVsID0gJCh0YXJnZXQpO1xuICAgICAgICBzZWxmLnRvb2xiYXIuZmluZCgnLmN1cnJlbnQtZm9udCcpLnRleHQoZWwuaHRtbCgpKTtcbiAgICAgIH0pO1xuXG4gICAgICB0b29sYmFyLmZpbmQoXCJhW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2ZvcmVDb2xvciddXCIpLmNsaWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgICAgIHZhciBlbCA9ICQodGFyZ2V0KTtcbiAgICAgICAgc2VsZi50b29sYmFyLmZpbmQoJy5jdXJyZW50LWNvbG9yJykudGV4dChlbC5odG1sKCkpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZWwuYmVmb3JlKHRvb2xiYXIpO1xuXG4gICAgICByZXR1cm4gdG9vbGJhcjtcbiAgICB9LFxuXG4gICAgaW5pdEh0bWw6IGZ1bmN0aW9uIGluaXRIdG1sKHRvb2xiYXIpIHtcbiAgICAgIHZhciBjaGFuZ2VWaWV3U2VsZWN0b3IgPSBcImFbZGF0YS13eXNpaHRtbDUtYWN0aW9uPSdjaGFuZ2VfdmlldyddXCI7XG4gICAgICB0b29sYmFyLmZpbmQoY2hhbmdlVmlld1NlbGVjdG9yKS5jbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICB0b29sYmFyLmZpbmQoJ2EuYnRuJykubm90KGNoYW5nZVZpZXdTZWxlY3RvcikudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJyk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5pdEluc2VydEltYWdlOiBmdW5jdGlvbiBpbml0SW5zZXJ0SW1hZ2UodG9vbGJhcikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGluc2VydEltYWdlTW9kYWwgPSB0b29sYmFyLmZpbmQoJy5ib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1pbWFnZS1tb2RhbCcpO1xuICAgICAgdmFyIHVybElucHV0ID0gaW5zZXJ0SW1hZ2VNb2RhbC5maW5kKCcuYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtaW1hZ2UtdXJsJyk7XG4gICAgICB2YXIgaW5zZXJ0QnV0dG9uID0gaW5zZXJ0SW1hZ2VNb2RhbC5maW5kKCdhLmJ0bi1wcmltYXJ5Jyk7XG4gICAgICB2YXIgaW5pdGlhbFZhbHVlID0gdXJsSW5wdXQudmFsKCk7XG4gICAgICB2YXIgY2FyZXRCb29rbWFyaztcblxuICAgICAgdmFyIGluc2VydEltYWdlID0gZnVuY3Rpb24gaW5zZXJ0SW1hZ2UoKSB7XG4gICAgICAgIHZhciB1cmwgPSB1cmxJbnB1dC52YWwoKTtcbiAgICAgICAgdXJsSW5wdXQudmFsKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIHNlbGYuZWRpdG9yLmN1cnJlbnRWaWV3LmVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgaWYgKGNhcmV0Qm9va21hcmspIHtcbiAgICAgICAgICBzZWxmLmVkaXRvci5jb21wb3Nlci5zZWxlY3Rpb24uc2V0Qm9va21hcmsoY2FyZXRCb29rbWFyayk7XG4gICAgICAgICAgY2FyZXRCb29rbWFyayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5lZGl0b3IuY29tcG9zZXIuY29tbWFuZHMuZXhlYyhcImluc2VydEltYWdlXCIsIHVybCk7XG4gICAgICB9O1xuXG4gICAgICB1cmxJbnB1dC5rZXlwcmVzcyhmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS53aGljaCA9PSAxMykge1xuICAgICAgICAgIGluc2VydEltYWdlKCk7XG4gICAgICAgICAgaW5zZXJ0SW1hZ2VNb2RhbC5tb2RhbCgnaGlkZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaW5zZXJ0QnV0dG9uLmNsaWNrKGluc2VydEltYWdlKTtcblxuICAgICAgaW5zZXJ0SW1hZ2VNb2RhbC5vbignc2hvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHVybElucHV0LmZvY3VzKCk7XG4gICAgICB9KTtcblxuICAgICAgaW5zZXJ0SW1hZ2VNb2RhbC5vbignaGlkZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5lZGl0b3IuY3VycmVudFZpZXcuZWxlbWVudC5mb2N1cygpO1xuICAgICAgfSk7XG5cbiAgICAgIHRvb2xiYXIuZmluZCgnYVtkYXRhLXd5c2lodG1sNS1jb21tYW5kPWluc2VydEltYWdlXScpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUJ1dHRvbiA9ICQodGhpcykuaGFzQ2xhc3MoXCJ3eXNpaHRtbDUtY29tbWFuZC1hY3RpdmVcIik7XG5cbiAgICAgICAgaWYgKCFhY3RpdmVCdXR0b24pIHtcbiAgICAgICAgICBzZWxmLmVkaXRvci5jdXJyZW50Vmlldy5lbGVtZW50LmZvY3VzKGZhbHNlKTtcbiAgICAgICAgICBjYXJldEJvb2ttYXJrID0gc2VsZi5lZGl0b3IuY29tcG9zZXIuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCk7XG4gICAgICAgICAgaW5zZXJ0SW1hZ2VNb2RhbC5hcHBlbmRUbygnYm9keScpLm1vZGFsKCdzaG93Jyk7XG4gICAgICAgICAgaW5zZXJ0SW1hZ2VNb2RhbC5vbignY2xpY2suZGlzbWlzcy5tb2RhbCcsICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpbml0SW5zZXJ0TGluazogZnVuY3Rpb24gaW5pdEluc2VydExpbmsodG9vbGJhcikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGluc2VydExpbmtNb2RhbCA9IHRvb2xiYXIuZmluZCgnLmJvb3RzdHJhcC13eXNpaHRtbDUtaW5zZXJ0LWxpbmstbW9kYWwnKTtcbiAgICAgIHZhciB1cmxJbnB1dCA9IGluc2VydExpbmtNb2RhbC5maW5kKCcuYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtbGluay11cmwnKTtcbiAgICAgIHZhciBpbnNlcnRCdXR0b24gPSBpbnNlcnRMaW5rTW9kYWwuZmluZCgnYS5idG4tcHJpbWFyeScpO1xuICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IHVybElucHV0LnZhbCgpO1xuICAgICAgdmFyIGNhcmV0Qm9va21hcms7XG5cbiAgICAgIHZhciBpbnNlcnRMaW5rID0gZnVuY3Rpb24gaW5zZXJ0TGluaygpIHtcbiAgICAgICAgdmFyIHVybCA9IHVybElucHV0LnZhbCgpO1xuICAgICAgICB1cmxJbnB1dC52YWwoaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgc2VsZi5lZGl0b3IuY3VycmVudFZpZXcuZWxlbWVudC5mb2N1cygpO1xuICAgICAgICBpZiAoY2FyZXRCb29rbWFyaykge1xuICAgICAgICAgIHNlbGYuZWRpdG9yLmNvbXBvc2VyLnNlbGVjdGlvbi5zZXRCb29rbWFyayhjYXJldEJvb2ttYXJrKTtcbiAgICAgICAgICBjYXJldEJvb2ttYXJrID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmVkaXRvci5jb21wb3Nlci5jb21tYW5kcy5leGVjKFwiY3JlYXRlTGlua1wiLCB7XG4gICAgICAgICAgaHJlZjogdXJsLFxuICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICByZWw6IFwibm9mb2xsb3dcIlxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB2YXIgcHJlc3NlZEVudGVyID0gZmFsc2U7XG5cbiAgICAgIHVybElucHV0LmtleXByZXNzKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLndoaWNoID09IDEzKSB7XG4gICAgICAgICAgaW5zZXJ0TGluaygpO1xuICAgICAgICAgIGluc2VydExpbmtNb2RhbC5tb2RhbCgnaGlkZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaW5zZXJ0QnV0dG9uLmNsaWNrKGluc2VydExpbmspO1xuXG4gICAgICBpbnNlcnRMaW5rTW9kYWwub24oJ3Nob3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB1cmxJbnB1dC5mb2N1cygpO1xuICAgICAgfSk7XG5cbiAgICAgIGluc2VydExpbmtNb2RhbC5vbignaGlkZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5lZGl0b3IuY3VycmVudFZpZXcuZWxlbWVudC5mb2N1cygpO1xuICAgICAgfSk7XG5cbiAgICAgIHRvb2xiYXIuZmluZCgnYVtkYXRhLXd5c2lodG1sNS1jb21tYW5kPWNyZWF0ZUxpbmtdJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYWN0aXZlQnV0dG9uID0gJCh0aGlzKS5oYXNDbGFzcyhcInd5c2lodG1sNS1jb21tYW5kLWFjdGl2ZVwiKTtcblxuICAgICAgICBpZiAoIWFjdGl2ZUJ1dHRvbikge1xuICAgICAgICAgIHNlbGYuZWRpdG9yLmN1cnJlbnRWaWV3LmVsZW1lbnQuZm9jdXMoZmFsc2UpO1xuICAgICAgICAgIGNhcmV0Qm9va21hcmsgPSBzZWxmLmVkaXRvci5jb21wb3Nlci5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKTtcbiAgICAgICAgICBpbnNlcnRMaW5rTW9kYWwuYXBwZW5kVG8oJ2JvZHknKS5tb2RhbCgnc2hvdycpO1xuICAgICAgICAgIGluc2VydExpbmtNb2RhbC5vbignY2xpY2suZGlzbWlzcy5tb2RhbCcsICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyB0aGVzZSBkZWZpbmUgb3VyIHB1YmxpYyBhcGlcbiAgdmFyIG1ldGhvZHMgPSB7XG4gICAgcmVzZXREZWZhdWx0czogZnVuY3Rpb24gcmVzZXREZWZhdWx0cygpIHtcbiAgICAgIHdpbmRvdy4kLmZuLnd5c2lodG1sNS5kZWZhdWx0T3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCB3aW5kb3cuJC5mbi53eXNpaHRtbDUuZGVmYXVsdE9wdGlvbnNDYWNoZSk7XG4gICAgfSxcbiAgICBieXBhc3NEZWZhdWx0czogZnVuY3Rpb24gYnlwYXNzRGVmYXVsdHMob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICR0aGlzLmRhdGEoJ3d5c2lodG1sNScsIG5ldyBXeXNpaHRtbDUoJHRoaXMsIG9wdGlvbnMpKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2hhbGxvd0V4dGVuZDogZnVuY3Rpb24gc2hhbGxvd0V4dGVuZChvcHRpb25zKSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgd2luZG93LiQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHJldHVybiBtZXRob2RzLmJ5cGFzc0RlZmF1bHRzLmFwcGx5KHRoYXQsIFtzZXR0aW5nc10pO1xuICAgIH0sXG4gICAgZGVlcEV4dGVuZDogZnVuY3Rpb24gZGVlcEV4dGVuZChvcHRpb25zKSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSAkLmV4dGVuZCh0cnVlLCB7fSwgd2luZG93LiQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHJldHVybiBtZXRob2RzLmJ5cGFzc0RlZmF1bHRzLmFwcGx5KHRoYXQsIFtzZXR0aW5nc10pO1xuICAgIH0sXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICByZXR1cm4gbWV0aG9kcy5zaGFsbG93RXh0ZW5kLmFwcGx5KHRoYXQsIFtvcHRpb25zXSk7XG4gICAgfVxuICB9O1xuXG4gIHdpbmRvdy4kLmZuLnd5c2lodG1sNSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICBpZiAobWV0aG9kc1ttZXRob2RdKSB7XG4gICAgICByZXR1cm4gbWV0aG9kc1ttZXRob2RdLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBtZXRob2QgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihtZXRob2QpKSA9PT0gJ29iamVjdCcgfHwgIW1ldGhvZCkge1xuICAgICAgcmV0dXJuIG1ldGhvZHMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkLmVycm9yKCdNZXRob2QgJyArIG1ldGhvZCArICcgZG9lcyBub3QgZXhpc3Qgb24galF1ZXJ5Lnd5c2lodG1sNScpO1xuICAgIH1cbiAgfTtcblxuICB3aW5kb3cuJC5mbi53eXNpaHRtbDUuQ29uc3RydWN0b3IgPSBXeXNpaHRtbDU7XG5cbiAgd2luZG93LiQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zID0ge1xuICAgIFwiZm9udC1zdHlsZXNcIjogdHJ1ZSxcbiAgICBcImNvbG9yXCI6IGZhbHNlLFxuICAgIFwiZW1waGFzaXNcIjogdHJ1ZSxcbiAgICBcImxpc3RzXCI6IHRydWUsXG4gICAgXCJodG1sXCI6IGZhbHNlLFxuICAgIFwibGlua1wiOiB0cnVlLFxuICAgIFwiaW1hZ2VcIjogdHJ1ZSxcbiAgICBldmVudHM6IHt9LFxuICAgIHBhcnNlclJ1bGVzOiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgIC8vIChwYXRoX3RvX3Byb2plY3QvbGliL2Nzcy93eXNpd3lnLWNvbG9yLmNzcylcbiAgICAgICAgXCJ3eXNpd3lnLWNvbG9yLWNsZWFyXCI6IDEsXG4gICAgICAgIFwid3lzaXd5Zy1jb2xvci1maXJzdFwiOiAxLFxuICAgICAgICBcInd5c2l3eWctY29sb3Itc2Vjb25kXCI6IDEsXG4gICAgICAgIFwid3lzaXd5Zy1jb2xvci10aHJlZVwiOiAxXG4gICAgICB9LFxuICAgICAgdGFnczoge1xuICAgICAgICBcImJcIjoge30sXG4gICAgICAgIFwiaVwiOiB7fSxcbiAgICAgICAgXCJiclwiOiB7fSxcbiAgICAgICAgXCJvbFwiOiB7fSxcbiAgICAgICAgXCJ1bFwiOiB7fSxcbiAgICAgICAgXCJsaVwiOiB7fSxcbiAgICAgICAgXCJoMVwiOiB7fSxcbiAgICAgICAgXCJoMlwiOiB7fSxcbiAgICAgICAgXCJoM1wiOiB7fSxcbiAgICAgICAgXCJibG9ja3F1b3RlXCI6IHt9LFxuICAgICAgICBcInVcIjogMSxcbiAgICAgICAgXCJpbWdcIjoge1xuICAgICAgICAgIFwiY2hlY2tfYXR0cmlidXRlc1wiOiB7XG4gICAgICAgICAgICBcIndpZHRoXCI6IFwibnVtYmVyc1wiLFxuICAgICAgICAgICAgXCJhbHRcIjogXCJhbHRcIixcbiAgICAgICAgICAgIFwic3JjXCI6IFwidXJsXCIsXG4gICAgICAgICAgICBcImhlaWdodFwiOiBcIm51bWJlcnNcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJhXCI6IHtcbiAgICAgICAgICBzZXRfYXR0cmlidXRlczoge1xuICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgcmVsOiBcIm5vZm9sbG93XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoZWNrX2F0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIGhyZWY6IFwidXJsXCIgLy8gaW1wb3J0YW50IHRvIGF2b2lkIFhTU1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzcGFuXCI6IDEsXG4gICAgICAgIFwiZGl2XCI6IDEsXG4gICAgICAgIC8vIHRvIGFsbG93IHNhdmUgYW5kIGVkaXQgZmlsZXMgd2l0aCBjb2RlIHRhZyBoYWNrc1xuICAgICAgICBcImNvZGVcIjogMSxcbiAgICAgICAgXCJwcmVcIjogMVxuICAgICAgfVxuICAgIH0sXG4gICAgc3R5bGVzaGVldHM6IFtcIi4vbGliL2Nzcy93eXNpd3lnLWNvbG9yLmNzc1wiXSwgLy8gKHBhdGhfdG9fcHJvamVjdC9saWIvY3NzL3d5c2l3eWctY29sb3IuY3NzKVxuICAgIGxvY2FsZTogXCJlblwiXG4gIH07XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cuJC5mbi53eXNpaHRtbDUuZGVmYXVsdE9wdGlvbnNDYWNoZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuJC5mbi53eXNpaHRtbDUuZGVmYXVsdE9wdGlvbnNDYWNoZSA9ICQuZXh0ZW5kKHRydWUsIHt9LCB3aW5kb3cuJC5mbi53eXNpaHRtbDUuZGVmYXVsdE9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIGxvY2FsZSA9IHdpbmRvdy4kLmZuLnd5c2lodG1sNS5sb2NhbGUgPSB7XG4gICAgZW46IHtcbiAgICAgIGZvbnRfc3R5bGVzOiB7XG4gICAgICAgIG5vcm1hbDogXCJOb3JtYWwgdGV4dFwiLFxuICAgICAgICBoMTogXCJIZWFkaW5nIDFcIixcbiAgICAgICAgaDI6IFwiSGVhZGluZyAyXCIsXG4gICAgICAgIGgzOiBcIkhlYWRpbmcgM1wiXG4gICAgICB9LFxuICAgICAgZW1waGFzaXM6IHtcbiAgICAgICAgYm9sZDogXCJCb2xkXCIsXG4gICAgICAgIGl0YWxpYzogXCJJdGFsaWNcIixcbiAgICAgICAgdW5kZXJsaW5lOiBcIlVuZGVybGluZVwiXG4gICAgICB9LFxuICAgICAgbGlzdHM6IHtcbiAgICAgICAgdW5vcmRlcmVkOiBcIlVub3JkZXJlZCBsaXN0XCIsXG4gICAgICAgIG9yZGVyZWQ6IFwiT3JkZXJlZCBsaXN0XCIsXG4gICAgICAgIG91dGRlbnQ6IFwiT3V0ZGVudFwiLFxuICAgICAgICBpbmRlbnQ6IFwiSW5kZW50XCJcbiAgICAgIH0sXG4gICAgICBsaW5rOiB7XG4gICAgICAgIGluc2VydDogXCJJbnNlcnQgbGlua1wiLFxuICAgICAgICBjYW5jZWw6IFwiQ2FuY2VsXCJcbiAgICAgIH0sXG4gICAgICBpbWFnZToge1xuICAgICAgICBpbnNlcnQ6IFwiSW5zZXJ0IGltYWdlXCIsXG4gICAgICAgIGNhbmNlbDogXCJDYW5jZWxcIlxuICAgICAgfSxcbiAgICAgIGh0bWw6IHtcbiAgICAgICAgZWRpdDogXCJFZGl0IEhUTUxcIlxuICAgICAgfSxcbiAgICAgIGNvbG91cnM6IHtcbiAgICAgICAgY2xlYXI6IFwiQ2xlYXJcIixcbiAgICAgICAgZmlyc3Q6IFwi6aaW6YCJXCIsXG4gICAgICAgIHNlY29uZDogXCLmrKHpgIlcIixcbiAgICAgICAgdGhyZWU6IFwi5aSH6YCJXCIsXG4gICAgICAgIGJsYWNrOiBcIkJsYWNrXCIsXG4gICAgICAgIHNpbHZlcjogXCJTaWx2ZXJcIixcbiAgICAgICAgZ3JheTogXCJHcmV5XCIsXG4gICAgICAgIG1hcm9vbjogXCJNYXJvb25cIixcbiAgICAgICAgcmVkOiBcIlJlZFwiLFxuICAgICAgICBwdXJwbGU6IFwiUHVycGxlXCIsXG4gICAgICAgIGdyZWVuOiBcIkdyZWVuXCIsXG4gICAgICAgIG9saXZlOiBcIk9saXZlXCIsXG4gICAgICAgIG5hdnk6IFwiTmF2eVwiLFxuICAgICAgICBibHVlOiBcIkJsdWVcIixcbiAgICAgICAgb3JhbmdlOiBcIk9yYW5nZVwiXG4gICAgICB9XG4gICAgfVxuICB9O1xufSh3aW5kb3cualF1ZXJ5LCB3aW5kb3cud3lzaWh0bWw1KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9lZGl0YWJsZS9qcy93eXNpaHRtbDUuanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Editable_vue__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Editable_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__Editable_vue__);\n\n\nVue.component('editable', __WEBPACK_IMPORTED_MODULE_0__Editable_vue___default.a);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbIlZ1ZSIsImNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7O0FBRUFBLElBQUlDLFNBQUosQ0FBYyxVQUFkLEVBQTBCLHFEQUExQiIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEVkaXRhYmxlIGZyb20gJy4vRWRpdGFibGUudnVlJ1xuXG5WdWUuY29tcG9uZW50KCdlZGl0YWJsZScsIEVkaXRhYmxlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYWluLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(0)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, "/*! X-editable - v1.5.1 \\n* In-place editing with Twitter Bootstrap, jQuery UI or pure jQuery\\n* http://github.com/vitalets/x-editable\\n* Copyright (c) 2013 Vitaliy Potapov; Licensed MIT */.editableform{margin-bottom:0}.editableform .control-group{margin-bottom:0;white-space:nowrap;line-height:20px}.editableform .form-control{width:auto}.editable-buttons{display:inline-block;vertical-align:top;margin-left:7px;zoom:1;*display:inline}.editable-buttons.editable-buttons-bottom{display:block;margin-top:7px;margin-left:0}.editable-input{vertical-align:top;display:inline-block;width:auto;white-space:normal;zoom:1;*display:inline}.editable-buttons .editable-cancel{margin-left:7px}.editable-buttons button.ui-button-icon-only{height:24px;width:30px}.editableform-loading{background:url(" + __webpack_require__(12) + ") 50% no-repeat;height:25px;width:auto;min-width:25px}.editable-inline .editableform-loading{background-position:left 5px}.editable-error-block{max-width:300px;margin:5px 0 0;width:auto;white-space:normal}.editable-error-block.ui-state-error{padding:3px}.editable-error{color:red}.editableform .editable-date{padding:0;margin:0;float:left}.editable-inline .add-on .icon-th{margin-top:3px;margin-left:1px}.editable-checklist label input[type=checkbox],.editable-checklist label span{vertical-align:middle;margin:0}.editable-checklist label{white-space:nowrap}.editable-wysihtml5{width:566px;height:250px}.editable-clear{clear:both;font-size:.9em;text-decoration:none;text-align:right}.editable-clear-x{background:url(" + __webpack_require__(11) + ") 50% no-repeat;display:block;width:13px;height:13px;position:absolute;opacity:.6;z-index:100;top:50%;right:6px;margin-top:-6px}.editable-clear-x:hover{opacity:1}.editable-pre-wrapped{white-space:pre-wrap}.editable-container.editable-popup{max-width:none!important}.editable-container.popover{width:auto}.editable-container.editable-inline{display:inline-block;vertical-align:middle;width:auto;zoom:1;*display:inline}.editable-container.ui-widget{font-size:inherit;z-index:9990}.editable-click,a.editable-click,a.editable-click:hover{text-decoration:none;border-bottom:1px dashed #08c}.editable-click.editable-disabled,a.editable-click.editable-disabled,a.editable-click.editable-disabled:hover{color:#585858;cursor:default;border-bottom:none}.editable-empty,.editable-empty:focus,.editable-empty:hover{font-style:italic;color:#d14;text-decoration:none}.editable-unsaved{font-weight:700}.editable-bg-transition{-webkit-transition:background-color 1.4s ease-out;-moz-transition:background-color 1.4s ease-out;-o-transition:background-color 1.4s ease-out;-ms-transition:background-color 1.4s ease-out;transition:background-color 1.4s ease-out}.form-horizontal .editable{padding-top:5px;display:inline-block}\\n\\n\\n/*!\\n * Datepicker for Bootstrap\\n *\\n * Copyright 2012 Stefan Petre\\n * Improvements by Andrew Rowls\\n * Licensed under the Apache License v2.0\\n * http://www.apache.org/licenses/LICENSE-2.0\\n *\\n */.datepicker{padding:4px;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;direction:ltr}.datepicker-inline{width:220px}.datepicker.datepicker-rtl{direction:rtl}.datepicker.datepicker-rtl table tr td span{float:right}.datepicker-dropdown{top:0;left:0}.datepicker-dropdown:before{content:\\"\\";display:inline-block;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #ccc;border-bottom-color:rgba(0,0,0,.2);position:absolute;top:-7px;left:6px}.datepicker-dropdown:after{content:\\"\\";display:inline-block;border-left:6px solid transparent;border-right:6px solid transparent;border-bottom:6px solid #fff;position:absolute;top:-6px;left:7px}.datepicker>div{display:none}.datepicker.days div.datepicker-days,.datepicker.months div.datepicker-months,.datepicker.years div.datepicker-years{display:block}.datepicker table{margin:0}.datepicker td,.datepicker th{text-align:center;width:20px;height:20px;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px;border:none}.table-striped .datepicker table tr td,.table-striped .datepicker table tr th{background-color:transparent}.datepicker table tr td.day:hover{background:#eee;cursor:pointer}.datepicker table tr td.new,.datepicker table tr td.old{color:#999}.datepicker table tr td.disabled,.datepicker table tr td.disabled:hover{background:none;color:#999;cursor:default}.datepicker table tr td.today,.datepicker table tr td.today.disabled,.datepicker table tr td.today.disabled:hover,.datepicker table tr td.today:hover{background-color:#fde19a;background-image:-moz-linear-gradient(top,#fdd49a,#fdf59a);background-image:-ms-linear-gradient(top,#fdd49a,#fdf59a);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fdd49a),to(#fdf59a));background-image:-webkit-linear-gradient(top,#fdd49a,#fdf59a);background-image:-o-linear-gradient(top,#fdd49a,#fdf59a);background-image:linear-gradient(top,#fdd49a,#fdf59a);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#fdd49a\\",endColorstr=\\"#fdf59a\\",GradientType=0);border-color:#fdf59a #fdf59a #fbed50;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);color:#000}.datepicker table tr td.today.active,.datepicker table tr td.today.disabled,.datepicker table tr td.today.disabled.active,.datepicker table tr td.today.disabled.disabled,.datepicker table tr td.today.disabled:active,.datepicker table tr td.today.disabled:hover,.datepicker table tr td.today.disabled:hover.active,.datepicker table tr td.today.disabled:hover.disabled,.datepicker table tr td.today.disabled:hover:active,.datepicker table tr td.today.disabled:hover:hover,.datepicker table tr td.today.disabled:hover[disabled],.datepicker table tr td.today.disabled[disabled],.datepicker table tr td.today:active,.datepicker table tr td.today:hover,.datepicker table tr td.today:hover.active,.datepicker table tr td.today:hover.disabled,.datepicker table tr td.today:hover:active,.datepicker table tr td.today:hover:hover,.datepicker table tr td.today:hover[disabled],.datepicker table tr td.today[disabled]{background-color:#fdf59a}.datepicker table tr td.today.active,.datepicker table tr td.today.disabled.active,.datepicker table tr td.today.disabled:active,.datepicker table tr td.today.disabled:hover.active,.datepicker table tr td.today.disabled:hover:active,.datepicker table tr td.today:active,.datepicker table tr td.today:hover.active,.datepicker table tr td.today:hover:active{background-color:#fbf069\\\\9}.datepicker table tr td.today:hover:hover{color:#000}.datepicker table tr td.today.active:hover{color:#fff}.datepicker table tr td.range,.datepicker table tr td.range.disabled,.datepicker table tr td.range.disabled:hover,.datepicker table tr td.range:hover{background:#eee;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.datepicker table tr td.range.today,.datepicker table tr td.range.today.disabled,.datepicker table tr td.range.today.disabled:hover,.datepicker table tr td.range.today:hover{background-color:#f3d17a;background-image:-moz-linear-gradient(top,#f3c17a,#f3e97a);background-image:-ms-linear-gradient(top,#f3c17a,#f3e97a);background-image:-webkit-gradient(linear,0 0,0 100%,from(#f3c17a),to(#f3e97a));background-image:-webkit-linear-gradient(top,#f3c17a,#f3e97a);background-image:-o-linear-gradient(top,#f3c17a,#f3e97a);background-image:linear-gradient(top,#f3c17a,#f3e97a);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#f3c17a\\",endColorstr=\\"#f3e97a\\",GradientType=0);border-color:#f3e97a #f3e97a #edde34;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);-webkit-border-radius:0;-moz-border-radius:0;border-radius:0}.datepicker table tr td.range.today.active,.datepicker table tr td.range.today.disabled,.datepicker table tr td.range.today.disabled.active,.datepicker table tr td.range.today.disabled.disabled,.datepicker table tr td.range.today.disabled:active,.datepicker table tr td.range.today.disabled:hover,.datepicker table tr td.range.today.disabled:hover.active,.datepicker table tr td.range.today.disabled:hover.disabled,.datepicker table tr td.range.today.disabled:hover:active,.datepicker table tr td.range.today.disabled:hover:hover,.datepicker table tr td.range.today.disabled:hover[disabled],.datepicker table tr td.range.today.disabled[disabled],.datepicker table tr td.range.today:active,.datepicker table tr td.range.today:hover,.datepicker table tr td.range.today:hover.active,.datepicker table tr td.range.today:hover.disabled,.datepicker table tr td.range.today:hover:active,.datepicker table tr td.range.today:hover:hover,.datepicker table tr td.range.today:hover[disabled],.datepicker table tr td.range.today[disabled]{background-color:#f3e97a}.datepicker table tr td.range.today.active,.datepicker table tr td.range.today.disabled.active,.datepicker table tr td.range.today.disabled:active,.datepicker table tr td.range.today.disabled:hover.active,.datepicker table tr td.range.today.disabled:hover:active,.datepicker table tr td.range.today:active,.datepicker table tr td.range.today:hover.active,.datepicker table tr td.range.today:hover:active{background-color:#efe24b\\\\9}.datepicker table tr td.selected,.datepicker table tr td.selected.disabled,.datepicker table tr td.selected.disabled:hover,.datepicker table tr td.selected:hover{background-color:#9e9e9e;background-image:-moz-linear-gradient(top,#b3b3b3,gray);background-image:-ms-linear-gradient(top,#b3b3b3,gray);background-image:-webkit-gradient(linear,0 0,0 100%,from(#b3b3b3),to(gray));background-image:-webkit-linear-gradient(top,#b3b3b3,gray);background-image:-o-linear-gradient(top,#b3b3b3,gray);background-image:linear-gradient(top,#b3b3b3,gray);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#b3b3b3\\",endColorstr=\\"#808080\\",GradientType=0);border-color:gray gray #595959;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25)}.datepicker table tr td.selected.active,.datepicker table tr td.selected.disabled,.datepicker table tr td.selected.disabled.active,.datepicker table tr td.selected.disabled.disabled,.datepicker table tr td.selected.disabled:active,.datepicker table tr td.selected.disabled:hover,.datepicker table tr td.selected.disabled:hover.active,.datepicker table tr td.selected.disabled:hover.disabled,.datepicker table tr td.selected.disabled:hover:active,.datepicker table tr td.selected.disabled:hover:hover,.datepicker table tr td.selected.disabled:hover[disabled],.datepicker table tr td.selected.disabled[disabled],.datepicker table tr td.selected:active,.datepicker table tr td.selected:hover,.datepicker table tr td.selected:hover.active,.datepicker table tr td.selected:hover.disabled,.datepicker table tr td.selected:hover:active,.datepicker table tr td.selected:hover:hover,.datepicker table tr td.selected:hover[disabled],.datepicker table tr td.selected[disabled]{background-color:gray}.datepicker table tr td.selected.active,.datepicker table tr td.selected.disabled.active,.datepicker table tr td.selected.disabled:active,.datepicker table tr td.selected.disabled:hover.active,.datepicker table tr td.selected.disabled:hover:active,.datepicker table tr td.selected:active,.datepicker table tr td.selected:hover.active,.datepicker table tr td.selected:hover:active{background-color:#666\\\\9}.datepicker table tr td.active,.datepicker table tr td.active.disabled,.datepicker table tr td.active.disabled:hover,.datepicker table tr td.active:hover{background-color:#006dcc;background-image:-moz-linear-gradient(top,#08c,#04c);background-image:-ms-linear-gradient(top,#08c,#04c);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#04c));background-image:-webkit-linear-gradient(top,#08c,#04c);background-image:-o-linear-gradient(top,#08c,#04c);background-image:linear-gradient(top,#08c,#04c);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#0088cc\\",endColorstr=\\"#0044cc\\",GradientType=0);border-color:#04c #04c #002a80;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25)}.datepicker table tr td.active.active,.datepicker table tr td.active.disabled,.datepicker table tr td.active.disabled.active,.datepicker table tr td.active.disabled.disabled,.datepicker table tr td.active.disabled:active,.datepicker table tr td.active.disabled:hover,.datepicker table tr td.active.disabled:hover.active,.datepicker table tr td.active.disabled:hover.disabled,.datepicker table tr td.active.disabled:hover:active,.datepicker table tr td.active.disabled:hover:hover,.datepicker table tr td.active.disabled:hover[disabled],.datepicker table tr td.active.disabled[disabled],.datepicker table tr td.active:active,.datepicker table tr td.active:hover,.datepicker table tr td.active:hover.active,.datepicker table tr td.active:hover.disabled,.datepicker table tr td.active:hover:active,.datepicker table tr td.active:hover:hover,.datepicker table tr td.active:hover[disabled],.datepicker table tr td.active[disabled]{background-color:#04c}.datepicker table tr td.active.active,.datepicker table tr td.active.disabled.active,.datepicker table tr td.active.disabled:active,.datepicker table tr td.active.disabled:hover.active,.datepicker table tr td.active.disabled:hover:active,.datepicker table tr td.active:active,.datepicker table tr td.active:hover.active,.datepicker table tr td.active:hover:active{background-color:#039\\\\9}.datepicker table tr td span{display:block;width:23%;height:54px;line-height:54px;float:left;margin:1%;cursor:pointer;-webkit-border-radius:4px;-moz-border-radius:4px;border-radius:4px}.datepicker table tr td span:hover{background:#eee}.datepicker table tr td span.disabled,.datepicker table tr td span.disabled:hover{background:none;color:#999;cursor:default}.datepicker table tr td span.active,.datepicker table tr td span.active.disabled,.datepicker table tr td span.active.disabled:hover,.datepicker table tr td span.active:hover{background-color:#006dcc;background-image:-moz-linear-gradient(top,#08c,#04c);background-image:-ms-linear-gradient(top,#08c,#04c);background-image:-webkit-gradient(linear,0 0,0 100%,from(#08c),to(#04c));background-image:-webkit-linear-gradient(top,#08c,#04c);background-image:-o-linear-gradient(top,#08c,#04c);background-image:linear-gradient(top,#08c,#04c);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#0088cc\\",endColorstr=\\"#0044cc\\",GradientType=0);border-color:#04c #04c #002a80;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);color:#fff;text-shadow:0 -1px 0 rgba(0,0,0,.25)}.datepicker table tr td span.active.active,.datepicker table tr td span.active.disabled,.datepicker table tr td span.active.disabled.active,.datepicker table tr td span.active.disabled.disabled,.datepicker table tr td span.active.disabled:active,.datepicker table tr td span.active.disabled:hover,.datepicker table tr td span.active.disabled:hover.active,.datepicker table tr td span.active.disabled:hover.disabled,.datepicker table tr td span.active.disabled:hover:active,.datepicker table tr td span.active.disabled:hover:hover,.datepicker table tr td span.active.disabled:hover[disabled],.datepicker table tr td span.active.disabled[disabled],.datepicker table tr td span.active:active,.datepicker table tr td span.active:hover,.datepicker table tr td span.active:hover.active,.datepicker table tr td span.active:hover.disabled,.datepicker table tr td span.active:hover:active,.datepicker table tr td span.active:hover:hover,.datepicker table tr td span.active:hover[disabled],.datepicker table tr td span.active[disabled]{background-color:#04c}.datepicker table tr td span.active.active,.datepicker table tr td span.active.disabled.active,.datepicker table tr td span.active.disabled:active,.datepicker table tr td span.active.disabled:hover.active,.datepicker table tr td span.active.disabled:hover:active,.datepicker table tr td span.active:active,.datepicker table tr td span.active:hover.active,.datepicker table tr td span.active:hover:active{background-color:#039\\\\9}.datepicker table tr td span.new,.datepicker table tr td span.old{color:#999}.datepicker th.datepicker-switch{width:145px}.datepicker tfoot tr th,.datepicker thead tr:first-child th{cursor:pointer}.datepicker tfoot tr th:hover,.datepicker thead tr:first-child th:hover{background:#eee}.datepicker .cw{font-size:10px;width:12px;padding:0 2px 0 5px;vertical-align:middle}.datepicker thead tr:first-child th.cw{cursor:default;background-color:transparent}.input-append.date .add-on i,.input-prepend.date .add-on i{display:block;cursor:pointer;width:16px;height:16px}.input-daterange input{text-align:center}.input-daterange input:first-child{-webkit-border-radius:3px 0 0 3px;-moz-border-radius:3px 0 0 3px;border-radius:3px 0 0 3px}.input-daterange input:last-child{-webkit-border-radius:0 3px 3px 0;-moz-border-radius:0 3px 3px 0;border-radius:0 3px 3px 0}.input-daterange .add-on{display:inline-block;width:auto;min-width:16px;height:18px;padding:4px 5px;font-weight:400;line-height:18px;text-align:center;text-shadow:0 1px 0 #fff;vertical-align:middle;background-color:#eee;border:1px solid #ccc;margin-left:-5px;margin-right:-5px}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC1lZGl0YWJsZS5jc3M/YmMwMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLHNNQUF1TSw4QkFBOEIsZ0JBQWdCLDZCQUE2QixnQkFBZ0IsbUJBQW1CLGlCQUFpQiw0QkFBNEIsV0FBVyxrQkFBa0IscUJBQXFCLG1CQUFtQixnQkFBZ0IsT0FBTyxnQkFBZ0IsMENBQTBDLGNBQWMsZUFBZSxjQUFjLGdCQUFnQixtQkFBbUIscUJBQXFCLFdBQVcsbUJBQW1CLE9BQU8sZ0JBQWdCLG1DQUFtQyxnQkFBZ0IsNkNBQTZDLFlBQVksV0FBVyxzQkFBc0IsOERBQW9FLFlBQVksV0FBVyxlQUFlLHVDQUF1Qyw2QkFBNkIsc0JBQXNCLGdCQUFnQixlQUFlLFdBQVcsbUJBQW1CLHFDQUFxQyxZQUFZLGdCQUFnQixVQUFVLDZCQUE2QixVQUFVLFNBQVMsV0FBVyxrQ0FBa0MsZUFBZSxnQkFBZ0IsOEVBQThFLHNCQUFzQixTQUFTLDBCQUEwQixtQkFBbUIsb0JBQW9CLFlBQVksYUFBYSxnQkFBZ0IsV0FBVyxlQUFlLHFCQUFxQixpQkFBaUIsa0JBQWtCLDhEQUFrRSxjQUFjLFdBQVcsWUFBWSxrQkFBa0IsV0FBVyxZQUFZLFFBQVEsVUFBVSxnQkFBZ0Isd0JBQXdCLFVBQVUsc0JBQXNCLHFCQUFxQixtQ0FBbUMseUJBQXlCLDRCQUE0QixXQUFXLG9DQUFvQyxxQkFBcUIsc0JBQXNCLFdBQVcsT0FBTyxnQkFBZ0IsOEJBQThCLGtCQUFrQixhQUFhLHdEQUF3RCxxQkFBcUIsOEJBQThCLDhHQUE4RyxjQUFjLGVBQWUsbUJBQW1CLDREQUE0RCxrQkFBa0IsV0FBVyxxQkFBcUIsa0JBQWtCLGdCQUFnQix3QkFBd0Isa0RBQWtELCtDQUErQyw2Q0FBNkMsOENBQThDLDBDQUEwQywyQkFBMkIsZ0JBQWdCLHFCQUFxQiwwTkFBME4sWUFBWSwwQkFBMEIsdUJBQXVCLGtCQUFrQixjQUFjLG1CQUFtQixZQUFZLDJCQUEyQixjQUFjLDRDQUE0QyxZQUFZLHFCQUFxQixNQUFNLE9BQU8sNEJBQTRCLGFBQWEscUJBQXFCLGtDQUFrQyxtQ0FBbUMsNkJBQTZCLG1DQUFtQyxrQkFBa0IsU0FBUyxTQUFTLDJCQUEyQixhQUFhLHFCQUFxQixrQ0FBa0MsbUNBQW1DLDZCQUE2QixrQkFBa0IsU0FBUyxTQUFTLGdCQUFnQixhQUFhLHFIQUFxSCxjQUFjLGtCQUFrQixTQUFTLDhCQUE4QixrQkFBa0IsV0FBVyxZQUFZLDBCQUEwQix1QkFBdUIsa0JBQWtCLFlBQVksOEVBQThFLDZCQUE2QixrQ0FBa0MsZ0JBQWdCLGVBQWUsd0RBQXdELFdBQVcsd0VBQXdFLGdCQUFnQixXQUFXLGVBQWUsc0pBQXNKLHlCQUF5QiwyREFBMkQsMERBQTBELCtFQUErRSw4REFBOEQseURBQXlELHNEQUFzRCwyQkFBMkIsb0hBQW9ILHFDQUFxQywyREFBMkQsaUVBQWlFLFdBQVcsMDRCQUEwNEIseUJBQXlCLG9XQUFvVyw0QkFBNEIsMENBQTBDLFdBQVcsMkNBQTJDLFdBQVcsc0pBQXNKLGdCQUFnQix3QkFBd0IscUJBQXFCLGdCQUFnQiw4S0FBOEsseUJBQXlCLDJEQUEyRCwwREFBMEQsK0VBQStFLDhEQUE4RCx5REFBeUQsc0RBQXNELDJCQUEyQixvSEFBb0gscUNBQXFDLDJEQUEyRCxpRUFBaUUsd0JBQXdCLHFCQUFxQixnQkFBZ0Isa2dDQUFrZ0MseUJBQXlCLG9aQUFvWiw0QkFBNEIsa0tBQWtLLHlCQUF5Qix3REFBd0QsdURBQXVELDRFQUE0RSwyREFBMkQsc0RBQXNELG1EQUFtRCwyQkFBMkIsb0hBQW9ILCtCQUErQiwyREFBMkQsaUVBQWlFLFdBQVcscUNBQXFDLHM4QkFBczhCLHNCQUFzQiw0WEFBNFgseUJBQXlCLDBKQUEwSix5QkFBeUIscURBQXFELG9EQUFvRCx5RUFBeUUsd0RBQXdELG1EQUFtRCxnREFBZ0QsMkJBQTJCLG9IQUFvSCwrQkFBK0IsMkRBQTJELGlFQUFpRSxXQUFXLHFDQUFxQyw4NUJBQTg1QixzQkFBc0IsNFdBQTRXLHlCQUF5Qiw2QkFBNkIsY0FBYyxVQUFVLFlBQVksaUJBQWlCLFdBQVcsVUFBVSxlQUFlLDBCQUEwQix1QkFBdUIsa0JBQWtCLG1DQUFtQyxnQkFBZ0Isa0ZBQWtGLGdCQUFnQixXQUFXLGVBQWUsOEtBQThLLHlCQUF5QixxREFBcUQsb0RBQW9ELHlFQUF5RSx3REFBd0QsbURBQW1ELGdEQUFnRCwyQkFBMkIsb0hBQW9ILCtCQUErQiwyREFBMkQsaUVBQWlFLFdBQVcscUNBQXFDLGtnQ0FBa2dDLHNCQUFzQixvWkFBb1oseUJBQXlCLGtFQUFrRSxXQUFXLGlDQUFpQyxZQUFZLDREQUE0RCxlQUFlLHdFQUF3RSxnQkFBZ0IsZ0JBQWdCLGVBQWUsV0FBVyxvQkFBb0Isc0JBQXNCLHVDQUF1QyxlQUFlLDZCQUE2QiwyREFBMkQsY0FBYyxlQUFlLFdBQVcsWUFBWSx1QkFBdUIsa0JBQWtCLG1DQUFtQyxrQ0FBa0MsK0JBQStCLDBCQUEwQixrQ0FBa0Msa0NBQWtDLCtCQUErQiwwQkFBMEIseUJBQXlCLHFCQUFxQixXQUFXLGVBQWUsWUFBWSxnQkFBZ0IsZ0JBQWdCLGlCQUFpQixrQkFBa0IseUJBQXlCLHNCQUFzQixzQkFBc0Isc0JBQXNCLGlCQUFpQixrQkFBa0I7O0FBRXJ1aUIiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qISBYLWVkaXRhYmxlIC0gdjEuNS4xIFxcbiogSW4tcGxhY2UgZWRpdGluZyB3aXRoIFR3aXR0ZXIgQm9vdHN0cmFwLCBqUXVlcnkgVUkgb3IgcHVyZSBqUXVlcnlcXG4qIGh0dHA6Ly9naXRodWIuY29tL3ZpdGFsZXRzL3gtZWRpdGFibGVcXG4qIENvcHlyaWdodCAoYykgMjAxMyBWaXRhbGl5IFBvdGFwb3Y7IExpY2Vuc2VkIE1JVCAqLy5lZGl0YWJsZWZvcm17bWFyZ2luLWJvdHRvbTowfS5lZGl0YWJsZWZvcm0gLmNvbnRyb2wtZ3JvdXB7bWFyZ2luLWJvdHRvbTowO3doaXRlLXNwYWNlOm5vd3JhcDtsaW5lLWhlaWdodDoyMHB4fS5lZGl0YWJsZWZvcm0gLmZvcm0tY29udHJvbHt3aWR0aDphdXRvfS5lZGl0YWJsZS1idXR0b25ze2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOnRvcDttYXJnaW4tbGVmdDo3cHg7em9vbToxOypkaXNwbGF5OmlubGluZX0uZWRpdGFibGUtYnV0dG9ucy5lZGl0YWJsZS1idXR0b25zLWJvdHRvbXtkaXNwbGF5OmJsb2NrO21hcmdpbi10b3A6N3B4O21hcmdpbi1sZWZ0OjB9LmVkaXRhYmxlLWlucHV0e3ZlcnRpY2FsLWFsaWduOnRvcDtkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDphdXRvO3doaXRlLXNwYWNlOm5vcm1hbDt6b29tOjE7KmRpc3BsYXk6aW5saW5lfS5lZGl0YWJsZS1idXR0b25zIC5lZGl0YWJsZS1jYW5jZWx7bWFyZ2luLWxlZnQ6N3B4fS5lZGl0YWJsZS1idXR0b25zIGJ1dHRvbi51aS1idXR0b24taWNvbi1vbmx5e2hlaWdodDoyNHB4O3dpZHRoOjMwcHh9LmVkaXRhYmxlZm9ybS1sb2FkaW5ne2JhY2tncm91bmQ6dXJsKFwiICsgcmVxdWlyZShcIi4uL2ltZy9sb2FkaW5nLmdpZlwiKSArIFwiKSA1MCUgbm8tcmVwZWF0O2hlaWdodDoyNXB4O3dpZHRoOmF1dG87bWluLXdpZHRoOjI1cHh9LmVkaXRhYmxlLWlubGluZSAuZWRpdGFibGVmb3JtLWxvYWRpbmd7YmFja2dyb3VuZC1wb3NpdGlvbjpsZWZ0IDVweH0uZWRpdGFibGUtZXJyb3ItYmxvY2t7bWF4LXdpZHRoOjMwMHB4O21hcmdpbjo1cHggMCAwO3dpZHRoOmF1dG87d2hpdGUtc3BhY2U6bm9ybWFsfS5lZGl0YWJsZS1lcnJvci1ibG9jay51aS1zdGF0ZS1lcnJvcntwYWRkaW5nOjNweH0uZWRpdGFibGUtZXJyb3J7Y29sb3I6cmVkfS5lZGl0YWJsZWZvcm0gLmVkaXRhYmxlLWRhdGV7cGFkZGluZzowO21hcmdpbjowO2Zsb2F0OmxlZnR9LmVkaXRhYmxlLWlubGluZSAuYWRkLW9uIC5pY29uLXRoe21hcmdpbi10b3A6M3B4O21hcmdpbi1sZWZ0OjFweH0uZWRpdGFibGUtY2hlY2tsaXN0IGxhYmVsIGlucHV0W3R5cGU9Y2hlY2tib3hdLC5lZGl0YWJsZS1jaGVja2xpc3QgbGFiZWwgc3Bhbnt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7bWFyZ2luOjB9LmVkaXRhYmxlLWNoZWNrbGlzdCBsYWJlbHt3aGl0ZS1zcGFjZTpub3dyYXB9LmVkaXRhYmxlLXd5c2lodG1sNXt3aWR0aDo1NjZweDtoZWlnaHQ6MjUwcHh9LmVkaXRhYmxlLWNsZWFye2NsZWFyOmJvdGg7Zm9udC1zaXplOi45ZW07dGV4dC1kZWNvcmF0aW9uOm5vbmU7dGV4dC1hbGlnbjpyaWdodH0uZWRpdGFibGUtY2xlYXIteHtiYWNrZ3JvdW5kOnVybChcIiArIHJlcXVpcmUoXCIuLi9pbWcvY2xlYXIucG5nXCIpICsgXCIpIDUwJSBuby1yZXBlYXQ7ZGlzcGxheTpibG9jazt3aWR0aDoxM3B4O2hlaWdodDoxM3B4O3Bvc2l0aW9uOmFic29sdXRlO29wYWNpdHk6LjY7ei1pbmRleDoxMDA7dG9wOjUwJTtyaWdodDo2cHg7bWFyZ2luLXRvcDotNnB4fS5lZGl0YWJsZS1jbGVhci14OmhvdmVye29wYWNpdHk6MX0uZWRpdGFibGUtcHJlLXdyYXBwZWR7d2hpdGUtc3BhY2U6cHJlLXdyYXB9LmVkaXRhYmxlLWNvbnRhaW5lci5lZGl0YWJsZS1wb3B1cHttYXgtd2lkdGg6bm9uZSFpbXBvcnRhbnR9LmVkaXRhYmxlLWNvbnRhaW5lci5wb3BvdmVye3dpZHRoOmF1dG99LmVkaXRhYmxlLWNvbnRhaW5lci5lZGl0YWJsZS1pbmxpbmV7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlO3dpZHRoOmF1dG87em9vbToxOypkaXNwbGF5OmlubGluZX0uZWRpdGFibGUtY29udGFpbmVyLnVpLXdpZGdldHtmb250LXNpemU6aW5oZXJpdDt6LWluZGV4Ojk5OTB9LmVkaXRhYmxlLWNsaWNrLGEuZWRpdGFibGUtY2xpY2ssYS5lZGl0YWJsZS1jbGljazpob3Zlcnt0ZXh0LWRlY29yYXRpb246bm9uZTtib3JkZXItYm90dG9tOjFweCBkYXNoZWQgIzA4Y30uZWRpdGFibGUtY2xpY2suZWRpdGFibGUtZGlzYWJsZWQsYS5lZGl0YWJsZS1jbGljay5lZGl0YWJsZS1kaXNhYmxlZCxhLmVkaXRhYmxlLWNsaWNrLmVkaXRhYmxlLWRpc2FibGVkOmhvdmVye2NvbG9yOiM1ODU4NTg7Y3Vyc29yOmRlZmF1bHQ7Ym9yZGVyLWJvdHRvbTpub25lfS5lZGl0YWJsZS1lbXB0eSwuZWRpdGFibGUtZW1wdHk6Zm9jdXMsLmVkaXRhYmxlLWVtcHR5OmhvdmVye2ZvbnQtc3R5bGU6aXRhbGljO2NvbG9yOiNkMTQ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmVkaXRhYmxlLXVuc2F2ZWR7Zm9udC13ZWlnaHQ6NzAwfS5lZGl0YWJsZS1iZy10cmFuc2l0aW9uey13ZWJraXQtdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIDEuNHMgZWFzZS1vdXQ7LW1vei10cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgMS40cyBlYXNlLW91dDstby10cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgMS40cyBlYXNlLW91dDstbXMtdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIDEuNHMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIDEuNHMgZWFzZS1vdXR9LmZvcm0taG9yaXpvbnRhbCAuZWRpdGFibGV7cGFkZGluZy10b3A6NXB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrfVxcblxcblxcbi8qIVxcbiAqIERhdGVwaWNrZXIgZm9yIEJvb3RzdHJhcFxcbiAqXFxuICogQ29weXJpZ2h0IDIwMTIgU3RlZmFuIFBldHJlXFxuICogSW1wcm92ZW1lbnRzIGJ5IEFuZHJldyBSb3dsc1xcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSB2Mi4wXFxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXFxuICpcXG4gKi8uZGF0ZXBpY2tlcntwYWRkaW5nOjRweDstd2Via2l0LWJvcmRlci1yYWRpdXM6NHB4Oy1tb3otYm9yZGVyLXJhZGl1czo0cHg7Ym9yZGVyLXJhZGl1czo0cHg7ZGlyZWN0aW9uOmx0cn0uZGF0ZXBpY2tlci1pbmxpbmV7d2lkdGg6MjIwcHh9LmRhdGVwaWNrZXIuZGF0ZXBpY2tlci1ydGx7ZGlyZWN0aW9uOnJ0bH0uZGF0ZXBpY2tlci5kYXRlcGlja2VyLXJ0bCB0YWJsZSB0ciB0ZCBzcGFue2Zsb2F0OnJpZ2h0fS5kYXRlcGlja2VyLWRyb3Bkb3due3RvcDowO2xlZnQ6MH0uZGF0ZXBpY2tlci1kcm9wZG93bjpiZWZvcmV7Y29udGVudDpcXFwiXFxcIjtkaXNwbGF5OmlubGluZS1ibG9jaztib3JkZXItbGVmdDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjdweCBzb2xpZCAjY2NjO2JvcmRlci1ib3R0b20tY29sb3I6cmdiYSgwLDAsMCwuMik7cG9zaXRpb246YWJzb2x1dGU7dG9wOi03cHg7bGVmdDo2cHh9LmRhdGVwaWNrZXItZHJvcGRvd246YWZ0ZXJ7Y29udGVudDpcXFwiXFxcIjtkaXNwbGF5OmlubGluZS1ibG9jaztib3JkZXItbGVmdDo2cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjZweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjZweCBzb2xpZCAjZmZmO3Bvc2l0aW9uOmFic29sdXRlO3RvcDotNnB4O2xlZnQ6N3B4fS5kYXRlcGlja2VyPmRpdntkaXNwbGF5Om5vbmV9LmRhdGVwaWNrZXIuZGF5cyBkaXYuZGF0ZXBpY2tlci1kYXlzLC5kYXRlcGlja2VyLm1vbnRocyBkaXYuZGF0ZXBpY2tlci1tb250aHMsLmRhdGVwaWNrZXIueWVhcnMgZGl2LmRhdGVwaWNrZXIteWVhcnN7ZGlzcGxheTpibG9ja30uZGF0ZXBpY2tlciB0YWJsZXttYXJnaW46MH0uZGF0ZXBpY2tlciB0ZCwuZGF0ZXBpY2tlciB0aHt0ZXh0LWFsaWduOmNlbnRlcjt3aWR0aDoyMHB4O2hlaWdodDoyMHB4Oy13ZWJraXQtYm9yZGVyLXJhZGl1czo0cHg7LW1vei1ib3JkZXItcmFkaXVzOjRweDtib3JkZXItcmFkaXVzOjRweDtib3JkZXI6bm9uZX0udGFibGUtc3RyaXBlZCAuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCwudGFibGUtc3RyaXBlZCAuZGF0ZXBpY2tlciB0YWJsZSB0ciB0aHtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmRheTpob3ZlcntiYWNrZ3JvdW5kOiNlZWU7Y3Vyc29yOnBvaW50ZXJ9LmRhdGVwaWNrZXIgdGFibGUgdHIgdGQubmV3LC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLm9sZHtjb2xvcjojOTk5fS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmRpc2FibGVkOmhvdmVye2JhY2tncm91bmQ6bm9uZTtjb2xvcjojOTk5O2N1cnNvcjpkZWZhdWx0fS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmhvdmVye2JhY2tncm91bmQtY29sb3I6I2ZkZTE5YTtiYWNrZ3JvdW5kLWltYWdlOi1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwjZmRkNDlhLCNmZGY1OWEpO2JhY2tncm91bmQtaW1hZ2U6LW1zLWxpbmVhci1ncmFkaWVudCh0b3AsI2ZkZDQ5YSwjZmRmNTlhKTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLDAgMCwwIDEwMCUsZnJvbSgjZmRkNDlhKSx0bygjZmRmNTlhKSk7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsI2ZkZDQ5YSwjZmRmNTlhKTtiYWNrZ3JvdW5kLWltYWdlOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsI2ZkZDQ5YSwjZmRmNTlhKTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0b3AsI2ZkZDQ5YSwjZmRmNTlhKTtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9XFxcIiNmZGQ0OWFcXFwiLGVuZENvbG9yc3RyPVxcXCIjZmRmNTlhXFxcIixHcmFkaWVudFR5cGU9MCk7Ym9yZGVyLWNvbG9yOiNmZGY1OWEgI2ZkZjU5YSAjZmJlZDUwO2JvcmRlci1jb2xvcjpyZ2JhKDAsMCwwLC4xKSByZ2JhKDAsMCwwLC4xKSByZ2JhKDAsMCwwLC4yNSk7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChlbmFibGVkPWZhbHNlKTtjb2xvcjojMDAwfS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5kaXNhYmxlZC5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQuZGlzYWJsZWQsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQ6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkOmhvdmVyLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5kaXNhYmxlZDpob3Zlci5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5kaXNhYmxlZDpob3ZlcjphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQ6aG92ZXI6aG92ZXIsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQ6aG92ZXJbZGlzYWJsZWRdLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkW2Rpc2FibGVkXSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheTphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXk6aG92ZXIsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXk6aG92ZXIuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmhvdmVyLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmhvdmVyOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheTpob3Zlcjpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheTpob3ZlcltkaXNhYmxlZF0sLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXlbZGlzYWJsZWRde2JhY2tncm91bmQtY29sb3I6I2ZkZjU5YX0uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5kaXNhYmxlZDpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQ6aG92ZXI6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheTpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXk6aG92ZXI6YWN0aXZle2JhY2tncm91bmQtY29sb3I6I2ZiZjA2OVxcXFw5fS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmhvdmVyOmhvdmVye2NvbG9yOiMwMDB9LmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuYWN0aXZlOmhvdmVye2NvbG9yOiNmZmZ9LmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UuZGlzYWJsZWQsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UuZGlzYWJsZWQ6aG92ZXIsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2U6aG92ZXJ7YmFja2dyb3VuZDojZWVlOy13ZWJraXQtYm9yZGVyLXJhZGl1czowOy1tb3otYm9yZGVyLXJhZGl1czowO2JvcmRlci1yYWRpdXM6MH0uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZDpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmM2QxN2E7YmFja2dyb3VuZC1pbWFnZTotbW96LWxpbmVhci1ncmFkaWVudCh0b3AsI2YzYzE3YSwjZjNlOTdhKTtiYWNrZ3JvdW5kLWltYWdlOi1tcy1saW5lYXItZ3JhZGllbnQodG9wLCNmM2MxN2EsI2YzZTk3YSk7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhciwwIDAsMCAxMDAlLGZyb20oI2YzYzE3YSksdG8oI2YzZTk3YSkpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCNmM2MxN2EsI2YzZTk3YSk7YmFja2dyb3VuZC1pbWFnZTotby1saW5lYXItZ3JhZGllbnQodG9wLCNmM2MxN2EsI2YzZTk3YSk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG9wLCNmM2MxN2EsI2YzZTk3YSk7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPVxcXCIjZjNjMTdhXFxcIixlbmRDb2xvcnN0cj1cXFwiI2YzZTk3YVxcXCIsR3JhZGllbnRUeXBlPTApO2JvcmRlci1jb2xvcjojZjNlOTdhICNmM2U5N2EgI2VkZGUzNDtib3JkZXItY29sb3I6cmdiYSgwLDAsMCwuMSkgcmdiYSgwLDAsMCwuMSkgcmdiYSgwLDAsMCwuMjUpO2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoZW5hYmxlZD1mYWxzZSk7LXdlYmtpdC1ib3JkZXItcmFkaXVzOjA7LW1vei1ib3JkZXItcmFkaXVzOjA7Ym9yZGVyLXJhZGl1czowfS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZC5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQuZGlzYWJsZWQsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQ6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmRpc2FibGVkOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmRpc2FibGVkOmhvdmVyLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZDpob3Zlci5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZDpob3ZlcjphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQ6aG92ZXI6aG92ZXIsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQ6aG92ZXJbZGlzYWJsZWRdLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmRpc2FibGVkW2Rpc2FibGVkXSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheTphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXk6aG92ZXIsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXk6aG92ZXIuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5OmhvdmVyLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5OmhvdmVyOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheTpob3Zlcjpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheTpob3ZlcltkaXNhYmxlZF0sLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXlbZGlzYWJsZWRde2JhY2tncm91bmQtY29sb3I6I2YzZTk3YX0uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmRpc2FibGVkOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZDpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQ6aG92ZXI6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5OmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheTpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXk6aG92ZXI6YWN0aXZle2JhY2tncm91bmQtY29sb3I6I2VmZTI0YlxcXFw5fS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzllOWU5ZTtiYWNrZ3JvdW5kLWltYWdlOi1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwjYjNiM2IzLGdyYXkpO2JhY2tncm91bmQtaW1hZ2U6LW1zLWxpbmVhci1ncmFkaWVudCh0b3AsI2IzYjNiMyxncmF5KTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLDAgMCwwIDEwMCUsZnJvbSgjYjNiM2IzKSx0byhncmF5KSk7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsI2IzYjNiMyxncmF5KTtiYWNrZ3JvdW5kLWltYWdlOi1vLWxpbmVhci1ncmFkaWVudCh0b3AsI2IzYjNiMyxncmF5KTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh0b3AsI2IzYjNiMyxncmF5KTtiYWNrZ3JvdW5kLXJlcGVhdDpyZXBlYXQteDtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9XFxcIiNiM2IzYjNcXFwiLGVuZENvbG9yc3RyPVxcXCIjODA4MDgwXFxcIixHcmFkaWVudFR5cGU9MCk7Ym9yZGVyLWNvbG9yOmdyYXkgZ3JheSAjNTk1OTU5O2JvcmRlci1jb2xvcjpyZ2JhKDAsMCwwLC4xKSByZ2JhKDAsMCwwLC4xKSByZ2JhKDAsMCwwLC4yNSk7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChlbmFibGVkPWZhbHNlKTtjb2xvcjojZmZmO3RleHQtc2hhZG93OjAgLTFweCAwIHJnYmEoMCwwLDAsLjI1KX0uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5kaXNhYmxlZDpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5kaXNhYmxlZDpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQ6aG92ZXIuZGlzYWJsZWQsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQ6aG92ZXI6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkOmhvdmVyOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkOmhvdmVyW2Rpc2FibGVkXSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5kaXNhYmxlZFtkaXNhYmxlZF0sLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQ6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkOmhvdmVyLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZDpob3Zlci5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZDpob3ZlcjphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQ6aG92ZXI6aG92ZXIsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQ6aG92ZXJbZGlzYWJsZWRdLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkW2Rpc2FibGVkXXtiYWNrZ3JvdW5kLWNvbG9yOmdyYXl9LmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5kaXNhYmxlZDphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQ6aG92ZXIuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkOmhvdmVyOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZDphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQ6aG92ZXIuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkOmhvdmVyOmFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiM2NjZcXFxcOX0uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZDpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMDA2ZGNjO2JhY2tncm91bmQtaW1hZ2U6LW1vei1saW5lYXItZ3JhZGllbnQodG9wLCMwOGMsIzA0Yyk7YmFja2dyb3VuZC1pbWFnZTotbXMtbGluZWFyLWdyYWRpZW50KHRvcCwjMDhjLCMwNGMpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsMCAwLDAgMTAwJSxmcm9tKCMwOGMpLHRvKCMwNGMpKTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjMDhjLCMwNGMpO2JhY2tncm91bmQtaW1hZ2U6LW8tbGluZWFyLWdyYWRpZW50KHRvcCwjMDhjLCMwNGMpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHRvcCwjMDhjLCMwNGMpO2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC14O2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj1cXFwiIzAwODhjY1xcXCIsZW5kQ29sb3JzdHI9XFxcIiMwMDQ0Y2NcXFwiLEdyYWRpZW50VHlwZT0wKTtib3JkZXItY29sb3I6IzA0YyAjMDRjICMwMDJhODA7Ym9yZGVyLWNvbG9yOnJnYmEoMCwwLDAsLjEpIHJnYmEoMCwwLDAsLjEpIHJnYmEoMCwwLDAsLjI1KTtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KGVuYWJsZWQ9ZmFsc2UpO2NvbG9yOiNmZmY7dGV4dC1zaGFkb3c6MCAtMXB4IDAgcmdiYSgwLDAsMCwuMjUpfS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZC5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZDphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZDpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkOmhvdmVyLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZDpob3ZlcjphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkOmhvdmVyOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZDpob3ZlcltkaXNhYmxlZF0sLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkW2Rpc2FibGVkXSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZTpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6aG92ZXIuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZTpob3Zlci5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6aG92ZXI6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZTpob3Zlcjpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6aG92ZXJbZGlzYWJsZWRdLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZVtkaXNhYmxlZF17YmFja2dyb3VuZC1jb2xvcjojMDRjfS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmUuZGlzYWJsZWQ6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZDpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkOmhvdmVyOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZTpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlOmhvdmVyOmFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiMwMzlcXFxcOX0uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFue2Rpc3BsYXk6YmxvY2s7d2lkdGg6MjMlO2hlaWdodDo1NHB4O2xpbmUtaGVpZ2h0OjU0cHg7ZmxvYXQ6bGVmdDttYXJnaW46MSU7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC1ib3JkZXItcmFkaXVzOjRweDstbW96LWJvcmRlci1yYWRpdXM6NHB4O2JvcmRlci1yYWRpdXM6NHB4fS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW46aG92ZXJ7YmFja2dyb3VuZDojZWVlfS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uZGlzYWJsZWQsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5kaXNhYmxlZDpob3ZlcntiYWNrZ3JvdW5kOm5vbmU7Y29sb3I6Izk5OTtjdXJzb3I6ZGVmYXVsdH0uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZDpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMwMDZkY2M7YmFja2dyb3VuZC1pbWFnZTotbW96LWxpbmVhci1ncmFkaWVudCh0b3AsIzA4YywjMDRjKTtiYWNrZ3JvdW5kLWltYWdlOi1tcy1saW5lYXItZ3JhZGllbnQodG9wLCMwOGMsIzA0Yyk7YmFja2dyb3VuZC1pbWFnZTotd2Via2l0LWdyYWRpZW50KGxpbmVhciwwIDAsMCAxMDAlLGZyb20oIzA4YyksdG8oIzA0YykpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCMwOGMsIzA0Yyk7YmFja2dyb3VuZC1pbWFnZTotby1saW5lYXItZ3JhZGllbnQodG9wLCMwOGMsIzA0Yyk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodG9wLCMwOGMsIzA0Yyk7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXg7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPVxcXCIjMDA4OGNjXFxcIixlbmRDb2xvcnN0cj1cXFwiIzAwNDRjY1xcXCIsR3JhZGllbnRUeXBlPTApO2JvcmRlci1jb2xvcjojMDRjICMwNGMgIzAwMmE4MDtib3JkZXItY29sb3I6cmdiYSgwLDAsMCwuMSkgcmdiYSgwLDAsMCwuMSkgcmdiYSgwLDAsMCwuMjUpO2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoZW5hYmxlZD1mYWxzZSk7Y29sb3I6I2ZmZjt0ZXh0LXNoYWRvdzowIC0xcHggMCByZ2JhKDAsMCwwLC4yNSl9LmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZC5kaXNhYmxlZCwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZDphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuZGlzYWJsZWQ6aG92ZXIsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuZGlzYWJsZWQ6aG92ZXIuYWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkOmhvdmVyLmRpc2FibGVkLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkOmhvdmVyOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZDpob3Zlcjpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZDpob3ZlcltkaXNhYmxlZF0sLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuZGlzYWJsZWRbZGlzYWJsZWRdLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlOmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZTpob3ZlciwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZTpob3Zlci5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmU6aG92ZXIuZGlzYWJsZWQsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmU6aG92ZXI6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlOmhvdmVyOmhvdmVyLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlOmhvdmVyW2Rpc2FibGVkXSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZVtkaXNhYmxlZF17YmFja2dyb3VuZC1jb2xvcjojMDRjfS5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZC5hY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuZGlzYWJsZWQ6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkOmhvdmVyLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZDpob3ZlcjphY3RpdmUsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmU6YWN0aXZlLC5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlOmhvdmVyLmFjdGl2ZSwuZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZTpob3ZlcjphY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojMDM5XFxcXDl9LmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5uZXcsLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5vbGR7Y29sb3I6Izk5OX0uZGF0ZXBpY2tlciB0aC5kYXRlcGlja2VyLXN3aXRjaHt3aWR0aDoxNDVweH0uZGF0ZXBpY2tlciB0Zm9vdCB0ciB0aCwuZGF0ZXBpY2tlciB0aGVhZCB0cjpmaXJzdC1jaGlsZCB0aHtjdXJzb3I6cG9pbnRlcn0uZGF0ZXBpY2tlciB0Zm9vdCB0ciB0aDpob3ZlciwuZGF0ZXBpY2tlciB0aGVhZCB0cjpmaXJzdC1jaGlsZCB0aDpob3ZlcntiYWNrZ3JvdW5kOiNlZWV9LmRhdGVwaWNrZXIgLmN3e2ZvbnQtc2l6ZToxMHB4O3dpZHRoOjEycHg7cGFkZGluZzowIDJweCAwIDVweDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmRhdGVwaWNrZXIgdGhlYWQgdHI6Zmlyc3QtY2hpbGQgdGguY3d7Y3Vyc29yOmRlZmF1bHQ7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0uaW5wdXQtYXBwZW5kLmRhdGUgLmFkZC1vbiBpLC5pbnB1dC1wcmVwZW5kLmRhdGUgLmFkZC1vbiBpe2Rpc3BsYXk6YmxvY2s7Y3Vyc29yOnBvaW50ZXI7d2lkdGg6MTZweDtoZWlnaHQ6MTZweH0uaW5wdXQtZGF0ZXJhbmdlIGlucHV0e3RleHQtYWxpZ246Y2VudGVyfS5pbnB1dC1kYXRlcmFuZ2UgaW5wdXQ6Zmlyc3QtY2hpbGR7LXdlYmtpdC1ib3JkZXItcmFkaXVzOjNweCAwIDAgM3B4Oy1tb3otYm9yZGVyLXJhZGl1czozcHggMCAwIDNweDtib3JkZXItcmFkaXVzOjNweCAwIDAgM3B4fS5pbnB1dC1kYXRlcmFuZ2UgaW5wdXQ6bGFzdC1jaGlsZHstd2Via2l0LWJvcmRlci1yYWRpdXM6MCAzcHggM3B4IDA7LW1vei1ib3JkZXItcmFkaXVzOjAgM3B4IDNweCAwO2JvcmRlci1yYWRpdXM6MCAzcHggM3B4IDB9LmlucHV0LWRhdGVyYW5nZSAuYWRkLW9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmF1dG87bWluLXdpZHRoOjE2cHg7aGVpZ2h0OjE4cHg7cGFkZGluZzo0cHggNXB4O2ZvbnQtd2VpZ2h0OjQwMDtsaW5lLWhlaWdodDoxOHB4O3RleHQtYWxpZ246Y2VudGVyO3RleHQtc2hhZG93OjAgMXB4IDAgI2ZmZjt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7YmFja2dyb3VuZC1jb2xvcjojZWVlO2JvcmRlcjoxcHggc29saWQgI2NjYzttYXJnaW4tbGVmdDotNXB4O21hcmdpbi1yaWdodDotNXB4fVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vc3JjL2VkaXRhYmxlL2Nzcy9ib290c3RyYXAtZWRpdGFibGUuY3NzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(0)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, "ul.wysihtml5-toolbar{margin:0;padding:0;display:block}ul.wysihtml5-toolbar:after{clear:both;display:table;content:\\"\\"}ul.wysihtml5-toolbar>li{float:left;display:list-item;list-style:none;margin:0 5px 10px 0}ul.wysihtml5-toolbar a[data-wysihtml5-command=bold]{font-weight:700}ul.wysihtml5-toolbar a[data-wysihtml5-command=italic]{font-style:italic}ul.wysihtml5-toolbar a[data-wysihtml5-command=underline]{text-decoration:underline}ul.wysihtml5-toolbar a.btn.wysihtml5-command-active{background-image:none;-webkit-box-shadow:inset 0 2px 4px rgba(0,0,0,.15),0 1px 2px rgba(0,0,0,.05);-moz-box-shadow:inset 0 2px 4px rgba(0,0,0,.15),0 1px 2px rgba(0,0,0,.05);box-shadow:inset 0 2px 4px rgba(0,0,0,.15),0 1px 2px rgba(0,0,0,.05);background-color:#e6e6e6;background-color:#d9d9d9;outline:0}ul.wysihtml5-commands-disabled .dropdown-menu{display:none!important}ul.wysihtml5-toolbar div.wysihtml5-colors{display:block;width:50px;height:20px;margin-top:2px;margin-left:5px;position:absolute;pointer-events:none}ul.wysihtml5-toolbar a.wysihtml5-colors-title{padding-left:70px}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=clear]{background:#a38a77!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=black]{background:#000!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=silver]{background:silver!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=gray]{background:gray!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=maroon]{background:maroon!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=red]{background:red!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=purple]{background:purple!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=green]{background:green!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=olive]{background:olive!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=navy]{background:navy!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=blue]{background:blue!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=orange]{background:orange!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=first]{background:#149d9a!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=second]{background:#e02924!important}ul.wysihtml5-toolbar div[data-wysihtml5-command-value=three]{background:#2954a4!important}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzPzIyYzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSw4Q0FBK0MsU0FBUyxVQUFVLGNBQWMsMkJBQTJCLFdBQVcsY0FBYyxhQUFhLHdCQUF3QixXQUFXLGtCQUFrQixnQkFBZ0Isb0JBQW9CLG9EQUFvRCxnQkFBZ0Isc0RBQXNELGtCQUFrQix5REFBeUQsMEJBQTBCLG9EQUFvRCxzQkFBc0IsNkVBQTZFLDBFQUEwRSxxRUFBcUUseUJBQXlCLHlCQUF5QixVQUFVLDhDQUE4Qyx1QkFBdUIsMENBQTBDLGNBQWMsV0FBVyxZQUFZLGVBQWUsZ0JBQWdCLGtCQUFrQixvQkFBb0IsOENBQThDLGtCQUFrQiw2REFBNkQsNkJBQTZCLDZEQUE2RCwwQkFBMEIsOERBQThELDRCQUE0Qiw0REFBNEQsMEJBQTBCLDhEQUE4RCw0QkFBNEIsMkRBQTJELHlCQUF5Qiw4REFBOEQsNEJBQTRCLDZEQUE2RCwyQkFBMkIsNkRBQTZELDJCQUEyQiw0REFBNEQsMEJBQTBCLDREQUE0RCwwQkFBMEIsOERBQThELDRCQUE0Qiw2REFBNkQsNkJBQTZCLDhEQUE4RCw2QkFBNkIsNkRBQTZELDZCQUE2Qjs7QUFFbDNFIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJ1bC53eXNpaHRtbDUtdG9vbGJhcnttYXJnaW46MDtwYWRkaW5nOjA7ZGlzcGxheTpibG9ja311bC53eXNpaHRtbDUtdG9vbGJhcjphZnRlcntjbGVhcjpib3RoO2Rpc3BsYXk6dGFibGU7Y29udGVudDpcXFwiXFxcIn11bC53eXNpaHRtbDUtdG9vbGJhcj5saXtmbG9hdDpsZWZ0O2Rpc3BsYXk6bGlzdC1pdGVtO2xpc3Qtc3R5bGU6bm9uZTttYXJnaW46MCA1cHggMTBweCAwfXVsLnd5c2lodG1sNS10b29sYmFyIGFbZGF0YS13eXNpaHRtbDUtY29tbWFuZD1ib2xkXXtmb250LXdlaWdodDo3MDB9dWwud3lzaWh0bWw1LXRvb2xiYXIgYVtkYXRhLXd5c2lodG1sNS1jb21tYW5kPWl0YWxpY117Zm9udC1zdHlsZTppdGFsaWN9dWwud3lzaWh0bWw1LXRvb2xiYXIgYVtkYXRhLXd5c2lodG1sNS1jb21tYW5kPXVuZGVybGluZV17dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZX11bC53eXNpaHRtbDUtdG9vbGJhciBhLmJ0bi53eXNpaHRtbDUtY29tbWFuZC1hY3RpdmV7YmFja2dyb3VuZC1pbWFnZTpub25lOy13ZWJraXQtYm94LXNoYWRvdzppbnNldCAwIDJweCA0cHggcmdiYSgwLDAsMCwuMTUpLDAgMXB4IDJweCByZ2JhKDAsMCwwLC4wNSk7LW1vei1ib3gtc2hhZG93Omluc2V0IDAgMnB4IDRweCByZ2JhKDAsMCwwLC4xNSksMCAxcHggMnB4IHJnYmEoMCwwLDAsLjA1KTtib3gtc2hhZG93Omluc2V0IDAgMnB4IDRweCByZ2JhKDAsMCwwLC4xNSksMCAxcHggMnB4IHJnYmEoMCwwLDAsLjA1KTtiYWNrZ3JvdW5kLWNvbG9yOiNlNmU2ZTY7YmFja2dyb3VuZC1jb2xvcjojZDlkOWQ5O291dGxpbmU6MH11bC53eXNpaHRtbDUtY29tbWFuZHMtZGlzYWJsZWQgLmRyb3Bkb3duLW1lbnV7ZGlzcGxheTpub25lIWltcG9ydGFudH11bC53eXNpaHRtbDUtdG9vbGJhciBkaXYud3lzaWh0bWw1LWNvbG9yc3tkaXNwbGF5OmJsb2NrO3dpZHRoOjUwcHg7aGVpZ2h0OjIwcHg7bWFyZ2luLXRvcDoycHg7bWFyZ2luLWxlZnQ6NXB4O3Bvc2l0aW9uOmFic29sdXRlO3BvaW50ZXItZXZlbnRzOm5vbmV9dWwud3lzaWh0bWw1LXRvb2xiYXIgYS53eXNpaHRtbDUtY29sb3JzLXRpdGxle3BhZGRpbmctbGVmdDo3MHB4fXVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPWNsZWFyXXtiYWNrZ3JvdW5kOiNhMzhhNzchaW1wb3J0YW50fXVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPWJsYWNrXXtiYWNrZ3JvdW5kOiMwMDAhaW1wb3J0YW50fXVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPXNpbHZlcl17YmFja2dyb3VuZDpzaWx2ZXIhaW1wb3J0YW50fXVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPWdyYXlde2JhY2tncm91bmQ6Z3JheSFpbXBvcnRhbnR9dWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9bWFyb29uXXtiYWNrZ3JvdW5kOm1hcm9vbiFpbXBvcnRhbnR9dWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9cmVkXXtiYWNrZ3JvdW5kOnJlZCFpbXBvcnRhbnR9dWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9cHVycGxlXXtiYWNrZ3JvdW5kOnB1cnBsZSFpbXBvcnRhbnR9dWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9Z3JlZW5de2JhY2tncm91bmQ6Z3JlZW4haW1wb3J0YW50fXVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPW9saXZlXXtiYWNrZ3JvdW5kOm9saXZlIWltcG9ydGFudH11bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1uYXZ5XXtiYWNrZ3JvdW5kOm5hdnkhaW1wb3J0YW50fXVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPWJsdWVde2JhY2tncm91bmQ6Ymx1ZSFpbXBvcnRhbnR9dWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9b3JhbmdlXXtiYWNrZ3JvdW5kOm9yYW5nZSFpbXBvcnRhbnR9dWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9Zmlyc3Rde2JhY2tncm91bmQ6IzE0OWQ5YSFpbXBvcnRhbnR9dWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9c2Vjb25kXXtiYWNrZ3JvdW5kOiNlMDI5MjQhaW1wb3J0YW50fXVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPXRocmVlXXtiYWNrZ3JvdW5kOiMyOTU0YTQhaW1wb3J0YW50fVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vc3JjL2VkaXRhYmxlL2Nzcy9ib290c3RyYXAtd3lzaWh0bWw1LmNzc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n')},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(0)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, "/*!\\n * Bootstrap v3.3.7 (http://getbootstrap.com)\\n * Copyright 2011-2017 Twitter, Inc.\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n */\\n\\n/*!\\n * Generated using the Bootstrap Customizer (https://getbootstrap.com/docs/3.3/customize/?id=6729ca5bfebd0b65e0f15f121902b07d)\\n * Config saved to config.json and https://gist.github.com/6729ca5bfebd0b65e0f15f121902b07d\\n *//*!\\n * Bootstrap v3.3.7 (http://getbootstrap.com)\\n * Copyright 2011-2016 Twitter, Inc.\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n *//*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}*,:after,:before{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:Helvetica Neue,Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#333;background-color:#fff}button,input,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#337ab7;text-decoration:none}a:focus,a:hover{color:#23527c;text-decoration:underline}a:focus{outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}figure{margin:0}img{vertical-align:middle}.img-responsive{display:block;max-width:100%;height:auto}.img-rounded{border-radius:6px}.img-thumbnail{padding:4px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out;display:inline-block;max-width:100%;height:auto}.img-circle{border-radius:50%}hr{margin-top:20px;margin-bottom:20px;border:0;border-top:1px solid #eee}.sr-only{position:absolute;width:1px;height:1px;margin:-1px;padding:0;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}.btn,[role=button]{cursor:pointer}.btn{display:inline-block;margin-bottom:0;font-weight:400;text-align:center;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;background-image:none;border:1px solid transparent;white-space:nowrap;padding:6px 12px;font-size:14px;line-height:1.42857143;border-radius:4px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.btn.active.focus,.btn.active:focus,.btn.focus,.btn:active.focus,.btn:active:focus,.btn:focus{outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.focus,.btn:focus,.btn:hover{color:#333;text-decoration:none}.btn.active,.btn:active{outline:0;background-image:none;-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{cursor:not-allowed;opacity:.65;filter:alpha(opacity=65);-webkit-box-shadow:none;box-shadow:none}a.btn.disabled,fieldset[disabled] a.btn{pointer-events:none}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default.focus,.btn-default:focus{color:#333;background-color:#e6e6e6;border-color:#8c8c8c}.btn-default.active,.btn-default:active,.btn-default:hover,.open>.dropdown-toggle.btn-default{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default.active.focus,.btn-default.active:focus,.btn-default.active:hover,.btn-default:active.focus,.btn-default:active:focus,.btn-default:active:hover,.open>.dropdown-toggle.btn-default.focus,.open>.dropdown-toggle.btn-default:focus,.open>.dropdown-toggle.btn-default:hover{color:#333;background-color:#d4d4d4;border-color:#8c8c8c}.btn-default.active,.btn-default:active,.open>.dropdown-toggle.btn-default{background-image:none}.btn-default.disabled.focus,.btn-default.disabled:focus,.btn-default.disabled:hover,.btn-default[disabled].focus,.btn-default[disabled]:focus,.btn-default[disabled]:hover,fieldset[disabled] .btn-default.focus,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:hover{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#337ab7;border-color:#2e6da4}.btn-primary.focus,.btn-primary:focus{color:#fff;background-color:#286090;border-color:#122b40}.btn-primary.active,.btn-primary:active,.btn-primary:hover,.open>.dropdown-toggle.btn-primary{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary.active.focus,.btn-primary.active:focus,.btn-primary.active:hover,.btn-primary:active.focus,.btn-primary:active:focus,.btn-primary:active:hover,.open>.dropdown-toggle.btn-primary.focus,.open>.dropdown-toggle.btn-primary:focus,.open>.dropdown-toggle.btn-primary:hover{color:#fff;background-color:#204d74;border-color:#122b40}.btn-primary.active,.btn-primary:active,.open>.dropdown-toggle.btn-primary{background-image:none}.btn-primary.disabled.focus,.btn-primary.disabled:focus,.btn-primary.disabled:hover,.btn-primary[disabled].focus,.btn-primary[disabled]:focus,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary.focus,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:hover{background-color:#337ab7;border-color:#2e6da4}.btn-primary .badge{color:#337ab7;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success.focus,.btn-success:focus{color:#fff;background-color:#449d44;border-color:#255625}.btn-success.active,.btn-success:active,.btn-success:hover,.open>.dropdown-toggle.btn-success{color:#fff;background-color:#449d44;border-color:#398439}.btn-success.active.focus,.btn-success.active:focus,.btn-success.active:hover,.btn-success:active.focus,.btn-success:active:focus,.btn-success:active:hover,.open>.dropdown-toggle.btn-success.focus,.open>.dropdown-toggle.btn-success:focus,.open>.dropdown-toggle.btn-success:hover{color:#fff;background-color:#398439;border-color:#255625}.btn-success.active,.btn-success:active,.open>.dropdown-toggle.btn-success{background-image:none}.btn-success.disabled.focus,.btn-success.disabled:focus,.btn-success.disabled:hover,.btn-success[disabled].focus,.btn-success[disabled]:focus,.btn-success[disabled]:hover,fieldset[disabled] .btn-success.focus,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:hover{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#5bc0de;border-color:#46b8da}.btn-info.focus,.btn-info:focus{color:#fff;background-color:#31b0d5;border-color:#1b6d85}.btn-info.active,.btn-info:active,.btn-info:hover,.open>.dropdown-toggle.btn-info{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info.active.focus,.btn-info.active:focus,.btn-info.active:hover,.btn-info:active.focus,.btn-info:active:focus,.btn-info:active:hover,.open>.dropdown-toggle.btn-info.focus,.open>.dropdown-toggle.btn-info:focus,.open>.dropdown-toggle.btn-info:hover{color:#fff;background-color:#269abc;border-color:#1b6d85}.btn-info.active,.btn-info:active,.open>.dropdown-toggle.btn-info{background-image:none}.btn-info.disabled.focus,.btn-info.disabled:focus,.btn-info.disabled:hover,.btn-info[disabled].focus,.btn-info[disabled]:focus,.btn-info[disabled]:hover,fieldset[disabled] .btn-info.focus,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:hover{background-color:#5bc0de;border-color:#46b8da}.btn-info .badge{color:#5bc0de;background-color:#fff}.btn-warning{color:#fff;background-color:#f0ad4e;border-color:#eea236}.btn-warning.focus,.btn-warning:focus{color:#fff;background-color:#ec971f;border-color:#985f0d}.btn-warning.active,.btn-warning:active,.btn-warning:hover,.open>.dropdown-toggle.btn-warning{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning.active.focus,.btn-warning.active:focus,.btn-warning.active:hover,.btn-warning:active.focus,.btn-warning:active:focus,.btn-warning:active:hover,.open>.dropdown-toggle.btn-warning.focus,.open>.dropdown-toggle.btn-warning:focus,.open>.dropdown-toggle.btn-warning:hover{color:#fff;background-color:#d58512;border-color:#985f0d}.btn-warning.active,.btn-warning:active,.open>.dropdown-toggle.btn-warning{background-image:none}.btn-warning.disabled.focus,.btn-warning.disabled:focus,.btn-warning.disabled:hover,.btn-warning[disabled].focus,.btn-warning[disabled]:focus,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning.focus,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:hover{background-color:#f0ad4e;border-color:#eea236}.btn-warning .badge{color:#f0ad4e;background-color:#fff}.btn-danger{color:#fff;background-color:#d9534f;border-color:#d43f3a}.btn-danger.focus,.btn-danger:focus{color:#fff;background-color:#c9302c;border-color:#761c19}.btn-danger.active,.btn-danger:active,.btn-danger:hover,.open>.dropdown-toggle.btn-danger{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger.active.focus,.btn-danger.active:focus,.btn-danger.active:hover,.btn-danger:active.focus,.btn-danger:active:focus,.btn-danger:active:hover,.open>.dropdown-toggle.btn-danger.focus,.open>.dropdown-toggle.btn-danger:focus,.open>.dropdown-toggle.btn-danger:hover{color:#fff;background-color:#ac2925;border-color:#761c19}.btn-danger.active,.btn-danger:active,.open>.dropdown-toggle.btn-danger{background-image:none}.btn-danger.disabled.focus,.btn-danger.disabled:focus,.btn-danger.disabled:hover,.btn-danger[disabled].focus,.btn-danger[disabled]:focus,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger.focus,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:hover{background-color:#d9534f;border-color:#d43f3a}.btn-danger .badge{color:#d9534f;background-color:#fff}.btn-link{color:#337ab7;font-weight:400;border-radius:0}.btn-link,.btn-link.active,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.btn-link,.btn-link:active,.btn-link:focus,.btn-link:hover{border-color:transparent}.btn-link:focus,.btn-link:hover{color:#23527c;text-decoration:underline;background-color:transparent}.btn-link[disabled]:focus,.btn-link[disabled]:hover,fieldset[disabled] .btn-link:focus,fieldset[disabled] .btn-link:hover{color:#777;text-decoration:none}.btn-group-lg>.btn,.btn-lg{padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}.btn-group-sm>.btn,.btn-sm{padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.btn-group-xs>.btn,.btn-xs{padding:1px 5px;font-size:12px;line-height:1.5;border-radius:3px}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type=button].btn-block,input[type=reset].btn-block,input[type=submit].btn-block{width:100%}.caret{display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-top:4px dashed;border-top:4px solid\\\\9;border-right:4px solid transparent;border-left:4px solid transparent}.dropdown,.dropup{position:relative}.dropdown-toggle:focus{outline:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;list-style:none;font-size:14px;text-align:left;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,.15);border-radius:4px;-webkit-box-shadow:0 6px 12px rgba(0,0,0,.175);box-shadow:0 6px 12px rgba(0,0,0,.175);-webkit-background-clip:padding-box;background-clip:padding-box}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:400;line-height:1.42857143;color:#333;white-space:nowrap}.dropdown-menu>li>a:focus,.dropdown-menu>li>a:hover{text-decoration:none;color:#262626;background-color:#f5f5f5}.dropdown-menu>.active>a,.dropdown-menu>.active>a:focus,.dropdown-menu>.active>a:hover{color:#fff;text-decoration:none;outline:0;background-color:#337ab7}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{color:#777}.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{text-decoration:none;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled = false);cursor:not-allowed}.open>.dropdown-menu{display:block}.open>a{outline:0}.dropdown-menu-right{left:auto;right:0}.dropdown-menu-left{left:0;right:auto}.dropdown-header{display:block;padding:3px 20px;font-size:12px;line-height:1.42857143;color:#777;white-space:nowrap}.dropdown-backdrop{position:fixed;left:0;right:0;bottom:0;top:0;z-index:990}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{border-top:0;border-bottom:4px dashed;border-bottom:4px solid\\\\9;content:\\"\\"}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:2px}@media (min-width:768px){.navbar-right .dropdown-menu{left:auto;right:0}.navbar-right .dropdown-menu-left{left:0;right:auto}}.btn-group,.btn-group-vertical{position:relative;display:inline-block;vertical-align:middle}.btn-group-vertical>.btn,.btn-group>.btn{position:relative;float:left}.btn-group-vertical>.btn.active,.btn-group-vertical>.btn:active,.btn-group-vertical>.btn:focus,.btn-group-vertical>.btn:hover,.btn-group>.btn.active,.btn-group>.btn:active,.btn-group>.btn:focus,.btn-group>.btn:hover{z-index:2}.btn-group .btn+.btn,.btn-group .btn+.btn-group,.btn-group .btn-group+.btn,.btn-group .btn-group+.btn-group{margin-left:-1px}.btn-toolbar{margin-left:-5px}.btn-toolbar .btn,.btn-toolbar .btn-group,.btn-toolbar .input-group{float:left}.btn-toolbar>.btn,.btn-toolbar>.btn-group,.btn-toolbar>.input-group{margin-left:5px}.btn-group>.btn:not(:first-child):not(:last-child):not(.dropdown-toggle){border-radius:0}.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn:first-child:not(:last-child):not(.dropdown-toggle){border-bottom-right-radius:0;border-top-right-radius:0}.btn-group>.btn:last-child:not(:first-child),.btn-group>.dropdown-toggle:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0}.btn-group>.btn-group{float:left}.btn-group>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-top-right-radius:0}.btn-group>.btn-group:last-child:not(:first-child)>.btn:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{padding-left:8px;padding-right:8px}.btn-group>.btn-lg+.dropdown-toggle{padding-left:12px;padding-right:12px}.btn-group.open .dropdown-toggle{-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn-group.open .dropdown-toggle.btn-link{-webkit-box-shadow:none;box-shadow:none}.btn .caret{margin-left:0}.btn-lg .caret{border-width:5px 5px 0;border-bottom-width:0}.dropup .btn-lg .caret{border-width:0 5px 5px}.btn-group-vertical>.btn,.btn-group-vertical>.btn-group,.btn-group-vertical>.btn-group>.btn{display:block;float:none;width:100%;max-width:100%}.btn-group-vertical>.btn-group>.btn{float:none}.btn-group-vertical>.btn+.btn,.btn-group-vertical>.btn+.btn-group,.btn-group-vertical>.btn-group+.btn,.btn-group-vertical>.btn-group+.btn-group{margin-top:-1px;margin-left:0}.btn-group-vertical>.btn:not(:first-child):not(:last-child){border-radius:0}.btn-group-vertical>.btn:first-child:not(:last-child){border-top-right-radius:4px;border-top-left-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn:last-child:not(:first-child){border-top-right-radius:0;border-top-left-radius:0;border-bottom-right-radius:4px;border-bottom-left-radius:4px}.btn-group-vertical>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group-vertical>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group-vertical>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-right-radius:0;border-top-left-radius:0}.btn-group-justified{display:table;width:100%;table-layout:fixed;border-collapse:separate}.btn-group-justified>.btn,.btn-group-justified>.btn-group{float:none;display:table-cell;width:1%}.btn-group-justified>.btn-group .btn{width:100%}.btn-group-justified>.btn-group .dropdown-menu{left:auto}[data-toggle=buttons]>.btn-group>.btn input[type=checkbox],[data-toggle=buttons]>.btn-group>.btn input[type=radio],[data-toggle=buttons]>.btn input[type=checkbox],[data-toggle=buttons]>.btn input[type=radio]{position:absolute;clip:rect(0,0,0,0);pointer-events:none}.tooltip{position:absolute;z-index:1070;display:block;font-family:Helvetica Neue,Helvetica,Arial,sans-serif;font-style:normal;font-weight:400;letter-spacing:normal;line-break:auto;line-height:1.42857143;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;white-space:normal;word-break:normal;word-spacing:normal;word-wrap:normal;font-size:12px;opacity:0;filter:alpha(opacity=0)}.tooltip.in{opacity:.9;filter:alpha(opacity=90)}.tooltip.top{margin-top:-3px;padding:5px 0}.tooltip.right{margin-left:3px;padding:0 5px}.tooltip.bottom{margin-top:3px;padding:5px 0}.tooltip.left{margin-left:-3px;padding:0 5px}.tooltip-inner{max-width:200px;padding:3px 8px;color:#fff;text-align:center;background-color:#000;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-left .tooltip-arrow{right:5px}.tooltip.top-left .tooltip-arrow,.tooltip.top-right .tooltip-arrow{bottom:0;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-right .tooltip-arrow{left:5px}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-width:5px 5px 5px 0;border-right-color:#000}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-width:5px 0 5px 5px;border-left-color:#000}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-left .tooltip-arrow{top:0;right:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-right .tooltip-arrow{top:0;left:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.btn-group-vertical>.btn-group:after,.btn-group-vertical>.btn-group:before,.btn-toolbar:after,.btn-toolbar:before,.clearfix:after,.clearfix:before{content:\\" \\";display:table}.btn-group-vertical>.btn-group:after,.btn-toolbar:after,.clearfix:after{clear:both}.center-block{display:block;margin-left:auto;margin-right:auto}.pull-right{float:right!important}.pull-left{float:left!important}.hide{display:none!important}.show{display:block!important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none!important}.affix{position:fixed}", ""]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC5taW4uY3NzPzlhYWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSwycUJBQTRxQix1QkFBdUIsMEJBQTBCLDhCQUE4QixLQUFLLFNBQVMsMkZBQTJGLGNBQWMsNEJBQTRCLHFCQUFxQix3QkFBd0Isc0JBQXNCLGFBQWEsU0FBUyxrQkFBa0IsYUFBYSxFQUFFLDZCQUE2QixpQkFBaUIsVUFBVSxZQUFZLHlCQUF5QixTQUFTLGdCQUFnQixJQUFJLGtCQUFrQixHQUFHLGNBQWMsZUFBZSxLQUFLLGdCQUFnQixXQUFXLE1BQU0sY0FBYyxRQUFRLGNBQWMsY0FBYyxrQkFBa0Isd0JBQXdCLElBQUksVUFBVSxJQUFJLGNBQWMsSUFBSSxTQUFTLGVBQWUsZ0JBQWdCLE9BQU8sZ0JBQWdCLEdBQUcsK0JBQStCLDRCQUE0Qix1QkFBdUIsU0FBUyxJQUFJLGNBQWMsa0JBQWtCLGdDQUFnQyxjQUFjLHNDQUFzQyxjQUFjLGFBQWEsU0FBUyxPQUFPLGlCQUFpQixjQUFjLG9CQUFvQixvRUFBb0UsMEJBQTBCLGVBQWUsc0NBQXNDLGVBQWUsaURBQWlELFNBQVMsVUFBVSxNQUFNLG1CQUFtQix1Q0FBdUMsOEJBQThCLDJCQUEyQixzQkFBc0IsVUFBVSw0RkFBNEYsWUFBWSxtQkFBbUIsNkJBQTZCLCtCQUErQiw0QkFBNEIsdUJBQXVCLCtGQUErRix3QkFBd0IsU0FBUyx3QkFBd0IsYUFBYSwyQkFBMkIsT0FBTyxTQUFTLFVBQVUsU0FBUyxjQUFjLFNBQVMsZ0JBQWdCLE1BQU0seUJBQXlCLGlCQUFpQixNQUFNLFVBQVUsaUJBQWlCLDhCQUE4QiwyQkFBMkIsc0JBQXNCLEtBQUssZUFBZSwwQ0FBMEMsS0FBSyxzREFBc0QsZUFBZSx1QkFBdUIsV0FBVyxzQkFBc0IsNkJBQTZCLG9CQUFvQixrQkFBa0Isb0JBQW9CLEVBQUUsY0FBYyxxQkFBcUIsZ0JBQWdCLGNBQWMs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QixNQUFNLFNBQVMsaUJBQWlCLHVCQUF1Qix5QkFBeUIsb0NBQW9DLE1BQU0sVUFBVSxnQkFBZ0IsdUJBQXVCLHlCQUF5QixxQ0FBcUMsTUFBTSxTQUFTLGdCQUFnQix1QkFBdUIseUJBQXlCLG1KQUFtSixjQUFjLGNBQWMsd0VBQXdFLFdBQVcsY0FBYyxjQUFjLGlCQUFpQixrQkFBa0IsWUFBWSxzQkFBc0IsV0FBVyxxQkFBcUIsTUFBTSx1QkFBdUIsTUFBTSx3QkFBd0IsV0FBVyxrQkFBa0IsV0FBVyxXQUFXLGtCQUFrQixpQkFBaUIsNkJBQTZCLFNBQVMsUUFBUSx1QkFBdUIsT0FBTyxlQUFlOztBQUVscXBCIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyohXFxuICogQm9vdHN0cmFwIHYzLjMuNyAoaHR0cDovL2dldGJvb3RzdHJhcC5jb20pXFxuICogQ29weXJpZ2h0IDIwMTEtMjAxNyBUd2l0dGVyLCBJbmMuXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcXG4gKi9cXG5cXG4vKiFcXG4gKiBHZW5lcmF0ZWQgdXNpbmcgdGhlIEJvb3RzdHJhcCBDdXN0b21pemVyIChodHRwczovL2dldGJvb3RzdHJhcC5jb20vZG9jcy8zLjMvY3VzdG9taXplLz9pZD02NzI5Y2E1YmZlYmQwYjY1ZTBmMTVmMTIxOTAyYjA3ZClcXG4gKiBDb25maWcgc2F2ZWQgdG8gY29uZmlnLmpzb24gYW5kIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzY3MjljYTViZmViZDBiNjVlMGYxNWYxMjE5MDJiMDdkXFxuICovLyohXFxuICogQm9vdHN0cmFwIHYzLjMuNyAoaHR0cDovL2dldGJvb3RzdHJhcC5jb20pXFxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBUd2l0dGVyLCBJbmMuXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcXG4gKi8vKiEgbm9ybWFsaXplLmNzcyB2My4wLjMgfCBNSVQgTGljZW5zZSB8IGdpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzICovaHRtbHtmb250LWZhbWlseTpzYW5zLXNlcmlmOy1tcy10ZXh0LXNpemUtYWRqdXN0OjEwMCU7LXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OjEwMCV9Ym9keXttYXJnaW46MH1hcnRpY2xlLGFzaWRlLGRldGFpbHMsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsbWFpbixtZW51LG5hdixzZWN0aW9uLHN1bW1hcnl7ZGlzcGxheTpibG9ja31hdWRpbyxjYW52YXMscHJvZ3Jlc3MsdmlkZW97ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9YXVkaW86bm90KFtjb250cm9sc10pe2Rpc3BsYXk6bm9uZTtoZWlnaHQ6MH1baGlkZGVuXSx0ZW1wbGF0ZXtkaXNwbGF5Om5vbmV9YXtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fWE6YWN0aXZlLGE6aG92ZXJ7b3V0bGluZTowfWFiYnJbdGl0bGVde2JvcmRlci1ib3R0b206MXB4IGRvdHRlZH1iLHN0cm9uZ3tmb250LXdlaWdodDo3MDB9ZGZue2ZvbnQtc3R5bGU6aXRhbGljfWgxe2ZvbnQtc2l6ZToyZW07bWFyZ2luOi42N2VtIDB9bWFya3tiYWNrZ3JvdW5kOiNmZjA7Y29sb3I6IzAwMH1zbWFsbHtmb250LXNpemU6ODAlfXN1YixzdXB7Zm9udC1zaXplOjc1JTtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfXN1cHt0b3A6LS41ZW19c3Vie2JvdHRvbTotLjI1ZW19aW1ne2JvcmRlcjowfXN2Zzpub3QoOnJvb3Qpe292ZXJmbG93OmhpZGRlbn1maWd1cmV7bWFyZ2luOjFlbSA0MHB4fWhyey13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtoZWlnaHQ6MH1wcmV7b3ZlcmZsb3c6YXV0b31jb2RlLGtiZCxwcmUsc2FtcHtmb250LWZhbWlseTptb25vc3BhY2UsbW9ub3NwYWNlO2ZvbnQtc2l6ZToxZW19YnV0dG9uLGlucHV0LG9wdGdyb3VwLHNlbGVjdCx0ZXh0YXJlYXtjb2xvcjppbmhlcml0O2ZvbnQ6aW5oZXJpdDttYXJnaW46MH1idXR0b257b3ZlcmZsb3c6dmlzaWJsZX1idXR0b24sc2VsZWN0e3RleHQtdHJhbnNmb3JtOm5vbmV9YnV0dG9uLGh0bWwgaW5wdXRbdHlwZT1idXR0b25dLGlucHV0W3R5cGU9cmVzZXRdLGlucHV0W3R5cGU9c3VibWl0XXstd2Via2l0LWFwcGVhcmFuY2U6YnV0dG9uO2N1cnNvcjpwb2ludGVyfWJ1dHRvbltkaXNhYmxlZF0saHRtbCBpbnB1dFtkaXNhYmxlZF17Y3Vyc29yOmRlZmF1bHR9YnV0dG9uOjotbW96LWZvY3VzLWlubmVyLGlucHV0OjotbW96LWZvY3VzLWlubmVye2JvcmRlcjowO3BhZGRpbmc6MH1pbnB1dHtsaW5lLWhlaWdodDpub3JtYWx9aW5wdXRbdHlwZT1jaGVja2JveF0saW5wdXRbdHlwZT1yYWRpb117LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6MH1pbnB1dFt0eXBlPW51bWJlcl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24saW5wdXRbdHlwZT1udW1iZXJdOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9ue2hlaWdodDphdXRvfWlucHV0W3R5cGU9c2VhcmNoXXstd2Via2l0LWFwcGVhcmFuY2U6dGV4dGZpZWxkOy13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveH1pbnB1dFt0eXBlPXNlYXJjaF06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24saW5wdXRbdHlwZT1zZWFyY2hdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uey13ZWJraXQtYXBwZWFyYW5jZTpub25lfWZpZWxkc2V0e2JvcmRlcjoxcHggc29saWQgc2lsdmVyO21hcmdpbjowIDJweDtwYWRkaW5nOi4zNWVtIC42MjVlbSAuNzVlbX1sZWdlbmR7Ym9yZGVyOjA7cGFkZGluZzowfXRleHRhcmVhe292ZXJmbG93OmF1dG99b3B0Z3JvdXB7Zm9udC13ZWlnaHQ6NzAwfXRhYmxle2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZTtib3JkZXItc3BhY2luZzowfXRkLHRoe3BhZGRpbmc6MH0qLDphZnRlciw6YmVmb3Jley13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH1odG1se2ZvbnQtc2l6ZToxMHB4Oy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjpyZ2JhKDAsMCwwLDApfWJvZHl7Zm9udC1mYW1pbHk6SGVsdmV0aWNhIE5ldWUsSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS40Mjg1NzE0Mztjb2xvcjojMzMzO2JhY2tncm91bmQtY29sb3I6I2ZmZn1idXR0b24saW5wdXQsc2VsZWN0LHRleHRhcmVhe2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOmluaGVyaXQ7bGluZS1oZWlnaHQ6aW5oZXJpdH1he2NvbG9yOiMzMzdhYjc7dGV4dC1kZWNvcmF0aW9uOm5vbmV9YTpmb2N1cyxhOmhvdmVye2NvbG9yOiMyMzUyN2M7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZX1hOmZvY3Vze291dGxpbmU6NXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yO291dGxpbmUtb2Zmc2V0Oi0ycHh9ZmlndXJle21hcmdpbjowfWltZ3t2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmltZy1yZXNwb25zaXZle2Rpc3BsYXk6YmxvY2s7bWF4LXdpZHRoOjEwMCU7aGVpZ2h0OmF1dG99LmltZy1yb3VuZGVke2JvcmRlci1yYWRpdXM6NnB4fS5pbWctdGh1bWJuYWlse3BhZGRpbmc6NHB4O2xpbmUtaGVpZ2h0OjEuNDI4NTcxNDM7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI2RkZDtib3JkZXItcmFkaXVzOjRweDstd2Via2l0LXRyYW5zaXRpb246YWxsIC4ycyBlYXNlLWluLW91dDstby10cmFuc2l0aW9uOmFsbCAuMnMgZWFzZS1pbi1vdXQ7dHJhbnNpdGlvbjphbGwgLjJzIGVhc2UtaW4tb3V0O2Rpc3BsYXk6aW5saW5lLWJsb2NrO21heC13aWR0aDoxMDAlO2hlaWdodDphdXRvfS5pbWctY2lyY2xle2JvcmRlci1yYWRpdXM6NTAlfWhye21hcmdpbi10b3A6MjBweDttYXJnaW4tYm90dG9tOjIwcHg7Ym9yZGVyOjA7Ym9yZGVyLXRvcDoxcHggc29saWQgI2VlZX0uc3Itb25seXtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxcHg7aGVpZ2h0OjFweDttYXJnaW46LTFweDtwYWRkaW5nOjA7b3ZlcmZsb3c6aGlkZGVuO2NsaXA6cmVjdCgwLDAsMCwwKTtib3JkZXI6MH0uc3Itb25seS1mb2N1c2FibGU6YWN0aXZlLC5zci1vbmx5LWZvY3VzYWJsZTpmb2N1c3twb3NpdGlvbjpzdGF0aWM7d2lkdGg6YXV0bztoZWlnaHQ6YXV0bzttYXJnaW46MDtvdmVyZmxvdzp2aXNpYmxlO2NsaXA6YXV0b30uYnRuLFtyb2xlPWJ1dHRvbl17Y3Vyc29yOnBvaW50ZXJ9LmJ0bntkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tYm90dG9tOjA7Zm9udC13ZWlnaHQ6NDAwO3RleHQtYWxpZ246Y2VudGVyO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTstbXMtdG91Y2gtYWN0aW9uOm1hbmlwdWxhdGlvbjt0b3VjaC1hY3Rpb246bWFuaXB1bGF0aW9uO2JhY2tncm91bmQtaW1hZ2U6bm9uZTtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O3doaXRlLXNwYWNlOm5vd3JhcDtwYWRkaW5nOjZweCAxMnB4O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjEuNDI4NTcxNDM7Ym9yZGVyLXJhZGl1czo0cHg7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5idG4uYWN0aXZlLmZvY3VzLC5idG4uYWN0aXZlOmZvY3VzLC5idG4uZm9jdXMsLmJ0bjphY3RpdmUuZm9jdXMsLmJ0bjphY3RpdmU6Zm9jdXMsLmJ0bjpmb2N1c3tvdXRsaW5lOjVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcjtvdXRsaW5lLW9mZnNldDotMnB4fS5idG4uZm9jdXMsLmJ0bjpmb2N1cywuYnRuOmhvdmVye2NvbG9yOiMzMzM7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmJ0bi5hY3RpdmUsLmJ0bjphY3RpdmV7b3V0bGluZTowO2JhY2tncm91bmQtaW1hZ2U6bm9uZTstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAzcHggNXB4IHJnYmEoMCwwLDAsLjEyNSk7Ym94LXNoYWRvdzppbnNldCAwIDNweCA1cHggcmdiYSgwLDAsMCwuMTI1KX0uYnRuLmRpc2FibGVkLC5idG5bZGlzYWJsZWRdLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRue2N1cnNvcjpub3QtYWxsb3dlZDtvcGFjaXR5Oi42NTtmaWx0ZXI6YWxwaGEob3BhY2l0eT02NSk7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lfWEuYnRuLmRpc2FibGVkLGZpZWxkc2V0W2Rpc2FibGVkXSBhLmJ0bntwb2ludGVyLWV2ZW50czpub25lfS5idG4tZGVmYXVsdHtjb2xvcjojMzMzO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXItY29sb3I6I2NjY30uYnRuLWRlZmF1bHQuZm9jdXMsLmJ0bi1kZWZhdWx0OmZvY3Vze2NvbG9yOiMzMzM7YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2O2JvcmRlci1jb2xvcjojOGM4YzhjfS5idG4tZGVmYXVsdC5hY3RpdmUsLmJ0bi1kZWZhdWx0OmFjdGl2ZSwuYnRuLWRlZmF1bHQ6aG92ZXIsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tZGVmYXVsdHtjb2xvcjojMzMzO2JhY2tncm91bmQtY29sb3I6I2U2ZTZlNjtib3JkZXItY29sb3I6I2FkYWRhZH0uYnRuLWRlZmF1bHQuYWN0aXZlLmZvY3VzLC5idG4tZGVmYXVsdC5hY3RpdmU6Zm9jdXMsLmJ0bi1kZWZhdWx0LmFjdGl2ZTpob3ZlciwuYnRuLWRlZmF1bHQ6YWN0aXZlLmZvY3VzLC5idG4tZGVmYXVsdDphY3RpdmU6Zm9jdXMsLmJ0bi1kZWZhdWx0OmFjdGl2ZTpob3Zlciwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1kZWZhdWx0LmZvY3VzLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLWRlZmF1bHQ6Zm9jdXMsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tZGVmYXVsdDpob3Zlcntjb2xvcjojMzMzO2JhY2tncm91bmQtY29sb3I6I2Q0ZDRkNDtib3JkZXItY29sb3I6IzhjOGM4Y30uYnRuLWRlZmF1bHQuYWN0aXZlLC5idG4tZGVmYXVsdDphY3RpdmUsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tZGVmYXVsdHtiYWNrZ3JvdW5kLWltYWdlOm5vbmV9LmJ0bi1kZWZhdWx0LmRpc2FibGVkLmZvY3VzLC5idG4tZGVmYXVsdC5kaXNhYmxlZDpmb2N1cywuYnRuLWRlZmF1bHQuZGlzYWJsZWQ6aG92ZXIsLmJ0bi1kZWZhdWx0W2Rpc2FibGVkXS5mb2N1cywuYnRuLWRlZmF1bHRbZGlzYWJsZWRdOmZvY3VzLC5idG4tZGVmYXVsdFtkaXNhYmxlZF06aG92ZXIsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4tZGVmYXVsdC5mb2N1cyxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1kZWZhdWx0OmZvY3VzLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLWRlZmF1bHQ6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlci1jb2xvcjojY2NjfS5idG4tZGVmYXVsdCAuYmFkZ2V7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMzMzN9LmJ0bi1wcmltYXJ5e2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMzM3YWI3O2JvcmRlci1jb2xvcjojMmU2ZGE0fS5idG4tcHJpbWFyeS5mb2N1cywuYnRuLXByaW1hcnk6Zm9jdXN7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMyODYwOTA7Ym9yZGVyLWNvbG9yOiMxMjJiNDB9LmJ0bi1wcmltYXJ5LmFjdGl2ZSwuYnRuLXByaW1hcnk6YWN0aXZlLC5idG4tcHJpbWFyeTpob3Zlciwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1wcmltYXJ5e2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMjg2MDkwO2JvcmRlci1jb2xvcjojMjA0ZDc0fS5idG4tcHJpbWFyeS5hY3RpdmUuZm9jdXMsLmJ0bi1wcmltYXJ5LmFjdGl2ZTpmb2N1cywuYnRuLXByaW1hcnkuYWN0aXZlOmhvdmVyLC5idG4tcHJpbWFyeTphY3RpdmUuZm9jdXMsLmJ0bi1wcmltYXJ5OmFjdGl2ZTpmb2N1cywuYnRuLXByaW1hcnk6YWN0aXZlOmhvdmVyLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXByaW1hcnkuZm9jdXMsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tcHJpbWFyeTpmb2N1cywub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1wcmltYXJ5OmhvdmVye2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMjA0ZDc0O2JvcmRlci1jb2xvcjojMTIyYjQwfS5idG4tcHJpbWFyeS5hY3RpdmUsLmJ0bi1wcmltYXJ5OmFjdGl2ZSwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1wcmltYXJ5e2JhY2tncm91bmQtaW1hZ2U6bm9uZX0uYnRuLXByaW1hcnkuZGlzYWJsZWQuZm9jdXMsLmJ0bi1wcmltYXJ5LmRpc2FibGVkOmZvY3VzLC5idG4tcHJpbWFyeS5kaXNhYmxlZDpob3ZlciwuYnRuLXByaW1hcnlbZGlzYWJsZWRdLmZvY3VzLC5idG4tcHJpbWFyeVtkaXNhYmxlZF06Zm9jdXMsLmJ0bi1wcmltYXJ5W2Rpc2FibGVkXTpob3ZlcixmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1wcmltYXJ5LmZvY3VzLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLXByaW1hcnk6Zm9jdXMsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4tcHJpbWFyeTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMzMzdhYjc7Ym9yZGVyLWNvbG9yOiMyZTZkYTR9LmJ0bi1wcmltYXJ5IC5iYWRnZXtjb2xvcjojMzM3YWI3O2JhY2tncm91bmQtY29sb3I6I2ZmZn0uYnRuLXN1Y2Nlc3N7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiM1Y2I4NWM7Ym9yZGVyLWNvbG9yOiM0Y2FlNGN9LmJ0bi1zdWNjZXNzLmZvY3VzLC5idG4tc3VjY2Vzczpmb2N1c3tjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzQ0OWQ0NDtib3JkZXItY29sb3I6IzI1NTYyNX0uYnRuLXN1Y2Nlc3MuYWN0aXZlLC5idG4tc3VjY2VzczphY3RpdmUsLmJ0bi1zdWNjZXNzOmhvdmVyLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXN1Y2Nlc3N7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiM0NDlkNDQ7Ym9yZGVyLWNvbG9yOiMzOTg0Mzl9LmJ0bi1zdWNjZXNzLmFjdGl2ZS5mb2N1cywuYnRuLXN1Y2Nlc3MuYWN0aXZlOmZvY3VzLC5idG4tc3VjY2Vzcy5hY3RpdmU6aG92ZXIsLmJ0bi1zdWNjZXNzOmFjdGl2ZS5mb2N1cywuYnRuLXN1Y2Nlc3M6YWN0aXZlOmZvY3VzLC5idG4tc3VjY2VzczphY3RpdmU6aG92ZXIsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tc3VjY2Vzcy5mb2N1cywub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1zdWNjZXNzOmZvY3VzLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXN1Y2Nlc3M6aG92ZXJ7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMzOTg0Mzk7Ym9yZGVyLWNvbG9yOiMyNTU2MjV9LmJ0bi1zdWNjZXNzLmFjdGl2ZSwuYnRuLXN1Y2Nlc3M6YWN0aXZlLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXN1Y2Nlc3N7YmFja2dyb3VuZC1pbWFnZTpub25lfS5idG4tc3VjY2Vzcy5kaXNhYmxlZC5mb2N1cywuYnRuLXN1Y2Nlc3MuZGlzYWJsZWQ6Zm9jdXMsLmJ0bi1zdWNjZXNzLmRpc2FibGVkOmhvdmVyLC5idG4tc3VjY2Vzc1tkaXNhYmxlZF0uZm9jdXMsLmJ0bi1zdWNjZXNzW2Rpc2FibGVkXTpmb2N1cywuYnRuLXN1Y2Nlc3NbZGlzYWJsZWRdOmhvdmVyLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLXN1Y2Nlc3MuZm9jdXMsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4tc3VjY2Vzczpmb2N1cyxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1zdWNjZXNzOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzVjYjg1Yztib3JkZXItY29sb3I6IzRjYWU0Y30uYnRuLXN1Y2Nlc3MgLmJhZGdle2NvbG9yOiM1Y2I4NWM7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5idG4taW5mb3tjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzViYzBkZTtib3JkZXItY29sb3I6IzQ2YjhkYX0uYnRuLWluZm8uZm9jdXMsLmJ0bi1pbmZvOmZvY3Vze2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMzFiMGQ1O2JvcmRlci1jb2xvcjojMWI2ZDg1fS5idG4taW5mby5hY3RpdmUsLmJ0bi1pbmZvOmFjdGl2ZSwuYnRuLWluZm86aG92ZXIsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4taW5mb3tjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzMxYjBkNTtib3JkZXItY29sb3I6IzI2OWFiY30uYnRuLWluZm8uYWN0aXZlLmZvY3VzLC5idG4taW5mby5hY3RpdmU6Zm9jdXMsLmJ0bi1pbmZvLmFjdGl2ZTpob3ZlciwuYnRuLWluZm86YWN0aXZlLmZvY3VzLC5idG4taW5mbzphY3RpdmU6Zm9jdXMsLmJ0bi1pbmZvOmFjdGl2ZTpob3Zlciwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1pbmZvLmZvY3VzLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLWluZm86Zm9jdXMsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4taW5mbzpob3Zlcntjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzI2OWFiYztib3JkZXItY29sb3I6IzFiNmQ4NX0uYnRuLWluZm8uYWN0aXZlLC5idG4taW5mbzphY3RpdmUsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4taW5mb3tiYWNrZ3JvdW5kLWltYWdlOm5vbmV9LmJ0bi1pbmZvLmRpc2FibGVkLmZvY3VzLC5idG4taW5mby5kaXNhYmxlZDpmb2N1cywuYnRuLWluZm8uZGlzYWJsZWQ6aG92ZXIsLmJ0bi1pbmZvW2Rpc2FibGVkXS5mb2N1cywuYnRuLWluZm9bZGlzYWJsZWRdOmZvY3VzLC5idG4taW5mb1tkaXNhYmxlZF06aG92ZXIsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4taW5mby5mb2N1cyxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1pbmZvOmZvY3VzLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLWluZm86aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojNWJjMGRlO2JvcmRlci1jb2xvcjojNDZiOGRhfS5idG4taW5mbyAuYmFkZ2V7Y29sb3I6IzViYzBkZTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LmJ0bi13YXJuaW5ne2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojZjBhZDRlO2JvcmRlci1jb2xvcjojZWVhMjM2fS5idG4td2FybmluZy5mb2N1cywuYnRuLXdhcm5pbmc6Zm9jdXN7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiNlYzk3MWY7Ym9yZGVyLWNvbG9yOiM5ODVmMGR9LmJ0bi13YXJuaW5nLmFjdGl2ZSwuYnRuLXdhcm5pbmc6YWN0aXZlLC5idG4td2FybmluZzpob3Zlciwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi13YXJuaW5ne2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojZWM5NzFmO2JvcmRlci1jb2xvcjojZDU4NTEyfS5idG4td2FybmluZy5hY3RpdmUuZm9jdXMsLmJ0bi13YXJuaW5nLmFjdGl2ZTpmb2N1cywuYnRuLXdhcm5pbmcuYWN0aXZlOmhvdmVyLC5idG4td2FybmluZzphY3RpdmUuZm9jdXMsLmJ0bi13YXJuaW5nOmFjdGl2ZTpmb2N1cywuYnRuLXdhcm5pbmc6YWN0aXZlOmhvdmVyLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXdhcm5pbmcuZm9jdXMsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4td2FybmluZzpmb2N1cywub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi13YXJuaW5nOmhvdmVye2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojZDU4NTEyO2JvcmRlci1jb2xvcjojOTg1ZjBkfS5idG4td2FybmluZy5hY3RpdmUsLmJ0bi13YXJuaW5nOmFjdGl2ZSwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi13YXJuaW5ne2JhY2tncm91bmQtaW1hZ2U6bm9uZX0uYnRuLXdhcm5pbmcuZGlzYWJsZWQuZm9jdXMsLmJ0bi13YXJuaW5nLmRpc2FibGVkOmZvY3VzLC5idG4td2FybmluZy5kaXNhYmxlZDpob3ZlciwuYnRuLXdhcm5pbmdbZGlzYWJsZWRdLmZvY3VzLC5idG4td2FybmluZ1tkaXNhYmxlZF06Zm9jdXMsLmJ0bi13YXJuaW5nW2Rpc2FibGVkXTpob3ZlcixmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi13YXJuaW5nLmZvY3VzLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLXdhcm5pbmc6Zm9jdXMsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4td2FybmluZzpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmMGFkNGU7Ym9yZGVyLWNvbG9yOiNlZWEyMzZ9LmJ0bi13YXJuaW5nIC5iYWRnZXtjb2xvcjojZjBhZDRlO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uYnRuLWRhbmdlcntjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6I2Q5NTM0Zjtib3JkZXItY29sb3I6I2Q0M2YzYX0uYnRuLWRhbmdlci5mb2N1cywuYnRuLWRhbmdlcjpmb2N1c3tjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6I2M5MzAyYztib3JkZXItY29sb3I6Izc2MWMxOX0uYnRuLWRhbmdlci5hY3RpdmUsLmJ0bi1kYW5nZXI6YWN0aXZlLC5idG4tZGFuZ2VyOmhvdmVyLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLWRhbmdlcntjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6I2M5MzAyYztib3JkZXItY29sb3I6I2FjMjkyNX0uYnRuLWRhbmdlci5hY3RpdmUuZm9jdXMsLmJ0bi1kYW5nZXIuYWN0aXZlOmZvY3VzLC5idG4tZGFuZ2VyLmFjdGl2ZTpob3ZlciwuYnRuLWRhbmdlcjphY3RpdmUuZm9jdXMsLmJ0bi1kYW5nZXI6YWN0aXZlOmZvY3VzLC5idG4tZGFuZ2VyOmFjdGl2ZTpob3Zlciwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1kYW5nZXIuZm9jdXMsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tZGFuZ2VyOmZvY3VzLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLWRhbmdlcjpob3Zlcntjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6I2FjMjkyNTtib3JkZXItY29sb3I6Izc2MWMxOX0uYnRuLWRhbmdlci5hY3RpdmUsLmJ0bi1kYW5nZXI6YWN0aXZlLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLWRhbmdlcntiYWNrZ3JvdW5kLWltYWdlOm5vbmV9LmJ0bi1kYW5nZXIuZGlzYWJsZWQuZm9jdXMsLmJ0bi1kYW5nZXIuZGlzYWJsZWQ6Zm9jdXMsLmJ0bi1kYW5nZXIuZGlzYWJsZWQ6aG92ZXIsLmJ0bi1kYW5nZXJbZGlzYWJsZWRdLmZvY3VzLC5idG4tZGFuZ2VyW2Rpc2FibGVkXTpmb2N1cywuYnRuLWRhbmdlcltkaXNhYmxlZF06aG92ZXIsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4tZGFuZ2VyLmZvY3VzLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLWRhbmdlcjpmb2N1cyxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1kYW5nZXI6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZDk1MzRmO2JvcmRlci1jb2xvcjojZDQzZjNhfS5idG4tZGFuZ2VyIC5iYWRnZXtjb2xvcjojZDk1MzRmO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uYnRuLWxpbmt7Y29sb3I6IzMzN2FiNztmb250LXdlaWdodDo0MDA7Ym9yZGVyLXJhZGl1czowfS5idG4tbGluaywuYnRuLWxpbmsuYWN0aXZlLC5idG4tbGluazphY3RpdmUsLmJ0bi1saW5rW2Rpc2FibGVkXSxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1saW5re2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7LXdlYmtpdC1ib3gtc2hhZG93Om5vbmU7Ym94LXNoYWRvdzpub25lfS5idG4tbGluaywuYnRuLWxpbms6YWN0aXZlLC5idG4tbGluazpmb2N1cywuYnRuLWxpbms6aG92ZXJ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50fS5idG4tbGluazpmb2N1cywuYnRuLWxpbms6aG92ZXJ7Y29sb3I6IzIzNTI3Yzt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9LmJ0bi1saW5rW2Rpc2FibGVkXTpmb2N1cywuYnRuLWxpbmtbZGlzYWJsZWRdOmhvdmVyLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLWxpbms6Zm9jdXMsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4tbGluazpob3Zlcntjb2xvcjojNzc3O3RleHQtZGVjb3JhdGlvbjpub25lfS5idG4tZ3JvdXAtbGc+LmJ0biwuYnRuLWxne3BhZGRpbmc6MTBweCAxNnB4O2ZvbnQtc2l6ZToxOHB4O2xpbmUtaGVpZ2h0OjEuMzMzMzMzMztib3JkZXItcmFkaXVzOjZweH0uYnRuLWdyb3VwLXNtPi5idG4sLmJ0bi1zbXtwYWRkaW5nOjVweCAxMHB4O2ZvbnQtc2l6ZToxMnB4O2xpbmUtaGVpZ2h0OjEuNTtib3JkZXItcmFkaXVzOjNweH0uYnRuLWdyb3VwLXhzPi5idG4sLmJ0bi14c3twYWRkaW5nOjFweCA1cHg7Zm9udC1zaXplOjEycHg7bGluZS1oZWlnaHQ6MS41O2JvcmRlci1yYWRpdXM6M3B4fS5idG4tYmxvY2t7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlfS5idG4tYmxvY2srLmJ0bi1ibG9ja3ttYXJnaW4tdG9wOjVweH1pbnB1dFt0eXBlPWJ1dHRvbl0uYnRuLWJsb2NrLGlucHV0W3R5cGU9cmVzZXRdLmJ0bi1ibG9jayxpbnB1dFt0eXBlPXN1Ym1pdF0uYnRuLWJsb2Nre3dpZHRoOjEwMCV9LmNhcmV0e2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7bWFyZ2luLWxlZnQ6MnB4O3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtib3JkZXItdG9wOjRweCBkYXNoZWQ7Ym9yZGVyLXRvcDo0cHggc29saWRcXFxcOTtib3JkZXItcmlnaHQ6NHB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjRweCBzb2xpZCB0cmFuc3BhcmVudH0uZHJvcGRvd24sLmRyb3B1cHtwb3NpdGlvbjpyZWxhdGl2ZX0uZHJvcGRvd24tdG9nZ2xlOmZvY3Vze291dGxpbmU6MH0uZHJvcGRvd24tbWVudXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTAwJTtsZWZ0OjA7ei1pbmRleDoxMDAwO2Rpc3BsYXk6bm9uZTtmbG9hdDpsZWZ0O21pbi13aWR0aDoxNjBweDtwYWRkaW5nOjVweCAwO21hcmdpbjoycHggMCAwO2xpc3Qtc3R5bGU6bm9uZTtmb250LXNpemU6MTRweDt0ZXh0LWFsaWduOmxlZnQ7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI2NjYztib3JkZXI6MXB4IHNvbGlkIHJnYmEoMCwwLDAsLjE1KTtib3JkZXItcmFkaXVzOjRweDstd2Via2l0LWJveC1zaGFkb3c6MCA2cHggMTJweCByZ2JhKDAsMCwwLC4xNzUpO2JveC1zaGFkb3c6MCA2cHggMTJweCByZ2JhKDAsMCwwLC4xNzUpOy13ZWJraXQtYmFja2dyb3VuZC1jbGlwOnBhZGRpbmctYm94O2JhY2tncm91bmQtY2xpcDpwYWRkaW5nLWJveH0uZHJvcGRvd24tbWVudS5wdWxsLXJpZ2h0e3JpZ2h0OjA7bGVmdDphdXRvfS5kcm9wZG93bi1tZW51IC5kaXZpZGVye2hlaWdodDoxcHg7bWFyZ2luOjlweCAwO292ZXJmbG93OmhpZGRlbjtiYWNrZ3JvdW5kLWNvbG9yOiNlNWU1ZTV9LmRyb3Bkb3duLW1lbnU+bGk+YXtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6M3B4IDIwcHg7Y2xlYXI6Ym90aDtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MS40Mjg1NzE0Mztjb2xvcjojMzMzO3doaXRlLXNwYWNlOm5vd3JhcH0uZHJvcGRvd24tbWVudT5saT5hOmZvY3VzLC5kcm9wZG93bi1tZW51PmxpPmE6aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7Y29sb3I6IzI2MjYyNjtiYWNrZ3JvdW5kLWNvbG9yOiNmNWY1ZjV9LmRyb3Bkb3duLW1lbnU+LmFjdGl2ZT5hLC5kcm9wZG93bi1tZW51Pi5hY3RpdmU+YTpmb2N1cywuZHJvcGRvd24tbWVudT4uYWN0aXZlPmE6aG92ZXJ7Y29sb3I6I2ZmZjt0ZXh0LWRlY29yYXRpb246bm9uZTtvdXRsaW5lOjA7YmFja2dyb3VuZC1jb2xvcjojMzM3YWI3fS5kcm9wZG93bi1tZW51Pi5kaXNhYmxlZD5hLC5kcm9wZG93bi1tZW51Pi5kaXNhYmxlZD5hOmZvY3VzLC5kcm9wZG93bi1tZW51Pi5kaXNhYmxlZD5hOmhvdmVye2NvbG9yOiM3Nzd9LmRyb3Bkb3duLW1lbnU+LmRpc2FibGVkPmE6Zm9jdXMsLmRyb3Bkb3duLW1lbnU+LmRpc2FibGVkPmE6aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtiYWNrZ3JvdW5kLWltYWdlOm5vbmU7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChlbmFibGVkID0gZmFsc2UpO2N1cnNvcjpub3QtYWxsb3dlZH0ub3Blbj4uZHJvcGRvd24tbWVudXtkaXNwbGF5OmJsb2NrfS5vcGVuPmF7b3V0bGluZTowfS5kcm9wZG93bi1tZW51LXJpZ2h0e2xlZnQ6YXV0bztyaWdodDowfS5kcm9wZG93bi1tZW51LWxlZnR7bGVmdDowO3JpZ2h0OmF1dG99LmRyb3Bkb3duLWhlYWRlcntkaXNwbGF5OmJsb2NrO3BhZGRpbmc6M3B4IDIwcHg7Zm9udC1zaXplOjEycHg7bGluZS1oZWlnaHQ6MS40Mjg1NzE0Mztjb2xvcjojNzc3O3doaXRlLXNwYWNlOm5vd3JhcH0uZHJvcGRvd24tYmFja2Ryb3B7cG9zaXRpb246Zml4ZWQ7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7dG9wOjA7ei1pbmRleDo5OTB9LnB1bGwtcmlnaHQ+LmRyb3Bkb3duLW1lbnV7cmlnaHQ6MDtsZWZ0OmF1dG99LmRyb3B1cCAuY2FyZXQsLm5hdmJhci1maXhlZC1ib3R0b20gLmRyb3Bkb3duIC5jYXJldHtib3JkZXItdG9wOjA7Ym9yZGVyLWJvdHRvbTo0cHggZGFzaGVkO2JvcmRlci1ib3R0b206NHB4IHNvbGlkXFxcXDk7Y29udGVudDpcXFwiXFxcIn0uZHJvcHVwIC5kcm9wZG93bi1tZW51LC5uYXZiYXItZml4ZWQtYm90dG9tIC5kcm9wZG93biAuZHJvcGRvd24tbWVudXt0b3A6YXV0bztib3R0b206MTAwJTttYXJnaW4tYm90dG9tOjJweH1AbWVkaWEgKG1pbi13aWR0aDo3NjhweCl7Lm5hdmJhci1yaWdodCAuZHJvcGRvd24tbWVudXtsZWZ0OmF1dG87cmlnaHQ6MH0ubmF2YmFyLXJpZ2h0IC5kcm9wZG93bi1tZW51LWxlZnR7bGVmdDowO3JpZ2h0OmF1dG99fS5idG4tZ3JvdXAsLmJ0bi1ncm91cC12ZXJ0aWNhbHtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuLC5idG4tZ3JvdXA+LmJ0bntwb3NpdGlvbjpyZWxhdGl2ZTtmbG9hdDpsZWZ0fS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi5hY3RpdmUsLmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuOmFjdGl2ZSwuYnRuLWdyb3VwLXZlcnRpY2FsPi5idG46Zm9jdXMsLmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuOmhvdmVyLC5idG4tZ3JvdXA+LmJ0bi5hY3RpdmUsLmJ0bi1ncm91cD4uYnRuOmFjdGl2ZSwuYnRuLWdyb3VwPi5idG46Zm9jdXMsLmJ0bi1ncm91cD4uYnRuOmhvdmVye3otaW5kZXg6Mn0uYnRuLWdyb3VwIC5idG4rLmJ0biwuYnRuLWdyb3VwIC5idG4rLmJ0bi1ncm91cCwuYnRuLWdyb3VwIC5idG4tZ3JvdXArLmJ0biwuYnRuLWdyb3VwIC5idG4tZ3JvdXArLmJ0bi1ncm91cHttYXJnaW4tbGVmdDotMXB4fS5idG4tdG9vbGJhcnttYXJnaW4tbGVmdDotNXB4fS5idG4tdG9vbGJhciAuYnRuLC5idG4tdG9vbGJhciAuYnRuLWdyb3VwLC5idG4tdG9vbGJhciAuaW5wdXQtZ3JvdXB7ZmxvYXQ6bGVmdH0uYnRuLXRvb2xiYXI+LmJ0biwuYnRuLXRvb2xiYXI+LmJ0bi1ncm91cCwuYnRuLXRvb2xiYXI+LmlucHV0LWdyb3Vwe21hcmdpbi1sZWZ0OjVweH0uYnRuLWdyb3VwPi5idG46bm90KDpmaXJzdC1jaGlsZCk6bm90KDpsYXN0LWNoaWxkKTpub3QoLmRyb3Bkb3duLXRvZ2dsZSl7Ym9yZGVyLXJhZGl1czowfS5idG4tZ3JvdXA+LmJ0bjpmaXJzdC1jaGlsZHttYXJnaW4tbGVmdDowfS5idG4tZ3JvdXA+LmJ0bjpmaXJzdC1jaGlsZDpub3QoOmxhc3QtY2hpbGQpOm5vdCguZHJvcGRvd24tdG9nZ2xlKXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjB9LmJ0bi1ncm91cD4uYnRuOmxhc3QtY2hpbGQ6bm90KDpmaXJzdC1jaGlsZCksLmJ0bi1ncm91cD4uZHJvcGRvd24tdG9nZ2xlOm5vdCg6Zmlyc3QtY2hpbGQpe2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjB9LmJ0bi1ncm91cD4uYnRuLWdyb3Vwe2Zsb2F0OmxlZnR9LmJ0bi1ncm91cD4uYnRuLWdyb3VwOm5vdCg6Zmlyc3QtY2hpbGQpOm5vdCg6bGFzdC1jaGlsZCk+LmJ0bntib3JkZXItcmFkaXVzOjB9LmJ0bi1ncm91cD4uYnRuLWdyb3VwOmZpcnN0LWNoaWxkOm5vdCg6bGFzdC1jaGlsZCk+LmJ0bjpsYXN0LWNoaWxkLC5idG4tZ3JvdXA+LmJ0bi1ncm91cDpmaXJzdC1jaGlsZDpub3QoOmxhc3QtY2hpbGQpPi5kcm9wZG93bi10b2dnbGV7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowfS5idG4tZ3JvdXA+LmJ0bi1ncm91cDpsYXN0LWNoaWxkOm5vdCg6Zmlyc3QtY2hpbGQpPi5idG46Zmlyc3QtY2hpbGR7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MH0uYnRuLWdyb3VwIC5kcm9wZG93bi10b2dnbGU6YWN0aXZlLC5idG4tZ3JvdXAub3BlbiAuZHJvcGRvd24tdG9nZ2xle291dGxpbmU6MH0uYnRuLWdyb3VwPi5idG4rLmRyb3Bkb3duLXRvZ2dsZXtwYWRkaW5nLWxlZnQ6OHB4O3BhZGRpbmctcmlnaHQ6OHB4fS5idG4tZ3JvdXA+LmJ0bi1sZysuZHJvcGRvd24tdG9nZ2xle3BhZGRpbmctbGVmdDoxMnB4O3BhZGRpbmctcmlnaHQ6MTJweH0uYnRuLWdyb3VwLm9wZW4gLmRyb3Bkb3duLXRvZ2dsZXstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAzcHggNXB4IHJnYmEoMCwwLDAsLjEyNSk7Ym94LXNoYWRvdzppbnNldCAwIDNweCA1cHggcmdiYSgwLDAsMCwuMTI1KX0uYnRuLWdyb3VwLm9wZW4gLmRyb3Bkb3duLXRvZ2dsZS5idG4tbGlua3std2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9LmJ0biAuY2FyZXR7bWFyZ2luLWxlZnQ6MH0uYnRuLWxnIC5jYXJldHtib3JkZXItd2lkdGg6NXB4IDVweCAwO2JvcmRlci1ib3R0b20td2lkdGg6MH0uZHJvcHVwIC5idG4tbGcgLmNhcmV0e2JvcmRlci13aWR0aDowIDVweCA1cHh9LmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cCwuYnRuLWdyb3VwLXZlcnRpY2FsPi5idG4tZ3JvdXA+LmJ0bntkaXNwbGF5OmJsb2NrO2Zsb2F0Om5vbmU7d2lkdGg6MTAwJTttYXgtd2lkdGg6MTAwJX0uYnRuLWdyb3VwLXZlcnRpY2FsPi5idG4tZ3JvdXA+LmJ0bntmbG9hdDpub25lfS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bisuYnRuLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bisuYnRuLWdyb3VwLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cCsuYnRuLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cCsuYnRuLWdyb3Vwe21hcmdpbi10b3A6LTFweDttYXJnaW4tbGVmdDowfS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bjpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1yYWRpdXM6MH0uYnRuLWdyb3VwLXZlcnRpY2FsPi5idG46Zmlyc3QtY2hpbGQ6bm90KDpsYXN0LWNoaWxkKXtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czo0cHg7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czo0cHg7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjB9LmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuOmxhc3QtY2hpbGQ6bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6NHB4O2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6NHB4fS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cDpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpPi5idG57Ym9yZGVyLXJhZGl1czowfS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cDpmaXJzdC1jaGlsZDpub3QoOmxhc3QtY2hpbGQpPi5idG46bGFzdC1jaGlsZCwuYnRuLWdyb3VwLXZlcnRpY2FsPi5idG4tZ3JvdXA6Zmlyc3QtY2hpbGQ6bm90KDpsYXN0LWNoaWxkKT4uZHJvcGRvd24tdG9nZ2xle2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowfS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cDpsYXN0LWNoaWxkOm5vdCg6Zmlyc3QtY2hpbGQpPi5idG46Zmlyc3QtY2hpbGR7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjB9LmJ0bi1ncm91cC1qdXN0aWZpZWR7ZGlzcGxheTp0YWJsZTt3aWR0aDoxMDAlO3RhYmxlLWxheW91dDpmaXhlZDtib3JkZXItY29sbGFwc2U6c2VwYXJhdGV9LmJ0bi1ncm91cC1qdXN0aWZpZWQ+LmJ0biwuYnRuLWdyb3VwLWp1c3RpZmllZD4uYnRuLWdyb3Vwe2Zsb2F0Om5vbmU7ZGlzcGxheTp0YWJsZS1jZWxsO3dpZHRoOjElfS5idG4tZ3JvdXAtanVzdGlmaWVkPi5idG4tZ3JvdXAgLmJ0bnt3aWR0aDoxMDAlfS5idG4tZ3JvdXAtanVzdGlmaWVkPi5idG4tZ3JvdXAgLmRyb3Bkb3duLW1lbnV7bGVmdDphdXRvfVtkYXRhLXRvZ2dsZT1idXR0b25zXT4uYnRuLWdyb3VwPi5idG4gaW5wdXRbdHlwZT1jaGVja2JveF0sW2RhdGEtdG9nZ2xlPWJ1dHRvbnNdPi5idG4tZ3JvdXA+LmJ0biBpbnB1dFt0eXBlPXJhZGlvXSxbZGF0YS10b2dnbGU9YnV0dG9uc10+LmJ0biBpbnB1dFt0eXBlPWNoZWNrYm94XSxbZGF0YS10b2dnbGU9YnV0dG9uc10+LmJ0biBpbnB1dFt0eXBlPXJhZGlvXXtwb3NpdGlvbjphYnNvbHV0ZTtjbGlwOnJlY3QoMCwwLDAsMCk7cG9pbnRlci1ldmVudHM6bm9uZX0udG9vbHRpcHtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjEwNzA7ZGlzcGxheTpibG9jaztmb250LWZhbWlseTpIZWx2ZXRpY2EgTmV1ZSxIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZjtmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDo0MDA7bGV0dGVyLXNwYWNpbmc6bm9ybWFsO2xpbmUtYnJlYWs6YXV0bztsaW5lLWhlaWdodDoxLjQyODU3MTQzO3RleHQtYWxpZ246bGVmdDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO3RleHQtc2hhZG93Om5vbmU7dGV4dC10cmFuc2Zvcm06bm9uZTt3aGl0ZS1zcGFjZTpub3JtYWw7d29yZC1icmVhazpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt3b3JkLXdyYXA6bm9ybWFsO2ZvbnQtc2l6ZToxMnB4O29wYWNpdHk6MDtmaWx0ZXI6YWxwaGEob3BhY2l0eT0wKX0udG9vbHRpcC5pbntvcGFjaXR5Oi45O2ZpbHRlcjphbHBoYShvcGFjaXR5PTkwKX0udG9vbHRpcC50b3B7bWFyZ2luLXRvcDotM3B4O3BhZGRpbmc6NXB4IDB9LnRvb2x0aXAucmlnaHR7bWFyZ2luLWxlZnQ6M3B4O3BhZGRpbmc6MCA1cHh9LnRvb2x0aXAuYm90dG9te21hcmdpbi10b3A6M3B4O3BhZGRpbmc6NXB4IDB9LnRvb2x0aXAubGVmdHttYXJnaW4tbGVmdDotM3B4O3BhZGRpbmc6MCA1cHh9LnRvb2x0aXAtaW5uZXJ7bWF4LXdpZHRoOjIwMHB4O3BhZGRpbmc6M3B4IDhweDtjb2xvcjojZmZmO3RleHQtYWxpZ246Y2VudGVyO2JhY2tncm91bmQtY29sb3I6IzAwMDtib3JkZXItcmFkaXVzOjRweH0udG9vbHRpcC1hcnJvd3twb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDowO2hlaWdodDowO2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItc3R5bGU6c29saWR9LnRvb2x0aXAudG9wIC50b29sdGlwLWFycm93e2JvdHRvbTowO2xlZnQ6NTAlO21hcmdpbi1sZWZ0Oi01cHg7Ym9yZGVyLXdpZHRoOjVweCA1cHggMDtib3JkZXItdG9wLWNvbG9yOiMwMDB9LnRvb2x0aXAudG9wLWxlZnQgLnRvb2x0aXAtYXJyb3d7cmlnaHQ6NXB4fS50b29sdGlwLnRvcC1sZWZ0IC50b29sdGlwLWFycm93LC50b29sdGlwLnRvcC1yaWdodCAudG9vbHRpcC1hcnJvd3tib3R0b206MDttYXJnaW4tYm90dG9tOi01cHg7Ym9yZGVyLXdpZHRoOjVweCA1cHggMDtib3JkZXItdG9wLWNvbG9yOiMwMDB9LnRvb2x0aXAudG9wLXJpZ2h0IC50b29sdGlwLWFycm93e2xlZnQ6NXB4fS50b29sdGlwLnJpZ2h0IC50b29sdGlwLWFycm93e3RvcDo1MCU7bGVmdDowO21hcmdpbi10b3A6LTVweDtib3JkZXItd2lkdGg6NXB4IDVweCA1cHggMDtib3JkZXItcmlnaHQtY29sb3I6IzAwMH0udG9vbHRpcC5sZWZ0IC50b29sdGlwLWFycm93e3RvcDo1MCU7cmlnaHQ6MDttYXJnaW4tdG9wOi01cHg7Ym9yZGVyLXdpZHRoOjVweCAwIDVweCA1cHg7Ym9yZGVyLWxlZnQtY29sb3I6IzAwMH0udG9vbHRpcC5ib3R0b20gLnRvb2x0aXAtYXJyb3d7dG9wOjA7bGVmdDo1MCU7bWFyZ2luLWxlZnQ6LTVweDtib3JkZXItd2lkdGg6MCA1cHggNXB4O2JvcmRlci1ib3R0b20tY29sb3I6IzAwMH0udG9vbHRpcC5ib3R0b20tbGVmdCAudG9vbHRpcC1hcnJvd3t0b3A6MDtyaWdodDo1cHg7bWFyZ2luLXRvcDotNXB4O2JvcmRlci13aWR0aDowIDVweCA1cHg7Ym9yZGVyLWJvdHRvbS1jb2xvcjojMDAwfS50b29sdGlwLmJvdHRvbS1yaWdodCAudG9vbHRpcC1hcnJvd3t0b3A6MDtsZWZ0OjVweDttYXJnaW4tdG9wOi01cHg7Ym9yZGVyLXdpZHRoOjAgNXB4IDVweDtib3JkZXItYm90dG9tLWNvbG9yOiMwMDB9LmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuLWdyb3VwOmFmdGVyLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cDpiZWZvcmUsLmJ0bi10b29sYmFyOmFmdGVyLC5idG4tdG9vbGJhcjpiZWZvcmUsLmNsZWFyZml4OmFmdGVyLC5jbGVhcmZpeDpiZWZvcmV7Y29udGVudDpcXFwiIFxcXCI7ZGlzcGxheTp0YWJsZX0uYnRuLWdyb3VwLXZlcnRpY2FsPi5idG4tZ3JvdXA6YWZ0ZXIsLmJ0bi10b29sYmFyOmFmdGVyLC5jbGVhcmZpeDphZnRlcntjbGVhcjpib3RofS5jZW50ZXItYmxvY2t7ZGlzcGxheTpibG9jazttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvfS5wdWxsLXJpZ2h0e2Zsb2F0OnJpZ2h0IWltcG9ydGFudH0ucHVsbC1sZWZ0e2Zsb2F0OmxlZnQhaW1wb3J0YW50fS5oaWRle2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9LnNob3d7ZGlzcGxheTpibG9jayFpbXBvcnRhbnR9LmludmlzaWJsZXt2aXNpYmlsaXR5OmhpZGRlbn0udGV4dC1oaWRle2ZvbnQ6MC8wIGE7Y29sb3I6dHJhbnNwYXJlbnQ7dGV4dC1zaGFkb3c6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlcjowfS5oaWRkZW57ZGlzcGxheTpub25lIWltcG9ydGFudH0uYWZmaXh7cG9zaXRpb246Zml4ZWR9XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC5taW4uY3NzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "clear.png?f470863024f982806a178d720710f024";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvaW1nL2NsZWFyLnBuZz80ODNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiY2xlYXIucG5nP2Y0NzA4NjMwMjRmOTgyODA2YTE3OGQ3MjA3MTBmMDI0XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZWRpdGFibGUvaW1nL2NsZWFyLnBuZ1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "loading.gif?7b9776076d5fceef4993b55c9383dedd";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvaW1nL2xvYWRpbmcuZ2lmPzdiODgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJsb2FkaW5nLmdpZj83Yjk3NzYwNzZkNWZjZWVmNDk5M2I1NWM5MzgzZGVkZFwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2VkaXRhYmxlL2ltZy9sb2FkaW5nLmdpZlxuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n')},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.2.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2017-03-20T18:59Z\n */\n( function( global, factory ) {\n\n\t"use strict";\n\n\tif ( typeof module === "object" && typeof module.exports === "object" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require("jquery")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( "jQuery requires a window with a document" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n"use strict";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\n\n\n\tfunction DOMEval( code, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar script = doc.createElement( "script" );\n\n\t\tscript.text = code;\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = "3.2.1",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor \'enhanced\'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array\'s method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === "boolean" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== "object" && !jQuery.isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we\'re merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && Array.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don\'t bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: "jQuery" + ( version + Math.random() ).replace( /\\D/g, "" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type( obj ) === "function";\n\t},\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\n\t\t// As of jQuery 3.0, isNumeric is limited to\n\t\t// strings and numbers (primitives or objects)\n\t\t// that can be coerced to finite numbers (gh-2662)\n\t\tvar type = jQuery.type( obj );\n\t\treturn ( type === "number" || type === "string" ) &&\n\n\t\t\t// parseFloat NaNs numeric-cast false positives ("")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals ("0x...")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t!isNaN( obj - parseFloat( obj ) );\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== "[object Object]" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, "constructor" ) && proto.constructor;\n\t\treturn typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + "";\n\t\t}\n\n\t\t// Support: Android <=2.3 only (functionish RegExp)\n\t\treturn typeof obj === "object" || typeof obj === "function" ?\n\t\t\tclass2type[ toString.call( obj ) ] || "object" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE <=9 - 11, Edge 12 - 13\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t"" :\n\t\t\t( text + "" ).replace( rtrim, "" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === "string" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === "string" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === "function" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),\nfunction( i, name ) {\n\tclass2type[ "[object " + name + "]" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn\'t used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && "length" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === "function" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === "array" || length === 0 ||\n\t\ttypeof length === "number" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = "sizzle" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it\'s faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = "(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = "\\\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +\n\t\t// Operator (capture 2)\n\t\t"*([*^$|!~]?=)" + whitespace +\n\t\t// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"\n\t\t"*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(" + identifier + "))|)" + whitespace +\n\t\t"*\\\\]",\n\n\tpseudos = ":(" + identifier + ")(?:\\\\((" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t"(\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|" +\n\t\t// 2. simple (capture 6)\n\t\t"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + attributes + ")*)|" +\n\t\t// 3. anything else (capture 2)\n\t\t".*" +\n\t\t")\\\\)|)",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + "+", "g" ),\n\trtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + whitespace + "+$", "g" ),\n\n\trcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),\n\trcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),\n\n\trattributeQuotes = new RegExp( "=" + whitespace + "*([^\\\\]\'\\"]*?)" + whitespace + "*\\\\]", "g" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( "^" + identifier + "$" ),\n\n\tmatchExpr = {\n\t\t"ID": new RegExp( "^#(" + identifier + ")" ),\n\t\t"CLASS": new RegExp( "^\\\\.(" + identifier + ")" ),\n\t\t"TAG": new RegExp( "^(" + identifier + "|[*])" ),\n\t\t"ATTR": new RegExp( "^" + attributes ),\n\t\t"PSEUDO": new RegExp( "^" + pseudos ),\n\t\t"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + whitespace +\n\t\t\t"*(even|odd|(([+-]|)(\\\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +\n\t\t\t"*(\\\\d+)|))" + whitespace + "*\\\\)|)", "i" ),\n\t\t"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" +\n\t\t\twhitespace + "*((?:-\\\\d)?\\\\d*)" + whitespace + "*\\\\)|)(?=[^-]|$)", "i" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( "\\\\\\\\([\\\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = "0x" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +"0x"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === "\\0" ) {\n\t\t\t\treturn "\\uFFFD";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + "\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn "\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a "Permission Denied"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && ("form" in elem || "label" in elem);\n\t\t},\n\t\t{ dir: "parentNode", next: "legend" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can\'t trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== "string" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a "get*By*" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don\'t exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + " " ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== "object" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( "id" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( "id", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = "#" + nid + " " + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( "," );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( "id" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, "$1" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + " " ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + " " ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement("fieldset");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split("|"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === "input" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === "input" || name === "button") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( "form" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a "form" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( "label" in elem ) {\n\t\t\t\t\tif ( "label" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can\'t be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn\'t\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( "label" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== "undefined" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn\'t yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== "HTML" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( "unload", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( "onunload", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = "i";\n\t\treturn !el.getAttribute("className");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName("*") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment("") );\n\t\treturn !el.getElementsByTagName("*").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don\'t pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter["ID"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute("id") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find["ID"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter["ID"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== "undefined" &&\n\t\t\t\t\telem.getAttributeNode("id");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find["ID"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode("id");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode("id");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find["TAG"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== "undefined" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don\'t have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === "*" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE\'s treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = "<a id=\'" + expando + "\'></a>" +\n\t\t\t\t"<select id=\'" + expando + "-\\r\\\\\' msallowcapture=\'\'>" +\n\t\t\t\t"<option selected=\'\'></option></select>";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but "safe" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll("[msallowcapture^=\'\']").length ) {\n\t\t\t\trbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\'\'|\\"\\")" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and "value" are not treated correctly\n\t\t\tif ( !el.querySelectorAll("[selected]").length ) {\n\t\t\t\trbuggyQSA.push( "\\\\[" + whitespace + "*(?:value|" + booleans + ")" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {\n\t\t\t\trbuggyQSA.push("~=");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(":checked").length ) {\n\t\t\t\trbuggyQSA.push(":checked");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {\n\t\t\t\trbuggyQSA.push(".#.+[+~]");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = "<a href=\'\' disabled=\'disabled\'></a>" +\n\t\t\t\t"<select disabled=\'disabled\'><option/></select>";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement("input");\n\t\t\tinput.setAttribute( "type", "hidden" );\n\t\t\tel.appendChild( input ).setAttribute( "name", "D" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll("[name=d]").length ) {\n\t\t\t\trbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(":enabled").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( ":enabled", ":disabled" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE\'s :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(":disabled").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( ":enabled", ":disabled" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll("*,:x");\n\t\t\trbuggyQSA.push(",.*:");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it\'s possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, "*" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, "[s!=\'\']:x" );\n\t\t\trbuggyMatches.push( "!=", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, "=\'$1\']" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + " " ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9\'s matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don\'t get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + "").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( "Syntax error, unrecognized expression: " + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = "",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === "string" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t">": { dir: "parentNode", first: true },\n\t\t" ": { dir: "parentNode" },\n\t\t"+": { dir: "previousSibling", first: true },\n\t\t"~": { dir: "previousSibling" }\n\t},\n\n\tpreFilter: {\n\t\t"ATTR": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === "~=" ) {\n\t\t\t\tmatch[3] = " " + match[3] + " ";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t"CHILD": function( match ) {\n\t\t\t/* matches from matchExpr["CHILD"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === "nth" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t"PSEUDO": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr["CHILD"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || "";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t"TAG": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === "*" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t"CLASS": function( className ) {\n\t\t\tvar pattern = classCache[ className + " " ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );\n\t\t\t\t});\n\t\t},\n\n\t\t"ATTR": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === "!=";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += "";\n\n\t\t\t\treturn operator === "=" ? result === check :\n\t\t\t\t\toperator === "!=" ? result !== check :\n\t\t\t\t\toperator === "^=" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === "*=" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === "$=" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t"CHILD": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== "nth",\n\t\t\t\tforward = type.slice( -4 ) !== "last",\n\t\t\t\tofType = what === "of-type";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? "nextSibling" : "previousSibling",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven\'t yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === "only" && !start && "nextSibling";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t"PSEUDO": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( "unsupported pseudo: " + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, "", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t"not": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, "$1" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don\'t keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t"has": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t"contains": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// "Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element\'s language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by "-".\n\t\t// The matching of C against the element\'s language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name."\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t"lang": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || "") ) {\n\t\t\t\tSizzle.error( "unsupported lang: " + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t"target": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t"root": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t"focus": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t"enabled": createDisabledPseudo( false ),\n\t\t"disabled": createDisabledPseudo( true ),\n\n\t\t"checked": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);\n\t\t},\n\n\t\t"selected": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t"empty": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t"parent": function( elem ) {\n\t\t\treturn !Expr.pseudos["empty"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t"header": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t"input": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t"button": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === "input" && elem.type === "button" || name === "button";\n\t\t},\n\n\t\t"text": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === "input" &&\n\t\t\t\telem.type === "text" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"\n\t\t\t\t( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t"first": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t"last": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t"even": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"odd": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos["nth"] = Expr.pseudos["eq"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + " " ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don\'t consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, " " )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we\'re just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = "";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === "parentNode",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can\'t set arbitrary data on XML nodes, so they don\'t benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we\'re done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[" "],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })\n\t\t\t\t\t).replace( rtrim, "$1" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = "0",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find["TAG"]( "*", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn\'t visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a "00" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + " " ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle\'s compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === "function" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split("").sort( sortOrder ).join("") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren\'t passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement("fieldset") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property "interpolation"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = "<a href=\'#\'></a>";\n\treturn el.firstChild.getAttribute("href") === "#" ;\n}) ) {\n\taddHandle( "type|href|height|width", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute("value")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = "<input/>";\n\tel.firstChild.setAttribute( "value", "" );\n\treturn el.firstChild.getAttribute( "value" ) === "";\n}) ) {\n\taddHandle( "value", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === "input" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute("disabled") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ ":" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== "string" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Simple selector that can be filtered directly, removing non-Elements\n\tif ( risSimple.test( qualifier ) ) {\n\t\treturn jQuery.filter( qualifier, elements, not );\n\t}\n\n\t// Complex selector, compare the two sets, removing non-Elements\n\tqualifier = jQuery.filter( qualifier, elements );\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;\n\t} );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = ":not(" + expr + ")";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== "string" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $("p:first").is("p:last") won\'t return true for a doc with two "p".\n\t\t\ttypeof selector === "string" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(""), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === "string" ) {\n\t\t\tif ( selector[ 0 ] === "<" &&\n\t\t\t\tselector[ selector.length - 1 ] === ">" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== "string" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there\'s no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don\'t pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === "string" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, "parentNode" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "parentNode", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, "nextSibling" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, "previousSibling" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, "nextSibling" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, "previousSibling" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "nextSibling", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "previousSibling", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n        if ( nodeName( elem, "iframe" ) ) {\n            return elem.contentDocument;\n        }\n\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n        // Treat the template element as a regular one in browsers that\n        // don\'t support it.\n        if ( nodeName( elem, "template" ) ) {\n            elem = elem.content || elem;\n        }\n\n        return jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== "Until" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === "string" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * "fired" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest "memorized"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === "string" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn\'t re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we\'re done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we\'re done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = "";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = "";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = "";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && jQuery.isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn\'t unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ "notify", "progress", jQuery.Callbacks( "memory" ),\n\t\t\t\t\tjQuery.Callbacks( "memory" ), 2 ],\n\t\t\t\t[ "resolve", "done", jQuery.Callbacks( "once memory" ),\n\t\t\t\t\tjQuery.Callbacks( "once memory" ), 0, "resolved" ],\n\t\t\t\t[ "reject", "fail", jQuery.Callbacks( "once memory" ),\n\t\t\t\t\tjQuery.Callbacks( "once memory" ), 1, "rejected" ]\n\t\t\t],\n\t\t\tstate = "pending",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t"catch": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + "With" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( "Thenable self-resolution" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === "object" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === "function" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( jQuery.isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it\'s otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tjQuery.isFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = "resolved" (i.e., fulfilled)\n\t\t\t\t\t\t// state = "rejected"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + "With" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === "pending" ||\n\t\t\t\tjQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we\'re already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( "DOMContentLoaded", completed );\n\twindow.removeEventListener( "load", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals "interactive" too soon\nif ( document.readyState === "complete" ||\n\t( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( "DOMContentLoaded", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( "load", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it\'s a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === "object" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === "string" ) {\n\t\t\tcache[ jQuery.camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ jQuery.camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the "read" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === "string" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the "set" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( jQuery.camelCase );\n\t\t\t} else {\n\t\t\t\tkey = jQuery.camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there\'s no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module\'s maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support "private" and "user" data.\n//\t4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === "true" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === "false" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === "null" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn\'t change the string\n\tif ( data === +data + "" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === "string" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn\'t changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( "data-" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, "hasDataAttrs", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === "object" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to "discover" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn\'t exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || "fx" ) + "queue";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || "fx";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === "inprogress" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === "fx" ) {\n\t\t\t\tqueue.unshift( "inprogress" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + "queueHooks";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( "once memory" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + "queue", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tdata = type;\n\t\t\ttype = "fx";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === "fx" && queue[ 0 ] !== "inprogress" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || "fx", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || "fx";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + "queueHooks" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );\n\n\nvar cssExpand = [ "Top", "Right", "Bottom", "Left" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === "none" ||\n\t\t\telem.style.display === "" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, "display" ) === "none";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted,\n\t\tscale = 1,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, "" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\tdo {\n\n\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t// Use string for doubling so we don\'t accidentally see scale as unchanged below\n\t\t\tscale = scale || ".5";\n\n\t\t\t// Adjust and apply\n\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t// Break the loop if scale is unchanged or perfect, or if we\'ve just had enough.\n\t\t} while (\n\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t);\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, "display" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === "none" ) {\n\t\tdisplay = "block";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === "none" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, "display" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = "";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== "none" ) {\n\t\t\t\tvalues[ index ] = "none";\n\n\t\t\t\t// Remember what we\'re overwriting\n\t\t\t\tdataPriv.set( elem, "display", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === "boolean" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, "<select multiple=\'multiple\'>", "</select>" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, "<table>", "</table>" ],\n\tcol: [ 2, "<table><colgroup>", "</colgroup></table>" ],\n\ttr: [ 2, "<table><tbody>", "</tbody></table>" ],\n\ttd: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],\n\n\t_default: [ 0, "", "" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== "undefined" ) {\n\t\tret = context.getElementsByTagName( tag || "*" );\n\n\t} else if ( typeof context.querySelectorAll !== "undefined" ) {\n\t\tret = context.querySelectorAll( tag || "*" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t"globalEval",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], "globalEval" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( jQuery.type( elem ) === "object" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( "div" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = "";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = "";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), "script" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || "" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( "div" ) ),\n\t\tinput = document.createElement( "input" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( "type", "radio" );\n\tinput.setAttribute( "checked", "checked" );\n\tinput.setAttribute( "name", "t" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn\'t clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = "<textarea>x</textarea>";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === "object" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== "string" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === "string" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards\' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don\'t attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element\'s event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || "" ).match( rnothtmlwhite ) || [ "" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( "." )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we\'re the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element\'s handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || "" ).match( rnothtmlwhite ) || [ "" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === "**" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it\'s no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, "handle events" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === "click" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don\'t check non-elements (#13208)\n\t\t\t\t// Don\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don\'t conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + " ";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: jQuery.isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: "focusin"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: "focusout"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don\'t fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn nodeName( event.target, "a" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn\'t alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This "if" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the \'new\' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn\'t have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t"char": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: "mouseover",\n\tmouseleave: "mouseout",\n\tpointerenter: "pointerover",\n\tpointerleave: "pointerout"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + "." + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === "object" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === "function" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked="checked" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, "table" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {\n\n\t\treturn jQuery( ">tbody", elem )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute( "type" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === "input" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === "input" || nodeName === "textarea" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tisFunction = jQuery.isFunction( value );\n\n\t// We can\'t cloneNode fragments that contain checked, in WebKit\n\tif ( isFunction ||\n\t\t\t( l > 1 && typeof value === "string" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( isFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, "script" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, "script" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || "" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, "globalEval" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won\'t run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, "" ), doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, "script" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, "<$1></$2>" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, "script" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, "script" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove\'s overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = "";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === "string" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: "append",\n\tprependTo: "prepend",\n\tinsertBefore: "before",\n\tinsertAfter: "after",\n\treplaceAll: "replaceWith"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rmargin = ( /^margin/ );\n\nvar rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they\'re executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdiv.style.cssText =\n\t\t\t"box-sizing:border-box;" +\n\t\t\t"position:relative;display:block;" +\n\t\t\t"margin:auto;border:1px;padding:1px;" +\n\t\t\t"top:1%;width:50%";\n\t\tdiv.innerHTML = "";\n\t\tdocumentElement.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== "1%";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = divStyle.marginLeft === "2px";\n\t\tboxSizingReliableVal = divStyle.width === "4px";\n\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Some styles come back with percentage values, even though they shouldn\'t\n\t\tdiv.style.marginRight = "50%";\n\t\tpixelMarginRightVal = divStyle.marginRight === "4px";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn\'t be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( "div" ),\n\t\tdiv = document.createElement( "div" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = "content-box";\n\tdiv.cloneNode( true ).style.backgroundClip = "";\n\tsupport.clearCloneStyle = div.style.backgroundClip === "content-box";\n\n\tcontainer.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +\n\t\t"padding:0;margin-top:1px;position:absolute";\n\tcontainer.appendChild( div );\n\n\tjQuery.extend( support, {\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelMarginRight: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelMarginRightVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css(\'filter\') (IE 9 only, #12537)\n\t//   .css(\'--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the "awesome hack by Dean Edwards"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + "" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we\'ll check on the first run if it\'s really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it\'s not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except "table", "table-cell", or "table-caption"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: "absolute", visibility: "hidden", display: "block" },\n\tcssNormalTransform = {\n\t\tletterSpacing: "0",\n\t\tfontWeight: "400"\n\t},\n\n\tcssPrefixes = [ "Webkit", "Moz", "ms" ],\n\temptyStyle = document.createElement( "div" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a property mapped along what jQuery.cssProps suggests or to\n// a vendor prefixed property.\nfunction finalPropName( name ) {\n\tvar ret = jQuery.cssProps[ name ];\n\tif ( !ret ) {\n\t\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\n\t}\n\treturn ret;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined "subtract", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i,\n\t\tval = 0;\n\n\t// If we already have the right measurement, avoid augmentation\n\tif ( extra === ( isBorderBox ? "border" : "content" ) ) {\n\t\ti = 4;\n\n\t// Otherwise initialize for horizontal or vertical properties\n\t} else {\n\t\ti = name === "width" ? 1 : 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === "margin" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === "content" ) {\n\t\t\t\tval -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn\'t border nor margin, so remove border\n\t\t\tif ( extra !== "margin" ) {\n\t\t\t\tval -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// At this point, extra isn\'t content, so add padding\n\t\t\tval += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn\'t content nor padding, so add border\n\t\t\tif ( extra !== "padding" ) {\n\t\t\t\tval += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with computed style\n\tvar valueIsBorderBox,\n\t\tstyles = getStyles( elem ),\n\t\tval = curCSS( elem, name, styles ),\n\t\tisBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";\n\n\t// Computed unit is not pixels. Stop here and return.\n\tif ( rnumnonpx.test( val ) ) {\n\t\treturn val;\n\t}\n\n\t// Check for style in case a browser which returns unreliable values\n\t// for getComputedStyle silently falls back to the reliable elem.style\n\tvalueIsBorderBox = isBorderBox &&\n\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t// Fall back to offsetWidth/Height when value is "auto"\n\t// This happens for inline elements with no explicit setting (gh-3571)\n\tif ( val === "auto" ) {\n\t\tval = elem[ "offset" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];\n\t}\n\n\t// Normalize "", auto, and prepare for extra\n\tval = parseFloat( val ) || 0;\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? "border" : "content" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + "px";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, "opacity" );\n\t\t\t\t\treturn ret === "" ? "1" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don\'t automatically add "px" to these possibly-unitless properties\n\tcssNumber: {\n\t\t"animationIterationCount": true,\n\t\t"columnCount": true,\n\t\t"fillOpacity": true,\n\t\t"flexGrow": true,\n\t\t"flexShrink": true,\n\t\t"fontWeight": true,\n\t\t"lineHeight": true,\n\t\t"opacity": true,\n\t\t"order": true,\n\t\t"orphans": true,\n\t\t"widows": true,\n\t\t"zIndex": true,\n\t\t"zoom": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t"float": "cssFloat"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don\'t set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we\'re working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we\'re working with the right name. We don\'t\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we\'re setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert "+=" or "-=" to relative numbers (#7345)\n\t\t\tif ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = "number";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren\'t set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === "number" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone\'s values\n\t\t\tif ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {\n\t\t\t\tstyle[ name ] = "inherit";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( "set" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && "get" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we\'re working with the right name. We don\'t\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && "get" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert "normal" to computed value\n\t\tif ( val === "normal" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === "" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ "height", "width" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, "display" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, "boxSizing", false, styles ) === "border-box",\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || "px" ) !== "px" ) {\n\n\t\t\t\telem.style[ name ] = value;\n\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, "marginLeft" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + "px";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: "",\n\tpadding: "",\n\tborder: "Width"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === "string" ? value.split( " " ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as "10px" are parsed to Float;\n\t\t\t// complex values such as "rotate(1rad)" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, "" );\n\n\t\t\t// Empty strings, null, undefined and "auto" are converted to 0.\n\t\t\treturn !result || result === "auto" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: "swing"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ "margin" + which ] = attrs[ "padding" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We\'re done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = "width" in props || "height" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, "fxshow" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, "fx" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, "fx" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === "toggle";\n\t\t\tif ( value === ( hidden ? "hide" : "show" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a "show" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict "overflow" and "display" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 13\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, "display" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, "display" );\n\t\tif ( display === "none" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, "display" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, "float" ) === "none" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === "none" ? "" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = "inline-block";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = "hidden";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( "hidden" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` "reverses"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a "hide" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, "fxshow" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && "expand" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won\'t overwrite existing keys.\n\t\t\t// Reusing \'index\' because we have the correct "name"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don\'t match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won\'t allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there\'s more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t"*": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ "*" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== "number" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> "fx"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = "fx";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won\'t be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, "finish" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || "fx", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + "queueHooks",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn\'t forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || "fx";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + "queue" ],\n\t\t\t\thooks = data[ type + "queueHooks" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === "boolean" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( "show" ),\n\tslideUp: genFx( "hide" ),\n\tslideToggle: genFx( "toggle" ),\n\tfadeIn: { opacity: "show" },\n\tfadeOut: { opacity: "hide" },\n\tfadeToggle: { opacity: "toggle" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || "fx";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( "input" ),\n\t\tselect = document.createElement( "select" ),\n\t\topt = select.appendChild( document.createElement( "option" ) );\n\n\tinput.type = "checkbox";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be "on"\n\tsupport.checkOn = input.value !== "";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( "input" );\n\tinput.value = "t";\n\tinput.type = "radio";\n\tsupport.radioValue = input.value === "t";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don\'t get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === "undefined" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && "set" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + "" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === "radio" &&\n\t\t\t\t\tnodeName( elem, "input" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( "type", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don\'t get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && "set" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn\'t always return the\n\t\t\t\t// correct value when it hasn\'t been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, "tabindex" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t"for": "htmlFor",\n\t\t"class": "className"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule "no-unused-expressions" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: "off" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: "off" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t"tabIndex",\n\t"readOnly",\n\t"maxLength",\n\t"cellSpacing",\n\t"cellPadding",\n\t"rowSpan",\n\t"colSpan",\n\t"useMap",\n\t"frameBorder",\n\t"contentEditable"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( " " );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( "class" ) || "";\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( typeof value === "string" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( " " + clazz + " " ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + " ";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( "class", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( "class", "" );\n\t\t}\n\n\t\tif ( typeof value === "string" && value ) {\n\t\t\tclasses = value.match( rnothtmlwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( " " + clazz + " " ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( " " + clazz + " ", " " );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( "class", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === "boolean" && type === "string" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( type === "string" ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = value.match( rnothtmlwhite ) || [];\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === "boolean" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, "__className__", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we\'re passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( "class",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t"" :\n\t\t\t\t\t\tdataPriv.get( this, "__className__" ) || ""\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = " " + selector + " ";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t"get" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, "value" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === "string" ) {\n\t\t\t\t\treturn ret.replace( rreturn, "" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? "" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as ""; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = "";\n\n\t\t\t} else if ( typeof val === "number" ) {\n\t\t\t\tval += "";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? "" : value + "";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, "value" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === "select-one",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn\'t update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don\'t return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, "optgroup" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don\'t need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ "radio", "checkbox" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( "value" ) === null ? "on" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, "type" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don\'t do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we\'re not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( "." ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( "." );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( ":" ) < 0 && "on" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === "object" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( "." );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, "handle" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don\'t do default actions on window, that\'s where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don\'t re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\njQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +\n\t"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +\n\t"change select submit keydown keypress keyup contextmenu" ).split( " " ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\nsupport.focusin = "onfocusin" in window;\n\n\n// Support: Firefox <=44\n// Firefox doesn\'t have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = jQuery.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== "string" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {\n\t\tjQuery.error( "Invalid XML: " + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && jQuery.type( obj ) === "object" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = jQuery.isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + "=" +\n\t\t\t\tencodeURIComponent( value == null ? "" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the "old" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( "&" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for "elements" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, "elements" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( ":disabled" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( ":disabled" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol "*" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to "*" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol "*" can be used\n\t * 3) selection will start with transport dataType and THEN go to "*" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = "*/".concat( "*" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( "a" );\n\toriginAnchor.href = location.href;\n\n// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to "*"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== "string" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = "*";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === "+" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || "*";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === "string" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );\n}\n\n// A special extend for ajax options\n// that takes "flat" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === "*" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );\n\t\t}\n\t}\n\n\t// Check if we\'re dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There\'s only work to do if current dataType is non-auto\n\t\t\tif ( current === "*" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== "*" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + " " + current ] || converters[ "* " + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( " " );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + " " + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ "* " + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: "parsererror",\n\t\t\t\t\t\t\t\terror: conv ? e : "No conversion from " + prev + " to " + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: "success", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: "GET",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: "application/x-www-form-urlencoded; charset=UTF-8",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t"*": allTypes,\n\t\t\ttext: "text/plain",\n\t\t\thtml: "text/html",\n\t\t\txml: "application/xml, text/xml",\n\t\t\tjson: "application/json, text/javascript"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: "responseXML",\n\t\t\ttext: "responseText",\n\t\t\tjson: "responseJSON"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall "*") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t"* text": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t"text html": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t"text json": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t"text xml": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn\'t be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn\'t be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === "object" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( "once memory" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = "canceled",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + "" )\n\t\t\t.replace( rprotocol, location.protocol + "//" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];\n\n\t\t// A cross-domain request is in order when the origin doesn\'t match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( "a" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 13\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor\'s host property isn\'t correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + "//" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== "string" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don\'t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( "ajaxStart" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we\'re toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, "" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it\'s not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, "$1" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change \'%20\' to \'+\' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, "+" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( "Content-Type", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t"Accept",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :\n\t\t\t\ts.accepts[ "*" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = "abort";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, "No Transport" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( "timeout" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || "";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( "Last-Modified" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( "etag" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === "HEAD" ) {\n\t\t\t\t\tstatusText = "nocontent";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = "notmodified";\n\n\t\t\t\t// If we have data, let\'s convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = "error";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + "";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( "ajaxStop" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, "json" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, "script" );\n\t}\n} );\n\njQuery.each( [ "get", "post" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: "GET",\n\t\tdataType: "script",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t"throws": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( "body" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won\'t change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {\n\t\t\t\t\theaders[ "X-Requested-With" ] = "XMLHttpRequest";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === "abort" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === "error" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== "number" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, "error" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || "text" ) !== "text"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== "string" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = callback( "error" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( "abort" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn\'t been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: "text/javascript, application/javascript, " +\n\t\t\t"application/ecmascript, application/x-ecmascript"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t"text script": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache\'s special case and crossDomain\njQuery.ajaxPrefilter( "script", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = "GET";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( "script", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( "<script>" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t"load error",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === "error" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: "callback",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t"url" :\n\t\t\ttypeof s.data === "string" &&\n\t\t\t\t( s.contentType || "" )\n\t\t\t\t\t.indexOf( "application/x-www-form-urlencoded" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && "data"\n\t\t);\n\n\t// Handle iff the expected data type is "jsonp" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ "script json" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + " was not called" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = "json";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn\'t exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn\'t screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn "script";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( "" ).body;\n\tbody.innerHTML = "<form></form><form></form>";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument "data" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== "string" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === "boolean" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( "" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document\'s URL (gh-2965)\n\t\t\tbase = context.createElement( "base" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( " " );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it\'s a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it\'s the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === "object" ) {\n\t\ttype = "POST";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If "type" variable is undefined, then "GET" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || "GET",\n\t\t\tdataType: "html",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE \'Permission Denied\' errors\n\t\t\t\tjQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets "data", "status", "jqXHR"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets "jqXHR", "status", "error"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t"ajaxStart",\n\t"ajaxStop",\n\t"ajaxComplete",\n\t"ajaxError",\n\t"ajaxSuccess",\n\t"ajaxSend"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, "position" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === "static" ) {\n\t\t\telem.style.position = "relative";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, "top" );\n\t\tcurCSSLeft = jQuery.css( elem, "left" );\n\t\tcalculatePosition = ( position === "absolute" || position === "fixed" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( "using" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar doc, docElem, rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\trect = elem.getBoundingClientRect();\n\n\t\tdoc = elem.ownerDocument;\n\t\tdocElem = doc.documentElement;\n\t\twin = doc.defaultView;\n\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset - docElem.clientTop,\n\t\t\tleft: rect.left + win.pageXOffset - docElem.clientLeft\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t// because it is its only offset parent\n\t\tif ( jQuery.css( elem, "position" ) === "fixed" ) {\n\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !nodeName( offsetParent[ 0 ], "html" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset = {\n\t\t\t\ttop: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),\n\t\t\t\tleft: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )\n\t\t\t};\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {\n\tvar top = "pageYOffset" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ "top", "left" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + "px" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: "height", Width: "width" }, function( name, type ) {\n\tjQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( "outer" ) === 0 ?\n\t\t\t\t\t\telem[ "inner" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ "client" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ "scroll" + name ], doc[ "scroll" + name ],\n\t\t\t\t\t\telem.body[ "offset" + name ], doc[ "offset" + name ],\n\t\t\t\t\t\tdoc[ "client" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, "**" ) :\n\t\t\tthis.off( types, selector || "**", fn );\n\t}\n} );\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\treturn jQuery;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pRdWVyeS9kaXN0L2pxdWVyeS5qcz85NjZjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsZ0JBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVEsNkJBQTZCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlEQUFpRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBLENBQUM7Ozs7QUFJRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxRQUFRLEdBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLDBCQUEwQix3QkFBd0I7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxzQ0FBc0M7QUFDOUUsb0NBQW9DLHVDQUF1QztBQUMzRSxvQ0FBb0Msc0NBQXNDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBOztBQUVBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGNBQWM7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBdUQ7QUFDOUU7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSwrQkFBK0I7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxxQ0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDhCQUE4QjtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxXQUFXO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQixzQkFBc0IsY0FBYztBQUNwQyxnQkFBZ0IsV0FBVyxZQUFZO0FBQ3ZDLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxVQUFVLFNBQVMsTUFBTSxhQUFhO0FBQzNFLGFBQWEsZUFBZTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBLFFBQVEsT0FBTzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUEsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlEQUFpRCwwQkFBMEI7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQXFDOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQiw0REFBNEQsZUFBZTtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUFBO0FBQ0Y7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBLENBQUMiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMi4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNy0wMy0yMFQxODo1OVpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cblxuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIGRvYyApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuMi4xXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZyxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgQXJyYXkuaXNBcnJheSggc3JjICkgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdFx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHRcdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdFx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNjEyNVxuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHRET01FdmFsKCBjb2RlICk7XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDEzXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXG5cdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuM1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDgtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0ZGlzYWJsZWRBbmNlc3RvciA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiAoXCJmb3JtXCIgaW4gZWxlbSB8fCBcImxhYmVsXCIgaW4gZWxlbSk7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gXCIjXCIgKyBuaWQgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRkaXNhYmxlZEFuY2VzdG9yKCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdGlmICggcHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxuXHRcdChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2Vcblx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbXNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFjb21waWxlckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59O1xudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG52YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW1wbGUgc2VsZWN0b3IgdGhhdCBjYW4gYmUgZmlsdGVyZWQgZGlyZWN0bHksIHJlbW92aW5nIG5vbi1FbGVtZW50c1xuXHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdH1cblxuXHQvLyBDb21wbGV4IHNlbGVjdG9yLCBjb21wYXJlIHRoZSB0d28gc2V0cywgcmVtb3Zpbmcgbm9uLUVsZW1lbnRzXG5cdHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMgKTtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdCAmJiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcImlmcmFtZVwiICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcbiAgICAgICAgLy8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgaXQuXG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIGpRdWVyeS50eXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXG5cdFx0XHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0bWFzdGVyLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCxcblx0XHRcdFx0IXJlbWFpbmluZyApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGpRdWVyeS5jYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBqUXVlcnkuY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgalF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBqUXVlcnkuY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsXG5cdFx0c2NhbGUgPSAxLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSspL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xufSApKCk7XG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHR2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBqUXVlcnkuaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgbm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXG5cdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuXHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdGlmICggYnV0dG9uICYgMSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgMiApIHtcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgNCApIHtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC53aGljaDtcblx0fVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggXCI+dGJvZHlcIiwgZWxlbSApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcblxuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybWFyZ2luID0gKCAvXm1hcmdpbi8gKTtcblxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwiYm94LXNpemluZzpib3JkZXItYm94O1wiICtcblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ0b3A6MSU7d2lkdGg6NTAlXCI7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gZGl2U3R5bGUubWFyZ2luTGVmdCA9PT0gXCIycHhcIjtcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IGRpdlN0eWxlLndpZHRoID09PSBcIjRweFwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IFwiNTAlXCI7XG5cdFx0cGl4ZWxNYXJnaW5SaWdodFZhbCA9IGRpdlN0eWxlLm1hcmdpblJpZ2h0ID09PSBcIjRweFwiO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsTWFyZ2luUmlnaHQoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcm1hcmdpbi50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcHJvcGVydHkgbWFwcGVkIGFsb25nIHdoYXQgalF1ZXJ5LmNzc1Byb3BzIHN1Z2dlc3RzIG9yIHRvXG4vLyBhIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eS5cbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciByZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXTtcblx0aWYgKCAhcmV0ICkge1xuXHRcdHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xuXHR9XG5cdHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcblx0dmFyIGksXG5cdFx0dmFsID0gMDtcblxuXHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cblx0aWYgKCBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdGkgPSA0O1xuXG5cdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0fSBlbHNlIHtcblx0XHRpID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gMSA6IDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG5cdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHR2YXIgdmFsdWVJc0JvcmRlckJveCxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApLFxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiZcblx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9IZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdGlmICggdmFsID09PSBcImF1dG9cIiApIHtcblx0XHR2YWwgPSBlbGVtWyBcIm9mZnNldFwiICsgbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICkgXTtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXHRcdFwiZmxvYXRcIjogXCJjc3NGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhICYmIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxM1xuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRqUXVlcnkucHJveHkoIHJlc3VsdC5zdG9wLCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmZyYXN0cnVjdHVyZS5odG1sI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICkge1xuXHRcdFx0Y2xhc3NlcyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC87XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0galF1ZXJ5Lm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDEzXG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApLnByb3AoIHtcblx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHR9ICkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgZG9jLCBkb2NFbGVtLCByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdHdpbiA9IGRvYy5kZWZhdWx0VmlldztcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXQgLSBkb2NFbGVtLmNsaWVudExlZnRcblx0XHR9O1xuXHR9LFxuXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LFxuXHRcdC8vIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyB0aGVyZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcblx0XHRcdG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7XG5cblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cdFx0XHRpZiAoICFub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7XG5cdFx0XHRcdHRvcDogcGFyZW50T2Zmc2V0LnRvcCArIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKSxcblx0XHRcdFx0bGVmdDogcGFyZW50T2Zmc2V0LmxlZnQgKyBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34valF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n')},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(8);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(1)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!./bootstrap-editable.css\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!./bootstrap-editable.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC1lZGl0YWJsZS5jc3M/ZTIzZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYm9vdHN0cmFwLWVkaXRhYmxlLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ib290c3RyYXAtZWRpdGFibGUuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC1lZGl0YWJsZS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2VkaXRhYmxlL2Nzcy9ib290c3RyYXAtZWRpdGFibGUuY3NzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(9);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(1)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!./bootstrap-wysihtml5.css\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!./bootstrap-wysihtml5.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzPzM2MDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9lZGl0YWJsZS9jc3MvYm9vdHN0cmFwLXd5c2lodG1sNS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n")},function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(10);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(1)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!./bootstrap.min.css\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!./bootstrap.min.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC5taW4uY3NzPzIwNTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC5taW4uY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC5taW4uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC5taW4uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9lZGl0YWJsZS9jc3MvYm9vdHN0cmFwLm1pbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n")},function(module,exports){eval('\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function "fixes" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== "undefined" && window.location;\n\n  if (!location) {\n    throw new Error("fixUrls requires window.location");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== "string") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + "//" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, "/");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word "url" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn\'t a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn\'t a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn\'t a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^"(.*)"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^\'(.*)\'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf("//") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf("/") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with \'/\'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, ""); // Strip leading \'./\'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn "url(" + JSON.stringify(newUrl) + ")";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9saWIvdXJscy5qcz85YzMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxFQUFFO0FBQ3JELHdDQUF3QyxXQUFXLEVBQUU7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDO0FBQ3RDLEdBQUc7QUFDSDtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n')},function(module,exports){eval("/* globals __VUE_SSR_CONTEXT__ */\n\n// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzP2Q0ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gdGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICB2YXIgZnVuY3Rpb25hbCA9IG9wdGlvbnMuZnVuY3Rpb25hbFxuICAgIHZhciBleGlzdGluZyA9IGZ1bmN0aW9uYWxcbiAgICAgID8gb3B0aW9ucy5yZW5kZXJcbiAgICAgIDogb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICBpZiAoIWZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBleGlzdGluZyhoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n")},function(module,exports){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'a\', {\n    attrs: {\n      "href": "javascript:;",\n      "data-type": _vm.type,\n      "disabled": _vm.disabled,\n      "emptytext": _vm.emptytext\n    }\n  }, [_vm._v(_vm._s(_vm.value))])\n},staticRenderFns: []}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRWRpdGFibGUudnVlP2ZiNzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2EnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaHJlZlwiOiBcImphdmFzY3JpcHQ6O1wiLFxuICAgICAgXCJkYXRhLXR5cGVcIjogX3ZtLnR5cGUsXG4gICAgICBcImRpc2FibGVkXCI6IF92bS5kaXNhYmxlZCxcbiAgICAgIFwiZW1wdHl0ZXh0XCI6IF92bS5lbXB0eXRleHRcbiAgICB9XG4gIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS52YWx1ZSkpXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00MDliNDgxNlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9zcmMvRWRpdGFibGUudnVlXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n')}]);